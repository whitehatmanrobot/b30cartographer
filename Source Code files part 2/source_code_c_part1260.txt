   }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsTypedName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CTypedName::AllocateTypedNameObject(
    CTypedName ** ppTypedName
    )
{
    CTypedName FAR * pTypedName = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pTypedName = new CTypedName();
    if (pTypedName == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsTypedName,
                (IADsTypedName *)pTypedName,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pTypedName->_pDispMgr = pDispMgr;
    *ppTypedName = pTypedName;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CTypedName::get_Interval(THIS_ long FAR * retval)
{
    *retval = _dwInterval;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::put_Interval(THIS_ long lnInterval)
{
    _dwInterval = lnInterval;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::get_Level(THIS_ long FAR * retval)
{
    *retval = _dwLevel;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::put_Level(THIS_ long lnLevel)
{
    _dwLevel = lnLevel;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CTypedName::put_ObjectName(THIS_ BSTR bstrObjectName)
{

    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}


DEFINE_IDispatch_Implementation(CHold)

CHold::CHold():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwAmount(0)
{
    ENLIST_TRACKING(CHold);
}


HRESULT
CHold::CreateHold(
    REFIID riid,
    void **ppvObj
    )
{
    CHold FAR * pHold = NULL;
    HRESULT hr = S_OK;

    hr = AllocateHoldObject(&pHold);
    BAIL_ON_FAILURE(hr);

    hr = pHold->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pHold->Release();

    RRETURN(hr);

error:
    delete pHold;

    RRETURN(hr);

}


CHold::~CHold( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CHold::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsHold))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CHold::AllocateHoldObject(
    CHold ** ppHold
    )
{
    CHold FAR * pHold = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pHold = new CHold();
    if (pHold == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsHold,
                (IADsHold *)pHold,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pHold->_pDispMgr = pDispMgr;
    *ppHold = pHold;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CHold::get_Amount(THIS_ long FAR * retval)
{
    *retval = _dwAmount;
    RRETURN(S_OK);
}

STDMETHODIMP
CHold::put_Amount(THIS_ long lnAmount)
{
    _dwAmount = lnAmount;
    RRETURN(S_OK);
}


STDMETHODIMP
CHold::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CHold::put_ObjectName(THIS_ BSTR bstrObjectName)
{
    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNDSEnumVariant::Create
//             CNDSEnumVariant::CNDSEnumVariant
//             CNDSEnumVariant::~CNDSEnumVariant
//             CNDSEnumVariant::QueryInterface
//             CNDSEnumVariant::AddRef
//             CNDSEnumVariant::Release
//             CNDSEnumVariant::Next
//             CNDSEnumVariant::Skip
//             CNDSEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::CNDSEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSEnumVariant::CNDSEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::~CNDSEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSEnumVariant::~CNDSEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNDSEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNDSEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cgenobj.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomain.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSGenObject

DEFINE_IDispatch_Implementation(CNDSGenObject)
DEFINE_IADs_Implementation(CNDSGenObject)


CNDSGenObject::CNDSGenObject():
                _pPropertyCache(NULL)
{

    _pOuterUnknown = NULL;
    _hADsContext = NULL;
    _pszNDSTreeName = _pszNDSDn = NULL;

    VariantInit(&_vFilter);

    InitSearchPrefs();

    ENLIST_TRACKING(CNDSGenObject);
}

HRESULT
CNDSGenObject::CreateGenericObject(
    BSTR bstrADsPath,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                szADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CNDSGenObject::CreateGenericObject(
                 szADsParent,
                 szCommonName,
                 ClassName,
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );
    RRETURN(hr);
}


HRESULT
CNDSGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGenObject FAR * pGenObject = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGenObject(Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_NDSGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                pGenObject->_ADsPath,
                &(pGenObject->_pszNDSTreeName),
                &(pGenObject->_pszNDSDn)
                );
    BAIL_ON_FAILURE(hr);

    hr  = ADsNdsOpenContext(
               pGenObject->_pszNDSTreeName,
               Credentials,
               &(pGenObject->_hADsContext)
               );
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGenObject->Release();

    RRETURN(hr);

error:

    delete pGenObject;
    RRETURN(hr);
}

CNDSGenObject::~CNDSGenObject( )
{
    VariantClear(&_vFilter);

    delete _pDispMgr;

    delete _pPropertyCache;

    if (_hADsContext) {
        ADsNdsCloseContext(_hADsContext);
    }

    if (_pszNDSTreeName) {
        FreeADsMem(_pszNDSTreeName);
    }

    if (_pszNDSDn) {
        FreeADsMem(_pszNDSDn);
    }

}

STDMETHODIMP
CNDSGenObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSGenObject::SetInfo()
{
    DWORD dwStatus = 0L;
    WCHAR szNDSPathName[MAX_PATH];
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = NDSCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = NDSSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
CNDSGenObject::NDSSetObject()
{
    NDS_BUFFER_HANDLE hOperationData = NULL;
    HRESULT hr = S_OK;

    hr = ADsNdsCreateBuffer(
                        _hADsContext,
                        DSV_MODIFY_ENTRY,
                        &hOperationData
                        );
    BAIL_ON_FAILURE(hr);

    hr = _pPropertyCache->NDSMarshallProperties(
                            _hADsContext,
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsModifyObject(
                    _hADsContext,
                    _pszNDSDn,
                    hOperationData
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (hOperationData) {

        ADsNdsFreeBuffer(hOperationData);
    }

    RRETURN(hr);
}

HRESULT
CNDSGenObject::NDSCreateObject()
{
    NDS_BUFFER_HANDLE hOperationData = NULL;
    HRESULT hr = S_OK;
    BOOLEAN fUserObject = FALSE;
    BSTR bstrClass = NULL;

    hr = ADsNdsCreateBuffer(
                        _hADsContext,
                        DSV_ADD_ENTRY,
                        &hOperationData
                        );
    BAIL_ON_FAILURE(hr);

    hr = get_CoreADsClass(&bstrClass);
    if (SUCCEEDED(hr)) {
        if (_wcsicmp(bstrClass, L"user") == 0) {
            fUserObject = TRUE;
        }
    }

    hr = _pPropertyCache->NDSMarshallProperties(
                            _hADsContext,
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsAddObject(
                    _hADsContext,
                    _pszNDSDn,
                    hOperationData
                    );
    BAIL_ON_FAILURE(hr);

    //
    // If it is a user object, we'll set the initial password to 'NULL'
    //
    if (fUserObject) {
        hr = ADsNdsGenObjectKey(_hADsContext,
                                _pszNDSDn);     
        BAIL_ON_FAILURE(hr);
    }

error:
    if (bstrClass) {
        ADsFreeString(bstrClass);
    }

    if (hOperationData) {

        ADsNdsFreeBuffer(hOperationData);
    }

    RRETURN(hr);
}

HRESULT
CNDSGenObject::GetInfo()
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(TRUE));
}

HRESULT
CNDSGenObject::GetInfo(
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    PNDS_ATTR_INFO lpEntries = NULL;
    DWORD dwNumEntries = 0, i = 0;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsNdsReadObject(
                _hADsContext,
                _pszNDSDn,
                DS_ATTRIBUTE_VALUES,
                NULL,
                (DWORD) -1, // signifies all attributes need to be returned
                NULL,
                &lpEntries,
                &dwNumEntries
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwNumEntries; i++) {

        //
        // unmarshall this property into the
        // property cache
        //
        //

        hr = _pPropertyCache->unmarshallproperty(
                    lpEntries[i].szAttributeName,
                    lpEntries[i].lpValue,
                    lpEntries[i].dwNumberOfValues,
                    lpEntries[i].dwSyntaxId,
                    fExplicit
                    );

        CONTINUE_ON_FAILURE(hr);

    }


error:

    if (_pPropertyCache) {
       Reset();
    }

    FreeNdsAttrInfo( lpEntries, dwNumEntries );

    RRETURN(hr);
}


STDMETHODIMP
CNDSGenObject::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;
    VARIANT *vVarArray = NULL;
    DWORD dwNumVariants = 0;
    PNDS_ATTR_INFO lpEntries = NULL;
    DWORD dwNumEntries = 0, i = 0;
    LPWSTR *ppszStrArray = NULL;


    UNREFERENCED_PARAMETER(lnReserved);

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSafeArrayToVariantArray(
            vProperties,
            &vVarArray,
            &dwNumVariants
            );
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantArrayToStringArray(
             vVarArray,
             &ppszStrArray,
             dwNumVariants
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsReadObject(
                _hADsContext,
                _pszNDSDn,
                DS_ATTRIBUTE_VALUES,
                ppszStrArray,
                dwNumVariants,
                NULL,
                &lpEntries,
                &dwNumEntries
                );
    BAIL_ON_FAILURE(hr);


    for (i = 0; i < dwNumEntries; i++) {

        //
        // unmarshall this property into the
        // property cache
        //

        // The TRUE is "fExplicit" -- we want to make sure that any
        // properties we get back from the server get updated in the
        // property cache.
        //

        hr = _pPropertyCache->unmarshallproperty(
                    lpEntries[i].szAttributeName,
                    lpEntries[i].lpValue,
                    lpEntries[i].dwNumberOfValues,
                    lpEntries[i].dwSyntaxId,
                    TRUE
                    );

        CONTINUE_ON_FAILURE(hr);

    }

error:

    if (ppszStrArray) {
        for (DWORD i=0; i < dwNumVariants; i++) {
            FreeADsStr(ppszStrArray[i]);
        }
        FreeADsMem(ppszStrArray);
    }

    if (vVarArray)
    {
        DWORD i = 0;

        for (i = 0; i < dwNumVariants; i++) {
            VariantClear(vVarArray + i);
        }
        FreeADsMem(vVarArray);
    }

    FreeNdsAttrInfo( lpEntries, dwNumEntries );

    RRETURN(hr);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSGenObject::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSGenObject::get_Filter(THIS_ VARIANT FAR* pVar)
{
    VariantInit(pVar);
    RRETURN(VariantCopy(pVar, &_vFilter));
}

STDMETHODIMP
CNDSGenObject::put_Filter(THIS_ VARIANT Var)
{
    VariantClear(&_vFilter);
    RRETURN(VariantCopy(&_vFilter, &Var));
}

STDMETHODIMP
CNDSGenObject::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CNDSGenObject::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSGenObject::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                    _ADsPath,
                    ClassName,
                    RelativeName,
                    _Credentials,
                    ppObject,
                    FALSE
                    );
    RRETURN(hr);

}

STDMETHODIMP
CNDSGenObject::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSGenObjectEnum::Create(
                (CNDSGenObjectEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSGenObject::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs * pADs  = NULL;
    VARIANT var;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwSyntaxId = 0;
    VARIANT vNewValue;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //


    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    VariantInit(&vNewValue);
    V_BSTR(&vNewValue) = ClassName;
    V_VT(&vNewValue) =  VT_BSTR;

    hr = pADs->Put(L"Object Class", vNewValue);
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppObject
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
        BAIL_ON_FAILURE(hr);
    }

error:

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSGenObject::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = S_OK;
    BSTR bstrChildPath = NULL;
    LPWSTR pszNDSTreeName = NULL;
    LPWSTR pszChildNDSDn = NULL;

    LPWSTR ppszAttrs[] = {L"object Class"};
    PNDS_ATTR_INFO pAttrEntries = NULL;
    DWORD dwNumEntries = 0;
    LPWSTR pszObjectClassName = NULL;

    hr = BuildADsPath(
                _ADsPath,
                bstrRelativeName,
                &bstrChildPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                bstrChildPath,
                &pszNDSTreeName,
                &pszChildNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsReadObject(
                _hADsContext,
                pszChildNDSDn,
                DS_ATTRIBUTE_VALUES,
                ppszAttrs,
                1,
                NULL,
                &pAttrEntries,
                &dwNumEntries
                );
    BAIL_ON_FAILURE(hr);

    if (dwNumEntries != 1) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    pszObjectClassName = (pAttrEntries[0].lpValue) ?
                             pAttrEntries[0].lpValue[0].NdsValue.value_20.ClassName :
                              NULL;

    if (!pszObjectClassName) {
        BAIL_ON_FAILURE(E_FAIL);
    }

    if (_wcsicmp(pszObjectClassName, bstrClassName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsNdsRemoveObject(
             _hADsContext,
             pszChildNDSDn
             );
    BAIL_ON_FAILURE(hr);

error:

    if (bstrChildPath) {
        SysFreeString(bstrChildPath);
    }

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);

    }

    if (pszChildNDSDn) {
        FreeADsStr(pszChildNDSDn);

    }

    if (pAttrEntries) {
        FreeNdsAttrInfo(pAttrEntries, dwNumEntries);
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSGenObject::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;

    hr = CopyObject(
             _hADsContext,
             SourceName,
             _ADsPath,
             NewName,
             _Credentials,
             (void**)&pUnk
             );

    BAIL_ON_FAILURE(hr);

    hr = pUnk->QueryInterface(IID_IDispatch, (void **)ppObject);

error:

    if (pUnk) {
        pUnk->Release();
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSGenObject::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{

    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;

    hr = MoveObject(
             _hADsContext,
             SourceName,
             _ADsPath,
             NewName,
             _Credentials,
             (void**)&pUnk
             );

    BAIL_ON_FAILURE(hr);

    if (ppObject) {
        hr = pUnk->QueryInterface(IID_IDispatch, (void **)ppObject);
    }

error:

    if (pUnk) {
        pUnk->Release();
    }

    RRETURN(hr);
}


HRESULT
CNDSGenObject::AllocateGenObject(
    CCredentials& Credentials,
    CNDSGenObject ** ppGenObject
    )
{
    CNDSGenObject FAR * pGenObject = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CNDSGenObject();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pGenObject,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);



    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);



    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);



    pGenObject->_Credentials = Credentials;
    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSGenObject::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                FALSE
                );


    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSGenObject::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumValues = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;

    //
    // Issue: How do we handle multi-valued support
    //

    if ((V_VT(&vProp) &  VT_VARIANT) &&  V_ISARRAY(&vProp)) {

        hr  = ConvertSafeArrayToVariantArray(
                    vProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    } else if ((V_VT(&vProp) &  VT_VARIANT) &&  V_ISARRAY(&vProp) && V_ISBYREF(&vProp)) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    vProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else {

        dwNumValues = 1;
        pvProp = &vProp;
    }

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                _pszNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSGenObject::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                _pszNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);



    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pNdsDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
    case ADS_PROPERTY_APPEND:
    case ADS_PROPERTY_DELETE:

        if (lnControlCode == ADS_PROPERTY_UPDATE) {
            dwFlags = CACHE_PROPERTY_MODIFIED;
        }
        else if (lnControlCode == ADS_PROPERTY_APPEND) {
            dwFlags = CACHE_PROPERTY_APPENDED;
        }
        else {
            dwFlags = CACHE_PROPERTY_DELETED;
        }

        //
        // Now begin the rest of the processing
        //

        if ((V_VT(&vProp) &  VT_VARIANT) &&  V_ISARRAY(&vProp)) {

            hr  = ConvertSafeArrayToVariantArray(
                        vProp,
                        &pVarArray,
                        &dwNumValues
                        );
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else if ((V_VT(&vProp) &  VT_VARIANT) &&  V_ISARRAY(&vProp) && V_ISBYREF(&vProp)) {

            hr  = ConvertByRefSafeArrayToVariantArray(
                        vProp,
                        &pVarArray,
                        &dwNumValues
                        );
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        }else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // check if the variant maps to the syntax of this property
        //

        hr = VarTypeToNdsTypeCopyConstruct(
                        dwSyntaxId,
                        pvProp,
                        &dwNumValues,
                        &pNdsDestObjects
                        );
        BAIL_ON_FAILURE(hr);

        break;

    default:
       RRETURN(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //



    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSGenObject::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

void
CNDSGenObject::InitSearchPrefs()
{
    _SearchPref._dwSearchScope = DS_SEARCH_SUBTREE;
    _SearchPref._fDerefAliases = FALSE;
    _SearchPref._fAttrsOnly = FALSE;
    _SearchPref._fCacheResults = TRUE;

}

STDMETHODIMP
CNDSGenObject::get_PropertyCount(
    THIS_ long FAR *plCount
    )
{
    HRESULT hr = E_FAIL;

    if (_pPropertyCache) {
        hr = _pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }
    RRETURN(hr);

}


STDMETHODIMP
CNDSGenObject::Next(
    THIS_ VARIANT FAR *pVariant
    )
{

    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    PADSVALUE pAdsValues = NULL;

    if (!_pPropertyCache->index_valid())
    RRETURN(E_FAIL);

    VariantInit(&varData);



    hr = _pPropertyCache->unboundgetproperty(
                _pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = ConvertNdsValuesToVariant(
                _pPropertyCache->get_CurrentPropName(),
                pNdsSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);


    //
    // We're successful so far, now skip by 1
    //

    hr = Skip(1);

error:
   if (pNdsSrcObjects) {
      NdsTypeFreeNdsObjects(pNdsSrcObjects, dwNumValues);
   }

   RRETURN(hr);
}


STDMETHODIMP
CNDSGenObject::Skip(
    THIS_ long cElements
    )
{
   HRESULT hr = S_OK;

    hr = _pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN(hr);
}


STDMETHODIMP
CNDSGenObject::Reset(

    )
{
    _pPropertyCache->reset_propindex();

    RRETURN(S_OK);
}


STDMETHODIMP
CNDSGenObject::ResetPropertyItem(THIS_ VARIANT varEntry)
{
   HRESULT hr = S_OK;
   DWORD dwIndex = 0;

   switch (V_VT(&varEntry)) {

   case VT_BSTR:

       hr = _pPropertyCache->findproperty(
                           V_BSTR(&varEntry),
                           &dwIndex
                           );
       BAIL_ON_FAILURE(hr);
       break;

   case VT_I4:
       dwIndex = V_I4(&varEntry);
       break;


   case VT_I2:
       dwIndex = V_I2(&varEntry);
       break;


   default:
       hr = E_FAIL;
       BAIL_ON_FAILURE(hr);
   }

   hr = _pPropertyCache->deleteproperty(
                       dwIndex
                       );
error:
   RRETURN(hr);
}



STDMETHODIMP
CNDSGenObject::GetPropertyItem(
    THIS_ BSTR bstrName,
    LONG lnType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    PADSVALUE pAdsValues = NULL;


    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // translate the Nds objects to variants
    //

    hr = ConvertNdsValuesToVariant(
                bstrName,
                pNdsSrcObjects,
                dwNumValues,
                pVariant
                );

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSGenObject::PutPropertyItem(THIS_ VARIANT varData)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    WCHAR szPropertyName[MAX_PATH];
    DWORD dwControlCode = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvarData = NULL;

    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues = 0;

    DWORD dwSyntaxId2 = 0;
    DWORD dwNumNdsValues = 0;


    hr = ConvertVariantToNdsValues(
                varData,
                szPropertyName,
                &dwControlCode,
                &pNdsDestObjects,
                &dwNumValues,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);


    switch (dwControlCode) {

    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pNdsDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = CACHE_PROPERTY_MODIFIED;
        break;

    case ADS_PROPERTY_APPEND:
        dwFlags = CACHE_PROPERTY_APPENDED;
        break;


    case ADS_PROPERTY_DELETE:
        dwFlags = CACHE_PROPERTY_DELETED;
        break;

    default:
       RRETURN(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    szPropertyName,
                    dwFlags,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    DWORD ADsType,
    DWORD numValues,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(ADsType);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}

STDMETHODIMP
CNDSGenObject::Item(
    THIS_ VARIANT varIndex,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    PADSVALUE pAdsValues = NULL;
    LPWSTR szPropName = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    switch (V_VT(&varIndex)) {

    case VT_BSTR:

        //
        // retrieve data object from cache; if one exists
        //

        if (GetObjectState() == ADS_OBJECT_UNBOUND) {

            hr = _pPropertyCache->unboundgetproperty(
                        V_BSTR(&varIndex),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNdsSrcObjects
                        );
            BAIL_ON_FAILURE(hr);

        }else {

            hr = _pPropertyCache->getproperty(
                        V_BSTR(&varIndex),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNdsSrcObjects
                        );
            BAIL_ON_FAILURE(hr);
        }

        hr = ConvertNdsValuesToVariant(
                    V_BSTR(&varIndex),
                    pNdsSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I4:

        hr = _pPropertyCache->unboundgetproperty(
                    V_I4(&varIndex),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(V_I4(&varIndex));

        hr = ConvertNdsValuesToVariant(
                    szPropName,
                    pNdsSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I2:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(&varIndex),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(V_I2(&varIndex));

        hr = ConvertNdsValuesToVariant(
                    szPropName,
                    pNdsSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);

        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }


error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSGenObject::PurgePropertyList()
{
    _pPropertyCache->flushpropcache();
    RRETURN(S_OK);
}

HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    HRESULT hr = S_OK;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    if ((V_VT(&varData) & VT_VARIANT) &&  V_ISARRAY(&varData) && V_ISBYREF(&varData)){

        hr  = ConvertByRefSafeArrayToVariantArray(
                  varData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else if ((V_VT(&varData) &  VT_VARIANT) &&  V_ISARRAY(&varData)) {

        hr  = ConvertSafeArrayToVariantArray(
                  varData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else {
        pVarArray = NULL;
        dwNumValues = 0;
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}


HRESULT
ConvertVariantToNdsValues(
    VARIANT varData,
    LPWSTR szPropertyName,
    PDWORD pdwControlCode,
    PNDSOBJECT * ppNdsDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;

    PNDSOBJECT pNdsDestObjects = 0;
    DWORD dwNumNdsObjects = 0;
    DWORD dwNdsSyntaxId = 0;

    if (V_VT(&varData) != VT_DISPATCH) {
        RRETURN (hr = DISP_E_TYPEMISMATCH);
    }

    pDispatch = V_DISPATCH(&varData);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);

    VariantInit(&varValues);
    VariantClear(&varValues);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    wcscpy(szPropertyName, bstrPropName);

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);
    *pdwControlCode = dwControlCode;

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        hr = PropVariantToAdsType(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues
                    );
        BAIL_ON_FAILURE(hr);

        hr = AdsTypeToNdsTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    &pNdsDestObjects,
                    &dwNumNdsObjects,
                    &dwNdsSyntaxId
                    );
        BAIL_ON_FAILURE(hr);

    }

    *ppNdsDestObjects = pNdsDestObjects;
    *pdwNumValues = dwNumNdsObjects;
    *pdwSyntaxId = dwNdsSyntaxId;
cleanup:

    if (bstrPropName) {
        ADsFreeString(bstrPropName);
    }

    if (pAdsValues) {
        AdsFreeAdsValues(
                pAdsValues,
                dwNumValues
                );
        FreeADsMem( pAdsValues );
    }

    if (pVarArray) {

        FreeVariantArray(
                pVarArray,
                dwAdsValues
                );
    }

    if (pPropEntry) {

        pPropEntry->Release();
    }

    RRETURN(hr);

error:

    if (pNdsDestObjects) {

        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumNdsObjects
                );
    }

    *ppNdsDestObjects = NULL;
    *pdwNumValues = 0;

    goto cleanup;

}


HRESULT
ConvertNdsValuesToVariant(
    BSTR bstrPropName,
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumValues,
    PVARIANT pVarProp
    )
{
    HRESULT hr = S_OK;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumAdsValues = 0;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    DWORD dwADsType = 0;


    VariantInit(&varData);
    VariantInit(pVarProp);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToAdsTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                &pAdsValues
                );

    if (SUCCEEDED(hr)){
        hr = AdsTypeToPropVariant(
                    pAdsValues,
                    dwNumValues,
                    &varData
                    );
        if (SUCCEEDED(hr)) {
            dwADsType = pAdsValues->dwType;
        }else {
            VariantClear(&varData);
            hr = S_OK;
        }

    }else {
       VariantClear(&varData);
       VariantInit(&varData);
       hr = S_OK;
    }

    hr = CreatePropEntry(
            bstrPropName,
            dwADsType,
            dwNumValues,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);


    V_DISPATCH(pVarProp) = pDispatch;
    V_VT(pVarProp) = VT_DISPATCH;

    RRETURN(hr);

error:

    if (pAdsValues) {
       AdsFreeAdsValues(
            pAdsValues,
            dwNumValues
            );
       FreeADsMem( pAdsValues );
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamcf.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object Class Factory Code
//
//             CNDSNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CNDSNamespace::CreateNamespace(
                L"ADs:",
                L"NDS:",
                Credentials,
                ADS_OBJECT_BOUND,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aGroupPropMapping[] =
{
  { TEXT("Description"), TEXT("Description") },
};


//  Class CNDSGroup

DEFINE_IDispatch_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADs_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSGroup, aGroupPropMapping)

CNDSGroup::CNDSGroup():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSAttrMgmt(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSGroup);
}


HRESULT
CNDSGroup::CreateGroup(
    IADs * pADs,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGroup FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupObject(pADs, Credentials, &pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();

    RRETURN(hr);

error:
    delete pGroup;

    RRETURN(hr);

}


CNDSGroup::~CNDSGroup( )
{
    if (_pADs) {
        _pADs->Release();
    }

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSAttrMgmt) {
        _pDSAttrMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }

    delete _pDispMgr;
}

STDMETHODIMP
CNDSGroup::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSGroup::AllocateGroupObject(
    IADs *pADs,
    CCredentials& Credentials,
    CNDSGroup ** ppGroup
    )
{
    CNDSGroup FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSAttrMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;


    pGroup = new CNDSGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsGroup,
                (IADsGroup *)pGroup,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pGroup,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSAttrMgmt
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSAttrMgmt = pDSAttrMgmt;

    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pGroup->_pADs = pADs;
    pADs->AddRef();

    pGroup->_Credentials = Credentials;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:

    delete  pDispMgr;

    delete pGroup;

    *ppGroup = NULL;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "nds.hxx"

//  Class CNDSGroupCollection

DEFINE_IDispatch_Implementation(CNDSGroupCollection)


CNDSGroupCollection::CNDSGroupCollection():
        _ADsPath(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNDSGroupCollection);
}


HRESULT
CNDSGroupCollection::CreateGroupCollection(
    BSTR bstrADsPath,
    VARIANT varMembers,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(Credentials, &pGroup);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(bstrADsPath, &(pGroup->_ADsPath));
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&(pGroup->_vMembers), &varMembers);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN(hr);

}


CNDSGroupCollection::~CNDSGroupCollection( )
{
    VariantClear(&_vMembers);
    VariantClear(&_vFilter);
    delete _pDispMgr;
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
        _ADsPath = NULL;
    }
}

STDMETHODIMP
CNDSGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSGroupCollection::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSGroupCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    VariantInit(pVar);
    RRETURN(VariantCopy(pVar, &_vFilter));
}

STDMETHODIMP
CNDSGroupCollection::put_Filter(THIS_ VARIANT Var)
{
    VariantClear(&_vFilter);
    RRETURN(VariantCopy(&_vFilter, &Var));
}

STDMETHODIMP
CNDSGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *retval = NULL;

    hr = CNDSGroupCollectionEnum::Create(
                _ADsPath,
                _Credentials,
                (CNDSGroupCollectionEnum **)&penum,
                _vMembers
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}

HRESULT
CNDSGroupCollection::AllocateGroupCollectionObject(
    CCredentials& Credentials,
    CNDSGroupCollection ** ppGroup
    )
{
    CNDSGroupCollection FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CNDSGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pGroup,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pGroup->_Credentials = Credentials;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cmacro.h ===
#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IADsPutGet_Implementation(cls, ClassPropMapping)    \
STDMETHODIMP                                                                 \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Get( pszPropName, pvProp));                               \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                                 \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                    \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Put( pszPropName, vProp));                                \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                         \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->GetEx( pszPropName, pvProp));                             \
}                                                                            \
STDMETHODIMP                                                                 \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->PutEx( lnControlCode, pszPropName, vProp));               \
}

#define DEFINE_CONTAINED_IDirectoryObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_INFO *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    IDispatch * FAR* ppObject                                         \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        ppObject                                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IDirectorySearch_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetSearchPreference(                                             \
    PADS_SEARCHPREF_INFO pSearchPrefs,                                \
    DWORD   dwNumPrefs                                                \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->SetSearchPreference(                             \
                         pSearchPrefs,                                \
                         dwNumPrefs                                   \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ExecuteSearch(                                                   \
    LPWSTR pszSearchFilter,                                           \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_SEARCH_HANDLE phSearchResult                                 \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->ExecuteSearch(                                   \
                         pszSearchFilter,                             \
                         pAttributeNames,                             \
                         dwNumberAttributes,                          \
                         phSearchResult                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::AbandonSearch(                                                   \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->AbandonSearch(                                   \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetFirstRow(                                                     \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetFirstRow(                                     \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextRow(                                                      \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPreviousRow(                                                  \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetPreviousRow(                                  \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextColumnName(                                               \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR * ppszColumnName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextColumnName(                               \
                         hSearchResult,                               \
                         ppszColumnName                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetColumn(                                                       \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR szColumnName,                                              \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetColumn(                                       \
                         hSearchResult,                               \
                         szColumnName,                                \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::FreeColumn(                                                      \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->FreeColumn(                                      \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CloseSearchHandle(                                               \
    ADS_SEARCH_HANDLE hSearchResult                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->CloseSearchHandle(                               \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsPropertyList_Implementation(cls)         \
STDMETHODIMP                                                          \
cls::get_PropertyCount(THIS_ long  FAR * plCount)                     \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->get_PropertyCount(                            \
                    plCount                                           \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Next(THIS_ VARIANT FAR *pVariant)                                \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Next(                                         \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Skip(THIS_ long cElements)                                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Skip(                                         \
                    cElements                                         \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Reset()                                                          \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Reset(                                        \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ResetPropertyItem(THIS_ VARIANT varEntry)                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->ResetPropertyItem(                           \
                    varEntry                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetPropertyItem(THIS_ BSTR bstrName, LONG lnADsType, VARIANT * pVariant)      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->GetPropertyItem(                              \
                    bstrName,                                         \
                    lnADsType,                                        \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::PutPropertyItem(THIS_ VARIANT varData)                           \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->PutPropertyItem(                                          \
                varData                                                                   \
                );                                                                            \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::PurgePropertyList(THIS_)                                                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->PurgePropertyList();                          \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Item(                                         \
                    varIndex,                                         \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(cls)              \
STDMETHODIMP                                                          \
cls::EnumAttributes(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumAttributes,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumAttributes                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSAttrMgmt->EnumAttributes(                                \
              ppszAttrNames,                                          \
              dwNumAttributes,                                        \
              ppAttrDefinition,                                       \
              pdwNumAttributes                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateAttributeDefinition(                                       \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF pAttributeDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSAttrMgmt->CreateAttributeDefinition(                     \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteAttributeDefinition(                                        \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF  pAttributeDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSAttrMgmt->WriteAttributeDefinition(                      \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteAttributeDefinition(                                       \
    LPWSTR pszAttributeName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSAttrMgmt->DeleteAttributeDefinition(                     \
              pszAttributeName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::EnumClasses(                                                     \
    LPWSTR * ppszClassNames,                                          \
    DWORD dwNumClasses,                                               \
    PADS_CLASS_DEF * ppClassDefinition,                               \
    DWORD * pdwNumClasses                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSAttrMgmt->EnumClasses(                                   \
            ppszClassNames,                                           \
            dwNumClasses,                                             \
            ppClassDefinition,                                        \
            pdwNumClasses                                             \
            );                                                        \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateClassDefinition(                                           \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF pClassDefinition                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSAttrMgmt->CreateClassDefinition(                         \
            pszClassName,                                             \
            pClassDefinition                                          \
            );                                                        \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteClassDefinition(                                            \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF  pClassDefinition                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSAttrMgmt->WriteClassDefinition(                          \
            pszClassName,                                             \
            pClassDefinition                                          \
            );                                                        \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteClassDefinition(                                           \
    LPWSTR pszClassName                                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSAttrMgmt->DeleteClassDefinition(                         \
            pszClassName                                              \
            );                                                        \
                                                                      \
    RRETURN(hr);                                                      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
               IADsGroup and IADsGroupOperation methods
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );




//  Class CNDSGroup


STDMETHODIMP CNDSGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this,Description);
}

STDMETHODIMP CNDSGroup::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this,Description);
}


STDMETHODIMP
CNDSGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    VARIANT varProp;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    if (!ppMembers) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    VariantInit(&varProp);

    hr = _pADs->GetEx(L"Member", &varProp);

    //
    // Do not bail out on failure here if you could not find
    // any data set for the Members property. You need to
    // pass it all the way through and on enumeration
    // return nothing.
    //

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        SAFEARRAY *aList = NULL;

        VariantInit(&varProp);
    
        SAFEARRAYBOUND aBound;
    
        aBound.lLbound = 0;
        aBound.cElements = 0;
    
        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    
        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        V_VT(&varProp) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&varProp) = aList;
    }
    else {
        BAIL_ON_FAILURE(hr);
    }

    hr = _pADs->get_ADsPath(&bstrADsPath);

    hr = CNDSGroupCollection::CreateGroupCollection(
                    bstrADsPath,
                    varProp,
                    _Credentials,
                    IID_IADsMembers,
                    (void **)ppMembers
                    );

    BAIL_ON_FAILURE(hr);

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    VariantClear(&varProp);

    RRETURN(hr);
}




STDMETHODIMP
CNDSGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    if (!bstrMember) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if (!bMember) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
	//
	// If it has no members, we will return FALSE
	//
	if (hr == E_FAIL) {
		hr = S_OK;
		goto error;
	}

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );
        if (fMember) {

            fContinue = FALSE;
        }



        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE: VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN(hr);
}


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

        if (!_wcsicmp(bstrName, bstrMember)) {

            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}


STDMETHODIMP
CNDSGroup::Add(THIS_ BSTR bstrNewItem)
{
    HRESULT hr = S_OK;

    WCHAR szNDSUserPathName[MAX_PATH];
    WCHAR szNDSUserTreeName[MAX_PATH];
    IUnknown * pUnknown = NULL;
    IADs * pUser = NULL;

    WCHAR szNDSGroupPathName[MAX_PATH];
    WCHAR szNDSGroupTreeName[MAX_PATH];
    BSTR bstrPathName = NULL;

    hr = ::GetObject(
                bstrNewItem,
                _Credentials,
                (void **)&pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IADs, (void **)&pUser);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrNewItem,
                szNDSUserTreeName,
                szNDSUserPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath(&bstrPathName);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrPathName,
                szNDSGroupTreeName,
                szNDSGroupPathName
                );
    BAIL_ON_FAILURE(hr);


    hr = AddEntry(_pADs, L"Member",szNDSUserPathName);
    BAIL_ON_FAILURE(hr);

    // hr = AddEntry(_pADs, L"Equivalent To Me", szNDSUserPathName);
    // BAIL_ON_FAILURE(hr);

    hr = AddEntry(pUser, L"Group Membership", szNDSGroupPathName);
    BAIL_ON_FAILURE(hr);

error:

    if (bstrPathName) {
        ADsFreeString(bstrPathName);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pUser) {
        pUser->Release();
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSGroup::Remove(THIS_ BSTR bstrNewItem)
{
    HRESULT hr = S_OK;

    WCHAR szNDSUserPathName[MAX_PATH];
    WCHAR szNDSUserTreeName[MAX_PATH];
    IUnknown * pUnknown = NULL;
    IADs * pUser = NULL;

    WCHAR szNDSGroupPathName[MAX_PATH];
    WCHAR szNDSGroupTreeName[MAX_PATH];
    BSTR bstrPathName = NULL;

    hr = ::GetObject(
                bstrNewItem,
                _Credentials,
                (void **)&pUnknown
                );

    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IADs, (void **)&pUser);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrNewItem,
                szNDSUserTreeName,
                szNDSUserPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath(&bstrPathName);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrPathName,
                szNDSGroupTreeName,
                szNDSGroupPathName
                );
    BAIL_ON_FAILURE(hr);


    hr = RemoveEntry(_pADs, L"Member",szNDSUserPathName);
    BAIL_ON_FAILURE(hr);

    // hr = RemoveEntry(_pADs, L"Equivalent To Me", szNDSUserPathName);
    // BAIL_ON_FAILURE(hr);

    hr = RemoveEntry(pUser, L"Group Membership", szNDSGroupPathName);
    BAIL_ON_FAILURE(hr);

error:

    if (bstrPathName) {
        ADsFreeString(bstrPathName);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pUser) {
        pUser->Release();
    }

    RRETURN(hr);
}


HRESULT
AddEntry(
    IADs * pADs,
    LPWSTR pszAttribute,
    LPWSTR pszValue
    )
{

    HRESULT hr = S_OK;
    VARIANT vOldValue;
    VARIANT vNewValue;
    SAFEARRAY * pArray = NULL;

    VariantInit(&vOldValue);
    VariantInit(&vNewValue);

#if defined(BUILD_FOR_NT40)

    hr = pADs->Get(pszAttribute, &vOldValue);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {


        VariantInit(&vNewValue);
        V_BSTR(&vNewValue) = SysAllocString(pszValue);
        V_VT(&vNewValue) =  VT_BSTR;

        hr = pADs->Put(pszAttribute, vNewValue);
        BAIL_ON_FAILURE(hr);

    }else{

        hr = VarAddEntry(
                    pszValue,
                    vOldValue,
                    &vNewValue
                    );
        BAIL_ON_FAILURE(hr);

        hr = pADs->Put(pszAttribute, vNewValue);
        BAIL_ON_FAILURE(hr);
    }
#else

    //
    // NT5 supports appending values. So we don't need to read everything.
    // append ourselves and write everything
    //

    SAFEARRAYBOUND sabNewArray;
    int i;
    VARIANT v;

    sabNewArray.cElements = 1;
    sabNewArray.lLbound = 0;

    pArray = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    VariantInit(&v);

    V_BSTR(&v) = SysAllocString(pszValue);
    V_VT(&v) =  VT_BSTR;

    i = 0;
    hr = SafeArrayPutElement(
                pArray,
                (long *)&i,
                (void *)&v
                );

    VariantClear(&v);

    BAIL_ON_FAILURE(hr);

    V_VT(&vNewValue) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&vNewValue) = pArray;

    hr = pADs->PutEx(ADS_PROPERTY_APPEND, pszAttribute, vNewValue);
    BAIL_ON_FAILURE(hr);

#endif

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vOldValue);
    VariantClear(&vNewValue);

    RRETURN(hr);
}






HRESULT
RemoveEntry(
    IADs * pADs,
    LPWSTR pszAttribute,
    LPWSTR pszValue
    )
{
    HRESULT hr = S_OK;
    VARIANT vOldValue;
    VARIANT vNewValue;
    SAFEARRAY * pArray = NULL;

    VariantInit(&vOldValue);
    VariantInit(&vNewValue);

#if defined(BUILD_FOR_NT40)

    hr = pADs->Get(pszAttribute, &vOldValue);
    BAIL_ON_FAILURE(hr);

    hr = VarRemoveEntry(
                pszValue,
                vOldValue,
                &vNewValue
                );
    BAIL_ON_FAILURE(hr);


    if (V_VT(&vNewValue) == VT_EMPTY) {
        hr = pADs->PutEx(ADS_PROPERTY_CLEAR, pszAttribute, vNewValue);
    }else {
        hr = pADs->Put(pszAttribute, vNewValue);

    }
    BAIL_ON_FAILURE(hr);

#else

    SAFEARRAYBOUND sabNewArray;
    VARIANT  v;
    int i;

    //
    // NT5 supports deleting values. So we don't need to read everything.
    // delete ourselves and write everything - Very inefficient!
    //

    sabNewArray.cElements = 1;
    sabNewArray.lLbound = 0;

    pArray = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    VariantInit(&v);

    V_BSTR(&v) = SysAllocString(pszValue);
    V_VT(&v) =  VT_BSTR;

    i = 0;
    hr = SafeArrayPutElement(
                pArray,
                (long *)&i,
                (void *)&v
                );

    VariantClear(&v);

    BAIL_ON_FAILURE(hr);

    V_VT(&vNewValue) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&vNewValue) = pArray;

    hr = pADs->PutEx(ADS_PROPERTY_DELETE, pszAttribute, vNewValue);
    BAIL_ON_FAILURE(hr);

#endif

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vOldValue);
    VariantClear(&vNewValue);

    RRETURN(hr);
}


HRESULT
VarFindEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    if (!(V_VT(&varMembers) ==  (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&varMembers),
                                (long FAR *)&i,
                                &v
                                );

        if (!_wcsicmp(V_BSTR(&v), pszNDSPathName)) {
            VariantClear(&v);
            RRETURN(S_OK);
        }

        VariantClear(&v);
    }

error:

    RRETURN(E_FAIL);
}

HRESULT
VarMultipleAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);

    if (!(V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    sabNewArray.cElements = (dwSUBound - dwSLBound + 1) + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(&v);

        hr = SafeArrayGetElement(
                    V_ARRAY(&varMembers),
                    (long FAR *)&i,
                    &v
                    );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&i,
                (void *)&v
                );

        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pszNDSPathName);

    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&v
                );
    VariantClear(&v);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}

HRESULT
VarMultipleRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    DWORD dwNewCount = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);


    if(!(V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY))){
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    sabNewArray.cElements = (dwSUBound - dwSLBound);
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound, dwNewCount = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(
                    V_ARRAY(&varMembers),
                    (long FAR *)&i,
                    &v
                    );

        if (!_wcsicmp(V_BSTR(&v), pszNDSPathName)) {

            VariantClear(&v);
            //
            // skip this entry
            //
            continue;

        }
        hr = SafeArrayPutElement(
                pFilter,
                (long*)&dwNewCount,
                (void *)&v
                );

        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

        dwNewCount++;

    }

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);


error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}




HRESULT
VarSingleAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);

    if(!((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR)){
        return(E_FAIL);
    }

    sabNewArray.cElements = (1) + 1;
    sabNewArray.lLbound = 0;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    i = 0;
    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&varMembers
                );
    BAIL_ON_FAILURE(hr);

    i++;

    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pszNDSPathName);

    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&v
                );
    VariantClear(&v);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}



HRESULT
VarSingleRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    VariantInit(pvarNewMembers);

    if(!((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR)){
        return(E_FAIL);
    }

    V_VT(pvarNewMembers) = VT_EMPTY;
    V_BSTR(pvarNewMembers) = NULL;

    RRETURN(hr);
}


HRESULT
VarRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    if (V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY)) {

        hr = VarMultipleRemoveEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );
        RRETURN(hr);

    }else if (V_VT(&varMembers) == VT_BSTR){

        hr = VarSingleRemoveEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );

        RRETURN(hr);

    }else {

        RRETURN(E_FAIL);
    }
}


HRESULT
VarAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    if (V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY)){

        hr = VarMultipleAddEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );
        RRETURN(hr);

    }else if ((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR){

        hr = VarSingleAddEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );

        RRETURN(hr);

    }else {

        RRETURN(E_FAIL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\clocalty.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cLocality.cxx
//
//  Contents:  Locality object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aLocalityPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("SeeAlso"), TEXT("See Also") }
};

//  Class CNDSLocality

DEFINE_IDispatch_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADs_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSLocality, aLocalityPropMapping)


CNDSLocality::CNDSLocality():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSAttrMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSLocality);
}


HRESULT
CNDSLocality::CreateLocality(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSLocality FAR * pLocality = NULL;
    HRESULT hr = S_OK;

    hr = AllocateLocalityObject(pADs, &pLocality);
    BAIL_ON_FAILURE(hr);

    hr = pLocality->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pLocality->Release();

    RRETURN(hr);

error:
    delete pLocality;

    RRETURN(hr);

}


CNDSLocality::~CNDSLocality( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSAttrMgmt) {
        _pDSAttrMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }

    delete _pDispMgr;
}

STDMETHODIMP
CNDSLocality::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsLocality))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {

        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSLocality::AllocateLocalityObject(
    IADs *pADs,
    CNDSLocality ** ppLocality
    )
{
    CNDSLocality FAR * pLocality = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSAttrMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pLocality = new CNDSLocality();
    if (pLocality == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsLocality,
                (IADsLocality *)pLocality,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pLocality,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pADsPropList,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSAttrMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSAttrMgmt = pDSAttrMgmt;


    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pLocality->_pADs = pADs;
    pADs->AddRef();


    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pLocality->_pADsContainer = pADsContainer;


    pLocality->_pDispMgr = pDispMgr;
    *ppLocality = pLocality;

    RRETURN(hr);

error:

    delete  pDispMgr;

    delete  pLocality;

    *ppLocality = NULL;

    RRETURN(hr);

}


STDMETHODIMP CNDSLocality::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,Description);
}

STDMETHODIMP CNDSLocality::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,Description);
}



STDMETHODIMP CNDSLocality::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CNDSLocality::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CNDSLocality::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CNDSLocality::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CNDSLocality::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}

STDMETHODIMP CNDSLocality::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}




/* IADsContainer methods */

STDMETHODIMP
CNDSLocality::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSLocality::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSLocality::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSLocality::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN(hr);
}



STDMETHODIMP
CNDSLocality::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSLocality::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSLocality::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN(hr);
}


STDMETHODIMP
CNDSLocality::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSLocality::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSLocality::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSLocality::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        BSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
            _ADsPath,
            ClassName,
            &_Schema
            );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_Schema) {
        ADsFreeString(_Schema);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Name, retval));
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsPath, retval));

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsClass, retval));
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Parent, retval));
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);

    RRETURN(ADsAllocString(_Schema, retval));
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsGuid, retval));
}

STDMETHODIMP
CCoreADsObject::GetInfo(
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\corg.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cOrganization.cxx
//
//  Contents:  Organization object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aOrgPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("SeeAlso"), TEXT("See Also") }
};

//  Class CNDSOrganization

DEFINE_IDispatch_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADs_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSOrganization, aOrgPropMapping)


CNDSOrganization::CNDSOrganization():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSAttrMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSOrganization);
}


HRESULT
CNDSOrganization::CreateOrganization(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSOrganization FAR * pOrganization = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOrganizationObject(pADs, &pOrganization);
    BAIL_ON_FAILURE(hr);

    hr = pOrganization->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOrganization->Release();

    RRETURN(hr);

error:
    delete pOrganization;

    RRETURN(hr);

}


CNDSOrganization::~CNDSOrganization( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSAttrMgmt) {
        _pDSAttrMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }


    delete _pDispMgr;
}

STDMETHODIMP
CNDSOrganization::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsO))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList  FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSOrganization::AllocateOrganizationObject(
    IADs *pADs,
    CNDSOrganization ** ppOrganization
    )
{
    CNDSOrganization FAR * pOrganization = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSAttrMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pOrganization = new CNDSOrganization();
    if (pOrganization == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsO,
                (IADsO *)pOrganization,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pOrganization,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pOrganization,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSAttrMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSAttrMgmt = pDSAttrMgmt;

    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pOrganization->_pADs = pADs;
    pADs->AddRef();

    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pADsContainer = pADsContainer;


    pOrganization->_pDispMgr = pDispMgr;
    *ppOrganization = pOrganization;

    RRETURN(hr);

error:

    delete  pOrganization;

    *ppOrganization = NULL;

    RRETURN(hr);

}


STDMETHODIMP CNDSOrganization::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,Description);
}

STDMETHODIMP CNDSOrganization::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsO *)this,Description);
}



STDMETHODIMP CNDSOrganization::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,LocalityName);
}

STDMETHODIMP CNDSOrganization::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsO *)this,LocalityName);
}



STDMETHODIMP CNDSOrganization::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}

STDMETHODIMP CNDSOrganization::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}


STDMETHODIMP CNDSOrganization::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}

STDMETHODIMP CNDSOrganization::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}


STDMETHODIMP CNDSOrganization::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}

STDMETHODIMP CNDSOrganization::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}


STDMETHODIMP CNDSOrganization::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

STDMETHODIMP CNDSOrganization::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSOrganization::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganization::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganization::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganization::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN(hr);
}



STDMETHODIMP
CNDSOrganization::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganization::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganization::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN(hr);
}


STDMETHODIMP
CNDSOrganization::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN(hr);






    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganization::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganization::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganization::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\common.cxx ===
#include "nds.hxx"
#pragma hdrstop

FILTERS Filters[] = {
                    {L"user", NDS_USER_ID},
                    {L"group", NDS_GROUP_ID},
                    {L"queue", NDS_PRINTER_ID},
                    {L"domain", NDS_DOMAIN_ID},
                    {L"computer", NDS_COMPUTER_ID},
                    {L"service", NDS_SERVICE_ID},
                    {L"fileservice", NDS_FILESERVICE_ID},
                    {L"fileshare", NDS_FILESHARE_ID},
                    {L"class", NDS_CLASS_ID},
                    {L"functionalset", NDS_FUNCTIONALSET_ID},
                    {L"syntax", NDS_SYNTAX_ID},
                    {L"property", NDS_PROPERTY_ID},
                    {L"tree", NDS_TREE_ID},
                    {L"Organizational Unit", NDS_OU_ID},
                    {L"Organization", NDS_O_ID},
                    {L"Locality", NDS_LOCALITY_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;

struct _err_lookup_ {
    LPWSTR errString;
    int errNo;
} g_aErrLookup[] = {

    {L"ERR_INSUFFICIENT_MEMORY        ", -150 },
    {L"ERR_REQUEST_UNKNOWN            ", -251 },
    {L"ERR_OF_SOME_SORT               ", -255 },
    {L"ERR_NOT_ENOUGH_MEMORY          ", -301 },
    {L"ERR_BAD_KEY                    ", -302 },
    {L"ERR_BAD_CONTEXT                ", -303 },
    {L"ERR_BUFFER_FULL                ", -304 },
    {L"ERR_LIST_EMPTY                 ", -305 },
    {L"ERR_BAD_SYNTAX                 ", -306 },
    {L"ERR_BUFFER_EMPTY               ", -307 },
    {L"ERR_BAD_VERB                   ", -308 },
    {L"ERR_EXPECTED_IDENTIFIER        ", -309 },
    {L"ERR_EXPECTED_EQUALS            ", -310 },
    {L"ERR_ATTR_TYPE_EXPECTED         ", -311 },
    {L"ERR_ATTR_TYPE_NOT_EXPECTED     ", -312 },
    {L"ERR_FILTER_TREE_EMPTY          ", -313 },
    {L"ERR_INVALID_OBJECT_NAME        ", -314 },
    {L"ERR_EXPECTED_RDN_DELIMITER     ", -315 },
    {L"ERR_TOO_MANY_TOKENS            ", -316 },
    {L"ERR_INCONSISTENT_MULTIAVA      ", -317 },
    {L"ERR_COUNTRY_NAME_TOO_LONG      ", -318 },
    {L"ERR_SYSTEM_ERROR               ", -319 },
    {L"ERR_CANT_ADD_ROOT              ", -320 },
    {L"ERR_UNABLE_TO_ATTACH           ", -321 },
    {L"ERR_INVALID_HANDLE             ", -322 },
    {L"ERR_BUFFER_ZERO_LENGTH         ", -323 },
    {L"ERR_INVALID_REPLICA_TYPE       ", -324 },
    {L"ERR_INVALID_ATTR_SYNTAX        ", -325 },
    {L"ERR_INVALID_FILTER_SYNTAX      ", -326 },
    {L"ERR_CONTEXT_CREATION           ", -328 },
    {L"ERR_INVALID_UNION_TAG          ", -329 },
    {L"ERR_INVALID_SERVER_RESPONSE    ", -330 },
    {L"ERR_NULL_POINTER               ", -331 },
    {L"ERR_NO_SERVER_FOUND            ", -332 },
    {L"ERR_NO_CONNECTION              ", -333 },
    {L"ERR_RDN_TOO_LONG               ", -334 },
    {L"ERR_DUPLICATE_TYPE             ", -335 },
    {L"ERR_DATA_STORE_FAILURE         ", -336 },
    {L"ERR_NOT_LOGGED_IN              ", -337 },
    {L"ERR_INVALID_PASSWORD_CHARS     ", -338 },
    {L"ERR_FAILED_SERVER_AUTHENT      ", -339 },
    {L"ERR_TRANSPORT                  ", -340 },
    {L"ERR_NO_SUCH_SYNTAX             ", -341 },
    {L"ERR_INVALID_DS_NAME            ", -342 },
    {L"ERR_ATTR_NAME_TOO_LONG         ", -343 },
    {L"ERR_INVALID_TDS                ", -344 },
    {L"ERR_INVALID_DS_VERSION         ", -345 },
    {L"ERR_UNICODE_TRANSLATION        ", -346 },
    {L"ERR_SCHEMA_NAME_TOO_LONG       ", -347 },
    {L"ERR_UNICODE_FILE_NOT_FOUND     ", -348 },
    {L"ERR_UNICODE_ALREADY_LOADED     ", -349 },
    {L"ERR_NOT_CONTEXT_OWNER          ", -350 },
    {L"ERR_ATTEMPT_TO_AUTHENTICATE_0  ", -351 },
    {L"ERR_NO_WRITABLE_REPLICAS       ", -352 },
    {L"ERR_DN_TOO_LONG                ", -353 },
    {L"ERR_RENAME_NOT_ALLOWED         ", -354 },
    {L"ERR_NO_SUCH_ENTRY              ", -601 },
    {L"ERR_NO_SUCH_VALUE              ", -602 },
    {L"ERR_NO_SUCH_ATTRIBUTE          ", -603 },
    {L"ERR_NO_SUCH_CLASS              ", -604 },
    {L"ERR_NO_SUCH_PARTITION          ", -605 },
    {L"ERR_ENTRY_ALREADY_EXISTS       ", -606 },
    {L"ERR_NOT_EFFECTIVE_CLASS        ", -607 },
    {L"ERR_ILLEGAL_ATTRIBUTE          ", -608 },
    {L"ERR_MISSING_MANDATORY          ", -609 },
    {L"ERR_ILLEGAL_DS_NAME            ", -610 },
    {L"ERR_ILLEGAL_CONTAINMENT        ", -611 },
    {L"ERR_CANT_HAVE_MULTIPLE_VALUES  ", -612 },
    {L"ERR_SYNTAX_VIOLATION           ", -613 },
    {L"ERR_DUPLICATE_VALUE            ", -614 },
    {L"ERR_ATTRIBUTE_ALREADY_EXISTS   ", -615 },
    {L"ERR_MAXIMUM_ENTRIES_EXIST      ", -616 },
    {L"ERR_DATABASE_FORMAT            ", -617 },
    {L"ERR_INCONSISTENT_DATABASE      ", -618 },
    {L"ERR_INVALID_COMPARISON         ", -619 },
    {L"ERR_COMPARISON_FAILED          ", -620 },
    {L"ERR_TRANSACTIONS_DISABLED      ", -621 },
    {L"ERR_INVALID_TRANSPORT          ", -622 },
    {L"ERR_SYNTAX_INVALID_IN_NAME     ", -623 },
    {L"ERR_REPLICA_ALREADY_EXISTS     ", -624 },
    {L"ERR_TRANSPORT_FAILURE          ", -625 },
    {L"ERR_ALL_REFERRALS_FAILED       ", -626 },
    {L"ERR_CANT_REMOVE_NAMING_VALUE   ", -627 },
    {L"ERR_OBJECT_CLASS_VIOLATION     ", -628 },
    {L"ERR_ENTRY_IS_NOT_LEAF          ", -629 },
    {L"ERR_DIFFERENT_TREE             ", -630 },
    {L"ERR_ILLEGAL_REPLICA_TYPE       ", -631 },
    {L"ERR_SYSTEM_FAILURE             ", -632 },
    {L"ERR_INVALID_ENTRY_FOR_ROOT     ", -633 },
    {L"ERR_NO_REFERRALS               ", -634 },
    {L"ERR_REMOTE_FAILURE             ", -635 },
    {L"ERR_UNREACHABLE_SERVER         ", -636 },
    {L"ERR_PREVIOUS_MOVE_IN_PROGRESS  ", -637 },
    {L"ERR_NO_CHARACTER_MAPPING       ", -638 },
    {L"ERR_INCOMPLETE_AUTHENTICATION  ", -639 },
    {L"ERR_INVALID_CERTIFICATE        ", -640 },
    {L"ERR_INVALID_REQUEST            ", -641 },
    {L"ERR_INVALID_ITERATION          ", -642 },
    {L"ERR_SCHEMA_IS_NONREMOVABLE     ", -643 },
    {L"ERR_SCHEMA_IS_IN_USE           ", -644 },
    {L"ERR_CLASS_ALREADY_EXISTS       ", -645 },
    {L"ERR_BAD_NAMING_ATTRIBUTES      ", -646 },
    {L"ERR_NOT_ROOT_PARTITION         ", -647 },
    {L"ERR_INSUFFICIENT_STACK         ", -648 },
    {L"ERR_INSUFFICIENT_BUFFER        ", -649 },
    {L"ERR_AMBIGUOUS_CONTAINMENT      ", -650 },
    {L"ERR_AMBIGUOUS_NAMING           ", -651 },
    {L"ERR_DUPLICATE_MANDATORY        ", -652 },
    {L"ERR_DUPLICATE_OPTIONAL         ", -653 },
    {L"ERR_PARTITION_BUSY             ", -654 },
    {L"ERR_MULTIPLE_REPLICAS          ", -655 },
    {L"ERR_CRUCIAL_REPLICA            ", -656 },
    {L"ERR_SCHEMA_SYNC_IN_PROGRESS    ", -657 },
    {L"ERR_SKULK_IN_PROGRESS          ", -658 },
    {L"ERR_TIME_NOT_SYNCHRONIZED      ", -659 },
    {L"ERR_RECORD_IN_USE              ", -660 },
    {L"ERR_DS_VOLUME_NOT_MOUNTED      ", -661 },
    {L"ERR_DS_VOLUME_IO_FAILURE       ", -662 },
    {L"ERR_DS_LOCKED                  ", -663 },
    {L"ERR_OLD_EPOCH                  ", -664 },
    {L"ERR_NEW_EPOCH                  ", -665 },
    {L"ERR_INCOMPATIBLE_DS_VERSION    ", -666 },
    {L"ERR_PARTITION_ROOT             ", -667 },
    {L"ERR_ENTRY_NOT_CONTAINER        ", -668 },
    {L"ERR_FAILED_AUTHENTICATION      ", -669 },
    {L"ERR_INVALID_CONTEXT            ", -670 },
    {L"ERR_NO_SUCH_PARENT             ", -671 },
    {L"ERR_NO_ACCESS                  ", -672 },
    {L"ERR_REPLICA_NOT_ON             ", -673 },
    {L"ERR_INVALID_NAME_SERVICE       ", -674 },
    {L"ERR_INVALID_TASK               ", -675 },
    {L"ERR_INVALID_CONN_HANDLE        ", -676 },
    {L"ERR_INVALID_IDENTITY           ", -677 },
    {L"ERR_DUPLICATE_ACL              ", -678 },
    {L"ERR_PARTITION_ALREADY_EXISTS   ", -679 },
    {L"ERR_TRANSPORT_MODIFIED         ", -680 },
    {L"ERR_ALIAS_OF_AN_ALIAS          ", -681 },
    {L"ERR_AUDITING_FAILED            ", -682 },
    {L"ERR_INVALID_API_VERSION        ", -683 },
    {L"ERR_SECURE_NCP_VIOLATION       ", -684 },
    {L"ERR_MOVE_IN_PROGRESS           ", -685 },
    {L"ERR_NOT_LEAF_PARTITION         ", -686 },
    {L"ERR_CANNOT_ABORT               ", -687 },
    {L"ERR_CACHE_OVERFLOW             ", -688 },
    {L"ERR_INVALID_SUBORDINATE_COUNT  ", -689 },
    {L"ERR_INVALID_RDN                ", -690 },
    {L"ERR_MOD_TIME_NOT_CURRENT       ", -691 },
    {L"ERR_INCORRECT_BASE_CLASS       ", -692 },
    {L"ERR_MISSING_REFERENCE          ", -693 },
    {L"ERR_LOST_ENTRY                 ", -694 },
    {L"ERR_AGENT_ALREADY_REGISTERED   ", -695 },
    {L"ERR_DS_LOADER_BUSY             ", -696 },
    {L"ERR_DS_CANNOT_RELOAD           ", -697 },
    {L"ERR_REPLICA_IN_SKULK           ", -698 },
    {L"ERR_FATAL                      ", -699 },
    {L"ERR_OBSOLETE_API               ", -700 },
    {L"ERR_SYNCHRONIZATION_DISABLED   ", -701 },
    {L"ERR_INVALID_PARAMETER          ", -702 },
    {L"ERR_DUPLICATE_TEMPLATE         ", -703 },
    {L"ERR_NO_MASTER_REPLICA          ", -704 },
    {L"ERR_DUPLICATE_CONTAINMENT      ", -705 },
    {L"ERR_NOT_SIBLING                ", -706 },
    {L"ERR_INVALID_SIGNATURE          ", -707 },
    {L"ERR_INVALID_RESPONSE           ", -708 },
    {L"ERR_INSUFFICIENT_SOCKETS       ", -709 },
    {L"ERR_DATABASE_READ_FAIL         ", -710 },
    {L"ERR_INVALID_CODE_PAGE          ", -711 },
    {L"ERR_INVALID_ESCAPE_CHAR        ", -712 },
    {L"ERR_INVALID_DELIMITERS         ", -713 },
    {L"ERR_NOT_IMPLEMENTED            ", -714 },
    {L"ERR_CHECKSUM_FAILURE           ", -715 },
    {L"ERR_CHECKSUMMING_NOT_SUPPORTED ", -716 },
    {L"ERR_CRC_FAILURE                ", -717 }
};

DWORD g_cErrLookup = sizeof(g_aErrLookup)/sizeof(g_aErrLookup[0]);

//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------


HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    LPWSTR lpADsPath = NULL;
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwLen = 0;
    LPWSTR pszDisplayName = NULL;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);


    //
    // Get the display name for the name; The display name will have the proper
    // escaping for characters that have special meaning in an ADsPath like
    // '/' etc.
    //
    hr = GetDisplayName(
             Name,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        hr = ADsAllocString( pszDisplayName, pADsPath);
        BAIL_ON_FAILURE(hr);
        goto cleanup;
    }

    //
    // Allocate the right side buffer
    // 2 for // + a buffer of MAX_PATH
    //
    dwLen = wcslen(Parent) + wcslen(pszDisplayName) + 2 + MAX_PATH;

    lpADsPath = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));
    if (!lpADsPath) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"WinNT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(lpADsPath, Parent);

    if (_wcsicmp(lpADsPath, ProviderName)) {
        wcscat(lpADsPath, L"/");
    }else {
        wcscat(lpADsPath, L"//");
    }
    wcscat(lpADsPath, pszDisplayName);

    hr = ADsAllocString( lpADsPath, pADsPath);

cleanup:
error:

    if (lpADsPath) {
        FreeADsMem(lpADsPath);
    }

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR bstrADsPath,
    BSTR bstrClass,
    BSTR *pSchemaPath
    )
{
    WCHAR ADsSchema[MAX_PATH];
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(bstrADsPath);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    wcscpy(ADsSchema, L"");
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (bstrClass && *bstrClass) {
        hr = ADsObject(&Lexer, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        if (pObjectInfo->TreeName) {

            wsprintf(ADsSchema,L"%s://",pObjectInfo->ProviderName);
            wcscat(ADsSchema, pObjectInfo->TreeName);
            wcscat(ADsSchema,L"/schema/");
            wcscat(ADsSchema, bstrClass);

        }
    }

    hr = ADsAllocString( ADsSchema, pSchemaPath);

error:

    if (pObjectInfo) {

        FreeObjectInfo( pObjectInfo );
    }
    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }

    RRETURN(ADsAllocString( ADsClass, pADsClass));
}


HRESULT
MakeUncName(
    LPWSTR szSrcBuffer,
    LPWSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    wcscpy(szTargBuffer, L"\\\\");
    wcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}


PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData,
    WCHAR ch
    )
{
    BOOL        fQuoteMode = FALSE; // TRUE means we're processing between
                                    // quotation marks
    BOOL        fEscaped = FALSE;   // TRUE means next one char to be 
                                    // processed should be treated as literal
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR       pszTokenStart = NULL;
    LPWSTR      *ppToken;


    if (!psz || !*psz)
        return NULL;

    cTokens=1;

    // Scan through the string looking for delimiters,
    // ensuring that each is followed by a non-NULL character:
    
    // If this char follows an unescaped backslash:
    //      Treat as literal, treat next char regularly (set fEscaped = FALSE)
    // Else, if we're between quotation marks:
    //      If we see a quotation mark, leave quote mode
    //      Else, treat as literal
    // Else, if we're not between quote marks, and we see a quote mark:
    //      Enter quote mode
    // Else, if we see a backslash (and we're not already in escape or quote
    // mode:
    //      Treat next char as literal (set fEscaped = TRUE)
    // Else, if we see the delimiter, and the next char is non-NULL:
    //      *** Found end of a token --- Increment count of tokens ***
    // Else:
    //      Do nothing, just a plain old character
    // Go on to next character, and repeat
    //
    // Backslashes inside quotation marks are always treated as literals,
    // since that is the definition of being inside quotation marks

    while (*psz) {
        if (fEscaped) {
            fEscaped = FALSE;
        }
        else if (fQuoteMode) {
            if (*psz == L'"') {
                fQuoteMode = FALSE;
            }
            // else, do nothing, no delimiter since in quote mode
        }
        else if (*psz == L'"') {
            fQuoteMode = TRUE;
        }
        else if (*psz == L'\\') {
            fEscaped = TRUE;
        }
        else if ( (*psz == ch) && (*(psz+1))) {
            cTokens++;
        }
        // else, do nothing, just a regular character

        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +
         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocADsMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    // Then copy the key data buffer there:

    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;

    // Split into tokens at each delimiter be replacing the delimiter
    // with a NULL

    psz = pDest;
    pszTokenStart = pDest;
    fEscaped = FALSE;
    fQuoteMode = FALSE;

    while (*psz) {
        if (fEscaped) {
            fEscaped = FALSE;
        }
        else if (fQuoteMode) {
            if (*psz == L'"') {
                fQuoteMode = FALSE;
            }
            // else, do nothing, no delimiter since in quote mode
        }
        else if (*psz == L'"') {
            fQuoteMode = TRUE;
        }
        else if (*psz == L'\\') {
            fEscaped = TRUE;
        }
        else if ((*psz == ch) && (*(psz+1))) {
            *psz = '\0';
            *ppToken++ = pszTokenStart;
            pszTokenStart = psz + 1;
        }
        // else, do nothing, just a regular character

        psz++;
    }

    *ppToken = pszTokenStart;

    pResult->cTokens = cTokens;

    return( pResult );
}


HRESULT
NDSConvertDWORDtoDATE(
    DWORD dwDate,
    DATE * pdaDate
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    WORD wFatDate;
    WORD wFatTime;
    HRESULT hr = S_OK;

    ::RtlSecondsSince1970ToTime(dwDate, &tmpTime );

    fileTime.dwLowDateTime = tmpTime.LowPart;
    fileTime.dwHighDateTime = tmpTime.HighPart;

    if (!FileTimeToDosDateTime( &fileTime, &wFatDate, &wFatTime)){
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
    }

    if (!DosDateTimeToVariantTime(wFatDate, wFatTime, pdaDate)){
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

HRESULT
NDSConvertDATEtoDWORD(
    DATE daDate,
    DWORD *pdwDate
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    WORD wFatDate;
    WORD wFatTime;
    HRESULT hr = S_OK;


    if(!VariantTimeToDosDateTime(daDate, &wFatDate, &wFatTime)){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!DosDateTimeToFileTime(wFatDate, wFatTime, &fileTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    tmpTime.LowPart = fileTime.dwLowDateTime;
    tmpTime.HighPart = fileTime.dwHighDateTime;

    ::RtlTimeToSecondsSince1970(&tmpTime, (ULONG *)pdwDate);

error:
    RRETURN(hr);
}



DWORD
ADsNwNdsOpenObject(
    IN  LPWSTR   ObjectDN,
    IN  CCredentials& Credentials,
    OUT HANDLE * lphObject,
    OUT LPWSTR   lpObjectFullName OPTIONAL,
    OUT LPWSTR   lpObjectClassName OPTIONAL,
    OUT LPDWORD  lpdwModificationTime,
    OUT LPDWORD  lpdwSubordinateCount OPTIONAL
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = S_OK;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    hr = Credentials.GetUserName(&pszUserName);
    hr = Credentials.GetPassword(&pszPassword);

//    dwStatus = NwNdsOpenObject(
//                    ObjectDN,
//                    pszUserName,
//                    pszPassword,
//                    lphObject,
//                    NULL, // szObjectName optional parameter
//                    lpObjectFullName,
//                    lpObjectClassName,
//                    lpdwModificationTime,
//                    lpdwSubordinateCount
//                    );


    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    return(dwStatus);

}

HRESULT
CheckAndSetExtendedError(
    DWORD dwRetval
    )

{
    DWORD dwLastError;
    WCHAR pszError[MAX_PATH];
    WCHAR pszProviderName[MAX_PATH];
    INT   numChars;
    HRESULT hr =S_OK;

    wcscpy(pszError, L"");
    wcscpy(pszProviderName, L"");

    if (NWCCODE_SUCCEEDED(dwRetval)){
        hr = S_OK;
    } 
    else {
        if (dwRetval == ERR_NO_ACCESS) {
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        }
        else if (dwRetval == ERR_ENTRY_ALREADY_EXISTS) {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }
        else if (dwRetval == ERR_NO_SUCH_ENTRY) {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_NETPATH);
        }
        else {
            hr = HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);
    
            numChars = LoadString( g_hInst,
                                   NWNDS_PROVIDER_ID,
                                   pszProviderName,
                                   MAX_PATH -1);
    
            //
            // Set the default error string
    
            wsprintf (pszError, L"NDS ccode = %x", dwRetval);
    
            for (DWORD i=0; i < g_cErrLookup; i++ ) {
    
                if ((DWORD) g_aErrLookup[i].errNo == dwRetval) {
                    wcscat (pszError, L"; ");
                    wcscat (pszError, g_aErrLookup[i].errString);
                    break;
                }
            }
    
            ADsSetLastError(
                dwRetval,
                pszError,
                pszProviderName
                );
        }
    }

    RRETURN(hr);
}



HRESULT
CopyObject(
    IN NDS_CONTEXT_HANDLE hDestADsContext,
    IN LPWSTR pszSrcADsPath,
    IN LPWSTR pszDestContainer,
    IN LPWSTR pszCommonName,           //optional
    IN CCredentials& Credentials,
    OUT VOID ** ppObject
    )

{

    HRESULT hr = S_OK;

    LPWSTR pszSrcNDSTreeName = NULL, pszSrcNDSDn = NULL;
    LPWSTR pszChildNDSTreeName = NULL, pszChildNDSDn = NULL;
    NDS_CONTEXT_HANDLE hSrcADsContext = NULL;

    BSTR bstrChildADsPath = NULL;

    NDS_BUFFER_HANDLE hDestOperationData = NULL;
    NDS_BUFFER_HANDLE hAttrOperationData = NULL;

    LPWSTR pszObjectClassName = NULL;

    DWORD dwNumEntries = 0L;
    DWORD dwNumEntriesDefs = 0L;
    LPNDS_ATTR_INFO lpEntries = NULL;
    LPWSTR  pszParent= NULL;
    LPWSTR  pszRelativeName = NULL;
    LPWSTR  pszCN = NULL;
    DWORD  i = 0;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDef = NULL;
    IADs  *pADs = NULL;

    LPWSTR *ppszAttrs = NULL;

    //
    // allocate all variables that are needed
    //

    pszParent = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszParent){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pszCN = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszCN){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = BuildADsParentPath(
                    pszSrcADsPath,
                    pszParent,
                    pszCN
                    );

    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                pszSrcADsPath,
                &pszSrcNDSTreeName,
                &pszSrcNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr  = ADsNdsOpenContext(
              pszSrcNDSTreeName,
              Credentials,
              &hSrcADsContext
              );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsReadObject(
                hSrcADsContext,
                pszSrcNDSDn,
                DS_ATTRIBUTE_VALUES,
                NULL,
                (DWORD) -1, // signifies all attributes need to be returned
                NULL,
                &lpEntries,
                &dwNumEntries
                );
    BAIL_ON_FAILURE(hr);

    //
    // create the destination object
    //
    // use the name given by the user if given at all
    // otherwise use the name of the source
    //

    if ( pszCommonName != NULL) {
        pszRelativeName = pszCommonName;

    } else {
        pszRelativeName = pszCN;
    }

    hr = BuildADsPath(
                pszDestContainer,
                pszRelativeName,
                &bstrChildADsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                bstrChildADsPath,
                &pszChildNDSTreeName,
                &pszChildNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsCreateBuffer(
                        hDestADsContext,
                        DSV_ADD_ENTRY,
                        &hDestOperationData
                        );
    BAIL_ON_FAILURE(hr);

    ppszAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * dwNumEntries);
    if (!ppszAttrs) {
       BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for(i=0; i< dwNumEntries; i++)
       ppszAttrs[i] = lpEntries[i].szAttributeName;

    hr = ADsNdsReadAttrDef(
                    hDestADsContext,
                    DS_ATTR_DEFS,
                    ppszAttrs,
                    dwNumEntries,
                    &hAttrOperationData
                    );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsGetAttrDefListFromBuffer(
                    hDestADsContext,
                    hAttrOperationData,
                    &dwNumEntriesDefs,
                    &dwInfoType,
                    & lpAttrDef
                    );
    BAIL_ON_FAILURE(hr);

    for (i=0; i< dwNumEntriesDefs; i++){


        if(wcscmp(lpEntries[i].szAttributeName, ACL_name) == 0){
            //
            // skip this attribute. Let it default
            //
            continue;
        }

        if(wcscmp(lpEntries[i].szAttributeName, OBJECT_CLASS_name) == 0){

           hr = ADsNdsPutInBuffer(
                    hDestADsContext,
                    hDestOperationData,
                    lpEntries[i].szAttributeName,
                    lpEntries[i].dwSyntaxId,
                    lpEntries[i].lpValue,
                    1,
                    DS_ADD_ATTRIBUTE
                    );
           BAIL_ON_FAILURE(hr);

           pszObjectClassName = lpEntries[i].lpValue ?
                                lpEntries[i].lpValue[0].NdsValue.value_20.ClassName :
                                NULL;

        } else if ( (lpAttrDef[i].dwFlags & DS_READ_ONLY_ATTR)
                      || (lpAttrDef[i].dwFlags & DS_HIDDEN_ATTR)  ){

            //
            // skip this value
            //
            continue;

        } else {

           hr = ADsNdsPutInBuffer(
                    hDestADsContext,
                    hDestOperationData,
                    lpEntries[i].szAttributeName,
                    lpEntries[i].dwSyntaxId,
                    lpEntries[i].lpValue,
                    lpEntries[i].dwNumberOfValues,
                    DS_ADD_ATTRIBUTE
                    );
           BAIL_ON_FAILURE(hr);

        }

    }

    hr = ADsNdsAddObject(
                    hDestADsContext,
                    pszChildNDSDn,
                    hDestOperationData
                    );

    BAIL_ON_FAILURE(hr);

    if (!pszObjectClassName) {
       BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (_wcsicmp(pszObjectClassName, L"user") == 0) {
        hr = ADsNdsGenObjectKey(hDestADsContext,
                                pszChildNDSDn);     
        BAIL_ON_FAILURE(hr);
    }

    hr = CNDSGenObject::CreateGenericObject(
                    pszDestContainer,
                    pszRelativeName,
                    pszObjectClassName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should add-ref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                        pADs,
                        Credentials,
                        IID_IUnknown,
                        ppObject
                        );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                            IID_IUnknown,
                            ppObject
                            );
        BAIL_ON_FAILURE(hr);
    }

error:

    FreeADsMem(pszParent);
    FreeADsMem(pszCN);

    FreeADsStr(pszSrcNDSTreeName);
    FreeADsStr(pszSrcNDSDn);

    FreeADsStr(pszChildNDSTreeName);
    FreeADsStr(pszChildNDSDn);

    FreeADsMem(ppszAttrs);

    if (bstrChildADsPath) {
        SysFreeString(bstrChildADsPath);
    }

    if (hDestOperationData) {
        ADsNdsFreeBuffer(hDestOperationData);
    }

    if (hAttrOperationData) {
        ADsNdsFreeBuffer(hAttrOperationData);
    }

    if(hSrcADsContext){
        ADsNdsCloseContext(hSrcADsContext);
    }

    if (pADs){
        pADs->Release();
    }

    FreeNdsAttrInfo(lpEntries, dwNumEntries);

    ADsNdsFreeAttrDefList(lpAttrDef, dwNumEntriesDefs);

    RRETURN(hr);
}


HRESULT
MoveObject(
    IN NDS_CONTEXT_HANDLE hDestADsContext,
    IN LPWSTR pszSrcADsPath,
    IN LPWSTR pszDestContainer,
    IN LPWSTR pszCommonName,           //optional
    IN CCredentials& Credentials,
    OUT VOID ** ppObject
    )

{
    HRESULT hr = S_OK;

    LPWSTR pszSrcNDSTreeName = NULL, pszSrcNDSDn = NULL;
    LPWSTR pszParentNDSTreeName = NULL, pszParentNDSDn = NULL;
    NDS_CONTEXT_HANDLE hSrcADsContext = NULL;

    LPWSTR pszObjectClassName = NULL;

    DWORD dwNumEntries = 0L;
    LPNDS_ATTR_INFO lpEntries = NULL;
    LPWSTR  pszParent= NULL;
    LPWSTR  pszRelativeName = NULL;
    LPWSTR  pszCN = NULL;
    IADs  *pADs = NULL;

    LPWSTR pszAttrs = L"object Class";

    //
    // allocate all variables that are needed
    //

    pszParent = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszParent){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pszCN = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszCN){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = BuildADsParentPath(
                    pszSrcADsPath,
                    pszParent,
                    pszCN
                    );

    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                pszSrcADsPath,
                &pszSrcNDSTreeName,
                &pszSrcNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr  = ADsNdsOpenContext(
              pszSrcNDSTreeName,
              Credentials,
              &hSrcADsContext
              );
    BAIL_ON_FAILURE(hr);

    //
    // Just get the objectClass attribute
    //
    hr = ADsNdsReadObject(
                hSrcADsContext,
                pszSrcNDSDn,
                DS_ATTRIBUTE_VALUES,
                &pszAttrs,
                1,
                NULL,
                &lpEntries,
                &dwNumEntries
                );
    BAIL_ON_FAILURE(hr);

    if (dwNumEntries != 1) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    pszObjectClassName = (lpEntries[0].lpValue) ?
                             lpEntries[0].lpValue[0].NdsValue.value_20.ClassName :
                              NULL;

    if (!pszObjectClassName) {
        BAIL_ON_FAILURE(E_FAIL);
    }

    hr = BuildNDSPathFromADsPath2(
                pszDestContainer,
                &pszParentNDSTreeName,
                &pszParentNDSDn
                );
    BAIL_ON_FAILURE(hr);

    //
    // use the name given by the user if given at all
    // otherwise use the name of the source
    //

    if ( pszCommonName != NULL) {
        pszRelativeName = pszCommonName;

    } else {
        pszRelativeName = pszCN;
    }

    //
    // If the relative name has changed and parent hasn't changed, just do a
    // simple rename
    //
    if ((_wcsicmp(pszParent,pszDestContainer) == 0) && 
        (_wcsicmp(pszCN,pszRelativeName) != 0)) {
        hr = ADsNdsRenameObject(
                        hDestADsContext,
                        pszSrcNDSDn,
                        pszRelativeName
                        );
    
        BAIL_ON_FAILURE(hr);
    }

    //
    // If the parent has changed
    //
    if (_wcsicmp(pszParent,pszDestContainer) != 0) {
        hr = ADsNdsMoveObject(
                        hDestADsContext,
                        pszSrcNDSDn,
                        pszParentNDSDn,
                        pszRelativeName
                        );
        BAIL_ON_FAILURE(hr);
    }

    if (!pszObjectClassName) {
       BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = CNDSGenObject::CreateGenericObject(
                    pszDestContainer,
                    pszRelativeName,
                    pszObjectClassName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should add-ref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                        pADs,
                        Credentials,
                        IID_IUnknown,
                        ppObject
                        );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                            IID_IUnknown,
                            ppObject
                            );
        BAIL_ON_FAILURE(hr);
    }

error:

    FreeADsMem(pszParent);
    FreeADsMem(pszCN);

    FreeADsStr(pszSrcNDSTreeName);
    FreeADsStr(pszSrcNDSDn);

    FreeADsStr(pszParentNDSTreeName);
    FreeADsStr(pszParentNDSDn);

    if(hSrcADsContext){
        ADsNdsCloseContext(hSrcADsContext);
    }

    if (pADs){
        pADs->Release();
    }

    FreeNdsAttrInfo( lpEntries, dwNumEntries );

    RRETURN(hr);
}

HRESULT
ConvertDWORDtoSYSTEMTIME(
    DWORD dwDate,
    LPSYSTEMTIME pSystemTime
    )
{
    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;

    ::RtlSecondsSince1970ToTime(dwDate, &tmpTime );

    fileTime.dwLowDateTime = tmpTime.LowPart;
    fileTime.dwHighDateTime = tmpTime.HighPart;

    if (!FileTimeToSystemTime( &fileTime, pSystemTime)){
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

HRESULT
ConvertSYSTEMTIMEtoDWORD(
    CONST SYSTEMTIME *pSystemTime,
    DWORD *pdwDate
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;

    if (!SystemTimeToFileTime(pSystemTime,&fileTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    tmpTime.LowPart = fileTime.dwLowDateTime;
    tmpTime.HighPart = fileTime.dwHighDateTime;

    ::RtlTimeToSecondsSince1970(&tmpTime, (ULONG *)pdwDate);

error:
    RRETURN(hr);
}



HRESULT
InitializeNWLibrary(
    void
    )
{
    NWDSCCODE ccode;
    HRESULT hr = S_OK;
    LCONV lConvInfo;

    ccode = NWCallsInit(NULL, NULL);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    ccode = NWCLXInit(NULL, NULL);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    NWLlocaleconv(&lConvInfo);

    ccode = NWInitUnicodeTables(lConvInfo.country_id,lConvInfo.code_page);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\corgu.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  OrganizationUnit object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aOrgUnitPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("SeeAlso"), TEXT("See Also") }
  // { TEXT("BusinessCategory"), TEXT("businessCategory") } BUG BUG
};


//  Class CNDSOrganizationUnit

DEFINE_IDispatch_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADs_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSOrganizationUnit, aOrgUnitPropMapping)


CNDSOrganizationUnit::CNDSOrganizationUnit():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSAttrMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSOrganizationUnit);
}


HRESULT
CNDSOrganizationUnit::CreateOrganizationUnit(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSOrganizationUnit FAR * pOrganizationUnit = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOrganizationUnitObject(pADs, &pOrganizationUnit);
    BAIL_ON_FAILURE(hr);

    hr = pOrganizationUnit->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->Release();

    RRETURN(hr);

error:
    delete pOrganizationUnit;

    RRETURN(hr);

}


CNDSOrganizationUnit::~CNDSOrganizationUnit( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if ( _pDSObject )
        _pDSObject->Release();

    if ( _pDSSearch )
        _pDSSearch->Release();

    if ( _pDSAttrMgmt )
        _pDSAttrMgmt->Release();


    if (_pADsPropList) {
        _pADsPropList->Release();
    }


    delete _pDispMgr;
}

STDMETHODIMP
CNDSOrganizationUnit::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOU))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList ) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSOrganizationUnit::AllocateOrganizationUnitObject(
    IADs *pADs,
    CNDSOrganizationUnit ** ppOrganizationUnit
    )
{
    CNDSOrganizationUnit FAR * pOrganizationUnit = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSAttrMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;


    pOrganizationUnit = new CNDSOrganizationUnit();
    if (pOrganizationUnit == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsOU,
                (IADsOU *)pOrganizationUnit,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pOrganizationUnit,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pOrganizationUnit,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSAttrMgmt
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSAttrMgmt = pDSAttrMgmt;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pOrganizationUnit->_pADs = pADs;
    pADs->AddRef();

    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pOrganizationUnit->_pADsContainer = pADsContainer;


    hr = pADs->QueryInterface(
                        IID_IADsPropertyList,
                        (void **)&pADsPropList
                        );
    BAIL_ON_FAILURE(hr);
    pOrganizationUnit->_pADsPropList = pADsPropList;



    pOrganizationUnit->_pDispMgr = pDispMgr;
    *ppOrganizationUnit = pOrganizationUnit;

    RRETURN(hr);

error:

    if (pADsContainer) {
        pADsContainer->Release();
    }


    if (pADsPropList) {

        pADsPropList->Release();
    }


    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP CNDSOrganizationUnit::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,Description);
}

STDMETHODIMP CNDSOrganizationUnit::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,Description);
}



STDMETHODIMP CNDSOrganizationUnit::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}

STDMETHODIMP CNDSOrganizationUnit::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}



STDMETHODIMP CNDSOrganizationUnit::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}

STDMETHODIMP CNDSOrganizationUnit::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}


STDMETHODIMP CNDSOrganizationUnit::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}

STDMETHODIMP CNDSOrganizationUnit::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}


STDMETHODIMP CNDSOrganizationUnit::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}

STDMETHODIMP CNDSOrganizationUnit::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}


STDMETHODIMP CNDSOrganizationUnit::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}

STDMETHODIMP CNDSOrganizationUnit::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}


STDMETHODIMP CNDSOrganizationUnit::get_BusinessCategory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}

STDMETHODIMP CNDSOrganizationUnit::put_BusinessCategory(THIS_ BSTR bstrBusinessCategory)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSOrganizationUnit::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN(hr);
}



STDMETHODIMP
CNDSOrganizationUnit::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN(hr);
}


STDMETHODIMP
CNDSOrganizationUnit::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN(hr);






    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cpgi.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

--*/

#include "nds.hxx"
#pragma hdrstop

//
//  CNDSPrintQueue
//

STDMETHODIMP
CNDSPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNDSPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNDSPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CNDSPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CNDSPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNDSPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}


STDMETHODIMP CNDSPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP CNDSPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}


STDMETHODIMP
CNDSPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNDSPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNDSPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    //
    // BUGBUG: long assigned a date(double) value. NT INFO structures
    // handle long only. ADS specs say double.
    //
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);

}

STDMETHODIMP
CNDSPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNDSPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    //
    // BUGBUG: long assigned a date(double) value. NT INFO structures
    // handle long only. ADS specs say double.
    //
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNDSPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNDSPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNDSPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNDSPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNDSPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNDSPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr = E_FAIL;
    // BugBug: RamV replace the get_HostComputer with
    // hr = ADsAllocString(_Parent, retval);
    RRETURN(hr);

}

STDMETHODIMP
CNDSPrintQueue::put_PrinterPath(THIS_ BSTR bstrPrinterPath)
{
    //
    // Cannot change this in Windows NT!
    //
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNDSPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNDSPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNDSPrintQueue::put_PrintDevices(THIS_ VARIANT vPorts)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNDSPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

STDMETHODIMP
CNDSPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

//
// Class CNDSPrintQueue
//

/* IADsFSPrintQueueOperation methods */

STDMETHODIMP
CNDSPrintQueue::PrintJobs(
    THIS_ IADsCollection * FAR* ppCollection
    )
{
    RRETURN(E_NOTIMPL);
}




//+------------------------------------------------------------------------
//
//  Function: CNDSPrintQueue::Pause
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName
//   and attempts to pause the real printer.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//  Appropriated from Old NetOle Code.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CNDSPrintQueue::Pause(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    LPWSTR pszNDSPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSPrintQueue::Resume
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName and
//              attempts to resume the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV  Created
//              Appropriated from old NetOle Project
//----------------------------------------------------------------------------


STDMETHODIMP
CNDSPrintQueue::Resume(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPath = NULL;
    BSTR bstrADsPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
               );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSPrintQueue::Purge
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to purge the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV   Created
//              Appropriated from old NetOle Code
//----------------------------------------------------------------------------


STDMETHODIMP
CNDSPrintQueue::Purge(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPath = NULL;
    BSTR bstrADsPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Purge printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PURGE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSPrintQueue::get_Status(THIS_ long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NDS Provider Object Class Factory Code
//
//             CNDSProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CNDSProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNDSProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamesp.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CNDSNamespace)
DEFINE_IADs_Implementation(CNDSNamespace)

//  Class CNDSNamespace

CNDSNamespace::CNDSNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNDSNamespace);
}

HRESULT
CNDSNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(
                Credentials,
                &pNamespace
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                L"Namespace",
                L"",
                CLSID_NDSNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN(hr);
}


CNDSNamespace::~CNDSNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CNDSNamespace::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider)) 
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


STDMETHODIMP
CNDSNamespace::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN(E_NOTIMPL);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSNamespace::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    VariantInit(pVar);
    RRETURN(VariantCopy(pVar, &_vFilter));
}

STDMETHODIMP
CNDSNamespace::put_Filter(THIS_ VARIANT Var)
{
    VariantClear(&_vFilter);
    RRETURN(VariantCopy(&_vFilter, &Var));
}

STDMETHODIMP
CNDSNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                TRUE
                );
    RRETURN(hr);

}

STDMETHODIMP
CNDSNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNDSNamespaceEnum::Create(
                (CNDSNamespaceEnum **)&penum,
                _vFilter,
                _Credentials
                );
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    return hr;
}

STDMETHODIMP
CNDSNamespace::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::MoveHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CNDSNamespace::AllocateNamespaceObject(
    CCredentials& Credentials,
    CNDSNamespace ** ppNamespace
    )
{
    CNDSNamespace FAR * pNamespace = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CNDSNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsOpenDSObject,
                           (IADsOpenDSObject *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespace,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;
    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}




STDMETHODIMP
CNDSNamespace::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    //
    // retrieve dataobject from cache; if one exists
    //



    //
    //
    //
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CNDSNamespace::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CNDSNamespace::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch FAR * * ppADsObj
    )
{
    HRESULT hr = S_OK;
    IUnknown * pObject = NULL;
    CCredentials Credentials(lpszUserName, lpszPassword, 0L);

    hr = ::GetObject(
                lpszDNName,
                Credentials,
                (LPVOID *)&pObject
                );
    BAIL_ON_FAILURE(hr);



    hr = pObject->QueryInterface(
                        IID_IDispatch,
                        (void **)ppADsObj
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pObject) {
        pObject->Release();
    }

    RRETURN(hr);
}

HRESULT
CNDSNamespace::ParsePath(
    BSTR bstrADsPath, 
    DWORD dwType, 
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - the place where the parsed object is stored
    
Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    PWSTR szPath = NULL;

    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            CLexer Lexer(bstrADsPath);
        
            hr = ADsObject(&Lexer, pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            CLexer Lexer(bstrADsPath);
        
            Lexer.SetAtDisabler(TRUE);
        
            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->ProviderName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->TreeName) {
        pObjectInfo->ServerName = AllocADsStr(pObjInfo->TreeName);
        if (!pObjectInfo->ServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->DisplayTreeName) {
        pObjectInfo->DisplayServerName = AllocADsStr(pObjInfo->DisplayTreeName);
        if (!pObjectInfo->DisplayServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;

error:
    FreeObjectInfo(pObjInfo);
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    return (hr);
}

HRESULT
CNDSNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the 
    components in the target objinfo is empty. Users of this function can call 
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            pObjectInfoTarget->ComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);

    RRETURN_EXP_IF_ERR(hr);
}

void
CNDSNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void 
CNDSNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    BOOL fEscaped
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    if (fEscaped) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }
    else {
        pComponent = _pObjectInfo->ComponentArray;
    }

    if (_fNamingAttribute) {
        wcscat(szReturn, pComponent[cComponents].szComponent);
        if (pComponent[cComponents].szValue) {
            wcscat(szReturn,
                   TEXT("="));
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
    }
    else {
        if (pComponent[cComponents].szValue) {
            //
            // If value exist, only show display value
            //
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
        else {
            //
            // else value is only stored in Component
            //
            wcscat(szReturn,
                   pComponent[cComponents].szComponent);
        }
    }
}


HRESULT 
CNDSNamespace::SetComponents(
                            LPWSTR szReturn,
                            BOOLEAN bIsWindowsPath,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            BOOL fEscaped
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    bIsWindowsPath - whether a windows path is to be returned
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    BOOL bReverse;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
        bReverse = !bIsWindowsPath;
    }
    else {
        bReverse = bIsWindowsPath;
    }


    if (!bReverse) {
        dwLimit = _pObjectInfo->NumComponents;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwOtherLimit >= dwLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
            SetComponent(szReturn,
                         cComponents,
                         fEscaped);
            if (cComponents != dwLimit - 1) {
                wcscat(szReturn,
                       chSeparator);
            }
        }
    }
    else {
        dwLimit = _pObjectInfo->NumComponents-1;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwLimit < dwOtherLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwLimit ; (long)cComponents >= dwOtherLimit; cComponents--) {
            SetComponent(szReturn,
                         cComponents,
                         fEscaped);
            if (cComponents != dwOtherLimit) {
                wcscat(szReturn, chSeparator);
            }
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2; 
    }
    return dwPath;
}


STDMETHODIMP
CNDSNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    BOOL fEscaped = FALSE;

    switch (dwEscapedMode) {
        case ADS_ESCAPEDMODE_OFF:
        case ADS_ESCAPEDMODE_DEFAULT:
            fEscaped = FALSE;
            break;
        case ADS_ESCAPEDMODE_ON:
            fEscaped = TRUE;
            break;
    }

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _fNamingAttribute = (BOOLEAN)(dwFlag & ADS_CONSTRUCT_NAMINGATTRIBUTE);
    _pObjectInfo = pObjectInfo;

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                fEscaped = TRUE;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                    wcscat(szReturn,pObjectInfo->DisplayServerName);
                    if (pObjectInfo->NumComponents>0) {
                        wcscat(szReturn,TEXT("/"));
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
        case ADS_FORMAT_X500_DN:
        case ADS_FORMAT_X500_PARENT:
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cprinter.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

  --*/

#include "nds.hxx"
#pragma hdrstop

//
// Class CNDSPrintQueue Methods
//

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aPrintPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("Location"), TEXT("L") },
  { TEXT("HostComputer"), TEXT("Host Server") }
};

DEFINE_IDispatch_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADs_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSPrintQueue, aPrintPropMapping)

CNDSPrintQueue::CNDSPrintQueue():
                    _pADs(NULL),
                    _pADsPropList(NULL)
{
    _pDispMgr = NULL;
    ENLIST_TRACKING(CNDSPrintQueue);
    return;
}


CNDSPrintQueue::~CNDSPrintQueue()
{

    if (_pADs) {

        _pADs->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }


    delete _pDispMgr;

    return;
}

HRESULT
CNDSPrintQueue:: CreatePrintQueue(
    IADs * pADs,
    REFIID riid,
    LPVOID * ppvoid
    )

{

    CNDSPrintQueue  *pPrintQueue =  NULL;
    HRESULT hr;

    //
    // Create the printer object
    //

    hr = AllocatePrintQueueObject(
                    pADs,
                    &pPrintQueue
                    );
    BAIL_ON_FAILURE(hr);

    //
    // initialize the core object
    //

    BAIL_ON_FAILURE(hr);


    hr = pPrintQueue->QueryInterface(
                        riid,
                        (void **)ppvoid
                        );
    BAIL_ON_FAILURE(hr);


    pPrintQueue->Release();
    RRETURN(hr);

error:
    delete pPrintQueue;
    RRETURN (hr);
}

/* IUnknown methods for printer object  */

STDMETHODIMP
CNDSPrintQueue::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintQueue *)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintQueue *)this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueue))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueueOperations))
    {
      *ppvObj = (IADsPrintQueueOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList) && _pADsPropList)
    {
      *ppvObj = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}


HRESULT
CNDSPrintQueue::AllocatePrintQueueObject(
    IADs * pADs,
    CNDSPrintQueue ** ppPrintQueue
    )
{
    CNDSPrintQueue FAR * pPrintQueue = NULL;
    HRESULT hr = S_OK;

    pPrintQueue = new CNDSPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pPrintQueue->_pDispMgr = new CDispatchMgr;
    if (pPrintQueue->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }

    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintQueue,
                (IADsPrintQueue *)pPrintQueue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintQueueOperations,
                (IADsPrintQueueOperations *)pPrintQueue,
                DISPID_REGULAR
                );

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pPrintQueue,
                DISPID_VALUE
                );

    BAIL_ON_FAILURE(hr);

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pPrintQueue->_pADs = pADs;
    pADs->AddRef();

    *ppPrintQueue = pPrintQueue;
    RRETURN(hr);

error:

    delete  pPrintQueue;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CNDSProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSProvider

CNDSProvider::CNDSProvider()
{

}

HRESULT
CNDSProvider::Create(CNDSProvider FAR * FAR * ppProvider)
{
    CNDSProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CNDSProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN(hr);
}

CNDSProvider::~CNDSProvider( )
{
    ENLIST_TRACKING(CNDSProvider);
}

STDMETHODIMP
CNDSProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IParseDisplayName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSProvider::ParseDisplayName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN(hr);
}

HRESULT
CNDSProvider::ResolvePathName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    CCredentials Credentials;

    *pchEaten = 0;
    hr = GetObject(
            szDisplayName,
            Credentials,
            (LPVOID *)&pUnknown
            );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cprops.cxx ===
//+---------------------------------------------------------------------------;
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NDS
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


#if DBG
DECLARE_INFOLEVEL(NDSMarshall);
DECLARE_DEBUG(NDSMarshall);
#define NDSMarshallDebugOut(x) NDSMarshallInlineDebugOut x
#endif







//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNDSOBJECT pNdsObject
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString = NULL;

    PPROPERTY pNewProperties = NULL;

    //
    // Allocate the string first
    //
    tempString = AllocADsStr(szPropertyName);

    if (!tempString)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    //  extend the property cache by adding a new property entry
    //

    pNewProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!pNewProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _pProperties = pNewProperties;

    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);


    //
    // Since the memory has already been allocated in tempString
    // just set the value/pointer now.
    //
    pNewProperty->szPropertyName = tempString;

    //
    // BugBug - add in the NDSOBJECT code
    //


    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

    RRETURN(hr);

error:

    if (tempString)
       FreeADsStr(tempString);

    RRETURN(hr);
}





//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNDSOBJECT pNdsObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PNDSOBJECT pNdsTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (!fExplicit) {
        if ((PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_MODIFIED) ||
            (PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_CLEARED))    {

            hr = S_OK;
            goto error;
        }
    }


    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        NdsTypeFreeNdsObjects(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NDSOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NdsTypeCopyConstruct(
            pNdsObject,
            dwNumValues,
            &pNdsTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

    PROPERTY_FLAGS(pThisProperty)  = CACHE_PROPERTY_INITIALIZED;

error:

    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {

        //
        // Now call the GetInfo function
        //

        hr = _pCoreADsObject->GetInfo(
                    FALSE
                    );
        BAIL_ON_FAILURE(hr);

        hr = findproperty(
                    szPropertyName,
                    &dwIndex
                    );

    }
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putproperty(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNDSOBJECT pNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PNDSOBJECT pNdsTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        NdsTypeFreeNdsObjects(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NDSOBJECT(pThisProperty) = NULL;
    }


    switch (dwFlags) {

    case CACHE_PROPERTY_MODIFIED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

        hr = NdsTypeCopyConstruct(
                pNdsObject,
                dwNumValues,
                &pNdsTempObject
                );
        BAIL_ON_FAILURE(hr);

        PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_MODIFIED;
        break;

    case CACHE_PROPERTY_CLEARED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = 0;

        PROPERTY_NDSOBJECT(pThisProperty) = NULL;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_CLEARED;

        break;


    case CACHE_PROPERTY_APPENDED:

       PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

       PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

       hr = NdsTypeCopyConstruct(
               pNdsObject,
               dwNumValues,
               &pNdsTempObject
               );
       BAIL_ON_FAILURE(hr);

       PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

       PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_APPENDED;
       break;


    case CACHE_PROPERTY_DELETED:

       PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

       PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

       hr = NdsTypeCopyConstruct(
               pNdsObject,
               dwNumValues,
               &pNdsTempObject
               );
       BAIL_ON_FAILURE(hr);

       PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

       PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_DELETED;
       break;

    }

error:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
CPropertyCache():
        _dwMaxProperties(0),
        _dwCurrentIndex(0),
        _pProperties(NULL),
        _cb(0),
        _pCoreADsObject(NULL)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

       if (pThisProperty->szPropertyName){
        FreeADsStr(pThisProperty->szPropertyName);
        pThisProperty->szPropertyName = NULL;
          }

            if (PROPERTY_NDSOBJECT(pThisProperty)) {

                NdsTypeFreeNdsObjects(
                        PROPERTY_NDSOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NDSOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN(E_FAIL);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    PNDSOBJECT pNdsObject,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{

    DWORD dwIndex = 0;
    HRESULT hr = S_OK;

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsObject
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);




error:

    RRETURN(hr);
}


HRESULT
CPropertyCache::
NDSUnMarshallProperties(
    HANDLE hOperationData,
    BOOL fExplicit
    )

{
    DWORD dwNumberOfEntries = 0L;
    LPNDS_ATTR_INFO lpEntries = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwStatus = 0L;

    //
    // Compute the number of attributes in the
    // read buffer.
    //

//    dwStatus = NwNdsGetAttrListFromBuffer(
//                    hOperationData,
//                    &dwNumberOfEntries,
//                    &lpEntries
//                    );
//
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumberOfEntries; i++) {

        //
        // unmarshall this property into the
        // property cache
        //

        hr = unmarshallproperty(
                    lpEntries[i].szAttributeName,
                    lpEntries[i].lpValue,
                    lpEntries[i].dwNumberOfValues,
                    lpEntries[i].dwSyntaxId,
                    fExplicit
                    );

        CONTINUE_ON_FAILURE(hr);

    }

error:

    RRETURN(hr);

}




HRESULT
CPropertyCache::
marshallproperty(
    NDS_CONTEXT_HANDLE hADsContext,
    NDS_BUFFER_HANDLE hOperationData,
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    PNDSOBJECT lpValues,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId
    )
{
    HRESULT hr = S_OK;

    switch (dwFlags) {

    case CACHE_PROPERTY_MODIFIED:

        hr = ADsNdsPutInBuffer(
                 hADsContext,
                 hOperationData,
                 szPropertyName,
                 dwSyntaxId,
                 NULL,
                 0,
                 DS_CLEAR_ATTRIBUTE
                 );
        BAIL_ON_FAILURE(hr);

        hr = ADsNdsPutInBuffer(
                 hADsContext,
                 hOperationData,
                 szPropertyName,
                 dwSyntaxId,
                 lpValues,
                 dwNumValues,
                 DS_ADD_ATTRIBUTE
                 );
        BAIL_ON_FAILURE(hr);

        break;

    case CACHE_PROPERTY_CLEARED:

        hr = ADsNdsPutInBuffer(
                 hADsContext,
                 hOperationData,
                 szPropertyName,
                 dwSyntaxId,
                 NULL,
                 0,
                 DS_CLEAR_ATTRIBUTE
                 );
        BAIL_ON_FAILURE(hr);
        break;

    case CACHE_PROPERTY_APPENDED:

        hr = ADsNdsPutInBuffer(
                 hADsContext,
                 hOperationData,
                 szPropertyName,
                 dwSyntaxId,
                 lpValues,
                 dwNumValues,
                 DS_ADD_VALUE
                 );
        BAIL_ON_FAILURE(hr);

        break;

    case CACHE_PROPERTY_DELETED:

        hr = ADsNdsPutInBuffer(
                 hADsContext,
                 hOperationData,
                 szPropertyName,
                 dwSyntaxId,
                 lpValues,
                 dwNumValues,
                 DS_REMOVE_VALUE
                 );
        BAIL_ON_FAILURE(hr);

        break;

    default:
        break;


    }


#if DBG

    NDSMarshallDebugOut((
                DEB_TRACE,
                "dwSyntaxId: %ld \n", dwSyntaxId
                ));
#endif


error:

    RRETURN(hr);

}

HRESULT
CPropertyCache::
NDSMarshallProperties(
    NDS_CONTEXT_HANDLE hADsContext,
    NDS_BUFFER_HANDLE hOperationData
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    BYTE lpBuffer[2048];

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == 0) {

            continue;
        }


        hr = marshallproperty(
                hADsContext,
                hOperationData,
                PROPERTY_NAME(pThisProperty),
                PROPERTY_FLAGS(pThisProperty),
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                PROPERTY_SYNTAX(pThisProperty)
                );
        CONTINUE_ON_FAILURE(hr);

        if (PROPERTY_NDSOBJECT(pThisProperty)) {

            NdsTypeFreeNdsObjects(
                    PROPERTY_NDSOBJECT(pThisProperty),
                    PROPERTY_NUMVALUES(pThisProperty)
                    );
            PROPERTY_NDSOBJECT(pThisProperty) = NULL;
        }

        wcscpy(pThisProperty->szPropertyName, TEXT(""));
        PROPERTY_SYNTAX(pThisProperty) = 0;
        PROPERTY_NUMVALUES(pThisProperty) = 0;
        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_INITIALIZED;

    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

       if (pThisProperty->szPropertyName) {
          FreeADsStr(pThisProperty->szPropertyName);
          pThisProperty->szPropertyName = NULL;
       }

            if (PROPERTY_NDSOBJECT(pThisProperty)) {

                NdsTypeFreeNdsObjects(
                        PROPERTY_NDSOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NDSOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
    _dwCurrentIndex = 0;
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr;
    PPROPERTY pThisProperty = NULL;

    if (!_pProperties) {
        RRETURN(E_FAIL);
    }


    if (dwIndex < 0 || dwIndex > (_dwMaxProperties - 1) )
       RRETURN(E_FAIL);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN(hr);
}

BOOL
CPropertyCache::
index_valid(
   )
{
   if (_dwCurrentIndex < 0 || _dwCurrentIndex > _dwMaxProperties - 1)
     return(FALSE);
  else
     return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{

   if (dwIndex < 0 || dwIndex > _dwMaxProperties - 1)
      return(FALSE);
   else
      return(TRUE);
}

void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}



HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
   DWORD newIndex = _dwCurrentIndex + dwElements;

   if (!index_valid() || !_dwMaxProperties)
      RRETURN(E_FAIL);

   //
   // BugBug it will be better to return IndexOutOfRange or something like that
   //

   if (_dwCurrentIndex < 0 || _dwCurrentIndex > _dwMaxProperties-1)
      RRETURN(E_FAIL);

   if ( newIndex < 0 || newIndex > _dwMaxProperties )
      RRETURN(E_FAIL);


   _dwCurrentIndex = newIndex;
   RRETURN(S_OK);

}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}


DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid())
        return(PROPERTY_NAME(pThisProperty));

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}


LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}



HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_NDSOBJECT(pThisProperty)) {
          NdsTypeFreeNdsObjects(
                  PROPERTY_NDSOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_NDSOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_NDSOBJECT(pThisProperty)) {
       NdsTypeFreeNdsObjects(
               PROPERTY_NDSOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_NDSOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
error:

   RRETURN(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cschobj.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cschema.cxx
//
//  Contents:  Microsoft ADs NDS Provider Schema Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSSchema

DEFINE_IDispatch_Implementation(CNDSSchema)
DEFINE_IADs_Implementation(CNDSSchema)


CNDSSchema::CNDSSchema()
{

    VariantInit(&_vFilter);

    _NDSTreeName = NULL;

    ENLIST_TRACKING(CNDSSchema);
}

HRESULT
CNDSSchema::CreateSchema(
    BSTR Parent,
    BSTR CommonName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSSchema FAR * pSchema = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSTreeName = NULL;
    LPWSTR pszNDSDn = NULL;

    hr = AllocateSchema(&pSchema, Credentials);
    BAIL_ON_FAILURE(hr);

    hr = pSchema->InitializeCoreObject(
                Parent,
                CommonName,
                SCHEMA_CLASS_NAME,
                L"",
                CLSID_NDSSchema,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath2(
                Parent,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pszNDSTreeName,  &pSchema->_NDSTreeName);
    BAIL_ON_FAILURE(hr);

    hr = pSchema->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);
    }

    if (pszNDSDn) {
        FreeADsStr(pszNDSDn);
    }

    RRETURN(hr);

error:

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);
    }

    delete pSchema;
    RRETURN(hr);
}

CNDSSchema::~CNDSSchema( )
{
    VariantClear(&_vFilter);

    if (_NDSTreeName) {
        ADsFreeString(_NDSTreeName);
    }
    delete _pDispMgr;
}

STDMETHODIMP
CNDSSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSSchema::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSSchema::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    VariantInit(pVar);
    RRETURN(VariantCopy(pVar, &_vFilter));
}

STDMETHODIMP
CNDSSchema::put_Filter(THIS_ VARIANT Var)
{
    VariantClear(&_vFilter);
    RRETURN(VariantCopy(&_vFilter, &Var));
}

STDMETHODIMP
CNDSSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(::RelativeGetObject(_ADsPath,
                                ClassName,
                                RelativeName,
                                _Credentials,
                                ppObject,
                                FALSE));
}

STDMETHODIMP
CNDSSchema::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSSchemaEnum::Create(
                (CNDSSchemaEnum **)&penum,
                _NDSTreeName,
                _ADsPath,
                _Name,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CNDSSchema::AllocateSchema(
    CNDSSchema ** ppSchema,
    CCredentials& Credentials
    )
{
    CNDSSchema FAR * pSchema = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CNDSSchema();
    if (pSchema == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADsDomain *)pSchema,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pSchema,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pSchema->_Credentials = Credentials;
    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSSchema::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CNDSSchema::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CNDSSchema::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser

STDMETHODIMP CNDSUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, BadLoginAddress);
}

STDMETHODIMP CNDSUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, BadLoginCount);
}

STDMETHODIMP CNDSUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogin);
}

STDMETHODIMP CNDSUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogoff);
}

STDMETHODIMP CNDSUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastFailedLogin);
}

STDMETHODIMP CNDSUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordLastChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\csynobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  NDS
//
//
//  History:   01-09-96     yihsins    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

/******************************************************************/
/*  Class CNDSSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CNDSSyntax)
DEFINE_IADs_Implementation(CNDSSyntax)

CNDSSyntax::CNDSSyntax()
{
    ENLIST_TRACKING(CNDSSyntax);
}

CNDSSyntax::~CNDSSyntax()
{
    delete _pDispMgr;
}

HRESULT
CNDSSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NDSSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN(hr);
}

STDMETHODIMP
CNDSSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CNDSSyntax::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSSyntax::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSSyntax::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
     RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CNDSSyntax::AllocateSyntaxObject(CNDSSyntax FAR * FAR * ppSyntax)
{
    CNDSSyntax FAR *pSyntax = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CNDSSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CNDSSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( (bstrList != NULL) && (*bstrList != 0) )
    {
        long i = 0;
        long nCount = 1;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cprpobj.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cclsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


// Class CNDSProperty

DECLARE_INFOLEVEL( Syntax );
DECLARE_DEBUG( Syntax );
#define SyntaxDebugOut(x) SyntaxInlineDebugOut x

DEFINE_IDispatch_Implementation(CNDSProperty)
DEFINE_IADs_Implementation(CNDSProperty)

CNDSProperty::CNDSProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE )
{

    ENLIST_TRACKING(CNDSProperty);
}

CNDSProperty::~CNDSProperty()
{
    delete _pDispMgr;
}

HRESULT
CNDSProperty::CreateProperty(
    BSTR   bstrParent,
    BSTR   bstrName,
    LPNDS_ATTR_DEF lpAttrDef,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;
    WCHAR szADsSyntax[MAX_PATH];
    WCHAR szNDSSyntax[MAX_PATH];

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             bstrName,
             PROPERTY_CLASS_NAME,
             L"",
             CLSID_NDSProperty,
             dwObjectState
             );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

#if DBG
        SyntaxDebugOut((DEB_TRACE,
                           "Property %s : SyntaxId %d\n",
                           lpAttrDef->szAttributeName,
                           lpAttrDef->dwSyntaxID));
#endif

    MapSyntaxIdtoADsSyntax(
            lpAttrDef->dwSyntaxID,
            szADsSyntax
            );

    hr = ADsAllocString(
                szADsSyntax,
                &pProperty->_bstrSyntax
                );
    BAIL_ON_FAILURE(hr);

    MapSyntaxIdtoNDSSyntax(
            lpAttrDef->dwSyntaxID,
            szNDSSyntax
            );

    hr = ADsAllocString(
                szNDSSyntax,
                &pProperty->_bstrOID
                );
    BAIL_ON_FAILURE(hr);

    pProperty->_lMaxRange = lpAttrDef->dwUpperLimit;
    pProperty->_lMinRange = lpAttrDef->dwLowerLimit;
    pProperty->_fMultiValued  = !(lpAttrDef->dwFlags & NDS_SINGLE_VALUED_ATTR);

    pProperty->Release();

    RRETURN(hr);

error:

    delete pProperty;
    RRETURN(hr);
}

HRESULT
CNDSProperty::CreateProperty(
    BSTR   bstrParent,
    BSTR   bstrName,
    NDS_CONTEXT_HANDLE hADsContext,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    DWORD dwStatus = 0;
    HRESULT hr = S_OK;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    DWORD dwNumberOfEntries = 0;
    DWORD dwInfoType = 0;
    HANDLE hOperationData = NULL;

    hr = ADsNdsReadAttrDef(
                    hADsContext,
                    DS_ATTR_DEFS,
                    &bstrName,
                    1,
                    &hOperationData
                    );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsGetAttrDefListFromBuffer(
                    hADsContext,
                    hOperationData,
                    &dwNumberOfEntries,
                    &dwInfoType,
                    &lpAttrDefs
                    );
    BAIL_ON_FAILURE(hr);

    if (!lpAttrDefs) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CNDSProperty::CreateProperty(
                bstrParent,
                bstrName,
                lpAttrDefs,
                Credentials,
                dwObjectState,
                riid,
                ppvObj
                );


error:
    if (hOperationData) {
        ADsNdsFreeBuffer(hOperationData);
    }

    ADsNdsFreeAttrDefList(lpAttrDefs, dwNumberOfEntries);

    RRETURN(hr);
}

STDMETHODIMP
CNDSProperty::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CNDSProperty::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSProperty::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CNDSProperty::AllocatePropertyObject(
    CNDSProperty FAR * FAR * ppProperty
    )
{
    CNDSProperty FAR *pProperty = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CNDSProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADsProperty,
            (IADsProperty *) pProperty,
            DISPID_REGULAR
            );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}


STDMETHODIMP
CNDSProperty::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CNDSProperty::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSProperty::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CNDSProperty::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


/* IADsProperty methods */

STDMETHODIMP
CNDSProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    if ( !pbstrSyntax )
        RRETURN(E_ADS_BAD_PARAMETER);

    RRETURN( ADsAllocString( _bstrSyntax, pbstrSyntax ));
}

STDMETHODIMP
CNDSProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MaxRange( THIS_ long lMaxRange )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MinRange( THIS_ long lMinRange )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN(E_NOTIMPL);
}


HRESULT
MapSyntaxIdtoADsSyntax(
    DWORD dwSyntaxId,
    LPWSTR pszADsSyntax
    )
{

    if (dwSyntaxId >= g_cNDSSyntaxMap) {
        wcscpy(pszADsSyntax, L"Out of Bounds");
    }else {
        wcscpy(pszADsSyntax, g_aNDSSyntaxMap[dwSyntaxId].bstrName);
    }
    RRETURN(S_OK);

}

HRESULT
MapSyntaxIdtoNDSSyntax(
    DWORD dwSyntaxId,
    LPWSTR pszNDSSyntax
    )
{

    if (dwSyntaxId > g_cNDSSyntaxMap) {
        wcscpy(pszNDSSyntax, L"Out of Bounds");
    }else {
        wcscpy(pszNDSSyntax, g_aNDSSyntaxMap[dwSyntaxId].bstrNDSName);
    }
    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser


STDMETHODIMP CNDSUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CNDSUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CNDSUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);

}

STDMETHODIMP CNDSUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}


STDMETHODIMP CNDSUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Languages);

}

STDMETHODIMP CNDSUser::put_Languages(THIS_ VARIANT vLanguages)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Languages);
}

STDMETHODIMP CNDSUser::get_Profile(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Profile);

}

STDMETHODIMP CNDSUser::put_Profile(THIS_ BSTR bstrProfile)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CNDSUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LoginScript);

}

STDMETHODIMP CNDSUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\csedcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 NDS Security Class Factory Code
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CADsAclCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsAclCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CADsAcl::CreateSecurityDescriptor(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\csed.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  CAcl.cxx
//
//  Contents:  SecurityDescriptor object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

//  Class CAcl

DEFINE_IDispatch_Implementation(CAcl)

CAcl::CAcl():
        _pDispMgr(NULL),
        _lpProtectedAttrName(NULL),
        _lpSubjectName(NULL),
        _dwPrivileges(0)
{
    ENLIST_TRACKING(CAcl);
}


HRESULT
CAcl::CreateSecurityDescriptor(
    REFIID riid,
    void **ppvObj
    )
{
    CAcl FAR * pSecurityDescriptor = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSecurityDescriptorObject(&pSecurityDescriptor);
    BAIL_ON_FAILURE(hr);

    hr = pSecurityDescriptor->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSecurityDescriptor->Release();

    RRETURN(hr);

error:
    delete pSecurityDescriptor;

    RRETURN(hr);

}


CAcl::~CAcl( )
{
    delete _pDispMgr;
}

STDMETHODIMP
CAcl::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAcl))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CAcl::AllocateSecurityDescriptorObject(
    CAcl ** ppSecurityDescriptor
    )
{
    CAcl FAR * pSecurityDescriptor = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSecurityDescriptor = new CAcl();
    if (pSecurityDescriptor == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);
    /*
    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_NDSOle,
                IID_IADsAcl,
                (IADsAcl *)pSecurityDescriptor,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);
    */
    pSecurityDescriptor->_pDispMgr = pDispMgr;
    *ppSecurityDescriptor = pSecurityDescriptor;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

// new stuff!

STDMETHODIMP
CAcl::get_Privileges(THIS_ long FAR * retval)
{

    *retval = _dwPrivileges;
    RRETURN(S_OK);
}

STDMETHODIMP
CAcl::put_Privileges(THIS_ long lnPrivileges)
{

    _dwPrivileges = lnPrivileges;
    RRETURN(S_OK);
}


STDMETHODIMP
CAcl::get_SubjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpSubjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CAcl::put_SubjectName(THIS_ BSTR bstrSubjectName)
{

    if (!bstrSubjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpSubjectName) {
        FreeADsStr(_lpSubjectName);
    }

    _lpSubjectName= AllocADsStr(bstrSubjectName);

    if (!_lpSubjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CAcl::get_ProtectedAttrName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpProtectedAttrName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CAcl::put_ProtectedAttrName(THIS_ BSTR bstrProtectedAttrName)
{

    if (!bstrProtectedAttrName) {
        RRETURN(E_FAIL);
    }

    if (_lpProtectedAttrName) {
        FreeADsStr(_lpProtectedAttrName);
    }

    _lpProtectedAttrName= AllocADsStr(bstrProtectedAttrName);

    if (!_lpProtectedAttrName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CAcl::CopyAcl(THIS_ IDispatch FAR * FAR * ppAcl)
{

    HRESULT hr = S_OK;
    IADsAcl * pSecDes = NULL;

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(_dwPrivileges);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(_lpSubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(_lpProtectedAttrName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, 
                                 (void**)ppAcl);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ctree.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomain.cxx
//
//  Contents:  Microsoft ADs NDS Provider Tree Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSTree

DEFINE_IDispatch_Implementation(CNDSTree)
DEFINE_IADs_Implementation(CNDSTree)


CNDSTree::CNDSTree():
                _pPropertyCache(NULL)
{

    VariantInit(&_vFilter);
    _hADsContext = NULL;
    _pszNDSTreeName = _pszNDSDn = NULL;

    ENLIST_TRACKING(CNDSTree);
}

HRESULT
CNDSTree::CreateTreeObject(
    BSTR bstrADsPath,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                szADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CNDSTree::CreateTreeObject(
                 szADsParent,
                 szCommonName,
                 L"user",
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );
    RRETURN(hr);
}


HRESULT
CNDSTree::CreateTreeObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSTree FAR * pTree = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTree(Credentials, &pTree);
    BAIL_ON_FAILURE(hr);

    hr = pTree->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_NDSTree,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                pTree->_ADsPath,
                &(pTree->_pszNDSTreeName),
                &(pTree->_pszNDSDn)
                );
    BAIL_ON_FAILURE(hr);

    hr  = ADsNdsOpenContext(
               pTree->_pszNDSTreeName,
               Credentials,
               &(pTree->_hADsContext)
               );
    BAIL_ON_FAILURE(hr);

    hr = pTree->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTree->Release();

    RRETURN(hr);

error:

    delete pTree;
    RRETURN(hr);
}

CNDSTree::~CNDSTree( )
{
    VariantClear(&_vFilter);

    if (_hADsContext) {
        ADsNdsCloseContext(_hADsContext);
    }

    if (_pszNDSTreeName) {
        FreeADsMem(_pszNDSTreeName);
    }

    if (_pszNDSDn) {
        FreeADsMem(_pszNDSDn);
    }

    delete _pDispMgr;

    delete _pPropertyCache;
}

STDMETHODIMP
CNDSTree::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSTree::SetInfo()
{
    DWORD dwStatus = 0L;
    WCHAR szNDSPathName[MAX_PATH];
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = NDSCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = NDSSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
CNDSTree::NDSSetObject()
{
    NDS_BUFFER_HANDLE hOperationData = NULL;
    HRESULT hr = S_OK;


    hr = ADsNdsCreateBuffer(
                        _hADsContext,
                        DSV_MODIFY_ENTRY,
                        &hOperationData
                        );             
    BAIL_ON_FAILURE(hr);

    hr = _pPropertyCache->NDSMarshallProperties(
                            _hADsContext,
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsModifyObject(
                    _hADsContext,
                    _pszNDSDn,
                    hOperationData
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (hOperationData) {

        ADsNdsFreeBuffer(hOperationData);
    }

    RRETURN(hr);
}

HRESULT
CNDSTree::NDSCreateObject()
{
    NDS_BUFFER_HANDLE hOperationData = NULL;
    HRESULT hr = S_OK;
    BOOLEAN fUserObject = FALSE;
    BSTR bstrClass = NULL;

    hr = ADsNdsCreateBuffer(
                        _hADsContext,
                        DSV_ADD_ENTRY,
                        &hOperationData
                        );             
    BAIL_ON_FAILURE(hr);

    hr = get_CoreADsClass(&bstrClass);
    if (SUCCEEDED(hr)) {
        if (_wcsicmp(bstrClass, L"user") == 0) {
            fUserObject = TRUE;
        }
    }

    hr = _pPropertyCache->NDSMarshallProperties(
                            _hADsContext,
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsAddObject(
                    _hADsContext,
                    _pszNDSDn,
                    hOperationData
                    );
    BAIL_ON_FAILURE(hr);

    if (fUserObject) {
        hr = ADsNdsGenObjectKey(_hADsContext,
                                _pszNDSDn);     
        BAIL_ON_FAILURE(hr);
    }

error:
    if (bstrClass) {
        ADsFreeString(bstrClass);
    }
    if (hOperationData) {

        ADsNdsFreeBuffer(hOperationData);
    }

    RRETURN(hr);
}

HRESULT
CNDSTree::GetInfo()
{
    RRETURN(GetInfo(TRUE));
}

HRESULT
CNDSTree::GetInfo(
    BOOL fExplicit
    )
{
    NDS_CONTEXT_HANDLE hADsContext = NULL;
    HRESULT hr = S_OK;
    PNDS_ATTR_INFO lpEntries = NULL;
    DWORD dwNumEntries = 0, i = 0;


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsNdsReadObject(
                _hADsContext,
                _pszNDSDn,
                DS_ATTRIBUTE_VALUES,
                NULL,
                (DWORD) -1, // signifies all attributes need to be returned
                NULL,
                &lpEntries,
                &dwNumEntries
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwNumEntries; i++) {

        //
        // unmarshall this property into the
        // property cache
        //
        //

        hr = _pPropertyCache->unmarshallproperty(
                    lpEntries[i].szAttributeName,
                    lpEntries[i].lpValue,
                    lpEntries[i].dwNumberOfValues,
                    lpEntries[i].dwSyntaxId,
                    fExplicit
                    );

        CONTINUE_ON_FAILURE(hr);

    }


error:

    FreeNdsAttrInfo( lpEntries, dwNumEntries );

    RRETURN(hr);
}

STDMETHODIMP
CNDSTree::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSTree::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::get_Filter(THIS_ VARIANT FAR* pVar)
{
    VariantInit(pVar);
    RRETURN(VariantCopy(pVar, &_vFilter));
}

STDMETHODIMP
CNDSTree::put_Filter(THIS_ VARIANT Var)
{
    VariantClear(&_vFilter);
    RRETURN(VariantCopy(&_vFilter, &Var));
}

STDMETHODIMP
CNDSTree::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CNDSTree::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                FALSE
                );

    RRETURN(hr);

}

STDMETHODIMP
CNDSTree::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSTreeEnum::Create(
                (CNDSTreeEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSTree::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs * pADs  = NULL;
    VARIANT var;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwSyntaxId = 0;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //


    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IDispatch,
                    (void **)ppObject
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

STDMETHODIMP
CNDSTree::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = S_OK;
    BSTR bstrChildPath = NULL;
    LPWSTR pszNDSTreeName = NULL;
    LPWSTR pszChildNDSDn = NULL;

    LPWSTR ppszAttrs[] = {L"object Class"};
    PNDS_ATTR_INFO pAttrEntries = NULL;
    DWORD dwNumEntries = 0;
    LPWSTR pszObjectClassName = NULL;

    hr = BuildADsPath(
                _ADsPath,
                bstrRelativeName,
                &bstrChildPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                bstrChildPath,
                &pszNDSTreeName,
                &pszChildNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsReadObject(
                _hADsContext,
                pszChildNDSDn,
                DS_ATTRIBUTE_VALUES,
                ppszAttrs,
                1,
                NULL,
                &pAttrEntries,
                &dwNumEntries
                );
    BAIL_ON_FAILURE(hr);

    if (dwNumEntries != 1) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    pszObjectClassName = (pAttrEntries[0].lpValue) ? 
                             pAttrEntries[0].lpValue[0].NdsValue.value_20.ClassName : 
                              NULL;

    if (!pszObjectClassName) {
        BAIL_ON_FAILURE(E_FAIL);
    }

    if (_wcsicmp(pszObjectClassName, bstrClassName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsNdsRemoveObject(
             _hADsContext,
             pszChildNDSDn
             );
    BAIL_ON_FAILURE(hr);

error:

    if (bstrChildPath) {
        SysFreeString(bstrChildPath);
    }

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);

    }

    if (pszChildNDSDn) {
        FreeADsStr(pszChildNDSDn);

    }

    if (pAttrEntries) {
        FreeNdsAttrInfo(pAttrEntries, dwNumEntries);
    }

    RRETURN(hr);
}

STDMETHODIMP
CNDSTree::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CNDSTree::AllocateTree(
    CCredentials& Credentials,
    CNDSTree ** ppTree
    )
{
    CNDSTree FAR * pTree = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pTree = new CNDSTree();
    if (pTree == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pTree,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pTree,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pTree,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);



    pTree->_Credentials = Credentials;
    pTree->_pPropertyCache = pPropertyCache;
    pTree->_pDispMgr = pDispMgr;
    *ppTree = pTree;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSTree::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                FALSE
                );

    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSTree::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
CNDSTree::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}














































































STDMETHODIMP
CNDSTree::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              I
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           I
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              I
//        PROPERTY_RW(IsAdmin, boolean, 8)                      I
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   I
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           I
//        PROPERTY_RW(MaxLogins, long, 11)                      I
//        PROPERTY_RW(MaxStorage, long, 12)                     I
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         I
//        PROPERTY_RW(PasswordRequired, boolean, 14)            I
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        I
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser

STDMETHODIMP
CNDSUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNDSUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}


STDMETHODIMP
CNDSUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNDSUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNDSUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}


STDMETHODIMP
CNDSUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNDSUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNDSUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNDSUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{
   GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, IsAccountLocked);
}

STDMETHODIMP
CNDSUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, IsAccountLocked);
}

STDMETHODIMP
CNDSUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{ 
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CNDSUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{ 
    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CNDSUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}


STDMETHODIMP
CNDSUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CNDSUser::get_MaxLogins(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNDSUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNDSUser::get_MaxStorage(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}


STDMETHODIMP
CNDSUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}

STDMETHODIMP
CNDSUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNDSUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNDSUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNDSUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNDSUser::get_PasswordMinimumLength(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNDSUser::put_PasswordMinimumLength(THIS_ LONG lPasswordMinimumLength)
{
    PUT_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNDSUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNDSUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNDSUser::ChangePassword(
    THIS_ BSTR bstrOldPassword,
    BSTR bstrNewPassword
    )
{
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL, bstrName = NULL;
    LPWSTR pszNDSTreeName = NULL, pszNDSDn = NULL;
    NDS_CONTEXT_HANDLE hADsContext = NULL;

    hr = _pADs->get_ADsPath(
                    &bstrADsPath
                    );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_Name(
                    &bstrName
                    );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                bstrADsPath,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr  = ADsNdsOpenContext(
              pszNDSTreeName,
              _Credentials,
              &hADsContext
              );
    BAIL_ON_FAILURE(hr);


    hr = ADsNdsChangeObjectPassword(
                    hADsContext,
//                    bstrName,
                    pszNDSDn,
                    OT_USER,
                    bstrOldPassword,
                    bstrNewPassword
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (hADsContext) {
        ADsNdsCloseContext(hADsContext);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    FreeADsMem(pszNDSDn);
    FreeADsMem(pszNDSTreeName);

    RRETURN(hr);
}

STDMETHODIMP
CNDSUser::SetPassword(THIS_ BSTR NewPassword)
{
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL, bstrName = NULL;
    LPWSTR pszNDSTreeName = NULL, pszNDSDn = NULL;
    NDS_CONTEXT_HANDLE hADsContext = NULL;

    hr = _pADs->get_ADsPath(
                    &bstrADsPath
                    );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_Name(
                    &bstrName
                    );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath2(
                bstrADsPath,
                &pszNDSTreeName,
                &pszNDSDn
                );
    BAIL_ON_FAILURE(hr);

    hr  = ADsNdsOpenContext(
              pszNDSTreeName,
              _Credentials,
              &hADsContext
              );
    BAIL_ON_FAILURE(hr);


    hr = ADsNdsChangeObjectPassword(
                    hADsContext,
//                    bstrName,
                    pszNDSDn,
                    OT_USER,
                    NULL,
                    NewPassword
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (hADsContext) {
        ADsNdsCloseContext(hADsContext);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    FreeADsMem(pszNDSDn);
    FreeADsMem(pszNDSTreeName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for NDS guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// NDSOle CLSIDs
//
//-------------------------------------------


//
// NDSOle objects
//

extern const CLSID LIBID_NDSOle;

extern const CLSID CLSID_NDSNamespace;

extern const CLSID CLSID_NDSGenObject;

extern const CLSID CLSID_NDSProvider;

extern const CLSID CLSID_NDSTree;

extern const CLSID CLSID_NDSSchema;

extern const CLSID CLSID_NDSClass;

extern const CLSID CLSID_NDSProperty;

extern const CLSID CLSID_NDSSyntax;

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FaxNumber, BSTR, 7)                 NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(Initials, BSTR, 10)                 NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(NickName, BSTR, 13)                 NI
//      PROPERTY_RW(OfficeLocations, BSTR, 14)          NI
//      PROPERTY_RW(Picture, VARIANT, 15)               NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


STDMETHODIMP
CNDSUser::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CNDSUser::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CNDSUser::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CNDSUser::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CNDSUser::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CNDSUser::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CNDSUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CNDSUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}


STDMETHODIMP
CNDSUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CNDSUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CNDSUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNDSUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNDSUser::get_LastName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CNDSUser::put_LastName(THIS_ BSTR bstrLastName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CNDSUser::get_Manager(THIS_ BSTR FAR* retval)
{
     GET_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CNDSUser::put_Manager(THIS_ BSTR bstrManager)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CNDSUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CNDSUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocation)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CNDSUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, PictureIcon);
}

STDMETHODIMP
CNDSUser::put_Picture(THIS_ VARIANT vPictureIcon)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, PictureIcon);
}

STDMETHODIMP
CNDSUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CNDSUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CNDSUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CNDSUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CNDSUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CNDSUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CNDSUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CNDSUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CNDSUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CNDSUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CNDSUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CNDSUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CNDSUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CNDSUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CNDSUser::get_Title(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CNDSUser::put_Title(THIS_ BSTR bstrTitle)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Title);
}


STDMETHODIMP CNDSUser::Groups(THIS_ IADsMembers FAR*  FAR * ppGroups)
{
    VARIANT varProp;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    VariantInit(&varProp);

    hr = _pADs->GetEx(L"Group Membership", &varProp);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        SAFEARRAY *aList = NULL;

        VariantInit(&varProp);
    
        SAFEARRAYBOUND aBound;
    
        aBound.lLbound = 0;
        aBound.cElements = 0;
    
        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    
        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        V_VT(&varProp) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&varProp) = aList;
    }
    else {
        BAIL_ON_FAILURE(hr);
    }

    hr = _pADs->get_ADsPath(&bstrADsPath);

    hr = CNDSUserCollection::CreateUserCollection(
                    bstrADsPath,
                    varProp,
                    IID_IADsMembers,
                    (void **)ppGroups
                    );

    BAIL_ON_FAILURE(hr);

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    VariantClear(&varProp);

    RRETURN(hr);
}
STDMETHODIMP CNDSUser::get_HomePage(THIS_ BSTR FAR* retval)
{
    RRETURN(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    RRETURN(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    RRETURN(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::put_NameSuffix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    RRETURN(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  getobj.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

extern LPWSTR szProviderName;

//+---------------------------------------------------------------------------
//  Function:   RelativeGetObject
//
//  Synopsis:   Gets object relative to given Active Directory path.
//
//  Arguments:  [BSTR ADsPath]
//              [BSTR ClassName]
//              [BSTR RelativeName]
//              [IUnknown** ppObject]
//              [BOOT bNamespaceRelative]
//
//  Returns:    HRESULT
//
//  Modifies:   *ppObject
//
//  History:    08-02-96   t-danal     Created as such.
//
//----------------------------------------------------------------------------
HRESULT
RelativeGetObject(
    BSTR ADsPath,
    BSTR ClassName,
    BSTR RelativeName,
    CCredentials& Credentials,
    IDispatch * FAR* ppObject,
    BOOL bNamespaceRelative
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    *ppObject = NULL;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    wcscpy(szBuffer, ADsPath);

    if (bNamespaceRelative)
        wcscat(szBuffer, L"//");
    else
        wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR szBuffer,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    DWORD dwStatus = NO_ERROR;

    LPWSTR pszNDSTreeName = NULL;
    LPWSTR pszNDSDn = NULL;

    WCHAR szParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];

    LPWSTR pszObjectClassName = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);

    NDS_CONTEXT_HANDLE hADsContext = NULL;
    IADs * pADs = NULL;

    NWDSCCODE ccode;
    PNDS_CONTEXT pADsContext;
    NWDSContextHandle context;
    Object_Info_T ObjInfo;
    WCHAR ObjectDN[MAX_DN_CHARS+1]; 


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is @NDS!
    //

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateObjectType(pObjectInfo);

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_SCHEMA:

        hr = GetSchemaObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;


    default:
        hr = BuildNDSPathFromADsPath2(
                    szBuffer,
                    &pszNDSTreeName,
                    &pszNDSDn
                    );
        BAIL_ON_FAILURE(hr);

        hr  = ADsNdsOpenContext(
                   pszNDSTreeName,
                   Credentials,
                   &hADsContext
                   );
        BAIL_ON_FAILURE(hr);


        pADsContext = (PNDS_CONTEXT) hADsContext;
        context = pADsContext->hContext;

        ccode = NWDSReadObjectInfo(
                   context,
                   (pnstr8) (!pszNDSDn || (*pszNDSDn == L'\0') ? L"[Root]" : pszNDSDn),
                   (pnstr8) ObjectDN,
                   &ObjInfo);

        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        pszObjectClassName = (LPWSTR) ObjInfo.baseClass;


        if (!pszObjectClassName) {
            BAIL_ON_FAILURE(E_FAIL);
        }

        hr = BuildADsParentPath(
                    szBuffer,
                    szParent,
                    szCommonName
                    );
        BAIL_ON_FAILURE(hr);

        hr = CNDSGenObject::CreateGenericObject(
                        szParent,
                        szCommonName,
                        pszObjectClassName,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
        BAIL_ON_FAILURE(hr);

        // InstantiateDerivedObject should add-ref this pointer for us.
        //

        hr = InstantiateDerivedObject(
                        pADs,
                        Credentials,
                        IID_IUnknown,
                        (void **)ppObject
                        );

        if (FAILED(hr)) {
            hr = pADs->QueryInterface(
                            IID_IUnknown,
                            ppObject
                            );
            BAIL_ON_FAILURE(hr);

        }

        break;

    }

error:

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);
    }

    if (pszNDSDn) {
        FreeADsStr(pszNDSDn);
    }

    if (pADs) {
        pADs->Release();
    }

    if (hADsContext) {
        ADsNdsCloseContext( hADsContext );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);
}

HRESULT
BuildADsPathFromNDSPath(
    LPWSTR szNDSTreeName,
    LPWSTR szNDSDNName,
    LPWSTR *ppszADsPath
    )
{
    PKEYDATA pKeyData = NULL;
    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR pszDisplayTreeName = NULL;
    LPWSTR pszDisplayDNName = NULL;
    LPWSTR pszTemp = NULL;
    HRESULT hr = S_OK;

    if (!szNDSTreeName || !szNDSDNName || !ppszADsPath) {
        RRETURN(E_FAIL);
    }

    *ppszADsPath = NULL;

    hr = GetDisplayName(
             szNDSTreeName,
             &pszDisplayTreeName
             );
    BAIL_ON_FAILURE(hr);

    pszTemp = (LPWSTR) AllocADsMem(
                           (wcslen(szProviderName) + 
                           wcslen(L"://") +
                           wcslen(szNDSTreeName) + 
                           wcslen(L"/") +
                           wcslen(szNDSDNName) + 
                           1) * sizeof(WCHAR)
                           );
    if (!pszTemp) {
        BAIL_ON_FAILURE(hr);
    }

    wsprintf(pszTemp,L"%s://%s", szProviderName, szNDSTreeName);

    hr = GetDisplayName(
             szNDSDNName,
             &pszDisplayDNName
             );
    BAIL_ON_FAILURE(hr);

    pKeyData = CreateTokenList(
                    pszDisplayDNName,
                    L'.'
                    );

    if (pKeyData) {

        dwCount = pKeyData->cTokens;
        for (i = 0; i < dwCount; i++) {
            wcscat(pszTemp, L"/");
            wcscat(pszTemp, pKeyData->pTokens[dwCount - 1 - i]);
        }
    }

    if (pKeyData) {
        FreeADsMem(pKeyData);
    }

    *ppszADsPath = pszTemp;

error:

    if (pszDisplayTreeName) {
        FreeADsMem(pszDisplayTreeName);
    }

    if (pszDisplayDNName) {
        FreeADsMem(pszDisplayDNName);
    }

    RRETURN(hr);
}


HRESULT
BuildNDSPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR * pszNDSPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;
    LPWSTR szNDSPathName = NULL;


    *pszNDSPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    szNDSPathName = AllocADsStr(szADsPathName);
    if (!szNDSPathName) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(szNDSPathName, L"\\\\");
    wcscat(szNDSPathName, pObjectInfo->TreeName);

    if (dwNumComponents) {

        wcscat(szNDSPathName, L"\\");

        for (i = dwNumComponents; i >  0; i--) {

            AppendComponent(
                    szNDSPathName,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

            if ((i - 1) > 0){
                wcscat(szNDSPathName, L".");
            }
        }

    }

    *pszNDSPathName = szNDSPathName;

error:

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}

HRESULT
AppendComponent(
   LPWSTR szNDSPathName,
   PCOMPONENT pComponent
   )
{
    if (pComponent->szComponent && pComponent->szValue) {
        wcscat(szNDSPathName, pComponent->szComponent);
        wcscat(szNDSPathName,L"=");
        wcscat(szNDSPathName, pComponent->szValue);

    }else if (pComponent->szComponent && !pComponent->szValue) {
        wcscat(szNDSPathName, pComponent->szComponent);
    }else {
        //
        // we should never hit this case
        //
    }

    RRETURN(S_OK);
}



HRESULT
BuildADsParentPath(
    LPWSTR szBuffer,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPath(
             pObjectInfo, 
             szParent, 
             szCommonName
             );

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
// Function:    GetNamespaceObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;

    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    hr = CNDSNamespace::CreateNamespace(
                L"ADs:",
                L"NDS:",
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                ppObject
                );


error:

    RRETURN(hr);
}

HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (!_wcsicmp(pObjectInfo->ProviderName, szProviderName)) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}



//+---------------------------------------------------------------------------
// Function:    GetSchemaObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwObjectType = 0;
    WCHAR szParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];

    NDS_CONTEXT_HANDLE hADsContext = NULL;

    hr = ValidateSchemaObject(
                pObjectInfo,
                &dwObjectType
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPath(
             pObjectInfo,
             szParent,
             szCommonName
             );
    BAIL_ON_FAILURE(hr);

    switch(dwObjectType) {
    case NDS_CLASS_ID:
    case NDS_PROPERTY_ID:
    case NDS_CLASSPROP_ID:

        hr  = ADsNdsOpenContext(
                   pObjectInfo->TreeName,
                   Credentials,
                   &hADsContext
                   );
        BAIL_ON_FAILURE(hr);

        break;

    default:
        break;
    }

    //
    // Note: The "error:" tag is at the end of the switch statement,
    //       so we can simply break out.
    //

    switch (dwObjectType) {
    case NDS_SCHEMA_ID:
        hr = CNDSSchema::CreateSchema(
                    szParent,
                    szCommonName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    case NDS_CLASSPROP_ID:
        hr = CNDSClass::CreateClass(
                    szParent,
                    szCommonName,
                    hADsContext,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        if (FAILED(hr)) {

            hr = CNDSProperty::CreateProperty(
                        szParent,
                        szCommonName,
                        hADsContext,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IUnknown,
                        ppObject
                        );
            BAIL_ON_FAILURE(hr);

        }
        break;

    case NDS_CLASS_ID:
        hr = CNDSClass::CreateClass(
                    szParent,
                    szCommonName,
                    hADsContext,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    case NDS_PROPERTY_ID:
        hr = CNDSProperty::CreateProperty(
                    szParent,
                    szCommonName,
                    hADsContext,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    default:
        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

error:
    if (hADsContext) {
        ADsNdsCloseContext(hADsContext);
    }
    RRETURN(hr);
}

HRESULT
ValidateSchemaObject(
    POBJECTINFO pObjectInfo,
    PDWORD pdwObjectType
    )
{
    DWORD dwNumComponents = 0;

    dwNumComponents = pObjectInfo->NumComponents;




    switch (dwNumComponents) {

    case 1:
        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent, L"schema")) {
            *pdwObjectType = NDS_SCHEMA_ID;
            RRETURN(S_OK);
        }
        break;

    case 2:

        if (pObjectInfo->ClassName) {
            if (!_wcsicmp(pObjectInfo->ClassName, L"Property")) {
                *pdwObjectType = NDS_PROPERTY_ID;
            }
            else {
                *pdwObjectType = NDS_CLASS_ID;
            }
        }
        else {
            *pdwObjectType = NDS_CLASSPROP_ID;
        }
        RRETURN(S_OK);

    default:
        break;

    }

    RRETURN(E_FAIL);
}

HRESULT
BuildADsParentPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;

    dwNumComponents = pObjectInfo->NumComponents;

    if (!dwNumComponents && !pObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(szParent,L"ADs:");

        RRETURN(S_OK);

    } else if (!dwNumComponents && pObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @NDS! object

        wsprintf(szParent, L"%s:", pObjectInfo->ProviderName);

        //
        // And the common name is the TreeName. Remember the
        // "//" will be added on  when we reconstruct the full
        // pathname
        //

        wsprintf(szCommonName,L"%s", pObjectInfo->DisplayTreeName);


        RRETURN(S_OK);


    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(
            szParent, L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->DisplayTreeName
            );

        for (i = 0; i < dwNumComponents - 1; i++) {

            wcscat(szParent, L"/");

            AppendComponent(szParent, &(pObjectInfo->DisplayComponentArray[i]));

        }

        //
        // And the common name is the last component
        //

        szCommonName[0] = '\0';
        AppendComponent(szCommonName, &(pObjectInfo->DisplayComponentArray[dwNumComponents-1]));
    }

    RRETURN(S_OK);
}


HRESULT
ValidateObjectType(
    POBJECTINFO pObjectInfo
    )
{

    pObjectInfo->ObjectType = TOKEN_NDSOBJECT;

    if (pObjectInfo->ProviderName && !pObjectInfo->TreeName
            && !pObjectInfo->NumComponents) {
        pObjectInfo->ObjectType = TOKEN_NAMESPACE;
    }else if (pObjectInfo->ProviderName && pObjectInfo->TreeName
                && pObjectInfo->NumComponents) {

        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"schema")) {
            pObjectInfo->ObjectType = TOKEN_SCHEMA;
        }

    }

    RRETURN(S_OK);
}




HRESULT
BuildNDSTreeNameFromADsPath(
    LPWSTR szBuffer,
    LPWSTR szNDSTreeName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    DWORD dwNumComponents = 0;
    HRESULT hr;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;


    if (!dwNumComponents && !pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        hr = E_FAIL;

    } else if (!dwNumComponents && pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @NDS! object

        wsprintf(szNDSTreeName,L"\\\\%s", pObjectInfo->TreeName);


        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(szNDSTreeName,L"\\\\%s", pObjectInfo->TreeName);

        hr = S_OK;
    }

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);

}



HRESULT
BuildNDSPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR szNDSTreeName,
    LPWSTR szNDSPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    wcscpy(szNDSTreeName, L"\\\\");
    wcscat(szNDSTreeName, pObjectInfo->TreeName);

    *szNDSPathName = L'\0';

    if (dwNumComponents) {

        for (i = dwNumComponents; i >  0; i--) {

            AppendComponent(
                    szNDSPathName,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

            if ((i - 1) > 0){
                wcscat(szNDSPathName, L".");
            }
        }

    }

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    FreeADsStr( pObjectInfo->ProviderName );
    FreeADsStr( pObjectInfo->TreeName );
    FreeADsStr( pObjectInfo->DisplayTreeName );
    FreeADsStr( pObjectInfo->ClassName);
    
    for ( DWORD i = 0; i < pObjectInfo->NumComponents; i++ ) {
        FreeADsStr( pObjectInfo->ComponentArray[i].szComponent );
        FreeADsStr( pObjectInfo->ComponentArray[i].szValue );
        FreeADsStr( pObjectInfo->DisplayComponentArray[i].szComponent );
        FreeADsStr( pObjectInfo->DisplayComponentArray[i].szValue );
    }

    // We don't need to free pObjectInfo since the object is always a static
    // variable on the stack.
}


HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;
    BOOL fQuotingOn = FALSE;

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;
    fQuotingOn = FALSE;

    for (len=0; *pch; pch++, len++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            len++;
        }
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName; 
    pszDisplayCh = pszDisplay;
    fQuotingOn = FALSE;

    for (; *pch; pch++, pszDisplayCh++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            *pszDisplayCh++ = L'\\';
        }
        *pszDisplayCh = *pch;
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}                                


HRESULT
BuildNDSPathFromADsPath2(
    LPWSTR szADsPathName,
    LPWSTR * pszTreeName,
    LPWSTR * pszDn
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;
    LPWSTR szTreeName = NULL;
    LPWSTR szDn = NULL;


    *pszTreeName = NULL;
    *pszDn = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    szTreeName = AllocADsStr(pObjectInfo->TreeName);

    szDn = AllocADsStr(szADsPathName);

    szDn[0] = L'\0';

    if (!szDn) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (dwNumComponents) {

        for (i = dwNumComponents; i >  0; i--) {

            AppendComponent(
                    szDn,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

            if ((i - 1) > 0){
                wcscat(szDn, L".");
            }
        }

    }

    *pszTreeName = szTreeName;
    *pszDn = szDn;

error:

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cuser.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aUserPropMapping[] =
{
  //{ TEXT("BadLoginCount"), TEXT("badPwdCount") },
  { TEXT("LastLogin"), TEXT("Last Login Time") },
  //{ TEXT("LastLogoff"), TEXT("lastLogoff") },
  //{ TEXT("LastFailedLogin"), TEXT("badPasswordTime") },
  //{ TEXT("PasswordLastChanged"), TEXT("pwdLastSet") },
  { TEXT("Description"), TEXT("Description") },
  //{ TEXT("Division"), TEXT("division") },
  //{ TEXT("Department"), TEXT("department") },
  //{ TEXT("EmployeeID"), TEXT("employeeID") },
  { TEXT("FullName"), TEXT("Full Name") },
  { TEXT("FirstName"), TEXT("Given Name") },
  { TEXT("LastName"), TEXT("Surname") },
  //{ TEXT("OtherName"), TEXT("middleName") },
  //{ TEXT("NamePrefix"), TEXT("personalTitle") },
  { TEXT("NameSuffix"), TEXT("Generational Qualifier") },
  { TEXT("Title"), TEXT("Title") },
  //{ TEXT("Manager"), TEXT("manager") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  //{ TEXT("TelephoneHome"), TEXT("homePhone") },
  //{ TEXT("TelephoneMobile"), TEXT("mobile") },
  //{ TEXT("TelephonePager"), TEXT("pager") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("OfficeLocations"), TEXT("Physical Delivery Office Name") },
  { TEXT("PostalAddresses"), TEXT("Postal Address") },
  { TEXT("PostalCodes"), TEXT("Postal Code") },
  { TEXT("SeeAlso"), TEXT("See Also") },
  //{ TEXT("AccountExpirationDate"), TEXT("accountExpires") },
  { TEXT("LoginHours"), TEXT("Login Allowed Time Map") },
  //{ TEXT("LoginWorkstations"), TEXT("logonWorkstation") },
  //{ TEXT("MaxStorage"), TEXT("maxStorage") },
  { TEXT("PasswordExpirationDate"), TEXT("Password Expiration Time") },
  { TEXT("PasswordMinimumLength"), TEXT("Password Minimum Length") },
  { TEXT("RequireUniquePassword"), TEXT("Password Unique Required") },
  { TEXT("EmailAddress"), TEXT("Email Address") },
  { TEXT("HomeDirectory"), TEXT("Home Directory") },
  { TEXT("Languages"), TEXT("Language") },
  { TEXT("Profile"), TEXT("Profile") },
  { TEXT("PasswordRequired"), TEXT("Password Required") },
  { TEXT("AccountDisabled"), TEXT("Login Disabled") },
  { TEXT("GraceLoginsAllowed"), TEXT("Login Grace Limit") },
  { TEXT("GraceLoginsRemaining"), TEXT("Login Grace Remaining") },
  { TEXT("LoginScript"), TEXT("Login Script") }
  //{ TEXT("HomePage"), TEXT("url") }
};

DWORD dwNumUserPropMapping = sizeof(aUserPropMapping)/sizeof(_propmap);


//  Class CNDSUser

DEFINE_IDispatch_Implementation(CNDSUser)
DEFINE_CONTAINED_IADs_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSUser)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSUser)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSUser,aUserPropMapping)

CNDSUser::CNDSUser():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSAttrMgmt(NULL),
        _pDispMgr(NULL),
        _pADsPropList(NULL)
{
    ENLIST_TRACKING(CNDSUser);
}

HRESULT
CNDSUser::CreateUser(
    IADs *pADs,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSUser FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserObject(pADs, Credentials, &pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();

    RRETURN(hr);

error:
    delete pUser;

    RRETURN(hr);

}


CNDSUser::~CNDSUser( )
{

    if (_pADs) {
        _pADs->Release();
    }

    if (_pDSObject) {
        _pDSObject->Release();
    }
    if (_pDSSearch) {
        _pDSSearch->Release();
    }
    if (_pADsPropList) {
        _pADsPropList->Release();
    }
    if (_pDSAttrMgmt) {
        _pDSAttrMgmt->Release();
    }

    delete _pDispMgr;
}


STDMETHODIMP
CNDSUser::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUser))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSUser::AllocateUserObject(
    IADs * pADs,
    CCredentials& Credentials,
    CNDSUser ** ppUser
    )
{
    CNDSUser FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSAttrMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pUser = new CNDSUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsUser,
                (IADsUser *)pUser,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSObject = pDSObject;


    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pADsPropList = pADsPropList;


    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSAttrMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSAttrMgmt = pDSAttrMgmt;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pUser->_pADs  = pADs;
    pADs->AddRef();


    pUser->_Credentials = Credentials;
    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pUser;

    *ppUser = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cUser.cxx
//
//  Contents:  User object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "nds.hxx"

//  Class CNDSUserCollection

DEFINE_IDispatch_Implementation(CNDSUserCollection)


CNDSUserCollection::CNDSUserCollection():
        _ADsPath(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNDSUserCollection);
}


HRESULT
CNDSUserCollection::CreateUserCollection(
    BSTR bstrADsPath,
    VARIANT varMembers,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSUserCollection FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserCollectionObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(bstrADsPath, &(pUser->_ADsPath));
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&(pUser->_vMembers), &varMembers);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:
    delete pUser;

    RRETURN(hr);

}


CNDSUserCollection::~CNDSUserCollection( )
{
    VariantClear(&_vMembers);
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CNDSUserCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSUserCollection::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CNDSUserCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    VariantInit(pVar);
    RRETURN(VariantCopy(pVar, &_vFilter));
}

STDMETHODIMP
CNDSUserCollection::put_Filter(THIS_ VARIANT Var)
{
    VariantClear(&_vFilter);
    RRETURN(VariantCopy(&_vFilter, &Var));
}

STDMETHODIMP
CNDSUserCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSUserCollectionEnum::Create(
                _ADsPath,
                (CNDSUserCollectionEnum **)&penum,
                _vMembers,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}

HRESULT
CNDSUserCollection::AllocateUserCollectionObject(
    CNDSUserCollection ** ppUser
    )
{
    CNDSUserCollection FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pUser = new CNDSUserCollection();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pUser,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

WCHAR *szProviderName = L"NDS";
CRITICAL_SECTION g_ContextCritSect;
CRITICAL_SECTION  BindCacheCritSect;

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_DOMAIN, L"domain"},
    { TOKEN_USER, L"user"},
    { TOKEN_GROUP, L"group"},
    { TOKEN_COMPUTER, L"computer"},
    { TOKEN_PRINTER, L"printqueue"},
    { TOKEN_SERVICE, L"service"},
    { TOKEN_FILESERVICE, L"fileservice"},
    { TOKEN_SCHEMA, L"schema"},
    { TOKEN_CLASS, L"class"},
    { TOKEN_FUNCTIONALSET, L"functionalset"},
    { TOKEN_FUNCTIONALSETALIAS, L"functionalsetalias"},
    { TOKEN_PROPERTY, L"property"},
    { TOKEN_SYNTAX, L"syntax"},
    { TOKEN_FILESHARE, L"fileshare"}
};

CClassCache *  pgClassCache;

SYNTAXMAP g_aNDSSyntaxMap[] =

{
  /* 0 */
  { TEXT("Unmappable"),  TEXT("Unknown"),  VT_UNKNOWN},

  /* 1 */
  { TEXT("String"),  TEXT("NDS Distinguished Name"),  VT_BSTR},

  /* 2 */
  { TEXT("String"),  TEXT("NDS Case Exact String"),   VT_BSTR},

  /* 3 */
  { TEXT("String"),  TEXT("NDS Case Ignore String"),  VT_BSTR},

  /* 4 */
  { TEXT("String"),  TEXT("NDS Printable String"),    VT_BSTR},

  /* 5 */
  { TEXT("String"),  TEXT("NDS Numeric String"),      VT_BSTR},

  /* 6 */
  { TEXT("Case Ignore List"), TEXT("NDS Case Ignore List"),  VT_VARIANT},

  /* 7 */
  { TEXT("Boolean"),    TEXT("NDS Boolean"),           VT_BOOL},

  /* 8 */
  { TEXT("Integer"),    TEXT("NDS Integer"),           VT_I4},

  /* 9 */
  { TEXT("Octet"),  TEXT("NDS Octet String"),     VT_VARIANT},

  /* 10 */
  { TEXT("String"),      TEXT("NDS Telephone Number"),  VT_BSTR},

  /* 11 */
  { TEXT("FaxNumber"),  TEXT("NDS Facsimile Number"),  VT_DISPATCH},

  /* 12 */
  { TEXT("NetAddress"),  TEXT("NDS Network Address"),   VT_DISPATCH},

  /* 13 */
  { TEXT("Octet List"),  TEXT("NDS Octet List"),        VT_VARIANT},

  /* 14 */
  { TEXT("Email"),  TEXT("NDS Email Address"),     VT_DISPATCH},

  /* 15 */
  { TEXT("Path"),  TEXT("NDS Path"),              VT_DISPATCH},

  /* 16 */
  { TEXT("Replica Pointer"),  TEXT("Replica Pointer"),       VT_DISPATCH},

  /* 17 */
  { TEXT("ACL"),  TEXT("NDS Object ACL"),        VT_DISPATCH},

  /* 18 */
  { TEXT("Postal Address"),  TEXT("NDS Postal Address"),     VT_DISPATCH},

  /* 19 */
  { TEXT("Timestamp"),  TEXT("NDS Timestamp"),          VT_DISPATCH},

  /* 20 */
  { TEXT("Object Class"),      TEXT("NDS Class Name"),         VT_BSTR},

  /* 21 */
  { TEXT("Octet"),   TEXT("NDS Stream"),            VT_VARIANT},

  /* 22 */
  { TEXT("Integer"),      TEXT("NDS Counter"),           VT_I4},

  /* 23 */
  { TEXT("Back Link"),     TEXT("NDS Back Link"),       VT_DISPATCH},

  /* 24 */
  { TEXT("Time"),           TEXT("NDS Time"),             VT_DATE},

  /* 25 */
  { TEXT("Typed Name"),     TEXT("NDS Typed Name"),      VT_DISPATCH},

  /* 26 */
  { TEXT("Hold"),     TEXT("NDS Hold"),            VT_DISPATCH},

  /* 27 */
  { TEXT("Integer"),     TEXT("NDS Interval"),           VT_I4}
};

DWORD g_cNDSSyntaxMap = (sizeof(g_aNDSSyntaxMap)/sizeof(g_aNDSSyntaxMap[0]));

SYNTAXINFO g_aNDSSyntax[] =
{
  { TEXT("String"),  VT_BSTR},
  { TEXT("Case Ignore List"), VT_VARIANT},
  { TEXT("Boolean"),    VT_BOOL},
  { TEXT("Octet"),  VT_VARIANT},
  { TEXT("FaxNumber"),VT_DISPATCH},
  { TEXT("NetAddress"),  VT_DISPATCH},
  { TEXT("Octet List"),  VT_VARIANT},
  { TEXT("Email"),  VT_DISPATCH},
  { TEXT("Path"),  VT_DISPATCH},
  { TEXT("Replica Pointer"),  VT_DISPATCH},
  { TEXT("ACL"),  VT_DISPATCH},
  { TEXT("Postal Address"),  VT_DISPATCH},
  { TEXT("Timestamp"),  VT_DISPATCH},
  { TEXT("Object Class"),      VT_BSTR},
  { TEXT("Back Link"),     VT_DISPATCH},
  { TEXT("Time"),           VT_DATE},
  { TEXT("Typed Name"),     VT_DISPATCH},
  { TEXT("Hold"),     VT_DISPATCH},
  { TEXT("Integer"),  VT_I4}
};

DWORD g_cNDSSyntax = (sizeof(g_aNDSSyntax)/sizeof(g_aNDSSyntax[0]));

ADSTYPE g_MapNdsTypeToADsType[] = {
    ADSTYPE_INVALID,                            /* Unknown */                             
    ADSTYPE_DN_STRING,                          /* Distinguished Name */                  
    ADSTYPE_CASE_EXACT_STRING,                  /* Case Exact String */                   
    ADSTYPE_CASE_IGNORE_STRING,                 /* Case Ignore String */                  
    ADSTYPE_PRINTABLE_STRING,                   /* Printable String */                    
    ADSTYPE_NUMERIC_STRING,                     /* Numeric String */                      
    ADSTYPE_CASEIGNORE_LIST,                /* Case Ignore List */                    
    ADSTYPE_BOOLEAN,                            /* Boolean */                             
    ADSTYPE_INTEGER,                            /* Integer */                             
    ADSTYPE_OCTET_STRING,                       /* Octet String */                        
    ADSTYPE_CASE_IGNORE_STRING,                 /* Telephone Number */                    
    ADSTYPE_FAXNUMBER,                      /* Facsimile Telephone Number */          
    ADSTYPE_NETADDRESS,                     /* Net Address */                         
    ADSTYPE_OCTET_LIST,                     /* Octet List */                          
    ADSTYPE_EMAIL,                          /* EMail Address */                       
    ADSTYPE_PATH,                           /* Path */                                
    ADSTYPE_REPLICAPOINTER,                 /* Replica Pointer */                     
    ADSTYPE_PROV_SPECIFIC,                      /* Object ACL */                          
    ADSTYPE_POSTALADDRESS,                  /* Postal Address */                      
    ADSTYPE_TIMESTAMP,                      /* Timestamp */                           
    ADSTYPE_OBJECT_CLASS,                       /* Class Name */                          
    ADSTYPE_OCTET_STRING,                       /* Stream */                              
    ADSTYPE_INTEGER,                            /* Counter */                             
    ADSTYPE_BACKLINK,                       /* Back Link */                           
    ADSTYPE_UTC_TIME,                           /* Time */                                
    ADSTYPE_TYPEDNAME,                      /* Typed Name */                          
    ADSTYPE_HOLD,                           /* Hold */                                
    ADSTYPE_INTEGER                             /* Interval */                            
};                                                                                        


DWORD g_cMapNdsTypeToADsType = (sizeof(g_MapNdsTypeToADsType)/sizeof(g_MapNdsTypeToADsType[0]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\mapper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HRESULT
InstantiateDerivedObject(
    IADs FAR * pADs,
    CCredentials& Credentials,
    REFIID riid,
    void  ** ppObject
    )
{
    BSTR bstrClassName = NULL;
    DWORD dwObjectId = 0;
    HRESULT hr = S_OK;

    *ppObject  = NULL;

    hr = pADs->get_Class(&bstrClassName);
    BAIL_ON_FAILURE(hr);

    hr = IsValidFilter(
            bstrClassName,
            &dwObjectId,
            gpFilters,
            gdwMaxFilters
            );
    BAIL_ON_FAILURE(hr)

    switch (dwObjectId) {

    case NDS_USER_ID:
        hr = CNDSUser::CreateUser(
                        pADs,
                        Credentials,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_GROUP_ID:
        hr = CNDSGroup::CreateGroup(
                        pADs,
                        Credentials,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_LOCALITY_ID:
        hr = CNDSLocality::CreateLocality(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_O_ID:
        hr = CNDSOrganization::CreateOrganization(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;



    case NDS_OU_ID:
        hr = CNDSOrganizationUnit::CreateOrganizationUnit(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;


    case NDS_PRINTER_ID:
        hr = CNDSPrintQueue::CreatePrintQueue(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;



    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

error:
    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  NDS CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(LIBID_NDSOle,0x53E7F030L,0x7B9D,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSNamespace,0x51D11C90L,0x7B9D,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSGenObject,0x8B645280L,0x7BA4,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSProvider,0x323991F0L,0x7BAD,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSTree,0x47E94340L,0x994F,0x11CF,0xA5,0xF2,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSSchema,0x65E252B0L,0xB4C8,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSClass,0x946260E0L,0xB505,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSProperty,0x93F8FBF0L,0xB67B,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSSyntax,0x953DBC50L,0xEBDB,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(CLSID_NDSAcl,0x7AF1EFB6L,0x0869,0x11D1,0xA3,0x77,0x00,0xC0,0x4F,0xB9,0x50,0xDC);

const IID IID_INDSAcl = {0x8452d3ab,0x0869,0x11d1,{0xa3,0x77,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\nds2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

HRESULT
NdsTypeToAdsTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    struct _NDS_CI_LIST *pNdsNext = &lpNdsSrcObject->NdsValue.value_6;
    PADS_CASEIGNORE_LIST pAdsOutput = NULL;
    PADS_CASEIGNORE_LIST pAdsCurrent = NULL;

    lpAdsDestValue->dwType = ADSTYPE_CASEIGNORE_LIST;

    lpAdsDestValue->pCaseIgnoreList = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
    if (!lpAdsDestValue->pCaseIgnoreList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pAdsOutput = lpAdsDestValue->pCaseIgnoreList;

    pAdsOutput->String = AllocADsStr(pNdsNext->String);
    if (!pAdsOutput->String) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pNdsNext = pNdsNext->Next;

    while (pNdsNext) {
        pAdsCurrent = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
        if (!pAdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAdsCurrent->String = AllocADsStr(pNdsNext->String);
        if (!pAdsCurrent->String) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAdsOutput->Next = pAdsCurrent;
        pAdsOutput = pAdsCurrent;
        pNdsNext = pNdsNext->Next;
    }

    pAdsOutput->Next = NULL;
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpNdsSrcObject->NdsValue.value_7.Boolean;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLength = lpNdsSrcObject->NdsValue.value_9.Length;

    if (dwLength) {

        lpByte = (LPBYTE)AllocADsMem(dwLength);
        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (lpNdsSrcObject->NdsValue.value_9.OctetString) {
            memcpy(lpByte, lpNdsSrcObject->NdsValue.value_9.OctetString, dwLength);
        }

        lpAdsDestValue->OctetString.dwLength = dwLength;
        lpAdsDestValue->OctetString.lpValue = lpByte;

    }else {

        lpAdsDestValue->OctetString.dwLength = 0;
        lpAdsDestValue->OctetString.lpValue = NULL;

    }

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_FAXNUMBER;

    lpAdsDestValue->pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
    if (!lpAdsDestValue->pFaxNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pFaxNumber->TelephoneNumber =
                            AllocADsStr(lpNdsSrcObject->NdsValue.value_11.TelephoneNumber);

    hr = CopyOctetString(lpNdsSrcObject->NdsValue.value_11.NumberOfBits,
                         lpNdsSrcObject->NdsValue.value_11.Parameters,
                         &lpAdsDestValue->pFaxNumber->NumberOfBits,
                         &lpAdsDestValue->pFaxNumber->Parameters);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_NETADDRESS;

    lpAdsDestValue->pNetAddress = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!lpAdsDestValue->pNetAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pNetAddress->AddressType =
                            lpNdsSrcObject->NdsValue.value_12.AddressType;

    hr = CopyOctetString(lpNdsSrcObject->NdsValue.value_12.AddressLength,
                         lpNdsSrcObject->NdsValue.value_12.Address,
                         &lpAdsDestValue->pNetAddress->AddressLength,
                         &lpAdsDestValue->pNetAddress->Address);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    struct _NDS_OCTET_LIST *pNdsNext = &lpNdsSrcObject->NdsValue.value_13;
    PADS_OCTET_LIST pAdsOutput = NULL;
    PADS_OCTET_LIST pAdsCurrent = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_LIST;

    lpAdsDestValue->pOctetList = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
    if (!lpAdsDestValue->pOctetList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pAdsOutput = lpAdsDestValue->pOctetList;

    hr = CopyOctetString(pNdsNext->Length,
                         pNdsNext->Data,
                         &pAdsOutput->Length,
                         &pAdsOutput->Data);
    BAIL_ON_FAILURE(hr);
    pNdsNext = pNdsNext->Next;

    while (pNdsNext) {
        pAdsCurrent = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
        if (!pAdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        hr = CopyOctetString(pNdsNext->Length,
                             pNdsNext->Data,
                             &pAdsOutput->Length,
                             &pAdsOutput->Data);
        BAIL_ON_FAILURE(hr);
        pAdsOutput->Next = pAdsCurrent;
        pAdsOutput = pAdsCurrent;
        pNdsNext = pNdsNext->Next;
    }

    pAdsOutput->Next = NULL;
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_EMAIL;

    lpAdsDestValue->Email.Address=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_14.Address
                        );
    if (!lpAdsDestValue->Email.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->Email.Type =
                            lpNdsSrcObject->NdsValue.value_14.Type;
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_PATH;

    lpAdsDestValue->pPath = (PADS_PATH)AllocADsMem(sizeof(ADS_PATH));
    if (!lpAdsDestValue->pPath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->VolumeName =
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.VolumeName
                        );
    if (!lpAdsDestValue->pPath->VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Path=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.Path
                        );
    if (!lpAdsDestValue->pPath->Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Type =
                            lpNdsSrcObject->NdsValue.value_15.Type;
error:
    RRETURN(hr);
}



HRESULT
NdsTypeToAdsTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_REPLICAPOINTER;

    lpAdsDestValue->pReplicaPointer = (PADS_REPLICAPOINTER)AllocADsMem(sizeof(ADS_REPLICAPOINTER));
    if (!lpAdsDestValue->pReplicaPointer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ServerName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_16.ServerName
                        );
    if (!lpAdsDestValue->pReplicaPointer->ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ReplicaType =
                            lpNdsSrcObject->NdsValue.value_16.ReplicaType;
    lpAdsDestValue->pReplicaPointer->ReplicaNumber =
                            lpNdsSrcObject->NdsValue.value_16.ReplicaNumber;
    lpAdsDestValue->pReplicaPointer->Count =
                            lpNdsSrcObject->NdsValue.value_16.Count;

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints =
                        (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!lpAdsDestValue->pReplicaPointer->ReplicaAddressHints) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressType =
                            lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints->AddressType;

    hr = CopyOctetString(lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints->AddressLength,
                         lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints->Address,
                         &lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressLength,
                         &lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->Address);
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr;

    hr = E_ADS_CANT_CONVERT_DATATYPE;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    long i;

    lpAdsDestValue->dwType = ADSTYPE_POSTALADDRESS;

    lpAdsDestValue->pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
    if (!lpAdsDestValue->pPostalAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    for (i=0;i<6;i++) {
        if (lpNdsSrcObject->NdsValue.value_18.PostalAddress[i]) {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] =
                                AllocADsStr(
                                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[i]
                                );
            if (!lpAdsDestValue->pPostalAddress->PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        else {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] =
                                AllocADsStr(
                                    L""
                                );
        }
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_TIMESTAMP;

    lpAdsDestValue->Timestamp.WholeSeconds =
                            lpNdsSrcObject->NdsValue.value_19.WholeSeconds;

    lpAdsDestValue->Timestamp.EventID =
                            lpNdsSrcObject->NdsValue.value_19.EventID;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_OBJECT_CLASS;

    lpAdsDestValue->ClassName  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_20.ClassName
                                );
    if (!lpAdsDestValue->ClassName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLength = lpNdsSrcObject->NdsValue.value_21.Length;

    if (dwLength) {

        lpByte = (LPBYTE)AllocADsMem(dwLength);
        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (lpNdsSrcObject->NdsValue.value_21.Data) {
            memcpy(lpByte, lpNdsSrcObject->NdsValue.value_21.Data, dwLength);
        }

        lpAdsDestValue->OctetString.dwLength = dwLength;
        lpAdsDestValue->OctetString.lpValue = lpByte;

    }else {

        lpAdsDestValue->OctetString.dwLength = 0;
        lpAdsDestValue->OctetString.lpValue = NULL;

    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BACKLINK;

    lpAdsDestValue->BackLink.ObjectName =
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_23.ObjectName
                        );
    if (!lpAdsDestValue->BackLink.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->BackLink.RemoteID =
                            lpNdsSrcObject->NdsValue.value_23.RemoteID;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    hr = ConvertDWORDtoSYSTEMTIME(
                lpNdsSrcObject->NdsValue.value_24.Time,
                &(lpAdsDestValue->UTCTime)
                );

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_TYPEDNAME;

    lpAdsDestValue->pTypedName = (PADS_TYPEDNAME)AllocADsMem(sizeof(ADS_TYPEDNAME));
    if (!lpAdsDestValue->pTypedName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pTypedName->ObjectName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_25.ObjectName
                        );
    if (!lpAdsDestValue->pTypedName->ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pTypedName->Level=
                            lpNdsSrcObject->NdsValue.value_25.Level;

    lpAdsDestValue->pTypedName->Interval=
                            lpNdsSrcObject->NdsValue.value_25.Interval;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_HOLD;

    lpAdsDestValue->Hold.ObjectName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_26.ObjectName
                        );
    if (!lpAdsDestValue->Hold.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->Hold.Amount=
                            lpNdsSrcObject->NdsValue.value_26.Amount;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeToAdsTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 2:
        hr = NdsTypeToAdsTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 3:
        hr = NdsTypeToAdsTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 4:
        hr = NdsTypeToAdsTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 5:
        hr = NdsTypeToAdsTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 6:
        hr = NdsTypeToAdsTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 7:
        hr = NdsTypeToAdsTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 8:
        hr = NdsTypeToAdsTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 9:
        hr = NdsTypeToAdsTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 10:
        hr = NdsTypeToAdsTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 11:
        hr = NdsTypeToAdsTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 12:
        hr = NdsTypeToAdsTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 13:
        hr = NdsTypeToAdsTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 14:
        hr = NdsTypeToAdsTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 15:
        hr = NdsTypeToAdsTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 16:
        hr = NdsTypeToAdsTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 17:
        hr = NdsTypeToAdsTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 18:
        hr = NdsTypeToAdsTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 19:
        hr = NdsTypeToAdsTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 20:
        hr = NdsTypeToAdsTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 21:
        hr = NdsTypeToAdsTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 22:
        hr = NdsTypeToAdsTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 23:
        hr = NdsTypeToAdsTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 24:
        hr = NdsTypeToAdsTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 25:
        hr = NdsTypeToAdsTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 26:
        hr = NdsTypeToAdsTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 27:
        hr = NdsTypeToAdsTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppAdsDestValues
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;

    pAdsDestValues = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pAdsDestValues) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NdsTypeToAdsTypeCopy(
                    pNdsSrcObjects + i,
                    pAdsDestValues + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppAdsDestValues = pAdsDestValues;

     RRETURN(S_OK);

error:

     if (pAdsDestValues) {
        AdsFreeAdsValues(
            pAdsDestValues,
            dwNumObjects
        );
        FreeADsMem( pAdsDestValues );
     }

     *ppAdsDestValues = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndscopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//              Object Types 6, 13, 16, and 21 are flaky - pay extra attn.
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//


HRESULT
NdsTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,      
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_1.DNString
                            );

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_1.DNString
                            );
    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                     (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                     (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_6 lpNdsSrcTempASN1_6 = NULL;

    LPNDS_ASN1_TYPE_6 lpNdsDestTempASN1_6 = NULL;
    LPNDS_ASN1_TYPE_6 lpNdsDestNextASN1_6 = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsSrcTempASN1_6 = &(lpNdsSrcObject->NdsValue.value_6);
    lpNdsDestTempASN1_6 = &(lpNdsDestObject->NdsValue.value_6);

    lpNdsDestTempASN1_6->Next = NULL;

    lpNdsDestTempASN1_6->String =
                (LPWSTR)AllocADsStr(lpNdsSrcTempASN1_6->String);
    if (!lpNdsDestTempASN1_6->String) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    while ( lpNdsSrcTempASN1_6->Next != NULL )
    {
        lpNdsSrcTempASN1_6 = lpNdsSrcTempASN1_6->Next;

        lpNdsDestNextASN1_6 =
                (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));
        if (!lpNdsDestNextASN1_6) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        lpNdsDestNextASN1_6->Next = NULL;

        lpNdsDestNextASN1_6->String =
                (LPWSTR)AllocADsStr(lpNdsSrcTempASN1_6->String);
        if (!lpNdsDestNextASN1_6->String) {
            FreeADsMem(lpNdsDestNextASN1_6);
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        lpNdsDestTempASN1_6->Next = lpNdsDestNextASN1_6;

        lpNdsDestTempASN1_6 = lpNdsDestNextASN1_6;
    }

    RRETURN(hr);
error:
    if (lpNdsDestObject->NdsValue.value_6.String)
        FreeADsStr(lpNdsDestObject->NdsValue.value_6.String);

    lpNdsDestTempASN1_6 = lpNdsDestObject->NdsValue.value_6.Next;

    while (lpNdsDestTempASN1_6 != NULL) {

        if (lpNdsDestTempASN1_6->String)
            FreeADsStr(lpNdsDestTempASN1_6->String);

        lpNdsDestNextASN1_6 = lpNdsDestTempASN1_6->Next;
        FreeADsMem(lpNdsDestTempASN1_6);
        lpNdsDestTempASN1_6 = lpNdsDestNextASN1_6;
    }

    RRETURN(hr);
}





HRESULT
NdsTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        lpNdsSrcObject->NdsValue.value_7.Boolean;

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;


    lpNdsDestObject->NdsValue.value_8.Integer =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    Length = lpNdsSrcObject->NdsValue.value_9.Length;

    if (Length) {
        pBuffer = (LPBYTE)AllocADsMem(Length);
        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(
            pBuffer,
            lpNdsSrcObject->NdsValue.value_9.OctetString,
            Length
            );

        lpNdsDestObject->NdsValue.value_9.Length = Length;
        lpNdsDestObject->NdsValue.value_9.OctetString = pBuffer;
    }else{
        lpNdsDestObject->NdsValue.value_9.Length = 0;
        lpNdsDestObject->NdsValue.value_9.OctetString = NULL;
    }

error:
    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_10.TelephoneNumber =
                    (LPWSTR)AllocADsStr(
                              lpNdsSrcObject->NdsValue.value_10.TelephoneNumber
                              );

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_11.NumberOfBits =
                lpNdsSrcObject->NdsValue.value_11.NumberOfBits;

    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                  (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_11.TelephoneNumber
                            );
    if (!lpNdsDestObject->NdsValue.value_11.TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD AddressLength = 0;
    LPBYTE Address = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_12.AddressType =
                lpNdsSrcObject->NdsValue.value_12.AddressType;

    AddressLength = lpNdsSrcObject->NdsValue.value_12.AddressLength;

    if (AddressLength) {
        Address = (LPBYTE)AllocADsMem(AddressLength);
        if (!Address) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(
            Address,
            lpNdsSrcObject->NdsValue.value_12.Address,
            AddressLength
            );

        lpNdsDestObject->NdsValue.value_12.AddressLength = AddressLength;
        lpNdsDestObject->NdsValue.value_12.Address = Address;
    }else{
        lpNdsDestObject->NdsValue.value_12.AddressLength = 0;
        lpNdsDestObject->NdsValue.value_12.Address = NULL;
    }

error:
    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    LPNDS_ASN1_TYPE_13 lpNdsASN1_13, pNextObj;
    LPNDS_ASN1_TYPE_13 * lppNext = NULL;
    LPBYTE lpBuffer = NULL;
    DWORD Length;


    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_13.Data = NULL;
    lpNdsDestObject->NdsValue.value_13.Next = NULL;

    Length =  lpNdsSrcObject->NdsValue.value_13.Length;
    lpBuffer = (LPBYTE)AllocADsMem(
                            Length
                            );
    if (!lpBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpBuffer,
        lpNdsSrcObject->NdsValue.value_13.Data,
        Length
        );

    lpNdsDestObject->NdsValue.value_13.Length = Length;
    lpNdsDestObject->NdsValue.value_13.Data = lpBuffer;

    lppNext = &(lpNdsDestObject->NdsValue.value_13.Next);

    while (lpNdsSrcObject->NdsValue.value_13.Next != NULL )
    {

        lpNdsASN1_13 = lpNdsSrcObject->NdsValue.value_13.Next;

        pNextObj =
            (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));
        if (!pNextObj) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        lpBuffer = (LPBYTE)AllocADsMem(lpNdsASN1_13->Length);
        if (!lpBuffer) {
            FreeADsMem(pNextObj);
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
            
        memcpy(lpBuffer, lpNdsASN1_13->Data, lpNdsASN1_13->Length);


        pNextObj->Length = lpNdsASN1_13->Length;
        pNextObj->Data = lpBuffer;
        pNextObj->Next = NULL;

        *lppNext =  pNextObj;

        lppNext = &pNextObj->Next;

    }

    RRETURN(hr);

error:
    if (lpNdsDestObject->NdsValue.value_13.Data)
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);

    lpNdsASN1_13 = lpNdsDestObject->NdsValue.value_13.Next;

    while (lpNdsASN1_13) {
        if (lpNdsASN1_13->Data)
            FreeADsMem(lpNdsASN1_13->Data);

        pNextObj = lpNdsASN1_13->Next;
        FreeADsMem(lpNdsASN1_13);
        lpNdsASN1_13 = pNextObj;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_14.Type = lpNdsSrcObject->NdsValue.value_14.Type;

    lpNdsDestObject->NdsValue.value_14.Address =
            (LPWSTR)AllocADsStr(
                        lpNdsSrcObject->NdsValue.value_14.Address
                        );




    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_15.Type =
            lpNdsSrcObject->NdsValue.value_15.Type;

    lpNdsDestObject->NdsValue.value_15.VolumeName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.VolumeName
                            );

    lpNdsDestObject->NdsValue.value_15.Path =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.Path
                            );

    RRETURN(hr);
}



HRESULT
NdsTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;


    DWORD Count = 0;
    DWORD iter = 0;
    DWORD dwAddrAlloc = 0;
    LPBYTE Address = NULL;
    DWORD AddressLength = 0;
    LPNDS_ASN1_TYPE_12 lpNdsDestASN1_12 = NULL, lpNdsSrcASN1_12 = NULL;


    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_16.ServerName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_16.ServerName
                            );
    if (!lpNdsDestObject->NdsValue.value_16.ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaType =
                    lpNdsSrcObject->NdsValue.value_16.ReplicaType;

    lpNdsDestObject->NdsValue.value_16.ReplicaNumber =
                    lpNdsSrcObject->NdsValue.value_16.ReplicaNumber;

    Count =  lpNdsSrcObject->NdsValue.value_16.Count;

    lpNdsDestObject->NdsValue.value_16.Count =  Count;

    lpNdsDestASN1_12 = (LPNDS_ASN1_TYPE_12)AllocADsMem(
                             Count * sizeof(NDS_ASN1_TYPE_12)
                             );
    if (!lpNdsDestASN1_12) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints = lpNdsDestASN1_12;


    lpNdsSrcASN1_12 = lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints;

    for ( iter = 0; iter < Count; iter++ )
    {

        (lpNdsDestASN1_12 + iter)->AddressType =
                    (lpNdsSrcASN1_12 + iter)->AddressType;

        AddressLength = (lpNdsSrcASN1_12 + iter)->AddressLength;

        if (AddressLength) {
            Address = (LPBYTE)AllocADsMem(AddressLength);
            if (!Address) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            memcpy(
                Address,
                (lpNdsSrcASN1_12 + iter)->Address,
                AddressLength
                );

            (lpNdsDestASN1_12 + iter)->AddressLength = AddressLength;
            (lpNdsDestASN1_12 + iter)->Address = Address;
            (lpNdsDestASN1_12 + iter)->AddressType = (lpNdsSrcASN1_12 + iter)->AddressType;
        }else{
            (lpNdsDestASN1_12 + iter)->AddressLength = AddressLength;
            (lpNdsDestASN1_12 + iter)->Address = NULL;
            (lpNdsDestASN1_12 + iter)->AddressType = 0;

        }

        dwAddrAlloc++;

    }

    RRETURN(hr);

error:

    if (lpNdsDestASN1_12) {

        for (iter=0; iter < dwAddrAlloc; iter++) {
            if ((lpNdsDestASN1_12 + iter)->Address)
                FreeADsMem((lpNdsDestASN1_12 + iter)->Address);
        }

        FreeADsMem(lpNdsDestASN1_12);
    }

    if (lpNdsDestObject->NdsValue.value_16.ServerName)
        FreeADsStr(lpNdsDestObject->NdsValue.value_16.ServerName);

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;
    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_17.Privileges =
                    lpNdsSrcObject->NdsValue.value_17.Privileges;

    lpNdsDestObject->NdsValue.value_17.ProtectedAttrName =
                    (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_17.ProtectedAttrName
                                );

    lpNdsDestObject->NdsValue.value_17.SubjectName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_17.SubjectName
                            );

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_18.PostalAddress[0] =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_18.PostalAddress[0]
                            );

    lpNdsDestObject->NdsValue.value_18.PostalAddress[1] =
                 (LPWSTR)AllocADsStr(
                             lpNdsSrcObject->NdsValue.value_18.PostalAddress[1]
                             );

    lpNdsDestObject->NdsValue.value_18.PostalAddress[2] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[2]
                    );


    lpNdsDestObject->NdsValue.value_18.PostalAddress[3] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[3]
                    );

    lpNdsDestObject->NdsValue.value_18.PostalAddress[4] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[4]
                    );

    lpNdsDestObject->NdsValue.value_18.PostalAddress[5] =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_18.PostalAddress[5]
                            );



    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_19.WholeSeconds =
            lpNdsSrcObject->NdsValue.value_19.WholeSeconds;

    lpNdsDestObject->NdsValue.value_19.EventID =
            lpNdsSrcObject->NdsValue.value_19.EventID;

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_20.ClassName =
        AllocADsStr(lpNdsSrcObject->NdsValue.value_20.ClassName);

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    //
    // BugBug - how do we handle this byte stream!!
    //

    lpNdsDestObject->NdsValue.value_21.Length =
            lpNdsSrcObject->NdsValue.value_21.Length;

    lpNdsDestObject->NdsValue.value_21.Data =
            lpNdsSrcObject->NdsValue.value_21.Data;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_22.Counter =
        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_23.RemoteID =
        lpNdsSrcObject->NdsValue.value_23.RemoteID;

    lpNdsDestObject->NdsValue.value_23.ObjectName =
        AllocADsStr(
            lpNdsSrcObject->NdsValue.value_23.ObjectName
            );

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_24.Time =
        lpNdsSrcObject->NdsValue.value_24.Time;

    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_25.ObjectName =
                AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_25.ObjectName
                    );

    lpNdsDestObject->NdsValue.value_25.Level =
            lpNdsSrcObject->NdsValue.value_25.Level;

    lpNdsDestObject->NdsValue.value_25.Interval =
            lpNdsSrcObject->NdsValue.value_25.Interval;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_26.ObjectName =
            AllocADsStr(lpNdsSrcObject->NdsValue.value_26.ObjectName);

    lpNdsDestObject->NdsValue.value_26.Amount =
            lpNdsSrcObject->NdsValue.value_26.Amount;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_27.Interval =
            lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 2:
        hr = NdsTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 3:
        hr = NdsTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 4:
        hr = NdsTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 5:
        hr = NdsTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 6:
        hr = NdsTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 7:
        hr = NdsTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 8:
        hr = NdsTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 9:
        hr = NdsTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 10:
        hr = NdsTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 11:
        hr = NdsTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 12:
        hr = NdsTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 13:
        hr = NdsTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 14:
        hr = NdsTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 15:
        hr = NdsTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 16:
        hr = NdsTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 17:
        hr = NdsTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 18:
        hr = NdsTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 19:
        hr = NdsTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 20:
        hr = NdsTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 21:
        hr = NdsTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 22:
        hr = NdsTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 23:
        hr = NdsTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 24:
        hr = NdsTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 25:
        hr = NdsTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 26:
        hr = NdsTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 27:
        hr = NdsTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
NdsTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;

    pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

    if (!pNdsDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NdsTypeCopy(pNdsSrcObjects + i, pNdsDestObjects + i);
     }

     *ppNdsDestObjects = pNdsDestObjects;

     RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}


#define CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr)                    \
    if (dwStatus) {                                                   \
        hr = CheckAndSetExtendedError(dwStatus);                      \
        BAIL_ON_FAILURE(hr);                                          \
    }

#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))


#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndsmrshl.cxx ===
/+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"

HRESULT
CopyNDSNetAddressToNDS12(
    pNet_Address_T lpSrcNetAddress,
    LPNDS_ASN1_TYPE_12 lpDest12
    )
{
    LPBYTE pBuffer = NULL;

    lpDest12->AddressType = lpSrcNetAddress->addressType;

    lpDest12->AddressLength = lpSrcNetAddress->addressLength;

    if (lpSrcNetAddress->addressLength) {
        pBuffer = (LPBYTE)AllocADsMem(lpSrcNetAddress->addressLength);

        if (!pBuffer) {
            RRETURN(E_OUTOFMEMORY);
        }

        memcpy(pBuffer, lpSrcNetAddress->address, lpSrcNetAddress->addressLength);

        lpDest12->Address = pBuffer;
    }else {
        lpDest12->Address = NULL;
    }

    RRETURN(S_OK);

}


HRESULT
CopyNDS12ToNDSNetAddress(
    LPNDS_ASN1_TYPE_12 lpSrc12,
    pNet_Address_T lpDestNetAddress
    )
{
    LPBYTE pBuffer = NULL;

    lpDestNetAddress->addressType = lpSrc12->AddressType;

    lpDestNetAddress->addressLength = lpSrc12->AddressLength;

    if (lpSrc12->AddressLength) {
        pBuffer = (LPBYTE)AllocADsMem(lpSrc12->AddressLength);

        if (!pBuffer) {
            RRETURN(E_OUTOFMEMORY);
        }

        memcpy(pBuffer, lpSrc12->Address, lpSrc12->AddressLength);

        lpDestNetAddress->address = pBuffer;
    }else {
        lpDestNetAddress->address = NULL;
    }

    RRETURN(S_OK);

}


HRESULT
CopyNdsValueToNdsObject(
      nptr attrVal,
      nuint32 luAttrValSize,
      nuint32 luSyntax,
      PNDSOBJECT pNdsObject
      )
{
    HRESULT hr = S_OK;

    if (!pNdsObject || !attrVal) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    pNdsObject->NdsType = luSyntax;

    switch (luSyntax) {
    case 1:

        pNdsObject->NdsValue.value_1.DNString = AllocADsStr( (LPWSTR) attrVal);
        break;

    case 2:

        pNdsObject->NdsValue.value_2.CaseExactString = AllocADsStr( (LPWSTR) attrVal);
        break;

    case 3:

        pNdsObject->NdsValue.value_3.CaseIgnoreString = AllocADsStr( (LPWSTR) attrVal);
        break;

    case 4:

        pNdsObject->NdsValue.value_4.PrintableString = AllocADsStr( (LPWSTR) attrVal);
        break;

    case 5:

        pNdsObject->NdsValue.value_5.NumericString = AllocADsStr( (LPWSTR) attrVal);
        break;

    case 6: {

        pCI_List_T pCaseIgnoreList = (pCI_List_T) attrVal;

        LPNDS_ASN1_TYPE_6 pNdsTempASN1_6 = NULL;
        LPNDS_ASN1_TYPE_6 pNdsNextASN1_6 = NULL;
    
        pNdsTempASN1_6 = &(pNdsObject->NdsValue.value_6);

        pNdsObject->NdsType = NDS_SYNTAX_ID_6;

        if (! pCaseIgnoreList->s) {
            pNdsTempASN1_6->String = NULL;
            pNdsTempASN1_6->Next = NULL;
            RRETURN (S_OK);
        }
    
        pNdsTempASN1_6->String =
                   (LPWSTR)AllocADsStr((LPWSTR) pCaseIgnoreList->s);
    
        while ( pCaseIgnoreList->next != NULL )
        {
            pCaseIgnoreList = pCaseIgnoreList->next;
    
            pNdsNextASN1_6 =
                    (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));

            if (!pNdsNextASN1_6) {
                //
                // BUGBUG: need to clean up the list
                //
                RRETURN(E_OUTOFMEMORY);
            }

            pNdsNextASN1_6->String =
                    (LPWSTR)AllocADsStr((LPWSTR) pCaseIgnoreList->s);

            if (!pNdsNextASN1_6->String) {
                //
                // BUGBUG: need to clean up the list
                //
                RRETURN(E_OUTOFMEMORY);
            }
        
            pNdsTempASN1_6->Next = pNdsNextASN1_6;
    
            pNdsTempASN1_6 = pNdsNextASN1_6;
        }

        pNdsTempASN1_6->Next = NULL;

        break;

    }

    case 7:

        pNdsObject->NdsValue.value_7.Boolean = *((Boolean_T *) attrVal);
        break;

    case 8:

        pNdsObject->NdsValue.value_8.Integer = *((Integer_T *) attrVal);
        break;

    case 9: {

        pOctet_String_T lpNdsOctetString = (pOctet_String_T) attrVal;

        if (lpNdsOctetString->length) {

            pNdsObject->NdsValue.value_9.Length = lpNdsOctetString->length;

            pNdsObject->NdsValue.value_9.OctetString = 
                              (LPBYTE) AllocADsMem(lpNdsOctetString->length);
            if (!pNdsObject->NdsValue.value_9.OctetString) {
                RRETURN(E_OUTOFMEMORY);
            }

            memcpy(
                pNdsObject->NdsValue.value_9.OctetString, 
                lpNdsOctetString->data,
                lpNdsOctetString->length
                );
        }
        else {

            pNdsObject->NdsValue.value_9.OctetString = NULL;
            pNdsObject->NdsValue.value_9.Length = 0;
        }
        break;
    }

    case 10:

        pNdsObject->NdsValue.value_10.TelephoneNumber = AllocADsStr( (LPWSTR) attrVal);
        break;

    case 11: {
        pFax_Number_T pNdsFaxNumber = (pFax_Number_T) attrVal;
        LPNDS_ASN1_TYPE_11 pNdsASN1_11 = &(pNdsObject->NdsValue.value_11);

        pNdsASN1_11->TelephoneNumber = AllocADsStr((LPWSTR)pNdsFaxNumber->telephoneNumber);
        pNdsASN1_11->NumberOfBits = pNdsFaxNumber->parameters.numOfBits;
        pNdsASN1_11->Parameters = (LPBYTE) AllocADsMem((pNdsASN1_11->NumberOfBits + 7) / 8);
        if (!pNdsASN1_11->Parameters) {
            RRETURN (E_OUTOFMEMORY);
        }

        memcpy(
            pNdsASN1_11->Parameters, 
            pNdsFaxNumber->parameters.data,
            ((pNdsASN1_11->NumberOfBits+7) / 8)
            );

        break;
    }

    case 12: {
        pNet_Address_T pNetAddress = (pNet_Address_T) attrVal;
        LPBYTE pBuffer = NULL;
    
        pNdsObject->NdsValue.value_12.AddressType = pNetAddress->addressType;
    
        pNdsObject->NdsValue.value_12.AddressLength = pNetAddress->addressLength;
    
        if (pNetAddress->addressLength) {
            pBuffer = (LPBYTE)AllocADsMem(pNetAddress->addressLength);
            if (!pBuffer) {
                RRETURN(E_OUTOFMEMORY);
            }
        
            memcpy(pBuffer, pNetAddress->address, pNetAddress->addressLength);
            pNdsObject->NdsValue.value_12.Address = pBuffer;
        }
    
        break;
    }

    case 13: {

        pOctet_List_T pOctetList = (pOctet_List_T) attrVal;
        LPNDS_ASN1_TYPE_13 * lppNext = NULL;
        LPBYTE lpBuffer = NULL;
        LPNDS_ASN1_TYPE_13  pNextObj = NULL;
    
        lpBuffer = (LPBYTE)AllocADsMem(pOctetList->length);
        if (!lpBuffer) {
            RRETURN(E_OUTOFMEMORY);
        }
    
        memcpy(lpBuffer, pOctetList->data, pOctetList->length);
    
        pNdsObject->NdsValue.value_13.Length = pOctetList->length;
        pNdsObject->NdsValue.value_13.Data = lpBuffer;
    
        lppNext = &(pNdsObject->NdsValue.value_13.Next);
    
        while ( pOctetList->next != NULL )
        {
            pOctetList = pOctetList->next;
    
            pNextObj =
                (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));
            if (!pNextObj) {
                // BUGBUG: need to clean up list
                RRETURN(E_OUTOFMEMORY);
            }
    
            lpBuffer = (LPBYTE)AllocADsMem(pOctetList->length);
    
            memcpy(lpBuffer, pOctetList->data, pOctetList->length);
    
    
            pNextObj->Length = pOctetList->length;
            pNextObj->Data = lpBuffer;
    
            *lppNext =  pNextObj;
    
            lppNext = &pNextObj->Next;
    
        }
    
        break;
    }

    case 14: {
                         
        pEMail_Address_T pEmailAddress = (pEMail_Address_T) attrVal;

        pNdsObject->NdsValue.value_14.Type = pEmailAddress->type;
    
        pNdsObject->NdsValue.value_14.Address =
                (LPWSTR)AllocADsStr((LPWSTR) pEmailAddress->address);
    
        break;
    }

    case 15: {

        pPath_T pPath = (pPath_T) attrVal;

        pNdsObject->NdsValue.value_15.Type = pPath->nameSpaceType;
    
        pNdsObject->NdsValue.value_15.VolumeName =
                    (LPWSTR)AllocADsStr( (LPWSTR) pPath->volumeName);
    
        pNdsObject->NdsValue.value_15.Path =
                    (LPWSTR)AllocADsStr( (LPWSTR) pPath->path);

        if (!pNdsObject->NdsValue.value_15.Path) {
            RRETURN(E_OUTOFMEMORY);
        }
    
        break;

   }

    case 16: {

        pReplica_Pointer_T pReplicaPtr = (pReplica_Pointer_T) attrVal;
        LPNDS_ASN1_TYPE_12 pNdsASN1_12 = NULL;
        DWORD iter = 0;
    
        pNdsObject->NdsValue.value_16.ServerName =
                    (LPWSTR)AllocADsStr((LPWSTR) pReplicaPtr->serverName);
    
        pNdsObject->NdsValue.value_16.ReplicaType = pReplicaPtr->replicaType;
    
        pNdsObject->NdsValue.value_16.ReplicaNumber = pReplicaPtr->replicaNumber;
    
        pNdsObject->NdsValue.value_16.Count = pReplicaPtr->count;
    
        //
        // NDS is kinda goofy. It stores one substructure as part of the
        // containing data type instead of a pointer to the object.
        //
    
        pNdsASN1_12 = (LPNDS_ASN1_TYPE_12)AllocADsMem(
                                pReplicaPtr->count * sizeof(NDS_ASN1_TYPE_12)
                                );
        if (!pNdsASN1_12) {
            RRETURN (E_OUTOFMEMORY);
        }
    
        pNdsObject->NdsValue.value_16.ReplicaAddressHints = pNdsASN1_12;
    
        for ( iter = 0; iter < pReplicaPtr->count; iter++ )
        {
    
            hr = CopyNDSNetAddressToNDS12(
                            pReplicaPtr->replicaAddressHint + iter,                            
                            (pNdsASN1_12 + iter)
                            );
            BAIL_ON_FAILURE(hr);
        }
    
        break;

    }

    case 17: {

        pObject_ACL_T  pObjectACL = (pObject_ACL_T) attrVal;

        pNdsObject->NdsValue.value_17.ProtectedAttrName =
                        (LPWSTR)AllocADsStr((LPWSTR) pObjectACL->protectedAttrName);
    
        pNdsObject->NdsValue.value_17.SubjectName =
                        (LPWSTR)AllocADsStr((LPWSTR) pObjectACL->subjectName);
    
        pNdsObject->NdsValue.value_17.Privileges =
                        pObjectACL->privileges; 
        break;
    }

    case 18: {

        LPWSTR *pPostalAddresses = (LPWSTR *) attrVal;

        for (DWORD i = 0; i < 6; i++) {

            pNdsObject->NdsValue.value_18.PostalAddress[i] =
                            (LPWSTR)AllocADsStr((LPWSTR) pPostalAddresses[i]);
        }
        break;
    }

    case 19: {

        pNWDS_TimeStamp_T pTimeStamp = (pNWDS_TimeStamp_T) attrVal;
    
        pNdsObject->NdsValue.value_19.WholeSeconds = pTimeStamp->wholeSeconds;
    
        pNdsObject->NdsValue.value_19.EventID =  pTimeStamp->eventID;

        break;
    }

    case 20:

        pNdsObject->NdsValue.value_20.ClassName = AllocADsStr( (LPWSTR) attrVal);
        break;

    case 21: {

        pStream_T lpASN1_21 = (pStream_T) attrVal;
    
        //
        // The Length value is supposedly always zero!!
        //
        pNdsObject->NdsValue.value_21.Length = lpASN1_21->length;
        pNdsObject->NdsValue.value_21.Data = NULL;
    
        break;
    }

    case 22:

        pNdsObject->NdsValue.value_22.Counter = *((DWORD *) attrVal);
        break;

    case 23: {

        pBack_Link_T pBackLink = (pBack_Link_T) attrVal;
    
        pNdsObject->NdsValue.value_23.RemoteID = pBackLink->remoteID;
    
        pNdsObject->NdsValue.value_23.ObjectName =
                (LPWSTR)AllocADsStr( (LPWSTR) pBackLink->objectName);

        if (!pBackLink->objectName) {
            RRETURN (E_OUTOFMEMORY);
        }
    
        break;
    }

    case 24:

        pNdsObject->NdsValue.value_24.Time = *((DWORD *) attrVal);
        break;

    case 25: {

        pTyped_Name_T pTypedName = (pTyped_Name_T) attrVal;
    
        pNdsObject->NdsValue.value_25.ObjectName =
                    (LPWSTR)AllocADsStr( (LPWSTR) pTypedName->objectName);
    
        pNdsObject->NdsValue.value_25.Level = pTypedName->level;
    
        pNdsObject->NdsValue.value_25.Interval = pTypedName->interval;
   
        break;
    }

    case 26: {

        pHold_T pHold = (pHold_T) attrVal;
    
        pNdsObject->NdsValue.value_26.ObjectName =
                    (LPWSTR)AllocADsStr( (LPWSTR) pHold->objectName);
    
        pNdsObject->NdsValue.value_26.Amount = pHold->amount;

        break;
    }

    case 27:

        pNdsObject->NdsValue.value_27.Interval = *((DWORD *) attrVal);
    
        break;

    default:

        //
        // BugBug. Get the proper value from NDS
        //
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
        break;
    }

error:

    RRETURN (hr);

}

HRESULT
CopyNdsObjectToNdsValue(
      PNDSOBJECT lpNdsObject,
      nptr *ppAttrVal,
      pnuint32 pluAttrValSize,
      pnuint32 pluSyntax
      )
{

    HRESULT hr = S_OK;

    if (!lpNdsObject || !ppAttrVal || !pluAttrValSize || !pluSyntax) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *pluAttrValSize = 0;
    *ppAttrVal = NULL;
    *pluSyntax = lpNdsObject->NdsType;

    switch (lpNdsObject->NdsType) {
    case 1:

        *ppAttrVal =  AllocADsStr( lpNdsObject->NdsValue.value_1.DNString );
        *pluAttrValSize = (wcslen( lpNdsObject->NdsValue.value_1.DNString ) + 1) * sizeof (WCHAR) ;
        break;

    case 2:

        *ppAttrVal = AllocADsStr( lpNdsObject->NdsValue.value_2.CaseExactString );
        *pluAttrValSize = (wcslen( lpNdsObject->NdsValue.value_2.CaseExactString ) + 1) * sizeof (WCHAR) ;
        break;

    case 3:

        *ppAttrVal = AllocADsStr( lpNdsObject->NdsValue.value_3.CaseIgnoreString );
        *pluAttrValSize = (wcslen( lpNdsObject->NdsValue.value_3.CaseIgnoreString ) + 1) * sizeof (WCHAR) ;
        break;

    case 4:

        *ppAttrVal = AllocADsStr( lpNdsObject->NdsValue.value_4.PrintableString );
        *pluAttrValSize = (wcslen( lpNdsObject->NdsValue.value_4.PrintableString ) + 1) * sizeof (WCHAR) ;
        break;

    case 5:

        *ppAttrVal = AllocADsStr( lpNdsObject->NdsValue.value_5.NumericString );
        *pluAttrValSize = (wcslen( lpNdsObject->NdsValue.value_5.NumericString ) + 1) * sizeof (WCHAR) ;
        break;

    case 6: {

        LPNDS_ASN1_TYPE_6 lpNdsTempASN1_6 = &(lpNdsObject->NdsValue.value_6);
        pCI_List_T pCaseIgnoreList = (pCI_List_T) AllocADsMem(sizeof(CI_List_T));
        if (!pCaseIgnoreList) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *ppAttrVal = pCaseIgnoreList;
        *pluAttrValSize = sizeof(CI_List_T);
    
        pCaseIgnoreList->s = (pnchar8) AllocADsStr( lpNdsTempASN1_6->String );
        if (!pCaseIgnoreList->s) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        while ( lpNdsTempASN1_6->Next)
        {
    
            pCaseIgnoreList->next = (pCI_List_T) AllocADsMem(sizeof(CI_List_T));
            if (!pCaseIgnoreList->next) {
                // BUGBUG: need to clean up list
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
    
            pCaseIgnoreList = pCaseIgnoreList->next;
    
            lpNdsTempASN1_6 = lpNdsTempASN1_6->Next;
    
            pCaseIgnoreList->s = (pnchar8) AllocADsStr( lpNdsTempASN1_6->String );
            if (!pCaseIgnoreList) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }
        pCaseIgnoreList->next = NULL;
    
        break;
    }

    case 7: {

        Boolean_T *pBool = (Boolean_T *) AllocADsMem(sizeof(Boolean_T));
        if (!pBool) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *pBool = *((Boolean_T *) &lpNdsObject->NdsValue.value_7.Boolean);
        *ppAttrVal = pBool;
        *pluAttrValSize = sizeof(Boolean_T);
        break;
    }

    case 8: {

        Integer_T *pInteger = (Integer_T *) AllocADsMem(sizeof(Integer_T));
        if (!pInteger) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *pInteger = *((Integer_T *) &lpNdsObject->NdsValue.value_8.Integer);
        *ppAttrVal = pInteger;
        *pluAttrValSize = sizeof(Integer_T);
        break;
    }

    case 9: {

        pOctet_String_T lpOctetString = (pOctet_String_T) 
                                            AllocADsMem(sizeof(Octet_String_T));

        if (!lpOctetString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        if (lpNdsObject->NdsValue.value_9.Length) {

            lpOctetString->length = lpNdsObject->NdsValue.value_9.Length;

            lpOctetString->data = (LPBYTE) AllocADsMem (
                                              lpNdsObject->NdsValue.value_9.Length);
            if (!lpOctetString->data) {
                RRETURN(E_OUTOFMEMORY);
            }

            memcpy(
                lpOctetString->data,
                lpNdsObject->NdsValue.value_9.OctetString, 
                lpNdsObject->NdsValue.value_9.Length
                );
        }
        else {
            lpOctetString->length = 0;
            lpOctetString->data = NULL;

        }
        *ppAttrVal = lpOctetString;
        *pluAttrValSize = sizeof(Octet_String_T);
        break;
    }

    case 10:

        *ppAttrVal = AllocADsStr( lpNdsObject->NdsValue.value_11.TelephoneNumber );
        *pluAttrValSize = (wcslen( lpNdsObject->NdsValue.value_11.TelephoneNumber ) + 1) * sizeof (WCHAR) ;
        break;

    case 11: {

        pFax_Number_T pFaxNumber = (pFax_Number_T) AllocADsMem(sizeof(Fax_Number_T));
    
        pFaxNumber->telephoneNumber =
                        (pnchar8)AllocADsStr(
                                    lpNdsObject->NdsValue.value_11.TelephoneNumber
                                    );
        if (!pFaxNumber->telephoneNumber) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pFaxNumber->parameters.numOfBits = lpNdsObject->NdsValue.value_11.NumberOfBits;

        pFaxNumber->parameters.data = (LPBYTE) AllocADsMem((pFaxNumber->parameters.numOfBits+7) / 8);

        memcpy(
            pFaxNumber->parameters.data,
            lpNdsObject->NdsValue.value_11.Parameters, 
            (pFaxNumber->parameters.numOfBits+7) / 8
            );
    
        *ppAttrVal = pFaxNumber;
        *pluAttrValSize = sizeof(Fax_Number_T);
    
        break;
    }

    case 12: {

        pNet_Address_T pNetAddress = (pNet_Address_T) AllocADsMem(sizeof (Net_Address_T));
        LPBYTE pBuffer = NULL;
    
        pNetAddress->addressType = lpNdsObject->NdsValue.value_12.AddressType;
    
        pNetAddress->addressLength = lpNdsObject->NdsValue.value_12.AddressLength;
    
        pBuffer = (LPBYTE)AllocADsMem(pNetAddress->addressLength);
        if (!pBuffer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        memcpy(
            pBuffer,
            lpNdsObject->NdsValue.value_12.Address,
            pNetAddress->addressLength
            );
    
        pNetAddress->address = pBuffer;

        *ppAttrVal = pNetAddress;
        *pluAttrValSize = sizeof(Net_Address_T);
    
        break;

    }

    case 13: {

        LPNDS_ASN1_TYPE_13 lpNdsTempASN1_13 = &(lpNdsObject->NdsValue.value_13);
        pOctet_List_T pOctetList = (pOctet_List_T) AllocADsMem(sizeof(Octet_List_T));
        if (!pOctetList) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *ppAttrVal = pOctetList;
        *pluAttrValSize = sizeof(Octet_List_T);
    
        pOctetList->length = lpNdsTempASN1_13->Length;

        pOctetList->data =
                    (LPBYTE)AllocADsMem(
                            lpNdsTempASN1_13->Length
                            );
        if (!pOctetList->data) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(
            pOctetList->data, 
            lpNdsTempASN1_13->Data,
            pOctetList->length
            );

        while ( lpNdsTempASN1_13->Next)
        {
    
            pOctetList->next = (pOctet_List_T) AllocADsMem(sizeof(Octet_List_T));
            if (!pOctetList->next) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
    
            pOctetList = pOctetList->next;
    
            lpNdsTempASN1_13 = lpNdsTempASN1_13->Next;
    
            pOctetList->length = lpNdsTempASN1_13->Length;

            pOctetList->data = (LPBYTE) AllocADsMem( lpNdsTempASN1_13->Length );
            if (!pOctetList->data) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pOctetList->data, 
                lpNdsTempASN1_13->Data,
                pOctetList->length
                );
        }
        pOctetList->next = NULL;
    
        break;
    }

    case 14: {

        pEMail_Address_T pEmailAddress = (pEMail_Address_T) AllocADsMem(sizeof (EMail_Address_T));
        if (!pEmailAddress) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pEmailAddress->type = lpNdsObject->NdsValue.value_14.Type;

        pEmailAddress->address = (pnchar8) AllocADsStr( (LPWSTR)  lpNdsObject->NdsValue.value_14.Address);

        *ppAttrVal = pEmailAddress;
        *pluAttrValSize = sizeof(EMail_Address_T);
    
        break;
    }

    case 15: {

        pPath_T pPath = (pPath_T) AllocADsMem(sizeof (Path_T));
        if (!pPath) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pPath->nameSpaceType = lpNdsObject->NdsValue.value_15.Type;
        pPath->volumeName = (pnchar8) AllocADsStr( lpNdsObject->NdsValue.value_15.VolumeName);
        pPath->path = (pnchar8) AllocADsStr( (LPWSTR)  lpNdsObject->NdsValue.value_15.Path);

        *ppAttrVal = pPath;
        *pluAttrValSize = sizeof(Path_T);
    
        break;
    }

    case 16: {

        LPNDS_ASN1_TYPE_12 pNdsASN1_12 = NULL;
        DWORD dwSize = sizeof (Replica_Pointer_T) + 
                (lpNdsObject->NdsValue.value_16.Count-1) * sizeof (Net_Address_T);

        pReplica_Pointer_T pReplicaPointer = 
            (pReplica_Pointer_T) AllocADsMem(dwSize);

        if (!pReplicaPointer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pReplicaPointer->serverName = (pnchar8) AllocADsStr( (LPWSTR) lpNdsObject->NdsValue.value_16.ServerName);
        pReplicaPointer->replicaType = lpNdsObject->NdsValue.value_16.ReplicaType;
        pReplicaPointer->replicaNumber = lpNdsObject->NdsValue.value_16.ReplicaNumber;
        pReplicaPointer->count = lpNdsObject->NdsValue.value_16.Count;

        pNdsASN1_12 = lpNdsObject->NdsValue.value_16.ReplicaAddressHints;

        for ( DWORD iter = 0; iter < pReplicaPointer->count; iter++ )
        {
    
            hr = CopyNDS12ToNDSNetAddress(
                            pNdsASN1_12 + iter,
                            pReplicaPointer->replicaAddressHint + iter
                            );
            BAIL_ON_FAILURE(hr);
        }
    
        *ppAttrVal = pReplicaPointer;
        *pluAttrValSize = dwSize;
    
        break;
    }

    case 17: {

        pObject_ACL_T pObjectACL = (pObject_ACL_T) AllocADsMem(sizeof (Object_ACL_T));
        if (!pObjectACL) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pObjectACL->protectedAttrName = (pnchar8) AllocADsStr( (LPWSTR)  lpNdsObject->NdsValue.value_17.ProtectedAttrName);

        pObjectACL->subjectName = (pnchar8) AllocADsStr( lpNdsObject->NdsValue.value_17.SubjectName);

        pObjectACL->privileges = lpNdsObject->NdsValue.value_17.Privileges;

        *ppAttrVal = pObjectACL;
        *pluAttrValSize = sizeof(Object_ACL_T);
    
        break;
    }

    case 18: {

        LPWSTR *pPostalAddresses = (LPWSTR *) AllocADsMem(sizeof (LPWSTR) * 6);
        if (!pPostalAddresses) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        for (DWORD i=0; i < 6; i++) {
            pPostalAddresses[i] = AllocADsStr( (LPWSTR)  lpNdsObject->NdsValue.value_18.PostalAddress[i]);
        }

        *ppAttrVal = pPostalAddresses;
        *pluAttrValSize = sizeof(LPWSTR) * 6;
    
        break;
    }

    case 19: {

        pNWDS_TimeStamp_T pTimeStamp = (pNWDS_TimeStamp_T) AllocADsMem(sizeof (NWDS_TimeStamp_T));
        if (!pTimeStamp) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pTimeStamp->wholeSeconds = lpNdsObject->NdsValue.value_19.WholeSeconds;
        pTimeStamp->eventID = lpNdsObject->NdsValue.value_19.EventID;

        *ppAttrVal = pTimeStamp;
        *pluAttrValSize = sizeof(NWDS_TimeStamp_T);
    
        break;
    }

    case 20:

        *ppAttrVal = AllocADsStr( lpNdsObject->NdsValue.value_20.ClassName );
        *pluAttrValSize = (wcslen( lpNdsObject->NdsValue.value_20.ClassName ) + 1) * sizeof (WCHAR) ;
        break;

    case 21:{

        pStream_T pStream = (pStream_T) AllocADsMem(sizeof (NWDS_TimeStamp_T));
        if (!pStream) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pStream->length = lpNdsObject->NdsValue.value_21.Length;
        pStream->data = NULL;

        *ppAttrVal = pStream;
        *pluAttrValSize = sizeof(Stream_T);
    
        break;
    }

    case 22: {

        Counter_T *pCounter = (Counter_T *) AllocADsMem(sizeof(Counter_T));
        if (!pCounter) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *pCounter = *((Counter_T *) &lpNdsObject->NdsValue.value_22.Counter);
        *ppAttrVal = pCounter;
        *pluAttrValSize = sizeof(Counter_T);
        break;
    }

    case 23: {

        pBack_Link_T pBackLink = (pBack_Link_T) AllocADsMem(sizeof (Back_Link_T));
        if (!pBackLink) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pBackLink->remoteID = lpNdsObject->NdsValue.value_23.RemoteID;

        pBackLink->objectName = (pnchar8) AllocADsStr( lpNdsObject->NdsValue.value_23.ObjectName);

        *ppAttrVal = pBackLink;
        *pluAttrValSize = sizeof(Back_Link_T);
    
        break;
    }

    case 24: {

        Integer_T *pInteger = (Integer_T *) AllocADsMem(sizeof(Integer_T));
        if (!pInteger) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *pInteger = *((Integer_T *) &lpNdsObject->NdsValue.value_24.Time);
        *ppAttrVal = pInteger;
        *pluAttrValSize = sizeof(Integer_T);
        break;
    }

    case 25: {

        pTyped_Name_T pTypedName = (pTyped_Name_T) AllocADsMem(sizeof (Typed_Name_T));
        if (!pTypedName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pTypedName->objectName = (pnchar8) AllocADsStr( lpNdsObject->NdsValue.value_25.ObjectName);

        pTypedName->level = lpNdsObject->NdsValue.value_25.Level;

        pTypedName->interval = lpNdsObject->NdsValue.value_25.Interval;

        *ppAttrVal = pTypedName;
        *pluAttrValSize = sizeof(Typed_Name_T);
    
        break;
    }

    case 26: {

        pHold_T pHold = (pHold_T) AllocADsMem(sizeof (Hold_T));
        if (!pHold) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        pHold->objectName = (pnchar8) AllocADsStr( (LPWSTR)  lpNdsObject->NdsValue.value_26.ObjectName);

        pHold->amount = lpNdsObject->NdsValue.value_26.Amount;

        *ppAttrVal = pHold;
        *pluAttrValSize = sizeof(Hold_T);
    
        break;
    }

    case 27: {

        nuint32 *pInterval = (nuint32 *) AllocADsMem(sizeof(nuint32));
        if (!pInterval) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *pInterval = *((nuint32 *) &lpNdsObject->NdsValue.value_27.Interval);
        *ppAttrVal = pInterval;
        *pluAttrValSize = sizeof(nuint32);
        break;
    }

    default:

        //
        // BugBug. Get the proper value from NDS
        //
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
        break;
    }

    RRETURN (hr);

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndscache.cxx ===
#include "nds.hxx"
#pragma hdrstop

NDS_CONTEXT       BindCache ;
DWORD             BindCacheCount = 0 ;

//
// Initializes a cache entry
//
HRESULT BindCacheAllocEntry(NDS_CONTEXT **ppCacheEntry)
{

    NDS_CONTEXT *pCacheEntry ;

    *ppCacheEntry = NULL ;

    if (!(pCacheEntry = (PNDS_CONTEXT)AllocADsMem(sizeof(NDS_CONTEXT)))) {

        RRETURN(E_OUTOFMEMORY);

    }

    pCacheEntry->RefCount = 0;
    pCacheEntry->Flags = 0;
    pCacheEntry->List.Flink = NULL ;
    pCacheEntry->List.Blink = NULL ;

    *ppCacheEntry =  pCacheEntry ;

    RRETURN(S_OK);
}

//
// Invalidates a cache entry so it will not be used.
//
VOID BindCacheInvalidateEntry(NDS_CONTEXT *pCacheEntry)
{
    pCacheEntry->Flags |= NDS_CACHE_INVALID ;
}

//
// Lookup an entry in the cache. Does not take into account timeouts.
// Increments ref count if found.
//
PNDS_CONTEXT
BindCacheLookup(
    LPWSTR pszNDSTreeName,
    CCredentials& Credentials
    )
{
    DWORD i ;

    PNDS_CONTEXT pEntry = (PNDS_CONTEXT) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     tree name and credentials, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        if (!(pEntry->Flags & NDS_CACHE_INVALID) &&
            (((pszNDSTreeName != NULL) && (pEntry->pszNDSTreeName != NULL) &&
             (wcscmp(pEntry->pszNDSTreeName, pszNDSTreeName) == 0)) ||
            (pEntry->pszNDSTreeName == NULL && pszNDSTreeName == NULL)) &&
             (*(pEntry->pCredentials) == Credentials)) {

            ++pEntry->RefCount ;

            return(pEntry) ;
        }

        pEntry = (PNDS_CONTEXT)pEntry->List.Flink ;
    }

    return NULL ;
}

//
// Add entry to cache
//
HRESULT
BindCacheAdd(
    LPWSTR pszNDSTreeName,
    CCredentials& Credentials,
    BOOL fLoggedIn,
    PNDS_CONTEXT pCacheEntry)
{

    if (BindCacheCount > MAX_BIND_CACHE_SIZE) {

        //
        // If exceed limit, just dont put in cache. Since we leave the
        // RefCount & the Links unset, the deref will simply note that
        // this entry is not in cache and allow it to be freed.
        //
        // We limit cache so that if someone leaks handles we dont over
        // time end up traversing this huge linked list.
        //
        RRETURN(S_OK) ;
    }

    LPWSTR pszTreeName = (LPWSTR) AllocADsMem(
                                   (wcslen(pszNDSTreeName)+1)*sizeof(WCHAR)) ;

    if (!pszTreeName) {

        RRETURN(E_OUTOFMEMORY);
    }

    CCredentials * pCredentials = new CCredentials(Credentials);

    if (!pCredentials) {

        FreeADsMem(pszTreeName);

        RRETURN(E_OUTOFMEMORY);
    }

    //
    // setup the data
    //
    wcscpy(pszTreeName,pszNDSTreeName) ;
    pCacheEntry->pszNDSTreeName = pszTreeName;
    pCacheEntry->pCredentials = pCredentials;
    pCacheEntry->RefCount  = 1 ;
    pCacheEntry->fLoggedIn = fLoggedIn;

    //
    // insert into list
    //
    InsertHeadList(&BindCache.List, &pCacheEntry->List) ;
    ++BindCacheCount ;

    RRETURN(S_OK);
}

//
// Dereference an entry in the cache. Removes if ref count is zero.
// Returns the final ref count or zero if not there. If zero, caller
// should close the handle.
//
DWORD BindCacheDeref(NDS_CONTEXT *pCacheEntry)
{

    DWORD i=0;

    ENTER_BIND_CRITSECT() ;

    if ((pCacheEntry->List.Flink == NULL) &&
        (pCacheEntry->List.Blink == NULL) &&
        (pCacheEntry->RefCount == NULL)) {

        //
        // this is one of the entries that never got into the cache.
        //
        LEAVE_BIND_CRITSECT() ;
        return(0) ;
    }

    ADsAssert(pCacheEntry->List.Flink) ;
    ADsAssert(pCacheEntry->RefCount > 0) ;

    //
    // Dereference by one. If result is non zero, just return.
    //
    --pCacheEntry->RefCount ;

    if (pCacheEntry->RefCount) {

        LEAVE_BIND_CRITSECT() ;
        return(pCacheEntry->RefCount) ;
    }

    //
    // This entry can be cleaned up. 
    //

    --BindCacheCount ;

    (void) FreeADsMem(pCacheEntry->pszNDSTreeName) ;
    pCacheEntry->pszNDSTreeName = NULL ;

    delete pCacheEntry->pCredentials;
    pCacheEntry->pCredentials = NULL;

    RemoveEntryList(&pCacheEntry->List) ;

    LEAVE_BIND_CRITSECT() ;
    return 0 ;
}


VOID
BindCacheInit(
    VOID
    )
{
    InitializeCriticalSection(&BindCacheCritSect) ;
    InitializeListHead(&BindCache.List) ;
}

VOID
BindCacheCleanup(
    VOID
    )
{
    PNDS_CONTEXT pEntry = (PNDS_CONTEXT) BindCache.List.Flink ;

    while (pEntry != &BindCache) {

        PNDS_CONTEXT pNext = (PNDS_CONTEXT) pEntry->List.Flink;

        (void) FreeADsMem(pEntry->pszNDSTreeName) ;

        pEntry->pszNDSTreeName = NULL ;

        RemoveEntryList(&pEntry->List) ;

        pEntry = pNext;
    }

    DeleteCriticalSection(&BindCacheCritSect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\nds2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//  The following conversions are not supported
//
//  NDS_ASN1_TYPE_1
//
//  NDS_ASN1_TYPE_2
//
//  NDS_ASN1_TYPE_3
//
//  NDS_ASN1_TYPE_4
//
//  NDS_ASN1_TYPE_5
//
//  NDS_ASN1_TYPE_6
//
//  NDS_ASN1_TYPE_7
//
//  NDS_ASN1_TYPE_8
//
//  NDS_ASN1_TYPE_9
//
//  NDS_ASN1_TYPE_10
//
//  NDS_ASN1_TYPE_11
//
//  NDS_ASN1_TYPE_12
//
//  NDS_ASN1_TYPE_13
//
//  NDS_ASN1_TYPE_14
//
//  NDS_ASN1_TYPE_15
//
//  NDS_ASN1_TYPE_16
//
//  NDS_ASN1_TYPE_17
//
//  NDS_ASN1_TYPE_18
//
//  NDS_ASN1_TYPE_19
//
//  NDS_ASN1_TYPE_20
//
//  NDS_ASN1_TYPE_21
//
//  NDS_ASN1_TYPE_22
//
//  NDS_ASN1_TYPE_23
//
//  NDS_ASN1_TYPE_24
//
//  NDS_ASN1_TYPE_25
//
//  NDS_ASN1_TYPE_26
//
//  NDS_ASN1_TYPE_27
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    VariantInit(lpVarDestObject);
    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
               lpNdsSrcObject->NdsValue.value_1.DNString,
               &(lpVarDestObject->bstrVal)
               );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
               lpNdsSrcObject->NdsValue.value_1.DNString,
               &(lpVarDestObject->bstrVal)
               );


    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i;
    BSTR bstrAddress;
    DWORD cElements = 0;
    IADsCaseIgnoreList* pCaseIgnoreList = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    struct _NDS_CI_LIST *pCurrent = NULL;
    VARIANT varElement;

    hr = CCaseIgnoreList::CreateCaseIgnoreList(
                IID_IADsCaseIgnoreList,
                (void **)&pCaseIgnoreList
                );
    BAIL_ON_FAILURE(hr);

    pCurrent = &(lpNdsSrcObject->NdsValue.value_6);
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = &(lpNdsSrcObject->NdsValue.value_6);
    for ( i = 0; i < (long)cElements; i++ ) {
        VariantInit(&varElement);
        varElement.vt = VT_BSTR;
        hr = ADsAllocString(
                pCurrent->String,
                &varElement.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &varElement);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
        VariantClear(&varElement);
    }

    VariantInit(&VarDestObject);
    V_VT(&VarDestObject) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&VarDestObject) = aList;

    hr = pCaseIgnoreList->put_CaseIgnoreList(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);
    aList = NULL;

    hr = pCaseIgnoreList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release();
    }
    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BOOL;

    lpVarDestObject->boolVal =
                        (lpNdsSrcObject->NdsValue.value_7.Boolean)?
                        VARIANT_TRUE: VARIANT_FALSE;

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;


    lpVarDestObject->lVal =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);

}

HRESULT
NdsTypeToVarTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    VariantInit(lpVarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_9.Length,
                lpNdsSrcObject->NdsValue.value_9.OctetString,
                lpVarDestObject);
    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
              lpNdsSrcObject->NdsValue.value_10.TelephoneNumber,
              &(lpVarDestObject->bstrVal)
              );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    IADsFaxNumber * pFaxNumber= NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VariantInit(lpVarDestObject);

    hr = CFaxNumber::CreateFaxNumber(
                IID_IADsFaxNumber,
                (void **)&pFaxNumber
                );
    BAIL_ON_FAILURE(hr);

    hr = pFaxNumber->put_TelephoneNumber(lpNdsSrcObject->NdsValue.value_11.TelephoneNumber);
    BAIL_ON_FAILURE(hr);

    VariantInit(&VarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_11.NumberOfBits,
                lpNdsSrcObject->NdsValue.value_11.Parameters,
                &VarDestObject);
    BAIL_ON_FAILURE(hr);
    hr = pFaxNumber->put_Parameters(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);

    hr = pFaxNumber->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pFaxNumber) {
        pFaxNumber->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsNetAddress * pNetAddress = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT VarDestObject;

    VariantInit(lpVarDestObject);

    hr = CNetAddress::CreateNetAddress(
                IID_IADsNetAddress,
                (void **)&pNetAddress
                );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->put_AddressType(lpNdsSrcObject->NdsValue.value_12.AddressType);
    BAIL_ON_FAILURE(hr);

    VariantInit(&VarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_12.AddressLength,
                lpNdsSrcObject->NdsValue.value_12.Address,
                &VarDestObject);
    BAIL_ON_FAILURE(hr);
    hr = pNetAddress->put_Address(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);

    hr = pNetAddress->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pNetAddress) {
        pNetAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    struct _NDS_OCTET_LIST *pCurrent = NULL;
    DWORD cElements = 0;
    IADsOctetList* pOctetList = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VARIANT VarElement;

    hr = COctetList::CreateOctetList(
                IID_IADsOctetList,
                (void **)&pOctetList
                );
    BAIL_ON_FAILURE(hr);

    pCurrent = &(lpNdsSrcObject->NdsValue.value_13);
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = &(lpNdsSrcObject->NdsValue.value_13);
    for ( i = 0; i < (long)cElements; i++ ) {
        VariantInit(&VarElement);
        hr = BinaryToVariant(
                    pCurrent->Length,
                    pCurrent->Data,
                    &VarElement);
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &VarElement);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
    }

    VariantInit(&VarDestObject);
    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pOctetList->put_OctetList(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);
    aList = NULL;

    hr = pOctetList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if (pOctetList) {
        pOctetList->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    IADsEmail * pEmail= NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VariantInit(lpVarDestObject);

    hr = CEmail::CreateEmail(
                IID_IADsEmail,
                (void **)&pEmail
                );
    BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Address(lpNdsSrcObject->NdsValue.value_14.Address);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Type(lpNdsSrcObject->NdsValue.value_14.Type);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pEmail) {
        pEmail->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsPath * pPath = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    VariantInit(lpVarDestObject);

    hr = CPath::CreatePath(
                IID_IADsPath,
                (void **)&pPath
                );
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_Type(lpNdsSrcObject->NdsValue.value_15.Type);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_VolumeName(lpNdsSrcObject->NdsValue.value_15.VolumeName);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_Path(lpNdsSrcObject->NdsValue.value_15.Path);
    BAIL_ON_FAILURE(hr);

    hr = pPath->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pPath) {
        pPath->Release();
    }

    RRETURN(hr);
}



HRESULT
NdsTypeToVarTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsReplicaPointer * pReplicaPointer = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    LPWSTR ServerName = NULL;
    DWORD  ReplicaType = 0;
    DWORD  ReplicaNumber = 0;
    DWORD  Count = 0;
    NDSOBJECT object;
    VARIANT varDestObject;

    VariantInit(lpVarDestObject);

    hr = CReplicaPointer::CreateReplicaPointer(
                IID_IADsReplicaPointer,
                (void **)&pReplicaPointer
                );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ServerName(lpNdsSrcObject->NdsValue.value_16.ServerName);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaType(lpNdsSrcObject->NdsValue.value_16.ReplicaType);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaNumber(lpNdsSrcObject->NdsValue.value_16.ReplicaNumber);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_Count(lpNdsSrcObject->NdsValue.value_16.Count);
    BAIL_ON_FAILURE(hr);

    VariantInit(&varDestObject);
    memcpy(&object.NdsValue.value_12,
           lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints,
           sizeof(NDS_ASN1_TYPE_12));
    hr = NdsTypeToVarTypeCopyNDSSynId12(
                            &object,
                            &varDestObject
                            );
    BAIL_ON_FAILURE(hr);
    hr = pReplicaPointer->put_ReplicaAddressHints(varDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&varDestObject);

    hr = pReplicaPointer->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pReplicaPointer) {
        pReplicaPointer->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsAcl * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(lpNdsSrcObject->NdsValue.value_17.SubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(lpNdsSrcObject->NdsValue.value_17.ProtectedAttrName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(lpNdsSrcObject->NdsValue.value_17.Privileges);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress;
    IADsPostalAddress* pPostalAddress = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VARIANT varElement;

    hr = CPostalAddress::CreatePostalAddress(
                IID_IADsPostalAddress,
                (void **)&pPostalAddress
                );
    BAIL_ON_FAILURE(hr);

    aBound.lLbound = 0;
    aBound.cElements = 6;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) 6; i++ ) {
        VariantInit(&varElement);
        varElement.vt = VT_BSTR;

        hr = ADsAllocString(
                lpNdsSrcObject->NdsValue.value_18.PostalAddress[i],
                &varElement.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &varElement);
        BAIL_ON_FAILURE(hr);
        VariantClear(&varElement);
    }

    VariantInit(&VarDestObject);
    V_VT(&VarDestObject) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&VarDestObject) = aList;

    hr = pPostalAddress->put_PostalAddress(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsTimestamp * pTime = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CTimestamp::CreateTimestamp(
                IID_IADsTimestamp,
                (void **)&pTime
                );
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_WholeSeconds(lpNdsSrcObject->NdsValue.value_19.WholeSeconds);
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_EventID(lpNdsSrcObject->NdsValue.value_19.EventID);
    BAIL_ON_FAILURE(hr);

    hr = pTime->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pTime) {
        pTime->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_20.ClassName,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    VariantInit(lpVarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_21.Length,
                lpNdsSrcObject->NdsValue.value_21.Data,
                lpVarDestObject);

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )

{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal =
        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsBackLink * pBackLink = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CBackLink::CreateBackLink(
                IID_IADsBackLink,
                (void **)&pBackLink
                );
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_ObjectName(lpNdsSrcObject->NdsValue.value_23.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_RemoteID(lpNdsSrcObject->NdsValue.value_23.RemoteID);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pBackLink) {
        pBackLink->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_DATE;

    hr = NDSConvertDWORDtoDATE(
                lpNdsSrcObject->NdsValue.value_24.Time,
                &(lpVarDestObject->date)
                );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsTypedName * pTypedName = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CTypedName::CreateTypedName(
                IID_IADsTypedName,
                (void **)&pTypedName
                );
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_ObjectName(lpNdsSrcObject->NdsValue.value_25.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Level(lpNdsSrcObject->NdsValue.value_25.Level);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Interval(lpNdsSrcObject->NdsValue.value_25.Interval);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pTypedName) {
        pTypedName->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsHold * pHold = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CHold::CreateHold(
                IID_IADsHold,
                (void **)&pHold
                );
    BAIL_ON_FAILURE(hr);

    hr = pHold->put_ObjectName(lpNdsSrcObject->NdsValue.value_26.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pHold->put_Amount(lpNdsSrcObject->NdsValue.value_26.Amount);
    BAIL_ON_FAILURE(hr);

    hr = pHold->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pHold) {
        pHold->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )

{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal =
            lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeToVarTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 2:
        hr = NdsTypeToVarTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 3:
        hr = NdsTypeToVarTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 4:
        hr = NdsTypeToVarTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 5:
        hr = NdsTypeToVarTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 6:
        hr = NdsTypeToVarTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 7:
        hr = NdsTypeToVarTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 8:
        hr = NdsTypeToVarTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 9:
        hr = NdsTypeToVarTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 10:
        hr = NdsTypeToVarTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 11:
        hr = NdsTypeToVarTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 12:
        hr = NdsTypeToVarTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 13:
        hr = NdsTypeToVarTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 14:
        hr = NdsTypeToVarTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 15:
        hr = NdsTypeToVarTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 16:
        hr = NdsTypeToVarTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 17:
        hr = NdsTypeToVarTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 18:
        hr = NdsTypeToVarTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 19:
        hr = NdsTypeToVarTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 20:
        hr = NdsTypeToVarTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 21:
        hr = NdsTypeToVarTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 22:
        hr = NdsTypeToVarTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 23:
        hr = NdsTypeToVarTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 24:
        hr = NdsTypeToVarTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 25:
        hr = NdsTypeToVarTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 26:
        hr = NdsTypeToVarTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 27:
        hr = NdsTypeToVarTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects,
    BOOLEAN bReturnArrayAlways
    )
{
    long i = 0;
    HRESULT hr = S_OK;
    VARIANT VarDestObjectsTemp;
    SAFEARRAY *aList = NULL;
    SAFEARRAY *aListTmp = NULL;

    if ((pNdsSrcObjects->NdsType == 17) || (dwNumObjects > 1) || bReturnArrayAlways) {

        VariantInit(pVarDestObjects);

        //
        // The following are for handling are multi-value properties
        //

        SAFEARRAYBOUND aBound;

        aBound.lLbound = 0;
        aBound.cElements = dwNumObjects;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for ( i = 0; i < (long) dwNumObjects; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            hr = NdsTypeToVarTypeCopy( pNdsSrcObjects + i,
                                       &v );
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);
        }

        V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pVarDestObjects) = aList;


        //
        // If it is an NDS ACL, we will convert it into an
        // NT Security Descriptor
        //
        if (pNdsSrcObjects->NdsType == 17) {
            hr = ConvertNDSAclVArrayToSecDesVar(pVarDestObjects,
                                                &VarDestObjectsTemp);
            SafeArrayDestroy( aList );
            if (!bReturnArrayAlways) {
                V_VT(pVarDestObjects) = V_VT(&VarDestObjectsTemp);
                V_DISPATCH(pVarDestObjects) = V_DISPATCH(&VarDestObjectsTemp);
            }
            else {
                //
                // Pack SecDescriptor into a one-element array
                //
                SAFEARRAYBOUND aBoundTmp;
                long j = 0;

                aBoundTmp.lLbound = 0;
                aBoundTmp.cElements = 1;

                aListTmp = SafeArrayCreate( VT_VARIANT, 1, &aBoundTmp);

                if ( aListTmp == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                hr = SafeArrayPutElement( aListTmp, &j, &VarDestObjectsTemp);
                BAIL_ON_FAILURE(hr);

                V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
                V_ARRAY(pVarDestObjects) = aListTmp;
            }
        }
    }
    else {
        hr  = NdsTypeToVarTypeCopy(
                   pNdsSrcObjects,
                   pVarDestObjects
                   );
    }
    BAIL_ON_FAILURE(hr);
    RRETURN(hr);
error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if ( aListTmp ) {
        SafeArrayDestroy( aListTmp );
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HINSTANCE g_hInst = NULL;
WCHAR * szNDSPrefix = L"@NDS!";


//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

extern CRITICAL_SECTION g_DispTypeInfoCritSect;
//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"NDS",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"NDS",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"NDS",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CNDSProviderCF g_cfProvider;
CNDSNamespaceCF g_cfNamespace;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_NDSProvider,                        &g_cfProvider,
    &CLSID_NDSNamespace,                       &g_cfNamespace
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    //
    // BugBug - Fix this Pronto!!
    //
    /*
    if (GET_OBJECT_COUNT() > 0)
        hr = S_FALSE;
    else
        hr = S_OK;
    */
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Catch case of init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif

            InitializeCriticalSection(&g_DispTypeInfoCritSect);
            InitializeCriticalSection(&g_ContextCritSect);

            BindCacheInit();

            //
            // Build the global object class cache
            //

            hr = CClassCache::CreateClassCache(
                            &pgClassCache
                            );
            if (FAILED(hr)) {
                return(FALSE);
            }

            InitializeNWLibrary();
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical Failure.
            //
            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:

        delete pgClassCache;

#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT);
        DeleteCriticalSection(&g_csMem);
#endif
        DeleteCriticalSection(&g_csDP);
#endif

        DeleteCriticalSection(&g_DispTypeInfoCritSect);
        DeleteCriticalSection(&g_ContextCritSect);

//        FreeTypeInfoTable();

        BindCacheCleanup();

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndsfree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsfree.cxx
//
//  Contents:   NDS Object Free Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//              Object Types 6, 13, 16, and 21 are flaky - pay extra attn.
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects free code
//


HRESULT
NdsTypeFreeNDSSynId1(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId2(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId3(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);
    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId4(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId5(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId6(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_6 pStart = NULL;
    LPNDS_ASN1_TYPE_6 pTemp = NULL;

    FreeADsStr(lpNdsDestObject->NdsValue.value_6.String);

    pStart = lpNdsDestObject->NdsValue.value_6.Next;

    while (pStart){
        pTemp = pStart;

        pStart = pTemp->Next;

        FreeADsStr(pTemp->String);
        FreeADsMem(pTemp);
    }

    RRETURN(hr);
}





HRESULT
NdsTypeFreeNDSSynId7(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do Nothing - Boolean
    //
    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId8(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing - Integer
    //

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId9(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;


    if (lpNdsDestObject->NdsValue.value_9.OctetString) {

        FreeADsMem(
            lpNdsDestObject->NdsValue.value_9.OctetString
            );
    }

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId10(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_10.TelephoneNumber);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId11(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_11.TelephoneNumber);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId12(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if (lpNdsDestObject->NdsValue.value_12.Address) {

        FreeADsMem(lpNdsDestObject->NdsValue.value_12.Address);
    }

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId13(
    PNDSOBJECT lpNdsDestObject
    )
{
    //
    // BugBug 13 Leaks like a sieve!!
    //

    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_13 pStart = NULL;
    LPNDS_ASN1_TYPE_13 pTemp = NULL;

    if (lpNdsDestObject->NdsValue.value_13.Data) {
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);
    }


    pStart = lpNdsDestObject->NdsValue.value_13.Next;


    while (pStart){
        pTemp = pStart;

        pStart = pTemp->Next;

        if (pTemp->Data) {
            FreeADsMem(pTemp->Data);
        }
        FreeADsMem(pTemp);
    }

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId14(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_14.Address);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId15(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_15.VolumeName);

    FreeADsStr(lpNdsDestObject->NdsValue.value_15.Path);

    RRETURN(hr);
}



HRESULT
NdsTypeFreeNDSSynId16(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPNDS_ASN1_TYPE_12 lpNdsTempASN1_12 = NULL;


    FreeADsStr(lpNdsDestObject->NdsValue.value_16.ServerName);

    dwCount =  lpNdsDestObject->NdsValue.value_16.Count;


    lpNdsTempASN1_12 = lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints;


    for (i = 0; i < dwCount; i++) {

         if ((lpNdsTempASN1_12 + i)->Address) {

             FreeADsMem((lpNdsTempASN1_12 + i)->Address);
         }
    }

    FreeADsMem(lpNdsTempASN1_12);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId17(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_17.ProtectedAttrName);

    FreeADsStr(lpNdsDestObject->NdsValue.value_17.SubjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId18(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;

    for (i = 0; i < 6; i++) {
        FreeADsStr(lpNdsDestObject->NdsValue.value_18.PostalAddress[i]);
    }

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId19(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing for 19
    //

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId20(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_20.ClassName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId21(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // BugBug - how do we handle this byte stream!!
    //

    //
    // BugBug 21 -still don't know how to handle this
    //

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId22(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    //
    // DoNothing for 22
    //

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId23(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_23.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId24(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing
    //

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId25(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_25.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId26(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_26.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId27(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    //
    // Nothing to do for this one
    //

    RRETURN(hr);
}


HRESULT
NdsTypeClear(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsDestObject->NdsType) {
    case 1:
        hr = NdsTypeFreeNDSSynId1(
                lpNdsDestObject
                );
        break;

    case 2:
        hr = NdsTypeFreeNDSSynId2(
                lpNdsDestObject
                );
        break;


    case 3:
        hr = NdsTypeFreeNDSSynId3(
                lpNdsDestObject
                );
        break;

    case 4:
        hr = NdsTypeFreeNDSSynId4(
                lpNdsDestObject
                );
        break;

    case 5:
        hr = NdsTypeFreeNDSSynId5(
                lpNdsDestObject
                );
        break;

    case 6:
        hr = NdsTypeFreeNDSSynId6(
                lpNdsDestObject
                );
        break;

    case 7:
        hr = NdsTypeFreeNDSSynId7(
                lpNdsDestObject
                );
        break;

    case 8:
        hr = NdsTypeFreeNDSSynId8(
                lpNdsDestObject
                );
        break;


    case 9:
        hr = NdsTypeFreeNDSSynId9(
                lpNdsDestObject
                );
        break;

    case 10:
        hr = NdsTypeFreeNDSSynId10(
                lpNdsDestObject
                );
        break;

    case 11:
        hr = NdsTypeFreeNDSSynId11(
                lpNdsDestObject
                );
        break;

    case 12:
        hr = NdsTypeFreeNDSSynId12(
                lpNdsDestObject
                );
        break;


    case 13:
        hr = NdsTypeFreeNDSSynId13(
                lpNdsDestObject
                );
        break;

    case 14:
        hr = NdsTypeFreeNDSSynId14(
                lpNdsDestObject
                );
        break;

    case 15:
        hr = NdsTypeFreeNDSSynId15(
                lpNdsDestObject
                );
        break;

    case 16:
        hr = NdsTypeFreeNDSSynId16(
                lpNdsDestObject
                );
        break;


    case 17:
        hr = NdsTypeFreeNDSSynId17(
                lpNdsDestObject
                );
        break;

    case 18:
        hr = NdsTypeFreeNDSSynId18(
                lpNdsDestObject
                );
        break;

    case 19:
        hr = NdsTypeFreeNDSSynId19(
                lpNdsDestObject
                );
        break;

    case 20:
        hr = NdsTypeFreeNDSSynId20(
                lpNdsDestObject
                );
        break;

    case 21:
        hr = NdsTypeFreeNDSSynId21(
                lpNdsDestObject
                );
        break;

    case 22:
        hr = NdsTypeFreeNDSSynId22(
                lpNdsDestObject
                );
        break;

    case 23:
        hr = NdsTypeFreeNDSSynId23(
                lpNdsDestObject
                );
        break;

    case 24:
        hr = NdsTypeFreeNDSSynId24(
                lpNdsDestObject
                );
        break;

    case 25:
        hr = NdsTypeFreeNDSSynId25(
                lpNdsDestObject
                );
        break;

    case 26:
        hr = NdsTypeFreeNDSSynId26(
                lpNdsDestObject
                );
        break;

    case 27:
        hr = NdsTypeFreeNDSSynId27(
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



void
NdsTypeFreeNdsObjects(
    PNDSOBJECT pNdsObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         NdsTypeClear(pNdsObject + i);
    }

    FreeADsMem(pNdsObject);

    return;
}

HRESULT
FreeNdsValues(
    nuint32 luSyntax,
    void *attrVal, 
    nuint32 luAttrValSize
    )
{
    HRESULT hr = S_OK;

    switch (luSyntax) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        FreeADsMem(attrVal);
        break;

    case 6: {
        pCI_List_T pCurr = (pCI_List_T) attrVal, pTemp = NULL;

        FreeADsMem(pCurr->s);

        pCurr = pCurr->next;

        while (pCurr) {

            pTemp = pCurr;
            pCurr = pCurr->next;

            FreeADsMem(pTemp->s);
            FreeADsMem(pTemp);
        }
        FreeADsMem(attrVal);
        break;
    }

    case 7:
    case 8:
        FreeADsMem(attrVal);
        break;

    case 9: {
        pOctet_String_T pOctetString = (pOctet_String_T) attrVal;

        FreeADsMem(pOctetString->data);
        FreeADsMem(pOctetString);
        break;
    }

    case 10:
        FreeADsMem(attrVal);
        break;

    case 11: {
        pFax_Number_T pFaxNumber = (pFax_Number_T) attrVal;

        FreeADsMem(pFaxNumber->telephoneNumber);
        FreeADsMem(pFaxNumber->parameters.data);

        FreeADsMem(pFaxNumber);
        break;

    }

    case 12: {
        pNet_Address_T pNetAddress = (pNet_Address_T) attrVal;
        
        FreeADsMem(pNetAddress->address);
        FreeADsMem(pNetAddress);
        break;
    }

    case 13: {

        pOctet_List_T pCurr = (pOctet_List_T) attrVal, pTemp = NULL;
        FreeADsMem(pCurr->data);

        pCurr = pCurr->next;

        while (pCurr) {

            pTemp = pCurr;
            pCurr = pCurr->next;

            FreeADsMem(pTemp->data);
            FreeADsMem(pTemp);
        }
        FreeADsMem(attrVal);
        break;

    }

    case 14: {
        pEMail_Address_T pEMailAddress = (pEMail_Address_T) attrVal;

        FreeADsMem(pEMailAddress->address);
        FreeADsMem(pEMailAddress);
        break;
    }

    case 15: {
        pPath_T pPath = (pPath_T) attrVal;

        FreeADsMem(pPath->path);
        FreeADsMem(pPath->volumeName);
        FreeADsMem(pPath);
        break;
    }

    case 16: {
        pReplica_Pointer_T pReplicaPointer = (pReplica_Pointer_T) attrVal;

        FreeADsMem(pReplicaPointer->serverName);

        for (DWORD i=0; i < pReplicaPointer->count; i++) {
            FreeADsMem(pReplicaPointer->replicaAddressHint[i].address);
        }
        FreeADsMem(pReplicaPointer);
        break;
    }

    case 17: {
        pObject_ACL_T pObjectACL = (pObject_ACL_T) attrVal;

        FreeADsMem(pObjectACL->protectedAttrName);
        FreeADsMem(pObjectACL->subjectName);
        FreeADsMem(pObjectACL);
        break;
    }

    case 18: {
        LPWSTR *pPostalAddresses = (LPWSTR *) attrVal;

        for (DWORD i=0; i<6; i++) {
            FreeADsMem(pPostalAddresses[i]);
        }
        FreeADsMem(pPostalAddresses);

        break;
    }

    case 19:
        FreeADsMem(attrVal);
        break;

    case 20:
        FreeADsMem(attrVal);
        break;

    case 21:
        //
        // Bugbug: more processing might be needed. 
        //
        FreeADsMem(attrVal);
        break;

    case 22:
        FreeADsMem(attrVal);
        break;

    case 23: {
        pBack_Link_T pBackLink = (pBack_Link_T) attrVal;

        FreeADsMem(pBackLink->objectName);
        FreeADsMem(pBackLink);
        break;
    }

    case 24: 
        FreeADsMem(attrVal);
        break;

    case 25: {
        pTyped_Name_T pTypedName = (pTyped_Name_T) attrVal;

        FreeADsMem(pTypedName->objectName);
        FreeADsMem(pTypedName);
        break;
    }

    case 26: {
        pHold_T pHold = (pHold_T) attrVal;

        FreeADsMem(pHold->objectName);
        FreeADsMem(pHold);
        break;
    }

    case 27:
        FreeADsMem(attrVal);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndstemp.h ===
/* Structure definitions used */

#include <ndssntx.h>

#include <ndsattr.h>
#include <ndsclass.h>


/* Netware NDS general definitions */

#define NDS_MAX_NAME_CHARS           256
#define NDS_MAX_NAME_SIZE            ( NDS_MAX_NAME_CHARS * 2 )
#define NDS_MAX_SCHEMA_NAME_CHARS    32
#define NDS_MAX_SCHEMA_NAME_BYTES    ( 2 * ( NDS_MAX_SCHEMA_NAME_CHARS + 1 ) )
#define NDS_MAX_TREE_NAME_LEN        32
#define NDS_MAX_ASN1_NAME_LEN        32
#define NDS_NO_MORE_ITERATIONS       0xFFFFFFFF
#define NDS_INITIAL_SEARCH           0xFFFFFFFF


/* Netware NDS create buffer operations */

#define NDS_OBJECT_ADD               0
#define NDS_OBJECT_MODIFY            1
#define NDS_OBJECT_READ              2
#define NDS_OBJECT_LIST_SUBORDINATES 3
#define NDS_SCHEMA_DEFINE_CLASS      4
#define NDS_SCHEMA_READ_ATTR_DEF     5
#define NDS_SCHEMA_READ_CLASS_DEF    6
#define NDS_SEARCH                   7


/* Netware NDS attribute modification operations */

#define NDS_ATTR_ADD              0 /* Add attribute to object */
#define NDS_ATTR_REMOVE           1 /* Remove attribute from object */
#define NDS_ATTR_CLEAR            6 /* Remove all values from an attribute */


/* Other Netware NDS attribute modification operation - NOT YET SUPPORTED */

#define NDS_ATTR_ADD_VALUE          2 /* Add a value to an attribute */
#define NDS_ATTR_REMOVE_VALUE       3 /* Remove a value from an attribute */
#define NDS_ATTR_ADDITIONAL_VALUE   4 /* Add additional value to an attribute */
#define NDS_ATTR_OVERWRITE_VALUE    5 /* Overwrite a value to an attribute */
#define NDS_ATTR_CLEAR_VALUE        7 /* Remove a value from an attribute */


/* Netware NDS schema attribute definition flags */

#define NDS_SINGLE_VALUED_ATTR      0x0001
#define NDS_SIZED_ATTR              0x0002
#define NDS_NONREMOVABLE_ATTR       0x0004 // Only for NwNDSReadAttributeDef
#define NDS_READ_ONLY_ATTR          0x0008 // Only for NwNDSReadAttributeDef
#define NDS_HIDDEN_ATTR             0x0010 // Only for NwNDSReadAttributeDef
#define NDS_STRING_ATTR             0x0020 // Only for NwNDSReadAttributeDef
#define NDS_SYNC_IMMEDIATE          0x0040
#define NDS_PUBLIC_READ             0x0080
#define NDS_SERVER_READ             0x0100 // Only for NwNDSReadAttributeDef
#define NDS_WRITE_MANAGED           0x0200
#define NDS_PER_REPLICA             0x0400


/* Netware NDS schema class definition flags */

#define NDS_CONTAINER_CLASS               0x01
#define NDS_EFFECTIVE_CLASS               0x02
#define NDS_NONREMOVABLE_CLASS            0x04
#define NDS_AMBIGUOUS_NAMING              0x08
#define NDS_AMBIGUOUS_CONTAINMENT         0x10


/* Netware NDS information flags */

#define NDS_INFO_NAMES                     0 // Search and Read operations
#define NDS_INFO_ATTR_NAMES_VALUES         1 // Search operations
#define NDS_INFO_NAMES_DEFS                1 // Read operations
#define NDS_CLASS_INFO_EXPANDED_DEFS       2 // Schema class definition only


/* Netware NDS information flags - NOT YET SUPPORTED */

#define NDS_CLASS_INFO                     3 // Schema class definition only


/* Netware NDS attribute right definitions */

#define NDS_RIGHT_COMPARE_ATTR             0x00000001L
#define NDS_RIGHT_READ_ATTR                0x00000002L
#define NDS_RIGHT_WRITE_ATTR               0x00000004L
#define NDS_RIGHT_ADD_SELF_ATTR            0x00000008L
#define NDS_RIGHT_SUPERVISE_ATTR           0x00000020L


/* Netware NDS object right definitions */

#define NDS_RIGHT_BROWSE_OBJECT            0x00000001L
#define NDS_RIGHT_CREATE_OBJECT            0x00000002L
#define NDS_RIGHT_DELETE_OBJECT            0x00000004L
#define NDS_RIGHT_RENAME_OBJECT            0x00000008L
#define NDS_RIGHT_SUPERVISE_OBJECT         0x00000010L


/* Netware file right definitions */

#define NW_RIGHTS WORD

#define NW_RIGHT_NONE                     0x0000
#define NW_RIGHT_READ_FROM_FILE           0x0001
#define NW_RIGHT_WRITE_TO_FILE            0x0002
#define NW_RIGHT_CREATE_DIR_OR_FILE       0x0008
#define NW_RIGHT_ERASE_DIR_OR_FILE        0x0010
#define NW_RIGHT_ACCESS_CONTROL           0x0020
#define NW_RIGHT_FILE_SCAN                0x0040
#define NW_RIGHT_MODIFY_DIR_OR_FILE       0x0080
#define NW_RIGHT_SUPERVISOR               0x0100
#define NW_RIGHT_ALL                      NW_RIGHT_READ_FROM_FILE     | \
                                          NW_RIGHT_WRITE_TO_FILE      | \
                                          NW_RIGHT_CREATE_DIR_OR_FILE | \
                                          NW_RIGHT_ERASE_DIR_OR_FILE  | \
                                          NW_RIGHT_ACCESS_CONTROL     | \
                                          NW_RIGHT_FILE_SCAN          | \
                                          NW_RIGHT_MODIFY_DIR_OR_FILE


/* Netware NDS query node operations for building a search query */

#define NDS_QUERY_OR                       0x00000001L
#define NDS_QUERY_AND                      0x00000002L
#define NDS_QUERY_NOT                      0x00000003L
#define NDS_QUERY_EQUAL                    0x00000007L
#define NDS_QUERY_GE                       0x00000008L
#define NDS_QUERY_LE                       0x00000009L
#define NDS_QUERY_APPROX                   0x0000000AL
#define NDS_QUERY_PRESENT                  0x0000000FL


/* Netware NDS function return codes */

#define NDS_ERR_SUCCESS                     0x00000000
#define NDS_ERR_NO_SUCH_ENTRY               0xFFFFFDA7
#define NDS_ERR_NO_SUCH_VALUE               0xFFFFFDA6
#define NDS_ERR_NO_SUCH_ATTRIBUTE           0xFFFFFDA5
#define NDS_ERR_NO_SUCH_CLASS               0xFFFFFDA4
#define NDS_ERR_NO_SUCH_PARTITION           0xFFFFFDA3
#define NDS_ERR_ENTRY_ALREADY_EXISTS        0xFFFFFDA2
#define NDS_ERR_NOT_EFFECTIVE_CLASS         0xFFFFFDA1
#define NDS_ERR_ILLEGAL_ATTRIBUTE           0xFFFFFDA0
#define NDS_ERR_MISSING_MANDATORY           0xFFFFFD9F
#define NDS_ERR_ILLEGAL_DS_NAME             0xFFFFFD9E
#define NDS_ERR_ILLEGAL_CONTAINMENT         0xFFFFFD9D
#define NDS_ERR_CANT_HAVE_MULTIPLE_VALUES   0xFFFFFD9C
#define NDS_ERR_SYNTAX_VIOLATION            0xFFFFFD9B
#define NDS_ERR_DUPLICATE_VALUE             0xFFFFFD9A
#define NDS_ERR_ATTRIBUTE_ALREADY_EXISTS    0xFFFFFD99
#define NDS_ERR_MAXIMUM_ENTRIES_EXIST       0xFFFFFD98
#define NDS_ERR_DATABASE_FORMAT             0xFFFFFD97
#define NDS_ERR_INCONSISTANT_DATABASE       0xFFFFFD96
#define NDS_ERR_INVALID_COMPARISON          0xFFFFFD95
#define NDS_ERR_COMPARISON_FAILED           0xFFFFFD94
#define NDS_ERR_TRANSACTIONS_DISABLED       0xFFFFFD93
#define NDS_ERR_INVALID_TRANSPORT           0xFFFFFD92
#define NDS_ERR_SYNTAX_INVALID_IN_NAME      0xFFFFFD91
#define NDS_ERR_REPLICA_ALREADY_EXISTS      0xFFFFFD90
#define NDS_ERR_TRANSPORT_FAILURE           0xFFFFFD8F
#define NDS_ERR_ALL_REFERRALS_FAILED        0xFFFFFD8E
#define NDS_ERR_CANT_REMOVE_NAMING_VALUE    0xFFFFFD8D
#define NDS_ERR_OBJECT_CLASS_VIOLATION      0xFFFFFD8C
#define NDS_ERR_ENTRY_IS_NOT_LEAF           0xFFFFFD8B
#define NDS_ERR_DIFFERENT_TREE              0xFFFFFD8A
#define NDS_ERR_ILLEGAL_REPLICA_TYPE        0xFFFFFD89
#define NDS_ERR_SYSTEM_FAILURE              0xFFFFFD88
#define NDS_ERR_INVALID_ENTRY_FOR_ROOT      0xFFFFFD87
#define NDS_ERR_NO_REFERRALS                0xFFFFFD86
#define NDS_ERR_REMOTE_FAILURE              0xFFFFFD85
#define NDS_ERR_PREVIOUS_MOVE_IN_PROGRESS   0xFFFFFD83
#define NDS_ERR_INVALID_REQUEST             0xFFFFFD7F
#define NDS_ERR_INVALID_ITERATION           0xFFFFFD7E
#define NDS_ERR_SCHEMA_IS_NONREMOVABLE      0xFFFFFD7D
#define NDS_ERR_SCHEMA_IS_IN_USE            0xFFFFFD7C
#define NDS_ERR_CLASS_ALREADY_EXISTS        0xFFFFFD7B
#define NDS_ERR_BAD_NAMING_ATTRIBUTES       0xFFFFFD7A
#define NDS_ERR_NOT_ROOT_PARTITION          0xFFFFFD79
#define NDS_ERR_INSUFFICIENT_STACK          0xFFFFFD78
#define NDS_ERR_INSUFFICIENT_BUFFER         0xFFFFFD77
#define NDS_ERR_AMBIGUOUS_CONTAINMENT       0xFFFFFD76
#define NDS_ERR_AMBIGUOUS_NAMING            0xFFFFFD75
#define NDS_ERR_DUPLICATE_MANDATORY         0xFFFFFD74
#define NDS_ERR_DUPLICATE_OPTIONAL          0xFFFFFD73
#define NDS_ERR_MULTIPLE_REPLICAS           0xFFFFFD71
#define NDS_ERR_CRUCIAL_REPLICA             0xFFFFFD70
#define NDS_ERR_SCHEMA_SYNC_IN_PROGRESS     0xFFFFFD6F
#define NDS_ERR_SKULK_IN_PROGRESS           0xFFFFFD6E
#define NDS_ERR_TIME_NOT_SYNCRONIZED        0xFFFFFD6D
#define NDS_ERR_RECORD_IN_USE               0xFFFFFD6C
#define NDS_ERR_DS_VOLUME_NOT_MOUNTED       0xFFFFFD6B
#define NDS_ERR_DS_VOLUME_IO_FAILURE        0xFFFFFD6A
#define NDS_ERR_DS_LOCKED                   0xFFFFFD69
#define NDS_ERR_OLD_EPOCH                   0xFFFFFD68
#define NDS_ERR_NEW_EPOCH                   0xFFFFFD67
#define NDS_ERR_PARTITION_ROOT              0xFFFFFD65
#define NDS_ERR_ENTRY_NOT_CONTAINER         0xFFFFFD64
#define NDS_ERR_FAILED_AUTHENTICATION       0xFFFFFD63
#define NDS_ERR_NO_SUCH_PARENT              0xFFFFFD61
#define NDS_ERR_NO_ACCESS                   0xFFFFFD60
#define NDS_ERR_REPLICA_NOT_ON              0xFFFFFD5F
#define NDS_ERR_DUPLICATE_ACL               0xFFFFFD5A
#define NDS_ERR_PARTITION_ALREADY_EXISTS    0xFFFFFD59
#define NDS_ERR_NOT_SUBREF                  0xFFFFFD58
#define NDS_ERR_ALIAS_OF_AN_ALIAS           0xFFFFFD57
#define NDS_ERR_AUDITING_FAILED             0xFFFFFD56
#define NDS_ERR_INVALID_API_VERSION         0xFFFFFD55
#define NDS_ERR_SECURE_NCP_VIOLATION        0xFFFFFD54
#define NDS_ERR_FATAL                       0xFFFFFD45


typedef struct _WSTR_LIST_ELEM
{
    struct _WSTR_LIST_ELEM * Next;
    LPWSTR                   szString;

} WSTR_LIST_ELEM, * LPWSTR_LIST;

typedef struct
{
    DWORD length;
    BYTE  data[256];

} ASN1_ID, * LPASN1_ID;

//
// NDS Attribute Definition structure
//
typedef struct
{
    LPWSTR  szAttributeName;
    DWORD   dwFlags;
    DWORD   dwSyntaxID;
    DWORD   dwLowerLimit;
    DWORD   dwUpperLimit;
    Asn1ID_T asn1ID;

} NDS_ATTR_DEF, * PNDS_ATTR_DEF, * LPNDS_ATTR_DEF;

//
// NDS Class Definition structure
//
typedef struct
{
    LPWSTR  szClassName;
    DWORD   dwFlags;
    Asn1ID_T asn1ID;
    DWORD   dwNumberOfSuperClasses;
    LPWSTR_LIST lpSuperClasses;
    DWORD   dwNumberOfContainmentClasses;
    LPWSTR_LIST lpContainmentClasses;
    DWORD   dwNumberOfNamingAttributes;
    LPWSTR_LIST lpNamingAttributes;
    DWORD   dwNumberOfMandatoryAttributes;
    LPWSTR_LIST lpMandatoryAttributes;
    DWORD   dwNumberOfOptionalAttributes;
    LPWSTR_LIST lpOptionalAttributes;

} NDS_CLASS_DEF, *PNDS_CLASS_DEF, *LPNDS_CLASS_DEF;

//
// If read results from NwNdsReadAttrDef, or NwNdsReadClassDef
// returned names only (no attribute or class definitions),
// then an array of these NDS_DEF_NAME_ONLY structures is returned.
//
typedef struct
{
    LPWSTR szName;

} NDS_NAME_ONLY, * PNDS_NAME_ONLY, * LPNDS_NAME_ONLY;

//
// NDS Attribute Information structure
//
typedef struct
{
    LPWSTR szAttributeName;
    DWORD  dwSyntaxId;
    DWORD  dwNumberOfValues;
    PNDSOBJECT lpValue;

} NDS_ATTR_INFO, * PNDS_ATTR_INFO, * LPNDS_ATTR_INFO;

//
// NDS Object Information structure
//
typedef struct
{
    LPWSTR szObjectFullName;
    LPWSTR szObjectName;
    LPWSTR szObjectClass;
    DWORD  dwEntryId;
    DWORD  dwModificationTime;
    DWORD  dwSubordinateCount;
    DWORD  dwNumberOfAttributes; // Zero for NwNdsReadObject results.
    LPVOID lpAttribute;          // For NwNdsSearch results, cast this
                                 // to either LPNDS_ATTR_INFO or
                                 // LPNDS_NAME_ONLY, depending on value of
                                 // lpdwAttrInformationType from call to
                                 // NwNdsGetObjectListFromBuffer.

} NDS_OBJECT_INFO, * LPNDS_OBJECT_INFO;


//
// List Subordinate Objects Search Filter structures
//
typedef struct
{
    LPWSTR szObjectClass;

} NDS_FILTER, * LPNDS_FILTER;

typedef struct
{
    DWORD      dwNumberOfFilters;
    NDS_FILTER Filters[1];

} NDS_FILTER_LIST, * LPNDS_FILTER_LIST;

//
// NDS Search Query Tree structure
//
typedef struct _QUERY_NODE
{
    DWORD dwOperation;
    DWORD dwSyntaxId;
    struct _QUERY_NODE * lpLVal;
    struct _QUERY_NODE * lpRVal;

} QUERY_NODE, * LPQUERY_NODE, * LPQUERY_TREE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\nwndsres.h ===
#define NWNDS_PROVIDER_ID    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\nwcmacro.h ===
//
// Return Code macro
//
#define NWCCODE_FAILED(Status) ((Status) != SUCCESSFUL)

#define NWCCODE_SUCCEEDED(Status) ((Status) == SUCCESSFUL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndsufree.cxx ===
/+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Freeright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsufree.cxx
//
//  Contents:
//
//  Functions:
//
//                FreeABC1ToNDSSynId1
//                FreeABC2ToNDSSynId2
//                FreeABC3ToNDSSynId3
//                FreeABC4ToNDSSynId4
//                FreeABC5ToNDSSynId5
//                FreeABC6ToNDSSynId6
//                FreeABC7ToNDSSynId7
//                FreeABC8ToNDSSynId8
//                FreeABC9ToNDSSynId9
//                FreeABC10ToNDSSynId10
//                FreeABC11ToNDSSynId11
//                FreeABC12ToNDSSynId12
//                FreeABC13ToNDSSynId13
//                FreeABC14ToNDSSynId14
//                FreeABC15ToNDSSynId15
//                FreeABC16ToNDSSynId16
//                FreeABC17ToNDSSynId17
//                FreeABC18ToNDSSynId18
//                FreeABC19ToNDSSynId19
//                FreeABC20ToNDSSynId20
//                FreeABC21ToNDSSynId21
//                FreeABC22ToNDSSynId22
//                FreeABC23ToNDSSynId23
//                FreeABC24ToNDSSynId24
//                FreeABC25ToNDSSynId25
//                FreeABC26ToNDSSynId26
//                FreeABC27ToNDSSynId27
//
//  History:      15-Jul-97   FelixW   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


LPBYTE
FreeNDSSynId1ToNDS1(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;

    if (lpASN1_1->DNString) {
        FreeADsStr(lpASN1_1->DNString);
    }

    lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);

    return(lpByte);

}

LPBYTE
FreeNDSSynId2ToNDS2(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_2 lpASN1_2 = (LPASN1_TYPE_2) lpByte;

    if (lpASN1_2->CaseExactString) {
        FreeADsStr(lpASN1_2->CaseExactString);
    }

    lpByte = (LPBYTE ) lpASN1_2 + sizeof(ASN1_TYPE_2);

    return(lpByte);
}



LPBYTE
FreeNDSSynId3ToNDS3(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_3 lpASN1_3 = (LPASN1_TYPE_3) lpByte;

    if (lpASN1_3->CaseIgnoreString) {
        FreeADsStr(lpASN1_3->CaseIgnoreString);
    }

    lpByte = (LPBYTE ) lpASN1_3 + sizeof(ASN1_TYPE_3);

    return(lpByte);
}

LPBYTE
FreeNDSSynId4ToNDS4(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_4 lpASN1_4 = (LPASN1_TYPE_4) lpByte;

    if (lpASN1_4->PrintableString) {
        FreeADsStr(lpASN1_4->PrintableString);
    }

    lpByte = (LPBYTE ) lpASN1_4 + sizeof(ASN1_TYPE_4);

    return(lpByte);

}


LPBYTE
FreeNDSSynId5ToNDS5(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_5 lpASN1_5 = (LPASN1_TYPE_5) lpByte;

    if (lpASN1_5->NumericString) {
        FreeADsStr(lpASN1_5->NumericString);
    }

    lpByte = (LPBYTE ) lpASN1_5 + sizeof(ASN1_TYPE_5);

    return(lpByte);
}

LPBYTE
FreeNDSSynId6ToNDS6(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;

    if (lpASN1_6->String) {
        FreeADsStr(lpASN1_6->String);
    }


    while (lpASN1_6->Next)
    {

        if (lpASN1_6->String) {
            FreeADsStr(lpASN1_6->String);
        }
        lpASN1_6 = (LPASN1_TYPE_6)lpASN1_6->Next;

    }

    lpByte = (LPBYTE ) lpASN1_6 + sizeof(ASN1_TYPE_6);

    return(lpByte);
}


LPBYTE
FreeNDSSynId7ToNDS7(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;
    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
FreeNDSSynId8ToNDS8(
    LPBYTE lpByte
    )

{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;
    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
FreeNDSSynId9ToNDS9(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;

    if (lpASN1_9->OctetString) {
        FreeADsMem((LPBYTE)lpASN1_9->OctetString);
    }

    lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);

    return(lpByte);
}

LPBYTE
FreeNDSSynId10ToNDS10(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_10 lpASN1_10 = (LPASN1_TYPE_10) lpByte;

    if (lpASN1_10->TelephoneNumber) {
        FreeADsStr(lpASN1_10->TelephoneNumber);
    }

    lpByte = (LPBYTE ) lpASN1_10 + sizeof(ASN1_TYPE_10);

    return(lpByte);
}

LPBYTE
FreeNDSSynId11ToNDS11(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;

    if (lpASN1_11->TelephoneNumber) {
        FreeADsStr(lpASN1_11->TelephoneNumber);
    }

    lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);

    return(lpByte);
}

LPBYTE
FreeNDSSynId12ToNDS12(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;

    if (lpASN1_12->Address) {
        FreeADsMem((LPBYTE)lpASN1_12->Address);
    }

    lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);

    return(lpByte);
}

LPBYTE
FreeNDSSynId13ToNDS13(
    LPBYTE lpByte
    )
{

    //
    // BugBug: KrishnaG not supported!
    //
    return(lpByte);
}


LPBYTE
FreeNDSSynId14ToNDS14(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;

    if (lpASN1_14->Address) {
        FreeADsStr(lpASN1_14->Address);
    }

    lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);

    return(lpByte);
}


LPBYTE
FreeNDSSynId15ToNDS15(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;

    if (lpASN1_15->VolumeName) {
        FreeADsStr(lpASN1_15->VolumeName);
    }

    if (lpASN1_15->Path) {
        FreeADsStr(lpASN1_15->Path);
    }

    lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);

    return(lpByte);
}

LPBYTE
FreeNDSSynId16ToNDS16(
    LPBYTE lpByte
    )
{

    //
    // BugBug: KrishnaG not supported!
    //

    return(lpByte);
}


LPBYTE
FreeNDSSynId17ToNDS17(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;


    if (lpASN1_17->ProtectedAttrName) {
        FreeADsStr(lpASN1_17->ProtectedAttrName);
    }

    if (lpASN1_17->SubjectName) {
        FreeADsStr(lpASN1_17->SubjectName);
    }

    lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);

    return(lpByte);
}


LPBYTE
FreeNDSSynId18ToNDS18(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;


    if (lpASN1_18->PostalAddress[0]) {
        FreeADsStr(lpASN1_18->PostalAddress[0]);
    }
    if (lpASN1_18->PostalAddress[1]) {
        FreeADsStr(lpASN1_18->PostalAddress[1]);
    }
    if (lpASN1_18->PostalAddress[2]) {
        FreeADsStr(lpASN1_18->PostalAddress[2]);
    }
    if (lpASN1_18->PostalAddress[3]) {
        FreeADsStr(lpASN1_18->PostalAddress[3]);
    }
    if (lpASN1_18->PostalAddress[4]) {
        FreeADsStr(lpASN1_18->PostalAddress[4]);
    }
    if (lpASN1_18->PostalAddress[5]) {
        FreeADsStr(lpASN1_18->PostalAddress[5]);
    }


    lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);


    return(lpByte);
}

LPBYTE
FreeNDSSynId19ToNDS19(
    LPBYTE lpByte
    )
{

    //
    // BugBug: KrishnaG not supported!
    //
    return(lpByte);

    LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;

    lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);

    return(lpByte);
}

LPBYTE
FreeNDSSynId20ToNDS20(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_20 lpASN1_20 = (LPASN1_TYPE_20) lpByte;

    if (lpASN1_20->ClassName) {
        FreeADsStr(lpASN1_20->ClassName);
    }

    lpByte = (LPBYTE ) lpASN1_20 + sizeof(ASN1_TYPE_20);

    return(lpByte);
}


LPBYTE
FreeNDSSynId21ToNDS21(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;

    //
    // The Length value is supposedly always zero!!
    //

    lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);

    return(lpByte);

}



LPBYTE
FreeNDSSynId22ToNDS22(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_22 lpASN1_22 = (LPASN1_TYPE_22) lpByte;

    lpByte = (LPBYTE ) lpASN1_22 + sizeof(ASN1_TYPE_22);

    return(lpByte);
}

LPBYTE
FreeNDSSynId23ToNDS23(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;

    if (lpASN1_23->ObjectName) {
        FreeADsStr(lpASN1_23->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);

    return(lpByte);
}

LPBYTE
FreeNDSSynId24ToNDS24(
    LPBYTE lpByte

    )
{
    LPASN1_TYPE_24 lpASN1_24 = (LPASN1_TYPE_24) lpByte;

    lpByte = (LPBYTE ) lpASN1_24 + sizeof(ASN1_TYPE_24);

    return(lpByte);
}



LPBYTE
FreeNDSSynId25ToNDS25(
    LPBYTE lpByte
    )

{
    LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;

    if (lpASN1_25->ObjectName) {
        FreeADsStr(lpASN1_25->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);

    return(lpByte);
}


LPBYTE
FreeNDSSynId26ToNDS26(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;


    if (lpASN1_26->ObjectName) {
        FreeADsStr(lpASN1_26->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);

    return(lpByte);
}


LPBYTE
FreeNDSSynId27ToNDS27(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_27 lpASN1_27 = (LPASN1_TYPE_27) lpByte;

    lpByte = (LPBYTE ) lpASN1_27 + sizeof(ASN1_TYPE_27);

    return(lpByte);
}


LPBYTE
FreeNDSSynIdToNDS(
    DWORD dwSyntaxId,
    LPBYTE lpByte
    )
{
    switch (dwSyntaxId) {
    case 1:
        lpByte = FreeNDSSynId1ToNDS1(
                        lpByte
                         );
        break;

    case 2:
        lpByte = FreeNDSSynId2ToNDS2(
                        lpByte
                         );
        break;

    case 3:
        lpByte = FreeNDSSynId3ToNDS3(
                        lpByte
                         );
        break;

    case 4:
        lpByte = FreeNDSSynId4ToNDS4(
                        lpByte
                         );
        break;

    case 5:
        lpByte = FreeNDSSynId5ToNDS5(
                        lpByte
                         );
        break;

    case 6:
        lpByte = FreeNDSSynId6ToNDS6(
                        lpByte
                         );
        break;

    case 7:
        lpByte = FreeNDSSynId7ToNDS7(
                        lpByte
                         );
        break;

    case 8:
        lpByte = FreeNDSSynId8ToNDS8(
                        lpByte
                         );
        break;


    case 9:
        lpByte = FreeNDSSynId9ToNDS9(
                        lpByte
                         );
        break;

    case 10:
        lpByte = FreeNDSSynId10ToNDS10(
                        lpByte
                         );
        break;

    case 11:
        lpByte = FreeNDSSynId11ToNDS11(
                        lpByte
                         );
        break;

    case 12:
        lpByte = FreeNDSSynId12ToNDS12(
                        lpByte
                         );
        break;

    case 13:
        lpByte = FreeNDSSynId13ToNDS13(
                        lpByte
                         );
        break;

    case 14:
        lpByte = FreeNDSSynId14ToNDS14(
                        lpByte
                         );
        break;

    case 15:
        lpByte = FreeNDSSynId15ToNDS15(
                        lpByte
                         );
        break;

    case 16:
        lpByte = FreeNDSSynId16ToNDS16(
                        lpByte
                         );
        break;


    case 17:
        lpByte = FreeNDSSynId17ToNDS17(
                        lpByte
                         );
        break;

    case 18:
        lpByte = FreeNDSSynId18ToNDS18(
                        lpByte
                         );
        break;

    case 19:
        lpByte = FreeNDSSynId19ToNDS19(
                        lpByte
                         );
        break;

    case 20:
        lpByte = FreeNDSSynId20ToNDS20(
                        lpByte
                         );
        break;


    case 21:
        lpByte = FreeNDSSynId21ToNDS21(
                        lpByte
                         );
        break;

    case 22:
        lpByte = FreeNDSSynId22ToNDS22(
                        lpByte
                         );
        break;

    case 23:
        lpByte = FreeNDSSynId23ToNDS23(
                        lpByte
                         );
        break;

    case 24:
        lpByte = FreeNDSSynId24ToNDS24(
                        lpByte
                         );
        break;

    case 25:
        lpByte = FreeNDSSynId25ToNDS25(
                        lpByte
                         );
        break;

    case 26:
        lpByte = FreeNDSSynId26ToNDS26(
                        lpByte
                         );
        break;

    case 27:
        lpByte = FreeNDSSynId27ToNDS27(
                        lpByte
                         );
        break;


    default:
        break;

    }

    return(lpByte);
}


HRESULT
FreeMarshallMemory(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    DWORD  i = 0;


    for (i = 0; i < dwNumValues; i++) {

        lpValue = FreeNDSSynIdToNDS(
                         dwSyntaxId,
                         lpValue
                         );

    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndstypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NDS
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      25-Apr-96   KrishnaG   Cloned off GlennC's ndssntx.h
//                                       to resolve inconsistencies with
//                                       datatypes
//
//----------------------------------------------------------------------------

#ifndef __NDSTYPES_HXX
#define __NDSTYPES_HXX

//
// NDS Distinguished Name
//
// Used in attributes: Alias Object Name, Default Queue, Device,
//                     Group Membership, Higher Privileges, Host Device,
//                     Host Server, Member, Message Server, Operator, Owner,
//                     Profile, Reference, Resource, Role Occupant,
//                     Security Equals, See Also, Server, User, Volume
//
typedef struct
{
    LPWSTR DNString;

} NDS_ASN1_TYPE_1, * LPNDS_ASN1_TYPE_1;

//
// NDS Case Exact String syntax
//
// Used in attribute: Home Directory
//
typedef struct
{
    LPWSTR CaseExactString;

} NDS_ASN1_TYPE_2, * LPNDS_ASN1_TYPE_2;

//
// NDS Case Ignore String syntax
//
// Used in attributes: Cartridge, CN (Common Name), C (Country Name),
//                     Description, Host Resource Name, L (Locality Name),
//                     O (Organization Name), OU (Organizational Unit Name),
//                     Physical Delivery Office Name, Postal Code,
//                     Postal Office Box, Queue Directory, SAP Name,
//                     S (State or Province Name), SA (Street Address),
//                     Supported Services, Supported Typefaces, Surname,
//                     Title, Unknown Base Class, Version
//
typedef struct
{
    LPWSTR CaseIgnoreString;

} NDS_ASN1_TYPE_3, * LPNDS_ASN1_TYPE_3;

//
// NDS Printable String syntax
//
// Used in attributes: Page Description Language, Serial Number
//
typedef struct
{
    LPWSTR PrintableString;

} NDS_ASN1_TYPE_4, * LPNDS_ASN1_TYPE_4;

//
// NDS Numeric String syntax
//
// Used in attributes: Bindery Type
//
typedef struct
{
    LPWSTR NumericString;

} NDS_ASN1_TYPE_5, * LPNDS_ASN1_TYPE_5;

//
// NDS Case Ignore List syntax
//
// Used in attribute: Language
//
typedef struct _NDS_CI_LIST
{
    struct _NDS_CI_LIST * Next;
    LPWSTR            String;

}
NDS_ASN1_TYPE_6, * LPNDS_ASN1_TYPE_6;

//
// NDS Boolean syntax
//
// Used in attributes: Allow Unlimited Credit, Detect Intruder,
//                     Lockout After Detection, Locked By Intruder,
//                     Login Diabled, Password Allow Change, Password Required,
//                     Password Unique Required
//
typedef struct
{
    DWORD Boolean;

} NDS_ASN1_TYPE_7, * LPNDS_ASN1_TYPE_7;

//
// Example: NDS Integer syntax
//
// Used in attributes: Bindery Object Restriction, Convergence, GID (Group ID),
//                     Login Grace Limit, Login Intruder Limit,
//                     Login Maximum Simultaneous, Memory,
//                     Minimum Account Balance, Password Minimum Length, Status,
//                     Supported Connections, UID (User ID)
//
typedef struct
{
    DWORD Integer;

} NDS_ASN1_TYPE_8, * LPNDS_ASN1_TYPE_8;

//
// NDS Octet String syntax
//
// Used in attributes: Athority Revocation, Bindery Property, CA Private Key,
//                     CA Public Key, Certificate Revocation,
//                     Cross Certificate Pair, Login Allowed Time Map,
//                     Passwords Used, Printer Configuration, Private Key,
//                     Public Key
//
typedef struct
{
    DWORD  Length;
    LPBYTE OctetString;

} NDS_ASN1_TYPE_9, * LPNDS_ASN1_TYPE_9;

//
// NDS Telephone Number syntax
//
// Used in attribute: Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;

} NDS_ASN1_TYPE_10, * LPNDS_ASN1_TYPE_10;

//
// NDS Facsimile Telephone Number syntax
//
// Used in attribute: Facsimile Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;

} NDS_ASN1_TYPE_11, * LPNDS_ASN1_TYPE_11;

//
// NDS Network Address syntax
//
// Used in attributes: Login Intruder Address, Network Address,
//                     Network Address Restriction
//
typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} NDS_ASN1_TYPE_12, * LPNDS_ASN1_TYPE_12;

//
// NDS Octet List syntax
//
// Used in attribute: (none)
//

typedef struct _NDS_OCTET_LIST
{
    struct _NDS_OCTET_LIST * Next;
    DWORD  Length;
    BYTE * Data;

}NDS_ASN1_TYPE_13, * LPNDS_ASN1_TYPE_13;

//
// NDS EMail Address syntax
//
// Used in attribute: EMail Address
//
typedef struct
{
    DWORD  Type;
    LPWSTR Address;

} NDS_ASN1_TYPE_14, * LPNDS_ASN1_TYPE_14;

//
// NDS Path syntax
//
// Used in attribute: Path
//
typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} NDS_ASN1_TYPE_15, * LPNDS_ASN1_TYPE_15;

//
// NDS Replica Pointer syntax
//
// Used in attribute: Replica
//
typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    LPNDS_ASN1_TYPE_12 ReplicaAddressHints;

    //
    // Note - This is where GlennC's datatypes and the ADs Nds Datatypes
    // part company. He expects a contiguous buffer of Type 12 structures
    // but the number of Type 12 structures cannot be determined until runtime
    //

    // ReplicaAddressHint is variable and
    // can be calculated by Count * the
    // length of a NDS_ASN1_TYPE_12 ( that is
    // Count * 9).


} NDS_ASN1_TYPE_16, * LPNDS_ASN1_TYPE_16;

//
// NDS Object ACL syntax
//
// Used in attributes: ACL, Inherited ACL
//
typedef struct
{
    LPWSTR ProtectedAttrName;
    LPWSTR SubjectName;
    DWORD  Privileges;

} NDS_ASN1_TYPE_17, * LPNDS_ASN1_TYPE_17;

//
// NDS Postal Address syntax
//
// Used in attribute: Postal Address
//
typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} NDS_ASN1_TYPE_18, * LPNDS_ASN1_TYPE_18;

//
// NDS Timestamp syntax
//
// Used in attribute: Obituary, Partition Creation Time, Received Up To,
//                    Syncronized Up To
//
typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} NDS_ASN1_TYPE_19, * LPNDS_ASN1_TYPE_19;

//
// NDS Class Name syntax
//
// Used in attribute: Object Class
//
typedef struct
{
    LPWSTR ClassName;

} NDS_ASN1_TYPE_20, * LPNDS_ASN1_TYPE_20;

//
// NDS Stream syntax
//
// Used in attribute: Login Script, Print Job Configuration, Printer Control,
//                    Type Creator Map
//
typedef struct
{
    DWORD  Length; // Always zero
    BYTE * Data;

} NDS_ASN1_TYPE_21, * LPNDS_ASN1_TYPE_21;

//
// NDS Count syntax
//
// Used in attributes: Account Balance, Login Grace Remaining,
//                     Login Intruder Attempts
//
typedef struct
{
    DWORD Counter;

} NDS_ASN1_TYPE_22, * LPNDS_ASN1_TYPE_22;

//
// NDS Back Link syntax
//
// Used in attribute: Back Link
//
typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} NDS_ASN1_TYPE_23, * LPNDS_ASN1_TYPE_23;

//
// NDS Time syntax
//
// Used in attributes: Last Login Time, Login Expiration Time,
//                     Login Intruder Rest Time, Login Time,
//                     Low Convergence Reset Time, Password Expiration Time
//
typedef struct
{
    DWORD Time; // (in whole seconds) zero equals 12:00 midnight,
                // January 1, 1970, UTC

} NDS_ASN1_TYPE_24, * LPNDS_ASN1_TYPE_24;

//
// NDS Typed Name syntax
//
// Used in attribute: Notify, Print Server, Printer, Queue
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} NDS_ASN1_TYPE_25, * LPNDS_ASN1_TYPE_25;

//
// NDS Hold syntax
//
// Used in attribute: Server Holds
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} NDS_ASN1_TYPE_26, * LPNDS_ASN1_TYPE_26;

//
// NDS Interval syntax
//
// Used in attribute: High Convergence Syncronization Interval,
//                    Intruder Attempt Reset Interval,
//                    Intruder Lockout Reset Interval,
//                    Low Convergence Syncronization Interval,
//                    Password Expiration Interval
//
typedef struct
{
    DWORD  Interval;

} NDS_ASN1_TYPE_27, * LPNDS_ASN1_TYPE_27;


#endif





typedef struct _ndstype{
    DWORD NdsType;
    union {
        NDS_ASN1_TYPE_1 value_1;
        NDS_ASN1_TYPE_2 value_2;
        NDS_ASN1_TYPE_3 value_3;
        NDS_ASN1_TYPE_4 value_4;
        NDS_ASN1_TYPE_5 value_5;

        NDS_ASN1_TYPE_6 value_6;
        NDS_ASN1_TYPE_7 value_7;
        NDS_ASN1_TYPE_8 value_8;
        NDS_ASN1_TYPE_9 value_9;
        NDS_ASN1_TYPE_10 value_10;


        NDS_ASN1_TYPE_11 value_11;
        NDS_ASN1_TYPE_12 value_12;
        NDS_ASN1_TYPE_13 value_13;
        NDS_ASN1_TYPE_14 value_14;
        NDS_ASN1_TYPE_15 value_15;


        NDS_ASN1_TYPE_16 value_16;
        NDS_ASN1_TYPE_17 value_17;
        NDS_ASN1_TYPE_18 value_18;
        NDS_ASN1_TYPE_19 value_19;
        NDS_ASN1_TYPE_20 value_20;


        NDS_ASN1_TYPE_21 value_21;
        NDS_ASN1_TYPE_22 value_22;
        NDS_ASN1_TYPE_23 value_23;
        NDS_ASN1_TYPE_24 value_24;
        NDS_ASN1_TYPE_25 value_25;

        NDS_ASN1_TYPE_26 value_26;
        NDS_ASN1_TYPE_27 value_27;
    }NdsValue;
}NDSOBJECT, *PNDSOBJECT, *LPNDSOBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndsurshl.cxx ===
/+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//                CopyABC1ToNDSSynId1
//                CopyABC2ToNDSSynId2
//                CopyABC3ToNDSSynId3
//                CopyABC4ToNDSSynId4
//                CopyABC5ToNDSSynId5
//                CopyABC6ToNDSSynId6
//                CopyABC7ToNDSSynId7
//                CopyABC8ToNDSSynId8
//                CopyABC9ToNDSSynId9
//                CopyABC10ToNDSSynId10
//                CopyABC11ToNDSSynId11
//                CopyABC12ToNDSSynId12
//                CopyABC13ToNDSSynId13
//                CopyABC14ToNDSSynId14
//                CopyABC15ToNDSSynId15
//                CopyABC16ToNDSSynId16
//                CopyABC17ToNDSSynId17
//                CopyABC18ToNDSSynId18
//                CopyABC19ToNDSSynId19
//                CopyABC20ToNDSSynId20
//                CopyABC21ToNDSSynId21
//                CopyABC22ToNDSSynId22
//                CopyABC23ToNDSSynId23
//                CopyABC24ToNDSSynId24
//                CopyABC25ToNDSSynId25
//                CopyABC26ToNDSSynId26
//                CopyABC27ToNDSSynId27
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//  Warnings:     NDS Data type 6 is not yet supported (no problems just
//                not done!
//
//                NDS Data type 16 need to complete the for loop code
//                NDS Data type 21 is the stream data type some stress.
//----------------------------------------------------------------------------
#include "nds.hxx"




LPBYTE
CopyNDSSynId1ToNDS1(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;

    lpASN1_1->DNString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_1.DNString
                        );

    lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);

    return(lpByte);

}

LPBYTE
CopyNDSSynId2ToNDS2(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_2 lpASN1_2 = (LPASN1_TYPE_2) lpByte;

    lpASN1_2->CaseExactString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_2.CaseExactString
                        );

    lpByte = (LPBYTE ) lpASN1_2 + sizeof(ASN1_TYPE_2);

    return(lpByte);
}



LPBYTE
CopyNDSSynId3ToNDS3(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_3 lpASN1_3 = (LPASN1_TYPE_3) lpByte;

    lpASN1_3->CaseIgnoreString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_3.CaseIgnoreString
                        );

    lpByte = (LPBYTE ) lpASN1_3 + sizeof(ASN1_TYPE_3);

    return(lpByte);
}

LPBYTE
CopyNDSSynId4ToNDS4(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_4 lpASN1_4 = (LPASN1_TYPE_4) lpByte;

    lpASN1_4->PrintableString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_4.PrintableString
                        );

    lpByte = (LPBYTE ) lpASN1_4 + sizeof(ASN1_TYPE_4);

    return(lpByte);

}


LPBYTE
CopyNDSSynId5ToNDS5(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_5 lpASN1_5 = (LPASN1_TYPE_5) lpByte;

    lpASN1_5->NumericString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_5.NumericString
                        );

    lpByte = (LPBYTE ) lpASN1_5 + sizeof(ASN1_TYPE_5);

    return(lpByte);
}

LPBYTE
CopyNDSSynId6ToNDS6(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;
    LPNDS_ASN1_TYPE_6 lpNdsTempASN1_6 = NULL;

    lpNdsTempASN1_6 = &(lpNdsObject->NdsValue.value_6);
    lpASN1_6->String =
                (LPWSTR)AllocADsStr(
                        lpNdsTempASN1_6->String
                        );
    if (!lpASN1_6->String)
        return NULL;


    while ( lpNdsTempASN1_6->Next)
    {

        lpASN1_6->Next = (LPASN1_TYPE_6)((LPBYTE)lpASN1_6 +sizeof(ASN1_TYPE_6));

        lpASN1_6 = (LPASN1_TYPE_6)lpASN1_6->Next;

        lpNdsTempASN1_6 = lpNdsTempASN1_6->Next;


        lpASN1_6->String =
                    (LPWSTR)AllocADsStr(
                            lpNdsTempASN1_6->String
                            );
        if (!lpASN1_6->String)
            return NULL;

    }
    lpASN1_6->Next = NULL;

    lpByte = (LPBYTE ) lpASN1_6 + sizeof(ASN1_TYPE_6);

    return(lpByte);
}


LPBYTE
CopyNDSSynId7ToNDS7(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;


    lpASN1_8->Integer = lpNdsObject->NdsValue.value_8.Integer;

    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
CopyNDSSynId8ToNDS8(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;


    lpASN1_8->Integer = lpNdsObject->NdsValue.value_8.Integer;

    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
CopyNDSSynId9ToNDS9(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;
    LPBYTE pBuffer = NULL;


    lpASN1_9->Length = lpNdsObject->NdsValue.value_9.Length;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_9->Length);
    if (!pBuffer)
        return NULL;

    memcpy(
        pBuffer,
        lpNdsObject->NdsValue.value_9.OctetString,
        lpASN1_9->Length
        );

    lpASN1_9->OctetString = pBuffer;

    lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);

    return(lpByte);
}

LPBYTE
CopyNDSSynId10ToNDS10(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_10 lpASN1_10 = (LPASN1_TYPE_10) lpByte;

    lpASN1_10->TelephoneNumber =
                        AllocADsStr(
                            lpNdsObject->NdsValue.value_10.TelephoneNumber
                            );

    lpByte = (LPBYTE ) lpASN1_10 + sizeof(ASN1_TYPE_10);

    return(lpByte);
}

LPBYTE
CopyNDSSynId11ToNDS11(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;

    lpASN1_11->NumberOfBits = lpNdsObject->NdsValue.value_11.NumberOfBits;

    lpASN1_11->TelephoneNumber =
                    (LPWSTR)AllocADsStr(
                                lpNdsObject->NdsValue.value_11.TelephoneNumber
                                );
    if (!lpASN1_11->TelephoneNumber)
        return NULL;

    lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);

    return(lpByte);
}

LPBYTE
CopyNDSSynId12ToNDS12(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;
    LPBYTE pBuffer = NULL;

    lpASN1_12->AddressType = lpNdsObject->NdsValue.value_12.AddressType;

    lpASN1_12->AddressLength = lpNdsObject->NdsValue.value_12.AddressLength;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_12->AddressLength);
    if (!pBuffer)
        return NULL;

    memcpy(
        pBuffer,
        lpNdsObject->NdsValue.value_12.Address,
        lpASN1_12->AddressLength
        );

    lpASN1_12->Address = pBuffer;

    lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);

    return(lpByte);
}

LPBYTE
CopyNDSSynId13ToNDS13(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{

    //
    // BugBug: KrishnaG not supported!
    //
    return(lpByte);
}


LPBYTE
CopyNDSSynId14ToNDS14(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;

    lpASN1_14->Type = lpNdsObject->NdsValue.value_14.Type;

    lpASN1_14->Address  =
            (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_14.Address
                        );

    lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);

    return(lpByte);
}


LPBYTE
CopyNDSSynId15ToNDS15(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;

    lpASN1_15->Type = lpNdsObject->NdsValue.value_15.Type;

    lpASN1_15->VolumeName  =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_15.VolumeName
                            );

    lpASN1_15->Path  =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_15.Path
                            );

    lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);

    return(lpByte);
}

LPBYTE
CopyNDSSynId16ToNDS16(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{

    //
    // BugBug: KrishnaG not supported!
    //

    return(lpByte);
}


LPBYTE
CopyNDSSynId17ToNDS17(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;


    lpASN1_17->ProtectedAttrName =
                    (LPWSTR)AllocADsStr(
                               lpNdsObject->NdsValue.value_17.ProtectedAttrName
                                );

    lpASN1_17->SubjectName =
                    (LPWSTR)AllocADsStr(
                                lpNdsObject->NdsValue.value_17.SubjectName
                                );

    lpASN1_17->Privileges = lpNdsObject->NdsValue.value_17.Privileges;

    lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);

    return(lpByte);
}


LPBYTE
CopyNDSSynId18ToNDS18(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;


    lpASN1_18->PostalAddress[0] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[0]
                            );
    lpASN1_18->PostalAddress[1] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[1]
                            );

    lpASN1_18->PostalAddress[2] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[2]
                            );

    lpASN1_18->PostalAddress[3] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[3]
                            );

    lpASN1_18->PostalAddress[4] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[4]
                            );

    lpASN1_18->PostalAddress[5] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[5]
                            );

    lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);


    return(lpByte);
}

LPBYTE
CopyNDSSynId19ToNDS19(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{

    //
    // BugBug: KrishnaG not supported!
    //
    return(lpByte);

    LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_19;

    lpASN1_19->WholeSeconds
            = lpNdsObject->NdsValue.value_19.WholeSeconds;


    lpASN1_19->EventID
                = lpNdsObject->NdsValue.value_19.EventID;

    lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);

    return(lpByte);
}

LPBYTE
CopyNDSSynId20ToNDS20(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_20 lpASN1_20 = (LPASN1_TYPE_20) lpByte;

    lpASN1_20->ClassName =
            (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_20.ClassName
                        );

    lpByte = (LPBYTE ) lpASN1_20 + sizeof(ASN1_TYPE_20);

    return(lpByte);
}


LPBYTE
CopyNDSSynId21ToNDS21(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;

    //
    // The Length value is supposedly always zero!!
    //

    lpASN1_21->Length = lpNdsObject->NdsValue.value_21.Length;
    lpASN1_21->Data = NULL;

    lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);

    return(lpByte);

}



LPBYTE
CopyNDSSynId22ToNDS22(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_22 lpASN1_22 = (LPASN1_TYPE_22) lpByte;

    lpASN1_22->Counter = lpNdsObject->NdsValue.value_22.Counter;

    lpByte = (LPBYTE ) lpASN1_22 + sizeof(ASN1_TYPE_22);

    return(lpByte);
}

LPBYTE
CopyNDSSynId23ToNDS23(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;

    lpASN1_23->RemoteID = lpNdsObject->NdsValue.value_23.RemoteID;

    lpASN1_23->ObjectName =
            (LPWSTR)AllocADsStr(
                    lpNdsObject->NdsValue.value_23.ObjectName
                    );

    lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);

    return(lpByte);
}

LPBYTE
CopyNDSSynId24ToNDS24(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject

    )
{
    LPASN1_TYPE_24 lpASN1_24 = (LPASN1_TYPE_24) lpByte;

    lpASN1_24->Time = lpNdsObject->NdsValue.value_24.Time;

    lpByte = (LPBYTE ) lpASN1_24 + sizeof(ASN1_TYPE_24);

    return(lpByte);
}



LPBYTE
CopyNDSSynId25ToNDS25(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;

    lpASN1_25->ObjectName =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_25.ObjectName
                            );

    lpASN1_25->Level = lpNdsObject->NdsValue.value_25.Level;

    lpASN1_25->Interval = lpNdsObject->NdsValue.value_25.Interval;

    lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);

    return(lpByte);
}


LPBYTE
CopyNDSSynId26ToNDS26(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;


    lpASN1_26->ObjectName =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_26.ObjectName
                        );

    lpASN1_26->Amount = lpNdsObject->NdsValue.value_26.Amount;

    lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);

    return(lpByte);
}


LPBYTE
CopyNDSSynId27ToNDS27(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_27 lpASN1_27 = (LPASN1_TYPE_27) lpByte;

    lpASN1_27->Interval = lpNdsObject->NdsValue.value_27.Interval;

    lpByte = (LPBYTE ) lpASN1_27 + sizeof(ASN1_TYPE_27);

    return(lpByte);
}


LPBYTE
CopyNDSSynIdToNDS(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    switch (dwSyntaxId) {
    case 1:
        lpByte = CopyNDSSynId1ToNDS1(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 2:
        lpByte = CopyNDSSynId2ToNDS2(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 3:
        lpByte = CopyNDSSynId3ToNDS3(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 4:
        lpByte = CopyNDSSynId4ToNDS4(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 5:
        lpByte = CopyNDSSynId5ToNDS5(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 6:
        lpByte = CopyNDSSynId6ToNDS6(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 7:
        lpByte = CopyNDSSynId7ToNDS7(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 8:
        lpByte = CopyNDSSynId8ToNDS8(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 9:
        lpByte = CopyNDSSynId9ToNDS9(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 10:
        lpByte = CopyNDSSynId10ToNDS10(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 11:
        lpByte = CopyNDSSynId11ToNDS11(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 12:
        lpByte = CopyNDSSynId12ToNDS12(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 13:
        lpByte = CopyNDSSynId13ToNDS13(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 14:
        lpByte = CopyNDSSynId14ToNDS14(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 15:
        lpByte = CopyNDSSynId15ToNDS15(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 16:
        lpByte = CopyNDSSynId16ToNDS16(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 17:
        lpByte = CopyNDSSynId17ToNDS17(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 18:
        lpByte = CopyNDSSynId18ToNDS18(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 19:
        lpByte = CopyNDSSynId19ToNDS19(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 20:
        lpByte = CopyNDSSynId20ToNDS20(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 21:
        lpByte = CopyNDSSynId21ToNDS21(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 22:
        lpByte = CopyNDSSynId22ToNDS22(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 23:
        lpByte = CopyNDSSynId23ToNDS23(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 24:
        lpByte = CopyNDSSynId24ToNDS24(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 25:
        lpByte = CopyNDSSynId25ToNDS25(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 26:
        lpByte = CopyNDSSynId26ToNDS26(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 27:
        lpByte = CopyNDSSynId27ToNDS27(
                         lpByte,
                         lpNdsObject
                         );
        break;


    default:
        break;

    }

    return(lpByte);
}


HRESULT
MarshallNDSSynIdToNDS(
    DWORD dwSyntaxId,
    PNDSOBJECT pNdsObject,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    DWORD  i = 0;
    HRESULT hr = S_OK;


    for (i = 0; i < dwNumValues; i++) {

        lpValue = CopyNDSSynIdToNDS(
                         dwSyntaxId,
                         lpValue,
                         (pNdsObject + i)
                         );

        if (!lpValue) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\nwnds2.h ===
#define NDS_CLSID_NDSNamespace             51d11c90-7b9d-11cf-b03d-00aa006e0975
#define NDS_LIBIID_NDSOle                  53e7f030-7b9d-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSGenObject             8b645280-7ba4-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSProvider              323991f0-7bad-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSTree                  47e94340-994f-11cf-a5f2-00aa006e05d3
#define NDS_CLSID_NDSSchema                65e252b0-b4c8-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSClass                 946260e0-b505-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSProperty              93f8fbf0-b67b-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSSyntax                953dbc50-ebdb-11cf-8abc-00c04fd8d503
#define NDS_CLSID_NDSAcl    7af1efb6-0869-11d1-a377-00c04fb950dc
#define NDS_CLSID_INDSAcl   8452d3ab-0869-11d1-a377-00c04fb950dc

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\property.cxx ===
#include "nds.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ndsutil.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  ndsutil.cxx
//
//  Contents:  Functions that encapsulate NDS API functions for ADSI
//
//
//  History:
//              Shanksh     Created     10/27/97
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop


HRESULT
ADsNdsOpenContext(
    LPWSTR pszNDSTreeName,
    CCredentials& Credentials,
    PNDS_CONTEXT_HANDLE phADsContext
    )
{

    NWDSCCODE           ccode;
    NWDSContextHandle   context = 0;
    BOOL                fLoggedIn = FALSE;
    HRESULT             hr = S_OK;
    PNDS_CONTEXT        pADsContext = NULL;
    PNDS_CONTEXT        *ppADsContext = (PNDS_CONTEXT *) phADsContext;
    nuint32             flags;
    LPWSTR              pszUserName = NULL, pszPassword = NULL;
    pnstr8              aPassword = NULL;
    nstr8               treeName[MAX_DN_CHARS+1];

    DWORD               dwLenUserName;
    LPWSTR              pszCanonicalUserName = NULL;
    LPWSTR              pbCanonicalUserName = NULL;
    LPWSTR              pszCanonicalPrefix = L".";

    WCHAR               szCurrentUserName[MAX_DN_CHARS+1];

    if (!ppADsContext) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *ppADsContext = NULL;

    //
    // Try the cache for the passed in credentials.
    //

    ENTER_BIND_CRITSECT() ;
    if (pADsContext = BindCacheLookup(pszNDSTreeName, Credentials)) {

         *ppADsContext = pADsContext ;
         LEAVE_BIND_CRITSECT() ;
         return S_OK;
    }

    //
    // Entry not found in the cache, need to allocate a new one.
    //

    hr = BindCacheAllocEntry(&pADsContext) ;
    if (FAILED(hr)) {
        LEAVE_BIND_CRITSECT() ;
        RRETURN(hr);
    }

    ccode = NWDSCreateContextHandle(&context);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    ccode = NWDSGetContext(context, DCK_FLAGS, &flags);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    flags &= ~DCV_CANONICALIZE_NAMES;
    flags &= ~DCV_XLATE_STRINGS;
    flags |= DCV_TYPELESS_NAMES;  // for NWDSWhoAmI below

    ccode = NWDSSetContext(context, DCK_FLAGS, &flags);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    if (pszNDSTreeName) {

        ccode = NWDSSetContext(
                   context,
                   DCK_TREE_NAME,
                   pszNDSTreeName
                   );

        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    }

    ccode = NWDSGetContext(context, DCK_TREE_NAME, &treeName);
    ccode = NWDSGetContext(context, DCK_FLAGS, &flags);

    // Find out who the currently logged-in user (if any) is,
    // then reset the DCV_TYPELESS_NAMES flag.
    ccode = NWDSWhoAmI(context, (pnstr8)szCurrentUserName);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    flags &= ~DCV_TYPELESS_NAMES;

    ccode = NWDSSetContext(context, DCK_FLAGS, &flags);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    hr = Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);


    // We want to do the login code if (1) we're not authenticated, or
    // (2) we are authenticated, but as a different user.  If we're
    // doing an ADsGetObject, pszUserName is NULL and case 2 doesn't
    // apply.
    if ( (!NWDSCanDSAuthenticate(context)) ||
         (pszUserName && (_wcsicmp(pszUserName, szCurrentUserName) != 0)) )
    {
        hr = Credentials.GetPassword(&pszPassword);
        BAIL_ON_FAILURE(hr);

        if (pszUserName != NULL)
        {
            //
            // If password is NULL, pass a Null string, otherwise Client32 will AV
            //
            aPassword = AllocateAnsiString(pszPassword);


#if 0
            //
            // Some builds of the Client32 NDS libraries seem to have a bug in their
            // usage of the DCV_CANONICALIZE_NAMES flag, in that they do not behave
            // properly when the flag is cleared.  The following is a work-around. To
            // use it, delete the line above which clears the flag.  This code will
            // prepend the name with a period (unless it already begins with one),
            // achieving the same result.
            //

            if (*pszUserName == L'.')
            {
                if (!(pszCanonicalUserName = AllocADsStr(pszUserName)))
                    BAIL_ON_FAILURE(E_OUTOFMEMORY);
            }
            else
            {
                dwLenUserName = wcslen(pszUserName) + 4;

                if (!(pbCanonicalUserName = (LPWSTR) AllocADsMem(dwLenUserName * sizeof(WCHAR))))
                    BAIL_ON_FAILURE(E_OUTOFMEMORY);

                wcscpy(pbCanonicalUserName, pszCanonicalPrefix);
                wcscat(pbCanonicalUserName, pszUserName);

                if (!(pszCanonicalUserName = AllocADsStr(pbCanonicalUserName)))
                {
                    FreeADsMem(pbCanonicalUserName);
                    BAIL_ON_FAILURE(E_OUTOFMEMORY);
                }

                FreeADsMem(pbCanonicalUserName);
            }
#endif

            ccode = NWDSLogin(
                        context,
                        0,
                        pszUserName ? (pnstr8) pszUserName : (pnstr8) L"",
                        aPassword ? aPassword : "",
                        0
                        );


            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
            fLoggedIn = TRUE;
        }
    }

    pADsContext->hContext = context;
    pADsContext->fLoggedIn = fLoggedIn;

    hr = BindCacheAdd(pszNDSTreeName, Credentials, fLoggedIn, pADsContext) ;
    BAIL_ON_FAILURE(hr);

    *ppADsContext = pADsContext;

    if (pszCanonicalUserName)
        FreeADsStr(pszCanonicalUserName);

    if (pszUserName)
        FreeADsStr(pszUserName);

    if (pszPassword)
        FreeADsStr(pszPassword);

    FreeADsMem(aPassword);

    LEAVE_BIND_CRITSECT() ;

    RRETURN (hr);

error:

    if (pszCanonicalUserName)
        FreeADsStr(pszCanonicalUserName);

    if ( fLoggedIn ) {
        NWDSLogout(context);
    }
    NWDSFreeContext(context);

    if (pADsContext) {
        FreeADsMem(pADsContext);
    }

    if (pszUserName)
        FreeADsStr(pszUserName);

    if (pszPassword)
        FreeADsStr(pszPassword);

    FreeADsMem(aPassword);

    LEAVE_BIND_CRITSECT() ;
    RRETURN (hr);
}


HRESULT
ADsNdsCloseContext(
    NDS_CONTEXT_HANDLE hADsContext
    )
{
    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    if (!pADsContext) {

        RRETURN(E_FAIL);
    }

    if (BindCacheDeref(pADsContext) == 0) {

        //
        // ref count has dropped to zero and its gone from cache.
        //
        if (pADsContext->fLoggedIn) {

            NWDSLogout(pADsContext->hContext);
        }
        NWDSFreeContext(pADsContext->hContext);

        FreeADsMem(pADsContext);
    }

    RRETURN(S_OK);
}

HRESULT
ADsNdsReadObject(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR pszDn,
    DWORD  dwInfoType,
    LPWSTR *ppszAttrs,
    DWORD nAttrs,
    pTimeStamp_T pTimeStamp,
    PNDS_ATTR_INFO *ppAttrEntries,
    DWORD *pAttrsReturned
    )
{
    NWDSCCODE           ccode;
    HRESULT             hr = S_OK;
    nint32              lIterationHandle = NO_MORE_ITERATIONS;
    NWDSContextHandle   context;
    DWORD               i, j;
    pnstr8              *ppAttrs = NULL, aDn = NULL;
    nstr                treeName[MAX_DN_CHARS+1];
    nuint32             flags;
    pBuf_T              pInBuf = NULL;
    pBuf_T              pOutBuf = NULL;
    BOOL                fAllAttrs = FALSE;
    DWORD               dwAttrsReturned = 0;
    DWORD               dwAttrsReturnedCurrIter = 0;

    PNDS_ATTR_INFO      pAttrEntries = NULL;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    if (!pADsContext || !pAttrsReturned || !ppAttrEntries) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;
    *ppAttrEntries = NULL;

    //
    //Allocate the output buffer to hold returned values
    //
    ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pOutBuf);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    ccode = NWDSGetContext(context, DCK_TREE_NAME, &treeName);
    ccode = NWDSGetContext(context, DCK_FLAGS, &flags);

    if (nAttrs == (DWORD) -1) {
        fAllAttrs = TRUE;
        pInBuf = NULL;
    }
    else {

        // Allocate and initialize input buffer a directory services
        // read operation.
        //
        ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pInBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        ccode = NWDSInitBuf(context, DSV_READ, pInBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        // To prepare for the read, place the names of the attributes
        // into the input buffer
        //
        for(i = 0; i < nAttrs; i++)
        {
           ccode = NWDSPutAttrName(context, pInBuf, (pnstr8) ppszAttrs[i]);
           CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
        }


    }

    do {

        // Perform the read.  The second arg to NWDSRead specifies that
        // attribute values are to be returned. The third attribute, FALSE,
        // indicates that only attribute information is desired.
        //

        //
        // To ensure that read/search doesn't collide with GenObjectKeyPair().
        // GenObjectKeyPair() changes the context state which will cause read/search
        // to return type-less DNs
        //
        EnterCriticalSection(&g_ContextCritSect);

        ccode = NWDSRead(
                    context,
                    (pnstr8) (!pszDn || (*pszDn == L'\0') ? L"[Root]" : pszDn),
                    dwInfoType,
                    fAllAttrs,
                    pInBuf,
                    &lIterationHandle,
                    pOutBuf
                    );

        LeaveCriticalSection(&g_ContextCritSect);

        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);


        // If pAttrEntries == NULL, this is the first iteration and there's
        // no previous attr list to append to.
        if (!pAttrEntries) {
            hr = ADsNdsGetAttrListFromBuffer(
                     hADsContext,
                     pOutBuf,
                     FALSE,
                     (void **) &pAttrEntries,
                     &dwAttrsReturnedCurrIter
                     );
        } else {
            hr = ADsNdsAppendAttrListFromBuffer(
                     hADsContext,
                     pOutBuf,
                     FALSE,
                     (void **) &pAttrEntries,
                     &dwAttrsReturnedCurrIter,
                     dwAttrsReturned
                     );
        }
        BAIL_ON_FAILURE(hr);

        dwAttrsReturned += dwAttrsReturnedCurrIter;

    } while (lIterationHandle != NO_MORE_ITERATIONS);

    *pAttrsReturned = dwAttrsReturned;
    *ppAttrEntries = pAttrEntries;

error:

    NWDSFreeBuf(pInBuf);
    NWDSFreeBuf(pOutBuf);

    RRETURN(hr);
}


HRESULT
ADsNdsGetAttrListFromBuffer(
    NDS_CONTEXT_HANDLE hADsContext,
    pBuf_T              pBuf,
    BOOL                fAttrsOnly,
    PVOID               *ppAttrEntries,
    PDWORD              pAttrsReturned
    )
{
    NWCCODE      ccode;
    HRESULT      hr = S_OK;
    NWDSContextHandle   context;
    nuint32      luAttrCount = 0;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    if (!hADsContext || !ppAttrEntries || !pAttrsReturned) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *pAttrsReturned = 0;

    context = pADsContext->hContext;

    ccode = NWDSGetAttrCount(context, pBuf, &luAttrCount);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    hr = ADsNdsGetAttrsFromBuffer(
             hADsContext,
             pBuf,
             luAttrCount,
             fAttrsOnly,
             ppAttrEntries
             );
    BAIL_ON_FAILURE(hr);

    *pAttrsReturned = luAttrCount;
error:

    RRETURN (hr);
}


HRESULT
ADsNdsAppendAttrListFromBuffer(
    NDS_CONTEXT_HANDLE hADsContext,
    pBuf_T              pBuf,
    BOOL                fAttrsOnly,
    PVOID               *ppAttrEntries,      // ptr to list to be appended to
    PDWORD              pdwNewAttrsReturned, // # of new attribs appended
    DWORD               dwCurrentAttrs       // # of attributes currently in list
    )
{
    NWCCODE      ccode;
    HRESULT      hr = S_OK;
    NWDSContextHandle   context;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    DWORD cbOld = 0;
    DWORD cbNew = 0;

    PNDS_ATTR_INFO pCombinedAttrEntries = NULL;
    DWORD dwCombinedCurrentIndex = 0;   // index of next unused entry

    PVOID    pNewAttrEntries = NULL;
    nuint32  luAttrCount = 0; //count of new attribs (those in pNewAttrEntries)

    DWORD i, j;


    if (!hADsContext || !ppAttrEntries || !pdwNewAttrsReturned) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    // BUGBUG: Ideally, we should be able to handle both NDS_ATTR_INFO and
    // NDS_NAME_ONLY entries.
    // However, currently we are always called with fAttrsOnly == FALSE,
    // and that is all we support.
    if (fAttrsOnly)
        RRETURN(E_ADS_BAD_PARAMETER);

    *pdwNewAttrsReturned = 0;

    context = pADsContext->hContext;

    // Build the list of the new attributes in this block

    ccode = NWDSGetAttrCount(context, pBuf, &luAttrCount);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    hr = ADsNdsGetAttrsFromBuffer(
             hADsContext,
             pBuf,
             luAttrCount,
             fAttrsOnly,
             &pNewAttrEntries
             );
    BAIL_ON_FAILURE(hr);

    // Append the list of new attributes (luAttrCount entries pointed to by
    // pNewAttrEntries) to the list of old attributes (dwCurrentAttrs entries
    // pointed to by *ppAttrEntries)

    // Allocate a new list big enough to hold old and new attributes.
    // We make the list the maximum possible size, assuming no dupes.
    // We may shrink it later if there are dupes.
    cbOld = dwCurrentAttrs * sizeof(NDS_ATTR_INFO);
    cbNew = cbOld + (luAttrCount * sizeof(NDS_ATTR_INFO));
    dwCombinedCurrentIndex = dwCurrentAttrs;

    pCombinedAttrEntries = (PNDS_ATTR_INFO) ReallocADsMem(
                                                *ppAttrEntries,
                                                cbOld,
                                                cbNew
                                                );
    if (!pCombinedAttrEntries)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    *ppAttrEntries = NULL;

    // For each new attrib entry, copy it into the combined list (if not
    // a dupe) or merge it into the corresponding old entry (if a dupe)
    for (j = 0; j < luAttrCount; j++) {

        PNDS_ATTR_INFO pNewEntry = ((PNDS_ATTR_INFO)pNewAttrEntries) + j;
        DWORD dwDupeIndex = -1;

        // Determine if the new entry is a duplicate of an old entry.
        // Note the implicit assumption that there is at most one of any
        // given attribute entry in the list of old entries (i.e., there
        // are no dupes within the list).  This should always hold, since
        // a NWDSRead should not yield any dupes in its results, and we take
        // care of merging dupes between multiple NWDSRead results.
        for (i = 0; i < dwCurrentAttrs; i++) {
            
            PNDS_ATTR_INFO pOldEntry = (pCombinedAttrEntries) + i;
            if (!_wcsicmp(pOldEntry->szAttributeName, pNewEntry->szAttributeName)) {
                // found a dupe
                dwDupeIndex = i;
                break;
            }
        }


        if (dwDupeIndex == -1) {
            // not a duplicate attribute, so just copy it from the new entries list
            // to the next available position in the combined entries list
            memcpy(
                (BYTE*)(pCombinedAttrEntries + dwCombinedCurrentIndex),
                (BYTE*)pNewEntry,
                sizeof(NDS_ATTR_INFO)
                );

            dwCombinedCurrentIndex++;
        }
        else {
            // duplicate, merge attribute values
            PNDS_ATTR_INFO pOldEntry = (pCombinedAttrEntries) + dwDupeIndex;

            cbOld = pOldEntry->dwNumberOfValues * sizeof(NDSOBJECT);
            cbNew = cbOld + pNewEntry->dwNumberOfValues * sizeof(NDSOBJECT);

            PNDSOBJECT lpValue = (PNDSOBJECT)ReallocADsMem(
                                                 pOldEntry->lpValue,
                                                 cbOld,
                                                 cbNew
                                                 );
            if (!lpValue)
                BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

            pOldEntry->lpValue = lpValue;

            // the new NDSOBJECTs will come after the preexisting ones
            memcpy(
                ((BYTE*) pOldEntry->lpValue) + cbOld,
                (BYTE*)pNewEntry->lpValue,
                cbNew-cbOld
                );

            pOldEntry->dwNumberOfValues += pNewEntry->dwNumberOfValues;
            FreeADsMem(pNewEntry->lpValue);
            pNewEntry->lpValue = NULL;
            FreeADsMem(pNewEntry->szAttributeName);
            pNewEntry->szAttributeName = NULL;

        }
    }

    // We allocated memory for the combined list assuming there were no duplicates.  If
    // there were duplicates, the combined list is shorter than what we allocated for,
    // and we shrink the allocated list down to size.
    if (dwCombinedCurrentIndex < luAttrCount + dwCurrentAttrs) {
        PNDS_ATTR_INFO pCombinedAttrEntriesResized;
        pCombinedAttrEntriesResized = (PNDS_ATTR_INFO)ReallocADsMem(
                                                          pCombinedAttrEntries,
                                                          (luAttrCount + dwCurrentAttrs) * sizeof(NDS_ATTR_INFO),
                                                          dwCombinedCurrentIndex * sizeof(NDS_ATTR_INFO)
                                                          );
        if (!pCombinedAttrEntriesResized)
            BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

        pCombinedAttrEntries = pCombinedAttrEntriesResized;
    }

    *ppAttrEntries = pCombinedAttrEntries;
    *pdwNewAttrsReturned = dwCombinedCurrentIndex - dwCurrentAttrs;

    FreeADsMem(pNewAttrEntries);

    RRETURN (hr);

error:
    if (pNewAttrEntries)
        FreeNdsAttrInfo((PNDS_ATTR_INFO)pNewAttrEntries, luAttrCount);

    if (pCombinedAttrEntries)
        FreeNdsAttrInfo((PNDS_ATTR_INFO)pCombinedAttrEntries, dwCombinedCurrentIndex);
    
    if (*ppAttrEntries)
        FreeNdsAttrInfo((PNDS_ATTR_INFO)*ppAttrEntries, dwCurrentAttrs);

    RRETURN (hr);    
}


HRESULT
FreeNdsAttrInfo(
    PNDS_ATTR_INFO pAttrEntries,
    DWORD  dwNumEntries
    )
{
    DWORD i;

    PNDS_ATTR_INFO pThisEntry = NULL;

    if (!pAttrEntries) {
        RRETURN(S_OK);
    }

    for (i=0; i < dwNumEntries; i++) {

        pThisEntry = pAttrEntries+i;

        if (pThisEntry->szAttributeName)
            FreeADsMem(pThisEntry->szAttributeName);

        if (pThisEntry->lpValue)
            NdsTypeFreeNdsObjects( pThisEntry->lpValue,
                                   pThisEntry->dwNumberOfValues );
    }

    FreeADsMem(pAttrEntries);

    RRETURN(S_OK);

}


HRESULT
FreeNdsAttrNames(
    PNDS_NAME_ONLY pAttrNames,
    DWORD  dwNumEntries
    )
{
    DWORD i;

    if (!pAttrNames) {
        RRETURN(S_OK);
    }

    for (i=0; i < dwNumEntries; i++) {

        if (pAttrNames[i].szName)
            FreeADsMem(pAttrNames[i].szName);
    }

    FreeADsMem(pAttrNames);

    RRETURN(S_OK);

}

HRESULT
ADsNdsListObjects(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR pszDn,
    LPWSTR classFilter,
    LPWSTR objectFilter,
    pTimeStamp_T pTimeStamp,
    BOOL fOnlyContainers,
    NDS_BUFFER_HANDLE *phBuf
    )
{
    NWDSCCODE     ccode;
    HRESULT       hr = S_OK;
    BOOL          fBufAllocated = FALSE;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = phBuf ? (PNDS_BUFFER_DATA) *phBuf : NULL;

    if ( !pADsContext  || !phBuf) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    if( pBufData == NULL) {
        pBufData = (PNDS_BUFFER_DATA) AllocADsMem( sizeof(NDS_BUFFER_DATA) );
        if (!pBufData) {
            RRETURN(E_OUTOFMEMORY);
        }
        fBufAllocated = TRUE;
        pBufData->lIterationHandle = NO_MORE_ITERATIONS;
        pBufData->pOutBuf = NULL;
        pBufData->pInBuf = NULL;

        ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pBufData->pOutBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    }
    else {
        if ( pBufData->lIterationHandle == NO_MORE_ITERATIONS) {
            RRETURN (S_ADS_NOMORE_ROWS);
        }
    }

    ccode = NWDSExtSyncList(
                pADsContext->hContext,
                (pnstr8) (!pszDn || (*pszDn == L'\0') ? L"[Root]" : pszDn),
                (pnstr8) classFilter,
                (pnstr8) objectFilter,
                &pBufData->lIterationHandle,
                NULL,
                FALSE,
                pBufData->pOutBuf
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    if (pBufData->lIterationHandle == NO_MORE_ITERATIONS) {
        hr = S_ADS_NOMORE_ROWS;
    }
    else {
        hr = S_OK;
    }

    *phBuf = pBufData;

    RRETURN(hr);

error:

    if (fBufAllocated) {

        if (pBufData->pOutBuf) {
            NWDSFreeBuf(pBufData->pOutBuf);
        }

        FreeADsMem(pBufData);
    }
    RRETURN(hr);

}

HRESULT
ADsNdsGetObjectListFromBuffer(
   NDS_CONTEXT_HANDLE hADsContext,
   NDS_BUFFER_HANDLE hBufData,
   PDWORD pdwObjectsReturned,
   PADSNDS_OBJECT_INFO *ppObjects
   )
{

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) hBufData;

    nuint32 luObjectCount = 0, luAttrCount = 0;
    WCHAR pszTemp[MAX_DN_CHARS+1] = L"";
    Object_Info_T  objectInfo;
    DWORD j, i;
    PADSNDS_OBJECT_INFO pThisObject = NULL, pObjectInfo = NULL;
    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    PNDS_ATTR_INFO     pAttrEntries = NULL, pThisEntry = NULL;
    PNDS_NAME_ONLY     pAttrNames = NULL, pThisName = NULL;

    if (!pADsContext || !pBufData || !pdwObjectsReturned || !ppObjects ||
        !pBufData->pOutBuf ) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *ppObjects = NULL;
    *pdwObjectsReturned = 0;

    ccode = NWDSGetObjectCount(pADsContext->hContext, pBufData->pOutBuf, &luObjectCount);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    if (luObjectCount) {

        pObjectInfo = (PADSNDS_OBJECT_INFO) AllocADsMem(
                                                sizeof(ADSNDS_OBJECT_INFO) *
                                                luObjectCount );

        if (!pObjectInfo) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memset (pObjectInfo, 0x0,  sizeof(ADSNDS_OBJECT_INFO) * luObjectCount);
    }
    for (j = 0; j < luObjectCount; j++) {

        pThisObject = pObjectInfo + j;

        ccode = NWDSGetObjectName(
                    pADsContext->hContext,
                    pBufData->pOutBuf,
                    (pnstr8) pszTemp,
                    &luAttrCount,
                    &objectInfo
                    );
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        pThisObject->szObjectName = AllocADsStr(pszTemp);
        pThisObject->szObjectClass = AllocADsStr( (LPWSTR) objectInfo.baseClass);
        pThisObject->dwModificationTime = objectInfo.modificationTime;
        pThisObject->dwSubordinateCount = objectInfo.subordinateCount;
        pThisObject->dwNumAttributes = luAttrCount;
        pThisObject->dwObjectFlags = objectInfo.objectFlags;

        //
        // Get the attributes if we are doing search
        //
        if (pBufData->dwOperation == DSV_SEARCH ) {

            hr = ADsNdsGetAttrsFromBuffer(
                     hADsContext,
                     pBufData->pOutBuf,
                     luAttrCount,
                     !pBufData->dwInfoType,
                     &pThisObject->lpAttribute
                     );
            BAIL_ON_FAILURE(hr);

            if (!pBufData->dwInfoType)
                pThisObject->fNameOnly = TRUE;
            else
                pThisObject->fNameOnly = FALSE;
        }

    }

    *pdwObjectsReturned = luObjectCount;
    *ppObjects = pObjectInfo;

    RRETURN(hr);

error:

    ADsNdsFreeNdsObjInfoList(pObjectInfo, luObjectCount);

    RRETURN(hr);

}


HRESULT
ADsNdsFreeNdsObjInfoList(
    PADSNDS_OBJECT_INFO pObjInfo,
    DWORD dwNumEntries
    )
{
    PADSNDS_OBJECT_INFO pThisObjInfo;

    if (!pObjInfo)
        RRETURN(S_OK);

    for (DWORD i = 0; i < dwNumEntries; i++)
    {
        pThisObjInfo = pObjInfo + i;

        FreeADsStr(pThisObjInfo->szObjectName);
        FreeADsStr(pThisObjInfo->szObjectClass);

        if (pThisObjInfo->fNameOnly)
            FreeNdsAttrNames((PNDS_NAME_ONLY)pThisObjInfo->lpAttribute, pThisObjInfo->dwNumAttributes);
        else
            FreeNdsAttrInfo((PNDS_ATTR_INFO)pThisObjInfo->lpAttribute, pThisObjInfo->dwNumAttributes);

    }

    FreeADsMem(pObjInfo);

    RRETURN(S_OK);
}


HRESULT
ADsNdsGetAttrsFromBuffer(
    NDS_CONTEXT_HANDLE hADsContext,
    pBuf_T              pBuf,
    DWORD               luAttrCount,
    BOOL                fAttrsOnly,
    PVOID               *ppAttrEntries
    )
{

    NWCCODE      ccode;
    HRESULT      hr = S_OK;
    NWDSContextHandle   context;
    nuint32      luAttrValCount = 0;
    nuint32      luAttrValSize = 0;
    nuint32      luSyntax;
    nptr         attrVal = NULL;
    PNDS_ATTR_INFO     pAttrEntries = NULL, pThisEntry = NULL;
    PNDS_NAME_ONLY     pAttrNames = NULL, pThisName = NULL;
    nstr         pszAttrName[MAX_DN_CHARS+1];
    DWORD        i, j;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    ADsAssert(pADsContext);
    ADsAssert(ppAttrEntries);

    context = pADsContext->hContext;

    if (fAttrsOnly) {

        if (luAttrCount) {

            pAttrNames = (PNDS_NAME_ONLY) AllocADsMem(
                                                sizeof(NDS_NAME_ONLY) * luAttrCount );

            if (!pAttrNames) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        for(i = 0; i < luAttrCount; i++) {

            // Initialize this entry so that we can free them if an error
            // occurs in building this entry
            //

            ccode = NWDSGetAttrName(context, pBuf, (pnstr8) pszAttrName,
                                     &luAttrValCount, &luSyntax);
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            pThisName->szName = AllocADsStr(pszAttrName);
            if (!pThisName->szName) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        *ppAttrEntries = pAttrNames;

    }
    else {

        if (luAttrCount) {

            pAttrEntries = (PNDS_ATTR_INFO) AllocADsMem(
                                                sizeof(NDS_ATTR_INFO) * luAttrCount );

            if (!pAttrEntries) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        /* Get the name and value for each attribute */
        for(i = 0; i < luAttrCount; i++) {

            // Initialize this entry so that we can free them if an error
            // occurs in building this entry
            //
            pThisEntry = pAttrEntries+i;

            pThisEntry->szAttributeName = NULL;
            pThisEntry->dwNumberOfValues = 0;
            pThisEntry->lpValue = NULL;

            ccode = NWDSGetAttrName(context, pBuf, (pnstr8) pszAttrName,
                                     &luAttrValCount, &luSyntax);
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            pThisEntry->szAttributeName = AllocADsStr(pszAttrName);
            if (!pThisEntry->szAttributeName) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            pThisEntry->dwNumberOfValues = luAttrValCount;
            pThisEntry->dwSyntaxId = luSyntax;

            pThisEntry->lpValue = (PNDSOBJECT) AllocADsMem(
                                               luAttrValCount * sizeof(NDSOBJECT)
                                               );

            for (j = 0; j < luAttrValCount; j++) {

                ccode = NWDSComputeAttrValSize(
                            context,
                            pBuf,
                            luSyntax,
                            &luAttrValSize
                            );
                CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

                attrVal = AllocADsMem(luAttrValSize);
                if (!attrVal) {
                    FreeNdsAttrInfo(pAttrEntries, i);
                    pAttrEntries = NULL;
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }

                ccode = NWDSGetAttrVal(context, pBuf, luSyntax, attrVal);
                CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

                hr = CopyNdsValueToNdsObject(
                           (nptr) attrVal,
                           luAttrValSize,
                           luSyntax,
                           (PNDSOBJECT) pThisEntry->lpValue + j
                           );

                if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
                    hr = S_OK;
                }

                BAIL_ON_FAILURE(hr);

                FreeADsMem(attrVal);
                attrVal = NULL;

            }

            *ppAttrEntries = pAttrEntries;
        }

    }

    RRETURN(S_OK);

error:

    // This function frees all the memory related to this array of entries
    // for i entries. The ith entry may not have be fully set, but that is ok
    // because we have initialized it properly in the beginning of the for loop
    //

    if (pAttrEntries) {
        FreeNdsAttrInfo(pAttrEntries, i);
    }

    if (pAttrNames) {
        FreeNdsAttrNames(pAttrNames, i);
    }

    if (attrVal) {
        FreeADsMem(attrVal);
    }

    RRETURN (hr);
}

HRESULT
ADsNdsReadClassDef(
    NDS_CONTEXT_HANDLE hADsContext,
    DWORD  dwInfoType,
    LPWSTR *ppszClasses,
    DWORD nClasses,
    NDS_BUFFER_HANDLE *phBuf
    )
{
    NWDSCCODE           ccode;
    HRESULT             hr = S_OK;
    DWORD               i;
    pBuf_T              pInBuf = NULL;
    BOOL                fAllClasses = FALSE;
    BOOL                fBufAllocated = FALSE;
    NWDSContextHandle   context;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = phBuf ? (PNDS_BUFFER_DATA) *phBuf : NULL;

    if ( !pADsContext  || !phBuf) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    if( pBufData == NULL) {
        pBufData = (PNDS_BUFFER_DATA) AllocADsMem( sizeof(NDS_BUFFER_DATA) );
        if (!pBufData) {
            RRETURN(E_OUTOFMEMORY);
        }
        fBufAllocated = TRUE;
        pBufData->lIterationHandle = NO_MORE_ITERATIONS;
        pBufData->pOutBuf = NULL;
        pBufData->dwInfoType = dwInfoType;

        ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN*2, &pBufData->pOutBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    }
    else {
        if ( pBufData->lIterationHandle == NO_MORE_ITERATIONS) {
            RRETURN (S_ADS_NOMORE_ROWS);
        }
    }

    if (nClasses == (DWORD) -1) {
        fAllClasses = TRUE;
        pInBuf = NULL;
    }
    else {

        // Allocate and initialize input buffer a directory services
        // read operation.
        //
        ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pInBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        ccode = NWDSInitBuf(context, DSV_READ_CLASS_DEF, pInBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        // To prepare for the read, place the names of the attributes
        // into the input buffer
        //
        for(i = 0; i < nClasses; i++)
        {
           ccode = NWDSPutClassName(context, pInBuf, (pnstr8) ppszClasses[i]);
           CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
        }

    }

    ccode = NWDSReadClassDef(
                context,
                dwInfoType,
                fAllClasses,
                pInBuf,
                &pBufData->lIterationHandle,
                pBufData->pOutBuf
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);


    if (pBufData->lIterationHandle == NO_MORE_ITERATIONS) {
        hr = S_ADS_NOMORE_ROWS;
    }
    else {
        hr = S_OK;
    }

    *phBuf = pBufData;

    if (pInBuf) {
        NWDSFreeBuf(pInBuf);
    }

    RRETURN(hr);

error:

    if (pInBuf) {
        NWDSFreeBuf(pInBuf);
    }

    if (fBufAllocated) {

        if (pBufData->pOutBuf) {
            NWDSFreeBuf(pBufData->pOutBuf);
        }

        FreeADsMem(pBufData);
    }
    RRETURN(hr);

}


HRESULT
ADsNdsGetClassDefListFromBuffer(
   NDS_CONTEXT_HANDLE hADsContext,
   NDS_BUFFER_HANDLE hBufData,
   PDWORD  pdwNumEntries,
   PDWORD  pdwInfoType,
   PNDS_CLASS_DEF *ppClassDef
   )
{

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) hBufData;

    nuint32 luClassDefCount = 0, luItemCount = 0;
    WCHAR pszTemp[MAX_DN_CHARS+1] = L"";
    Class_Info_T  classInfo;
    DWORD j;
    PNDS_CLASS_DEF pThisClassDef = NULL, pClassDef = NULL;
    HRESULT hr = S_OK;
    NWDSCCODE ccode;
    NWDSContextHandle   context;


    if (!pADsContext || !pBufData || !pdwNumEntries ||
        !pdwInfoType || !ppClassDef || !pBufData->pOutBuf) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    *ppClassDef = NULL;
    *pdwNumEntries = 0;
    *pdwInfoType = pBufData->dwInfoType;

    ccode = NWDSGetClassDefCount(context, pBufData->pOutBuf, &luClassDefCount);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    if (luClassDefCount) {

        pClassDef = (PNDS_CLASS_DEF) AllocADsMem(
                                                sizeof(NDS_CLASS_DEF) *
                                                luClassDefCount );
        if (!pClassDef) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memset (pClassDef, 0x0,  sizeof(NDS_CLASS_DEF) * luClassDefCount);
    }

    for (j = 0; j < luClassDefCount; j++) {

        pThisClassDef = pClassDef + j;

        if (pBufData->dwInfoType == DS_CLASS_DEF_NAMES) {

            ccode = NWDSGetClassItem(
                        context,
                        pBufData->pOutBuf,
                        (pnstr8) pszTemp
                        );

            if (pszTemp) {
                pThisClassDef->szClassName = AllocADsStr( pszTemp );
                if (!pThisClassDef->szClassName) {
                    RRETURN (hr = E_OUTOFMEMORY);
                }
            }

            //
            // This is all that is available for this class (only name)
            // move to the next class
            //

            continue;

        }

        ccode = NWDSGetClassDef(
                    context,
                    pBufData->pOutBuf,
                    (pnstr8) pszTemp,
                    &classInfo
                    );
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        pThisClassDef->dwFlags = classInfo.classFlags;
        pThisClassDef->asn1ID = classInfo.asn1ID;

        if (pBufData->dwInfoType == DS_INFO_CLASS_DEFS) {
            //
            // Name won't be there
            //
            pThisClassDef->szClassName = NULL;

        }
        else {
            pThisClassDef->szClassName = AllocADsStr(pszTemp);

            //
            // This is for getting superior classes
            //

            ccode = NWDSGetClassItemCount(
                        context,
                        pBufData->pOutBuf,
                        &luItemCount
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            pThisClassDef->dwNumberOfSuperClasses = luItemCount;

            hr = GetItemsToList(
                     context,
                     pBufData->pOutBuf,
                     luItemCount,
                     &pThisClassDef->lpSuperClasses
                     );
            BAIL_ON_FAILURE(hr);

            //
            // This is for getting Containment classes
            //

            ccode = NWDSGetClassItemCount(
                        context,
                        pBufData->pOutBuf,
                        &luItemCount
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            pThisClassDef->dwNumberOfContainmentClasses = luItemCount;

            hr = GetItemsToList(
                     context,
                     pBufData->pOutBuf,
                     luItemCount,
                     &pThisClassDef->lpContainmentClasses
                     );
            BAIL_ON_FAILURE(hr);

            //
            // This is for getting the Naming Attribute List
            //

            ccode = NWDSGetClassItemCount(
                        context,
                        pBufData->pOutBuf,
                        &luItemCount
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            pThisClassDef->dwNumberOfNamingAttributes = luItemCount;

            hr = GetItemsToList(
                     context,
                     pBufData->pOutBuf,
                     luItemCount,
                     &pThisClassDef->lpNamingAttributes
                     );
            BAIL_ON_FAILURE(hr);
            //
            // This is for getting the Mandatory Attribute List
            //

            ccode = NWDSGetClassItemCount(
                        context,
                        pBufData->pOutBuf,
                        &luItemCount
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            pThisClassDef->dwNumberOfMandatoryAttributes = luItemCount;

            hr = GetItemsToList(
                     context,
                     pBufData->pOutBuf,
                     luItemCount,
                     &pThisClassDef->lpMandatoryAttributes
                     );
            BAIL_ON_FAILURE(hr);
            //
            // This is for getting the Optional Attribute List
            //

            ccode = NWDSGetClassItemCount(
                        context,
                        pBufData->pOutBuf,
                        &luItemCount
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            pThisClassDef->dwNumberOfOptionalAttributes = luItemCount;

            hr = GetItemsToList(
                     context,
                     pBufData->pOutBuf,
                     luItemCount,
                     &pThisClassDef->lpOptionalAttributes
                     );
            BAIL_ON_FAILURE(hr);
        }

    }

    *pdwNumEntries = luClassDefCount;
    *ppClassDef = pClassDef;

    RRETURN(hr);

error:

    if (pClassDef) {
        ADsNdsFreeClassDefList(pClassDef, luClassDefCount);
    }

    RRETURN(hr);

}

HRESULT
GetItemsToList(
    NWDSContextHandle context,
    pBuf_T pBuf,
    DWORD luItemCount,
    LPWSTR_LIST *ppList
    )
{

    WCHAR pszTemp[MAX_DN_CHARS+1] = L"";
    HRESULT hr = S_OK;
    NWDSCCODE ccode;
    LPWSTR_LIST pPrevItem = NULL, pCurrItem = NULL, pItems = NULL;
    DWORD i;

    if (!ppList) {
        RRETURN(E_FAIL);
    }

    *ppList = NULL;

    if (luItemCount > 0) {

        pItems = (LPWSTR_LIST ) AllocADsMem(sizeof(WSTR_LIST_ELEM) * luItemCount);
        if (!pItems) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memset(pItems, 0x0, sizeof(WSTR_LIST_ELEM) * luItemCount);

        for (i = 0; i < luItemCount ; i++) {

            pCurrItem = pItems + i;

            ccode = NWDSGetClassItem(
                        context,
                        pBuf,
                        (pnstr8) &pszTemp
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            pCurrItem->szString = AllocADsStr(pszTemp);

            if (pPrevItem) {
                pPrevItem->Next = pCurrItem;
            }

            pPrevItem = pCurrItem;

        }

        pCurrItem->Next = NULL;
    }

    *ppList = pItems;

    RRETURN(hr);

error:

    if (pItems) {

        FreeItemList(pItems);
    }

    RRETURN(hr);

}

HRESULT
ADsNdsFreeClassDef(
    PNDS_CLASS_DEF pClassDef
    )
{

    if (!pClassDef) {
        RRETURN(S_OK);
    }
    FreeADsStr(pClassDef->szClassName);

    FreeItemList(pClassDef->lpSuperClasses);
    FreeItemList(pClassDef->lpContainmentClasses);
    FreeItemList(pClassDef->lpNamingAttributes);
    FreeItemList(pClassDef->lpMandatoryAttributes);
    FreeItemList(pClassDef->lpOptionalAttributes);

    FreeADsMem(pClassDef);

    RRETURN(S_OK);

}

HRESULT
ADsNdsFreeClassDefList(
    PNDS_CLASS_DEF pClassDef,
    DWORD dwNumEntries
    )
{
    PNDS_CLASS_DEF pThisClassDef;

    if (!pClassDef) {
        RRETURN(S_OK);
    }

    for (DWORD i = 0; i < dwNumEntries; i++) {

        pThisClassDef = pClassDef + i;

        FreeADsStr(pThisClassDef->szClassName);

        FreeItemList(pThisClassDef->lpSuperClasses);
        FreeItemList(pThisClassDef->lpContainmentClasses);
        FreeItemList(pThisClassDef->lpNamingAttributes);
        FreeItemList(pThisClassDef->lpMandatoryAttributes);
        FreeItemList(pThisClassDef->lpOptionalAttributes);
    }

    FreeADsMem(pClassDef);

    RRETURN(S_OK);
}


HRESULT
ADsNdsReadAttrDef(
    NDS_CONTEXT_HANDLE hADsContext,
    DWORD  dwInfoType,
    LPWSTR *ppszAttrs,
    DWORD nAttrs,
    NDS_BUFFER_HANDLE *phBuf
    )
{
    NWDSCCODE           ccode;
    HRESULT             hr = S_OK;
    DWORD               i;
    pBuf_T              pInBuf = NULL;
    BOOL                fAllAttrs = FALSE;
    BOOL                fBufAllocated = FALSE;
    NWDSContextHandle   context;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = phBuf ? (PNDS_BUFFER_DATA) *phBuf : NULL;

    if ( !pADsContext  || !phBuf) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    if( pBufData == NULL) {
        pBufData = (PNDS_BUFFER_DATA) AllocADsMem( sizeof(NDS_BUFFER_DATA) );
        if (!pBufData) {
            RRETURN(E_OUTOFMEMORY);
        }
        fBufAllocated = TRUE;
        pBufData->lIterationHandle = NO_MORE_ITERATIONS;
        pBufData->pOutBuf = NULL;
        pBufData->dwInfoType = dwInfoType;

        ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pBufData->pOutBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    }
    else {
        if ( pBufData->lIterationHandle == NO_MORE_ITERATIONS) {
            RRETURN (S_ADS_NOMORE_COLUMNS);
        }
    }

    if (nAttrs == (DWORD) -1) {
        fAllAttrs = TRUE;
        pInBuf = NULL;
    }
    else {

        // Allocate and initialize input buffer a directory services
        // read operation.
        //
        ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pInBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        ccode = NWDSInitBuf(context, DSV_READ_ATTR_DEF, pInBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        // To prepare for the read, place the names of the attributes
        // into the input buffer
        //
        for(i = 0; i < nAttrs; i++)
        {
           ccode = NWDSPutAttrName(context, pInBuf, (pnstr8) ppszAttrs[i]);
           CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
        }

    }

    ccode = NWDSReadAttrDef(
                context,
                dwInfoType,
                fAllAttrs,
                pInBuf,
                &pBufData->lIterationHandle,
                pBufData->pOutBuf
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);


    if (pBufData->lIterationHandle == NO_MORE_ITERATIONS) {
        hr = S_ADS_NOMORE_COLUMNS;
    }
    else {
        hr = S_OK;
    }

    *phBuf = pBufData;

    if (pInBuf) {
        NWDSFreeBuf(pInBuf);
    }

    RRETURN(hr);

error:

    if (pInBuf) {
        NWDSFreeBuf(pInBuf);
    }

    if (fBufAllocated) {

        if (pBufData->pOutBuf) {
            NWDSFreeBuf(pBufData->pOutBuf);
        }

        FreeADsMem(pBufData);
    }
    RRETURN(hr);

}


HRESULT
ADsNdsGetAttrDefListFromBuffer(
   NDS_CONTEXT_HANDLE hADsContext,
   NDS_BUFFER_HANDLE hBufData,
   PDWORD  pdwNumEntries,
   PDWORD  pdwInfoType,
   PNDS_ATTR_DEF *ppAttrDef
   )
{

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) hBufData;

    nuint32 luAttrDefCount = 0, luItemCount = 0;
    WCHAR pszTemp[MAX_DN_CHARS+1] = L"";
    Attr_Info_T  attrInfo;
    DWORD j;
    LPNDS_ATTR_DEF pThisAttrDef = NULL, pAttrDef = NULL;
    HRESULT hr = S_OK;
    NWDSCCODE ccode;
    NWDSContextHandle   context;


    if (!pADsContext || !pBufData || !pdwNumEntries ||
        !pdwInfoType || !ppAttrDef || !pBufData->pOutBuf) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    *ppAttrDef = NULL;
    *pdwNumEntries = 0;
    *pdwInfoType = pBufData->dwInfoType;

    ccode = NWDSGetAttrCount(context, pBufData->pOutBuf, &luAttrDefCount);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    if (luAttrDefCount) {

        pAttrDef = (PNDS_ATTR_DEF) AllocADsMem(
                                                sizeof(NDS_ATTR_DEF) *
                                                luAttrDefCount );
        if (!pAttrDef) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memset (pAttrDef, 0x0,  sizeof(NDS_ATTR_DEF) * luAttrDefCount);
    }

    for (j = 0; j < luAttrDefCount; j++) {

        pThisAttrDef = pAttrDef + j;

        ccode = NWDSGetAttrDef(
                    context,
                    pBufData->pOutBuf,
                    (pnstr8) pszTemp,
                    &attrInfo
                    );
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        pThisAttrDef->szAttributeName = AllocADsStr(pszTemp);

        if (pBufData->dwInfoType == DS_ATTR_DEFS) {

            pThisAttrDef->dwFlags = attrInfo.attrFlags;
            pThisAttrDef->dwSyntaxID = attrInfo.attrSyntaxID;
            pThisAttrDef->dwLowerLimit = attrInfo.attrLower;
            pThisAttrDef->dwUpperLimit = attrInfo.attrUpper;

        }

    }

    *pdwNumEntries = luAttrDefCount;
    *ppAttrDef = pAttrDef;

    RRETURN(hr);

error:

    if (pAttrDef) {
        ADsNdsFreeAttrDefList(pAttrDef,luAttrDefCount);
    }

    RRETURN(hr);

}

HRESULT
ADsNdsFreeAttrDef(
    PNDS_ATTR_DEF pAttrDef
    )
{

    if (!pAttrDef) {
        RRETURN(S_OK);
    }
    FreeADsStr(pAttrDef->szAttributeName);

    FreeADsMem(pAttrDef);

    RRETURN(S_OK);

}

HRESULT
ADsNdsFreeAttrDefList(
    PNDS_ATTR_DEF pAttrDef,
    DWORD dwNumEntries
    )
{
    PNDS_ATTR_DEF pThisAttrDef;

    if (!pAttrDef) {
        RRETURN(S_OK);
    }

    for (DWORD i = 0; i < dwNumEntries; i++) {

        pThisAttrDef = pAttrDef + i;

        FreeADsStr(pThisAttrDef->szAttributeName);
    }

    FreeADsMem(pAttrDef);

    RRETURN(S_OK);
}


//
// Free all the allocated memory in the list and the list itself.
//

HRESULT
FreeItemList(
    LPWSTR_LIST pList
    )
{
    LPWSTR_LIST pCurr = pList;

    while (pCurr) {
        FreeADsStr(pCurr->szString);
        pCurr = pCurr->Next;
    }

    FreeADsMem(pList);

    RRETURN(S_OK);

}

HRESULT
ADsNdsFreeBuffer(
    NDS_BUFFER_HANDLE hBuf
    )
{
    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) hBuf;

    if (pBufData) {

        if (pBufData->pOutBuf) {
            NWDSFreeBuf(pBufData->pOutBuf);
        }

        if (pBufData->pInBuf) {
            NWDSFreeBuf(pBufData->pInBuf);
        }

        FreeADsMem(pBufData);
    }

    RRETURN(S_OK);
}


HRESULT
ADsNdsCreateBuffer(
    NDS_CONTEXT_HANDLE hADsContext,
    DWORD dwOperation,
    NDS_BUFFER_HANDLE *phBufData
    )
{
    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    if (!hADsContext || !phBufData) {

        RRETURN(E_ADS_BAD_PARAMETER);
    }

    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) AllocADsMem( sizeof(NDS_BUFFER_DATA) );
    if (!pBufData) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    pBufData->lIterationHandle = NO_MORE_ITERATIONS;
    pBufData->pOutBuf = NULL;
    pBufData->dwOperation = dwOperation;

    ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pBufData->pInBuf);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    ccode = NWDSInitBuf(
                pADsContext->hContext,
                dwOperation,
                pBufData->pInBuf
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    *phBufData = pBufData;

error:

    RRETURN(hr);

}


HRESULT
ADsNdsPutInBuffer(
    NDS_CONTEXT_HANDLE hADsContext,
    NDS_BUFFER_HANDLE hBufData,
    LPWSTR szAttributeName,
    DWORD  dwSyntaxID,
    LPNDSOBJECT lpAttributeValues,
    DWORD  dwValueCount,
    DWORD  dwChangeType
    )
{
    LPNDSOBJECT pThisValue = NULL;
    NWDSContextHandle   context;

    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) hBufData;

    nptr attrVal = NULL;
    DWORD i = 0, luSyntax, luAttrValSize = 0;

    if (!hADsContext || !hBufData) {

        RRETURN(E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    switch (pBufData->dwOperation) {

    case DSV_ADD_ENTRY:

        ccode = NWDSPutAttrName (
                    context,
                    pBufData->pInBuf,
                    (pnstr8) szAttributeName
                    );
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
        break;

    default:

        ccode = NWDSPutChange (
                    context,
                    pBufData->pInBuf,
                    dwChangeType,
                    (pnstr8) szAttributeName
                    );
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
        break;

    }

    for (i=0; i < dwValueCount; i++) {

        pThisValue = lpAttributeValues + i;


        hr = CopyNdsObjectToNdsValue(
                   (PNDSOBJECT) pThisValue,
                   (nptr *) &attrVal,
                   &luAttrValSize,
                   &luSyntax
                   );
        BAIL_ON_FAILURE(hr);


        ccode = NWDSPutAttrVal (
                    context,
                    pBufData->pInBuf,
                    luSyntax,
                    attrVal
                    );
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        if (attrVal) {
            FreeNdsValues(luSyntax, attrVal, luAttrValSize);
            attrVal = NULL;
        }

    }

error:

    if (attrVal) {
        FreeNdsValues(luSyntax, attrVal, luAttrValSize);
    }

    RRETURN(hr);

}


HRESULT
ADsNdsPutFilter(
    NDS_CONTEXT_HANDLE hADsContext,
    NDS_BUFFER_HANDLE hBufData,
    pFilter_Cursor_T pCur,
    void (N_FAR N_CDECL  *freeVal)(nuint32 syntax, nptr val)
    )
{
    NWDSContextHandle   context;

    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) hBufData;

    nstr                treeName[MAX_DN_CHARS+1];
    nuint32             flags;

    if (!hADsContext || !hBufData) {

        RRETURN(E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    ccode = NWDSGetContext(context, DCK_TREE_NAME, &treeName);
    ccode = NWDSGetContext(context, DCK_FLAGS, &flags);

    NWDSPutFilter(
        pADsContext->hContext,
        pBufData->pInBuf,
        pCur,
        freeVal
        );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    ccode = NWDSGetContext(context, DCK_TREE_NAME, &treeName);
    ccode = NWDSGetContext(context, DCK_FLAGS, &flags);

error:

    RRETURN(hr);

}

HRESULT
ADsNdsModifyObject(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR szObjectName,
    NDS_BUFFER_HANDLE hBufData
    )
{
    NWDSContextHandle   context;
    nint32              lIterationHandle = NO_MORE_ITERATIONS;

    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) hBufData;

    if (!hADsContext || !hBufData) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    ccode = NWDSModifyObject(
                context,
                (pnstr8) szObjectName,
                &lIterationHandle,
                FALSE,
                pBufData->pInBuf
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);
}

HRESULT
ADsNdsAddObject(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR szObjectName,
    NDS_BUFFER_HANDLE hBufData
    )
{
    NWDSContextHandle   context;
    nint32              lIterationHandle = NO_MORE_ITERATIONS;

    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pBufData = (PNDS_BUFFER_DATA) hBufData;

    if (!hADsContext || !hBufData) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    ccode = NWDSAddObject(
                context,
                (pnstr8) szObjectName,
                &lIterationHandle,
                FALSE,
                pBufData->pInBuf
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);
}

HRESULT
ADsNdsGenObjectKey(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR szObjectName
    )
{
    NWDSContextHandle   context;
    HRESULT hr = S_OK;
    NWDSCCODE ccode;
    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    if (!hADsContext) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    //
    // To ensure that read/search doesn't collide with GenObjectKeyPair().
    // GenObjectKeyPair() changes the context state which will cause read/search
    // to return type-less DNs
    //
    EnterCriticalSection(&g_ContextCritSect);

    ccode = NWDSGenerateObjectKeyPair(
                            context,
                            (pnstr8) szObjectName,
                            "",
                            0);

    LeaveCriticalSection(&g_ContextCritSect);

    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);
}


HRESULT
ADsNdsRemoveObject(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR szObjectName
    )
{
    NWDSContextHandle   context;

    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    if (!hADsContext) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    ccode = NWDSRemoveObject(
                context,
                (pnstr8) szObjectName
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);
}

HRESULT
ADsNdsGetSyntaxID(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR szAttributeName,
    PDWORD pdwSyntaxId
    )
{

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    if (!pADsContext) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    ccode = NWDSGetSyntaxID(
                pADsContext->hContext,
                (pnstr8) szAttributeName,
                pdwSyntaxId
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);

}


HRESULT
ADsNdsSearch(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR             szObjectName,
    DWORD              scope,
    BOOL               fSearchAliases,
    NDS_BUFFER_HANDLE  hFilterBuf,
    pTimeStamp_T       pTimeStamp,
    DWORD              dwInfoType,
    LPWSTR             *ppszAttrs,
    DWORD              nAttrs,
    DWORD              nObjectsTobeSearched,
    PDWORD             pnObjectsSearched,
    NDS_BUFFER_HANDLE  *phBuf,
    pnint32            plIterationHandle
    )
{
    NWDSContextHandle   context;

    HRESULT hr = S_OK;
    NWDSCCODE ccode;
    BOOL fBufAllocated = FALSE;
    DWORD i, j;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pFilterBuf = (PNDS_BUFFER_DATA) hFilterBuf;
    PNDS_BUFFER_DATA pBuf = phBuf ? (PNDS_BUFFER_DATA) *phBuf : NULL;
    nstr               treeName[MAX_DN_CHARS+1];
    nuint32             flags;

    if (!hADsContext || !hFilterBuf || !phBuf ) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    context = pADsContext->hContext;

    ccode = NWDSGetContext(context, DCK_TREE_NAME, &treeName);
    ccode = NWDSGetContext(context, DCK_FLAGS, &flags);

    //
    // Allocate the result buffer if not already done
    //

    if( pBuf == NULL) {
        pBuf = (PNDS_BUFFER_DATA) AllocADsMem( sizeof(NDS_BUFFER_DATA) );
        if (!pBuf) {
            RRETURN(E_OUTOFMEMORY);
        }
        fBufAllocated = TRUE;
        pBuf->pOutBuf = NULL;
        pBuf->pInBuf = NULL;
        pBuf->dwInfoType = dwInfoType;
        pBuf->dwOperation = DSV_SEARCH;

        ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN * 4, &pBuf->pOutBuf);
        CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

        if (nAttrs == (DWORD) -1) {
            pBuf->fAllAttrs = TRUE;
            pBuf->pInBuf = NULL;
        }
        else {

            // Allocate and initialize input buffer a directory services
            // read operation.
            //
            ccode = NWDSAllocBuf(DEFAULT_MESSAGE_LEN, &pBuf->pInBuf);
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            ccode = NWDSInitBuf(context, DSV_SEARCH, pBuf->pInBuf);
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

            // To prepare for the read, place the names of the attributes
            // into the input buffer
            //
            for(i = 0; i < nAttrs; i++)
            {
               ccode = NWDSPutAttrName(context, pBuf->pInBuf, (pnstr8) ppszAttrs[i]);
               CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
            }

        }

    }

    //
    // To ensure that read/search doesn't collide with GenObjectKeyPair().
    // GenObjectKeyPair() changes the context state which will cause read/search
    // to return type-less DNs
    //
    EnterCriticalSection(&g_ContextCritSect);

    if (pTimeStamp) {
        ccode = NWDSExtSyncSearch(
                    context,
                    (pnstr8) szObjectName,
                    (nint) scope,
                    (nbool8) fSearchAliases,
                    pFilterBuf->pInBuf,
                    pTimeStamp,
                    pBuf->dwInfoType,
                    (nbool8) pBuf->fAllAttrs,
                    pBuf->pInBuf,
                    plIterationHandle,
                    (nint32) nObjectsTobeSearched,
                    (pnint32) pnObjectsSearched,
                    pBuf->pOutBuf
                    );
    }
    else {
        ccode = NWDSSearch(
                    context,
                    (pnstr8) szObjectName,
                    (nint) scope,
                    (nbool8) fSearchAliases,
                    pFilterBuf->pInBuf,
                    pBuf->dwInfoType,
                    (nbool8) pBuf->fAllAttrs,
                    pBuf->pInBuf,
                    plIterationHandle,
                    (nint32) nObjectsTobeSearched,
                    (pnint32) pnObjectsSearched,
                    pBuf->pOutBuf
                    );
    }
    LeaveCriticalSection(&g_ContextCritSect);

    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

    *phBuf = pBuf;

    RRETURN(hr);


error:

    if (fBufAllocated) {

        if (pBuf->pOutBuf) {
            NWDSFreeBuf(pBuf->pOutBuf);
        }

        if (pBuf->pInBuf) {
            NWDSFreeBuf(pBuf->pInBuf);
        }

        FreeADsMem(pBuf);
    }

    RRETURN(hr);
}


HRESULT
ADsNdsMoveObject(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR pszSrcObjectDn,
    LPWSTR pszDestContainerDn,
    LPWSTR pszNewRDN
    )
{

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    if (!pADsContext) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    ccode = NWDSMoveObject(
                pADsContext->hContext,
                (pnstr8) pszSrcObjectDn,
                (pnstr8) pszDestContainerDn,
                (pnstr8) pszNewRDN
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);

}

HRESULT
ADsNdsRenameObject(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR pszSrcObjectDn,
    LPWSTR pszNewRDN
    )
{

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    HRESULT hr = S_OK;
    NWDSCCODE ccode;

    if (!pADsContext) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    ccode = NWDSModifyRDN(
                pADsContext->hContext,
                (pnstr8) pszSrcObjectDn,
                (pnstr8) pszNewRDN,
                TRUE
                );
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    RRETURN(hr);

}


HRESULT
ADsNdsChangeObjectPassword(
   NDS_CONTEXT_HANDLE hADsContext,
   LPWSTR szObjectName,
   NWOBJ_TYPE dwOT_ID,
   LPWSTR szOldPassword,
   LPWSTR szNewPassword
   )
{
    NWCCODE      ccode = 0;
    HRESULT hr = S_OK;

    nuint32       connRef = 0;
    NWCONN_HANDLE connHandle;

    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;

    char *szAnsiNewPassword = szNewPassword ? (char *)AllocADsMem(wcslen(szNewPassword)+1) : NULL;
    char *szAnsiOldPassword = szOldPassword ? (char *)AllocADsMem(wcslen(szOldPassword)+1) : (char *) AllocADsMem(1);

    if ( !szObjectName || !szNewPassword ) {

        hr = E_INVALIDARG ;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Convert UNICODE into ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    UnicodeToAnsiString(
        szNewPassword,
        szAnsiNewPassword,
        0
        );

    //
    // If the old password is passed in, we'll call change password
    //
    if (szOldPassword) {
        UnicodeToAnsiString(
            szOldPassword,
            szAnsiOldPassword,
            0
            );
        ccode = NWDSChangeObjectPassword(
                pADsContext->hContext,
                0,
                (pnstr8) szObjectName, //IMP: send the unicode string itself
                szAnsiOldPassword,
                szAnsiNewPassword
                );
    }
    //
    // Else, we'll set the password to the supplied password
    //
    else {
        szAnsiOldPassword[0] = 0 ;

        //
        // To ensure that read/search doesn't collide with GenObjectKeyPair().
        // GenObjectKeyPair() changes the context state which will cause
        // read/search to return type-less DNs
        //
        EnterCriticalSection(&g_ContextCritSect);
        ccode = NWDSGenerateObjectKeyPair(
                        pADsContext->hContext,
                        (pnstr8) szObjectName,
                        szAnsiNewPassword,
                        0);
        LeaveCriticalSection(&g_ContextCritSect);

    }
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

error:

    FreeADsMem(szAnsiOldPassword);
    FreeADsMem(szAnsiNewPassword);

    RRETURN(hr);

}

//
// General function to convert variant array to string array
//
HRESULT
ConvertVariantArrayToStringArray(
    PVARIANT pVarArray,
    PWSTR **pppszStringArray,
    DWORD dwNumStrings
    )
{
    HRESULT hr = S_OK;
    PWSTR *ppszStringArray = NULL;
    DWORD i = 0;

    //
    // Start off with a zero-length array.
    //
    *pppszStringArray = NULL;

    ppszStringArray = (PWSTR *)AllocADsMem(dwNumStrings * sizeof(PWSTR));
    if (!ppszStringArray)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    for (i = 0; i < dwNumStrings; i++)
    {
        if (!(V_VT(pVarArray + i) == VT_BSTR))
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

        ppszStringArray[i] = AllocADsStr(V_BSTR(pVarArray + i));
        if (!ppszStringArray[i])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    *pppszStringArray = ppszStringArray;
    RRETURN(hr);

error:
    if (ppszStringArray)
    {
        for (DWORD j = 0; j < i; j++)
            if (ppszStringArray[i])
                FreeADsStr(ppszStringArray[i]);

        FreeADsMem(ppszStringArray);
    }
    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiOpenPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiOpenPrinter(
    LPWSTR lpszUncPrinterName,
    HANDLE *phPrinter,
    DWORD  dwAccess
    )
{
    BOOL    fStatus = TRUE;
    HANDLE  hPrinter;
    HRESULT hr = S_OK;
    PRINTER_DEFAULTS PrinterDefault = {0, 0, dwAccess};

    //
    // Set desired access right.
    //

    PrinterDefault.DesiredAccess = dwAccess;

    //
    // Get a handle to the speccified printer using Win32 API.
    //

    fStatus = OpenPrinter(
                  lpszUncPrinterName,
                  &hPrinter,
                  &PrinterDefault
                  );

    //
    // Convert error code into HRESULT.
    //

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Return.
    //

    else {
        *phPrinter = hPrinter;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiClosePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiClosePrinter(
    HANDLE hPrinter
    )
{
    BOOL fStatus = TRUE;
    HRESULT hr = S_OK;

    //
    // Close a printer using Win32 API.
    //

    fStatus = ClosePrinter(hPrinter);

    //
    // Convert error code into HRESULT.
    //

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE lpbPrinters,
    DWORD  dwAccess
    )
{
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    fStatus = SetPrinter(
                  hPrinter,
                  dwLevel,
                  lpbPrinters,
                  dwAccess
                  );
    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\qryparse.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qryparse.cxx

Abstract:

Author:

    Felix Wong [t-FelixW]    05-Nov-1996
    
++*/
#include "nds.hxx"
#pragma hdrstop

//#define DEBUG_DUMPSTACK
//#define DEBUG_DUMPRULE

#if (defined(DEBUG_DUMPSTACK) || defined (DEBUG_DUMPRULE))
#include "stdio.h"
#endif

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )


nuint16 g_MapTokenToNdsToken[] = {

        FTOK_END,           // TOKEN_ERROR     
        FTOK_LPAREN,        // TOKEN_LPARAN    
        FTOK_RPAREN,        // TOKEN_RPARAN    
        FTOK_OR,            // TOKEN_OR        
        FTOK_AND,           // TOKEN_AND       
        FTOK_NOT,           // TOKEN_NOT       
        FTOK_APPROX,        // TOKEN_APPROX_EQ 
        FTOK_EQ,            // TOKEN_EQ        
        FTOK_LE,            // TOKEN_LE        
        FTOK_GE,            // TOKEN_GE        
        FTOK_PRESENT,       // TOKEN_PRESENT   
        FTOK_ANAME,         // TOKEN_ATTRTYPE  
        FTOK_AVAL,          // TOKEN_ATTRVAL   
        FTOK_END            // TOKEN_ENDINPUT
};

// Action Table 
typedef struct _action{
    DWORD type;
    DWORD dwState;
}action;

// Rule Table 
typedef struct _rule{
    DWORD dwNumber;
    DWORD dwA;
}rule;

enum types {
    N,
    S,
    R,
    A
    };

#define X 99

action g_action[28][14] = { 
//       ERROR  ,LPARAN,RPARAN,OR,    AND,   NOT,   APPROX,EQ,    LE,    GE,    PRESNT,ATYPE, VAL,   END,  
/*00*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*01*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{A,X } },
/*02*/  { {N,X },{N,X },{N,X },{S,12},{S,11},{S,13},{N,X },{N,X },{N,X },{N,X },{N,X },{S,14},{N,X },{N,X } },
/*03*/  { {N,X },{N,X },{R,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*04*/  { {N,X },{N,X },{R,3 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*05*/  { {N,X },{N,X },{R,4 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*06*/  { {N,X },{N,X },{R,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*07*/  { {N,X },{N,X },{S,15},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*08*/  { {N,X },{N,X },{R,11},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*09*/  { {N,X },{N,X },{R,12},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*10*/  { {N,X },{N,X },{R,13},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*11*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*12*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*13*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*14*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,20},{S,26},{S,22},{S,21},{S,23},{N,X },{N,X },{N,X } },
/*15*/  { {N,X },{R,1 },{R,1 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,1 } },
/*16*/  { {N,X },{N,X },{R,6 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*17*/  { {N,X },{S,2 },{R,9 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*18*/  { {N,X },{N,X },{R,7 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*19*/  { {N,X },{N,X },{R,8 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*20*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,15},{N,X } },
/*21*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,16},{N,X } },
/*22*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,17},{N,X } },
/*23*/  { {N,X },{N,X },{R,18},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*24*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,25},{N,X } },
/*25*/  { {N,X },{N,X },{R,14},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*26*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,19},{N,X } },
/*27*/  { {N,X },{N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } }
};

enum non_terminals {
    NONTERM_F,
    NONTERM_FC,
    NONTERM_AND,
    NONTERM_OR,
    NONTERM_NOT,
    NONTERM_FL,
    NONTERM_ITM,
    NONTERM_SMP,
    NONTERM_FT,
    NONTERM_PRS
};


rule g_rule[] = {
//        1)No. of non-terminals and terminals on the right hand side
//        2)The Parent
/*00*/    {0, 0,             },
/*01*/    {3, NONTERM_F,     },
/*02*/    {1, NONTERM_FC,    },
/*03*/    {1, NONTERM_FC,    },
/*04*/    {1, NONTERM_FC,    },
/*05*/    {1, NONTERM_FC,    },
/*06*/    {2, NONTERM_AND,   },
/*07*/    {2, NONTERM_OR,    },
/*08*/    {2, NONTERM_NOT,   },
/*09*/    {1, NONTERM_FL,    },
/*10*/    {2, NONTERM_FL,    },
/*11*/    {1, NONTERM_ITM,   },
/*12*/    {1, NONTERM_ITM,   },
/*13*/    {1, NONTERM_ITM,   },
/*14*/    {3, NONTERM_SMP,   },
/*15*/    {1, NONTERM_FT,    },
/*16*/    {1, NONTERM_FT,    },
/*17*/    {1, NONTERM_FT,    },
/*18*/    {2, NONTERM_PRS,   },
/*19*/    {1, NONTERM_FT,    }
};

#ifdef DEBUG_DUMPRULE
LPWSTR g_rgszRule[] = {
/*00*/    L"",
/*01*/    L"F->(FC)",
/*02*/    L"FC->AND",
/*03*/    L"FC->OR",
/*04*/    L"FC->NOT",
/*05*/    L"FC->ITM",
/*06*/    L"AND->&FL",
/*07*/    L"OR->|FL",
/*08*/    L"NOT->!F",
/*09*/    L"FL->F",
/*10*/    L"FL->F FL",
/*11*/    L"ITM->SMP",
/*12*/    L"ITM->PRS",
/*13*/    L"ITM->STR",
/*14*/    L"SMP->ATR FT VAL",
/*15*/    L"FT->~=",
/*16*/    L"FT->>=",
/*17*/    L"FT-><=",
/*18*/    L"PRS->ATR=*",
/*19*/    L"FT->="
};
#endif

DWORD g_goto[28][10] = {
//         F,   FC,  AND, OR,  NOT, FL,  ITM, SMP, FT,  PRS, 
/*00*/    {1,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*01*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*02*/    {X,   7,   3,   4,   5,   X,   6,   8,   X,   9  },
/*03*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*04*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*05*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*06*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*07*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*08*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*09*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*10*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*11*/    {17,  X,   X,   X,   X,  16,   X,   X,   X,   X  },
/*12*/    {17,  X,   X,   X,   X,  18,   X,   X,   X,   X  },
/*13*/    {19,  X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*14*/    {X,   X,   X,   X,   X,   X,   X,   X,  24,   X  },
/*15*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*16*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*17*/    {17,  X,   X,   X,   X,  27,   X,   X,   X,   X  },
/*18*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*19*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*20*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*21*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*22*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*23*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*24*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*25*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*26*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*27*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  }
};

HRESULT MapTokenToType(
                    DWORD dwToken,
                    DWORD *pdwType
                    )
{
    DWORD dwType;    
    switch(dwToken) {            
        case TOKEN_EQ:
            dwType = QUERY_EQUAL;
            break;
        case TOKEN_LE:
            dwType = QUERY_LE;
            break;
        case TOKEN_GE:
            dwType = QUERY_GE;
            break;
        case TOKEN_APPROX_EQ:
            dwType = QUERY_APPROX;
            break;
        default:
            return (E_ADS_INVALID_FILTER);
    }
    *pdwType = dwType;
    return (S_OK);
}

HRESULT Parse(
          LPWSTR szQuery,
          CQueryNode **ppNode,
          CAttrList **ppAttrList
          )
{
    CStack Stack;
    CQryLexer Query(szQuery);
    LPWSTR lexeme;
    DWORD dwToken;
    DWORD dwState;
    HRESULT hr = E_ADS_INVALID_FILTER;

    CAttrList* pAttrList = new CAttrList;
    if (!pAttrList)
        return E_OUTOFMEMORY;

    CSyntaxNode *pSynNode = NULL;
    CQueryNode *pNode1 = NULL;
    CQueryNode *pNode2 = NULL;
    CQueryNode *pNode3 = NULL;
    
    // Push in State 0
    pSynNode = new CSyntaxNode;
    Stack.Push(pSynNode);
    pSynNode = NULL;

#ifdef DEBUG_DUMPSTACK
    Stack.Dump();
#endif

    while (1) {
        // Getting information for this iteration, dwToken and dwState
        hr = Query.GetCurrentToken(
                                &lexeme,
                                &dwToken 
                                );
        BAIL_ON_FAILURE(hr);

        hr = Stack.Current(&pSynNode);
        BAIL_ON_FAILURE(hr);
        
        dwState = pSynNode->_dwState;
        pSynNode = NULL;
        
        // Analysing and processing the data 
        if (g_action[dwState][dwToken].type == S) {
            pSynNode = new CSyntaxNode;
            pSynNode->_dwState = g_action[dwState][dwToken].dwState;
            pSynNode->_dwToken = dwToken;
            switch (dwToken) {
                case TOKEN_ATTRTYPE:
                {
                    hr = pAttrList->Add(lexeme);
                    BAIL_ON_FAILURE(hr);
                }
                case TOKEN_ATTRVAL:
                // both TOKEN_ATTRTYPE and TOKEN_ATTRVAL will get here
                {    
                    LPWSTR szValue = AllocADsStr(lexeme);
                    if (!szValue) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    pSynNode->SetNode(szValue);
                    break;
                }
            }
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;

            hr = Query.GetNextToken(
                               &lexeme,
                               &dwToken
                               );
            BAIL_ON_FAILURE(hr);
#ifdef DEBUG_DUMPSTACK
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == R) {
            DWORD dwRule = g_action[dwState][dwToken].dwState;
            DWORD dwNumber = g_rule[dwRule].dwNumber;
#ifdef DEBUG_DUMPRULE             
            wprintf(L"%s\n",g_rgszRule[dwRule]);
#endif            
            pSynNode = new CSyntaxNode;
            CSyntaxNode *pSynNodeRed;
            switch (dwRule) {
                case 1:  // Reduction of Basic Filter rule
                {
                    // Getting the middle node

                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);

                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    break;
                }
                case 18: // Reduction of PRESENT rule
                {
                    // Getting second node
                    LPWSTR szType;
                    
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szType = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeLeaf(
                               szType,
                               &pNode1
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeNode(
                               QUERY_PRESENT,
                               pNode1,
                               NULL,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    pNode1 = NULL;

                    pSynNode->SetNode(
                              pNode2
                              );
                    pNode2 = NULL;
                    break;
                }
                case 14:    // Reduction of SMP rule 
                {
                    LPWSTR szType;
                    LPWSTR szValue;
                    DWORD dwType;
                    DWORD dwToken;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szValue = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwToken = (DWORD)pSynNodeRed->_dwFilterType;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szType = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeLeaf(
                               szType,
                               &pNode1
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeLeaf(
                               szValue,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MapTokenToType(
                                   dwToken,
                                   &dwType
                                   );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               pNode2,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    pNode3 = NULL;

                    break;
                }
                case 6:     // Reduction of AND, OR rules
                case 7:
                {
                    DWORD dwType;
                    
                    Stack.Pop(&pSynNodeRed);
                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    Stack.Pop();
                    
                    // Adding in the type information
                    if (dwRule == 6)
                        dwType = QUERY_AND;
                    else
                        dwType = QUERY_OR;
                    
                    pSynNode->_pNode->_dwType = dwType;
                    break;
                }
                case 10:    // Reduction of FL rule
                {
                    DWORD dwType;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode2 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    if (pNode2->_dwType == QUERY_UNKNOWN) {
                        // It's not new node, append to node1
                        hr = pNode2->AddChild(pNode1);
                        BAIL_ON_FAILURE(hr);
                        pSynNode->SetNode(
                                  pNode2
                                  );
                        pNode1 = NULL;
                        pNode2 = NULL;
                    }
                    else {
                        // New node
                        hr = MakeNode(
                                   QUERY_UNKNOWN,
                                   pNode1,
                                   pNode2,
                                   &pNode3
                                   );
                        BAIL_ON_FAILURE(hr);
                        pSynNode->SetNode(
                                  pNode3
                                  );
                        pNode1 = NULL;
                        pNode2 = NULL;
                        pNode3 = NULL;
                    }
                    break;
                }
                case 9:    // Reduction of FL rule
                {
                    DWORD dwType;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeNode(
                               QUERY_UNKNOWN,
                               pNode1,
                               NULL,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode3 = NULL;
                    break;
                }
                case 8:     // Reduction of NOT rule
                {
                    Stack.Pop(&pSynNodeRed);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeNode(
                               QUERY_NOT,
                               pNode1,
                               NULL,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    pNode1 = NULL;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode2
                              );
                    pNode2 = NULL;
                    break;
                }
                case 15:    // Reduction of FT rule
                case 16:
                case 17:
                case 19:
                {
                    // Propagating the last entry
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_dwToken
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                default:
                {
                    // For all the other rules, we propogate the last entry
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    for (DWORD i = 0;i<dwNumber-1;i++)
                        Stack.Pop();
                }
            }
            hr = Stack.Current(&pSynNodeRed);
            BAIL_ON_FAILURE(hr);
            
            dwState = pSynNodeRed->_dwState;
            DWORD A = g_rule[dwRule].dwA;
            pSynNode->_dwState = g_goto[dwState][A];
            pSynNode->_dwToken = A;
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;
#ifdef DEBUG_DUMPSTACK
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == A){
            hr = Stack.Pop(&pSynNode);
            BAIL_ON_FAILURE(hr);
            *ppNode = pSynNode->_pNode; 
            *ppAttrList = pAttrList;
            pSynNode->_dwType = SNODE_NULL;
            delete pSynNode;
            return S_OK;
        }
        else {
            hr = E_ADS_INVALID_FILTER;
            goto error;
        }
    }
error:
    if (pAttrList) {
        delete pAttrList;
    }
    if (pSynNode) {
        delete pSynNode;
    }
    if (pNode1) {
        delete pNode1;
    }
    if (pNode2) {
        delete pNode2;
    }
    if (pNode3) {
        delete pNode3;
    }
    return hr;
}

                
CStack::CStack()
{
    _dwStackIndex = 0;
}

CStack::~CStack()
{
    DWORD dwIndex = _dwStackIndex;
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        delete pNode;
    }
}

#ifdef DEBUG_DUMPSTACK
void CStack::Dump()
{
    DWORD dwIndex = _dwStackIndex;
    printf("Stack:\n");
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        printf(
           "State=%5.0d, Token=%5.0d\n",
           pNode->_dwState,
           pNode->_dwToken
           );
    }
}
#endif

HRESULT CStack::Push(CSyntaxNode* pNode)
{
    if (_dwStackIndex < MAXVAL) {
        _Stack[_dwStackIndex++] = pNode;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT CStack::Pop(CSyntaxNode** ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[--_dwStackIndex];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Pop()
{
    if (_dwStackIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--_dwStackIndex];
        delete pNode;
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Current(CSyntaxNode **ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[_dwStackIndex-1];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

CAttrList::CAttrList()
{
    _rgAttr = NULL;
    _dwAttrCur = 0;
}

CAttrList::~CAttrList()
{
    if (_rgAttr) {
        for (DWORD i=0;i<_dwAttrCur;i++) 
            FreeADsStr(_rgAttr[i].szName);
        FreeADsMem(_rgAttr);
    }
}

HRESULT CAttrList::Add(LPWSTR szName)
{
    HRESULT hr = S_OK;
    BOOL fBinary = FALSE;
    LPWSTR pszTemp = NULL;

    for (DWORD i=0;i<_dwAttrCur;i++) {
        if (_wcsicmp(
                szName,
                _rgAttr[i].szName
                ) == 0)
            break;
    }
    
    if (i != _dwAttrCur)    // does not loop till the end, entry exist already
        return S_OK;
        
    LPWSTR szAttr = AllocADsStr(szName);
    if (!szAttr)
        return E_OUTOFMEMORY;

    //
    // Check if the attribute comes with a ";binary" specifier. This means 
    // that the value has to be converted from the encoded form to 
    // octet strings

    if (pszTemp = wcschr (szAttr, L';')) {
        //
        // Make sure binary appears at the end of the attribute name and 
        // immediately after ;
        //
        if (_wcsicmp(pszTemp+1, L"binary") == 0) {
            fBinary = TRUE;
            // 
            // Strip off the binary specifier. 
            //
            wcstok(szAttr, L";");
        }
    }
    
    if (_dwAttrCur == _dwAttrMax) {
        if (!_rgAttr) {
            _rgAttr = (AttrNode*)AllocADsMem(ATTRNODE_INITIAL*sizeof(AttrNode));
            if (!_rgAttr) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            _dwAttrMax = ATTRNODE_INITIAL;
        }
        else {
            _rgAttr = (AttrNode*)ReallocADsMem(
                                             (void*)_rgAttr,
                                             _dwAttrMax*sizeof(AttrNode),
                                             (_dwAttrMax+ATTRNODE_INC)*sizeof(AttrNode)
                                             );
            if (!_rgAttr) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            _dwAttrMax+= ATTRNODE_INC;
        }
    }
    _rgAttr[_dwAttrCur].szName = szAttr;
    _rgAttr[_dwAttrCur].dwType = 0;     //UNKNOWN at this point
    _rgAttr[_dwAttrCur].fBinary = fBinary; 
    _dwAttrCur++;
    return S_OK;
error:
    if (szAttr)
        FreeADsStr(szAttr);
    return (hr);
}

HRESULT CAttrList::SetupType(NDS_CONTEXT_HANDLE hADsContext)
{

    DWORD dwStatus;
    HRESULT hr = S_OK;
    DWORD dwNumberOfEntries;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    DWORD i,j,k;
    LPWSTR *ppszAttrs = NULL;
    HANDLE hOperationData = NULL;

    if (_dwAttrCur == 0) {
        RRETURN(S_OK);
    }

    ppszAttrs = (LPWSTR *) AllocADsMem(_dwAttrCur * sizeof(LPWSTR *));
    if (!ppszAttrs) {
        BAIL_ON_FAILURE(E_OUTOFMEMORY);
    }

    for (i=0, j=0; i<_dwAttrCur; i++) {
        ppszAttrs[j++] = _rgAttr[i].szName;
    }
    
    hr = ADsNdsReadAttrDef(
                    hADsContext,
                    DS_ATTR_DEFS,
                    ppszAttrs,
                    _dwAttrCur,
                    &hOperationData
                    );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsGetAttrDefListFromBuffer(
                    hADsContext,
                    hOperationData,
                    &dwNumberOfEntries,
                    &dwInfoType,
                    &lpAttrDefs
                    );
    BAIL_ON_FAILURE(hr);

    if (dwNumberOfEntries != _dwAttrCur) {
        hr = E_ADS_INVALID_FILTER;
        goto error;
    }

    for (j = 0; j < dwNumberOfEntries ; j++ ) {
        for (k = 0; k < dwNumberOfEntries; k++) {
            if (_wcsicmp(
                    _rgAttr[k].szName,
                    lpAttrDefs[j].szAttributeName
                    ) == 0) {
                _rgAttr[k].dwType = lpAttrDefs[j].dwSyntaxID;
            break;
            }
        }
        if (k == dwNumberOfEntries)     // cannot find entry
            goto error;
    }

error:

    if (ppszAttrs)
        FreeADsMem(ppszAttrs);

    if (hOperationData)
        ADsNdsFreeBuffer( hOperationData );

    ADsNdsFreeAttrDefList(lpAttrDefs, dwNumberOfEntries);

    RRETURN(hr);
}

HRESULT CAttrList::GetType(LPWSTR szName, DWORD *pdwType)
{

   DWORD i = 0;

    for (i=0;i<_dwAttrCur;i++) {
        if (_wcsicmp(
                szName,
                _rgAttr[i].szName
                ) == 0)
            break;
    }
    
    if (i == _dwAttrCur)    // Cannot find attribute
        return E_FAIL;

    *pdwType = _rgAttr[i].dwType;
    return S_OK;
}

CSyntaxNode::CSyntaxNode()
{
    _dwType = SNODE_NULL;
    _dwToken = 0;
    _dwState = 0;
    _pNode = 0;
}

CSyntaxNode::~CSyntaxNode()
{
    switch (_dwType) {
        case SNODE_SZ:
            FreeADsStr(_szValue);
            break;
        case SNODE_NODE:
            delete _pNode;
            break;
        default:
            break;
    }
}

void CSyntaxNode::SetNode(
                    CQueryNode *pNode
                    )       
{
    _pNode = pNode;
    _dwType = SNODE_NODE;
}

void CSyntaxNode::SetNode(
                     LPWSTR szValue
                     )       
{
    _szValue = szValue;
    _dwType = SNODE_SZ;
}

void CSyntaxNode::SetNode(
                    DWORD dwFilterType
                    )       
{
    _dwFilterType = dwFilterType;
    _dwType = SNODE_FILTER;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::CQueryNode
//
//  Synopsis:  Constructor of the CQueryNode
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CQueryNode::CQueryNode()
{
    _dwType = 0;
    _szValue = NULL;
    _dwQueryNode = 0;
    _rgQueryNode = NULL;
    _dwQueryNodeMax = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::SetToString
//
//  Synopsis:  Set the Node to be a String Node
//
//  Arguments: szValue      value of the string
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::SetToString(
    LPWSTR szValue
    )
{
    _szValue = szValue;
    /*
    _szValue = AllocADsStr(szValue);
    if (!_szValue) {
        return E_OUTOFMEMORY;
    }
    */
    _dwType = QUERY_STRING;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::~CQueryNode
//
//  Synopsis:  Destructor of the CQueryNode
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CQueryNode::~CQueryNode()
{
    if (_szValue)
        FreeADsStr(_szValue);
    if (_rgQueryNode) {
        for (DWORD i=0;i<_dwQueryNode;i++) {
            delete _rgQueryNode[i];
        }
        FreeADsMem(_rgQueryNode);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::AddChild
//
//  Synopsis:  Add a child to the node
//
//  Arguments: CQueryNode *pChild   pointer to the child to be added
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::AddChild(CQueryNode *pChild)
{
    if (_dwQueryNode == _dwQueryNodeMax) {
        if (!_rgQueryNode) {
            _rgQueryNode = (CQueryNode**)AllocADsMem(QUERYNODE_INITIAL*sizeof(CQueryNode*));
            if (!_rgQueryNode) {
                return E_OUTOFMEMORY;
            }
            _dwQueryNodeMax = QUERYNODE_INITIAL;
        }
        else {
            _rgQueryNode = (CQueryNode**)ReallocADsMem(
                                             (void*)_rgQueryNode,
                                             _dwQueryNodeMax*sizeof(CQueryNode*),
                                             (_dwQueryNodeMax+QUERYNODE_INC)*sizeof(CQueryNode*)
                                             );
            if (!_rgQueryNode) {
                return E_OUTOFMEMORY;
            }
            _dwQueryNodeMax+= QUERYNODE_INC;
        }
    }
    _rgQueryNode[_dwQueryNode] = pChild;
    _dwQueryNode++;
    return S_OK;
}


HRESULT CQueryNode::AddToFilterBuf(
    pFilter_Cursor_T  pCur,
    CAttrList *pAttrList
    )
{
   HRESULT hr = E_FAIL;
   nuint16 luTokenType;
   DWORD dwStatus = 0;

   LPWSTR szValue = NULL;
   LPWSTR szAttr = NULL;
   NWDSCCODE ccode;
   void*   pValue = NULL;


   // Looking at type of operation
   switch (_dwType) {
       case QUERY_EQUAL:
       case QUERY_LE:
       case QUERY_GE:
       case QUERY_APPROX:
       case QUERY_PRESENT:
       {
           DWORD dwSyntax;
           DWORD dwAttrType;
           LPWSTR pszTemp = NULL;

           // Getting left node
           if (_rgQueryNode[0] &&
               _rgQueryNode[0]->_dwType == QUERY_STRING) {
               szAttr = AllocADsStr(_rgQueryNode[0]->_szValue);
               if (!szAttr) {
                   hr = E_OUTOFMEMORY;
                   goto error;
               }

           }
           else {
               // No nodes available
               goto error;
           }

           // Get syntax info of right node from attribute list
           hr = pAttrList->GetType(
                              szAttr,
                              &dwAttrType
                              );
           BAIL_ON_FAILURE(hr);

           // Getting right node
           if (_rgQueryNode[1] &&
               _rgQueryNode[1]->_dwType == QUERY_STRING) {

               // Format the node depending on the syntax
               switch (dwAttrType) {
                   // WIDE STRING
                   case 1:
                   case 2:
                   case 3:
                   case 4:
                   case 5:
                   case 10:
                   case 11:
                   case 20:
                       pValue = (void *) AllocADsStr(_rgQueryNode[1]->_szValue);
                       if (!pValue) {
                           hr = E_OUTOFMEMORY;
                           goto error;
                       }
                       break;

                   // BOOLEAN
                   case 7: {
                      Boolean_T *pBool = (Boolean_T *) AllocADsMem(sizeof(Boolean_T));
                      if (!pBool) {
                          BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                      }
              
                      *pBool = (Boolean_T) _wtol(_rgQueryNode[1]->_szValue);
                      pValue = pBool;
                      break;
                  }
              
                   // Binary Strings
                   case 9: {
                      hr = E_ADS_CANT_CONVERT_DATATYPE;
                      goto error;
                       break;
                   }

                   // DWORD
                   case 8 :
                   case 22 :
                   case 27 : {
                      Integer_T *pInteger = (Integer_T *) AllocADsMem(sizeof(Integer_T));
                      if (!pInteger) {
                          BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                      }
                      *pInteger = (Integer_T) _wtol(_rgQueryNode[1]->_szValue);
                      pValue = pInteger;
                      break;
                   }

                   case 6 :
                   case 13 :
                   case 14 :
                   case 15 :
                   case 16 :
                   case 17 :
                   case 18 :
                   case 19 :
                   case 23 :
                   case 24 :
                   case 25 :
                   case 26 :
                   default:
                       hr = E_ADS_CANT_CONVERT_DATATYPE;
                       goto error;
                       break;
               }
           }

           hr = MapQueryToNDSType(
                               _dwType,
                               &luTokenType
                               );
           BAIL_ON_FAILURE (hr);

           ccode = NWDSAddFilterToken(
                       pCur, 
                       FTOK_LPAREN,
                       NULL,
                       0
                       );
           CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

           if (_dwType == QUERY_PRESENT ) {
              // 
              // First add the present token and then the attribute 
              //
              ccode = NWDSAddFilterToken(
                          pCur, 
                          FTOK_PRESENT,
                          NULL,
                          0
                          );
              CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
   
              ccode = NWDSAddFilterToken(
                          pCur, 
                          FTOK_ANAME,
                          szAttr,
                          dwAttrType
                          );
              CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
   
              ccode = NWDSAddFilterToken(
                          pCur, 
                          FTOK_RPAREN,
                          NULL,
                          0
                          );
              CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
   
           }
           else {

              // All the rest are binary operators. Add the attribute name, 
              // operator and then the attribute value
              //

              ccode = NWDSAddFilterToken(
                          pCur, 
                          FTOK_ANAME,
                          szAttr,
                          dwAttrType
                          );
              CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
   
              ccode = NWDSAddFilterToken(
                          pCur, 
                          luTokenType,
                          NULL,
                          0
                          );
              CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
   
              ccode = NWDSAddFilterToken(
                          pCur, 
                          FTOK_AVAL,
                          pValue,
                          dwAttrType
                          );
              CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
   
              ccode = NWDSAddFilterToken(
                          pCur, 
                          FTOK_RPAREN,
                          NULL,
                          0
                          );
              CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

           }

           break;
       }
       case QUERY_AND:
       case QUERY_OR:
           {
           hr = MapQueryToNDSType(
                               _dwType,
                               &luTokenType
                               );
           BAIL_ON_FAILURE (hr);

           // Create first node
           if (!_rgQueryNode[0])
               goto error;

            ccode = NWDSAddFilterToken(
                        pCur, 
                        FTOK_LPAREN,
                        NULL,
                        0
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
 
           hr = _rgQueryNode[0]->AddToFilterBuf(
                                           pCur,
                                           pAttrList
                                           );
           BAIL_ON_FAILURE (hr);

           // Go through a loop creating the rest
           for (DWORD i=1;i<_dwQueryNode;i++) {

               if (!_rgQueryNode[i])
                   goto error;

                ccode = NWDSAddFilterToken(
                            pCur, 
                            luTokenType,
                            NULL,
                            0
                            );
                CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
     
               hr = _rgQueryNode[i]->AddToFilterBuf(
                                               pCur,
                                               pAttrList
                                               );
               BAIL_ON_FAILURE (hr);

           }
           ccode = NWDSAddFilterToken(
                       pCur, 
                       FTOK_RPAREN,
                       NULL,
                       0
                       );
           CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

           break;
           }
       case QUERY_NOT:
           {
           hr = MapQueryToNDSType(
                               _dwType,
                               &luTokenType
                               );
           BAIL_ON_FAILURE (hr);

           // Create first node
           if (!_rgQueryNode[0])
               goto error;

            ccode = NWDSAddFilterToken(
                        pCur, 
                        FTOK_LPAREN,
                        NULL,
                        0
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
 
            ccode = NWDSAddFilterToken(
                        pCur, 
                        FTOK_NOT,
                        NULL,
                        0
                        );
            CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
 
           hr = _rgQueryNode[0]->AddToFilterBuf(
                                           pCur,
                                           pAttrList
                                           );
           BAIL_ON_FAILURE (hr);

           ccode = NWDSAddFilterToken(
                       pCur, 
                       FTOK_RPAREN,
                       NULL,
                       0
                       );
           CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);

           break;
           }
       default:
           goto error;
   }

   RRETURN(hr);

error:
   if (szAttr)
       FreeADsStr(szAttr);
   if (pValue)
       FreeADsMem(pValue);
   return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::FreeFilterTokens
//
//  Synopsis:  Frees dynamically-allocated attributes passed to
//             NWDSAddFilterToken by CQueryNode::AddToFilterBuffer
//
//  Arguments: syntax   NetWare syntax attribute ID
//             val      ptr. to memory to be freed
//
//  Returns:
//
//  Modifies: deallocates the memory
//
//  History:    9-18-99   Matthew Rimer Created.
//
//----------------------------------------------------------------------------
void N_FAR N_CDECL  CQueryNode::FreeFilterTokens(
    nuint32 syntax,
    nptr pVal
    )
{
    if (pVal) {

        switch(syntax) {
            // WIDE STRING
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 10:
            case 11:
            case 20:
                FreeADsStr((LPWSTR) pVal);
                break;

            // BOOLEAN
            case 7:
                FreeADsMem(pVal);
                break;

            // DWORD
            case 8:
            case 22:
            case 27:
                FreeADsMem(pVal);
                break;

            // attribute name
            case -1:
                FreeADsStr((LPWSTR) pVal);
                break;

            default:
                break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::MapQueryToNDSType
//
//  Synopsis:  Maps the node type to the equivalent NDS types
//
//  Arguments:  dwType      input type
//              pdwNDSType  output type
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::MapQueryToNDSType(
                                DWORD dwType,
                                nuint16 *pulNDSTokenType
                                )
{
    nuint16 ulNDSTokenType;
    switch(dwType) {
        case QUERY_EQUAL:
            ulNDSTokenType = FTOK_EQ;
            break;
        case QUERY_LE:
            ulNDSTokenType = FTOK_LE;
            break;
        case QUERY_GE:
            ulNDSTokenType = FTOK_GE;
            break;
        case QUERY_APPROX:
            ulNDSTokenType = FTOK_APPROX;
            break;
        case QUERY_PRESENT:
            ulNDSTokenType = FTOK_PRESENT;
            break;
        case QUERY_NOT:
            ulNDSTokenType = FTOK_NOT;
            break;
        case QUERY_AND:
            ulNDSTokenType = FTOK_AND;
            break;
        case QUERY_OR:
            ulNDSTokenType = FTOK_OR;
            break;

        default:
            return (E_ADS_INVALID_FILTER);
    }
    *pulNDSTokenType = ulNDSTokenType;
    return (S_OK);
}


// Helper Functions for creating nodes using the CQueryNode Class

//+---------------------------------------------------------------------------
//
//  Function:  MakeNode
//
//  Synopsis:  Make a node with the input values
//
//  Arguments:  dwType              type of node
//              pLQueryNode         pointer to left node
//              pRQueryNode         pointer to right node
//              ppQueryNodeReturn   pointer to Return Node
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeNode(
    DWORD dwType,
    CQueryNode *pLQueryNode,
    CQueryNode *pRQueryNode,
    CQueryNode **ppQueryNodeReturn
    )
{
    HRESULT hr = S_OK;

    CQueryNode *pQueryNode = new CQueryNode();
    if (!pQueryNode)
        return E_OUTOFMEMORY;

    pQueryNode->_dwType = dwType;

    hr = pQueryNode->AddChild(pLQueryNode);
    BAIL_ON_FAILURE(hr);

    if (pRQueryNode) {
                pQueryNode->AddChild(pRQueryNode);
                BAIL_ON_FAILURE(hr);
        }
    *ppQueryNodeReturn = pQueryNode;

    RRETURN(hr);

error:
    delete pQueryNode;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:  MakeLeaf
//
//  Synopsis:  Constructor of the CQueryNode
//
//  Arguments: szValue              value of the string
//             ppQueryNodeReturn    the return node
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeLeaf(
    LPWSTR szValue,
    CQueryNode **ppQueryNodeReturn
    )
{
    HRESULT hr = S_OK;

    CQueryNode *pQueryNode = new CQueryNode();
    if (!pQueryNode)
        return E_OUTOFMEMORY;

    hr = pQueryNode->SetToString(szValue);
    BAIL_ON_FAILURE(hr);

    *ppQueryNodeReturn = pQueryNode;
    RRETURN(hr);

error:
    delete pQueryNode;
    RRETURN(hr);
}


HRESULT
AdsNdsGenerateFilterBuffer(
    NDS_CONTEXT_HANDLE hADsContext,
    LPWSTR szSearchFilter,
    NDS_BUFFER_HANDLE *phFilterBuf
)
{
    NWDSContextHandle   context;

    HRESULT hr = E_ADS_INVALID_FILTER;
    NWDSCCODE ccode;        
    BOOL fBufAllocated = FALSE;
    DWORD i, j;
    pFilter_Cursor_T  pCur;
    NDS_BUFFER_HANDLE hFilterBuf = NULL;


    PNDS_CONTEXT pADsContext = (PNDS_CONTEXT) hADsContext;
    PNDS_BUFFER_DATA pFilterBuf = (PNDS_BUFFER_DATA) hFilterBuf;
    nuint16 luFilterToken;

    CQueryNode *pNode = NULL;
    CAttrList *pAttrList = NULL;

    if (!hADsContext || !phFilterBuf) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }


    // Generate the parse tree and the attribute list
    hr = Parse(
            szSearchFilter,
            &pNode,
            &pAttrList
            );
    BAIL_ON_FAILURE(hr);


    // Setup syntax information in the attribute list
    hr = pAttrList->SetupType(hADsContext);
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsCreateBuffer(
             hADsContext,
             DSV_SEARCH_FILTER,
             &hFilterBuf
             );             
    BAIL_ON_FAILURE(hr);

    fBufAllocated = TRUE;

    // Generate the parse tree and the attribute list

    ccode = NWDSAllocFilter(&pCur);
    CHECK_AND_SET_EXTENDED_ERROR(ccode, hr);
 
    // Generate the NDS tree
    hr = pNode->AddToFilterBuf(
                        pCur,
                        pAttrList
                        );
    BAIL_ON_FAILURE(hr);

    hr = ADsNdsPutFilter(
              hADsContext,
              hFilterBuf,
              pCur, 
              CQueryNode::FreeFilterTokens
              );
    BAIL_ON_FAILURE(hr);


    *phFilterBuf = hFilterBuf; 

    if (pNode)
        delete pNode;

    if (pAttrList)
        delete pAttrList;

    RRETURN(S_OK);


error:

    if (fBufAllocated) {
        ADsNdsFreeBuffer(hFilterBuf);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\qrylexer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lexer.hxx

Abstract:

    This module implements functions to recognize the tokens in the string
    repressentation of the search filter. The format of the search filter
    according to the RFC 1960.

Author:

    Shankara Shastry [ShankSh]    08-Jul-1996

++*/

#include "nds.hxx"
#pragma hdrstop

DFA_STATE  CQryLexer::_pStateTable[MAX_STATES][MAX_CHAR_CLASSES] = gStateTable;

DWORD CQryLexer::_pCharClassTable[] = gCharClassTable;

//+---------------------------------------------------------------------------
// Function: CQryLexer
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments: szBuffer: pattern
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CQryLexer::CQryLexer(
    LPWSTR szBuffer
    ):
    _ptr(NULL),
    _Buffer(NULL),
    _dwEndofString(0),
    _dwState(ATTRTYPE_START_STATE),
    _lexeme()
{
    _bInitialized = FALSE;
    if (!szBuffer || !*szBuffer) {
        return;
    }
        
    _Buffer = (LPWSTR) AllocADsMem(
                            (wcslen(szBuffer)+1) * sizeof(WCHAR)
                            );
    
    if(_Buffer)
    wcscpy(_Buffer,
           szBuffer
           );
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function: GetNextToken
//
// Synopsis: Give the next valid token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CQryLexer::GetNextToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
    WCHAR wcNextChar;
    DWORD dwActionId;
    DFA_STATE dfaState;
    DWORD dwStartState = _dwState;
    // If there is no pattern
    if(!_ptr) {
        *pdwToken = TOKEN_ENDINPUT;
        RRETURN (S_OK);
    }

    // Start forming the lexeme.

    _lexeme.ResetLexeme();

    *ppszToken = NULL;
    *pdwToken = TOKEN_ERROR;

    while (_dwState != ERROR_STATE && _dwState < FINAL_STATES_BEGIN) {
        // Get the character class from the character and then index the
        // state table
        wcNextChar = NextChar();
        DWORD now = GetCharClass(wcNextChar);
        dwActionId = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwActionId;

        _dwState = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwNextState;

        if(_dwState == ERROR_STATE) {
            BAIL_ON_FAILURE (E_FAIL);
        }

        PerformAction(_dwState,
                      wcNextChar,
                      dwActionId
                      );
    }

    _bInitialized = TRUE;

    if(*pdwToken == TOKEN_ENDINPUT)
        RRETURN (S_OK);

    *ppszToken = _lexeme.GetLexeme();
    *pdwToken = GetTokenFromState(_dwState);

    _dwStateSave = _dwState;
    // This is to set the start state for the next token to be recognized
    if(*pdwToken == TOKEN_ATTRTYPE) {
        _dwState = ATTRVAL_START_STATE;
    }
    else if (*pdwToken == TOKEN_ATTRVAL) {
        _dwState = ATTRTYPE_START_STATE;
    }
    else if (*pdwToken == TOKEN_PRESENT) {
            _dwState = ATTRTYPE_START_STATE;
    } else {
        _dwState = dwStartState;
    }


    RRETURN (S_OK);

error:
    RRETURN (E_FAIL);
}

//+---------------------------------------------------------------------------
// Function: GetCurrentToken
//
// Synopsis: Give the current valid token, and do not advance unless
//           it is the first token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CQryLexer::GetCurrentToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
    if (!_bInitialized) {
        HRESULT hr;
        hr = GetNextToken(
                    ppszToken,
                    pdwToken
                    );
        return hr;
    } else {
        *ppszToken = _lexeme.GetLexeme();
        *pdwToken = GetTokenFromState(_dwStateSave);
        return (S_OK);
    }
}

//+---------------------------------------------------------------------------
// Function: NextChar
//
// Synopsis: Returns the next chaarcter in the pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
WCHAR
CQryLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function: PushbackChar
//
// Synopsis: Puts back a character to the unrecognised pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
void
CQryLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

HRESULT
CQryLexer::PerformAction(
            DWORD dwCurrState,
            WCHAR wcCurrChar,
            DWORD dwActionId
            )
{
   switch(dwActionId) {
       case ACTION_PUSHBACK_CHAR:
           PushbackChar();
           break;
       case ACTION_PUSHBACK_2CHAR:
           PushbackChar();
           PushbackChar();
           _lexeme.PushBackChar();
           break;
       case ACTION_IGNORE_ESCAPECHAR:
           break;
       case ACTION_DEFAULT:
           _lexeme.PushNextChar(wcCurrChar);
           break;
   }

   if(_dwState >= FINAL_STATES_BEGIN)
       _lexeme.PushNextChar(L'\0');

   RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
// Function: CQryLexer::GetTokenFromState
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
inline DWORD
CQryLexer::GetTokenFromState(
            DWORD dwCurrState
            )
{
    return (dwCurrState - FINAL_STATES_BEGIN);
}


//+---------------------------------------------------------------------------
// Function: ~CQryLexer
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CQryLexer::~CQryLexer()
{
    if( _Buffer )
        FreeADsMem (_Buffer);

}

//+---------------------------------------------------------------------------
// Function: CLexeme
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexeme::CLexeme(
    ):
        _dwMaxLength(0),
        _dwIndex(0)
{
    _pszLexeme = (LPWSTR) AllocADsMem(LEXEME_UNIT_LENGTH * sizeof(WCHAR));
    if(_pszLexeme)
        _dwMaxLength = LEXEME_UNIT_LENGTH;
}

//+---------------------------------------------------------------------------
// Function: ~CLexeme
//
// Synopsis: Destructor
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

inline CLexeme::~CLexeme(
    )
{
    if(_pszLexeme)
        FreeADsMem(_pszLexeme);
}

//+---------------------------------------------------------------------------
// Function: PushNextChar
//
// Synopsis: Add the next character after making sure there is enough memory
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexeme::PushNextChar(
    WCHAR wcNextChar
    )
{
    if(_dwIndex >= _dwMaxLength)
    {
        _pszLexeme = (LPWSTR) ReallocADsMem(
                                    _pszLexeme,
                                    _dwMaxLength * sizeof(WCHAR),
                                    (_dwMaxLength + LEXEME_UNIT_LENGTH) * sizeof(WCHAR)
                                    );
        BAIL_ON_NULL(_pszLexeme);

        _dwMaxLength += LEXEME_UNIT_LENGTH;
    }

    _pszLexeme[_dwIndex++] = wcNextChar;


    RRETURN (S_OK);

error:
    RRETURN (E_FAIL);

}

HRESULT
CLexeme::PushBackChar()
{
    _pszLexeme[--_dwIndex] = '\0';
    RRETURN (S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:  RemoveWhiteSpaces
//
//  Synopsis:  Removes the leading and trailing white spaces
//
//  Arguments: pszText                  Text strings from which the leading
//                                      and trailing white spaces are to be
//                                      removed
//
//  Returns:    LPWSTR                  Pointer to the modified string
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
LPWSTR
RemoveWhiteSpaces(
    LPWSTR pszText)
{
    LPWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!iswspace(*pChar))
            break;
        else
            *pChar = L'\0';
    }

    return pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\ods2nds.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "nds.hxx"

HRESULT
AdsTypeToNdsTypeCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_1;

    lpNdsDestObject->NdsValue.value_1.DNString =
                        AllocADsStr(
                            lpAdsSrcValue->DNString
                        );
    if (!lpNdsDestObject->NdsValue.value_1.DNString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_2;

    lpNdsDestObject->NdsValue.value_2.CaseExactString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseExactString
                        );
    if (!lpNdsDestObject->NdsValue.value_2.CaseExactString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyCaseIgnoreList( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    PADS_PROV_SPECIFIC test;
    PADS_CASEIGNORE_LIST pAdsNext = lpAdsSrcValue->pCaseIgnoreList;
    struct _NDS_CI_LIST *pNdsOutput = &lpNdsDestObject->NdsValue.value_6;
    struct _NDS_CI_LIST *pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (pAdsNext == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_6;

    pNdsOutput->String = AllocADsStr(pAdsNext->String);
    if (!pNdsOutput->String ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        pNdsCurrent = (struct _NDS_CI_LIST *)AllocADsMem(sizeof(struct _NDS_CI_LIST));
        if (!pNdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pNdsCurrent->String = AllocADsStr(pAdsNext->String);
        if (!pNdsCurrent->String ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsOutput->Next;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyOctetList( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    PADS_OCTET_LIST pAdsNext = lpAdsSrcValue->pOctetList;
    struct _NDS_OCTET_LIST *pNdsOutput = &lpNdsDestObject->NdsValue.value_13;
    struct _NDS_OCTET_LIST *pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (pAdsNext == NULL) {
        hr = E_FAIL;
        RRETURN(hr);
    }


    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_13;

    pNdsOutput->Next = NULL;
    pNdsOutput->Data = NULL;

    hr = CopyOctetString(pAdsNext->Length,
                         pAdsNext->Data,
                         &pNdsOutput->Length,
                         &pNdsOutput->Data);
    BAIL_ON_FAILURE(hr);
    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        pNdsCurrent = (struct _NDS_OCTET_LIST *)AllocADsMem(sizeof(struct _NDS_CI_LIST));
        if (!pNdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        pNdsCurrent->Next = NULL;
        pNdsCurrent->Data = NULL;

        hr = CopyOctetString(pAdsNext->Length,
                             pAdsNext->Data,
                             &pNdsCurrent->Length,
                             &pNdsCurrent->Data);
        if (FAILED(hr)) {
            FreeADsMem(pNdsCurrent);
            BAIL_ON_FAILURE(hr);
        }
        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsCurrent;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;
    RRETURN(hr);

error:
    if (lpNdsDestObject->NdsValue.value_13.Data) {
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);
    }

    pNdsOutput = lpNdsDestObject->NdsValue.value_13.Next;

    while (pNdsOutput) {
        if (pNdsOutput->Data) {
            FreeADsMem(pNdsOutput->Data);
        }

        pNdsCurrent = pNdsOutput->Next;
        FreeADsMem(pNdsOutput);
        pNdsOutput = pNdsCurrent;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyPath( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pPath == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_15;

    lpNdsDestObject->NdsValue.value_15.VolumeName =
                        AllocADsStr(
                            lpAdsSrcValue->pPath->VolumeName
                        );
    if (!lpNdsDestObject->NdsValue.value_15.VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_15.Path=
                        AllocADsStr(
                            lpAdsSrcValue->pPath->Path
                        );
    if (!lpNdsDestObject->NdsValue.value_15.Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_15.Type =
                            lpAdsSrcValue->pPath->Type;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyPostalAddress( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pPostalAddress == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_18;

    for (i=0;i<6;i++) {
        if (lpAdsSrcValue->pPostalAddress->PostalAddress[i]) {
            lpNdsDestObject->NdsValue.value_18.PostalAddress[i] =
                                AllocADsStr(
                                    lpAdsSrcValue->pPostalAddress->PostalAddress[i]
                                );
            if (!lpNdsDestObject->NdsValue.value_18.PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        else {
            lpNdsDestObject->NdsValue.value_18.PostalAddress[i] =
                                AllocADsStr(
                                    L""
                                );
        }
    }
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyNdsTime( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_19;

    lpNdsDestObject->NdsValue.value_19.WholeSeconds =
                            lpAdsSrcValue->Timestamp.WholeSeconds;

    lpNdsDestObject->NdsValue.value_19.EventID =
                            lpAdsSrcValue->Timestamp.EventID;

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyBackLink( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_23;

    lpNdsDestObject->NdsValue.value_23.ObjectName =
                        AllocADsStr(
                            lpAdsSrcValue->BackLink.ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_23.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_23.RemoteID =
                            lpAdsSrcValue->BackLink.RemoteID;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyTypedName( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pTypedName == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_25;

    lpNdsDestObject->NdsValue.value_25.ObjectName=
                        AllocADsStr(
                            lpAdsSrcValue->pTypedName->ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_25.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_25.Level=
                            lpAdsSrcValue->pTypedName->Level;

    lpNdsDestObject->NdsValue.value_25.Interval=
                            lpAdsSrcValue->pTypedName->Interval;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyHold( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_26;

    lpNdsDestObject->NdsValue.value_26.ObjectName=
                        AllocADsStr(
                            lpAdsSrcValue->Hold.ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_26.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_26.Amount=
                            lpAdsSrcValue->Hold.Amount;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyEmail( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_14;

    lpNdsDestObject->NdsValue.value_14.Address=
                        AllocADsStr(
                            lpAdsSrcValue->Email.Address
                        );
    if (!lpNdsDestObject->NdsValue.value_14.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    lpNdsDestObject->NdsValue.value_14.Type=
                            lpAdsSrcValue->Email.Type;
error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyNetAddress( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pNetAddress == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_12;

    lpNdsDestObject->NdsValue.value_12.AddressType =
                            lpAdsSrcValue->pNetAddress->AddressType;

    hr = CopyOctetString(lpAdsSrcValue->pNetAddress->AddressLength,
                         lpAdsSrcValue->pNetAddress->Address,
                         &lpNdsDestObject->NdsValue.value_12.AddressLength,
                         &lpNdsDestObject->NdsValue.value_12.Address);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyFaxNumber( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pFaxNumber == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_11;

    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                            AllocADsStr(lpAdsSrcValue->pFaxNumber->TelephoneNumber);
    if (!lpNdsDestObject->NdsValue.value_11.TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = CopyOctetString(lpAdsSrcValue->pFaxNumber->NumberOfBits,
                         lpAdsSrcValue->pFaxNumber->Parameters,
                         &lpNdsDestObject->NdsValue.value_11.NumberOfBits,
                         &lpNdsDestObject->NdsValue.value_11.Parameters);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyReplicaPointer( 
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pReplicaPointer == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_16;

    lpNdsDestObject->NdsValue.value_16.ServerName=
                        AllocADsStr(
                            lpAdsSrcValue->pReplicaPointer->ServerName
                        );
    if (!lpNdsDestObject->NdsValue.value_16.ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaType =
                            lpAdsSrcValue->pReplicaPointer->ReplicaType;
    lpNdsDestObject->NdsValue.value_16.ReplicaNumber =
                            lpAdsSrcValue->pReplicaPointer->ReplicaNumber;
    lpNdsDestObject->NdsValue.value_16.Count =
                            lpAdsSrcValue->pReplicaPointer->Count;

    lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints =
                        (LPNDS_ASN1_TYPE_12)AllocADsMem(sizeof(NDS_ASN1_TYPE_12 ));
    if (!lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints->AddressType =
                            lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressType;

    hr = CopyOctetString(lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressLength,
                         lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->Address,
                         &lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints->AddressLength,
                         &lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints->Address);

error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = ADSTYPE_CASE_IGNORE_STRING;

    lpNdsDestObject->NdsValue.value_3.CaseIgnoreString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );
    if (!lpNdsDestObject->NdsValue.value_3.CaseIgnoreString) {
        hr = E_OUTOFMEMORY;
    }
    RRETURN(hr);

}


HRESULT
AdsTypeToNdsTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_4;

    lpNdsDestObject->NdsValue.value_4.PrintableString =
                        AllocADsStr(
                            lpAdsSrcValue->PrintableString
                        );
    if (!lpNdsDestObject->NdsValue.value_4.PrintableString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_5;

    lpNdsDestObject->NdsValue.value_5.NumericString =
                        AllocADsStr(
                                lpAdsSrcValue->NumericString
                        );
    if (!lpNdsDestObject->NdsValue.value_5.NumericString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}



HRESULT
AdsTypeToNdsTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_7;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_8;

    lpNdsDestObject->NdsValue.value_8.Integer =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_9;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
    if (!lpByteStream) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpNdsDestObject->NdsValue.value_9.Length = dwNumBytes;
    lpNdsDestObject->NdsValue.value_9.OctetString =  lpByteStream;
error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyTime(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_24;

    hr = ConvertSYSTEMTIMEtoDWORD(
                &(lpAdsSrcValue->UTCTime),
                &(lpNdsDestObject->NdsValue.value_24.Time)
                );

    RRETURN(hr);

}


HRESULT                                              
AdsTypeToNdsTypeCopyObjectClass(                        
    PADSVALUE lpAdsSrcValue,                         
    PNDSOBJECT lpNdsDestObject                       
    )                                                
{                                                    
    HRESULT hr = S_OK;                               
                                                     
    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){  
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);   
    }                                                
                                                     
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_20;      
                                                     
    lpNdsDestObject->NdsValue.value_20.ClassName =     
                        AllocADsStr(                 
                            lpAdsSrcValue->ClassName  
                        );                           
    if (!lpNdsDestObject->NdsValue.value_20.ClassName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);                                     
}                                                    


HRESULT
AdsTypeToNdsTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        hr = AdsTypeToNdsTypeCopyDNString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        hr = AdsTypeToNdsTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToNdsTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        hr = AdsTypeToNdsTypeCopyPrintableString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        hr = AdsTypeToNdsTypeCopyNumericString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToNdsTypeCopyBoolean(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToNdsTypeCopyInteger(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_OCTET_STRING:
        hr = AdsTypeToNdsTypeCopyOctetString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_UTC_TIME:
        hr = AdsTypeToNdsTypeCopyTime(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_OBJECT_CLASS:                
        hr = AdsTypeToNdsTypeCopyObjectClass( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  
                                                
    case ADSTYPE_CASEIGNORE_LIST:
        hr = AdsTypeToNdsTypeCopyCaseIgnoreList( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    case ADSTYPE_FAXNUMBER:
        hr = AdsTypeToNdsTypeCopyFaxNumber( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    case ADSTYPE_NETADDRESS:
        hr = AdsTypeToNdsTypeCopyNetAddress( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    case ADSTYPE_OCTET_LIST:
        hr = AdsTypeToNdsTypeCopyOctetList( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    case ADSTYPE_EMAIL:
        hr = AdsTypeToNdsTypeCopyEmail( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    case ADSTYPE_PATH:
        hr = AdsTypeToNdsTypeCopyPath( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    case ADSTYPE_REPLICAPOINTER:
        hr = AdsTypeToNdsTypeCopyReplicaPointer( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  


    case ADSTYPE_TIMESTAMP:
        hr = AdsTypeToNdsTypeCopyNdsTime( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;               

    case ADSTYPE_POSTALADDRESS:
        hr = AdsTypeToNdsTypeCopyPostalAddress( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  
                   
    case ADSTYPE_BACKLINK:
        hr = AdsTypeToNdsTypeCopyBackLink( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    case ADSTYPE_TYPEDNAME:
        hr = AdsTypeToNdsTypeCopyTypedName( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    case ADSTYPE_HOLD:
        hr = AdsTypeToNdsTypeCopyHold( 
                lpAdsSrcValue,                  
                lpNdsDestObject                 
                );                              
        break;                                  

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToNdsTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects,
    PDWORD pdwNumNdsObjects,
    PDWORD pdwNdsSyntaxId
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;

    if (dwNumObjects == 0) {
        *ppNdsDestObjects = NULL;
        *pdwNumNdsObjects = 0;
        RRETURN(S_OK);
    }


    pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

    if (!pNdsDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = AdsTypeToNdsTypeCopy(
                    pAdsSrcValues + i,
                    pNdsDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppNdsDestObjects = pNdsDestObjects;
     *pdwNumNdsObjects = dwNumObjects;
     *pdwNdsSyntaxId = pNdsDestObjects->NdsType;
     RRETURN(S_OK);

error:

     if (pNdsDestObjects) {

        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumObjects
                );
     }

     *ppNdsDestObjects = NULL;
     *pdwNumNdsObjects = 0;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\odssz.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "nds.hxx"



DWORD
AdsTypeDNStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR);

    return(dwSize);
}

DWORD
AdsTypeCaseExactStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->CaseExactString) + 1) *sizeof(WCHAR);


    return(dwSize);
}


DWORD
AdsTypeCaseIgnoreStringSize(
    PADSVALUE lpAdsSrcValue
    )

{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1) *sizeof(WCHAR);


    return(dwSize);
}


DWORD
AdsTypePrintableStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->PrintableString) + 1) *sizeof(WCHAR);


    return(dwSize);
}

DWORD
AdsTypeNumericStringSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->NumericString) + 1)* sizeof(WCHAR);


    return(dwSize);
}



DWORD
AdsTypeBooleanSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(0);
    }

    return(0);
}


DWORD
AdsTypeIntegerSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeOctetStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(0);
    }

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;


    return(dwNumBytes);
}


DWORD
AdsTypeTimeSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeObjectClassSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->ClassName) + 1)*sizeof(WCHAR);

    return(dwSize);
}

DWORD
AdsTypeSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        dwSize = AdsTypeDNStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        dwSize = AdsTypeCaseExactStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        dwSize = AdsTypeCaseIgnoreStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        dwSize = AdsTypePrintableStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        dwSize = AdsTypeNumericStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_BOOLEAN:
        dwSize = AdsTypeBooleanSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_INTEGER:
        dwSize = AdsTypeIntegerSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_OCTET_STRING:
        dwSize = AdsTypeOctetStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_UTC_TIME:
        dwSize = AdsTypeTimeSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_OBJECT_CLASS:
        dwSize = AdsTypeObjectClassSize(
                lpAdsSrcValue
                );
        break;
    
    default:
        break;
    }

    return(dwSize);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\var2sec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
ConvertSecDesToNDSAclVarArray(
    IADsSecurityDescriptor *pSecDes,
    PVARIANT pvarNDSAcl
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        hr = E_FAIL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);

    hr = ConvertAccessControlListToNDSAclVarArray(
                pDiscAcl,
                pvarNDSAcl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertAccessControlListToNDSAclVarArray(
    IADsAccessControlList FAR * pAccessList,
    PVARIANT pvarNDSAcl
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    VARIANT varAce;
    DWORD dwAceCount = 0;
    DWORD cReturned = 0;
    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;
    VARIANT varNDSAce;

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    
    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);


    VariantInit(pvarNDSAcl);
    aBound.lLbound = 0;
    aBound.cElements = dwAceCount;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);


        hr = ConvertAccessControlEntryToAceVariant(
                    pAccessControlEntry,
                    &varNDSAce
                    );
        CONTINUE_ON_FAILURE(hr);


        //
        // Add the NDSAce into your Safe Array
        //
        hr = SafeArrayPutElement( aList, (long*)&i, &varNDSAce );


        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }
        //dwCount++;
    }

    //
    // Return the Safe Array back to the caller
    //
    V_VT(pvarNDSAcl) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNDSAcl) = aList;

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }


    RRETURN(hr);
}

HRESULT
ConvertAccessControlEntryToAceVariant(
    IADsAccessControlEntry * pAccessControlEntry,
    PVARIANT pvarNDSAce
    )
{
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    BSTR bstrObjectTypeClsid = NULL;
    IADsAcl * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    DWORD dwAccessMask;

    VariantInit(pvarNDSAce);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNDSAce) = VT_DISPATCH;
    V_DISPATCH(pvarNDSAce) = pDispatch;

error:
    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\odsmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "nds.hxx"


LPBYTE
AdsTypeCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    lpAdsDestValue->DNString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->DNString);

    dwLength = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    lpAdsDestValue->CaseExactString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseExactString);

    dwLength = (wcslen(lpAdsSrcValue->CaseExactString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )

{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->CaseIgnoreString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseIgnoreString);

    dwLength = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    lpAdsDestValue->PrintableString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->PrintableString);

    dwLength = (wcslen(lpAdsSrcValue->PrintableString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    lpAdsDestValue->NumericString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->NumericString);

    dwLength = (wcslen(lpAdsSrcValue->NumericString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}



LPBYTE
AdsTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpAdsSrcValue->Boolean;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                                lpAdsSrcValue->Integer;


    return(lpBuffer);
}

LPBYTE
AdsTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyTime(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    lpAdsDestValue->UTCTime =
                        lpAdsSrcValue->UTCTime;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyObjectClass(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OBJECT_CLASS;

    lpAdsDestValue->ClassName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->ClassName);

    dwLength = (wcslen(lpAdsSrcValue->ClassName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        lpBuffer = AdsTypeCopyDNString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        lpBuffer = AdsTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        lpBuffer = AdsTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        lpBuffer = AdsTypeCopyPrintableString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        lpBuffer = AdsTypeCopyNumericString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_BOOLEAN:
        lpBuffer = AdsTypeCopyBoolean(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_INTEGER:
        lpBuffer = AdsTypeCopyInteger(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_OCTET_STRING:
        lpBuffer = AdsTypeCopyOctetString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_UTC_TIME:
        lpBuffer = AdsTypeCopyTime(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_OBJECT_CLASS:
        lpBuffer = AdsTypeCopyObjectClass(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    default:

        break;
    }

    return(lpBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  parse.cxx
//
//  Contents:  NDS Pathname Parser

    The Pathname Parser is a key component in ADs providers. It checks for
    syntactic validity of an ADs pathname that has been passed to this
    provider. If the syntax is valid, then an OBJECTINFO structure is
    constructed. This OBJECTINFO structure contains a componentized version
    of the ADs pathname for this object.

    Note all that is being done is a syntax check. Rather than special-case
    every single new nuance to pathnames, all path checking must conform to
    the grammar rules laid out by the parser.


//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <NDSObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {

    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = NDSObject(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }
    }

cleanup:
    RRETURN(hr);

}



//+---------------------------------------------------------------------------
//  Function:   NDSObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <NDSObject> -> "\\""identifier""\" <PathName>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
NDSObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    WCHAR szDisplayToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddTreeName(pObjectInfo, szToken, szDisplayToken );
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    //
    // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
    //

    if (dwToken == TOKEN_END || dwToken == TOKEN_COMMA) {
        hr = pTokenizer->PushBackToken();
        RRETURN(S_OK);
    }

    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component
HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);

    if ((dwToken == TOKEN_FSLASH) ) {
        RRETURN (PathName(pTokenizer, pObjectInfo));
    }else {
        hr = pTokenizer->PushBackToken();
        RRETURN (S_OK);
    }
cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szValue[MAX_TOKEN_LENGTH];
    WCHAR szDisplayValue[MAX_TOKEN_LENGTH];
    WCHAR szEqual[MAX_TOKEN_LENGTH];
    WCHAR szComponent[MAX_TOKEN_LENGTH];
    WCHAR szDisplayComponent[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szComponent, szDisplayComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = pTokenizer->GetNextToken(szEqual, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_EQUAL) {

        hr = pTokenizer->GetNextToken(szValue, szDisplayValue, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddComponent(
                 pObjectInfo,
                 szComponent,
                 szValue,
                 szDisplayComponent,
                 szDisplayValue
                 );
        BAIL_IF_ERROR(hr);

    }else {
        hr = AddComponent(pObjectInfo, szComponent, NULL, szDisplayComponent, NULL);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->PushBackToken();
        BAIL_IF_ERROR(hr);
    }

    RRETURN(S_OK);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPWSTR szDisplayToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;
    LPWSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);

    if (szDisplayToken) {
        memset(szDisplayToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    }

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            if (c == TEXT('"')) {
                //
                // Quoting;
                //

                fQuotingOn = TRUE;

                pch--;
                state = 1;

            }else if (c == TEXT('\\')) {
                //
                // Escaping; Ignore the '\' in the token and check to make
                // sure that the next character exists
                //
                pch--;

                fEscapeOn = TRUE;

                state = 1;

            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'='){
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            /*
            }else if (c == L'.'){
                *pdwToken = TOKEN_PERIOD;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            */
            }else if (c == L':'){
                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
            }else if (c == TEXT('<')) {
                RRETURN(E_FAIL);
            }else if (c == TEXT('>')) {
                RRETURN(E_FAIL);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }
            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_FAIL);
            }
            else if (fEscapeOn) {
                //
                // If escape is on, we check the next character, if it is indeed
                // an ADSI special character, we'll ignore the escaping, if not,
                // we'll put back the escaped character
                //
                if (c != '/') {
                    *pch++ = '\\';
                }
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                }
                else {
                    *pch++ = c;
                }
                _dwLastTokenLength++;
                break;
            }
            else if (c == TEXT('\\') ) {
                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                break;

            }
            else if (c == TEXT('"')) {
                fQuotingOn = TRUE;
                _dwLastTokenLength++;
                break;
            }
            else if (c == L'\0' || c == L',' ||
                    c == L'=' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);

            }else if (c == L'@' || c == L'!' || c == L':' ) {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }

            }else {
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }

        default:
            RRETURN(E_FAIL);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}

HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(
    POBJECTINFO pObjectInfo,
    LPWSTR szComponent,
    LPWSTR szValue,
    LPWSTR szDisplayComponent,
    LPWSTR szDisplayValue
    )
{
    if (!szComponent || !*szComponent || !szDisplayComponent || !*szDisplayComponent) {
        RRETURN(E_FAIL);
    }

    if (pObjectInfo->NumComponents < MAXCOMPONENTS) {

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                        AllocADsStr(szComponent);

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                        AllocADsStr(szValue);

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szComponent =
                    AllocADsStr(szDisplayComponent);

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szValue =
                    AllocADsStr(szDisplayValue);

        pObjectInfo->NumComponents++;

        RRETURN(S_OK);

    }else {
        RRETURN(E_FAIL);
    }
}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPWSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken || !szDisplayToken || !*szDisplayToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = AllocADsStr(szToken);
    pObjectInfo->DisplayTreeName = AllocADsStr(szDisplayToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


// Type -> "user", "group","printer","service", "fileservice"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            pObjectInfo->ClassName = AllocADsStr(szToken);
        }
        RRETURN(hr);
    }

    RRETURN(E_FAIL);

cleanup:
    RRETURN(hr);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\encrypt.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    encrypt.h

Abstract:

    Contains API to encrypt password.

Author:

    Yi-Hsin Sung (yihsins)  30-Aug-1994

Revision History:

--*/

#ifndef _ENCRYPT_H_
#define _ENCRYPT_H_

VOID
EncryptChangePassword(
    IN  PUCHAR pOldPassword,
    IN  PUCHAR pNewPassword,
    IN  ULONG  ObjectId,
    IN  PUCHAR pKey,
    OUT PUCHAR pValidationKey,
    OUT PUCHAR pEncryptNewPassword
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\sconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  sconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)AllocADsMem( StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    //
    // Null terminate 
    //
    pAnsi[StringLength-1] = 0;

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)AllocADsMem(
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}


LPSTR
AllocateAnsiString(
    LPWSTR  pUnicodeString
    )
{
    LPSTR  pAnsiString = NULL;

    if (!pUnicodeString)
        return NULL;

    pAnsiString = (LPSTR) AllocADsMem(
                        wcslen(pUnicodeString)*sizeof(CHAR) +sizeof(CHAR)
                        );

    if (pAnsiString) {

        UnicodeToAnsiString(
            pUnicodeString,
            pAnsiString,
            NULL_TERMINATED
            );
    }

    return pAnsiString;
}


void
FreeAnsiString(
    LPSTR  pAnsiString
    )
{
    if (!pAnsiString)
        return;

    LocalFree(pAnsiString);

    return;
}


LPSTR*
AllocateAnsiStringArray(
    LPWSTR  *ppUnicodeStrings,
    DWORD   dwNumElements
    )
{
    LPSTR  *ppAnsiStrings = NULL;
    DWORD i, j;

    if (ppUnicodeStrings && dwNumElements) {
        ppAnsiStrings = (LPSTR *) AllocADsMem(sizeof(LPSTR) * dwNumElements);

        if (!ppAnsiStrings) {
            goto error;
        }

        for (i=0; i < dwNumElements; i++) {

            ppAnsiStrings[i] = AllocateAnsiString(ppUnicodeStrings[i]);

            if (!ppAnsiStrings[i]) {

                for (j=0; j<i; j++)
                    FreeADsMem(ppAnsiStrings[j]);

                FreeADsMem(ppAnsiStrings);

                goto error;

            }
        }
    }

    return ppAnsiStrings;

error: 

    return NULL;

}

void
FreeAnsiStringArray(
    LPSTR  *ppAnsiStrings,
    DWORD   dwNumElements
    )
{
    DWORD i;

    if (!ppAnsiStrings) {
        return;
    }

    for (i=0; i < dwNumElements; i++) {
        FreeADsMem(ppAnsiStrings[i]);
    }

    FreeADsMem(ppAnsiStrings);
}




DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //

    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\sec2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
ConvertNDSAclVArrayToSecDesVar(
    PVARIANT pVarArrayNDSAcl,
    PVARIANT pVarSecDes
    )
{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT varDACL;    

    VariantInit(pVarSecDes);
    memset(&varDACL, 0, sizeof(VARIANT));

    hr = ConvertNDSAclVArrayToAclVariant(
                                    pVarArrayNDSAcl,
                                    &varDACL
                                    );
    BAIL_ON_FAILURE(hr);

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    V_VT(pVarSecDes) = VT_DISPATCH;
    V_DISPATCH(pVarSecDes) =  pDispatch;

error:

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}




HRESULT
ConvertNDSAclVArrayToAclVariant(
    PVARIANT pVarArrayNDSACL,
    PVARIANT pVarACL
    )
{
    IADsAccessControlList *pAccessControlList = NULL;
    IDispatch *pDispatch = NULL;
    VARIANT *pVarArray = NULL;
    VARIANT varAce;
    DWORD i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumValues;
    DWORD dwNewAceCount = 0;

    VariantInit(pVarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    hr  = ConvertSafeArrayToVariantArray(
                *pVarArrayNDSACL,
                &pVarArray,
                &dwNumValues
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwNumValues; i++) {
        hr = ConvertNDSAclVariantToAceVariant(
                    &(pVarArray[i]),
                    (PVARIANT)&varAce
                    );

        hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));
        if (SUCCEEDED(hr)) {
           dwNewAceCount++;
        }

        VariantClear(&varAce);
    }

    pAccessControlList->put_AceCount(dwNewAceCount);

    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pVarACL) = VT_DISPATCH;
    V_DISPATCH(pVarACL) = pDispatch;

error:

    if (pAccessControlList) {
        pAccessControlList->Release();
    }

    if (pVarArray)
    {
        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}



HRESULT
ConvertNDSAclVariantToAceVariant(
    PVARIANT pvarNDSAce,
    PVARIANT pvarAce
    )
{
    HRESULT hr = S_OK;
    IADsAccessControlEntry *pAccessControlEntry = NULL;
    IDispatch *pDispatch = NULL;
    IADsAcl *pSecDes = NULL;
    DWORD  dwPrivileges = 0;
    BSTR bstrProtectedAttrName = NULL;
    BSTR bstrSubjectName = NULL;

    if (V_VT(pvarNDSAce) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pvarNDSAce);

    hr = pDispatch->QueryInterface(
                    IID_IADsAcl,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_ProtectedAttrName(
                    &bstrProtectedAttrName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_SubjectName(
                    &bstrSubjectName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_Privileges(
                    (LONG *)&dwPrivileges);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_AccessMask(dwPrivileges);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_Trustee(bstrSubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_ObjectType(bstrProtectedAttrName);
    BAIL_ON_FAILURE(hr);


    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pSecDes) {
        pSecDes->Release();
    }

    if (pAccessControlEntry) {
        pAccessControlEntry->Release();
    }

    RRETURN(hr);


error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pSecDes) {
        pSecDes->Release();
    }

    if (pAccessControlEntry) {
        pAccessControlEntry->Release();
    }
  
    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\encrypt.c ===
/*++

Copyright (c) 1994  Micro Computer Systems, Inc.

Module Name:

    nwlibs\encrypt.c

Abstract:

    This module implements the routines for the NetWare
    redirector to mangle an objectid, challenge key and
    password such that a NetWare server will accept the
    password as valid.

    This program uses information published in Byte Magazine.

Author:

    Shawn Walker (v-swalk) 10-10-1994

Revision History:

    11-9-1994 Copied from nwslib for login and minimars for
                change password.
    09-7-1995 (AndyHe) Put in proper setpass compatible processing

--*/
#include "dswarn.h"
#include <windef.h>
#include "encrypt.h"
#include <oledsdbg.h>

#define STATIC
#define STRLEN strlen
#define STRUPR _strupr

#define NUM_NYBBLES             34

STATIC
VOID
RespondToChallengePart1(
    IN     PUCHAR pObjectId,
    IN     PUCHAR pPassword,
       OUT PUCHAR pResponse
    );

STATIC
VOID
RespondToChallengePart2(
    IN     PUCHAR pResponsePart1,
    IN     PUCHAR pChallenge,
       OUT PUCHAR pResponse
    );

STATIC
VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer,
    UCHAR ChangePassword
    );

STATIC
int
Scramble(
    int   iSeed,
    UCHAR achBuffer[32]
    );

STATIC
VOID
ExpandBytes(
    IN  PUCHAR InArray,
    OUT PUCHAR OutArray
    );

STATIC
VOID
CompressBytes(
    IN  PUCHAR InArray,
    OUT PUCHAR OutArray
    );

VOID
CalculateWireFromOldAndNewPasswords(
    UCHAR *Vold,
    UCHAR *Vnew,
    UCHAR *Vc
    );



/*++
*******************************************************************

        EncryptLoginPassword

Routine Description:

        Encrypts the password for login.

Arguments:

        pPassword = The pointer to a plain text null terminated password.
        ObjectId = The object id of the user to encrypt the password.
        pLogKey = The pointer to key to use to encrpyt the password.
        pEncryptedPassword = The pointer to return a 8 byte encrypted
                                password.

Return Value:

        None.

*******************************************************************
--*/
void
EncryptLoginPassword(
    unsigned char *pPassword,
    unsigned long  ObjectId,
    unsigned char *pLogKey,
    unsigned char *pEncryptedPassword
    )
{
    INT   Index;
    UCHAR achK[32];
    UCHAR achBuf[32];

    ADsAssert(pPassword);

    /** The password must be upper case **/

    pPassword = STRUPR(pPassword);

    /** Encrypt the password **/

    Shuffle((UCHAR *) &ObjectId, pPassword, STRLEN(pPassword), achBuf, FALSE);
    Shuffle((UCHAR *) &pLogKey[0], achBuf, 16, &achK[0], FALSE);
    Shuffle((UCHAR *) &pLogKey[4], achBuf, 16, &achK[16], FALSE);

    for (Index = 0; Index < 16; Index++) {
        achK[Index] ^= achK[31 - Index];
    }

    for (Index = 0; Index < 8; Index++) {
        pEncryptedPassword[Index] = achK[Index] ^ achK[15 - Index];
    }

    return;
}



/*++
*******************************************************************

        EncryptChangePassword

Routine Description:

        This function encrypts for change passwords.

Arguments:

        pOldPassword = The pointer to the old password.
        pNewPassword = The pointer to the new password.
        ObjectId = The object id to use to encrypt the password.
        pKey = The challenge key from the server.
        pValidationKey = The 8 byte validation key to return.
        pEncryptNewPassword = The 17 byte encrypted new password to
                                return.

Return Value:

        None.

*******************************************************************
--*/
VOID
EncryptChangePassword(
    IN     PUCHAR pOldPassword,
    IN     PUCHAR pNewPassword,
    IN     ULONG  ObjectId,
    IN     PUCHAR pKey,
       OUT PUCHAR pValidationKey,
       OUT PUCHAR pEncryptNewPassword
    )
{
    UCHAR Vc[17];
    UCHAR Vold[17];
    UCHAR Vnew[17];
    UCHAR ValidationKey[16];
    UCHAR VcTemp[NUM_NYBBLES];
    UCHAR VoldTemp[NUM_NYBBLES];
    UCHAR VnewTemp[NUM_NYBBLES];

    ADsAssert(pOldPassword);
    ADsAssert(pNewPassword);

    /** Uppercase the passwords **/

    pOldPassword = STRUPR(pOldPassword);
    pNewPassword = STRUPR(pNewPassword);

    //
    // The old password and object ID make up the 17-byte Vold.
    // This is used later to form the 17-byte Vc for changing
    // password on the server.
    //

    Shuffle((PUCHAR) &ObjectId, pOldPassword, STRLEN(pOldPassword), Vold, FALSE);

    //
    // Need to make an 8-byte key which includes the old password
    // The server validates this value before allowing the user to
    // set password.
    //

    RespondToChallengePart2(Vold, pKey, ValidationKey);

    //
    //  Now determine Vold using the Change PW table rather than verify pw table
    //

    Shuffle((PUCHAR) &ObjectId, pOldPassword, STRLEN(pOldPassword), Vold, TRUE);

    //
    // The new password and object ID make up the 17-byte Vnew.
    //

    RespondToChallengePart1((PUCHAR) &ObjectId, pNewPassword, Vnew);

    //
    // Expand the 17-byte Vold and Vnew arrays into 34-byte arrays
    // for easy munging.
    //
    ExpandBytes(Vold, VoldTemp);
    ExpandBytes(Vnew, VnewTemp);

    //
    //  leave first two bytes of VcTemp free... we slap in the value based
    //  on new password length in below.
    //

    CalculateWireFromOldAndNewPasswords( VoldTemp, VnewTemp, &VcTemp[2] );

    //
    // Compress 34-byte array of nibbles into 17-byte array of bytes.
    //

    CompressBytes(VcTemp, Vc);

    //
    //  Calculate the 1st byte of Vc as a function of the new password length
    //  and the old password residue.
    //

    Vc[0] = ( ( ( Vold[0] ^ Vold[1] ) & 0x7F ) | 0x40 ) ^ STRLEN(pNewPassword);

    memcpy(pValidationKey, ValidationKey, 8);
    memcpy(pEncryptNewPassword, Vc, 17);

    return;
}



/*++
*******************************************************************
        Encryption table.
*******************************************************************
--*/

//
//  This is the same as LoginTable, just in a slightly different format.
//

UCHAR ChangeTable[] = {
    0x78, 0x08, 0x64, 0xe4, 0x5c, 0x17, 0xbf, 0xa8,
    0xf8, 0xcc, 0x94, 0x1e, 0x46, 0x24, 0x0a, 0xb9,
    0x2f, 0xb1, 0xd2, 0x19, 0x5e, 0x70, 0x02, 0x66,
    0x07, 0x38, 0x29, 0x3f, 0x7f, 0xcf, 0x64, 0xa0,
    0x23, 0xab, 0xd8, 0x3a, 0x17, 0xcf, 0x18, 0x9d,
    0x91, 0x94, 0xe4, 0xc5, 0x5c, 0x8b, 0x23, 0x9e,
    0x77, 0x69, 0xef, 0xc8, 0xd1, 0xa6, 0xed, 0x07,
    0x7a, 0x01, 0xf5, 0x4b, 0x7b, 0xec, 0x95, 0xd1,
    0xbd, 0x13, 0x5d, 0xe6, 0x30, 0xbb, 0xf3, 0x64,
    0x9d, 0xa3, 0x14, 0x94, 0x83, 0xbe, 0x50, 0x52,
    0xcb, 0xd5, 0xd5, 0xd2, 0xd9, 0xac, 0xa0, 0xb3,
    0x53, 0x69, 0x51, 0xee, 0x0e, 0x82, 0xd2, 0x20,
    0x4f, 0x85, 0x96, 0x86, 0xba, 0xbf, 0x07, 0x28,
    0xc7, 0x3a, 0x14, 0x25, 0xf7, 0xac, 0xe5, 0x93,
    0xe7, 0x12, 0xe1, 0xf4, 0xa6, 0xc6, 0xf4, 0x30,
    0xc0, 0x36, 0xf8, 0x7b, 0x2d, 0xc6, 0xaa, 0x8d
};

UCHAR LoginTable[] = {
    0x7,0x8,0x0,0x8,0x6,0x4,0xE,0x4,0x5,0xC,0x1,0x7,0xB,0xF,0xA,0x8,
    0xF,0x8,0xC,0xC,0x9,0x4,0x1,0xE,0x4,0x6,0x2,0x4,0x0,0xA,0xB,0x9,
    0x2,0xF,0xB,0x1,0xD,0x2,0x1,0x9,0x5,0xE,0x7,0x0,0x0,0x2,0x6,0x6,
    0x0,0x7,0x3,0x8,0x2,0x9,0x3,0xF,0x7,0xF,0xC,0xF,0x6,0x4,0xA,0x0,
    0x2,0x3,0xA,0xB,0xD,0x8,0x3,0xA,0x1,0x7,0xC,0xF,0x1,0x8,0x9,0xD,
    0x9,0x1,0x9,0x4,0xE,0x4,0xC,0x5,0x5,0xC,0x8,0xB,0x2,0x3,0x9,0xE,
    0x7,0x7,0x6,0x9,0xE,0xF,0xC,0x8,0xD,0x1,0xA,0x6,0xE,0xD,0x0,0x7,
    0x7,0xA,0x0,0x1,0xF,0x5,0x4,0xB,0x7,0xB,0xE,0xC,0x9,0x5,0xD,0x1,
    0xB,0xD,0x1,0x3,0x5,0xD,0xE,0x6,0x3,0x0,0xB,0xB,0xF,0x3,0x6,0x4,
    0x9,0xD,0xA,0x3,0x1,0x4,0x9,0x4,0x8,0x3,0xB,0xE,0x5,0x0,0x5,0x2,
    0xC,0xB,0xD,0x5,0xD,0x5,0xD,0x2,0xD,0x9,0xA,0xC,0xA,0x0,0xB,0x3,
    0x5,0x3,0x6,0x9,0x5,0x1,0xE,0xE,0x0,0xE,0x8,0x2,0xD,0x2,0x2,0x0,
    0x4,0xF,0x8,0x5,0x9,0x6,0x8,0x6,0xB,0xA,0xB,0xF,0x0,0x7,0x2,0x8,
    0xC,0x7,0x3,0xA,0x1,0x4,0x2,0x5,0xF,0x7,0xA,0xC,0xE,0x5,0x9,0x3,
    0xE,0x7,0x1,0x2,0xE,0x1,0xF,0x4,0xA,0x6,0xC,0x6,0xF,0x4,0x3,0x0,
    0xC,0x0,0x3,0x6,0xF,0x8,0x7,0xB,0x2,0xD,0xC,0x6,0xA,0xA,0x8,0xD
};

UCHAR Keys[32] = {
    0x48,0x93,0x46,0x67,0x98,0x3D,0xE6,0x8D,
    0xB7,0x10,0x7A,0x26,0x5A,0xB9,0xB1,0x35,
    0x6B,0x0F,0xD5,0x70,0xAE,0xFB,0xAD,0x11,
    0xF4,0x47,0xDC,0xA7,0xEC,0xCF,0x50,0xC0
};

#define XorArray( DEST, SRC ) {                             \
    PULONG D = (PULONG)DEST;                                \
    PULONG S = (PULONG)SRC;                                 \
    int i;                                                  \
    for ( i = 0; i <= 7 ; i++ ) {                           \
        D[i] ^= S[i];                                       \
    }                                                       \
}

/*++
*******************************************************************

        RespondToChallengePart1

Routine Description:

        This routine takes the ObjectId and Challenge key from the server
        and encrypts the user supplied password to develop a credential
        for the server to verify.

Arguments:

        pObjectId - Supplies the 4 byte user's bindery object id
        pPassword - Supplies the user's uppercased password
        pChallenge - Supplies the 8 byte challenge key
        pResponse - Returns the 16 byte response held by the server

Return Value:

        None.

*******************************************************************
--*/

STATIC
VOID
RespondToChallengePart1(
    IN     PUCHAR pObjectId,
    IN     PUCHAR pPassword,
       OUT PUCHAR pResponse
    )
{
    UCHAR   achBuf[32];

    Shuffle(pObjectId, pPassword, STRLEN(pPassword), achBuf, TRUE);
    memcpy(pResponse, achBuf, 17);

    return;
}

/*++
*******************************************************************

        RespondToChallengePart2

Routine Description:

        This routine takes the result of Shuffling the ObjectId and
        the Password and processes it with a challenge key.

Arguments:

        pResponsePart1 - Supplies the 16 byte output of
                                        RespondToChallengePart1.
        pChallenge - Supplies the 8 byte challenge key
        pResponse - Returns the 8 byte response

Return Value:

        None.
*******************************************************************
--*/

STATIC
VOID
RespondToChallengePart2(
    IN     PUCHAR pResponsePart1,
    IN     PUCHAR pChallenge,
       OUT PUCHAR pResponse
    )
{
    int     index;
    UCHAR   achK[32];

    Shuffle( &pChallenge[0], pResponsePart1, 16, &achK[0], TRUE);
    Shuffle( &pChallenge[4], pResponsePart1, 16, &achK[16], TRUE);

    for (index = 0; index < 16; index++) {
        achK[index] ^= achK[31-index];
    }

    for (index = 0; index < 8; index++) {
        pResponse[index] = achK[index] ^ achK[15-index];
    }

    return;
}


/*++
*******************************************************************

        Shuffle

Routine Description:

        This routine shuffles around the object ID with the password

Arguments:

        achObjectId - Supplies the 4 byte user's bindery object id
        szUpperPassword - Supplies the user's uppercased password on the
                            first call to process the password. On the
                            second and third calls this parameter contains
                            the OutputBuffer from the first call
        iPasswordLen - length of uppercased password
        achOutputBuffer - Returns the 8 byte sub-calculation

Return Value:

        None.

*******************************************************************
--*/

STATIC
VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer,
    UCHAR ChangePassword
    )
{
    int     iTempIndex;
    int     iOutputIndex;
    UCHAR   achTemp[32];

    //
    //  Truncate all trailing zeros from the password.
    //

    while (iPasswordLen > 0 && szUpperPassword[iPasswordLen-1] == 0 ) {
        iPasswordLen--;
    }

    //
    //  Initialize the achTemp buffer. Initialization consists of taking
    //  the password and dividing it up into chunks of 32. Any bytes left
    //  over are the remainder and do not go into the initialization.
    //
    //  achTemp[0] = szUpperPassword[0] ^ szUpperPassword[32] ^ szUpper...
    //  achTemp[1] = szUpperPassword[1] ^ szUpperPassword[33] ^ szUpper...
    //  etc.
    //

    if ( iPasswordLen > 32) {

        //  At least one chunk of 32. Set the buffer to the first chunk.

        memcpy( achTemp, szUpperPassword, 32 );

        szUpperPassword += 32;   //  Remove the first chunk
        iPasswordLen    -= 32;

        while ( iPasswordLen >= 32 ) {
            //
            //  Xor this chunk with the characters already loaded into
            //  achTemp.
            //

            XorArray( achTemp, szUpperPassword);

            szUpperPassword += 32;   //  Remove this chunk
            iPasswordLen    -= 32;
        }

    } else {

        //  No chunks of 32 so set the buffer to zero's

        memset( achTemp, 0, sizeof(achTemp));

    }

    //
    //  achTemp is now initialized. Load the remainder into achTemp.
    //  The remainder is repeated to fill achTemp.
    //
    //  The corresponding character from Keys is taken to seperate
    //  each repitition.
    //
    //  As an example, take the remainder "ABCDEFG". The remainder is expanded
    //  to "ABCDEFGwABCDEFGxABCDEFGyABCDEFGz" where w is Keys[7],
    //  x is Keys[15], y is Keys[23] and z is Keys[31].
    //
    //

    if (iPasswordLen > 0) {
        int iPasswordOffset = 0;
        for (iTempIndex = 0; iTempIndex < 32; iTempIndex++) {

            if (iPasswordLen == iPasswordOffset) {
                iPasswordOffset = 0;
                achTemp[iTempIndex] ^= Keys[iTempIndex];
            } else {
                achTemp[iTempIndex] ^= szUpperPassword[iPasswordOffset++];
            }
        }
    }

    //
    //  achTemp has been loaded with the users password packed into 32
    //  bytes. Now take the objectid that came from the server and use
    //  that to munge every byte in achTemp.
    //

    for (iTempIndex = 0; iTempIndex < 32; iTempIndex++)
        achTemp[iTempIndex] ^= achObjectId[ iTempIndex & 3];

    Scramble( Scramble( 0, achTemp ), achTemp );

    //
    //  Finally take pairs of bytes in achTemp and return the two
    //  nibbles obtained from Table. The pairs of bytes used
    //  are achTemp[n] and achTemp[n+16].
    //

    for (iOutputIndex = 0; iOutputIndex < 16; iOutputIndex++) {

        if (ChangePassword) {
            unsigned int offset = achTemp[iOutputIndex << 1],
                         shift  = (offset & 0x1) ? 0 : 4 ;

            achOutputBuffer[iOutputIndex] =
                (ChangeTable[offset >> 1] >> shift) & 0xF ;

            offset = achTemp[(iOutputIndex << 1)+1],
            shift = (offset & 0x1) ? 4 : 0 ;

            achOutputBuffer[iOutputIndex] |=
                (ChangeTable[offset >> 1] << shift) & 0xF0;
        } else {
            achOutputBuffer[iOutputIndex] =
                LoginTable[achTemp[iOutputIndex << 1]] |
                (LoginTable[achTemp[(iOutputIndex << 1) + 1]] << 4);
        }
    }

    return;
}


/*++
*******************************************************************

        Scramble

Routine Description:

        This routine scrambles around the contents of the buffer. Each
        buffer position is updated to include the contents of at least
        two character positions plus an EncryptKey value. The buffer
        is processed left to right and so if a character position chooses
        to merge with a buffer position to its left then this buffer
        position will include bits derived from at least 3 bytes of
        the original buffer contents.

Arguments:

        iSeed =
        achBuffer =

Return Value:

        None.

*******************************************************************
--*/
STATIC
int
Scramble(
    int     iSeed,
    UCHAR   achBuffer[32]
    )
{
    int iBufferIndex;

    for (iBufferIndex = 0; iBufferIndex < 32; iBufferIndex++) {
        achBuffer[iBufferIndex] =
            (UCHAR)(
                ((UCHAR)(achBuffer[iBufferIndex] + iSeed)) ^
                ((UCHAR)(   achBuffer[(iBufferIndex+iSeed) & 31] -
                    Keys[iBufferIndex] )));

        iSeed += achBuffer[iBufferIndex];
    }
    return iSeed;
}

//
// Takes a 17-byte array and makes a 34-byte array out of it by
// putting each nibble into the space of a byte.
//

STATIC
void
ExpandBytes(
    IN  PUCHAR InArray,
    OUT PUCHAR OutArray
    )
{
    unsigned int i;

    for (i = 0 ; i < (NUM_NYBBLES / 2); i++) {
        OutArray[i * 2] = InArray[i] & 0x0f;
        OutArray[(i * 2) + 1] = (InArray[i] & 0xf0) >> 4;
    }
}

//
// Takes a 34-byte array and makes a 17-byte array out of it
// by combining the lower nibbles of two bytes into a byte.
//

STATIC
void
CompressBytes(
    IN  PUCHAR InArray,
    OUT PUCHAR OutArray
    )
{
    unsigned int i;

    for (i = 0; i < (NUM_NYBBLES / 2); i++) {
        OutArray[i] = InArray[i * 2] | (InArray[i * 2 + 1] << 4);
    }
}


#define N   0x10
typedef char    entry_t;

entry_t pinv[N][N] = {
    { 0xF,0x8,0x5,0x7,0xC,0x2,0xE,0x9,0x0,0x1,0x6,0xD,0x3,0x4,0xB,0xA,},
    { 0x2,0xC,0xE,0x6,0xF,0x0,0x1,0x8,0xD,0x3,0xA,0x4,0x9,0xB,0x5,0x7,},
    { 0x5,0x2,0x9,0xF,0xC,0x4,0xD,0x0,0xE,0xA,0x6,0x8,0xB,0x1,0x3,0x7,},
    { 0xF,0xD,0x2,0x6,0x7,0x8,0x5,0x9,0x0,0x4,0xC,0x3,0x1,0xA,0xB,0xE,},
    { 0x5,0xE,0x2,0xB,0xD,0xA,0x7,0x0,0x8,0x6,0x4,0x1,0xF,0xC,0x3,0x9,},
    { 0x8,0x2,0xF,0xA,0x5,0x9,0x6,0xC,0x0,0xB,0x1,0xD,0x7,0x3,0x4,0xE,},
    { 0xE,0x8,0x0,0x9,0x4,0xB,0x2,0x7,0xC,0x3,0xA,0x5,0xD,0x1,0x6,0xF,},
    { 0x1,0x4,0x8,0xA,0xD,0xB,0x7,0xE,0x5,0xF,0x3,0x9,0x0,0x2,0x6,0xC,},
    { 0x5,0x3,0xC,0x8,0xB,0x2,0xE,0xA,0x4,0x1,0xD,0x0,0x6,0x7,0xF,0x9,},
    { 0x6,0x0,0xB,0xE,0xD,0x4,0xC,0xF,0x7,0x2,0x8,0xA,0x1,0x5,0x3,0x9,},
    { 0xB,0x5,0xA,0xE,0xF,0x1,0xC,0x0,0x6,0x4,0x2,0x9,0x3,0xD,0x7,0x8,},
    { 0x7,0x2,0xA,0x0,0xE,0x8,0xF,0x4,0xC,0xB,0x9,0x1,0x5,0xD,0x3,0x6,},
    { 0x7,0x4,0xF,0x9,0x5,0x1,0xC,0xB,0x0,0x3,0x8,0xE,0x2,0xA,0x6,0xD,},
    { 0x9,0x4,0x8,0x0,0xA,0x3,0x1,0xC,0x5,0xF,0x7,0x2,0xB,0xE,0x6,0xD,},
    { 0x9,0x5,0x4,0x7,0xE,0x8,0x3,0x1,0xD,0xB,0xC,0x2,0x0,0xF,0x6,0xA,},
    { 0x9,0xA,0xB,0xD,0x5,0x3,0xF,0x0,0x1,0xC,0x8,0x7,0x6,0x4,0xE,0x2,},
};

entry_t master_perm[] = {
    0, 3, 0xe, 0xf, 9, 6, 0xa, 7, 0xc, 0xb, 1, 4, 5, 8, 2, 0xd,
};

entry_t key_sched[N][N];
entry_t perm_sched[N][N];

int InverseTableInitialized = 0;

void cipher_inv (
    const entry_t    *ctxt,
    const entry_t    *key,
          entry_t    *ptxt
    )
{
    int sc, r;
    entry_t v;

    for (sc = 0; sc < N; sc++) {
        v = ctxt[sc];
        for (r = N; --r >= 0; ) {
            v ^= key[key_sched[sc][r]];
            v = pinv[perm_sched[sc][r]][v];
        }
        ptxt[sc] = v;
    }
}

#if 0
void swab_nybbles (
    entry_t *vec
    )
{
    int i, j;

    //
    //  swap all columns instead of calling this routine twice.
    //

    for (i = 0; i < (2 * N); i += 2) {
        j = vec[i];
        vec[i] = vec[i+1];
        vec[i+1] = j;
    }
}
#endif

VOID
CalculateWireFromOldAndNewPasswords(
    UCHAR *Vold,
    UCHAR *Vnew,
    UCHAR *Vc
    )
{
    if (InverseTableInitialized == 0) {

        UCHAR sc,r;

        for (sc = 0; sc < N; sc++) {
            key_sched[sc][N-1] = sc;    /* terminal subkey */
            key_sched[0][(N+ N-1 - master_perm[sc])%N] = (N+sc-master_perm[sc])%N;
        }
        for (sc = 1; sc < N; sc++) for (r = 0; r < N; r++) {
            key_sched[sc][(r+master_perm[sc])%N] = (key_sched[0][r] + master_perm[sc]) % N;
        }
        for (sc = 0; sc < N; sc++) {
            perm_sched[sc][N-1] = sc;
            perm_sched[0][(N + N-1 - master_perm[sc])%N] = sc;
        }
        for (sc = 1; sc < N; sc++) for (r = 0; r < N; r++) {
            perm_sched[sc][r] = perm_sched[0][(N+r-master_perm[sc])%N];
        }

        InverseTableInitialized = 1;
    }

    //
    //  already swapped coming in here... don't swap them again.
    //

//  swab_nybbles(Vold);
//  swab_nybbles(Vnew);

    cipher_inv( (entry_t *)(&Vnew[0]),
                (entry_t *)(&Vold[0]),
                (entry_t *)(&Vc[0]));
    cipher_inv( (entry_t *)(&Vnew[16]),
                (entry_t *)(&Vold[16]),
                (entry_t *)(&Vc[16]));

//  swab_nybbles(Vc);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\nwutils.cxx ===
#include "procs.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: NWApiGetBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetBinderyHandle(
    NWCONN_HANDLE *phConnReturned,
    BSTR bstrBinderyName
    )
{
    NWLOCAL_SCOPE ScopeFlag = 0;
    NWCONN_HANDLE hConn;
    NWCCODE       usRet = SUCCESSFUL;
    HRESULT       hr = S_OK;

    usRet = NWCAttachToFileServerW(
                bstrBinderyName,
                ScopeFlag,
                &hConn
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *phConnReturned = hConn;

    RRETURN(hr);

error:
    *phConnReturned = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiReleaseBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiReleaseBinderyHandle(
    NWCONN_HANDLE hConn
    )
{
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    if (hConn) {
        usRet = NWCDetachFromFileServer(hConn);
        hr = HRESULT_FROM_NWCCODE(usRet);
    }

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiWriteProperty
//
//  Synopsis: This function modifies values of a bindery property.  For now, it
//            only accept one buffer segment.  However, one segment is enough
//            for most practical purpose.  If the bindery property does not
//            exist, the function will attempt to create the property.
//
//----------------------------------------------------------------------------
HRESULT
NWApiWriteProperty(
    NWCONN_HANDLE hConn,
    BSTR bstrObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    NWSEGMENT_DATA *SegmentData
    )
{
    CHAR    szObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    if (wcslen(bstrObjectName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    UnicodeToAnsiString(
        bstrObjectName,
        szObjectName,
        0
        );

    usRet = NWCWritePropertyValue(
                hConn,
                szObjectName,
                wObjType,
                lpszPropertyName,
                1,                   // "1" for one segment.
                SegmentData,
                0                    // "0" for no more segment.
                );
    //
    // Create the property if it doesn't exist and attempt to write again.
    //

    // If the property doesn't exist, NWCWritePropertyValue will return
    // UNSUCCESSFUL, not NO_SUCH_PROPERTY (bug #34833 --- by design).
    // So if the call doesn't succeed, try to create the property and
    // see if that succeeds.

    if (usRet == 0xffff) {

        hr = NWApiCreateProperty(
                 hConn,
                 bstrObjectName,
                 wObjType,
                 lpszPropertyName,
                 BF_ITEM
                 );
        BAIL_ON_FAILURE(hr);

        usRet = NWCWritePropertyValue(
                    hConn,
                    szObjectName,
                    wObjType,
                    lpszPropertyName,
                    1,                   // "1" for one segment.
                    SegmentData,
                    0                    // "0" for no more segment.
                    );
    }

    hr = HRESULT_FROM_NWCCODE(usRet);

error:

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiObjectEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiObjectEnum(
    NWCONN_HANDLE hConn,
    NWOBJ_TYPE dwObjType,
    LPWSTR *lppszObjectName,
    DWORD  *pdwResumeObjectID
    )
{
    HRESULT       hr = S_OK;
    LPWSTR        lpszTemp = NULL;
    NWCCODE       usRet = SUCCESSFUL;
    NWOBJ_TYPE    pdwObjType = 0xFFFF;
    NWFLAGS       pucHasProperties;
    NWFLAGS       pucObjectFlags;
    NWFLAGS       pucObjSecurity;
    CHAR          szObjectName[(OBJ_NAME_SIZE + 1)*2];

    //
    // This call will fail and return 0xffff if the user is not authenticated
    // on the server to which the hConn handle is attached to.
    //

    usRet = NWCScanObject(
                hConn,
                "*",
                dwObjType,
                pdwResumeObjectID,
                szObjectName,
                &pdwObjType,
                &pucHasProperties,
                &pucObjectFlags,
                &pucObjSecurity
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    lpszTemp = AllocateUnicodeString(szObjectName);
    if (!lpszTemp) {
       RRETURN(E_OUTOFMEMORY);
    }

    *lppszObjectName = AllocADsStr(lpszTemp);
    if (!(*lppszObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    if(lpszTemp){
        FreeUnicodeString(lpszTemp);
    }

    RRETURN(hr);

error:
    *lppszObjectName = NULL;
    pdwResumeObjectID = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiValidateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiValidateObject(
    NWCONN_HANDLE hConn,
    NWOBJ_TYPE dwObjType,
    LPWSTR lpszObjectName,
    DWORD  *pdwResumeObjectID
    )
{
    HRESULT       hr = S_OK;
    NWCCODE       usRet = SUCCESSFUL;
    CHAR          szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    CHAR          szObjectName[(OBJ_NAME_SIZE + 1)*2];
    NWOBJ_TYPE    pdwObjType = 0xFFFF;
    NWFLAGS       pucHasProperties;
    NWFLAGS       pucObjectFlags;
    NWFLAGS       pucObjSecurity;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // This call will fail and return 0xffff if the user is not authenticated
    // on the server to which the hConn handle is attached to.
    //

    usRet = NWCScanObject(
                hConn,
                szAnsiObjectName,
                dwObjType,
                pdwResumeObjectID,
                szObjectName,
                &pdwObjType,
                &pucHasProperties,
                &pucObjectFlags,
                &pucObjSecurity
                );

    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetAnyBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetAnyBinderyHandle(
    NWCONN_HANDLE *phConn
    )
{
    HRESULT hr = S_OK;

    //
    // Get Bindery handle.
    //

    hr = NWApiGetBinderyHandle(
             phConn,
             L"*"
             );

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetObjectName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetObjectName(
    NWCONN_HANDLE hConn,
    DWORD dwObjectID,
    LPWSTR *lppszObjectName
    )
{
    CHAR       szObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT    hr = S_OK;
    LPWSTR     lpszTemp = NULL;
    NWCCODE    usRet = SUCCESSFUL;
    NWOBJ_TYPE dwObjType;

    usRet = NWCGetObjectName(
                hConn,
                dwObjectID,
                szObjectName,
                &dwObjType
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);


    lpszTemp = AllocateUnicodeString(szObjectName);
    if (!lpszTemp) {
       RRETURN(E_OUTOFMEMORY);
    }

    *lppszObjectName = AllocADsStr(lpszTemp);
    if (!(*lppszObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    FreeUnicodeString(lpszTemp);

    RRETURN(hr);

error:
    *lppszObjectName = NULL;

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: HRESULT_FROM_NWCCODE
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
HRESULT_FROM_NWCCODE(
    NWCCODE usRet
    )
{
    HRESULT hr = S_OK;

    if (usRet != SUCCESSFUL) {

        hr = HRESULT_FROM_WIN32(GetLastError());

        if (hr == S_OK) {
            //
            // In case CSNW didn't SetLastError,
            // make sure we don't return a false S_OK,
            // since we know _some_ error occurred
            //
            hr = HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);
        }

        if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR)) {
  
            ADsSetLastError((DWORD) usRet,
                            L"",
                            L"NDS Provider"
                            );
        }
    }

    RRETURN(hr);
}



//----------------------------------------------------------------------------
//
//  Function: NWApiOpenPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiOpenPrinter(
    LPWSTR lpszUncPrinterName,
    HANDLE *phPrinter,
    DWORD  dwAccess
    )
{
    BOOL    fStatus = TRUE;
    HANDLE  hPrinter;
    HRESULT hr = S_OK;
    PRINTER_DEFAULTS PrinterDefault = {0, 0, dwAccess};

    //
    // Set desired access right.
    //

    PrinterDefault.DesiredAccess = dwAccess;

    //
    // Get a handle to the speccified printer using Win32 API.
    //

    fStatus = OpenPrinter(
                  lpszUncPrinterName,
                  &hPrinter,
                  &PrinterDefault
                  );

    //
    // Convert error code into HRESULT.
    //

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Return.
    //

    else {
        *phPrinter = hPrinter;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiClosePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiClosePrinter(
    HANDLE hPrinter
    )
{
    BOOL fStatus = TRUE;
    HRESULT hr = S_OK;

    //
    // Close a printer using Win32 API.
    //

    fStatus = ClosePrinter(hPrinter);

    //
    // Convert error code into HRESULT.
    //

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE lpbPrinters,
    DWORD  dwAccess
    )
{
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    fStatus = SetPrinter(
                  hPrinter,
                  dwLevel,
                  lpbPrinters,
                  dwAccess
                  );
    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetJob(
    HANDLE hPrinter,
    DWORD dwJobId,
    DWORD dwLevel,
    LPBYTE *lplpbJobs
    )
{
    BOOL  fStatus = FALSE;
    DWORD dwError = 0;
    DWORD dwNeeded = 0;
    DWORD dwPassed = 1024;
    LPBYTE pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem = (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        RRETURN(E_OUTOFMEMORY);
    }

    //
    // Get Job's information.
    //

    fStatus = GetJob(
                  hPrinter,
                  dwJobId,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded
                  );

    //
    // Get job's information again with a bigger buffer if a bigger buffer is
    // needed for the result.
    //

    if (!fStatus) {

        if (pMem){
            FreeADsMem(pMem);
        }

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            RRETURN(HRESULT_FROM_WIN32(dwError));
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            RRETURN(E_OUTOFMEMORY);
        }

        dwPassed = dwNeeded;

        fStatus = GetJob(
                      hPrinter,
                      dwJobId,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded
                      );

        if (!fStatus) {
            FreeADsMem(pMem);
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Return.
    //

    *lplpbJobs = pMem;

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetJob(
    HANDLE hPrinter,
    DWORD  dwJobId,
    DWORD  dwLevel,
    LPBYTE lpbJobs,
    DWORD  dwCommand
    )
{
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    fStatus = SetJob(
                  hPrinter,
                  dwJobId,
                  dwLevel,
                  lpbJobs,
                  dwCommand
                  );
    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiCreateProperty
//
//  Synopsis: This function creates a bindery property.  Access is logged read,
//            supervisor write.
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateProperty(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    NWFLAGS ucObjectFlags
    )
{
    CHAR    szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Create property.
    //

    usRet = NWCCreateProperty(
                hConn,
                szAnsiObjectName,
                wObjType,
                lpszPropertyName,
                ucObjectFlags,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\sconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  sconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop

#define NULL_TERMINATED 0

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength * 2);
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength*2,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}


DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //

    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwnds\var2nds.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       var2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//  NDS_ASN1_TYPE_1
//
//  NDS_ASN1_TYPE_2
//
//  NDS_ASN1_TYPE_3
//
//  NDS_ASN1_TYPE_4
//
//  NDS_ASN1_TYPE_5
//
//  NDS_ASN1_TYPE_6     
//
//  NDS_ASN1_TYPE_7
//
//  NDS_ASN1_TYPE_8
//
//  NDS_ASN1_TYPE_9     
//
//  NDS_ASN1_TYPE_10
//
//  NDS_ASN1_TYPE_11    
//
//  NDS_ASN1_TYPE_12    
//
//  NDS_ASN1_TYPE_13    
//
//  NDS_ASN1_TYPE_14
//
//  NDS_ASN1_TYPE_15    
//
//  NDS_ASN1_TYPE_16    
//
//  NDS_ASN1_TYPE_17    
//
//  NDS_ASN1_TYPE_18    
//
//  NDS_ASN1_TYPE_19    
//
//  NDS_ASN1_TYPE_20
//
//  NDS_ASN1_TYPE_21    
//
//  NDS_ASN1_TYPE_22
//
//  NDS_ASN1_TYPE_23    
//
//  NDS_ASN1_TYPE_24
//
//  NDS_ASN1_TYPE_25    
//
//  NDS_ASN1_TYPE_26    
//
//  NDS_ASN1_TYPE_27
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//
HRESULT
VarTypeToNdsTypeCopyNDSSynId1(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_1;

    lpNdsDestObject->NdsValue.value_1.DNString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId2(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_2;

    lpNdsDestObject->NdsValue.value_2.CaseExactString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId3(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_3;

    lpNdsDestObject->NdsValue.value_3.CaseIgnoreString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);

}


HRESULT
VarTypeToNdsTypeCopyNDSSynId4(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_4;

    lpNdsDestObject->NdsValue.value_4.PrintableString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId5(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_5;

    lpNdsDestObject->NdsValue.value_5.NumericString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId6(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    LPNDS_ASN1_TYPE_6 pCurrent = NULL;
    IADsCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varCaseIgnoreList;
    VARIANT varElement;

    VariantInit(&varCaseIgnoreList);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsCaseIgnoreList,
                    (void **)&pCaseIgnoreList
                    );
    BAIL_ON_FAILURE(hr);

    hr = pCaseIgnoreList->get_CaseIgnoreList(
                    &varCaseIgnoreList
                    );
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varCaseIgnoreList) &  VT_VARIANT) &&  V_ISARRAY(&varCaseIgnoreList))) {
        return(E_FAIL);
    }
 
    if ((V_ARRAY(&varCaseIgnoreList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varCaseIgnoreList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_6;
    pCurrent = &lpNdsDestObject->NdsValue.value_6;
    
    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varCaseIgnoreList),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        pCurrent->String = AllocADsStr(V_BSTR(&varElement));
        if (i != (long)dwSUBound) {
            pCurrent->Next = (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
        VariantClear(&varElement);
    }
    pCurrent->Next = NULL;
    RRETURN(S_OK);

error:
    VariantClear(&varCaseIgnoreList);
    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release();
    }
    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId7(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_7;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        (lpVarSrcObject->boolVal)? TRUE:FALSE;

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId8(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_8;

    if (lpVarSrcObject->vt == VT_I4)
        lpNdsDestObject->NdsValue.value_8.Integer = lpVarSrcObject->lVal;
    else if (lpVarSrcObject->vt == VT_I2)
        lpNdsDestObject->NdsValue.value_8.Integer = lpVarSrcObject->iVal;
    else
        hr = E_ADS_CANT_CONVERT_DATATYPE;

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId9(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr;
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_9;
    hr = VariantToBinary(
                lpVarSrcObject,
                &lpNdsDestObject->NdsValue.value_9.Length,
                &lpNdsDestObject->NdsValue.value_9.OctetString
                );
    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId10(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_10;

    lpNdsDestObject->NdsValue.value_10.TelephoneNumber =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId11(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsFaxNumber FAR * pFaxNumber = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varParameters;
    BSTR bstrVal;

    VariantInit(&varParameters);

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsFaxNumber,
                    (void **)&pFaxNumber
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_11;

    hr = pFaxNumber->get_TelephoneNumber(
                                    &bstrVal
                                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                        AllocADsStr(
                                bstrVal
                        );

    hr = pFaxNumber->get_Parameters(
                            &varParameters
                            );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varParameters,
                    &lpNdsDestObject->NdsValue.value_11.NumberOfBits,
                    &lpNdsDestObject->NdsValue.value_11.Parameters
                    );
    BAIL_ON_FAILURE(hr);

error:
    VariantClear(&varParameters);
    if (pFaxNumber) {
        pFaxNumber->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId12(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsNetAddress FAR * pNetAddress = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwAddressType = 0;
    BYTE*  pbAddress = NULL;
    VARIANT varAddress;

    VariantInit(&varAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                            IID_IADsNetAddress,
                            (void **)&pNetAddress
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_12;

    hr = pNetAddress->get_AddressType(
                                &dwAddressType
                                );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_12.AddressType = dwAddressType;

    VariantInit(&varAddress);
    hr = pNetAddress->get_Address(
                            &varAddress
                            );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                        &varAddress,
                        &lpNdsDestObject->NdsValue.value_12.AddressLength,
                        &lpNdsDestObject->NdsValue.value_12.Address
                        );
    BAIL_ON_FAILURE(hr);

error:
    VariantClear(&varAddress);
    if (pNetAddress) {
        pNetAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId13(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    LPNDS_ASN1_TYPE_13 pCurrent = NULL;
    IADsOctetList FAR * pOctetList= NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varOctetList;
    VARIANT varElement;

    VariantInit(&varOctetList);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                    IID_IADsOctetList,
                    (void **)&pOctetList
                    );
    BAIL_ON_FAILURE(hr);


    hr = pOctetList->get_OctetList(&varOctetList);
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varOctetList) &  VT_VARIANT) &&  V_ISARRAY(&varOctetList))) {
        return(E_FAIL);
    }
 
    if ((V_ARRAY(&varOctetList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varOctetList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_13;
    pCurrent = &lpNdsDestObject->NdsValue.value_13;
    
    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varOctetList),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        hr = VariantToBinary(
                        &varElement,
                        &pCurrent->Length,
                        &pCurrent->Data
                        );
        BAIL_ON_FAILURE(hr);
        if (i != (long)dwSUBound) {
            pCurrent->Next = (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            pCurrent = pCurrent->Next;
        }
        VariantClear(&varElement);
    }
    pCurrent->Next = NULL;

error:
    VariantClear(&varOctetList);
    if (pOctetList) {
        pOctetList->Release();
    }
    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId14(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsEmail FAR * pEmail = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwAddressType = 0;
    BSTR bstrAddress;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                            IID_IADsEmail,
                            (void **)&pEmail
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_14;

    hr = pEmail->get_Type(
                    &dwAddressType
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_14.Type = dwAddressType;

    hr = pEmail->get_Address(
                        &bstrAddress
                        );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_14.Address=
                        AllocADsStr(
                                bstrAddress
                        );

error:
    if (pEmail) {
        pEmail->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId15(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsPath FAR * pPath = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwType = 0;
    BSTR bstrVolumeName = NULL;
    BSTR bstrPath = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsPath,
                    (void **)&pPath
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_15;

    hr = pPath->get_VolumeName(
                    &bstrVolumeName
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.VolumeName=
                                AllocADsStr(bstrVolumeName);

    hr = pPath->get_Path(
                    &bstrPath
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.Path=
                                AllocADsStr(bstrPath);

    hr = pPath->get_Type((LONG *)&dwType);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.Type = dwType;

error:
    if (pPath) {
        pPath->Release();
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNdsTypeCopyNDSSynId16(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsReplicaPointer FAR * pReplicaPointer = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwReplicaType = 0;
    DWORD  dwReplicaNumber = 0;
    DWORD  dwCount = 0;
    BSTR bstrServerName = NULL;
    NDSOBJECT object;
    VARIANT varAddress;

    VariantInit(&varAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsReplicaPointer,
                    (void **)&pReplicaPointer
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_16;

    hr = pReplicaPointer->get_ServerName(
                    &bstrServerName
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ServerName=
                                AllocADsStr(bstrServerName);

    hr = pReplicaPointer->get_ReplicaType((LONG *)&dwReplicaType);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ReplicaType= dwReplicaType;

    hr = pReplicaPointer->get_ReplicaNumber((LONG *)&dwReplicaNumber);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ReplicaNumber= dwReplicaNumber;

    hr = pReplicaPointer->get_Count((LONG *)&dwCount);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.Count= dwCount;

    hr = pReplicaPointer->get_ReplicaAddressHints(&varAddress);
    BAIL_ON_FAILURE(hr);
    hr = VarTypeToNdsTypeCopyNDSSynId12(
                            &varAddress,
                            &object
                            );
    BAIL_ON_FAILURE(hr);
    memcpy(&lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints,
           object.NdsValue.value_16.ReplicaAddressHints,
           sizeof(NDS_ASN1_TYPE_12));

error:
    VariantClear(&varAddress);
    if (pReplicaPointer) {
        pReplicaPointer->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId17(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsAcl FAR * pSecDes = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwPrivileges = 0;
    BSTR bstrProtectedAttrName = NULL;
    BSTR bstrSubjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsAcl,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_17;

    hr = pSecDes->get_ProtectedAttrName(
                    &bstrProtectedAttrName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_17.ProtectedAttrName =
                                AllocADsStr(bstrProtectedAttrName);

    hr = pSecDes->get_SubjectName(
                    &bstrSubjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_17.SubjectName=
                                AllocADsStr(bstrSubjectName);

    hr = pSecDes->get_Privileges((LONG *)&dwPrivileges);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_17.Privileges= dwPrivileges;


error:

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId18(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    IADsPostalAddress FAR * pPostalAddress = NULL;
    IDispatch FAR * pDispatch = NULL;
    VARIANT varPostalAddress;
    VARIANT varElement;
    BSTR bstrElement;
    
    VariantInit(&varPostalAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsPostalAddress,
                    (void **)&pPostalAddress
                    );
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->get_PostalAddress(
                    &varPostalAddress
                    );
    BAIL_ON_FAILURE(hr);


    if(!((V_VT(&varPostalAddress) &  VT_VARIANT) &&  V_ISARRAY(&varPostalAddress))) {
        return(E_FAIL);
    }
 
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_18;

    if ((V_ARRAY(&varPostalAddress))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ( ((V_ARRAY(&varPostalAddress))->rgsabound[0].cElements <= 0) || 
         ((V_ARRAY(&varPostalAddress))->rgsabound[0].cElements >6) ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varPostalAddress),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varPostalAddress),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varPostalAddress),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        lpNdsDestObject->NdsValue.value_18.PostalAddress[i-dwSLBound] = 
                            AllocADsStr(V_BSTR(&varElement));
        VariantClear(&varElement);
    }

error:
    VariantClear(&varPostalAddress);
    if (pPostalAddress) {
        pPostalAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId19(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsTimestamp FAR * pTime = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwEventID = 0;
    long dwWholeSeconds = 0;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsTimestamp,
                    (void **)&pTime
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_19;

    hr = pTime->get_WholeSeconds(
                    &dwWholeSeconds
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_19.WholeSeconds= dwWholeSeconds;
    BAIL_ON_FAILURE(hr);

    hr = pTime->get_EventID(
                    &dwEventID
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_19.EventID = dwEventID;
    BAIL_ON_FAILURE(hr);

error:
    if (pTime) {
        pTime->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId20(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_20;

    lpNdsDestObject->NdsValue.value_20.ClassName =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId21(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr;
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_21;
    hr = VariantToBinary(
                            lpVarSrcObject,
                            &lpNdsDestObject->NdsValue.value_21.Length,
                            &lpNdsDestObject->NdsValue.value_21.Data
                            );
    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId22(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_22;

    lpNdsDestObject->NdsValue.value_22.Counter =
                            lpVarSrcObject->lVal;

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId23(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsBackLink FAR * pBackLink = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwRemoteID = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsBackLink,
                    (void **)&pBackLink
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_23;

    hr = pBackLink->get_ObjectName(
                            &bstrObjectName
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_23.ObjectName=
                                AllocADsStr(bstrObjectName);

    hr = pBackLink->get_RemoteID((LONG *)&dwRemoteID);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_23.RemoteID = dwRemoteID;

error:
    if (pBackLink) {
        pBackLink->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId24(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_24;

    hr = ConvertDATEtoDWORD(
                lpVarSrcObject->date,
                &(lpNdsDestObject->NdsValue.value_24.Time),
                TRUE
                );

    RRETURN(hr);

}

HRESULT
VarTypeToNdsTypeCopyNDSSynId25(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsTypedName FAR * pTypedName = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwLevel = 0;
    DWORD  dwInterval = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsTypedName,
                    (void **)&pTypedName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_25;

    hr = pTypedName->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_25.ObjectName=
                                AllocADsStr(bstrObjectName);

    hr = pTypedName->get_Level((LONG *)&dwLevel);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_25.Level = dwLevel;

    hr = pTypedName->get_Interval((LONG *)&dwInterval);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_25.Interval= dwInterval;

error:
    if (pTypedName) {
        pTypedName->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId26(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsHold FAR * pHold = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwAmount = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsHold,
                    (void **)&pHold
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_26;

    hr = pHold->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_26.ObjectName=
                                AllocADsStr(bstrObjectName);

    hr = pHold->get_Amount((LONG *)&dwAmount);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_26.Amount = dwAmount;

error:
    if (pHold) {
        pHold->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId27(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_27;

    lpNdsDestObject->NdsValue.value_27.Interval =
                            lpVarSrcObject->lVal;

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopy(
    DWORD dwNdsType,
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (dwNdsType){
    case 1:
        hr = VarTypeToNdsTypeCopyNDSSynId1(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 2:
        hr = VarTypeToNdsTypeCopyNDSSynId2(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 3:
        hr = VarTypeToNdsTypeCopyNDSSynId3(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 4:
        hr = VarTypeToNdsTypeCopyNDSSynId4(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 5:
        hr = VarTypeToNdsTypeCopyNDSSynId5(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 6:
        hr = VarTypeToNdsTypeCopyNDSSynId6(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 7:
        hr = VarTypeToNdsTypeCopyNDSSynId7(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 8:
        hr = VarTypeToNdsTypeCopyNDSSynId8(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 9:
        hr = VarTypeToNdsTypeCopyNDSSynId9(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 10:
        hr = VarTypeToNdsTypeCopyNDSSynId10(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 11:
        hr = VarTypeToNdsTypeCopyNDSSynId11(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 12:
        hr = VarTypeToNdsTypeCopyNDSSynId12(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 13:
        hr = VarTypeToNdsTypeCopyNDSSynId13(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 14:
        hr = VarTypeToNdsTypeCopyNDSSynId14(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 15:
        hr = VarTypeToNdsTypeCopyNDSSynId15(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 16:
        hr = VarTypeToNdsTypeCopyNDSSynId16(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 17:
        hr = VarTypeToNdsTypeCopyNDSSynId17(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 18:
        hr = VarTypeToNdsTypeCopyNDSSynId18(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 19:
        hr = VarTypeToNdsTypeCopyNDSSynId19(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 20:
        hr = VarTypeToNdsTypeCopyNDSSynId20(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 21:
        hr = VarTypeToNdsTypeCopyNDSSynId21(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 22:
        hr = VarTypeToNdsTypeCopyNDSSynId22(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 23:
        hr = VarTypeToNdsTypeCopyNDSSynId23(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 24:
        hr = VarTypeToNdsTypeCopyNDSSynId24(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 25:
        hr = VarTypeToNdsTypeCopyNDSSynId25(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 26:
        hr = VarTypeToNdsTypeCopyNDSSynId26(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 27:
        hr = VarTypeToNdsTypeCopyNDSSynId27(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNdsTypeCopyConstruct(
    DWORD dwNdsType,
    LPVARIANT pVarSrcObjects,
    DWORD *pdwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;
    VARIANT varNDSAcl;
    IDispatch * pDispatch = NULL;
    IADsSecurityDescriptor * pSecDes = NULL;
    DWORD dwNumObjects = *pdwNumObjects;

    // 
    // If it is a security descriptor, do special conversion
    // 
    if (dwNdsType == 17) {

        //
        // Bail out if it contains more than 1 object
        //
        if (dwNumObjects != 1) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        if (V_VT(pVarSrcObjects) != VT_DISPATCH){
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    
        pDispatch = V_DISPATCH(pVarSrcObjects);
    
        hr = pDispatch->QueryInterface(
                        IID_IADsSecurityDescriptor,
                        (void **)&pSecDes
                        );
        BAIL_ON_FAILURE(hr);

        hr = ConvertSecDesToNDSAclVarArray(
            pSecDes,
            &varNDSAcl
            );
        BAIL_ON_FAILURE(hr);

        hr  = ConvertSafeArrayToVariantArray(
                    varNDSAcl,
                    &pVarSrcObjects,
                    &dwNumObjects
                    );
        BAIL_ON_FAILURE(hr);
        pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

        if (!pNdsDestObjects) {
            RRETURN(E_FAIL);
        }
        *pdwNumObjects = dwNumObjects;
    }
    else {
        pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                        dwNumObjects * sizeof(NDSOBJECT)
                                        );

        if (!pNdsDestObjects) {
            RRETURN(E_FAIL);
        }
    }    
     
    for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToNdsTypeCopy(
                    dwNdsType,
                    pVarSrcObjects + i,
                    pNdsDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);
    
    }

     *ppNdsDestObjects = pNdsDestObjects;

     if (pSecDes) {
        pSecDes->Release();
     }

     RRETURN(S_OK);

error:

     if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumObjects
                );
     }

     if (pSecDes) {
        pSecDes->Release();
     }

     *ppNdsDestObjects = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsiid\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsiid\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsiid\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\win95\data.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.h

Abstract:

    Common definitions for structure offsets for pointer based data.

Author:

Environment:

    User Mode - Win32

Revision History:

--*/

//DWORD PrinterInfoStressOffsetsA[]={offsetof(PRINTER_INFO_STRESSW, pPrinterName),
//                             offsetof(PRINTER_INFO_STRESSW, pServerName),
//                             0xFFFFFFFF};

DWORD PrinterInfo1OffsetsA[]={offsetof(PRINTER_INFO_1W, pDescription),
                             offsetof(PRINTER_INFO_1W, pName),
                             offsetof(PRINTER_INFO_1W, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2OffsetsA[]={offsetof(PRINTER_INFO_2W, pServerName),
                             offsetof(PRINTER_INFO_2W, pPrinterName),
                             offsetof(PRINTER_INFO_2W, pShareName),
                             offsetof(PRINTER_INFO_2W, pPortName),
                             offsetof(PRINTER_INFO_2W, pDriverName),
                             offsetof(PRINTER_INFO_2W, pComment),
                             offsetof(PRINTER_INFO_2W, pLocation),
                             offsetof(PRINTER_INFO_2W, pDevMode),
                             offsetof(PRINTER_INFO_2W, pSepFile),
                             offsetof(PRINTER_INFO_2W, pPrintProcessor),
                             offsetof(PRINTER_INFO_2W, pDatatype),
                             offsetof(PRINTER_INFO_2W, pParameters),
                             offsetof(PRINTER_INFO_2W, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo3OffsetsA[]={offsetof(PRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo4OffsetsA[]={offsetof(PRINTER_INFO_4W, pPrinterName),
                             offsetof(PRINTER_INFO_4W, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5OffsetsA[]={offsetof(PRINTER_INFO_5W, pPrinterName),
                             offsetof(PRINTER_INFO_5W, pPortName),
                             0xFFFFFFFF};
/*
DWORD PrinterInfoStressStringsA[]={offsetof(PRINTER_INFO_STRESSW, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSW, pServerName),
                             0xFFFFFFFF};
*/

DWORD PrinterInfo1StringsA[]={offsetof(PRINTER_INFO_1W, pDescription),
                             offsetof(PRINTER_INFO_1W, pName),
                             offsetof(PRINTER_INFO_1W, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2StringsA[]={offsetof(PRINTER_INFO_2W, pServerName),
                             offsetof(PRINTER_INFO_2W, pPrinterName),
                             offsetof(PRINTER_INFO_2W, pShareName),
                             offsetof(PRINTER_INFO_2W, pPortName),
                             offsetof(PRINTER_INFO_2W, pDriverName),
                             offsetof(PRINTER_INFO_2W, pComment),
                             offsetof(PRINTER_INFO_2W, pLocation),
                             offsetof(PRINTER_INFO_2W, pSepFile),
                             offsetof(PRINTER_INFO_2W, pPrintProcessor),
                             offsetof(PRINTER_INFO_2W, pDatatype),
                             offsetof(PRINTER_INFO_2W, pParameters),
                             0xFFFFFFFF};

DWORD PrinterInfo3StringsA[]={0xFFFFFFFF};

DWORD PrinterInfo4StringsA[]={offsetof(PRINTER_INFO_4W, pPrinterName),
                             offsetof(PRINTER_INFO_4W, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5StringsA[]={offsetof(PRINTER_INFO_5W, pPrinterName),
                             offsetof(PRINTER_INFO_5W, pPortName),
                             0xFFFFFFFF};


DWORD JobInfo1OffsetsA[]={offsetof(JOB_INFO_1W, pPrinterName),
                         offsetof(JOB_INFO_1W, pMachineName),
                         offsetof(JOB_INFO_1W, pUserName),
                         offsetof(JOB_INFO_1W, pDocument),
                         offsetof(JOB_INFO_1W, pDatatype),
                         offsetof(JOB_INFO_1W, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2OffsetsA[]={offsetof(JOB_INFO_2W, pPrinterName),
                         offsetof(JOB_INFO_2W, pMachineName),
                         offsetof(JOB_INFO_2W, pUserName),
                         offsetof(JOB_INFO_2W, pDocument),
                         offsetof(JOB_INFO_2W, pNotifyName),
                         offsetof(JOB_INFO_2W, pDatatype),
                         offsetof(JOB_INFO_2W, pPrintProcessor),
                         offsetof(JOB_INFO_2W, pParameters),
                         offsetof(JOB_INFO_2W, pDriverName),
                         offsetof(JOB_INFO_2W, pDevMode),
                         offsetof(JOB_INFO_2W, pStatus),
                         offsetof(JOB_INFO_2W, pSecurityDescriptor),
                         0xFFFFFFFF};

DWORD JobInfo3OffsetsA[]={0xFFFFFFFF};

DWORD JobInfo1StringsA[]={offsetof(JOB_INFO_1W, pPrinterName),
                         offsetof(JOB_INFO_1W, pMachineName),
                         offsetof(JOB_INFO_1W, pUserName),
                         offsetof(JOB_INFO_1W, pDocument),
                         offsetof(JOB_INFO_1W, pDatatype),
                         offsetof(JOB_INFO_1W, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2StringsA[]={offsetof(JOB_INFO_2W, pPrinterName),
                         offsetof(JOB_INFO_2W, pMachineName),
                         offsetof(JOB_INFO_2W, pUserName),
                         offsetof(JOB_INFO_2W, pDocument),
                         offsetof(JOB_INFO_2W, pNotifyName),
                         offsetof(JOB_INFO_2W, pDatatype),
                         offsetof(JOB_INFO_2W, pPrintProcessor),
                         offsetof(JOB_INFO_2W, pParameters),
                         offsetof(JOB_INFO_2W, pDriverName),
                         offsetof(JOB_INFO_2W, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo3StringsA[]={0xFFFFFFFF};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\win95\offsets.h ===
extern DWORD PrinterInfoStressOffsets[];
extern DWORD PrinterInfoStressStrings[];
extern DWORD PrinterInfo4Offsets[];
extern DWORD PrinterInfo4Strings[];
extern DWORD PrinterInfo1Offsets[];
extern DWORD PrinterInfo1Strings[];
extern DWORD PrinterInfo2Offsets[];
extern DWORD PrinterInfo2Strings[];
extern DWORD PrinterInfo3Offsets[];
extern DWORD PrinterInfo3Strings[];
extern DWORD PrinterInfo5Offsets[];
extern DWORD PrinterInfo5Strings[];
extern DWORD JobInfo1Offsets[];
extern DWORD JobInfo1Strings[];
extern DWORD JobInfo2Offsets[];
extern DWORD JobInfo2Strings[];
extern DWORD JobInfo3Offsets[];
extern DWORD JobInfo3Strings[];
extern DWORD DriverInfo1Offsets[];
extern DWORD DriverInfo1Strings[];
extern DWORD DriverInfo2Offsets[];
extern DWORD DriverInfo2Strings[];
extern DWORD DriverInfo3Offsets[];
extern DWORD DriverInfo3Strings[];
extern DWORD AddJobOffsets[];
extern DWORD AddJobStrings[];
extern DWORD FormInfo1Offsets[];
extern DWORD FormInfo1Strings[];
extern DWORD PortInfo1Offsets[];
extern DWORD PortInfo1Strings[];
extern DWORD PortInfo2Offsets[];
extern DWORD PortInfo2Strings[];
extern DWORD PortInfo3Offsets[];
extern DWORD PrintProcessorInfo1Offsets[];
extern DWORD PrintProcessorInfo1Strings[];
extern DWORD MonitorInfo1Offsets[];
extern DWORD MonitorInfo2Offsets[];
extern DWORD MonitorInfo1Strings[];
extern DWORD MonitorInfo2Strings[];
extern DWORD DocInfo1Offsets[];
extern DWORD DocInfo1Strings[];
extern DWORD ProvidorInfo1Strings[];
extern DWORD DatatypeInfo1Offsets[];
extern DWORD DatatypeInfo1Strings[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nwutils\win95\printwrp.cxx ===
#include "procs.hxx"
#pragma hdrstop

/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    PrintWrp.c

Abstract:

    Wide end to Win95 Ansi printing APIs

Author:
    Felix Wong (t-felixw)

Environment:

Revision History:

--*/

#include "dswarn.h"
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <data.h>

typedef struct _SPOOL *PSPOOL;
typedef struct _NOTIFY *PNOTIFY;

typedef struct _NOTIFY {
    PNOTIFY  pNext;
    HANDLE   hEvent;      // event to trigger on notification
    DWORD    fdwFlags;    // flags to watch for
    DWORD    fdwOptions;  // PRINTER_NOTIFY_*
    DWORD    dwReturn;    // used by WPC when simulating FFPCN
    PSPOOL   pSpool;
} NOTIFY;

typedef struct _SPOOL {
    DWORD       signature;
    HANDLE      hPrinter;
    HANDLE      hFile;
    DWORD       JobId;
    LPBYTE      pBuffer;
    DWORD       cbBuffer;
    DWORD       Status;
    DWORD       fdwFlags;
    DWORD       cCacheWrite;
    DWORD       cWritePrinters;
    DWORD       cFlushBuffers;
    DWORD       dwTickCount;
    DWORD       dwCheckJobInterval;
    PNOTIFY     pNotify;
} SPOOL;

#define SPOOL_STATUS_ANSI                  0x00000004
#define MIN_DEVMODE_SIZEW 72
#define MIN_DEVMODE_SIZEA 40
#define NULL_TERMINATED 0


BOOL
ConvertAnsiToUnicodeBuf(
    LPBYTE pAnsiBlob,
    LPBYTE pUnicodeBlob,
    DWORD dwAnsiSize,
    DWORD dwUnicodeSize,
    PDWORD pOffsets
    );


BOOL
bValidDevModeW(
    const DEVMODEW *pDevModeW
    )

/*++

Routine Description:

    Check whether a devmode is valid to be RPC'd across to the spooler.

Arguments:

    pDevMode - DevMode to check.

Return Value:

    TRUE - Devmode can be RPC'd to spooler.
    FALSE - Invalid Devmode.

--*/

{
    if( !pDevModeW ){
        return FALSE;
    }

    if( pDevModeW->dmSize < MIN_DEVMODE_SIZEW ){

        //
        // The only valid case is if pDevModeW is NULL.  If it's
        // not NULL, then a bad devmode was passed in and the
        // app should fix it's code.
        //
        ASSERT( pDevModeW->dmSize >= MIN_DEVMODE_SIZEW );
        return FALSE;
    }

    return TRUE;
}

LPSTR
AllocateAnsiString(
    LPWSTR  pPrinterName
)
{
    LPSTR  pAnsiString;

    if (!pPrinterName)
        return NULL;

    pAnsiString = (LPSTR)LocalAlloc(LPTR, wcslen(pPrinterName)*sizeof(CHAR) +
                                      sizeof(CHAR));

    if (pAnsiString)
        UnicodeToAnsiString(pPrinterName, pAnsiString, NULL_TERMINATED);

    return pAnsiString;
}


LPSTR
FreeAnsiString(
    LPSTR  pAnsiString
)
{
    if (!pAnsiString)
        return NULL;

    return (LPSTR)LocalFree(pAnsiString);
}


/***************************** Function Header ******************************
 * AllocateAnsiDevMode
 *      Allocate an ANSI version of the DEVMODE structure, and optionally
 *      copy the contents of the ANSI version passed in.
 *
 * RETURNS:
 *      Address of newly allocated structure, 0 if storage not available.
 *
 * HISTORY:
 * 09:23 on 10-Aug-92 -by- Lindsay Harris [lindsayh]
 *      Made it usable.
 *
 * Originally "written" by DaveSn.
 *
 ***************************************************************************/

LPDEVMODEA
AllocateAnsiDevMode(
    LPDEVMODEW pUNICODEDevMode
    )
{
    LPDEVMODEA  pAnsiDevMode;
    LPBYTE      p1, p2;
    DWORD       dwSize;

    //
    // If the devmode is NULL, then return NULL -- KrishnaG
    //
    if ( !pUNICODEDevMode || !pUNICODEDevMode->dmSize ) {
        return NULL;
    }

    ASSERT( bValidDevModeW( pUNICODEDevMode ));

    //
    // Determine output structure size.  This has two components:  the
    // DEVMODEW structure size,  plus any private data area.  The latter
    // is only meaningful when a structure is passed in.
    //
    dwSize = pUNICODEDevMode->dmSize + pUNICODEDevMode->dmDriverExtra
                                  + sizeof(DEVMODEA) - sizeof(DEVMODEW);

    pAnsiDevMode = (LPDEVMODEA) LocalAlloc(LPTR, dwSize);

    if( !pAnsiDevMode ) {
        return NULL;                   /* This is bad news */
    }

    //
    // Copy dmDeviceName which is a string
    //
    UnicodeToAnsiString(pUNICODEDevMode->dmDeviceName,
                        (LPSTR)(pAnsiDevMode->dmDeviceName),
                        ComputeMaxStrlenW(pUNICODEDevMode->dmDeviceName,
                                     sizeof pUNICODEDevMode->dmDeviceName));

    //
    // Does the devmode we got have a dmFormName? (Windows 3.1 had
    // DevMode of size 40 and did not have dmFormName)
    //
    if ( (LPBYTE)pUNICODEDevMode + pUNICODEDevMode->dmSize >
                                    (LPBYTE) pUNICODEDevMode->dmFormName ) {

        //
        // Copy everything between dmDeviceName and dmFormName
        //
        p1      = (LPBYTE) pUNICODEDevMode->dmDeviceName +
                                    sizeof(pUNICODEDevMode->dmDeviceName);
        p2      = (LPBYTE) pUNICODEDevMode->dmFormName;


        CopyMemory((LPBYTE) pAnsiDevMode->dmDeviceName +
                            sizeof(pAnsiDevMode->dmDeviceName),
                   p1,
                   p2 - p1);

        //
        // Copy dmFormName which is a string
        //
        UnicodeToAnsiString(pUNICODEDevMode->dmFormName,
                            (LPSTR)(pAnsiDevMode->dmFormName),
                            ComputeMaxStrlenW(pUNICODEDevMode->dmFormName,
                                         sizeof pUNICODEDevMode->dmFormName));

        //
        // Copy everything after dmFormName
        //
        p1      = (LPBYTE) pUNICODEDevMode->dmFormName +
                                sizeof(pUNICODEDevMode->dmFormName);
        p2      = (LPBYTE) pUNICODEDevMode + pUNICODEDevMode->dmSize
                                        + pUNICODEDevMode->dmDriverExtra;

        CopyMemory((LPBYTE) pAnsiDevMode->dmFormName +
                                sizeof(pAnsiDevMode->dmFormName),
                    p1,
                    p2 - p1);

        pAnsiDevMode->dmSize = pUNICODEDevMode->dmSize + sizeof(DEVMODEA)
                                                       - sizeof(DEVMODEW);
    } else {

        //
        // Copy everything after dmDeviceName
        //
        p1 = (LPBYTE) pUNICODEDevMode->dmDeviceName +
                                    sizeof(pUNICODEDevMode->dmDeviceName);
        p2 = (LPBYTE) pUNICODEDevMode + pUNICODEDevMode->dmSize + pUNICODEDevMode->dmDriverExtra;

        CopyMemory((LPBYTE) pAnsiDevMode->dmDeviceName +
                            sizeof(pAnsiDevMode->dmDeviceName),
                   p1,
                   p2-p1);

        pAnsiDevMode->dmSize = pUNICODEDevMode->dmSize
                                        + sizeof(pAnsiDevMode->dmDeviceName)
                                        - sizeof(pUNICODEDevMode->dmDeviceName);
    }

    ASSERT(pAnsiDevMode->dmDriverExtra == pUNICODEDevMode->dmDriverExtra);


    return pAnsiDevMode;
}

/************************** Function Header ******************************
 * CopyUnicodeDevModeFromAnsiDevMode
 *      Converts the ANSI version of the DEVMODE to the UNICODE version.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 * 09:57 on 10-Aug-92  -by-  Lindsay Harris [lindsayh]
 *      This one actually works!
 *
 * Originally dreamed up by DaveSn.
 *
 **************************************************************************/

void
CopyUnicodeDevModeFromAnsiDevMode(
    LPDEVMODEW  pUNICODEDevMode,              /* Filled in by us */
    LPDEVMODEA  pAnsiDevMode            /* Source of data to fill above */
)
{
    LPBYTE  p1, p2, pExtra;
    WORD    dmSize, dmDriverExtra;

    //
    // NOTE:    THE TWO INPUT STRUCTURES MAY BE THE SAME.
    //
    dmSize          = pAnsiDevMode->dmSize;
    dmDriverExtra   = pAnsiDevMode->dmDriverExtra;
    pExtra          = (LPBYTE) pAnsiDevMode + pAnsiDevMode->dmSize;

    //
    // Copy dmDeviceName which is a string
    //
    AnsiToUnicodeString((LPSTR)(pAnsiDevMode->dmDeviceName),
                        (pUNICODEDevMode->dmDeviceName),
                        ComputeMaxStrlenA((LPSTR)(pAnsiDevMode->dmDeviceName),
                                     sizeof pUNICODEDevMode->dmDeviceName));

    //
    // Does the devmode we got have a dmFormName? (Windows 3.1 had
    // DevMode of size 40 and did not have dmFormName)
    //
    if ( (LPBYTE)pAnsiDevMode + dmSize >
                                    (LPBYTE) pAnsiDevMode->dmFormName ) {

        //
        // Copy everything between dmDeviceName and dmFormName
        //
        p1      = (LPBYTE) pAnsiDevMode->dmDeviceName +
                                    sizeof(pAnsiDevMode->dmDeviceName);
        p2      = (LPBYTE) pAnsiDevMode->dmFormName;

        MoveMemory((LPBYTE) pUNICODEDevMode->dmDeviceName +
                                sizeof(pUNICODEDevMode->dmDeviceName),
                    p1,
                    p2 - p1);

        //
        // Copy dmFormName which is a string
        //
        AnsiToUnicodeString((LPSTR)(pAnsiDevMode->dmFormName),
                            pUNICODEDevMode->dmFormName,
                            ComputeMaxStrlenA((LPSTR)pAnsiDevMode->dmFormName,
                                         sizeof pUNICODEDevMode->dmFormName));

        //
        // Copy everything after dmFormName
        //
        p1      = (LPBYTE) pAnsiDevMode->dmFormName +
                                sizeof(pAnsiDevMode->dmFormName);
        p2      = (LPBYTE) pAnsiDevMode + dmSize + dmDriverExtra;

        MoveMemory((LPBYTE) pUNICODEDevMode->dmFormName +
                                sizeof(pUNICODEDevMode->dmFormName),
                    p1,
                    p2 - p1);


        pUNICODEDevMode->dmSize = dmSize + sizeof(DEVMODEW) - sizeof(DEVMODEA);
    } else {

        //
        // Copy everything after dmDeviceName
        //
        p1      = (LPBYTE) pAnsiDevMode->dmDeviceName +
                                sizeof(pAnsiDevMode->dmDeviceName);
        p2      = (LPBYTE) pAnsiDevMode + dmSize + dmDriverExtra;

        MoveMemory((LPBYTE) pUNICODEDevMode->dmDeviceName +
                                sizeof(pUNICODEDevMode->dmDeviceName),
                   p1,
                   p2 - p1);


        pUNICODEDevMode->dmSize = dmSize + sizeof(pUNICODEDevMode->dmDeviceName)
                                      - sizeof(pAnsiDevMode->dmDeviceName);
    }

    ASSERT(pUNICODEDevMode->dmDriverExtra == dmDriverExtra);

    return;
}

void
ConvertAnsiToUnicodeStrings(
    LPBYTE  pStructure,
    LPDWORD pOffsets
)
{
    register DWORD  i=0;
    LPSTR           pAnsi;
    LPWSTR          pUnicode;

    while (pOffsets[i] != -1) {
        pAnsi = *(LPSTR *)(pStructure+pOffsets[i]);
        if (pAnsi) {
            pUnicode = (LPWSTR)LocalAlloc( LPTR, 
                                           strlen(pAnsi)*sizeof(WCHAR)+
                                                sizeof(WCHAR));
            if (pUnicode) {
                AnsiToUnicodeString(pAnsi, 
                                    pUnicode, 
                                    NULL_TERMINATED);
                *(LPWSTR *)(pStructure+pOffsets[i]) = pUnicode;
                LocalFree(pAnsi);
            }
        }
        i++;
    }
}

LPBYTE
AllocateAnsiStructure(
    LPBYTE  pUnicodeStructure,
    DWORD   cbStruct,
    LPDWORD pOffsets
)
{
    DWORD   i, j;
    LPSTR   *ppAnsiString;
    LPWSTR  *ppUnicodeString;
    LPBYTE  pAnsiStructure;


    if (!pUnicodeStructure) {
        return NULL;
    }
    pAnsiStructure = (LPBYTE)LocalAlloc(LPTR, cbStruct);

    if (pAnsiStructure) {

        memcpy(pAnsiStructure, pUnicodeStructure, cbStruct);

        for (i = 0 ; pOffsets[i] != -1 ; ++i) {

            ppUnicodeString = (LPWSTR *)(pUnicodeStructure+pOffsets[i]);
            ppAnsiString = (LPSTR *)(pAnsiStructure+pOffsets[i]);

            *ppAnsiString = AllocateAnsiString(*ppUnicodeString);

            if (*ppUnicodeString && !*ppAnsiString) {

                for( j = 0 ; j < i ; ++j) {
                    ppAnsiString = (LPSTR *)(pAnsiStructure+pOffsets[j]);
                    FreeAnsiString(*ppAnsiString);
                }
                LocalFree(pAnsiStructure);
                pAnsiStructure = NULL;
                break;
            }
       }
    }

    return pAnsiStructure;
}

void
FreeAnsiStructure(
    LPBYTE  pAnsiStructure,
    LPDWORD pOffsets
)
{
    DWORD   i=0;

    if ( pAnsiStructure == NULL ) {
        return;
    }

    while (pOffsets[i] != -1) {

        FreeAnsiString(*(LPSTR *)(pAnsiStructure+pOffsets[i]));
        i++;
    }

    LocalFree( pAnsiStructure );
}


BOOL
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, cbStruct, *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1StringsA;
        cbStruct = sizeof(JOB_INFO_1W);
        break;

    case 2:
        pOffsets = JobInfo2StringsA;
        cbStruct = sizeof(JOB_INFO_2W);
        break;

    case 3:
        return EnumJobsA( hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf, pcbNeeded, pcReturned );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (EnumJobsA(hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf, pcbNeeded,
                 pcReturned)) {

        i=*pcReturned;

        while (i--) {

            ConvertAnsiToUnicodeStrings(pJob, pOffsets);

            //
            // Convert the devmode in place for INFO_2.
            //
            if( Level == 2 ){

                PJOB_INFO_2W pJobInfo2 = (PJOB_INFO_2W)pJob;

                if( pJobInfo2->pDevMode ){
                    CopyUnicodeDevModeFromAnsiDevMode(
                        (LPDEVMODEW)pJobInfo2->pDevMode,
                        (LPDEVMODEA)pJobInfo2->pDevMode);
                }
            }

            pJob += cbStruct;
        }

        return TRUE;

    } else

        return FALSE;
}

BOOL
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD   *pOffsets;

    switch (Level) {

    //case STRESSINFOLEVEL:
    //    pOffsets = PrinterInfoStressOffsetsA;
    //    break;

    case 1:
        pOffsets = PrinterInfo1StringsA;
        break;

    case 2:
        pOffsets = PrinterInfo2StringsA;
        break;

    case 3:
        pOffsets = PrinterInfo3StringsA;
        break;

    case 4:
        pOffsets = PrinterInfo4StringsA;
        break;

    case 5:
        pOffsets = PrinterInfo5StringsA;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (GetPrinterA(hPrinter, Level, pPrinter, cbBuf, pcbNeeded)) {

        if (pPrinter) {

            ConvertAnsiToUnicodeStrings(pPrinter, pOffsets);

            if ((Level == 2) && pPrinter) {

                PRINTER_INFO_2W *pPrinterInfo2 = (PRINTER_INFO_2W *)pPrinter;

                if (pPrinterInfo2->pDevMode)
                    CopyUnicodeDevModeFromAnsiDevMode(
                                        (LPDEVMODEW)pPrinterInfo2->pDevMode,
                                        (LPDEVMODEA)pPrinterInfo2->pDevMode);
            }
        }

        return TRUE;
    }

    return FALSE;
}

BOOL
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
)
{
    LPBYTE  pAnsiStructure;         /* Ansi version of input data */
    DWORD   cbStruct;                  /* Size of the output structure */
    DWORD  *pOffsets;                  /* -1 terminated list of addresses */
    DWORD   ReturnValue=FALSE;

    switch (Level) {

    case 0:
        //
        // This could be 2 cases. STRESSINFOLEVEL, or the real 0 level.
        // If Command is 0 then it is STRESSINFOLEVEL, else real 0 level
        //
        /*
                if ( !Command ) {

            pOffsets = PrinterInfoStressStringsA;
            cbStruct = sizeof( PRINTER_INFO_STRESSA );
        }
                */
        break;

    case 1:
        pOffsets = PrinterInfo1StringsA;
        cbStruct = sizeof( PRINTER_INFO_1W );
        break;

    case 2:
        pOffsets = PrinterInfo2StringsA;
        cbStruct = sizeof( PRINTER_INFO_2W );
        break;

    case 3:
        pOffsets = PrinterInfo3StringsA;
        cbStruct = sizeof( PRINTER_INFO_3);
        break;

    case 4:
        pOffsets = PrinterInfo4StringsA;
        cbStruct = sizeof( PRINTER_INFO_4W );
        break;

    case 5:
        pOffsets = PrinterInfo5StringsA;
        cbStruct = sizeof( PRINTER_INFO_5W );
        break;

    case 6:
        break;

    default:
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

     //
     //    The structure needs to have its CONTENTS converted from
     //  ANSI to Unicode.  The above switch() statement filled in
     //  the two important pieces of information needed to accomplish
     //  this goal.  First is the size of the structure, second is
     //  a list of the offset within the structure to UNICODE
     //  string pointers.  The AllocateUnicodeStructure() call will
     //  allocate a wide version of the structure, copy its contents
     //  and convert the strings to Unicode as it goes.  That leaves
     //  us to deal with any other pieces needing conversion.
     //

    //
    // If Level == 0 and Command != 0 then pPrintert is a DWORD
    //
    if ( Level == 6 || (!Level && Command) ) {

        if ( Level == 6 || Command == PRINTER_CONTROL_SET_STATUS )
            pAnsiStructure = pPrinter;
        else
            pAnsiStructure = NULL;
    } else {

        pAnsiStructure = AllocateAnsiStructure(pPrinter, cbStruct, pOffsets);
        if (pPrinter && !pAnsiStructure)
            return FALSE;
    }

#define pPrinterInfo2A  ((LPPRINTER_INFO_2A)pAnsiStructure)
#define pPrinterInfo2W  ((LPPRINTER_INFO_2W)pPrinter)

    //  The Level 2 structure has a DEVMODE struct in it: convert now

    if ( Level == 2  &&
         pAnsiStructure &&
         pPrinterInfo2W->pDevMode ) {

        if( bValidDevModeW( pPrinterInfo2W->pDevMode )){
            pPrinterInfo2A->pDevMode = AllocateAnsiDevMode(
                                           pPrinterInfo2W->pDevMode );

            if( !pPrinterInfo2A->pDevMode) {
                FreeAnsiStructure(pAnsiStructure, pOffsets);
                return FALSE;
            }
        }
    }

    ReturnValue = SetPrinterA( hPrinter, Level, pAnsiStructure, Command );


    //  Free the DEVMODE we allocated (if we did!), then the
    //  the Unicode structure and its contents.


    if (Level == 2 &&
        pAnsiStructure &&
        pPrinterInfo2A->pDevMode ) {

        LocalFree( pPrinterInfo2A->pDevMode );
    }

    //
    // STRESS_INFO and Levels 1-5
    //
    if ( Level != 6 && (Level || !Command) )
        FreeAnsiStructure( pAnsiStructure, pOffsets );

#undef pPrinterInfo2A
#undef pPrinterInfo2W
    
        return ReturnValue;
}

BOOL
SetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)
{
    BOOL        ReturnValue=FALSE;
    LPBYTE      pAnsiStructure=NULL;
    LPDEVMODEA  pDevModeA = NULL;
    DWORD       cbStruct;
    DWORD       *pOffsets;

    switch (Level) {

    case 0:
        break;

    case 1:
        pOffsets = JobInfo1StringsA;
        cbStruct = sizeof(JOB_INFO_1W);
        break;

    case 2:
        pOffsets = JobInfo2StringsA;
        cbStruct = sizeof(JOB_INFO_2W);
        break;

    case 3:
        return SetJobA( hPrinter, JobId, Level, pJob, Command );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }


    if (Level) {
        pAnsiStructure = AllocateAnsiStructure(pJob, cbStruct, pOffsets);
        if (pJob && !pAnsiStructure)
            return FALSE;
    }

    if ( Level == 2 && pAnsiStructure && pJob ) {

        if( bValidDevModeW( ((LPJOB_INFO_2W)pJob)->pDevMode )){

            pDevModeA = AllocateAnsiDevMode(((LPJOB_INFO_2W)pJob)->pDevMode);

            if( !pDevModeA ){
                ReturnValue = FALSE;
                goto Cleanup;
            }
            ((LPJOB_INFO_2A) pAnsiStructure)->pDevMode = pDevModeA;
        }
    }

    ReturnValue = SetJobA(hPrinter, JobId, Level, pAnsiStructure, Command);

    if ( pDevModeA ) {

        LocalFree(pDevModeA);
    }

Cleanup:
    FreeAnsiStructure(pAnsiStructure, pOffsets);

    return ReturnValue;
}

BOOL
GetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD *pOffsets;
    LPBYTE pJobA = NULL;
    DWORD cbNeededA = 0;
    DWORD cbBufA = 0;
    DWORD dwJobStructSizeW = 0;
    DWORD dwJobStructSizeA = 0;
    BOOL fRetval;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1StringsA;
        dwJobStructSizeW = sizeof(JOB_INFO_1W);
        dwJobStructSizeA = sizeof(JOB_INFO_1A);
        break;

    case 2:
        pOffsets = JobInfo2StringsA;
        dwJobStructSizeW = sizeof(JOB_INFO_2W);
        dwJobStructSizeA = sizeof(JOB_INFO_2A);
        break;

    case 3:
        return GetJobA( hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }


    //
    // GetJobA is broken. THis is a workaround here which will work 
    // sometimes. The AV problem however goes away.
    //
    // Ramv bug fix: The user has passed in a certain amount of 
    // unicode memory. This has to be appropriately translated into
    // equivalent ANSI memory.
    //
    //
    // The translation is to take the entire blob of memory and
    // subtract sizeof(JOB_INFO_2W) and then divide the remaining memory
    // into 2. 
    //
    // we also have to contend with GetJobA's erroneous return values
    // when we pass in a buffer of sixe 0, it gives back wrong results
    //
    //
    //

    cbBufA = cbBuf > dwJobStructSizeW ?  
        (cbBuf-dwJobStructSizeW)/sizeof(WCHAR) + dwJobStructSizeA : 64;


    pJobA = (LPBYTE)AllocADsMem( cbBufA);
    
    if (!pJobA){
        goto error;
    }
    
    
    fRetval = GetJobA (hPrinter, JobId, Level, pJobA, cbBufA, &cbNeededA);

    if ( fRetval) {
        
        //
        // RamV bug fix.
        // The size that we get back is actually the size of
        // the ANSI array needed. We need our array to be larger for 
        // unicode by an amount = (total lengths of all strings +1)
        // times the sizeof(WCHAR)
        //
        
        
        //
        // Looks like we have sufficient memory here for our operations
        // we need to copy the memory blob from Ansi to Unicode
        //
        
        
        // 
        // Thanks to win95 returning erroneous values, we are forced
        // to fail this call even though it succeeded and send back 
        // the cbNeededA value converted into the Unicode value
        //

        if (cbBuf == 0){
            *pcbNeeded = 2*cbNeededA; // just being conservative here by
            
            // allocating a little more space than needed

            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto error;
        }

        if (!ConvertAnsiToUnicodeBuf(
            pJobA, 
            pJob,
            dwJobStructSizeA,
            dwJobStructSizeW,
            pOffsets)){
            
            goto error;
        }
        
        //
        // Convert the devmode in place for INFO_2.
        //
        if( Level == 2 ){
            
            PJOB_INFO_2W pJobInfo2 = (PJOB_INFO_2W)pJob;
            
            if( pJobInfo2->pDevMode ){
                CopyUnicodeDevModeFromAnsiDevMode(
                    (LPDEVMODEW)pJobInfo2->pDevMode,
                    (LPDEVMODEA)pJobInfo2->pDevMode);
            }
        }
        
        return TRUE;
        
        } else {
      
            //
            // RamV bug fix.
            // The size that we get back is actually the size of
            // the ANSI array needed. We need our array to be larger for 
            // unicode by an amount = (total lengths of all strings +1)
            // times the sizeof(WCHAR)
            //
            
            if(cbNeededA) {
                //
                // we need to translate this into unicode terms
                //
                
                *pcbNeeded = dwJobStructSizeW + 
                    (cbBufA + cbNeededA - dwJobStructSizeA)*sizeof(WCHAR);
            }
            
            return FALSE;
        }
    
error: 
    if(pJobA) {
        FreeADsMem(pJobA);
    }

    return FALSE;
}



BOOL
ConvertAnsiToUnicodeBuf(
    LPBYTE pAnsiBlob,
    LPBYTE pUnicodeBlob,
    DWORD dwAnsiSize,
    DWORD dwUnicodeSize,
    PDWORD pOffsets
    )

{
    DWORD i = 0;
    LPSTR pAnsi;
    LPBYTE pUnicode;
    LPBYTE pszString = pUnicodeBlob + dwUnicodeSize;
    LPBYTE pStringPos = NULL;

    memcpy(pUnicodeBlob, pAnsiBlob, dwAnsiSize);

    pUnicode = pszString;
    while (pOffsets[i] != -1) {
        pAnsi = *(LPSTR *)(pAnsiBlob + pOffsets[i]);

        if (!AnsiToUnicodeString((LPSTR)pAnsi,
                                 (LPWSTR)pUnicode,
                                 NULL_TERMINATED )){
            return(FALSE);
        }

        pStringPos = pUnicodeBlob +pOffsets[i];

        *((LPBYTE *)pStringPos) = pUnicode;

        pUnicode = pUnicode + (wcslen((LPWSTR)(pUnicode))+1)* sizeof(WCHAR);
        
        i++;
    }
    
    return(TRUE);

}

    

    

BOOL
OpenPrinterW(
    LPWSTR pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTSW pDefault
    )
{
    BOOL ReturnValue = FALSE;
    LPSTR pAnsiPrinterName = NULL;
    PRINTER_DEFAULTSA AnsiDefaults={NULL, NULL, 0};

    pAnsiPrinterName = AllocateAnsiString(pPrinterName);
    
        if (pPrinterName && !pAnsiPrinterName)
        goto Cleanup;

    if (pDefault) {

        AnsiDefaults.pDatatype = AllocateAnsiString(pDefault->pDatatype);
        if (pDefault->pDatatype && !AnsiDefaults.pDatatype)
            goto Cleanup;

        //
        // Milestones etc. 4.5 passes in a bogus devmode in pDefaults.
        // Be sure to validate here.
        //
        if( bValidDevModeW( pDefault->pDevMode )){

            AnsiDefaults.pDevMode = AllocateAnsiDevMode(
                                           pDefault->pDevMode );

            if( !AnsiDefaults.pDevMode ){
                goto Cleanup;
            }
        }

        AnsiDefaults.DesiredAccess = pDefault->DesiredAccess;
    }

    ReturnValue = OpenPrinterA(pAnsiPrinterName, phPrinter, &AnsiDefaults);

/*  Ramv This code below causes AV. I have disabled it
    MattRim 1-10-00: Leaving this disabled.  phPrinter is an opaque handle
    to an undocumented structure.  Trying to manipulate it is a surefire way
    to cause AVs if a service pack/O.S. upgrade ever changes the implementation
    of this Win9x-internal structure.
    if (ReturnValue) {

        ((PSPOOL)*phPrinter)->Status |= SPOOL_STATUS_ANSI;
    }

    */


Cleanup:

    if (AnsiDefaults.pDevMode)
        LocalFree(AnsiDefaults.pDevMode);

    FreeAnsiString(AnsiDefaults.pDatatype);
    FreeAnsiString(pAnsiPrinterName);

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\adsdsrc.h ===
#ifndef  _ADSDATASOURCE_H_
#define  _ADSDATASOURCE_H_

//#define  ROWS  10L
#define  ROWS  1L

typedef  struct _tagSEARCHPREF
{
   TCHAR szSource       [ MAX_PATH ];
   TCHAR szQuery        [ 2048 ];
   TCHAR szAttributes   [ MAX_PATH ];
   TCHAR szScope        [ MAX_PATH ];
   TCHAR szUserName     [ 2 * MAX_PATH ];
   TCHAR szPassword     [ MAX_PATH ];
   BOOL  bEncryptPassword;
   BOOL  bUseSQL;
   int   nAsynchronous;
   int   nDerefAliases;
   int   nSizeLimit;
   int   nTimeLimit;
   int   nAttributesOnly;
   int   nScope;
   int   nTimeOut;
   int   nPageSize;
   int   nChaseReferrals;
}  SEARCHPREF;

class CADsDataSource: public CObject
{
   public:
      CADsDataSource( );
      ~CADsDataSource( );

   public:
      /*void     SetQueryParameters( CString& strSource,
                                   CString& strQuery,
                                   CString& strAttributes,
                                   CString& strScope,
                                   CString& strUserName,
                                   CString& strPassword,
                                   BOOL bEncryptPassword,
                                   BOOL bUseSQL );*/

      void     SetQueryParameters( SEARCHPREF* pSerachPref );

      virtual  int   GetColumnsCount   ( int nRow );
      virtual  BOOL  GetValue          ( int nRow, int nColumn, CString& );
      virtual  BOOL  GetValue          ( int nRow, CString& strColumn, CString& );
      virtual  BOOL  GetADsPath        ( int nRow, CString& );
      virtual  BOOL  GetColumnText     ( int nRow, int nColumn, CString& );
               BOOL  Refresh           ( void );
      virtual  BOOL  RunTheQuery       ( void );

   protected:
      DBORDINAL      m_nColumnsCount;
      int            m_nAddOne;

      BOOL           m_bNoQuery;
      BOOL           m_bNoMoreData;

      int            m_nFirstRow;
      int            m_nLastRow;
      int            m_nCurrentRow;

      ULONG          m_cRows;
      ULONG          m_cColumns;
      CString        m_strAttributes;

      /*CString        m_strSource;
      CString        m_strQuery;
      CString        m_strScope;
      CString        m_strPassword;
      CString        m_strUserName;
      BOOL           m_bEncryptPassword;
      BOOL           m_bUseSQL;*/

      CStringArray   m_ADsPath;
      SEARCHPREF*    m_pSearchPref;
};


/*typedef struct tagData {
    void          *obValue;
    DATE          dateValue;
    ULONG         obLength;
    LARGE_INTEGER aLargeInteger;
    ULONG         status;
} Data;*/

typedef struct tagData {
    union {
        void *obValue;
        double obValue2;
    };
    ULONG obLength;
    ULONG status;
} Data;


class CADsOleDBDataSource: public CADsDataSource
{
   public:
      CADsOleDBDataSource( );
      ~CADsOleDBDataSource( );

   public:
      HRESULT  SetQueryCredentials( IDBInitialize* pInit, ICommandText* pCommand );

      virtual  int   GetColumnsCount   ( int nRow );
      virtual  BOOL  GetValue          ( int nRow, int nColumn, CString& );
      virtual  BOOL  GetADsPath        ( int nRow, CString& );
      virtual  BOOL  GetColumnText     ( int nRow, int nColumn, CString& );
      virtual  BOOL  RunTheQuery       ( void );

   private:
      void     DestroyInternalData  ( void );
      BOOL     AdvanceCursor        ( void );
      BOOL     CreateAccessorHelp   ( void );
      BOOL     BringRowInBuffer     ( int nRow );
      CString  ExtractData          ( int );
      void     ReadADsPath          ( void );

      private:
      Data*          m_pData;

      IRowset*       m_pIRowset;
      IMalloc*       m_pIMalloc;
      IAccessor*     m_pAccessor;
      IColumnsInfo*  m_pIColsInfo;
      HROW*          m_hRows;

      HACCESSOR      m_hAccessor;
      DBCOLUMNINFO*  m_prgColInfo;
      DBBINDSTATUS*  m_pBindStatus;
      OLECHAR*       m_szColNames;
};

class CADsSearchDataSource: public CADsDataSource
{
   public:
      CADsSearchDataSource( );
      ~CADsSearchDataSource( );

   public:
      virtual  int   GetColumnsCount   ( int nRow );
      virtual  BOOL  GetValue          ( int nRow, int nColumn, CString& );
      virtual  BOOL  GetValue          ( int nRow, CString& rColumn, CString& );
      virtual  BOOL  GetADsPath        ( int nRow, CString& );
      virtual  BOOL  GetColumnText     ( int nRow, int nColumn, CString& );
      virtual  BOOL  RunTheQuery       ( void );

   private:
      void     DestroyInternalData  ( void );
      HRESULT  CreateSearchInterface( );
      BOOL     BringRowInBuffer     ( int nRow );
      BOOL     ReadColumnNames      ( int nRow );
      HRESULT  SetQueryPreferences  ( );
      HRESULT  SetSearchPreferences ( );
      HRESULT  SetAttributesName    ( );
      void     ReadADsPath          ( void );

   private:
      IDirectorySearch*        m_pSearch;
      ADS_SEARCH_HANDLE m_hSearch;
      CStringArray      m_strColumns;
      /*BOOL              m_bAsynchronous;     //ADS_SEARCHPREF_ASYNCHRONOUS
      BOOL              m_bDerefAliases;     //ADS_SEARCHPREF_DEREF_ALIASES
      int               m_nSizeLimit;        //ADS_SEARCHPREF_SIZE_LIMIT
	   int               m_nTimeLimit;        //ADS_SEARCHPREF_TIME_LIMIT
	   BOOL              m_bAttributesOnly;   //ADS_SEARCHPREF_ATTRIBTYPES_ONLY
	   CString           m_strScope;          //ADS_SEARCHPREF_SEARCH_SCOPE
      int               m_nTimeOut;          //ADS_SEARCHPREF_TIMEOUT
      int               m_nPageSize;	      //ADS_SEARCHPREF_PAGESIZE*/
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsiid\guid.c ===
#define INITGUID

#include "dswarn.h"
#include <ole2.h>

//--------------------------------------------------------------------------
//
//  ADs CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(LIBID_ADs,0x97D25DB0L,0x0363,0x11CF,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADs,0xFD8256D0L,0xFD15,0x11CE,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADsContainer,0x001677D0L,0xFD16,0x11CE,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADsNamespaces,0x28B96BA0L,0xB330,0x11CF,0xA9,0xAD,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsDomain,0x00E4C220L,0xFD16,0x11CE,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);


DEFINE_GUID(IID_IADsUser,0x3E37E320L,0x17E2,0x11CF,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);



DEFINE_GUID(IID_IADsComputerOperations,0xEF497680L,0x1D9F,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADsComputer,0xEFE3CC70L,0x1D9F,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);


DEFINE_GUID(IID_IADsGroup,0x27636B00L,0x410F,0x11CF,0xB1,0xFF,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADsMembers,0x451A0030L,0x72EC,0x11CF,0xB0,0x3B,0x00,0xAA,0x00,0x6E,0x09,0x75);


DEFINE_GUID(IID_IADsPrintQueue,0xB15160D0L,0x1226,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsPrintQueueOperations,0x124BE5C0L,0x156E,0x11CF,0xA9,0x86,0x00,0xAA,0x00,0x6B,0xC1,0x49);



DEFINE_GUID(IID_IADsPrintJobOperations,0x9A52DB30L,0x1ECF,0x11CF,0xA9,0x88,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsPrintJob,0x32FB6780L,0x1ED0,0x11CF,0xA9,0x88,0x00,0xAA,0x00,0x6B,0xC1,0x49);


DEFINE_GUID(IID_IADsCollection,0x72B945E0L,0x253B,0x11CF,0xA9,0x88,0x00,0xAA,0x00,0x6B,0xC1,0x49);



DEFINE_GUID(IID_IADsServiceOperations,0x5D7B33F0L,0x31CA,0x11CF,0xA9,0x8A,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsService,0x68AF66E0L,0x31CA,0x11CF,0xA9,0x8A,0x00,0xAA,0x00,0x6B,0xC1,0x49);



DEFINE_GUID(IID_IADsFileServiceOperations,0xA02DED10L,0x31CA,0x11CF,0xA9,0x8A,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsFileService,0xA89D1900L,0x31CA,0x11CF,0xA9,0x8A,0x00,0xAA,0x00,0x6B,0xC1,0x49);



DEFINE_GUID(IID_IADsResource,0x34A05B20L,0x4AAB,0x11CF,0xAE,0x2C,0x00,0xAA,0x00,0x6E,0xBF,0xB9);



DEFINE_GUID(IID_IADsSession,0x398B7DA0L,0x4AAB,0x11CF,0xAE,0x2C,0x00,0xAA,0x00,0x6E,0xBF,0xB9);


DEFINE_GUID(IID_IADsFileShare,0xEB6DCAF0L,0x4B83,0x11CF,0xA9,0x95,0x00,0xAA,0x00,0x6B,0xC1,0x49);


DEFINE_GUID(IID_IADsClass, 0xC8F93DD0L, 0x4AE0, 0x11CF, 0x9E, 0x73, 0x00, 0xAA, 0x00, 0x4A, 0x56, 0x91);

DEFINE_GUID(IID_IADsSyntax, 0xC8F93DD2L, 0x4AE0, 0x11CF, 0x9E, 0x73, 0x00, 0xAA, 0x00, 0x4A, 0x56, 0x91);

DEFINE_GUID(IID_IADsProperty, 0xC8F93DD3L, 0x4AE0, 0x11CF, 0x9E, 0x73, 0x00, 0xAA, 0x00, 0x4A, 0x56, 0x91);

DEFINE_GUID(IID_IADsLocality,0xA05E03A2L,0xEFFE,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(IID_IADsO,0xA1CD2DC6L,0xEFFE,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(IID_IADsOU,0xA2F733B8L,0xEFFE,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(IID_IADsOpenDSObject,0xddf2891e,0x0f9c,0x11d0,0x8a,0xd4,0x00,0xc0,0x4f,0xd8,0xd5,0x03);

DEFINE_GUID(IID_IDirectoryObject,0xe798de2c,0x22e4,0x11d0,0x84,0xfe,0x00,0xc0,0x4f,0xd8,0xd5,0x03);

DEFINE_GUID(IID_IDirectorySearch,0x109ba8ec,0x92f0,0x11d0,0xa7,0x90,0x00,0xc0,0x4f,0xd8,0xd5,0xa8);


DEFINE_GUID(IID_IDirectorySchemaMgmt, 0x75db3b9c, 0xa4d8, 0x11d0, 0xa7, 0x9c, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xa8);


DEFINE_GUID(IID_IADsSearch, 0xC69F7780L, 0x4008, 0x11D0, 0xB9, 0x4C, 0x00, 0xC0, 0x4F, 0xD8, 0xD5, 0xA8);

DEFINE_GUID(IID_IADsPropertyList, 0xc6f602b6,0x8f69,0x11d0, 0x85, 0x28, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0x03);

DEFINE_GUID(IID_IADsObjectOptions, 0x46f14fda,0x232b,0x11d1, 0xa8, 0x08, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xa8);

DEFINE_GUID(IID_IADsObjOptPrivate, 0x81cbb829,0x1867,0x11d2, 0x92, 0x20, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1);

const IID IID_IADsPropertyEntry = {0x05792c8e,0x941f,0x11d0,{0x85,0x29,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_PropertyEntry = {0x72d3edc2,0xa4c4,0x11d0,{0x85,0x33,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const IID IID_IADsAccessControlEntry = {0xb4f3a14c,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_AccessControlEntry = {0xb75ac000,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const IID IID_IADsAccessControlList = {0xb7ee91cc,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_AccessControlList = {0xb85ea052,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const IID IID_IADsSecurityDescriptor = {0xb8c787ca,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_SecurityDescriptor = {0xb958f73c,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IADsPropertyValue = {0x79fa9ad0,0xa97c,0x11d0,{0x85,0x34,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_PropertyValue = {0x7b9e38b0,0xa97c,0x11d0,{0x85,0x34,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IADsPropertyValue2 = {0x306e831c,0x5bc7,0x11d1,{0xa3,0xb8,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

const IID IID_IADsValue = {0x1e3ef0aa,0xaef5,0x11d0,{0x85,0x37,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IADsPathname = {0xd592aed4,0xf420,0x11d0,{0xa3,0x6e,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};
const IID IID_IADsPathnameProvider = {0xaacd1d30,0x8bd0,0x11d2,{0x92, 0xa9, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x34}};


const CLSID CLSID_Pathname = {0x080d0d78,0xf421,0x11d0,{0xa3,0x6e,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

const IID IID_IADsADSystemInfo = {0x5BB11929, 0xAFD1, 0x11d2, {0x9C, 0xB9, 0x00, 0x00, 0xF8, 0x7A, 0x36, 0x9E}};
const CLSID CLSID_ADSystemInfo = {0x50B6327F, 0xAFD1, 0x11d2, {0x9C, 0xB9, 0x00, 0x00, 0xF8, 0x7A, 0x36, 0x9E}};

const IID IID_IADsWinNTSystemInfo = {0x6C6D65DC, 0xAFD1, 0x11d2, {0x9C, 0xB9, 0x00, 0x00, 0xF8, 0x7A, 0x36, 0x9E}};
const CLSID CLSID_WinNTSystemInfo = {0x66182EC4, 0xAFD1, 0x11d2, {0x9C, 0xB9, 0x00, 0x00, 0xF8, 0x7A, 0x36, 0x9E}};

const IID IID_IADsDNWithString = {0x370df02e, 0xf934, 0x11d2, {0xba, 0x96, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1}};
const CLSID CLSID_DNWithString = {0x334857cc, 0xf934, 0x11d2, {0xba, 0x96, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1}};

const IID IID_IADsDNWithBinary = {0x7e99c0a2, 0xf935, 0x11d2, {0xba, 0x96, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1}};
const CLSID CLSID_DNWithBinary = {0x7e99c0a3, 0xf935, 0x11d2, {0xba, 0x96, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1}};

const IID IID_IADsNameTranslate = {0xb1b272a3,0x3625,0x11d1,{0xa3,0xa4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};
const CLSID CLSID_NameTranslate = {0x274fae1f,0x3626,0x11d1,{0xa3,0xa4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

const IID IID_IADsLargeInteger = {0x9068270b,0x0939,0x11d1,{0x8b,0xe1,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_LargeInteger = {0x927971f5,0x0939,0x11d1,{0x8b,0xe1,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IADsAcl = {0x8452d3ab,0x0869,0x11d1,{0xa3,0x77,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_NetAddress,0xb0b71247L,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsNetAddress = {0xb21a50a9,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_Path,0xb2538919L,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsPath = {0xb287fcd5,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_Timestamp,0xb2bed2ebL,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsTimestamp = {0xb2f5a901,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_TypedName,0xb33143cbL,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsTypedName = {0xb371a349,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_Hold,0xb3ad3e13L,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsHold = {0xb3eb3b37,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_ReplicaPointer,0xf5d1badfL,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsReplicaPointer= {0xf60fb803,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_BackLink,0xfcbf906fL,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsBackLink = {0xfd1302bd,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_PostalAddress,0x0a75afcdL,0x4680,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsPostalAddress = {0x7adecf29,0x4680,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_OctetList,0x1241400fL,0x4680,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsOctetList= {0x7b28b80f,0x4680,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_CaseIgnoreList,0x15f88a55L,0x4680,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsCaseIgnoreList = {0x7b66b533,0x4680,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_FaxNumber,0xa5062215L,0x4681,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsFaxNumber= {0xa910dea9,0x4680,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_Email,0x8f92a857L,0x478e,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);

const IID IID_IADsEmail= {0x97af011a,0x478e,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

const IID IID_IPrivateDispatch = {0x86ab4bbe,0x65f6,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IPrivateUnknown = {0x89126bab,0x6ead,0x11d1,{0x8c,0x18,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

DEFINE_GUID(IID_IADsExtension, 0x3d35553c, 0xd2b0, 0x11d1, 0xb1, 0x7b, 0x0, 0x0, 0xf8, 0x75, 0x93, 0xa0);

const IID IID_IADsDeleteOps = {0xb2bd0902,0x8878,0x11d1,{0x8c,0x21,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


//
// Umi specific GUIDS
//
/*
DEFINE_GUID(IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);

DEFINE_GUID(IID_IUmiPathKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);

DEFINE_GUID(IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);
*/

//
// LDAP Connection object GUID - uuid(7da2a9c4-0c46-43bd-b04e-d92b1be27c45)
//
DEFINE_GUID(CLSID_LDAPConnectionObject,0x7da2a9c4,0x0c46,0x43bd,0xb0,0x4e,0xd9,0x2b,0x1b,0xe2,0x7c,0x45);

// 
// WinNT Connection object GUID - uuid(7992c6eb-d142-4332-831e-3154c50a8316)
//
DEFINE_GUID(CLSID_WinNTConnectionObject,0x7992c6eb,0xd142,0x4332,0x83,0x1e,0x31,0x54,0xc5,0x0a,0x83,0x16);

//
// CLSID to represent non-extension objects for IUmiCustomInterface calls
//
DEFINE_GUID(CLSID_WinNTObject,0xb8324185,0x4050,0x4220,0x98,0x0a,0xab,0x14,0x62,0x3e,0x06,0x3a);

//
// CLSID to represent non-extension interfaces for LDAP objects - 05709878-5195-466c-9e64-487ce3ca20bf
//
DEFINE_GUID(CLSID_LDAPObject,0x05709878,0x5195,0x466c,0x9e,0x64,0x48,0x7c,0xe3,0xca,0x20,0xbf);

//
// LDAP Umi Query object GUID - uuid(cd5d4d76-a818-4f95-b958-7970fd9412ca)
//
DEFINE_GUID(CLSID_UmiLDAPQueryObject, 0xcd5d4d76,0xa818,0x4f95,0xb9,0x58,0x79,0x70,0xfd,0x94,0x12,0xca);

//
// Private Umi helper routine GUID - 4fe243f0-ad89-4cbc-9b14-486126446ae0.
//
DEFINE_GUID(IID_IADsUmiHelperPrivate, 0x4fe243f0,0xad89,0x4cbc,0x9b,0x14,0x48,0x61,0x26,0x44,0x6a,0xe0);

DEFINE_GUID(IID_IUmiADSIPrivate,0xcfcecb01,0x3123,0x4926,0xb5,0xe3,0x62,0x78,0x08,0x27,0x26,0x43);

//
// Definition for private ACE helper interface GUID - fd145df2-fd96-4135-9b22-68ff0f6bf5bb
//
DEFINE_GUID(IID_IADsAcePrivate, 0xfd145df2, 0xfd96, 0x4135,0x9b, 0x22, 0x68, 0xff, 0x0f, 0x6b, 0xf5, 0xbb);

//
// ADS Util related GUIDs.
//
DEFINE_GUID(CLSID_ADsSecurityUtility, 0xf270c64a, 0xffb8, 0x4ae4, 0x85, 0xfe, 0x3a, 0x75, 0xe5, 0x34, 0x79, 0x66);
DEFINE_GUID(IID_IADsSecurityUtility, 0xa63251b2, 0x5f21, 0x474b, 0xab, 0x52, 0x4a, 0x8e, 0xfa, 0xd1, 0x08, 0x95);

//
// Define the OLE DB specific GUIDs
//

DEFINE_GUID(CLSID_ADsDSOObject,0x549365D0L,0xEC26,0x11CF,0x83,0x10,0x00,0xAA,0x00,0xB5,0x05,0xDB);

DEFINE_GUID(DBGUID_LDAPDialect, 0xEFF65380L, 0x9C98, 0x11CF, 0xB9, 0x63, 0x00, 0xAA, 0x00, 0x44, 0x77, 0x3D);

DEFINE_GUID(DBPROPSET_ADSISEARCH, 0xcfcfc928, 0x9aa2, 0x11d0, 0xa7, 0x9a, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xa8);

DEFINE_GUID(DBPROPSET_ADSIBIND, 0x6da66dc8, 0xb7e8, 0x11d2, 0x9d, 0x60, 0x0, 0xc0, 0x4f, 0x68, 0x93, 0x45);

#define DBINITCONSTANTS
#include "oledb.h"
#include "oledberr.h"
#include "msdaguid.h"
#include "msdatt.h"
#include "msdadc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\adsqdoc.cpp ===
// adsqryDoc.cpp : implementation of the CAdsqryDoc class
//

#include "stdafx.h"
#include "adsqDoc.h"
#include "newquery.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc

IMPLEMENT_DYNCREATE(CAdsqryDoc, CDocument)

BEGIN_MESSAGE_MAP(CAdsqryDoc, CDocument)
	//{{AFX_MSG_MAP(CAdsqryDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc construction/destruction

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CAdsqryDoc::CAdsqryDoc()
{
	// TODO: add one-time construction code here
   m_pDataSource  = NULL;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CAdsqryDoc::~CAdsqryDoc()
{
   if( m_pDataSource )
   {
      delete m_pDataSource;
   }
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CAdsqryDoc::OnNewDocument()
{
   CNewQuery   aNewQuery;
   CString     strTitle;
   SEARCHPREF* pSearchPref;

	if (!CDocument::OnNewDocument())
		return FALSE;

      
   if( aNewQuery.DoModal( ) != IDOK )
      return FALSE;

   pSearchPref = (SEARCHPREF*) AllocADsMem( sizeof(SEARCHPREF) );
   if( NULL == pSearchPref )
      return FALSE;

   pSearchPref->bEncryptPassword = FALSE;
   pSearchPref->bUseSQL          = FALSE;
   pSearchPref->nAsynchronous    = -1;
   pSearchPref->nDerefAliases    = -1;
   pSearchPref->nSizeLimit       = -1;
   pSearchPref->nTimeLimit       = -1;
   pSearchPref->nAttributesOnly  = -1;
   pSearchPref->nScope           = -1;
   pSearchPref->nTimeOut         = -1;
   pSearchPref->nPageSize        = -1;
   pSearchPref->nChaseReferrals  = -1;

   _tcscpy( pSearchPref->szSource, aNewQuery.m_strSource );
   _tcscpy( pSearchPref->szQuery,  aNewQuery.m_strQuery );
   _tcscpy( pSearchPref->szAttributes, aNewQuery.m_strAttributes );
   _tcscpy( pSearchPref->szScope,      aNewQuery.m_strScope );
   _tcscpy( pSearchPref->szUserName,   aNewQuery.m_strUser );
   _tcscpy( pSearchPref->szPassword,   aNewQuery.m_strPassword );

   pSearchPref->bEncryptPassword    = aNewQuery.m_bEncryptPassword;
   pSearchPref->bUseSQL             = aNewQuery.m_bUseSQL;

   if( !GetSearchPreferences( pSearchPref ) )
      return FALSE;

   if( aNewQuery.m_bUseSearch )
   {
      m_pDataSource  = new CADsSearchDataSource;
   }
   else
   {
      m_pDataSource  = new CADsOleDBDataSource;
   }


   m_pDataSource->SetQueryParameters( pSearchPref );

   FreeADsMem( pSearchPref );

   strTitle = aNewQuery.m_strSource + _T("  ")+
              aNewQuery.m_strQuery  + _T("  ")+
              aNewQuery.m_strAttributes;

   m_pDataSource->RunTheQuery( );

   SetTitle( strTitle );

	return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  CAdsqryDoc::GetSearchPreferences( SEARCHPREF* pSearchPref )
{
   CSearchPreferencesDlg   aSearchPref;

   if( aSearchPref.DoModal( ) != IDOK )
   {
      return FALSE;
   }
   
   //***************************************************************************
   if( !aSearchPref.m_strAsynchronous.IsEmpty( ) )
   {
      if( !aSearchPref.m_strAsynchronous.CompareNoCase( _T("Yes") ) )
      {
         pSearchPref->nAsynchronous = 1;
      }
      else
      {
         pSearchPref->nAsynchronous = 0;
      }
   }

   //***************************************************************************
   if( !aSearchPref.m_strChaseReferrals.IsEmpty( ) )
   {
      if( !aSearchPref.m_strChaseReferrals.CompareNoCase( _T("Yes") ) )
      {
         pSearchPref->nChaseReferrals = 1;
      }
      else
      {
         pSearchPref->nChaseReferrals = 0;
      }
   }
      
   //***************************************************************************
   if( !aSearchPref.m_strAttributesOnly.IsEmpty( ) )
   {
      if( !aSearchPref.m_strAttributesOnly.CompareNoCase( _T("Yes") ) )
      {
         pSearchPref->nAttributesOnly = 1;
      }
      else
      {
         pSearchPref->nAttributesOnly = 0;
      }
   }

   //***************************************************************************
   if( !aSearchPref.m_strDerefAliases.IsEmpty( ) )
   {
      if( !aSearchPref.m_strDerefAliases.CompareNoCase( _T("Yes") ) )
      {
         pSearchPref->nDerefAliases = 1;
      }
      else
      {
         pSearchPref->nDerefAliases = 0;
      }
   }

   //***************************************************************************
   if( !aSearchPref.m_strTimeOut.IsEmpty( ) )
   {
      pSearchPref->nTimeOut = _ttoi( aSearchPref.m_strTimeOut.GetBuffer( 16 ) );
   }

   //***************************************************************************
   if( !aSearchPref.m_strTimeLimit.IsEmpty( ) )
   {
      pSearchPref->nTimeLimit = _ttoi( aSearchPref.m_strTimeLimit.GetBuffer( 16 ) );
   }
   
   //***************************************************************************
   if( !aSearchPref.m_strSizeLimit.IsEmpty( ) )
   {
      pSearchPref->nSizeLimit = _ttoi( aSearchPref.m_strSizeLimit.GetBuffer( 16 ) );
   }

   //***************************************************************************
   if( !aSearchPref.m_strPageSize.IsEmpty( ) )
   {
      pSearchPref->nPageSize  = _ttoi( aSearchPref.m_strPageSize.GetBuffer( 16 ) );
   }

   //***************************************************************************
   if( !aSearchPref.m_strScope.IsEmpty( ) )
   {
      _tcscpy( pSearchPref->szScope, aSearchPref.m_strScope );
   }

   return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc serialization


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CAdsqryDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc diagnostics

#ifdef _DEBUG
void CAdsqryDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CAdsqryDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\adsqview.h ===
// adsqryView.h : interface of the CAdsqryView class
//
/////////////////////////////////////////////////////////////////////////////



class CAdsqryView : public CListView
{
protected: // create from serialization only
	CAdsqryView();
	DECLARE_DYNCREATE(CAdsqryView)

// Attributes
public:
	CAdsqryDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdsqryView)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void OnInitialUpdate();
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAdsqryView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CAdsqryView)
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
protected:
   void  CreateColumns  ( void );
   void  ClearContent   ( void );
   void  AddRows        ( void );
   void  AddColumns     ( int nRow );

protected:
   int            m_nLastInsertedRow;
   int            m_nColumnsCount;
   CStringArray   m_strColumns;

};

#ifndef _DEBUG  // debug version in adsqryView.cpp
inline CAdsqryDoc* CAdsqryView::GetDocument()
   { return (CAdsqryDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\adsqview.cpp ===
// adsqryView.cpp : implementation of the CAdsqryView class
//

#include "stdafx.h"
#include "viewex.h"
#include "adsqDoc.h"
#include "adsqView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdsqryView

IMPLEMENT_DYNCREATE(CAdsqryView, CListView )

BEGIN_MESSAGE_MAP(CAdsqryView, CListView )
	//{{AFX_MSG_MAP(CAdsqryView)
	ON_WM_VSCROLL()
	//}}AFX_MSG_MAP
	// Standard printing commands
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdsqryView construction/destruction

extern   CViewExApp NEAR theApp;
extern   TCHAR szOpen[ MAX_PATH ];

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CAdsqryView::CAdsqryView()
{
	// TODO: add construction code here
   m_nLastInsertedRow   = -1;
   m_nColumnsCount      = 0;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CAdsqryView::~CAdsqryView()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CAdsqryView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	cs.style   |= LVS_REPORT;

   return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CAdsqryView diagnostics

#ifdef _DEBUG
void CAdsqryView::AssertValid() const
{
	CListView::AssertValid();
}

void CAdsqryView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

CAdsqryDoc* CAdsqryView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CAdsqryDoc)));
	return (CAdsqryDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAdsqryView message handlers

/***********************************************************
  Function:    CAdsqryView::OnInitialUpdate
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CAdsqryView::OnInitialUpdate() 
{
   CListView ::OnInitialUpdate();

   CreateColumns( );
   AddRows( );
}


/***********************************************************
  Function:    CAdsqryView::AddColumns
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CAdsqryView::AddColumns( int nRow )
{
   int               nColumnCount, nIdx, nColumn;
   CString           strColumn;
   LV_COLUMN         lvColumn;
   CADsDataSource*   pDataSource;
   CAdsqryDoc*       pDoc;
   
   pDoc        = GetDocument( );
   pDataSource = pDoc->GetADsDataSource( );

   nColumnCount   =  pDataSource->GetColumnsCount( nRow );
   
   for( nIdx = 0; nIdx < nColumnCount ; nIdx++ )
   {
      pDataSource->GetColumnText( nRow, nIdx, strColumn );

      for( nColumn = 0; nColumn < m_nColumnsCount ; nColumn++ )
      {
         if( m_strColumns[ nColumn ] == strColumn )
            break;
      }
      if( nColumn == m_nColumnsCount )
      {
         m_strColumns.Add( strColumn );
         m_nColumnsCount++;
         lvColumn.iSubItem = m_nColumnsCount - 1;
         lvColumn.mask     = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	      lvColumn.fmt      = LVCFMT_LEFT;
	      lvColumn.pszText  = strColumn.GetBuffer( 256 );
	      lvColumn.cx       = GetListCtrl( ).GetStringWidth( _T("WWWWWWWWWW") ) + 15;

         GetListCtrl( ).InsertColumn( m_nColumnsCount - 1, &lvColumn );
         TRACE( _T("Found new Column %s\n"), (LPCTSTR)strColumn );
      }
   }
}



/***********************************************************
  Function:    CAdsqryView::CreateColumns
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CAdsqryView::CreateColumns( void )
{
/*   int               nCol;
   LV_COLUMN         lvColumn;
   CADsDataSource*   pDataSource;
   CAdsqryDoc*       pDoc;
   CString           strColumn;
   
   pDoc  = GetDocument( );
   pDataSource = pDoc->GetADsDataSource( );

   m_nColumnsCount = pDataSource->GetColumnsCount( );

   for( nCol = 0 ; nCol < m_nColumnsCount ; nCol++ )
   {
      pDataSource->GetColumnText( nCol, strColumn );

      lvColumn.iSubItem = nCol;
      lvColumn.mask     = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	   lvColumn.fmt      = LVCFMT_LEFT;
	   lvColumn.pszText  = strColumn.GetBuffer( 256 );
	   lvColumn.cx       = GetListCtrl( ).GetStringWidth( _T("WWWWWWWWWW") ) + 15;

      GetListCtrl( ).InsertColumn( nCol, &lvColumn );
   }*/
}


/***********************************************************
  Function:    CAdsqryView::ClearContent
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CAdsqryView::ClearContent( void )
{
   GetListCtrl( ).DeleteAllItems( );

   m_nLastInsertedRow   = -1;
}


/***********************************************************
  Function:    CAdsqryView::AddRows
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CAdsqryView::AddRows( void )
{
   int               nCol;
   int               nTopIndex, nPageItems;
   int               nRowIndex;
   CADsDataSource*   pDataSource;
   CAdsqryDoc*       pDoc;
   
   pDoc        = GetDocument( );
   pDataSource = pDoc->GetADsDataSource( );

   nTopIndex   = GetListCtrl( ).GetTopIndex( );
   nPageItems  = GetListCtrl( ).GetCountPerPage( );
   if( m_nLastInsertedRow < nTopIndex + 2 * nPageItems )
   {
      HCURSOR  aCursor, oldCursor;

      aCursor     = LoadCursor( NULL, IDC_WAIT );
      oldCursor   = SetCursor( aCursor );
      // we must add extra items in the list view
      for( nRowIndex = m_nLastInsertedRow + 1 ; 
           nRowIndex < nTopIndex + 2 * nPageItems ;
           nRowIndex++ )
      {
         CString  strValue;
         BOOL  bWork = FALSE;

         AddColumns( nRowIndex );

         for( nCol = 0; nCol < m_nColumnsCount ; nCol++ )
         {
            CString  strColumnName;

            strColumnName  = m_strColumns.GetAt( nCol );

            if( pDataSource->GetValue( nRowIndex, nCol, strValue ) || 
                pDataSource->GetValue( nRowIndex, strColumnName, strValue ) )
            {
               LV_ITEM  lvItem;
               TCHAR*   pszText;

               
               pszText  = (TCHAR*) malloc( strValue.GetLength( ) + 10 );
               
					if(NULL != pszText)
					{
						_tcscpy( pszText, _T("") );
						if( !nCol )
						{
							_itot( nRowIndex + 1, pszText, 10 );
							_tcscat( pszText, _T(") ") );
						}

						_tcscat( pszText, strValue.GetBuffer( strValue.GetLength( ) + 1 ) );
               
						bWork = TRUE;
						memset( &lvItem, 0, sizeof(lvItem) );

						lvItem.mask       = LVIF_TEXT | LVIF_STATE; 
						lvItem.state      = 0; 
						lvItem.stateMask  = 0; 
						lvItem.iItem      = nRowIndex;
						lvItem.iSubItem   = nCol;
						lvItem.pszText    = pszText;
						lvItem.cchTextMax = _tcslen( pszText );

						if( nCol == 0)
						{
							GetListCtrl( ).InsertItem(&lvItem);
						}
						else
						{
							GetListCtrl( ).SetItem(&lvItem);
						}

						free( pszText );
					}
            }
         }
         if( bWork )
         {
            m_nLastInsertedRow++;
         }
      }
      SetCursor( oldCursor );
   }
}


/***********************************************************
  Function:    CAdsqryView::OnVScroll
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CAdsqryView::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	// TODO: Add your message handler code here and/or call default

   CListView ::OnVScroll(nSBCode, nPos, pScrollBar);
   
   //if( nSBCode == SB_LINEDOWN || nSBCode == SB_PAGEDOWN )
   {
      AddRows( );
   }
}


/***********************************************************
  Function:    CAdsqryView::OnChildNotify
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CAdsqryView::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult) 
{
	// TODO: Add your specialized code here and/or call the base class
   NMHDR*            pHeader;
   int               nSel;
   CADsDataSource*   pDataSource;
   CAdsqryDoc*       pDoc;
   CString           strADsPath;

   while( TRUE )
   {
      if( message != WM_NOTIFY )
         break;

      pHeader  = (NMHDR*)lParam;
      if( pHeader->code != NM_DBLCLK )
         break;

      
      if( !GetListCtrl( ).GetSelectedCount( ) )
         break;

      nSel  = GetListCtrl( ).GetNextItem( -1, LVNI_SELECTED );;
          
      if( -1 == nSel )
         break;

      pDoc           = GetDocument( );
      pDataSource    = pDoc->GetADsDataSource( );

      pDataSource->GetADsPath( nSel, strADsPath );

      _tcscpy( szOpen, strADsPath.GetBuffer( MAX_PATH ) );

      theApp.OpenDocumentFile( strADsPath.GetBuffer( MAX_PATH ) );

      return TRUE;
   }
	
	return CListView::OnChildNotify(message, wParam, lParam, pLResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\bwsview.cpp ===
// BrowseView.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "bwsview.h"
#include "schclss.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define  BUFF_SIZE   0xFFFFL
//#define  BUFF_SIZE   0x1000L

/////////////////////////////////////////////////////////////////////////////
// CBrowseView

IMPLEMENT_DYNCREATE(CBrowseView, CTreeView)

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CBrowseView::CBrowseView()
{
   BOOL        bOK;
   DWORD       dwObjectType;
   CBitmap*    pBitmap;
   UINT        imageID;

   m_pImageList  = new CImageList( );

   if( NULL != m_pImageList )
   {
      bOK   = m_pImageList->Create( 18, 18, FALSE, 20, 20 );
      if( bOK )
      {
         for( dwObjectType = FIRST; dwObjectType < LIMIT ; dwObjectType++)
         {
            pBitmap  = new CBitmap;

            imageID  = GetBitmapImageId  ( dwObjectType );
            pBitmap->LoadBitmap( imageID );
            m_pImageList->Add( pBitmap, (COLORREF)0L );

            pBitmap->DeleteObject( );
            delete   pBitmap;
         }
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CBrowseView::OnInitialUpdate()
{
   HTREEITEM      hItem;
   CMainDoc*      pDoc;
   DWORD          dwStyle;
   BOOL           bRez;
   COleDsObject*  pObject;

   m_bDoNotUpdate = TRUE;

   pDoc     = (CMainDoc*)  GetDocument( );

   dwStyle  = TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS;

   bRez     = GetTreeCtrl( ).ModifyStyle( 0L, dwStyle );

   GetTreeCtrl( ).SetImageList( m_pImageList, TVSIL_NORMAL );
   GetTreeCtrl( ).DeleteAllItems( );
   GetTreeCtrl( ).SetIndent( 20 );

   pObject  = pDoc->GetCurrentObject( );
   hItem    = GetTreeCtrl( ).InsertItem( pObject->GetItemName( ) );
   GetTreeCtrl( ).SetItemData( hItem, pDoc->GetToken( &pObject ) );
   GetTreeCtrl( ).SetItemImage( hItem, pObject->GetType( ), pObject->GetType( ) );

   m_bDoNotUpdate = FALSE;

   CTreeView::OnInitialUpdate( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CBrowseView::~CBrowseView()
{
   delete m_pImageList;
}

BEGIN_MESSAGE_MAP(CBrowseView, CTreeView)
	//{{AFX_MSG_MAP(CBrowseView)
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelChanged)
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, OnItemExpanded)
	ON_COMMAND(IDM_ADD, OnAddItem)
	ON_COMMAND(IDM_DELETE, OnDeleteItem)
	ON_COMMAND(IDM_MOVEITEM, OnMoveItem)
	ON_COMMAND(IDM_COPYITEM, OnCopyItem)
	ON_COMMAND(IDM_REFRESH, OnRefresh)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CMainDoc*   sgpDoc;

int __cdecl  QSortCompare( const void* pVal1, const void* pVal2 )
{
   COleDsObject*  pObject1;
   COleDsObject*  pObject2;
   CString*       pString1;
   CString*       pString2;
   int            nDiff;

   pObject1 = sgpDoc->GetObject( (void*)pVal1 );
   pObject2 = sgpDoc->GetObject( (void*)pVal2 );
   nDiff    = pObject1->GetType( ) - pObject2->GetType( );
   if( nDiff )
      return nDiff;

   pString1 = pObject1->PtrGetItemName( );
   pString2 = pObject2->PtrGetItemName( );

   return pString1->Compare( (LPCTSTR)( pString2->GetBuffer( 128 ) ) );
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CBrowseView::SortChildItemList( DWORD* pChildTokens, DWORD dwCount )
{
   sgpDoc   = (CMainDoc*)GetDocument( );
   qsort( (void*)pChildTokens, dwCount, sizeof(DWORD), QSortCompare );
}
/////////////////////////////////////////////////////////////////////////////
// CBrowseView diagnostics

#ifdef _DEBUG
/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::AssertValid() const
{
	CTreeView::AssertValid();
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBrowseView message handlers


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	
   HTREEITEM      hTreeItem, hChildItem;;
   CString        strItemName;
   CMainDoc*      pDoc;
   DWORD          dwIter;
   DWORD          dwToken;
   DWORD*         pTokens     = NULL;
   DWORD          dwNumItems  = 0L;

   *pResult       = 0;
   if( m_bDoNotUpdate )
   {
      return;
   }

   hTreeItem      = GetTreeCtrl( ).GetSelectedItem( );
   hChildItem     = TVI_LAST;

   if( NULL != hTreeItem )
   {
      dwToken  = (DWORD)GetTreeCtrl( ).GetItemData( hTreeItem );
      pDoc     = (CMainDoc*)  GetDocument( );

      ASSERT( NULL != pDoc );

      if( NULL != pDoc )
      {
         HCURSOR  oldCursor, newCursor;

         newCursor   = LoadCursor( NULL, IDC_WAIT );
         oldCursor   = SetCursor( newCursor );

         // the item has children support ???
         pTokens     = (DWORD*) malloc( sizeof(DWORD) * BUFF_SIZE );

         if( !GetTreeCtrl( ).ItemHasChildren( hTreeItem ) )
         {
            dwNumItems  = pDoc->GetChildItemList( dwToken, pTokens, BUFF_SIZE );

            if( dwNumItems )
            {
               // siaply children items
               SortChildItemList( pTokens, dwNumItems );
               for( dwIter = 0; dwIter < dwNumItems ; dwIter++ )
               {
                  COleDsObject*  pObject;
                  CString*       pName;
                  DWORD          dwType;
                  TCHAR          szName[ 256 ];

                  pObject     = pDoc->GetObject( &pTokens[ dwIter ] );
                  dwType      = pObject->GetType( );
                  pName       = pObject->PtrGetItemName( );

                  _ultot( dwIter + 1, szName, 10 );
                  _tcscat( szName, _T(") ") );
                  _tcscat( szName, pName->GetBuffer( 128 ) );

                  /*hChildItem  = GetTreeCtrl( ).InsertItem( pName->GetBuffer( 128 ),
                                                           hTreeItem, hChildItem ); */

                  hChildItem  = GetTreeCtrl( ).InsertItem( szName,
                                                           hTreeItem,
                                                           hChildItem );

                  GetTreeCtrl( ).SetItemData( hChildItem, pTokens[ dwIter ] );
                  GetTreeCtrl( ).SetItemImage( hChildItem, dwType, dwType );
               }
            }
         }
         if( NULL != pTokens )
         {
            free((void*)pTokens);
         }
         pDoc->SetCurrentItem( dwToken );
         SetCursor( oldCursor );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW*   pNMTreeView = (NM_TREEVIEW*)pNMHDR;
   HTREEITEM      hItem;
	// TODO: Add your control notification handler code here
	
   hItem = pNMTreeView->itemNew.hItem;
   if( !( pNMTreeView->itemNew.state & TVIS_EXPANDED ) )
   {
      //    this should mean that the item was unexpanded.
      //    We should delete its children.

      /*hChildItem  = GetTreeCtrl( ).GetChildItem( hItem );
      while( NULL != hChildItem )
      {
         bRez  = GetTreeCtrl( ).DeleteItem( hChildItem );
         ASSERT( bRez );
         hChildItem  = GetTreeCtrl( ).GetChildItem( hItem );
      } */
   }
   else
   {
      /*dwItemData  = GetTreeCtrl( ).GetItemData( hItem );
      GetItemPath( hItem, strItemName );
      pDoc  = (CMainDoc*)  GetDocument( );

      ASSERT( NULL != pDoc );

      if( NULL != pDoc )
      {
         HCURSOR  oldCursor, newCursor;

         newCursor   = LoadCursor( NULL, IDC_WAIT );
         oldCursor   = SetCursor( newCursor );

         // the item has children support ???
         lpItemsName = (LPWSTR) malloc( 0x40000L );
         lpItemsType = (LPDWORD) malloc( 0x20000L );

         bRez  = pDoc->GetChildItemList( strItemName, dwItemData,
                                         lpItemsName, lpItemsType,
                                         &dwNumItems, 0x40000L );

         if( bRez )
         {

            // siaply children items
            lpName   = lpItemsName;
            for( nIter = 0; nIter < dwNumItems ; nIter++ )
            {
               hChildItem  = GetTreeCtrl( ).InsertItem( lpName, hItem );
               GetTreeCtrl( ).SetItemData( hChildItem, lpItemsType[ nIter ] );
               lpName      = lpName + ( _tcslen( lpName ) + 1 );
            }
         }

         if( NULL != lpItemsName )
         {
            free( lpItemsName );
         }

         if( NULL != lpItemsType )
         {
            free( lpItemsType );
         }

         //pDoc->SetItemName( strItemName, dwItemData );

         SetCursor( oldCursor );
      } */
   }

	*pResult = 0;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnAddItem()
{
	// TODO: Add your command handler code here
   CMainDoc*      pDoc;
   COleDsObject*  pObject;
   HRESULT        hResult;

   pDoc     = (CMainDoc*)  GetDocument( );

   pObject  = pDoc->GetCurrentObject( );
   if( NULL == pObject )
      return;

   if( pObject->AddItemSuported( ) )
   {
      pObject->CreateTheObject( );
      hResult  = pObject->AddItem( );
      pObject->ReleaseIfNotTransient( );
      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
      else
      {
         pDoc->DeleteAllItems( );
         OnInitialUpdate( );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnDeleteItem()
{
	// TODO: Add your command handler code here
   CMainDoc*      pDoc;
   COleDsObject*  pObject;
   HRESULT        hResult;

   pDoc     = (CMainDoc*)  GetDocument( );

   pObject  = pDoc->GetCurrentObject( );
   if( NULL == pObject )
      return;

   if( pObject->DeleteItemSuported( ) )
   {
      pObject->CreateTheObject( );
      hResult  = pObject->DeleteItem( );
      pObject->ReleaseIfNotTransient( );
      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
      else
      {
         pDoc->DeleteAllItems( );
         OnInitialUpdate( );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnMoveItem()
{
	// TODO: Add your command handler code here
   CMainDoc*      pDoc;
   COleDsObject*  pObject;
   HRESULT        hResult;

   pDoc     = (CMainDoc*)  GetDocument( );

   pObject  = pDoc->GetCurrentObject( );
   if( NULL == pObject )
      return;

   if( pObject->MoveItemSupported( ) )
   {
      hResult  = pObject->MoveItem( );
      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
      else
      {
         OnRefresh( );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnCopyItem()
{
   // TODO: Add your command handler code here
   CMainDoc*      pDoc;
   COleDsObject*  pObject;
   HRESULT        hResult;

   pDoc     = (CMainDoc*)  GetDocument( );

   pObject  = pDoc->GetCurrentObject( );
   if( NULL == pObject )
      return;

   if( pObject->CopyItemSupported( ) )
   {
      hResult  = pObject->CopyItem( );

      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
      else
      {
         OnRefresh( );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnRefresh()
{
	// TODO: Add your command handler code here
   CMainDoc*      pDoc;

   pDoc  = (CMainDoc*)GetDocument( );
   pDoc->DeleteAllItems( );
   OnInitialUpdate( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
   HTREEITEM   hTreeItem;

   // TODO: Add your specialized code here and/or call the base class
   CTreeView::OnUpdate( pSender, lHint, pHint );	

   hTreeItem      = GetTreeCtrl( ).GetSelectedItem( );

   if( NULL == hTreeItem )
   {
      hTreeItem      = GetTreeCtrl( ).GetRootItem( );
      GetTreeCtrl( ).SelectItem( hTreeItem );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\adsdsrc.cpp ===
// adsqryDoc.cpp : implementation of the CAdsqryDoc class
//

#include "stdafx.h"
#include "adsqDoc.h"
#include "adsdsrc.h"
#include "oledberr.h"
#include "adsdb.h"
#include "csyntax.h"
#include "newquery.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef BUILD_FOR_NT40
typedef DWORD DWORD_PTR;
#endif

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CADsDataSource::CADsDataSource( )
{
   m_pSearchPref  = NULL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CADsDataSource::~CADsDataSource( )
{
   if( NULL != m_pSearchPref )
   {
      FreeADsMem( m_pSearchPref );
   }
}


/***********************************************************
  Function:    CADsDataSource::SetQueryParameters
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
/*void CADsDataSource::SetQueryParameters( CString& strSource,
                                         CString& strQuery,
                                         CString& strAttributes,
                                         CString& strScope,
                                         CString& strUserName,
                                         CString& strPassword,
                                         BOOL bEncryptPassword,
                                         BOOL bUseSQL )
{
   m_strSource          = strSource;
   m_strQuery           = strQuery;
   m_strAttributes      = strAttributes;
   m_strScope           = strScope;
   m_strUserName        = strUserName;
   m_strPassword        = strPassword;
   m_bEncryptPassword   = bEncryptPassword;
   m_bUseSQL            = bUseSQL;
} */


void CADsDataSource::SetQueryParameters( SEARCHPREF* pSearchPref )
{
   if( NULL == m_pSearchPref )
   {
      m_pSearchPref  = (SEARCHPREF*) AllocADsMem( sizeof(SEARCHPREF) );
   }

   *m_pSearchPref = *pSearchPref;
}

/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CADsDataSource::GetColumnsCount( int nRow )
{
   ASSERT( FALSE );

   return 0;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::GetValue( int nRow, int nColumn, CString& )
{
   return FALSE;
}

/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::GetValue( int nRow, CString& strColumn, CString& )
{
   return FALSE;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::GetADsPath( int nRow, CString& )
{
   ASSERT( FALSE );
   return FALSE;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::GetColumnText( int nRow, int nColumn, CString& )
{
   ASSERT( FALSE );
   return FALSE;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::Refresh( void )
{
   return FALSE;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::RunTheQuery( void )
{
   ASSERT( FALSE );

   return FALSE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::CADsOleDBDataSource
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
CADsOleDBDataSource::CADsOleDBDataSource( )
{
   CoGetMalloc(MEMCTX_TASK, &m_pIMalloc);

   m_pData              = NULL;
   m_pBindStatus        = NULL;
   m_hRows              = NULL;
   m_pIRowset           = NULL;
   m_pIColsInfo         = NULL;
   m_pAccessor          = NULL;
   m_nColumnsCount      = 0;
   m_prgColInfo         = NULL;
   m_szColNames         = NULL;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::~CADsOleDBDataSource
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
CADsOleDBDataSource::~CADsOleDBDataSource( )
{
   DestroyInternalData( );
   m_pIMalloc->Release( );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::GetColumnsCount
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
int   CADsOleDBDataSource::GetColumnsCount( int nRow )
{
   if( m_nColumnsCount )
   {
      return   (int)(m_nColumnsCount - m_nAddOne);
   }
   else
   {
      return 0;
   }
}



/*****************************************************************************
   Function:   CADsOleDBDataSource::GetColumnText
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
BOOL  CADsOleDBDataSource::GetColumnText( int nRow, int nColumn, CString& rValue )
{
   nColumn += m_nAddOne;

   if( nColumn < 0 || nColumn >= (int)m_nColumnsCount )
   {
      ASSERT( FALSE );
      return FALSE;
   }

   if( FALSE )
   {
      rValue   = _T("ADsPath");
   }
   else
   {
      TCHAR szColumnName[ MAX_PATH ];

      Convert( szColumnName, m_prgColInfo[ nColumn + 1].pwszName );

      rValue   = szColumnName;
   }

   return TRUE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::CreateAccessorHelper
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsOleDBDataSource::CreateAccessorHelp( void )
{

   DBBINDING*  prgBindings = NULL;
   HRESULT     hResult;
   ULONG       i;
   IAccessor*  pIAccessor = NULL;

   prgBindings = (DBBINDING *) LocalAlloc(
                                           LPTR,
                                           sizeof(DBBINDING) * (m_nColumnsCount)
                                         );
	if(NULL == prgBindings)
		return E_OUTOFMEMORY;

   //
   // Set up rest of the attributes
   //
   for ( i=0; i < m_nColumnsCount ; i++)
   {
      prgBindings[i].iOrdinal       = i+1;
      prgBindings[i].obValue        = sizeof(Data)*i + offsetof(Data, obValue);
      prgBindings[i].obLength       = sizeof(Data)*i + offsetof(Data, obLength);
      prgBindings[i].obStatus       = sizeof(Data)*i + offsetof(Data, status);
      prgBindings[i].dwPart         = DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS;
      //prgBindings[i].dwMemOwner     = DBMEMOWNER_PROVIDEROWNED;
      prgBindings[i].wType          = m_prgColInfo[i+1].wType;
      prgBindings[i].dwFlags        = 0;

      if( prgBindings[i].wType & DBTYPE_BYREF )
      {
         prgBindings[i].dwMemOwner  = DBMEMOWNER_PROVIDEROWNED;
      }
      else
      {
         prgBindings[i].dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
      }

      if( m_prgColInfo[i+1].wType == DBTYPE_DATE  ||
          m_prgColInfo[i+1].wType == DBTYPE_I8 )
      {
         prgBindings[i].obValue  = sizeof(Data)*i + offsetof(Data, obValue2);
      }

   }


   hResult= m_pIRowset->QueryInterface( IID_IAccessor, (void**) &pIAccessor );
   ASSERT( SUCCEEDED( hResult ) );

   //
   // With the bindings create the accessor
   //
   hResult = pIAccessor->CreateAccessor(
                                         DBACCESSOR_ROWDATA,
                                         m_nColumnsCount,
                                         prgBindings,
                                         0,
                                         &m_hAccessor,
                                         m_pBindStatus
                                       );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      AfxMessageBox( _T("IAccessor::CreateAccessor failed") );
   }

   pIAccessor->Release();
   LocalFree(prgBindings);

   return( SUCCEEDED( hResult ) );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::SetQueryCredentials
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
HRESULT  CADsOleDBDataSource::SetQueryCredentials( IDBInitialize* pInit,
                                                   ICommandText* pCommand )
{
   DBPROPSET      aPropSet;
   DBPROP         arrProp[ 20 ];
   HRESULT        hResult;
   int            nIter, nIdx;

   ASSERT( !( (NULL != pInit) && (NULL != pCommand) ) );

   for ( nIter = 0; nIter < 20; nIter++)
   {
      VariantInit( &(arrProp[ nIter ].vValue ) );
      V_VT( &(arrProp[ nIter ].vValue ) ) = VT_BSTR;
      arrProp[ nIter ].dwOptions          = DBPROPOPTIONS_REQUIRED;
   }

   if( NULL != pInit )
   {
      IDBProperties* pIProp   = NULL;

      if( !_tcslen(m_pSearchPref->szUserName) )
      {
         return S_OK;
      }

      hResult  = pInit->QueryInterface( IID_IDBProperties, (void**)&pIProp );

      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         return hResult;

      nIter = 0;
      if( _tcslen(m_pSearchPref->szUserName) )
      {
         arrProp[ nIter ].dwPropertyID        = DBPROP_AUTH_USERID;
         V_BSTR( &(arrProp[ nIter ].vValue) ) = AllocBSTR( m_pSearchPref->szUserName );
         nIter++;

         arrProp[ nIter ].dwPropertyID        = DBPROP_AUTH_PASSWORD;
         V_BSTR( &(arrProp[ nIter ].vValue) ) = AllocBSTR( m_pSearchPref->szPassword );
         nIter++;

         arrProp[ nIter ].dwPropertyID        = DBPROP_AUTH_ENCRYPT_PASSWORD;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_BOOL;

         if( m_pSearchPref->bEncryptPassword )
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_TRUE;
         }
         else
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_FALSE;
         }
         nIter++;

         aPropSet.rgProperties            = arrProp;
         aPropSet.cProperties             = nIter;
         aPropSet.guidPropertySet         = DBPROPSET_DBINIT;

         hResult                          = pIProp->SetProperties( 1, &aPropSet );

         ASSERT( S_OK == hResult );

         for ( nIdx = 0; nIdx < nIter ; nIdx++ )
         {
            VariantClear( &(arrProp[ nIdx ].vValue ) );
         }
         nIter = 0;
      }

      pIProp->Release( );
   }

   if( NULL != pCommand )
   {
      ICommandProperties*  pCommandProp   = NULL;


      hResult  = pCommand->QueryInterface( IID_ICommandProperties,
                                           (void**) &pCommandProp );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         return hResult;

      nIter = 0;
      // Initialize the VARIANTs and the options in rgProps.
      //***************************************************************************
      if( -1 != m_pSearchPref->nAsynchronous )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_ASYNCHRONOUS;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_BOOL;

         if( m_pSearchPref->nAsynchronous )
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_TRUE;
         }
         else
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_FALSE;
         }
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nAttributesOnly )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_ATTRIBTYPES_ONLY;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_BOOL;

         if( m_pSearchPref->nAttributesOnly )
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_TRUE;
         }
         else
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_FALSE;
         }
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nTimeOut )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_TIMEOUT;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         V_I4( &(arrProp[ nIter ].vValue ) )  = m_pSearchPref->nTimeOut;
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nTimeLimit )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_TIME_LIMIT;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         V_I4( &(arrProp[ nIter ].vValue ) )  = m_pSearchPref->nTimeLimit;
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nSizeLimit )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_SIZE_LIMIT;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         V_I4( &(arrProp[ nIter ].vValue ) )  = m_pSearchPref->nSizeLimit;
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nPageSize )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_PAGESIZE;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         V_I4( &(arrProp[ nIter ].vValue ) )  = m_pSearchPref->nPageSize;
         nIter++;
      }

      //***************************************************************************

      if( _tcslen( m_pSearchPref->szScope ) )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_SEARCH_SCOPE;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         if( !_tcsicmp(  m_pSearchPref->szScope, _T("subtree") ) )
         {
            V_I4( &(arrProp[ nIter ].vValue ) )  = ADS_SCOPE_SUBTREE;
         }
         else if( !_tcsicmp(  m_pSearchPref->szScope, _T("onelevel") ) )
         {
            V_I4( &(arrProp[ nIter ].vValue ) )  = ADS_SCOPE_ONELEVEL;
         }
         else
         {
            V_I4( &(arrProp[ nIter ].vValue ) )  = ADS_SCOPE_BASE;
         }

         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nChaseReferrals )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_CHASE_REFERRALS;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         if( m_pSearchPref->nChaseReferrals )
         {
            V_I4( &(arrProp[ nIter ].vValue) ) = ADS_CHASE_REFERRALS_ALWAYS;
         }
         else
         {
            V_I4( &(arrProp[ nIter ].vValue) ) = ADS_CHASE_REFERRALS_NEVER;
         }
         nIter++;
      }



      // Create the initialization structure.
      if( nIter )
      {
         aPropSet.rgProperties            = arrProp;
         aPropSet.cProperties             = nIter;
         aPropSet.guidPropertySet         = DBPROPSET_ADSISEARCH;

         hResult                          = pCommandProp->SetProperties( 1, &aPropSet );

         ASSERT( S_OK == hResult );

         for ( nIdx = 0; nIdx < nIter ; nIdx++ )
         {
            VariantClear( &(arrProp[ nIdx ].vValue ) );
         }
         ASSERT( SUCCEEDED( hResult ) );
      }
      pCommandProp->Release( );
   }

   return hResult;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::RunTheQuery
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsOleDBDataSource::RunTheQuery( void )
{
   HRESULT            hResult;

   IDBInitialize    * pIDBInit         = NULL;
   IDBCreateSession * pIDBCS           = NULL;
   IDBCreateCommand * pIDBCreateCommand= NULL;
   ICommandText     * pICommandText    = NULL;
   ICommand         * pICommand        = NULL;
   DBBINDSTATUS     * pMyStatus = NULL;
   CString          strCommandText;
   BSTR             bstrCommandText;
   HCURSOR          aCursor, oldCursor;

   aCursor     = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( aCursor );

   m_nCurrentRow  = -1;
   m_nFirstRow    = -1;
   m_nLastRow     = -1;
   m_bNoMoreData  = FALSE;
   m_hRows        = NULL;

   m_nAddOne         = 0;
   m_strAttributes   = m_pSearchPref->szAttributes;

   if( !_tcsicmp( m_pSearchPref->szAttributes, _T("*") ) )
   {
      CString  strTemp  = _T("ADsPath,");

      strTemp          += m_pSearchPref->szAttributes;
      m_strAttributes   = strTemp;
      m_nAddOne         = 1;
   }

   if( !m_pSearchPref->bUseSQL )
   {
      strCommandText   = m_pSearchPref->szSource;
      if( strCommandText[ 0 ] != _T('<') )
       {
         CString  strTemp;

         strTemp  = _T("<");
         strTemp  = strTemp + strCommandText;
         strTemp  = strTemp + _T(">");
         strCommandText = strTemp;
       }

      strCommandText  += _T(';');
      strCommandText  += m_pSearchPref->szQuery;
      strCommandText  += _T(';');
      strCommandText  += m_strAttributes;

      /*if( _tcslen( m_pSearchPref->szScope ) )
      {
         strCommandText  += _T(';');
         strCommandText  += m_pSearchPref->szScope;
      }*/
   }
   else
   {
      strCommandText   = _T("SELECT ");
      strCommandText  += m_strAttributes;

      strCommandText  += _T(" FROM '");
      strCommandText  += m_pSearchPref->szSource;
      strCommandText  += _T("'");

      strCommandText  += _T(" WHERE ");
      strCommandText  += m_pSearchPref->szQuery;
   }

   bstrCommandText = AllocBSTR( strCommandText.GetBuffer( strCommandText.GetLength( ) + 1 ) );

    //
    // Instantiate a data source object for LDAP provider
    //
   while( TRUE )
   {
      hResult  = CoCreateInstance( CLSID_ADsDSOObject,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IDBInitialize,
                                   (void **)&pIDBInit
                                  );
      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE(_T("CoCreateInstance failed \n"));
         AfxMessageBox( _T("CoCreateInstance failed") );
         break;
      }

       //
       // Initialize the Data Source
       //

      hResult  = SetQueryCredentials( pIDBInit, NULL );

      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pIDBInit->Initialize();

      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE(_T("IDBIntialize::Initialize failed \n"));
         AfxMessageBox( _T("IDBIntialize::Initialize failed") );
         break;
      }

      hResult  = pIDBInit->QueryInterface(
                                           IID_IDBCreateSession,
                                           (void**) &pIDBCS);

      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE(_T("QueryInterface for IDBCreateSession failed \n"));
         AfxMessageBox( _T("QueryInterface for IDBCreateSession failed") );
         break;
      }

      pIDBInit->Release( );
      pIDBInit = NULL;

      //
      // Create a session returning a pointer to its CreateCommand interface
      //
      hResult  = pIDBCS->CreateSession(
                                        NULL,
                                        IID_IDBCreateCommand,
                                        (LPUNKNOWN*) &pIDBCreateCommand
                                      );

      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE( _T("IDBCreateSession::CreateSession failed \n") );
         AfxMessageBox( _T("IDBCreateSession::CreateSession failed") );
         break;
      }

      pIDBCS->Release( );
      pIDBCS   = NULL;

       //
       // Create a command from the session object
       //
      hResult = pIDBCreateCommand->CreateCommand(
                                                  NULL,
                                                  IID_ICommandText,
                                                  (LPUNKNOWN*) &pICommandText
                                                );

      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE( _T(" IDBCreateCommand::CreateCommand failed\n") );
         AfxMessageBox( _T("IDBCreateCommand::CreateCommand failed") );
         break;
      }

      pIDBCreateCommand->Release( );
      pIDBCreateCommand = NULL;

      hResult  = SetQueryCredentials( NULL, pICommandText );

      ASSERT( SUCCEEDED( hResult ) );

      if( !m_pSearchPref->bUseSQL )
      {
         hResult  = pICommandText->SetCommandText(
                                                   DBGUID_LDAPDialect,
                                                   bstrCommandText
                                                 );
      }
      else
      {
         hResult  = pICommandText->SetCommandText(
                                                   DBGUID_DBSQL,
                                                   bstrCommandText
                                                 );
      }

      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE(_T("ICommandText::CommandText failed \n"));
         AfxMessageBox( _T("ICommandText::CommandText failed") );
         break;
      }

      hResult  = pICommandText->QueryInterface(
                                                IID_ICommand,
                                                (void**) &pICommand);

      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE(_T("QueryInterface for ICommand failed \n") );
         AfxMessageBox( _T("QueryInterface for ICommand failed ") );
         break;
      }

      pICommandText->Release();
      pICommandText = NULL;

      //
      // Do the Query and get back a rowset
      //
      pICommand->AddRef( );
      pICommand->Release( );

      hResult = pICommand->Execute(
                                  NULL,
                                  IID_IRowset,
                                  NULL,
                                  NULL,
                                  (LPUNKNOWN *)&m_pIRowset
                                );

      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE(_T("ICommand::Execute failed \n"));
         AfxMessageBox( _T("ICommand::Execute failed") );
         pICommand->Release( );
         pICommand  = NULL;

         break;
      }

      m_pIRowset->AddRef( );
      m_pIRowset->Release( );

      pICommand->Release( );
      pICommand   = NULL;


      hResult = m_pIRowset->QueryInterface(
                                          IID_IColumnsInfo,
                                          (void**) &m_pIColsInfo
                                        );
      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE(_T("QueryInterface for IColumnsInfo failed \n"));
         AfxMessageBox( _T("QueryInterface for IColumnsInfo failed") );
         break;
      }

      hResult = m_pIColsInfo->GetColumnInfo(
                                           &m_nColumnsCount,
                                           &m_prgColInfo,
                                           &m_szColNames
                                         );

      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE( _T("IColumnsInfo::GetColumnInfo failed \n") );
         AfxMessageBox( _T("IColumnsInfo::GetColumnInfo failed") );
         break;
      }

       //
       // The no. of attributes is one less than the no. of columns because of
       // the Bookmark column
       //
      m_nColumnsCount--;

      m_pData  = (Data *) LocalAlloc( LPTR, sizeof(Data) * m_nColumnsCount );

      m_pBindStatus = (DBBINDSTATUS *) LocalAlloc(
                                                   LPTR,
                                                   sizeof(DBBINDSTATUS) * m_nColumnsCount
                                                  );
      hResult = CreateAccessorHelp( );
      if(FAILED(hResult))
      {
         TRACE(_T("CreateAccessorHelper failed \n"));
         break;
      }

      break;
   }

   SysFreeString( bstrCommandText );

   SetCursor( oldCursor );

   return SUCCEEDED( hResult );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::AdvanceCursor
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsOleDBDataSource::AdvanceCursor( void )
{
   HRESULT  hResult;
   DBCOUNTITEM cRowsObtained;
   HCURSOR  aCursor, oldCursor;

   aCursor     = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( aCursor );

   if( !m_bNoMoreData )
   {
      cRowsObtained  = 0;

      if( m_hRows )
      {
         ULONG       refCount[ ROWS ];
         DBROWSTATUS rowStat[ ROWS ];

         m_pIRowset->ReleaseRows( ROWS,
                                  m_hRows,
                                  NULL,
                                  refCount,
                                  rowStat );

         m_pIMalloc->Free( m_hRows );
         m_hRows        = NULL;
      }

      TRACE( _T("Ask for %d rows starting from %d\n"), ROWS, m_nLastRow + 1 );

      hResult        = m_pIRowset->GetNextRows(
                                                NULL,
                                                0,
                                                ROWS,
                                                //1L,
                                                &cRowsObtained,
                                                &m_hRows
                                              );
      TRACE( _T("After asking for %d rows starting from %d\n"), ROWS, m_nLastRow + 1 );

      if( SUCCEEDED( hResult ) )
      {
         m_nFirstRow = m_nLastRow + 1;
         m_nLastRow  = (int)(m_nFirstRow + cRowsObtained - 1);
      }

      m_bNoMoreData  = (cRowsObtained != ROWS);
   }

   SetCursor( oldCursor );

   return TRUE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::GetADsPath
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
BOOL  CADsOleDBDataSource::GetADsPath( int nRow, CString& rPath )
{
   ASSERT( nRow < m_ADsPath.GetSize( ) );

   if( ! (nRow < m_ADsPath.GetSize( ) ) )
   {
      return FALSE;
   }

   rPath = m_ADsPath.GetAt( nRow );

   return TRUE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::GetValue
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
BOOL  CADsOleDBDataSource::GetValue( int nRow, int nColumn, CString& rValue )
{
   HRESULT  hResult;

   nColumn += m_nAddOne;

   ASSERT( nRow >= 0 );
   if( nRow < 0 )
   {
      return FALSE;
   }

   ASSERT( nColumn >=0 && nColumn < (int)m_nColumnsCount );
   if( nColumn < 0 || nColumn >= (int)m_nColumnsCount )
   {
      return FALSE;
   }

   if( !BringRowInBuffer( nRow ) )
      return FALSE;

   if( m_nCurrentRow != nRow )
   {
      hResult  = m_pIRowset->GetData( m_hRows[nRow - m_nFirstRow],
                                      m_hAccessor,
                                      (void*)m_pData );
      m_nCurrentRow  = nRow;

      ReadADsPath( );
   }

   if( SUCCEEDED( hResult) )
   {
      rValue   = ExtractData( nColumn );
   }
   else
   {
      rValue   = _T("Error");
   }

   return TRUE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::ReadADsPath
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
void     CADsOleDBDataSource::ReadADsPath( void )
{
   CString  strADsPath;

   strADsPath  = ExtractData( 0 );
   m_ADsPath.Add( strADsPath );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::ExtractData
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
CString  CADsOleDBDataSource::ExtractData( int nColumn )
{
   ULONG    i;
   TCHAR    szValue[ 2048 ]   = _T("Error");
   HRESULT  hResult;

   i = nColumn;

   if( m_pData[i].status == DBSTATUS_S_ISNULL )
      return CString(_T("<No value>") );

   if( !( m_prgColInfo[i+1].dwFlags & DBCOLUMNFLAGS_ISNULLABLE &&
          m_pData[i].status == DBSTATUS_S_ISNULL))
   {

      switch(m_prgColInfo[i+1].wType)
      {
         case  DBTYPE_I8:
            LARGE_INTEGERToString( szValue, (LARGE_INTEGER*)&m_pData[i].obValue2 );
            break;

         case  DBTYPE_I4:
            wsprintf( szValue, _T("%ld"), (DWORD_PTR) m_pData[i].obValue );
            break;

         case DBTYPE_BOOL:
            wsprintf( szValue,  _T("%s"),
                      (VARIANT_TRUE == (VARIANT_BOOL) m_pData[i].obValue) ? _T("TRUE") : _T("FALSE") );

            break;

         case DBTYPE_DATE:
         {
            VARIANT  varTemp, varString;
            HRESULT  hResult;

            VariantInit( &varString );
            VariantInit( &varTemp );

            V_VT( &varTemp )     = VT_DATE;
            V_DATE( &varTemp )   = (DATE) m_pData[i].obValue2;

            hResult=  VariantChangeType( &varString, &varTemp, VARIANT_NOVALUEPROP, VT_BSTR );
            ASSERT( SUCCEEDED( hResult ) );

            if( SUCCEEDED( hResult ) )
            {
               Convert( szValue, V_BSTR( &varString ) );
               VariantClear( &varString );
            }

            break;
         }

         case DBTYPE_STR | DBTYPE_BYREF:
            if( NULL != (char *)m_pData[i].obValue )
            {
               wsprintf( szValue, _T("%s"), (char *)m_pData[i].obValue );
            }
            else
            {
               _tcscpy( szValue, _T("NULL") );
            }
            break;

         case DBTYPE_BYTES | DBTYPE_BYREF:
            {
               TCHAR szTemp[ 16 ];
               ULONG ulIter;
               BYTE* pByte;

               _ltot    ( m_pData[i].obLength, szTemp, 10 );
               _tcscpy  ( szValue, _T("[") );
               _tcscat  ( szValue, szTemp );
               _tcscat  ( szValue, _T("] ") );
               pByte    = (BYTE*) (m_pData[i].obValue);

               for( ulIter = 0; ulIter < m_pData[i].obLength && _tcslen( szValue ) < 2000; ulIter++ )
               {
                  BYTE  bVal;

                  bVal  = pByte[ ulIter ];
                  _itot( (int)bVal , szTemp, 16 );
                  _tcscat  ( szValue, _T("x") );
                  _tcscat  ( szValue, szTemp );
                  _tcscat  ( szValue, _T(" ") );
               }
            }
            break;

         case DBTYPE_WSTR | DBTYPE_BYREF:
            if( NULL != (WCHAR *)m_pData[i].obValue )
            {
               wsprintf( szValue, _T("%S"), (WCHAR *) m_pData[i].obValue );
            }
            else
            {
               _tcscpy( szValue, _T("NULL") );
            }
            break;

         case DBTYPE_VARIANT | DBTYPE_BYREF:
         {

            ULONG dwSLBound;
            ULONG dwSUBound, j;
            void HUGEP *pArray;
            VARIANT *pVariant;

            pArray   = NULL;
            pVariant = (VARIANT*) m_pData[i].obValue;

               if( NULL == pVariant )
                   _tcscpy( szValue, _T("ERROR!!! m_pData[i].obValue is NULL") );


            while( TRUE && (NULL != pVariant) )
            {

               ASSERT( V_VT( pVariant ) & VT_ARRAY );
               if( ! (V_VT( pVariant ) & VT_ARRAY ) )
                  break;


               hResult  = SafeArrayGetLBound( V_ARRAY(pVariant),
                                              1,
                                              (long FAR *) &dwSLBound );
               ASSERT( SUCCEEDED( hResult ) );
               if( FAILED( hResult ) )
                  break;

               hResult  = SafeArrayGetUBound( V_ARRAY(pVariant),
                                        1,
                                        (long FAR *) &dwSUBound );
               ASSERT( SUCCEEDED( hResult ) );
               if( FAILED( hResult ) )
                  break;

               hResult  = SafeArrayAccessData( V_ARRAY(pVariant),
                                               &pArray );
               ASSERT( SUCCEEDED( hResult ) );
               if( FAILED( hResult ) )
                  break;

               _tcscpy( szValue, _T("") );

               for ( j = dwSLBound; j <= dwSUBound; j++ )
               {
                  TCHAR szTemp[ 1024 ];

                  switch( pVariant->vt & ~VT_ARRAY )
                  {
                     case VT_BSTR:
                        Convert( szTemp, ( (BSTR *)pArray )[j] );
                        break;

                     case VT_I8:
                        LARGE_INTEGERToString( szTemp, &( (LARGE_INTEGER *)pArray )[j] );
                        break;

                     case VT_I4:
                        _ltot( ((DWORD *) pArray)[j], szTemp, 10 );
                        break;

                     case VT_BOOL:
                        _tcscpy( szTemp, (((VARIANT_BOOL *) pArray)[j]) == VARIANT_TRUE ?
                                 _T("TRUE") : _T("FALSE") );
                        break;

                     case  VT_VARIANT:
                     {
                        VARIANT* pVar;

                        pVar  = ((VARIANT *)pArray) + j;
                        switch( V_VT( pVar ) )
                        {
                           case VT_BSTR:
                              Convert( szTemp, V_BSTR( pVar ) );
                              break;

                           case VT_I4:
                              _ltot( V_I4( pVar ), szTemp, 10 );
                              break;

                           case VT_BOOL:
                              _tcscpy( szTemp, V_BOOL( pVar ) == VARIANT_TRUE ?
                                       _T("TRUE") : _T("FALSE") );
                              break;

                           default:
                               ASSERT( FALSE ) ;
                              _tcscpy( szTemp, _T("Unsupported") );
                              break;
                        }

                        break;
                     }

                     default:
                        _tcscpy( szTemp, _T("Unsupported") );
                  }

                  if( _tcslen( szValue) + _tcslen( szTemp ) < 2040 )
                  {
                     if( j != dwSLBound )
                     {
                        _tcscat( szValue, _T("# ") );
                     }

                     _tcscat( szValue, szTemp );
                  }
               }

               SafeArrayUnaccessData( V_ARRAY(pVariant) );
               break;
            }

            break;
         }

         default:
            wsprintf( szValue, _T("Don't know how to convert") );
            break;
      }
   }
   else
   {
      _tcscpy( szValue, _T("NA") );
   }

   return CString( szValue );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::BringRowInBuffer
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
BOOL  CADsOleDBDataSource::BringRowInBuffer( int nRow )
{
   if( nRow >= m_nFirstRow && nRow <= m_nLastRow )
      return TRUE;

   if( m_nLastRow == -1 )
      AdvanceCursor( );

   while( nRow > m_nLastRow && !m_bNoMoreData )
      AdvanceCursor( );

   if (nRow >= m_nFirstRow && nRow <= m_nLastRow)
   {
      return TRUE;
   }

   return FALSE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::DestroyInternalData
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
void  CADsOleDBDataSource::DestroyInternalData( void )
{
   if( m_hRows )
   {
      m_pIMalloc->Free( m_hRows );
   }
   if( m_pBindStatus )
   {
      LocalFree( m_pBindStatus );
   }
   if( m_pData )
   {
      LocalFree( m_pData );
   }
   if( m_pIRowset )
   {
      m_pIRowset->Release( );
   }
   if( m_pIColsInfo )
   {
      m_pIColsInfo->Release( );
   }
   if( m_pAccessor )
   {
      m_pAccessor->Release( );
   }
   if( m_prgColInfo )
   {
      m_pIMalloc->Free( m_prgColInfo );
   }
   if( m_szColNames )
   {
      m_pIMalloc->Free( m_szColNames );
   }
}



/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
CADsSearchDataSource::CADsSearchDataSource( )
{
   m_pSearch      = NULL;
   m_nCurrentRow  = -1;
   m_hSearch      = NULL;
}


/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
CADsSearchDataSource::~CADsSearchDataSource( )
{
   if( m_pSearch )
   {
      m_pSearch->CloseSearchHandle( m_hSearch );
      m_pSearch->Release( );
   }
}



/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
int   CADsSearchDataSource::GetColumnsCount( int nRow )
{
   BOOL  bOK;

   bOK   = BringRowInBuffer( nRow );
   if( bOK )
   {
      return (int)m_strColumns.GetSize( );
   }
   else
   {
      return 0;
   }
}


/*****************************************************************************
   Function:   CADsSearchDataSource::GetValue
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::GetValue( int nRow, int nColumn, CString& )
{
   return FALSE;
}

/*****************************************************************************
   Function:   CADsSearchDataSource::GetValue
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::GetValue( int nRow, CString& strColumn, CString& rValue )
{
   HRESULT           hResult;
   BSTR              bstrColumnName;
   ADS_SEARCH_COLUMN aSearchColumn;
   ADS_ATTR_INFO      aAttrDef;
   BOOL              bOK   = TRUE;
   COleDsSyntax*     pSyntax;

   rValue   = _T("<No value>");

   bOK   = BringRowInBuffer( nRow );
   if( bOK )
   {
      bstrColumnName = AllocBSTR( strColumn.GetBuffer( 256 ) );

      hResult        = m_pSearch->GetColumn( m_hSearch,
                                             bstrColumnName,
                                             &aSearchColumn );
      if( SUCCEEDED( hResult ) )
      {
         aAttrDef.pszAttrName = aSearchColumn.pszAttrName;
         aAttrDef.dwADsType   = aSearchColumn.dwADsType;
         aAttrDef.pADsValues  = aSearchColumn.pADsValues;
         aAttrDef.dwNumValues = aSearchColumn.dwNumValues;
         pSyntax              = NULL;

         pSyntax  = GetSyntaxHandler( aAttrDef.dwADsType, rValue );

         if( pSyntax )
         {
            hResult  = pSyntax->Native2Value( &aAttrDef, rValue );
            delete pSyntax;
         }

         hResult        = m_pSearch->FreeColumn( &aSearchColumn );
      }

      SysFreeString( bstrColumnName );
   }

   return bOK;
}


/*****************************************************************************
   Function:   CADsSearchDataSource::GetADsPath
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::GetADsPath( int nRow, CString& rPath )
{
   ASSERT( nRow < m_ADsPath.GetSize( ) );

   if( ! (nRow < m_ADsPath.GetSize( ) ) )
   {
      return FALSE;
   }

   rPath = m_ADsPath.GetAt( nRow );

   return TRUE;
}


/*****************************************************************************
   Function:   CADsSearchDataSource::GetColumnText
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::GetColumnText( int nRow, int nColumn, CString& rColumn )
{
   BOOL  bOK   = TRUE;

   bOK   = BringRowInBuffer( nRow );
   if( bOK )
   {
      rColumn  = m_strColumns[ nColumn ];
   }

   return bOK;
}


/*****************************************************************************
   Function:   CADsSearchDataSource::RunTheQuery
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::RunTheQuery( void )
{
   HRESULT  hResult;
   HCURSOR  aCursor, oldCursor;

   aCursor     = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( aCursor );
   while( TRUE )
   {

      hResult  = CreateSearchInterface( );
      if( FAILED( hResult ) )
         break;

      hResult  = SetSearchPreferences( );
      if( FAILED( hResult ) )
         break;

      hResult  = SetAttributesName( );
      break;
   }
   SetCursor( oldCursor );

   m_bNoMoreData  = FALSE;

   return (S_OK == hResult);
}


/*****************************************************************************
   Function:   CADsSearchDataSource::SetAttributesName
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
HRESULT  CADsSearchDataSource::SetAttributesName( void )
{
   HRESULT  hResult  = E_FAIL;
   BSTR     bstrSearchFilter;
   DWORD    dwNumAttributes = (DWORD)-1;
   BSTR     ppszAttributes[ 128 ];
   int      nIterator;
   TCHAR    szAttribute[ 128 ];
   CString  strAttr;
   CString  strAttributes;

   bstrSearchFilter  = AllocBSTR( m_pSearchPref->szQuery );
   strAttributes   = m_pSearchPref->szAttributes;

   // first, we need to figure out how many attributes are requested
   strAttributes.TrimLeft( );
   strAttributes.TrimRight( );

   if( strAttributes.CompareNoCase( _T("*") ) )
   {
      dwNumAttributes   = 1;
      _tcscpy( szAttribute, _T("") );

      for( nIterator = 0; nIterator < strAttributes.GetLength( ) ; nIterator++ )
      {
         if( strAttributes[ nIterator ] == _T(',') )
         {
            strAttr  = szAttribute;
            strAttr.TrimLeft( );
            strAttr.TrimRight( );

            ppszAttributes[ dwNumAttributes - 1 ]  = AllocBSTR( strAttr.GetBuffer( 128 ) );
            dwNumAttributes++;
            _tcscpy( szAttribute, _T("") );
         }
         else
         {
            TCHAR szChars[ 2 ];

            szChars[ 1 ]   = _T('\0');
            szChars[ 0 ]   = strAttributes[ nIterator ];
            _tcscat( szAttribute, szChars );

            if( nIterator == strAttributes.GetLength( ) - 1 )
            {
               strAttr  = szAttribute;
               strAttr.TrimLeft( );
               strAttr.TrimRight( );

               ppszAttributes[ dwNumAttributes - 1 ]  = AllocBSTR( strAttr.GetBuffer( 128 ) );
            }
         }
      }
   }

   hResult  = m_pSearch->ExecuteSearch(
                                        bstrSearchFilter,
                                        ppszAttributes,
                                        dwNumAttributes,
                                        &m_hSearch
                                      );

   if( FAILED( hResult ) )
   {
      TRACE(_T("ExecuteSearch failed with %lx \n"), hResult);
      AfxMessageBox( _T("ExecuteSearch failed") );
   }

   for( nIterator = 0; nIterator < (int)dwNumAttributes ; nIterator++ )
   {
      SysFreeString( ppszAttributes[ nIterator ] );
   }

   SysFreeString( bstrSearchFilter );

   return hResult;
}


/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
/*HRESULT  CADsSearchDataSource::SetSearchPreferences( )
{
   CSearchPreferencesDlg   aSearchPref;
   ADS_SEARCHPREF_INFO     arrSearchPref[ 20 ];
   int                     nSearchPrefCount  = 0;
   HRESULT                 hResult;

   if( aSearchPref.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }
   //***************************************************************************
   if( !aSearchPref.m_strAsynchronous.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
      arrSearchPref[nSearchPrefCount].vValue.dwType= ADSTYPE_BOOLEAN;
      if( !aSearchPref.m_strAsynchronous.CompareNoCase( _T("Yes") ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Boolean = TRUE;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Boolean = FALSE;
      }
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strAttributesOnly.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_BOOLEAN;
      if( !aSearchPref.m_strAttributesOnly.CompareNoCase( _T("Yes") ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Boolean = TRUE;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Boolean = FALSE;
      }
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strDerefAliases.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
      arrSearchPref[nSearchPrefCount].vValue.dwType= ADSTYPE_INTEGER;
      if( !aSearchPref.m_strDerefAliases.CompareNoCase( _T("Yes") ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_DEREF_ALWAYS;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_DEREF_NEVER;
      }
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strTimeOut.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_TIMEOUT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = _ttoi( aSearchPref.m_strTimeOut.GetBuffer( 16 ) );
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strTimeLimit.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_TIME_LIMIT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = _ttoi( aSearchPref.m_strTimeLimit.GetBuffer( 16 ) );
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strSizeLimit.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_SIZE_LIMIT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = _ttoi( aSearchPref.m_strSizeLimit.GetBuffer( 16 ) );
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strPageSize.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_PAGESIZE;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = _ttoi( aSearchPref.m_strPageSize.GetBuffer( 16 ) );
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strScope.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_SEARCH_SCOPE;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      if (!aSearchPref.m_strScope.CompareNoCase( _T("Base" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_BASE;
      }
      if (!aSearchPref.m_strScope.CompareNoCase( _T("OneLevel" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_ONELEVEL;
      }
      if (!aSearchPref.m_strScope.CompareNoCase( _T("Subtree" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_SUBTREE;
      }
      nSearchPrefCount++;
   }

   hResult  = m_pSearch->SetSearchPreference( arrSearchPref, nSearchPrefCount );

   ASSERT( SUCCEEDED( hResult ) );

   return hResult;

} */



/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
HRESULT  CADsSearchDataSource::SetSearchPreferences( )
{
   ADS_SEARCHPREF_INFO     arrSearchPref[ 20 ];
   int                     nSearchPrefCount  = 0;
   HRESULT                 hResult;

   //***************************************************************************
   if( -1 != m_pSearchPref->nAsynchronous )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
      arrSearchPref[nSearchPrefCount].vValue.dwType= ADSTYPE_BOOLEAN;
      arrSearchPref[nSearchPrefCount].vValue.Boolean = (BOOLEAN) m_pSearchPref->nAsynchronous;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nAttributesOnly )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_BOOLEAN;
      arrSearchPref[nSearchPrefCount].vValue.Boolean  = (BOOLEAN) m_pSearchPref->nAttributesOnly;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nDerefAliases )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
      arrSearchPref[nSearchPrefCount].vValue.dwType= ADSTYPE_INTEGER;
      if( m_pSearchPref->nDerefAliases )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_DEREF_ALWAYS;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_DEREF_NEVER;
      }
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nTimeOut )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_TIMEOUT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = m_pSearchPref->nTimeOut;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nTimeLimit )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_TIME_LIMIT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = m_pSearchPref->nTimeLimit;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nSizeLimit )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_SIZE_LIMIT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = m_pSearchPref->nSizeLimit;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nPageSize )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_PAGESIZE;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = m_pSearchPref->nPageSize;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( _tcslen( m_pSearchPref->szScope ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_SEARCH_SCOPE;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      if( !_tcsicmp( m_pSearchPref->szScope, _T("Base" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_BASE;
      }
      if( !_tcsicmp( m_pSearchPref->szScope, _T("OneLevel" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_ONELEVEL;
      }
      if( !_tcsicmp( m_pSearchPref->szScope, _T("Subtree" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_SUBTREE;
      }
      nSearchPrefCount++;
   }


   //***************************************************************************
   if( -1 != m_pSearchPref->nChaseReferrals )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_CHASE_REFERRALS;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      if( m_pSearchPref->nChaseReferrals )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer  = ADS_CHASE_REFERRALS_ALWAYS;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer  = ADS_CHASE_REFERRALS_NEVER;
      }
      nSearchPrefCount++;
   }

   hResult  = m_pSearch->SetSearchPreference( arrSearchPref, nSearchPrefCount );

   ASSERT( S_OK == hResult );

   return hResult;
}



/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
HRESULT  CADsSearchDataSource::CreateSearchInterface( )
{
   BSTR     bstrPath;
   HRESULT  hResult  = E_FAIL;

   bstrPath = AllocBSTR( m_pSearchPref->szSource );

   if( _tcslen( m_pSearchPref->szUserName ) )
   {
      BSTR  bstrOpenAs;
      BSTR  bstrPassword;
      LONG  lControlCode = 0L;

      bstrOpenAs     = AllocBSTR( m_pSearchPref->szUserName );
      bstrPassword   = AllocBSTR( m_pSearchPref->szPassword );

      if( m_pSearchPref->bEncryptPassword )
         lControlCode   = lControlCode | ADS_SECURE_AUTHENTICATION;

      hResult        = ADsOpenObject( bstrPath,
                                      _wcsicmp( bstrOpenAs, L"NULL" ) ? bstrOpenAs : NULL,
                                      _wcsicmp( bstrPassword, L"NULL" ) ? bstrPassword : NULL,
                                      lControlCode, IID_IDirectorySearch, (void**)&m_pSearch );
      SysFreeString( bstrOpenAs );
      SysFreeString( bstrPassword );
   }
   else
   {
      hResult  = ADsGetObject( bstrPath, IID_IDirectorySearch, (void**)&m_pSearch );
   }

   ASSERT( SUCCEEDED( hResult ) );

   SysFreeString( bstrPath );

   return hResult;
}


/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL     CADsSearchDataSource::BringRowInBuffer( int nRow )
{
   HRESULT  hResult  = E_FAIL;

   if( NULL == m_pSearch )
   {
      m_bNoMoreData  = TRUE;
   }

   if( m_bNoMoreData )
      return FALSE;

   if( m_nCurrentRow == nRow )
      return TRUE;

   if( m_nCurrentRow != -1 )
   {
      ASSERT( nRow >= m_nCurrentRow );
   }

   while( m_nCurrentRow != nRow )
   {
      m_bNoMoreData  = TRUE;
      TRACE(  _T("Asking for row %d\n"), m_nCurrentRow + 1);
      hResult  = m_pSearch->GetNextRow( m_hSearch );
      if( hResult != S_OK )
         break;
      m_bNoMoreData  = FALSE;

      if( hResult == S_ADS_NOMORE_ROWS )
      {
         m_bNoMoreData  = TRUE;
      }

      m_nCurrentRow++;
   }

   if( hResult == S_OK )
   {
      ReadColumnNames( nRow );
   }

   return ( hResult == S_OK );
}


/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::ReadColumnNames( int nRow )
{
   HRESULT  hResult = E_FAIL;
   WCHAR*   pszColumnName;
   TCHAR    szColumn[ 256 ];

   ASSERT( nRow == m_nCurrentRow );
   if( nRow != m_nCurrentRow )
   {
      return FALSE;
   }

   m_strColumns.RemoveAll( );
   ReadADsPath( );

   while( TRUE )
   {
      hResult  = m_pSearch->GetNextColumnName( m_hSearch, &pszColumnName );
      //if( SUCCEEDED( hResult ) )
      if( S_OK == hResult )
      {
         Convert( szColumn, pszColumnName );
         m_strColumns.Add( szColumn );
         FreeADsStr( pszColumnName );
      }
      //if( FAILED( hResult ) )
      else
      {
         break;
      }
   }

   return TRUE;
}

/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
void  CADsSearchDataSource::ReadADsPath( void )
{
   HRESULT           hResult;
   BSTR              bstrColumnName;
   ADS_SEARCH_COLUMN aSearchColumn;
   ADS_ATTR_INFO      aAttrDef;
   BOOL              bOK   = TRUE;
   COleDsSyntax*     pSyntax;
   CString           rValue   = _T("");

   bstrColumnName = AllocBSTR( _T("ADsPath") );

   hResult        = m_pSearch->GetColumn( m_hSearch,
                                          bstrColumnName,
                                          &aSearchColumn );
   SysFreeString( bstrColumnName );

   if( SUCCEEDED( hResult ) )
   {
      aAttrDef.pszAttrName = aSearchColumn.pszAttrName;
      aAttrDef.dwADsType   = aSearchColumn.dwADsType;
      aAttrDef.pADsValues  = aSearchColumn.pADsValues;
      aAttrDef.dwNumValues = aSearchColumn.dwNumValues;

      pSyntax  = new COleDsBSTR;

      hResult  = pSyntax->Native2Value( &aAttrDef, rValue );
      delete pSyntax;

      hResult        = m_pSearch->FreeColumn( &aSearchColumn );
   }

   m_ADsPath.Add( rValue );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\adsqdoc.h ===
// adsqryDoc.h : interface of the CAdsqryDoc class
//
/////////////////////////////////////////////////////////////////////////////

#include "adsdsrc.h"

class CAdsqryDoc : public CDocument
{
protected: // create from serialization only
	CAdsqryDoc();
	DECLARE_DYNCREATE(CAdsqryDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdsqryDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAdsqryDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
   CADsDataSource*   GetADsDataSource( ) {return m_pDataSource;};

protected:
   BOOL              GetSearchPreferences( SEARCHPREF* );

protected:
   CADsDataSource*   m_pDataSource;

// Generated message map functions
protected:
	//{{AFX_MSG(CAdsqryDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cdomain.h ===
#ifndef  _CDOMAIN_H_
#define  _CDOMAIN_H_

class COleDsDomain: public COleDsObject
{

public:   
   COleDsDomain( IUnknown* );
   COleDsDomain( );
   ~COleDsDomain( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\ccomp.h ===
#ifndef  _CCOMPUTER_H_
#define  _CCOMPUTER_H_

class COleDsComputer: public COleDsObject
{

public:   
   COleDsComputer( IUnknown* );
   COleDsComputer( );
   ~COleDsComputer( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

public:
   DWORD    GetChildren( DWORD*     pTokens, 
                         DWORD      dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, 
                         DWORD      dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\bwsview.h ===
// BrowseView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBrowseView view

class CBrowseView : public CTreeView
{
protected:
	CBrowseView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBrowseView)

// Attributes
public:
   void  OnInitialUpdate( void );
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowseView)
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBrowseView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBrowseView)
	afx_msg void OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnAddItem();
	afx_msg void OnDeleteItem();
	afx_msg void OnMoveItem();
	afx_msg void OnCopyItem();
	afx_msg void OnRefresh();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
   void  SortChildItemList( DWORD*, DWORD );

   BOOL        m_bDoNotUpdate;
   CImageList* m_pImageList;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cacls.h ===
// cacls.h: interface for the CADsAccessControlEntry class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CACLS_H__11DBDB41_BC2B_11D0_B1D8_00C04FD702AD__INCLUDED_)
#define AFX_CACLS_H__11DBDB41_BC2B_11D0_B1D8_00C04FD702AD__INCLUDED_

#if _MSC_VER >= 1000
#if (!defined(BUILD_FOR_NT40))
#pragma once
#endif
#endif // _MSC_VER >= 1000

typedef enum _tagACLTYPE
{
   acl_Invalid = 0,
   acl_DACL,
   acl_SACL,
   acl_Limit
} ACLTYPE;

class CADsAccessControlEntry : public COleDsObject  
{
   public:
	   CADsAccessControlEntry  ( void      );
      CADsAccessControlEntry  ( IUnknown* );
	   ~CADsAccessControlEntry ( void      );

   public:
	   void FooFunction(void);
      IDispatch*  GetACE      ( void      );
      IDispatch*  CreateACE   ( void      );

      HRESULT     PutProperty ( int, 
                                CString&, 
                                long Code = ADS_PROPERTY_UPDATE );

      HRESULT     GetProperty ( int, 
                                CString&  );

   private:
      void        InitializeMembers( void );

};

class CADsAccessControlList : public COleDsObject
{
   public:
	   CADsAccessControlList      ( void      );
      CADsAccessControlList      ( IUnknown* );
	   ~CADsAccessControlList     ( void      );

   public:
      IDispatch*     GetACL      ( void      );
      IDispatch*     CreateACL   ( void      );
      
      void           SetDocument ( CMainDoc* );
      
      int            GetACECount ( void      );
      CADsAccessControlEntry*  GetACEObject( int nACE  );

      HRESULT        AddACE      ( IUnknown* pNewACE );
      HRESULT        RemoveACE   ( IUnknown* pRemoveACE );

      void           RemoveAllACE( void      );

      HRESULT        PutProperty ( int, 
                                   int, 
                                   CString&, 
                                   long Code = ADS_PROPERTY_UPDATE );

      HRESULT        GetProperty ( int, 
                                   int, 
                                   CString&  );
      

   private:
      void  InitializeMembers    ( void      );

   private:
      CObArray  m_arrACE;
};


class CADsSecurityDescriptor : public COleDsObject  
{
   public:
	   CADsSecurityDescriptor();
      CADsSecurityDescriptor( IUnknown* );
	   virtual ~CADsSecurityDescriptor();

   public:
      HRESULT        PutProperty ( int, 
                                   CString&, 
                                   long Code = ADS_PROPERTY_UPDATE );
      HRESULT        GetProperty ( int, 
                                   CString& );

      
      HRESULT        PutProperty ( ACLTYPE, 
                                   int, 
                                   int, 
                                   CString&, 
                                   long Code = ADS_PROPERTY_UPDATE );

      HRESULT        GetProperty ( ACLTYPE, 
                                   int, 
                                   int, 
                                   CString& );

      HRESULT        PutACL      ( IDispatch* pACL, 
                                   ACLTYPE eACL );

	   IDispatch*     GetACL      ( ACLTYPE eACL );
      CADsAccessControlList*     GetACLObject( ACLTYPE eACL );
      
      HRESULT        AddACE      ( ACLTYPE eACL, IUnknown* pNewACE );
      HRESULT        RemoveACE   ( ACLTYPE eACL, IUnknown* pNewACE );
      void           RemoveAllACE( ACLTYPE eACL );
      int            GetACECount ( ACLTYPE eACL );
      void           SetDocument ( CMainDoc*    );

   private:
      void                    InitializeMembers ( );
      

   private:
      COleDsObject*  pACLObj[ acl_Limit ];
};


#endif // !defined(AFX_CACLS_H__11DBDB41_BC2B_11D0_B1D8_00C04FD702AD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cfserv.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "resource.h"
#include "grpcrtit.h"
#include "delgrpit.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileService::COleDsFileService( )
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileService::COleDsFileService( IUnknown *pIUnk): COleDsService( pIUnk )
{
   m_bHasChildren    = TRUE;
   m_bSupportAdd     = TRUE;   
   m_bSupportDelete  = TRUE;   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileService::~COleDsFileService( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsFileService::GetChildren( DWORD*     pTokens, 
                                         DWORD      dwMaxChildren,
                                         CDialog*   pQueryStatus,
                                         BOOL*      pFilters, 
                                         DWORD      dwFilters )
{
   HRESULT                          hResult;
   IADsFileService*               pIOleDsFileService   = NULL;
   IADsFileServiceOperations*     pIFServOper       = NULL;
   IADsCollection*                pICollFShares  = NULL;
   IADsCollection*                pICollSessions = NULL;
   IADsCollection*                pICollRes      = NULL;
   IADsContainer*                 pIContainer    = NULL;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsFileService, 
                                       (void**) &pIOleDsFileService );
   hResult  = m_pIUnk->QueryInterface( IID_IADsFileServiceOperations, 
                                       (void**) &pIFServOper );

   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
      return 0L;
   hResult  = pIOleDsFileService->QueryInterface( IID_IADsContainer, 
                                          (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      pIOleDsFileService->Release( );

      return 0L;
   }
   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   hResult  = pIFServOper->Sessions ( &pICollSessions );
   hResult  = pIFServOper->Resources( &pICollRes      );

   if( NULL != pICollFShares )
   {
      COleDsObject::GetChildren( pICollFShares );
      pICollFShares->Release( );
   }
   if( NULL != pICollSessions )
   {
      COleDsObject::GetChildren( pICollSessions );
      pICollSessions->Release( );
   }
   if( NULL != pICollRes )
   {
      COleDsObject::GetChildren( pICollRes );
      pICollRes->Release( );
   }
   pIFServOper->Release( );
   pIOleDsFileService->Release( );

   return m_dwCount;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsFileService::DeleteItem( COleDsObject* pObject )
{
   DWORD                         dwType;
   HRESULT                       hResult;
   CString                       strQualifiedName;
   CString                       strItemType;
   CString                       strDeleteName;
   CDeleteGroupItem              aDeleteItem;
   IADsCollection*             pIColl      = NULL;
   IADsFileService*            pIFServ     = NULL;

   
   hResult  = m_pIUnk->QueryInterface( IID_IADsFileService, (void**)&pIFServ );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      return E_FAIL;
   }

   dwType   = pObject->GetType( );

   switch( dwType )
   {
      case  FILESHARE:
      {
         return ContainerDeleteItem( pObject );
      }

      case  SESSION:
      {
         IADsFileServiceOperations*  pIOper   = NULL;

         hResult  = pIFServ->QueryInterface( IID_IADsFileServiceOperations, (void**)&pIOper );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
         {
            break;
         }
         hResult  = pIOper->Sessions( &pIColl );
         pIOper->Release( );
         break;
      }

      case  RESOURCE:
      {
         IADsFileServiceOperations*  pIOper   = NULL;

         hResult  = pIFServ->QueryInterface( IID_IADsFileServiceOperations, (void**)&pIOper );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
         {
            break;
         }
         hResult  = pIOper->Resources( &pIColl );
         pIOper->Release( );
         break;
      }

      default:
         ASSERT( FALSE );
         return E_FAIL;
   }
   
   if( NULL != pIColl )
   {
      strDeleteName  = pObject->GetDeleteName( );   
      MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );

      strItemType = pObject->GetClass( ); 

      aDeleteItem.m_strItemName  = strDeleteName;
      aDeleteItem.m_strParent    = strQualifiedName;
      aDeleteItem.m_strItemType  = strItemType;
      if( aDeleteItem.DoModal( ) == IDOK )
      {
         VARIANT  var;

         VariantInit( &var );
         V_VT( &var )   = VT_BSTR;
         V_BSTR( &var ) = AllocBSTR( aDeleteItem.m_strItemName.GetBuffer( 128 ) );
         hResult        = pIColl->Remove( V_BSTR( &var ) );
         VariantClear( &var );
      }
      pIColl->Release( );
   }

   pIFServ->Release( );

   return hResult;   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsFileService::AddItem( )
{
   return ContainerAddItem( );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsFileService::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsFileService::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\ccomp.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "resource.h"
#include "createit.h"
#include "delitem.h"

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsComputer::COleDsComputer( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsComputer::COleDsComputer( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = TRUE;
   m_bSupportAdd  = TRUE;
   m_bSupportMove = TRUE;
   m_bSupportCopy = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsComputer::~COleDsComputer( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsComputer::GetChildren( DWORD*     pTokens, 
                                      DWORD      dwMaxChildren,
                                      CDialog*   pQueryStatus,
                                      BOOL*      pFilters, 
                                      DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}
  


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsComputer::DeleteItem  ( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsComputer::AddItem( )
{
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsComputer::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsComputer::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cdomain.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "objects.h"
#include "maindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsDomain::COleDsDomain( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsDomain::COleDsDomain( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsDomain::~COleDsDomain( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsDomain::GetChildren( DWORD*     pTokens, 
                                    DWORD      dwMaxChildren,
                                    CDialog*   pQueryStatus,
                                    BOOL*      pFilters, 
                                    DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}

  
   
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsDomain::DeleteItem( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsDomain::AddItem( )
{
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsDomain::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsDomain::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cacls.cpp ===
// cacls.cpp: implementation of the CADsAccessControlEntry class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "cacls.h"
#include "newquery.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************

//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlEntry::CADsAccessControlEntry()
{
   InitializeMembers( );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlEntry::CADsAccessControlEntry( IUnknown* pIUnk)
   :COleDsObject( pIUnk )
{
   InitializeMembers( );
}

//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlEntry::~CADsAccessControlEntry( )
{
}



//***********************************************************
//  Function:    CADsAccessControlEntry::PutProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlEntry::PutProperty ( int nProp,
                                               CString& rValue,
                                               long lCode  )
{
   BOOL     bOldUseGeneric;
   HRESULT  hResult;

   bOldUseGeneric = m_pDoc->GetUseGeneric( );

   m_pDoc->SetUseGeneric( FALSE );

   hResult  = COleDsObject::PutProperty( nProp, rValue, lCode );

   m_pDoc->SetUseGeneric( bOldUseGeneric );

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlEntry::GetProperty ( int nProp,
                                               CString& rValue )
{
   BOOL     bOldUseGeneric;
   HRESULT  hResult;

   bOldUseGeneric = m_pDoc->GetUseGeneric( );

   m_pDoc->SetUseGeneric( FALSE );

   hResult  = COleDsObject::GetProperty( nProp, rValue );

   m_pDoc->SetUseGeneric( bOldUseGeneric );

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch*  CADsAccessControlEntry::GetACE( )
{
   IDispatch*  pDispatch   = NULL;

   if( NULL != m_pIUnk )
   {
      m_pIUnk->QueryInterface( IID_IDispatch, (void**)&pDispatch );
   }

   return pDispatch;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch*  CADsAccessControlEntry::CreateACE( )
{
   IDispatch*              pDispatch   = NULL;
   IADsAccessControlEntry* pNewACE     = NULL;
   HRESULT                 hResult     = NULL;
   DWORD                   dwAceType = 0;
   CACEDialog              aDialog;
   BSTR                    bstrTrustee;


   if( IDOK != aDialog.DoModal( ) )
      return NULL;

   hResult = CoCreateInstance(
                               CLSID_AccessControlEntry,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IADsAccessControlEntry,
                               (void **)&pNewACE
                             );
   if( SUCCEEDED( hResult ) )
   {
      bstrTrustee = AllocBSTR( aDialog.m_strTrustee.GetBuffer( 128 ) );

      pNewACE->put_Trustee( bstrTrustee );
      hResult  = pNewACE->QueryInterface( IID_IDispatch,
                                          (void**)&pDispatch );
      SysFreeString( bstrTrustee );
      pNewACE->Release( );
   }

   return pDispatch;
   return NULL;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsAccessControlEntry::InitializeMembers ( )
{
   IADsAccessControlEntry* pEntry;
   HRESULT           hResult;

   if( NULL != m_pIUnk )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsAccessControlEntry,
                                          (void**)&pEntry );
      if( SUCCEEDED( hResult ) )
      {
         BSTR  bstrTrustee = NULL;
         TCHAR szTrustee[ 256 ];

         pEntry->get_Trustee( &bstrTrustee );
         if( NULL != bstrTrustee )
         {
            Convert( szTrustee, bstrTrustee );
            m_strItemName  = szTrustee;
         }
         SysFreeString( bstrTrustee );
         pEntry->Release( );
      }
   }
   m_strSchemaPath   = _T("ACE");
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsSecurityDescriptor::CADsSecurityDescriptor()
{
   InitializeMembers( );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsSecurityDescriptor::CADsSecurityDescriptor( IUnknown* pIUnk )
   :COleDsObject( pIUnk )
{
   /*IADsSecurityDescriptor* pSecD;
   IDispatch*              pCopy;
   HRESULT  hResult;

   hResult  = m_pIUnk->QueryInterface( IID_IADsSecurityDescriptor,
                                       (void**)&pSecD );

   hResult  = pSecD->CopySecurityDescriptor( &pCopy );

   if( SUCCEEDED( hResult ) )
   {
      m_pIUnk->Release( );
      hResult  = pCopy->QueryInterface( IID_IUnknown,(void**)&m_pIUnk );
      pCopy->Release( );
   }

   pSecD->Release( );*/

   InitializeMembers( );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsSecurityDescriptor::~CADsSecurityDescriptor()
{
   for( int nIdx = 0; nIdx < (int) acl_Limit ; nIdx++ )
   {
      if( NULL != pACLObj[ nIdx ] )
         delete pACLObj[ nIdx ];
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsSecurityDescriptor::PutProperty ( int nProp,
                                               CString& rValue,
                                               long lCode )
{
   BOOL     bOldUseGeneric;
   HRESULT  hResult;

   bOldUseGeneric = m_pDoc->GetUseGeneric( );

   m_pDoc->SetUseGeneric( FALSE );

   hResult  = COleDsObject::PutProperty( nProp, rValue, lCode );

   m_pDoc->SetUseGeneric( bOldUseGeneric );

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsSecurityDescriptor::GetProperty ( int nProp,
                                               CString& rValue )
{
   BOOL     bOldUseGeneric;
   HRESULT  hResult;

   bOldUseGeneric = m_pDoc->GetUseGeneric( );

   m_pDoc->SetUseGeneric( FALSE );

   hResult  = COleDsObject::GetProperty( nProp, rValue );

   m_pDoc->SetUseGeneric( bOldUseGeneric );

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsSecurityDescriptor::InitializeMembers ( )
{
   HRESULT                 hResult;
   IADsSecurityDescriptor* pDescriptor = NULL;
   IDispatch*              pDispACL;

   m_strSchemaPath   = _T("SecurityDescriptor");

   pACLObj[ acl_SACL ]     = NULL;
   pACLObj[ acl_DACL ]     = NULL;
   pACLObj[ acl_Invalid ]    = NULL;

   if( NULL == m_pIUnk )
      return;

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsSecurityDescriptor,
                                          (void**)&pDescriptor );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      pDispACL = GetACL( acl_DACL );
      ASSERT( NULL != pDispACL );

      if( NULL != pDispACL )
      {
         pACLObj[ acl_DACL ]  = new CADsAccessControlList( pDispACL );
         pDispACL->Release( );
      }

      pDispACL = GetACL( acl_SACL );
      ASSERT( NULL != pDispACL );

      if( NULL != pDispACL )
      {
         pACLObj[ acl_SACL ]  = new CADsAccessControlList( pDispACL );
         pDispACL->Release( );
      }

      break;
   }

   if( NULL != pDescriptor )
   {
      pDescriptor->Release( );
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch* CADsSecurityDescriptor::GetACL( ACLTYPE eType )
{
   HRESULT                    hResult;
   IDispatch*                 pACL        = NULL;
   IDispatch*                 pCopyACL    = NULL;
   IADsSecurityDescriptor*    pSecDescr   = NULL;

   while( TRUE )
   {
      if( NULL == m_pIUnk )
         break;

      //QI for IID_IADsSecurityDescriptor interface

      hResult  = m_pIUnk->QueryInterface( IID_IADsSecurityDescriptor,
                                          (void**)&pSecDescr );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         break;
      }

      hResult  = E_FAIL;

      if( acl_DACL == eType )
      {
         hResult  = pSecDescr->get_DiscretionaryAcl( &pACL );
      }
      if( acl_SACL == eType )
      {
         hResult  = pSecDescr->get_SystemAcl( &pACL );
      }
      pSecDescr->Release( );

      ASSERT( SUCCEEDED( hResult ) );
      break;
   }

   if( NULL != pACL )
   {
      //pCopyACL = CopyACL( pACL );
      //pACL->Release( );

      pACL->QueryInterface( IID_IDispatch, (void**)&pCopyACL );
      pACL->Release( );
   }

   return pCopyACL;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT CADsSecurityDescriptor::PutACL( IDispatch * pACL,
                                        ACLTYPE eACL )
{
   HRESULT     hResult;
   IADsSecurityDescriptor*  pSecDescr   = NULL;

   while( TRUE )
   {
      if( NULL == m_pIUnk )
         break;

      //QI for IID_IADsSecurityDescriptor interface

      hResult  = m_pIUnk->QueryInterface( IID_IADsSecurityDescriptor,
                                          (void**)&pSecDescr );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         break;
      }

      hResult  = E_FAIL;

      if( acl_DACL == eACL )
      {
         hResult  = pSecDescr->put_DiscretionaryAcl( pACL );
      }
      if( acl_SACL == eACL )
      {
         hResult  = pSecDescr->put_SystemAcl( pACL );
      }

      pSecDescr->Release( );
      break;
   }

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsSecurityDescriptor::AddACE( ACLTYPE eACL, IUnknown* pNewACE )
{
   ASSERT( acl_DACL == eACL || acl_SACL == eACL );

   if( acl_DACL != eACL && acl_SACL != eACL )
      return -1;

   if( NULL == pACLObj[ (int)eACL ] )
      return -1;

   return ((CADsAccessControlList*)(pACLObj[ (int)eACL ]))->AddACE( pNewACE );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsSecurityDescriptor::RemoveACE( ACLTYPE eACL, IUnknown* pRemoveACE )
{
   ASSERT( acl_DACL == eACL || acl_SACL == eACL );

   if( acl_DACL != eACL && acl_SACL != eACL )
      return -1;

   if( NULL == pACLObj[ (int)eACL ] )
      return -1;

   return ((CADsAccessControlList*)(pACLObj[ (int)eACL ]))->RemoveACE( pRemoveACE );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsSecurityDescriptor::SetDocument( CMainDoc* pDoc )
{
   int   nIdx;

   COleDsObject::SetDocument ( pDoc );

   for( nIdx = 0 ; nIdx < (int)acl_Limit ; nIdx++ )
   {
      if( NULL != pACLObj[ nIdx ] )
         pACLObj[ nIdx ]->SetDocument( pDoc );
   }
}

//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsSecurityDescriptor::RemoveAllACE( ACLTYPE eACL )
{
   ASSERT( acl_DACL == eACL || acl_SACL == eACL );

   if( acl_DACL != eACL && acl_SACL != eACL )
      return;

   if( NULL == pACLObj[ (int)eACL ] )
      return;
}



//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlList*  CADsSecurityDescriptor::GetACLObject( ACLTYPE eACL )
{
   CADsAccessControlList* pACL;

   ASSERT( acl_DACL == eACL || acl_SACL == eACL );

   if( acl_DACL != eACL && acl_SACL != eACL )
      return NULL;

   pACL  = (CADsAccessControlList*) (pACLObj[ (int)eACL ]);

   return pACL;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlList::CADsAccessControlList()
{
   InitializeMembers( );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlList::CADsAccessControlList( IUnknown* pUnk ):
   COleDsObject( pUnk )
{
   InitializeMembers( );
}


//***********************************************************
//  Function:    CADsAccessControlList::AddACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlList::AddACE( IUnknown* pNewACE )
{
   IDispatch*  pDisp = NULL;
   HRESULT     hResult;
   IADsAccessControlList*  pACL  = NULL;

   if( NULL == m_pIUnk )
   {
      return E_FAIL;
   }

   hResult  = m_pIUnk->QueryInterface( IID_IADsAccessControlList,
                                       (void**)&pACL );

   if( FAILED( hResult ) )
      return hResult;

   hResult  = pNewACE->QueryInterface( IID_IDispatch, (void**)&pDisp );
   if( SUCCEEDED( hResult ) )
   {
      hResult  = pACL->AddAce( pDisp );

      if( SUCCEEDED( hResult ) )
         InitializeMembers( );

      pDisp->Release( );
   }

   pACL->Release( );

   return hResult;
}


//***********************************************************
//  Function:    CADsAccessControlList::AddACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlList::RemoveACE( IUnknown* pRemoveACE )
{
   IDispatch*  pDisp = NULL;
   HRESULT     hResult;
   IADsAccessControlList*  pACL  = NULL;

   if( NULL == m_pIUnk )
   {
      return E_FAIL;
   }

   hResult  = m_pIUnk->QueryInterface( IID_IADsAccessControlList,
                                       (void**)&pACL );

   if( FAILED( hResult ) )
      return hResult;

   hResult  = pRemoveACE->QueryInterface( IID_IDispatch, (void**)&pDisp );
   if( SUCCEEDED( hResult ) )
   {
      hResult  = pACL->RemoveAce( pDisp );

      if( SUCCEEDED( hResult ) )
         InitializeMembers( );

      pDisp->Release( );
   }

   pACL->Release( );

   return hResult;
}



//***********************************************************
//  Function:    CADsAccessControlList::~CADsAccessControlList
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlList::~CADsAccessControlList()
{
   for( int nIdx = 0 ; nIdx < m_arrACE.GetSize( ) ; nIdx++ )
   {
      delete m_arrACE.GetAt( nIdx );
   }

   m_arrACE.RemoveAll( );
}


//***********************************************************
//  Function:    CADsAccessControlList::GetACL
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch*  CADsAccessControlList::GetACL( )
{
   IDispatch*  pDispatch   = NULL;

   if( NULL != m_pIUnk )
   {
      m_pIUnk->QueryInterface( IID_IDispatch, (void**)&pDispatch );
   }

   return pDispatch;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch*  CADsAccessControlList::CreateACL( )
{
   IDispatch*              pDispatch   = NULL;
   IADsAccessControlList*  pNewACL     = NULL;
   HRESULT                 hResult     = NULL;
   DWORD dwAceType = 0;

   hResult = CoCreateInstance(
                               CLSID_AccessControlList,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IADsAccessControlList,
                               (void **)&pNewACL
                             );
   if( SUCCEEDED( hResult ) )
   {
      hResult  = pNewACL->QueryInterface( IID_IDispatch,
                                          (void**)&pDispatch );
      pNewACL->Release( );
   }

   return pDispatch;
}

//***********************************************************
//  Function:    CADsAccessControlList::PutProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlList::PutProperty ( int nACE,
                                              int nProp,
                                              CString& rVal,
                                              long lCode )
{
   HRESULT        hResult;
   COleDsObject*  pACE;

   ASSERT( nACE < m_arrACE.GetSize( ) );

   if( nACE < m_arrACE.GetSize( ) )
   {
      pACE  = (COleDsObject*) m_arrACE.GetAt( nACE );

      hResult  = pACE->PutProperty ( nProp, rVal, lCode );
   }

   return hResult;
}



//***********************************************************
//  Function:    CADsAccessControlList::GetProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlList::GetProperty ( int nACE,
                                              int nProp,
                                              CString& rVal )
{
   HRESULT        hResult;
   COleDsObject*  pACE;

   ASSERT( nACE < m_arrACE.GetSize( ) );

   if( nACE < m_arrACE.GetSize( ) )
   {
      pACE  = (COleDsObject*) m_arrACE.GetAt( nACE );

      hResult  = pACE->GetProperty ( nProp, rVal );
   }

   return hResult;
}


//***********************************************************
//  Function:    CADsAccessControlList::InitializeMembers
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsAccessControlList::InitializeMembers( )
{
   IADsAccessControlList*  pACList   = NULL;
   IUnknown*               pIUnk;
   HRESULT                 hResult;
   IEnumVARIANT*           pEnum = NULL;
   VARIANT                 aVariant;
   IUnknown*               pACE;
   ULONG                   ulGet;

   if( !m_pIUnk )
      return;

   for( int nIdx = 0 ; nIdx < m_arrACE.GetSize( ) ; nIdx++ )
   {
      delete m_arrACE.GetAt( nIdx );
   }

   m_arrACE.RemoveAll( );


   while( TRUE )
   {
      //hResult  = m_pIUnk->QueryInterface( IID_IEnumVARIANT,
      //                                    (void**)&pEnum );
      hResult  = m_pIUnk->QueryInterface( IID_IADsAccessControlList,
                                          (void**)&pACList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pACList->get__NewEnum( &pIUnk );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pIUnk->QueryInterface( IID_IEnumVARIANT,
                                        (void**)&pEnum );

      pIUnk->Release( );
      pACList->Release( );


      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      while( TRUE )
      {
         CADsAccessControlEntry* pNewACE;

         ulGet    = 0L;
         hResult  = pEnum->Next( 1, &aVariant, &ulGet );
         if( FAILED( hResult ) )
            break;

         if( 0 == ulGet )
            break;

         hResult  = V_DISPATCH( &aVariant )->QueryInterface( IID_IUnknown,
                                                             (void**)&pACE );
         VariantClear( &aVariant );
         pNewACE  = new CADsAccessControlEntry( pACE );

         if( NULL != m_pDoc )
         {
            pNewACE->SetDocument( m_pDoc );
         }

         m_arrACE.Add( pNewACE );

         pACE->Release( );
      }
      pEnum->Release( );
      break;
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsAccessControlList::SetDocument ( CMainDoc* pDoc )
{
   COleDsObject*  pObject;
   int            nSize, nIdx;

   COleDsObject::SetDocument ( pDoc );

   nSize = (int)m_arrACE.GetSize( );
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      pObject  = (COleDsObject*)m_arrACE.GetAt( nIdx );
      pObject->SetDocument( pDoc );
   }
}


//***********************************************************
//  Function:    CADsAccessControlList::GetACECount
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
int   CADsAccessControlList::GetACECount ( void )
{
   return (int)m_arrACE.GetSize( );
}


//***********************************************************
//  Function:    CADsAccessControlList::GetACEObject
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlEntry* CADsAccessControlList::GetACEObject ( int nACE )
{
   CADsAccessControlEntry* pACE;

   //ASSERT( nACE < GetACECount( ) );
   if( nACE >= GetACECount( ) )
      return NULL;

   pACE  = (CADsAccessControlEntry*) (m_arrACE.GetAt( nACE ) );

   return pACE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cfshare.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileShare::COleDsFileShare( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileShare::COleDsFileShare( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileShare::~COleDsFileShare( )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cgeneric.h ===
#ifndef  _CGENERIC_H_
#define  _CGENERIC_H_

class COleDsGeneric: public COleDsObject
{

public:   
   COleDsGeneric( IUnknown* );
   COleDsGeneric( );
   ~COleDsGeneric( );

//   void      SetClass   ( CClass*   );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cgroup.h ===
#ifndef  _CGROUP_H_
#define  _CGROUP_H_

class COleDsGroup: public COleDsObject
{

public:   
   COleDsGroup( IUnknown* );
   COleDsGroup( );
   ~COleDsGroup( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );


public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cfserv.h ===
#ifndef  _CFILESERVICE_H_
#define  _CFILESERVICE_H_

class COleDsFileService: public COleDsService
{

public:   
   COleDsFileService( IUnknown* );
   COleDsFileService( );
   ~COleDsFileService( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cfshare.h ===
#ifndef  _CFILESHARE_H_
#define  _CFILESHARE_H_

class COleDsFileShare: public COleDsObject
{

public:   
   COleDsFileShare( IUnknown* );
   COleDsFileShare( );
   ~COleDsFileShare( );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cgeneric.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "objects.h"
#include "maindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGeneric::COleDsGeneric( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGeneric::COleDsGeneric( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   BOOL              bContainer;
   IADsContainer*  pContainer;
   HRESULT           hResult;

   hResult  = pIUnk->QueryInterface( IID_IADsContainer, (void**)&pContainer );
   bContainer  = SUCCEEDED( hResult );

   if( SUCCEEDED( hResult ) )
      pContainer->Release( );

   m_bHasChildren       = bContainer;
   m_bSupportAdd        = bContainer;
   m_bSupportMove       = bContainer;
   m_bSupportCopy       = bContainer;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
/*void  COleDsGeneric::SetClass( CClass* pClass )
{
   
   /*CString  strContainer;

   strContainer   = pClass->GetAttribute( ca_Container );
   if( strContainer == _T("YES") || strContainer == _T("Yes") )
   {
      m_bHasChildren       = TRUE;
      m_bSupportAdd        = TRUE;
      m_bSupportMove       = TRUE;
      m_bSupportCopy       = TRUE;   
   } 

   COleDsObject::SetClass( pClass );
} */


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGeneric::~COleDsGeneric( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsGeneric::GetChildren( DWORD*     pTokens, 
                                     DWORD      dwMaxChildren,
                                     CDialog*   pQueryStatus,
                                     BOOL*      pFilters, 
                                     DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }

   if( !m_bHasChildren )
      return 0L;
   

   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}
  
   
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGeneric::DeleteItem( COleDsObject* pObject )
{
   if( !m_bHasChildren )
      return E_FAIL;

   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGeneric::AddItem( )
{
   if( !m_bHasChildren )
      return E_FAIL;
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGeneric::MoveItem( )
{
   if( !m_bHasChildren )
      return E_FAIL;
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGeneric::CopyItem( )
{
   if( !m_bHasChildren )
      return E_FAIL;
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cgroup.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "resource.h"
#include "grpcrtit.h"
#include "delgrpit.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGroup::COleDsGroup( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGroup::COleDsGroup( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   BOOL              bContainer;
   IADsContainer*    pContainer;
   HRESULT           hResult;

   hResult  = pIUnk->QueryInterface( IID_IADsContainer, (void**)&pContainer );
   bContainer  = SUCCEEDED( hResult );

   if( SUCCEEDED( hResult ) )
      pContainer->Release( );

   m_bHasChildren       = bContainer;
   m_bSupportAdd        = bContainer;
   m_bSupportMove       = bContainer;
   m_bSupportCopy       = bContainer;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGroup::~COleDsGroup( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsGroup::GetChildren( DWORD*     pTokens, 
                                   DWORD      dwMaxChildren,
                                   CDialog*   pQueryStatus,
                                   BOOL*      pFilters, 
                                   DWORD      dwFilters )
{
   HRESULT                    hResult;
   IADsGroup*               pIGroup;
   //IOleDsGroupOperations*     pIGroupOper;
   MEMBERS*        pIMembers;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsGroup, (void**) &pIGroup );
   if( FAILED( hResult ) )
   {
      TRACE( _T("ERROR!!! Group object does not return IID_IADsGroup interface\n") );
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   
   //hResult  = pIGroup->QueryInterface( IID_IADsGroupOperations, (void**)&pIGroupOper );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pIGroup->Members( &pIMembers );
      if( SUCCEEDED( hResult ) )
      {
         COleDsObject::GetChildren( pIMembers );
         pIMembers->Release( );
      }
      else
      {
         TRACE( _T("ERROR!!! Members fails for Group object\n") );
      }

      //pIGroupOper->Release( );
   }
   else
   {
      TRACE( _T("ERROR!!! GeneralInfo fails for Group object\n") );
   }
   
   pIGroup->Release( );

   return m_dwCount;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGroup::DeleteItem  ( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
   
   CDeleteGroupItem           aDeleteItem;
   BSTR                       bstrName;
   //IOleDsGroupOperations*     pIGroupOperations = NULL;
   IADsGroup*               pIGroup           = NULL;
   HRESULT                    hResult;
   CString                    strFullName;
   CString                    strQualifiedName;
   CString                    strItemType;

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   
   strFullName = pObject->GetOleDsPath( );
   strItemType = pObject->GetClass( );

   aDeleteItem.m_strItemName  = strFullName;
   aDeleteItem.m_strParent    = strQualifiedName;
   aDeleteItem.m_strItemType  = strItemType;

   if( aDeleteItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsGroup, 
                                          (void**)&pIGroup );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         break;
      }

      //hResult  = m_pIUnk->QueryInterface( IID_IADsGroupOperations, 
      //                                    (void**)&pIGroupOperations );
      //ASSERT( SUCCEEDED( hResult ) );
      //if( FAILED( hResult ) )
      //{
      //   break;
      //}

      bstrName = AllocBSTR( aDeleteItem.m_strItemName.GetBuffer( 128 ) );
      //hResult  = pIGroupOperations->Remove( bstrName );
      hResult  = pIGroup->Remove( bstrName );
      SysFreeString( bstrName );

      break;
   }

   //if( NULL != pIGroupOperations )
   //{
   //   pIGroupOperations->Release( );
   //}

   if( NULL != pIGroup )
   {
      pIGroup->Release( );
   }

   return hResult;   

}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGroup::AddItem( )
{

   return ContainerAddItem( );

   CGroupCreateItem           aCreateItem;
   BSTR                       bstrName;
   //IOleDsGroupOperations*     pIGroupOperations = NULL;
   IADsGroup*               pIGroup           = NULL;
   HRESULT                    hResult;
   CString                    strQualifiedName;

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aCreateItem.m_strParent    = strQualifiedName;
   aCreateItem.m_strItemType  = _T("NA");

   if( aCreateItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   bstrName  = AllocBSTR( aCreateItem.m_strNewItemName.GetBuffer(128) );

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsGroup, (void**)&pIGroup );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         break;
      }

      //hResult  = m_pIUnk->QueryInterface( IID_IADsGroupOperations, (void**)&pIGroupOperations );
      //ASSERT( SUCCEEDED( hResult ) );
      //if( FAILED( hResult ) )
      //{
      //   break;
      //}

      hResult  = pIGroup->Add( bstrName );
      break;
   }

   SysFreeString( bstrName );

   //if( NULL != pIGroupOperations )
   //{
   //   pIGroupOperations->Release( );
   //}

   if( NULL != pIGroup )
   {
      pIGroup->Release( );
   }

   return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cnmsp.h ===
#ifndef  _CNAMESPACE_H_
#define  _CNAMESPACE_H_

class COleDsNamespace: public COleDsObject
{

public:   
   COleDsNamespace( IUnknown* );
   COleDsNamespace( );
   ~COleDsNamespace( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cnmsps.h ===
#ifndef  _CNAMESPACES_H_
#define  _CNAMESPACES_H_

class COleDsNamespaces: public COleDsObject
{

public:   
   COleDsNamespaces( IUnknown* );
   COleDsNamespaces( );
   ~COleDsNamespaces( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );
public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cnmsp.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "objects.h"
#include "maindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespace::COleDsNamespace( )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespace::COleDsNamespace( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespace::~COleDsNamespace( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsNamespace::GetChildren( DWORD*     pTokens, 
                                       DWORD      dwMaxChildren,
                                       CDialog*   pQueryStatus,
                                       BOOL*      pFilters, 
                                       DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}

  
   
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespace::DeleteItem( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespace::AddItem( )
{
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespace::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespace::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\colldlg.h ===
// colldlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCollectionDialog dialog

class CCollectionDialog : public CDialog
{
// Construction
public:
	CCollectionDialog(CWnd* pParent = NULL);   // standard constructor
   ~CCollectionDialog( );   // standard destructor

// Dialog Data
	//{{AFX_DATA(CCollectionDialog)
	enum { IDD = IDD_COLLECTION };
	CStatic	m_strParent;
	CStatic	m_strItemType;
	CStatic	m_strItemOleDsPath;
	CListBox	m_ItemsList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCollectionDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCollectionDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeItemCollection();
	afx_msg void OnAdd();
	afx_msg void OnRefresh();
	afx_msg void OnRemove();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
   void  SetCollectionInterface  ( IADsCollection* );
   void  SetMembersInterface     ( IADsMembers* );
   void  SetGroup                ( IADsGroup* );
   void  DisplayActiveItemData   ( void );
   void  BuildStrings            ( void );

protected:
   IADsCollection*   m_pCollection;
   IADsMembers*      m_pMembers;
   IADsGroup*        m_pGroup;
   CStringArray      m_Paths;
   CStringArray      m_Types;
   CStringArray      m_Names;
   int               m_nSelectedItem;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cnmsps.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "objects.h"
#include "maindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespaces::COleDsNamespaces( )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespaces::COleDsNamespaces( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespaces::~COleDsNamespaces( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsNamespaces::GetChildren( DWORD*     pTokens, 
                                        DWORD      dwMaxChildren,
                                        CDialog*   pQueryStatus,
                                        BOOL*      pFilters, 
                                        DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}

  
   
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespaces::DeleteItem( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespaces::AddItem( )
{
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespaces::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespaces::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\colldlg.cpp ===
// colldlg.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "colldlg.h"
#include "delgrpit.h"
#include "grpcrtit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCollectionDialog dialog


CCollectionDialog::CCollectionDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CCollectionDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCollectionDialog)
	//}}AFX_DATA_INIT

   m_pCollection     = NULL;
   m_pMembers        = NULL;
   m_pGroup          = NULL;
   m_nSelectedItem   = -1;
}

CCollectionDialog::~CCollectionDialog( )
{
   m_Paths.RemoveAll( );
   m_Types.RemoveAll( );
   m_Names.RemoveAll( );
   if( NULL != m_pGroup && NULL != m_pMembers )
   {
      m_pMembers->Release( );
   }
}


void CCollectionDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCollectionDialog)
	DDX_Control(pDX, IDC_ITEMTYPE, m_strItemType);
	DDX_Control(pDX, IDC_ITEMOLEDSPATH, m_strItemOleDsPath);
	DDX_Control(pDX, IDC_COLLECTONITEMSLIST, m_ItemsList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCollectionDialog, CDialog)
	//{{AFX_MSG_MAP(CCollectionDialog)
	ON_LBN_SELCHANGE(IDC_COLLECTONITEMSLIST, OnSelchangeItemCollection)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCollectionDialog message handlers


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::SetCollectionInterface( IADsCollection* pICollection )
{
   m_pCollection   = pICollection;

   BuildStrings( );
}


/***********************************************************
  Function:    CCollectionDialog::SetGroup
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::SetGroup( IADsGroup* pGroup )
{
   HRESULT  hResult;

   ASSERT( NULL == m_pMembers );

   hResult  = pGroup->Members( &m_pMembers );
   BuildStrings( );

   m_pGroup = pGroup;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::SetMembersInterface( IADsMembers* pIMembers )
{
   m_pMembers   = pIMembers;

   BuildStrings( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::DisplayActiveItemData( )
{
   if( m_Types.GetSize( ) )
   {
      m_strItemType.SetWindowText( m_Types[ m_nSelectedItem ] );
      m_strItemOleDsPath.SetWindowText( m_Paths[ m_nSelectedItem ] );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::BuildStrings( )
{
   IUnknown*      pIEnum      = NULL;
   IEnumVARIANT*  pIEnumVar   = NULL;
   HRESULT        hResult;
   VARIANT        var;
   IADs*        pIOleDs     = NULL;
   BSTR           bstrPath;
   BSTR           bstrName;
   BSTR           bstrClass;
   ULONG          ulFetch;
   TCHAR          szTemp[ 1024 ];

   m_Paths.RemoveAll( );
   m_Names.RemoveAll( );
   m_Types.RemoveAll( );

   while( TRUE )
   {
      if( NULL != m_pCollection )
      {
         hResult  = m_pCollection->get__NewEnum( &pIEnum );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
            break;
      }
      else
      {
         hResult  = m_pMembers->get__NewEnum( &pIEnum );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
            break;
      }

      hResult  = pIEnum->QueryInterface( IID_IEnumVARIANT,
                                         (void**)&pIEnumVar );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      VariantInit( &var );

      hResult  = pIEnumVar->Next( 1, &var, &ulFetch );
      while( ulFetch )
      {
         hResult  = V_DISPATCH( &var )->QueryInterface( IID_IADs,
                                                        (void**)&pIOleDs );
         VariantClear( &var );

         ASSERT( SUCCEEDED( hResult ) );


         bstrPath    = NULL;
         bstrName    = NULL;
         bstrClass   = NULL;

         hResult     = pIOleDs->get_ADsPath( &bstrPath );
         ASSERT( SUCCEEDED( hResult ) );

         hResult     = pIOleDs->get_Name( &bstrName );
         ASSERT( SUCCEEDED( hResult ) );

         hResult     = pIOleDs->get_Class( &bstrClass );
         ASSERT( SUCCEEDED( hResult ) );

         _tcscpy( szTemp, _T("NA") );
         if( bstrName )
         {
            _tcscpy( szTemp, _T("") );
            StringCat( szTemp, bstrName );
         }
         m_Names.Add( szTemp );

         _tcscpy( szTemp, _T("NA") );
         if( bstrClass )
         {
            _tcscpy( szTemp, _T("") );
            StringCat( szTemp, bstrClass );
         }
         m_Types.Add( szTemp );

         _tcscpy( szTemp, _T("NA") );
         if( bstrPath )
         {
            _tcscpy( szTemp, _T("") );
            StringCat( szTemp, bstrPath );
         }
         m_Paths.Add( szTemp );

         pIOleDs->Release( );
         SysFreeString( bstrPath );
         bstrPath = NULL;

         SysFreeString( bstrName );
         bstrName = NULL;

         SysFreeString( bstrClass );
         bstrClass   = NULL;


         hResult  = pIEnumVar->Next( 1, &var, &ulFetch );
      }
      pIEnumVar->Release( );
      pIEnum->Release( );

      break;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CCollectionDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

   if( NULL == m_pGroup && NULL == m_pCollection  )
   {
      GetDlgItem( IDC_ADD )->EnableWindow( FALSE );
      GetDlgItem( IDC_REMOVE )->EnableWindow( FALSE );
   }

   if( m_pCollection != NULL || m_pMembers != NULL )
   {
      int   nItems, nIdx;

      nItems   = (int)m_Paths.GetSize( );
      for( nIdx = 0; nIdx < nItems ; nIdx++ )
      {
         m_ItemsList.AddString( m_Names[ nIdx ] );
      }
      m_nSelectedItem   = 0;
      m_ItemsList.SetCurSel( 0 );
      DisplayActiveItemData( );
   }


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CCollectionDialog::OnSelchangeItemCollection()
{
	// TODO: Add your control notification handler code here
	int   nSelected;

   nSelected   = m_ItemsList.GetCurSel( );
   if( nSelected != m_nSelectedItem )
   {
      m_nSelectedItem = nSelected;
      DisplayActiveItemData( );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CCollectionDialog::OnAdd()
{
	// TODO: Add your control notification handler code here
   CGroupCreateItem*    m_pAddItem;

   if( NULL == m_pGroup )
      return;


   m_pAddItem  = new CGroupCreateItem;

   if( IDOK == m_pAddItem->DoModal( ) )
   {
      BSTR     bstrName;
      HRESULT  hResult;

      bstrName = AllocBSTR( m_pAddItem->m_strNewItemName.GetBuffer( 512 ) );
      hResult  = m_pGroup->Add( bstrName );
      SysFreeString( bstrName );

      MessageBox( (LPCTSTR)OleDsGetErrorText( hResult ), _T("Add") );

      OnRefresh( );

      if( SUCCEEDED( hResult ) )
      {
         m_ItemsList.SelectString( 0, m_pAddItem->m_strNewItemName );
      }
   }

   delete m_pAddItem;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CCollectionDialog::OnRefresh()
{
	// TODO: Add your control notification handler code here
   int   nItems, nIdx;


   if( NULL == m_pGroup )
      return;

   if( NULL != m_pMembers )
   {
      m_pMembers->Release( );
      m_pMembers  = NULL;
   }

   m_pGroup->GetInfo( );

   SetGroup( m_pGroup );

   nItems   = (int)m_Paths.GetSize( );

   m_ItemsList.ResetContent( );

   for( nIdx = 0; nIdx < nItems ; nIdx++ )
   {
      m_ItemsList.AddString( m_Names[ nIdx ] );
   }

   m_nSelectedItem   = 0;
   m_ItemsList.SetCurSel( 0 );
   DisplayActiveItemData( );
}


/***********************************************************
  Function:    CCollectionDialog::OnRemove
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CCollectionDialog::OnRemove()
{
	// TODO: Add your control notification handler code here
	int               nSelect;
   CDeleteGroupItem* m_pDeleteItem;

   if( NULL == m_pGroup )
      return;

   nSelect  = m_ItemsList.GetCurSel( );

   if( LB_ERR == nSelect )
      return;

   m_pDeleteItem  = new CDeleteGroupItem;

   m_pDeleteItem->m_strItemName  = m_Paths[ nSelect ];
	//CString	m_strParent;
	m_pDeleteItem->m_strItemType  = m_Types[ nSelect ];

   if( IDOK == m_pDeleteItem->DoModal( ) )
   {
      BSTR     bstrName;
      HRESULT  hResult;

      bstrName = AllocBSTR( m_pDeleteItem->m_strItemName.GetBuffer( 512 ) );
      hResult  = m_pGroup->Remove( bstrName );
      SysFreeString( bstrName );

      MessageBox( (LPCTSTR)OleDsGetErrorText( hResult ), _T("Remove") );

      OnRefresh( );
   }

   delete m_pDeleteItem;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\copyitem.cpp ===
// CopyItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "CopyItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCopyItem dialog


CCopyItem::CCopyItem(CWnd* pParent /*=NULL*/)
	: CDialog(CCopyItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCopyItem)
	m_strDestination = _T("");
	m_strParent = _T("");
	m_strSource = _T("");
	//}}AFX_DATA_INIT
}


void  CCopyItem::SetContainerName( CString strParent )
{
   m_strParent = strParent;
}

void CCopyItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCopyItem)
	DDX_Text(pDX, IDC_DESTINATION, m_strDestination);
	DDX_Text(pDX, IDC_PARENT, m_strParent);
	DDX_Text(pDX, IDC_SOURCE, m_strSource);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCopyItem, CDialog)
	//{{AFX_MSG_MAP(CCopyItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopyItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\copyitem.h ===
// CopyItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCopyItem dialog

class CCopyItem : public CDialog
{
// Construction
public:
	CCopyItem(CWnd* pParent = NULL);   // standard constructor

public:
   void  SetContainerName( CString );

// Dialog Data
	//{{AFX_DATA(CCopyItem)
	enum { IDD = IDD_COPYITEM };
	CString	m_strDestination;
	CString	m_strParent;
	CString	m_strSource;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCopyItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCopyItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cpdevice.h ===
#ifndef  _PRINTDEVICE_H_
#define  _PRINTDEVICE_H_

class COleDsPrintDevice: public COleDsObject
{

public:   
   COleDsPrintDevice( IUnknown* );
   COleDsPrintDevice( );
   ~COleDsPrintDevice( );

public:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cpdevice.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintDevice::COleDsPrintDevice( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintDevice::COleDsPrintDevice( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintDevice::~COleDsPrintDevice( )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cpqueue.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "resource.h"
#include "grpcrtit.h"
#include "delgrpit.h"



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintQueue::COleDsPrintQueue( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintQueue::COleDsPrintQueue( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintQueue::~COleDsPrintQueue( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsPrintQueue::GetChildren( DWORD*     pTokens, 
                                        DWORD      dwMaxChildren,
                                        CDialog*   pQueryStatus,
                                        BOOL*      pFilters, 
                                        DWORD      dwFilters )
{
   HRESULT                       hResult;
   IADsPrintQueue*             pIOleDsPrintQueue = NULL;
   IADsCollection*             pIJobs            = NULL;
   IADsPrintQueueOperations*   pIPQueueOper      = NULL;

   
   if( m_strOleDsPath[ 4 ] == _T(':') )
   {
      // the wort way to find if this is "LDAP:"
      // SWilson (NT) needs this 
      return 0L;
   }

   
   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   hResult  = m_pIUnk->QueryInterface( IID_IADsPrintQueue, 
                                       (void**) &pIOleDsPrintQueue );
   if( FAILED( hResult ) )
   {
      TRACE( _T("ERROR: QueryInterface for IID_IADsPrintQueue failed\n") );
   }
   else
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsPrintQueueOperations, 
                                       (void**) &pIPQueueOper );
      
      if( FAILED( hResult ) )
      {
         TRACE( _T("ERROR: QueryInterface for IID_IADsPrintQueueOperations failed\n") );
      }
      else
      {
         hResult  = pIPQueueOper->PrintJobs( &pIJobs );

         if( NULL != pIJobs )
         {
            COleDsObject::GetChildren( pIJobs );
            pIJobs->Release( );
         }
         pIPQueueOper->Release( );
      }
      pIOleDsPrintQueue->Release( );
   }

   return m_dwCount;
}
  

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsPrintQueue::DeleteItem  ( COleDsObject* pObject )
{
   DWORD                         dwType;
   HRESULT                       hResult;
   CString                       strQualifiedName;
   CString                       strItemType;
   CString                       strDeleteName;
   CDeleteGroupItem              aDeleteItem;
   IADsCollection*             pIColl      = NULL;
   IADsPrintQueue*             pIPQueue    = NULL;
   BOOL                          bSuccess = FALSE;

   
   hResult  = m_pIUnk->QueryInterface( IID_IADsPrintQueue, (void**)&pIPQueue );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      return E_FAIL;
   }

   dwType   = pObject->GetType( );

   switch( dwType )
   {
      case  PRINTJOB:
      {
         IADsPrintQueueOperations*  pIOper   = NULL;

         hResult  = pIPQueue->QueryInterface( IID_IADsPrintQueueOperations, (void**)&pIOper );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
         {
            break;
         }
         hResult  = pIOper->PrintJobs( &pIColl );
         pIOper->Release( );
         bSuccess = TRUE;
         break;
      }


      default:
         ASSERT( FALSE );
         return E_FAIL;
   }
   
   if( bSuccess )
   {
      strDeleteName  = pObject->GetDeleteName( );   
      MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );

      strItemType = pObject->GetClass( ); 

      aDeleteItem.m_strItemName  = strDeleteName;
      aDeleteItem.m_strParent    = strQualifiedName;
      aDeleteItem.m_strItemType  = strItemType;
      if( aDeleteItem.DoModal( ) == IDOK )
      {
         VARIANT  var;

         VariantInit( &var );
         V_VT( &var )   = VT_BSTR;
         V_BSTR( &var ) = AllocBSTR( aDeleteItem.m_strItemName.GetBuffer( 128 ) );
         if( NULL != pIColl )
         {
            hResult  = pIColl->Remove( V_BSTR(&var) );
         }
         VariantClear( &var );
      }

      if( NULL != pIColl )
      {
         ULONG ulRef;

         ulRef = pIColl->Release( );
         if( ulRef )
         {
            TRACE( _T("ERROR: Release on PrintJob collection did not returned 0\n") );
         }
      }
   }

   pIPQueue->Release( );

   return hResult;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cpqueue.h ===
#ifndef  _PRINTQUEUE_H_
#define  _PRINTQUEUE_H_

class COleDsPrintQueue: public COleDsObject
{

public:   
   COleDsPrintQueue( IUnknown* );
   COleDsPrintQueue( );
   ~COleDsPrintQueue( );

   HRESULT  DeleteItem  ( COleDsObject* );

public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cpjob.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintJob::COleDsPrintJob( )
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintJob::COleDsPrintJob( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintJob::~COleDsPrintJob( )
{

}
  

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsPrintJob::ReleaseIfNotTransient( void )
{
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cpjob.h ===
#ifndef  _CPRINTJOB_H_
#define  _CPRINTJOB_H_

class COleDsPrintJob: public COleDsObject
{

public:   
   COleDsPrintJob( IUnknown* );
   COleDsPrintJob( );
   ~COleDsPrintJob( );

   virtual  HRESULT  ReleaseIfNotTransient( void               );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\createit.cpp ===
// CreateItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "createit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateItem dialog


CCreateItem::CCreateItem(CWnd* pParent /*=NULL*/)
	: CDialog(CCreateItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCreateItem)
	m_strClass = _T("");
	m_strRelativeName = _T("");
	m_strParent = _T("");
	//}}AFX_DATA_INIT
}


void CCreateItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreateItem)
	DDX_Control(pDX, IDC_RELATIVENAME, m_RelativeName);
	DDX_Control(pDX, IDC_CLASS, m_Class);
	DDX_Text(pDX, IDC_CLASS, m_strClass);
	DDX_Text(pDX, IDC_RELATIVENAME, m_strRelativeName);
	DDX_Text(pDX, IDC_PARENTNAME, m_strParent);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateItem, CDialog)
	//{{AFX_MSG_MAP(CCreateItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cresourc.h ===
#ifndef  _CRESOURCE_H_
#define  _CRESOURCE_H_

class COleDsResource: public COleDsObject
{

public:   
   COleDsResource( IUnknown* );
   COleDsResource( );
   ~COleDsResource( );

   virtual  HRESULT  ReleaseIfNotTransient( void               );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\createit.h ===
// CreateItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCreateItem dialog

class CCreateItem : public CDialog
{
// Construction
public:
	CCreateItem(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreateItem)
	enum { IDD = IDD_CREATEITEM };
	CEdit	m_RelativeName;
	CEdit	m_Class;
	CString	m_strClass;
	CString	m_strRelativeName;
	CString	m_strParent;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cresourc.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsResource::COleDsResource( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsResource::COleDsResource( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsResource::~COleDsResource( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsResource::ReleaseIfNotTransient( void )
{
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cservice.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsService::COleDsService( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsService::COleDsService( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsService::~COleDsService( )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cservice.h ===
#ifndef  _CSERVICE_H_
#define  _CSERVICE_H_

class COleDsService: public COleDsObject
{

public:   
   COleDsService( IUnknown* );
   COleDsService( );
   ~COleDsService( );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\csession.h ===
#ifndef  _CSESSION_H_
#define  _CSESSION_H_

class COleDsSession: public COleDsObject
{

public:   
   COleDsSession( IUnknown* );
   COleDsSession( );
   ~COleDsSession( );

   CString  GetDeleteName        ( );

public:
   HRESULT  ReleaseIfNotTransient( void  );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cuser.h ===
#ifndef  _CUSER_H_
#define  _CUSER_H_

class COleDsUser: public COleDsObject
{

   public:   
      COleDsUser( IUnknown* );
      COleDsUser( );
      ~COleDsUser( );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\cuser.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsUser::COleDsUser( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsUser::COleDsUser( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsUser::~COleDsUser( )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\csyntax.h ===
#ifndef  _CSYNTAX_H_
#define  _CSYNTAX_H_

class COleDsSyntax: public CObject
{
   public:   
      COleDsSyntax( );

   public:
      virtual  CString  VarToDisplayString( VARIANT&, BOOL bMultiValued, BOOL bUseGetEx );
      virtual  BOOL     DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL bMultiValued, BOOL bUseGetEx );
      virtual  CString  VarToDisplayStringEx( VARIANT&, BOOL bMultiValued );
      virtual  BOOL     DisplayStringToDispParamsEx( CString&, DISPPARAMS&, BOOL bMultiValued );

      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );
      virtual  void      FreeAttrValue ( ADSVALUE* );
      
      void     FreeAttrInfo            ( ADS_ATTR_INFO* );  
      HRESULT  Native2Value            ( ADS_ATTR_INFO*, CString& );
      HRESULT  Value2Native            ( ADS_ATTR_INFO*, CString& );

   public:
      DWORD    m_dwSyntaxID;
   protected:
      CString  GetValueByIndex         ( CString&, TCHAR, DWORD );
      DWORD    GetValuesCount          ( CString&, TCHAR );

   protected:
      VARTYPE  m_lType;
      

};

class COleDsBSTR: public COleDsSyntax
{
   public:   
      COleDsBSTR( );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );
      virtual  void      FreeAttrValue ( ADSVALUE* );

};


class COleDsBOOL: public COleDsSyntax
{
   public:   
      COleDsBOOL( );
   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );

};


class COleDsLONG: public COleDsSyntax
{
   public:   
      COleDsLONG( );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );

};

class COleDsLargeInteger: public COleDsSyntax
{
   public:   
      COleDsLargeInteger( );

   public:
      HRESULT  Native2Value  ( ADSVALUE*, CString& );
      HRESULT  Value2Native  ( ADSVALUE*, CString& );
      
      BOOL     DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL, BOOL );
      BOOL     DisplayStringToDispParamsEx( CString&, DISPPARAMS&, BOOL bMultiValued );

      CString  VarToDisplayStringEx( VARIANT&, BOOL bMultiValued );
      CString  VarToDisplayString( VARIANT&, BOOL, BOOL );
};


class COleDsDATE: public COleDsSyntax
{
   public:   
      COleDsDATE( );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );
};


class COleDsNDSComplexType: public COleDsSyntax
{
   public:
      COleDsNDSComplexType            ( );

      CString  VarToDisplayString         ( VARIANT&, BOOL, BOOL        );
      BOOL     DisplayStringToDispParams  ( CString&, DISPPARAMS&, BOOL, BOOL );
      CString  VarToDisplayStringEx       ( VARIANT&, BOOL bMultiValued );
      BOOL     DisplayStringToDispParamsEx( CString&, DISPPARAMS&, BOOL bMultiValued );

   private:
      virtual  HRESULT  String_2_VARIANT( TCHAR*, VARIANT& ) = 0;
      virtual  HRESULT  VARIANT_2_String( TCHAR*, VARIANT& ) = 0;
};


class COleDsNDSTimeStamp: public COleDsNDSComplexType
{
   public:
      COleDsNDSTimeStamp            ( );

      HRESULT  Native2Value               ( ADSVALUE*, CString&         );
      HRESULT  Value2Native               ( ADSVALUE*, CString&         );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

      HRESULT  GetComponents  ( TCHAR*, DWORD*, DWORD*   );
      HRESULT  GenerateString ( TCHAR*, DWORD, DWORD     );
};


class COleDsNDSCaseIgnoreList: public COleDsNDSComplexType
{
   public:
      COleDsNDSCaseIgnoreList      ( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSOctetList: public COleDsNDSComplexType
{
   public:
      COleDsNDSOctetList      ( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};


class COleDsNDSNetAddress: public COleDsNDSComplexType
{
   public:
      COleDsNDSNetAddress      ( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSPostalAddress: public COleDsNDSComplexType
{
   public:
      COleDsNDSPostalAddress  ( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSEMail: public COleDsNDSComplexType
{
   public:
      COleDsNDSEMail( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSFaxNumber: public COleDsNDSComplexType
{
   public:
      COleDsNDSFaxNumber( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};
class COleDsNDSBackLink: public COleDsNDSComplexType
{
   public:
      COleDsNDSBackLink( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSPath: public COleDsNDSComplexType
{
   public:
      COleDsNDSPath( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSHold: public COleDsNDSComplexType
{
   public:
      COleDsNDSHold( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};


class COleDsNDSTypedName: public COleDsNDSComplexType
{
   public:
      COleDsNDSTypedName( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};




class COleDsVARIANT: public COleDsSyntax
{
   public:   
      COleDsVARIANT( ){};

   public:
      CString   VarToDisplayString( VARIANT&, BOOL, BOOL );
      BOOL      DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL, BOOL );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );

};


class COleDsOctetString: public COleDsSyntax
{
   public:   
      COleDsOctetString( );

   public:
      CString  VarToDisplayString( VARIANT&, BOOL, BOOL );
      BOOL     DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL, BOOL );
      CString  VarToDisplayStringEx( VARIANT&, BOOL bMultiValued );
      BOOL     DisplayStringToDispParamsEx( CString&, DISPPARAMS&, BOOL bMultiValued );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );
      virtual  void      FreeAttrValue ( ADSVALUE* );

   private:
      BYTE      GetByteValue( TCHAR* szString );

};


class COleDsCounter: public COleDsLONG
{
   public:   
      COleDsCounter( ){};
};

class COleDsNetAddress: public COleDsBSTR
{
   public:   
      COleDsNetAddress( ){};
};

class COleDsOleDsPath: public COleDsBSTR
{
   public:
      COleDsOleDsPath( ){};
};


class COleDsEmailAddress: public COleDsBSTR
{
   public:
      COleDsEmailAddress( ){};
};

class COleDsInteger: public COleDsLONG
{
   public:
      COleDsInteger( ){};
};


class COleDsInterval: public COleDsLONG
{
   public:
      COleDsInterval( ){};
};

class COleDsList: public COleDsVARIANT
{
   public:
      COleDsList( ){};
};

class COleDsString: public COleDsBSTR
{
   public:
      COleDsString( ){ };
};


COleDsSyntax*  GetSyntaxHandler( ADSTYPE eType, CString& rText );
COleDsSyntax*  GetSyntaxHandler( WCHAR* pszSyntax );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\csession.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSession::COleDsSession( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSession::COleDsSession( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSession::~COleDsSession( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsSession::ReleaseIfNotTransient( void )
{
   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsSession::GetDeleteName( )
{
   HRESULT        hResult, hResultX;
   IADsSession* pISess   = NULL;
   CString        strDeleteName;
   BSTR           bstrName;

   hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pISess );
   ASSERT( SUCCEEDED( hResult ) );

   hResultX = pISess->get_Name( &bstrName );
   if( SUCCEEDED( hResultX ) )
   {
      strDeleteName  = bstrName;
      SysFreeString( bstrName );

      return strDeleteName;
   }

   if( SUCCEEDED( hResult ) )
   {
      VARIANT  var;

      hResult  = Get( pISess, _T("User"), &var );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         strDeleteName  = V_BSTR( &var );
         VariantClear( &var );
      }

      hResult  = Get( pISess, _T("Computer"), &var );
      ASSERT( SUCCEEDED( hResult ) );
      if( SUCCEEDED( hResult ) )
      {
         strDeleteName += _T('\\');
         strDeleteName += V_BSTR( &var );
         VariantClear( &var );
      }
      pISess->Release( );
   }
   
   return strDeleteName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\csyntax.cpp ===
#include "stdafx.h"
//#include "inds.h"
#include <limits.h>
#include "ole2.h"
#include "csyntax.h"

#define  NDS_SEPARATOR     _T('&')
#define  NDS_SEPARATOR_S     _T(" & ")
#define  NDS_SEPARATOR_W   L'&'
#define  NDS_SEPARATOR_A   '&'


/***********************************************************
  Function:    GetSyntaxHandler
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSyntax*  GetSyntaxHandler( WCHAR* pszSyntax )
{
   ADSTYPE        eType;
   CString        strText;

   eType = ADsTypeFromSyntaxString( pszSyntax );

   return GetSyntaxHandler( eType, strText );
}
   

/***********************************************************
  Function:    GetSyntaxHandler
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSyntax*  GetSyntaxHandler( ADSTYPE eType, CString& rText )
{
   COleDsSyntax*  pSyntax  = NULL;

   switch( eType )
   {
      case  ADSTYPE_INVALID:
         ASSERT( FALSE );
         rText = _T("ERROR: ADSTYPE_INVALID");
         break;

      case  ADSTYPE_DN_STRING:
      case  ADSTYPE_CASE_EXACT_STRING:
      case  ADSTYPE_CASE_IGNORE_STRING:
      case  ADSTYPE_PRINTABLE_STRING:
      case  ADSTYPE_NUMERIC_STRING:
      case  ADSTYPE_OBJECT_CLASS:
         pSyntax  = new COleDsBSTR( );
         break;

      case  ADSTYPE_BOOLEAN:
         pSyntax  = new COleDsBOOL( );
         break;

      case  ADSTYPE_CASEIGNORE_LIST:
         pSyntax  = new COleDsNDSCaseIgnoreList( );
         break;

      case  ADSTYPE_OCTET_LIST:
         pSyntax  = new COleDsNDSOctetList( );
         break;

      case  ADSTYPE_PATH:
         pSyntax  = new COleDsNDSPath( );
         break;

      case  ADSTYPE_NETADDRESS:
         pSyntax  = new COleDsNDSNetAddress( );
         break;

      case  ADSTYPE_BACKLINK:
         pSyntax  = new COleDsNDSBackLink( );
         break;

      case  ADSTYPE_HOLD:
         pSyntax  = new COleDsNDSHold( );
         break;

      case  ADSTYPE_TYPEDNAME:
         pSyntax  = new COleDsNDSTypedName( );
         break;

      case  ADSTYPE_INTEGER:
         pSyntax  = new COleDsLONG( );
         break;

      case  ADSTYPE_LARGE_INTEGER:
         pSyntax  = new COleDsLargeInteger( );
         break;

      case  ADSTYPE_POSTALADDRESS:
         pSyntax  = new COleDsNDSPostalAddress( );
         break;
 
      case  ADSTYPE_OCTET_STRING:
         pSyntax  = new COleDsOctetString( );
         break;

      case  ADSTYPE_UTC_TIME:
         pSyntax  = new COleDsDATE( );
         break;

      case  ADSTYPE_TIMESTAMP:
         pSyntax  = new COleDsNDSTimeStamp;
         break;

      case  ADSTYPE_EMAIL:
         pSyntax  = new COleDsNDSEMail;
         break;

      case  ADSTYPE_FAXNUMBER:
         pSyntax  = new COleDsNDSFaxNumber;
         break;

      case  ADSTYPE_PROV_SPECIFIC:
         ASSERT( FALSE );
         rText = _T("ADSTYPE_PROV_SPECIFIC");
         break;

      default:
         ASSERT( FALSE );
         rText = _T("ERROR Unknown ADSTYPE");
         break;
   }

   return pSyntax;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSyntax::COleDsSyntax( )
{
   m_lType        = VT_BSTR;
   m_dwSyntaxID   = ADSTYPE_DN_STRING;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsSyntax::VarToDisplayStringEx( VARIANT& var, BOOL bMultiValued )
{
   VARIANT  aVar;
   HRESULT  hResult;
   CString  strText  = _T("ERROR");

   VariantInit( &aVar );
   
   if( !bMultiValued )
   {
      SAFEARRAY*  pSafeArray; 
      TCHAR       szText[ 8096 ];
      VARIANT     varString;
      long        lBound, uBound, lItem;
      CString     strResult;

      ASSERT( VT_ARRAY & V_VT(&var ) );
      
      if( !(VT_ARRAY & V_VT(&var) ) )
      {
         ERROR_HERE( szText );
      }

      else
      {
         VariantInit( &varString );

         pSafeArray  = V_ARRAY( &var );

         hResult     = SafeArrayGetLBound(pSafeArray, 1, &lBound); 
         hResult     = SafeArrayGetUBound(pSafeArray, 1, &uBound); 

         ASSERT( lBound == uBound );

         szText[ 0 ]    = _T('\0');

         lItem = lBound;
         hResult  = SafeArrayGetElement( pSafeArray, &lItem, &aVar );
         if( FAILED( hResult ) )
         {
            ASSERT(FALSE);
         }

         if( !ConvertFromPropertyValue( aVar, szText ) )
         {
            hResult  = VariantChangeType( &varString, &aVar, VARIANT_NOVALUEPROP, VT_BSTR );

            ASSERT( SUCCEEDED( hResult ) );
            if( FAILED( hResult ) )
            {
               ERROR_HERE( szText );
            }
            else
            {
               Convert( szText, V_BSTR( &varString ) );
               VariantClear( &varString );
            }
            VariantClear( &aVar );
         }
      }

      return CString( szText );
   }
   else
   {
      strText  = FromVariantArrayToString( var );
   }


   return strText;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsSyntax::VarToDisplayString( VARIANT& var, BOOL bMultiValued, BOOL bUseGetEx )
{
   VARIANT  aVar;
   HRESULT  hResult;
   CString  strText;

   // we have to use GetEx style
   if( bUseGetEx )
      return VarToDisplayStringEx( var, bMultiValued );
   
   // we're using Get
   VariantInit( &aVar );
   if( !bMultiValued )
   {
      hResult  = VariantChangeType( &aVar, &var, VARIANT_NOVALUEPROP, VT_BSTR );
      if( SUCCEEDED( hResult ) )
      {
         strText  = V_BSTR( &aVar );
      }
      else
      {
         strText  = _T("ERROR on conversion");
      }

      hResult  = VariantClear( &aVar  );
   }
   else
   {
      strText  = FromVariantArrayToString( var );
   }

   return strText;
}


/***********************************************************
  Function:    COleDsSyntax::DisplayStringToDispParamsEx
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsSyntax::DisplayStringToDispParamsEx( CString& rText, 
                                                    DISPPARAMS& dispParams, 
                                                    BOOL bMultiValued )
{
   HRESULT  hResult;

   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   hResult  = BuildVariantArray( m_lType, rText, dispParams.rgvarg[0] );

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsSyntax::DisplayStringToDispParams( CString& rText, DISPPARAMS& dispParams, 
                                                  BOOL bMultiValued, BOOL bUseGetEx )
{
   HRESULT  hResult;

   if( bUseGetEx )
   {
      return DisplayStringToDispParamsEx( rText, dispParams, bMultiValued );
   }
   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   if( bMultiValued )
   {
      hResult  = BuildVariantArray( m_lType, rText, dispParams.rgvarg[0] );
   }
   else
   {
      VARIANT  vStr;

      VariantInit( &vStr );
      VariantInit( &dispParams.rgvarg[0] );

      V_VT( &vStr )     = VT_BSTR;
      V_BSTR( &vStr )   = AllocBSTR( rText.GetBuffer( 1024 ) );

      hResult           = VariantChangeType( &dispParams.rgvarg[0], &vStr, VARIANT_NOVALUEPROP, m_lType );

      VariantClear( &vStr );

   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsSyntax::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   ASSERT( FALSE );

   return E_FAIL;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsSyntax::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   ASSERT( FALSE );

   return E_FAIL;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  COleDsSyntax::FreeAttrValue ( ADSVALUE* pADsValue )
{
   return;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsSyntax::FreeAttrInfo( ADS_ATTR_INFO* pAttrInfo )
{
   DWORD dwIter;

   ASSERT( NULL != pAttrInfo->pszAttrName );
   
   FREE_MEMORY( pAttrInfo->pszAttrName );

   if( ADS_ATTR_CLEAR == pAttrInfo->dwControlCode )
      return;

   for( dwIter = 0; 
        NULL != pAttrInfo->pADsValues &&  dwIter < pAttrInfo->dwNumValues ; 
        dwIter++ )
   {
      FreeAttrValue( pAttrInfo->pADsValues + dwIter );
   }

   FREE_MEMORY( pAttrInfo->pADsValues );

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsSyntax::Native2Value( ADS_ATTR_INFO* pAttr, CString& rVal )
{
   HRESULT     hResult  = E_FAIL;
   CString     strItem;
   ADSVALUE*   pAdsValue;

   rVal.Empty( );

   while( TRUE )
   {
      ASSERT( pAttr );
      if( !pAttr )
         break;
      
      ASSERT( pAttr->pADsValues );
      if( !pAttr->pADsValues )
         break;

      for( DWORD dwIdx = 0L; dwIdx < pAttr->dwNumValues ; dwIdx++ )
      {
         if( dwIdx )
            rVal  = rVal + SEPARATOR_S;

         pAdsValue  = pAttr->pADsValues + dwIdx;
         if( ADSTYPE_INVALID != pAdsValue->dwType )
         {
            hResult  = Native2Value( pAdsValue, strItem );
         }
         else
         {
            strItem  = _T("ERROR: ADSTYPE_INVALID");
            TRACE( _T("ERROR: Got ADSTYPE_INVALID!!!\n") );
         }
         rVal        = rVal + strItem;
      }

      break;
   }

   return hResult;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsSyntax::Value2Native( ADS_ATTR_INFO* pAttr, CString& rVal )
{
   HRESULT     hResult  = E_FAIL;
   CString     strItem;
   ADSVALUE*   pCurrentADsObject;
   DWORD       dwValues;
   DWORD       dwIdx;

   pAttr->dwADsType  = (ADSTYPE)m_dwSyntaxID;
   
   while( TRUE )
   {
      ASSERT( pAttr );
      if( !pAttr )
         break;
      
      dwValues             = GetValuesCount( rVal, SEPARATOR_C );

      pAttr->dwNumValues   = dwValues;
      pAttr->pADsValues    = (ADSVALUE*)AllocADsMem( sizeof( ADSVALUE ) * dwValues );
      pCurrentADsObject    = pAttr->pADsValues;

      for( dwIdx = 0L; dwIdx < dwValues ; dwIdx++ )
      {
         strItem  = GetValueByIndex( rVal, SEPARATOR_C, dwIdx );
         pCurrentADsObject->dwType = (ADSTYPE)m_dwSyntaxID;
         hResult  = Value2Native( pCurrentADsObject, strItem );
         pCurrentADsObject++;
      }

      break;
   }

   return hResult;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsSyntax::GetValuesCount( CString& rString, TCHAR cSeparator )
{
   DWORD dwValues;
   DWORD dwIdx;

   dwValues = 1L;
   
   for( dwIdx = 0L; dwIdx < (DWORD)rString.GetLength( ) ; dwIdx++ )
   {
      TCHAR cCurrent;

      cCurrent = rString.GetAt( dwIdx );
      if(  cCurrent == cSeparator )
      {
         dwValues++;
      }
   }

   return dwValues;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsSyntax::GetValueByIndex( CString& rVal, TCHAR cSeparator, DWORD dwIndex )
{
   DWORD    dwParsed = 0L;
   DWORD    dwIter   = 0L;
   DWORD    dwSize;
   CString  strItem;

   dwSize   = rVal.GetLength( );
   
   while( dwIter < dwSize && dwParsed < dwIndex && rVal.GetAt(dwIter) )
   {
      if( cSeparator == rVal.GetAt(dwIter++) )
         dwParsed++;
   }

   
   while( dwIter < dwSize && cSeparator != rVal.GetAt(dwIter) )
   {
      strItem += rVal.GetAt(dwIter++);
   }

   strItem.TrimLeft( );

   return strItem;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsBSTR::COleDsBSTR( )
{
   m_lType        = VT_BSTR;
   m_dwSyntaxID   = ADSTYPE_DN_STRING;
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsBSTR::Native2Value( ADSVALUE* pAdsValue, CString& rVal )
{
   TCHAR    szBuffer[ 1024 ];
   
   if( pAdsValue->DNString )
   {
      Convert( szBuffer, pAdsValue->DNString );
   }
   else
   {
      _tcscpy( szBuffer, _T("NULL value") );
   }
   rVal  = szBuffer;

   return S_OK;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsBSTR::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   LPWSTR   lpwszValue;

   lpwszValue  = (LPWSTR) AllocADsMem( sizeof(WCHAR) * ( rVal.GetLength( ) + 1 ) );
   Convert( lpwszValue, rVal.GetBuffer( 1024 ) );
   pADsObject->DNString  = lpwszValue;

   return S_OK;
}


/***********************************************************
  Function:    COleDsBSTR::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  COleDsBSTR::FreeAttrValue ( ADSVALUE* pADsValue )
{
   ASSERT( NULL != pADsValue->DNString );

   FREE_MEMORY( pADsValue->DNString );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsBOOL::COleDsBOOL( )
{
   m_lType        = VT_BOOL;
   m_dwSyntaxID   = ADSTYPE_BOOLEAN;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsBOOL::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   BOOL     bVal;

   bVal  = pADsObject->Boolean;
   rVal  = ( bVal ? _T("1") : _T("0") );

   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsBOOL::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   pADsObject->Boolean = 
      rVal.Compare( _T("0") ) ? TRUE : FALSE;

   return S_OK;
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsLONG::COleDsLONG( )
{
   m_lType        = VT_I4;
   m_dwSyntaxID   = ADSTYPE_INTEGER;
}  


/***********************************************************
  Function:    COleDsLONG::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsLONG::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   DWORD    dwVal;
   TCHAR    szText[ 16 ];

   dwVal = pADsObject->Integer;
   _ultot( dwVal, szText, 10 );
   rVal  = szText;

   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsLONG::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   DWORD    dwVal;

   dwVal = (DWORD)_ttol( rVal.GetBuffer( 128 ) );

   pADsObject->Integer   = dwVal ;

   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsLargeInteger::COleDsLargeInteger( )
{
   m_lType        = VT_I8;
   m_dwSyntaxID   = ADSTYPE_LARGE_INTEGER;
}


/******************************************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
******************************************************************************/
HRESULT   COleDsLargeInteger::Native2Value( ADSVALUE* pValue, CString& rValue)
{
   HRESULT  hResult;
   TCHAR    szValue[ 32 ];

   hResult  = LARGE_INTEGERToString( szValue, &pValue->LargeInteger );
   ASSERT( SUCCEEDED( hResult ) );

   if( SUCCEEDED( hResult ) ) 
   {
      rValue   = szValue;
   }

   return hResult;
}


/******************************************************************************
  Function:    COleDsLargeInteger::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
******************************************************************************/
HRESULT   COleDsLargeInteger::Value2Native( ADSVALUE* pValue, CString& rValue )
{
   HRESULT  hResult;

   hResult  = LARGE_INTEGERToString( rValue.GetBuffer( 128 ), &pValue->LargeInteger );

   return hResult;
}


/***********************************************************
  Function:    COleDsLargeInteger::DisplayStringToDispParamsEx
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  COleDsLargeInteger::DisplayStringToDispParamsEx( CString& rText, 
                                                       DISPPARAMS& dispParams, 
                                                       BOOL bMultiValued )
{
   SAFEARRAY*        pSArray;
   SAFEARRAYBOUND    saBound;
   HRESULT           hResult;
   LONG              lIdx = LBOUND;

   DisplayStringToDispParams( rText, dispParams, bMultiValued, FALSE );
   
   if( !bMultiValued )
   {
      saBound.lLbound   = LBOUND;
      saBound.cElements = 1;
      pSArray           = SafeArrayCreate( VT_VARIANT, 1, &saBound );
      hResult           = SafeArrayPutElement( pSArray, &lIdx, &dispParams.rgvarg[0] );
      
      VariantClear( &dispParams.rgvarg[0] );

      V_VT( &dispParams.rgvarg[0] )    = VT_ARRAY | VT_VARIANT;
      V_ARRAY( &dispParams.rgvarg[0] ) = pSArray;
   }

   return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsLargeInteger::DisplayStringToDispParams( CString& rText, 
                                                        DISPPARAMS& dispParams, 
                                                        BOOL bMultiValued, 
                                                        BOOL bUseEx )
{
   HRESULT  hResult  = E_FAIL;
   int      x= 0;

  
   if( bUseEx )
   {
      return DisplayStringToDispParamsEx( rText, dispParams, bMultiValued );
   }

   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   if( bMultiValued )
   {
      SAFEARRAY*     psa;
      SAFEARRAYBOUND sab;
      long           lItems   = 0;
      int            lIdx;
      HRESULT        hResult;

      rText.MakeUpper( );

      lItems   = GetValuesCount( rText, SEPARATOR_C );

      sab.cElements   = lItems;
      sab.lLbound     = LBOUND;
      psa             = SafeArrayCreate( VT_VARIANT, 1, &sab );
      ASSERT( NULL != psa );
      if ( psa )
      {
         for( lIdx = LBOUND; lIdx < ( LBOUND + lItems ) ; lIdx++ )
         {
            VARIANT  var;
            CString  strTemp;

            strTemp  = GetValueAt( rText, SEPARATOR_C, lIdx - LBOUND );
            V_VT( &var )         = VT_DISPATCH;
            V_DISPATCH( &var )   = CreateLargeInteger( strTemp );

            hResult  = SafeArrayPutElement( psa, (long FAR *)&lIdx, &var );
            VariantClear( &var );
         }
         V_VT( &dispParams.rgvarg[0] )     = VT_VARIANT | VT_ARRAY;
         V_ARRAY( &dispParams.rgvarg[0] )  = psa;
      }
   }
   else
   {
      IDispatch*        pDisp = NULL;
      hResult  = S_OK;

      pDisp    = CreateLargeInteger( rText );

      V_VT( &dispParams.rgvarg[0] )       = VT_DISPATCH;
      V_DISPATCH( &dispParams.rgvarg[0] ) = pDisp;
   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsLargeInteger::VarToDisplayStringEx( VARIANT& var, 
                                                   BOOL bMultiValued )
{
   SAFEARRAY*  pSArray;
   HRESULT     hResult;
   LONG        uLow, uHigh, uIndex;
   VARIANT     vItem;
   CString     strVal;
   CString     strTemp;

   pSArray  = V_ARRAY( &var );

   hResult  = SafeArrayGetLBound( pSArray, 1, &uLow );
   hResult  = SafeArrayGetUBound( pSArray, 1, &uHigh );

   if( !bMultiValued )
   {
      ASSERT( uLow == uHigh );
   }

   for( uIndex = uLow; uIndex <= uHigh; uIndex++ )
   {
      if( uIndex != uLow )
      {
         strVal  += SEPARATOR_S;
      }

      VariantInit( &vItem );
      hResult  = SafeArrayGetElement( pSArray, &uIndex, &vItem );
      ASSERT( SUCCEEDED( hResult ) );

      strTemp   = FromLargeInteger( V_DISPATCH( &vItem ) );
      VariantClear( &vItem );
      strVal   += strTemp;

      if( strVal.GetLength( ) > 8096 )
         break;
   }

   return strVal;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsLargeInteger::VarToDisplayString( VARIANT& var, 
                                                 BOOL bMultiValued, 
                                                 BOOL bUseEx )
{
   if( bUseEx )
   {
      return VarToDisplayStringEx( var, bMultiValued );
   }
   
   if( bMultiValued )   
   {
      return VarToDisplayStringEx( var, TRUE );
   }
   else
   {
      return FromLargeInteger( V_DISPATCH( &var ) );
   }
}



/******************************************************************************
  Function:    COleDsDATE::COleDsDATE
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
******************************************************************************/
COleDsDATE::COleDsDATE( )
{
   m_lType        = VT_DATE;
   m_dwSyntaxID   = ADSTYPE_UTC_TIME;
}

/******************************************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
******************************************************************************/
HRESULT   COleDsDATE::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   DATE           aDate;
   ADS_UTC_TIME   aUTCTime;
   HRESULT        hResult;

   aUTCTime = pADsObject->UTCTime;
   
   hResult  = SystemTimeToVariantTime( (SYSTEMTIME*) &aUTCTime, &aDate );

   if( SUCCEEDED( hResult ) )
   {
      VARIANT  aVar;
      VARIANT  vText;

      VariantInit( &aVar );
      VariantInit( &vText );
      V_VT( &aVar )     = VT_DATE;
      V_DATE( &aVar )   = aDate;

      hResult  = VariantChangeType( &vText, &aVar, VARIANT_NOVALUEPROP, VT_BSTR );
      if( SUCCEEDED( hResult ) )
      {
         TCHAR szText[ 128 ];

         Convert( szText, V_BSTR( &vText ) );
         rVal  = szText;
         VariantClear( &vText );
      }
   }

   return hResult;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsDATE::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   DATE           aDate;
   ADS_UTC_TIME   aUTCTime;
   HRESULT        hResult;
   VARIANT        vDate;
   VARIANT        vText;

   VariantInit( &vText );
   VariantInit( &vDate );

   V_VT( &vText )    = VT_BSTR;
   V_BSTR( &vText )  = AllocBSTR( rVal.GetBuffer( 128 ) );

   hResult  = VariantChangeType( &vDate, &vText, VARIANT_NOVALUEPROP, VT_DATE );
   VariantClear( &vText );

   if( SUCCEEDED( hResult ) )
   {
      aDate    = V_DATE( &vDate );
      hResult  = VariantTimeToSystemTime( aDate, (SYSTEMTIME*) &aUTCTime );
      pADsObject->UTCTime  = aUTCTime;
   }

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSOctetList::COleDsNDSOctetList
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSCaseIgnoreList::COleDsNDSCaseIgnoreList( )
{
   m_dwSyntaxID   = ADSTYPE_CASEIGNORE_LIST;
}

      
/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSCaseIgnoreList::Native2Value( ADSVALUE* pValue, 
                                                CString& rText )
{
   ADS_CASEIGNORE_LIST* pStringList;
   int                  nIdx;

   ASSERT( ADSTYPE_CASEIGNORE_LIST == pValue->dwType );
   
   if( ADSTYPE_CASEIGNORE_LIST != pValue->dwType )
   {
      rText  = _T("ERROR: ADSTYPE_CASEIGNORE_LIST != pValue->dwType");
      return E_FAIL;
   }   
   nIdx  = 0;

   pStringList   = pValue->pCaseIgnoreList;
   while( NULL != pStringList && NULL != pStringList->String ) 
   {
      TCHAR*   pszText;

      if( 0 != nIdx )
         rText = rText + NDS_SEPARATOR;
      nIdx  = 1;

      pszText  = AllocTCHAR( pStringList->String );
      if( NULL != pszText )
      {
         rText = rText + pszText;
         FreeADsMem( pszText );
      }

      pStringList   = pStringList->Next;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSCaseIgnoreList::Value2Native( ADSVALUE* pValue, 
                                                CString& rText )
{
   HRESULT               hResult  = E_FAIL;
   DWORD                 dwValues, dwItem;
   CString               strItem;
   ADS_CASEIGNORE_LIST** ppItem;

   pValue->dwType = ADSTYPE_CASEIGNORE_LIST;
   pValue->pCaseIgnoreList = NULL;

   dwValues = GetValuesCount( rText, NDS_SEPARATOR );
   
   ppItem   = &(pValue->pCaseIgnoreList);

   for( dwItem = 0; dwItem < dwValues ; dwItem++ )
   {
      strItem  = GetValueByIndex( rText, NDS_SEPARATOR, dwItem );
      *ppItem  = (ADS_CASEIGNORE_LIST*) AllocADsMem( sizeof( ADS_CASEIGNORE_LIST ) );

      (*ppItem)->String  = AllocWCHAR( strItem.GetBuffer( strItem.GetLength( ) ) );
      (*ppItem)->Next    = NULL;
      ppItem   = &((*ppItem)->Next );
   }
   if( dwValues   == 0 )
   {
      pValue->pCaseIgnoreList = (ADS_CASEIGNORE_LIST*) AllocADsMem( sizeof( ADS_CASEIGNORE_LIST ) );
      pValue->pCaseIgnoreList->String  = NULL;
      pValue->pCaseIgnoreList->Next  = NULL;

   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSCaseIgnoreList::FreeAttrValue( ADSVALUE* pValue )
{
   ADS_CASEIGNORE_LIST* pStringList;
   ADS_CASEIGNORE_LIST* pSaveStringList;

   pStringList = pValue->pCaseIgnoreList;

   while( NULL != pStringList )
   {
      FREE_MEMORY( pStringList->String );
      
      pSaveStringList = pStringList;
      pStringList     = pStringList->Next;

      FREE_MEMORY( pSaveStringList );
   }
}


/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSCaseIgnoreList::String_2_VARIANT( TCHAR* pszText, 
                                                    VARIANT& rValue )
{
   HRESULT              hResult  = E_FAIL;
   CString              strItem;
   VARIANT              vVal;
   IADsCaseIgnoreList*  pCaseIgnoreList  = NULL;
   IDispatch*           pDisp = NULL;

   VariantInit( &vVal );
   VariantInit( &rValue );

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_CaseIgnoreList,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsCaseIgnoreList,
                                  (void **)&pCaseIgnoreList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      strItem  = pszText;
      hResult  = BuildVariantArray( VT_BSTR, 
                                    strItem, 
                                    vVal, 
                                    NDS_SEPARATOR );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pCaseIgnoreList->put_CaseIgnoreList( vVal );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pCaseIgnoreList->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      V_VT( &rValue )         = VT_DISPATCH;
      V_DISPATCH( &rValue )   = pDisp;
      break;

   }
   VariantClear( &vVal );
   RELEASE( pCaseIgnoreList );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSCaseIgnoreList::VARIANT_2_String( TCHAR* pszText, 
                                                    VARIANT& rValue )
{
   IADsCaseIgnoreList*  pCaseIgnoreList  = NULL;
   HRESULT  hResult;
   VARIANT  vValue;
   CString  strText;

   VariantInit( &vValue );
   while( TRUE )
   {
      hResult  = V_DISPATCH( &rValue )->QueryInterface( IID_IADsCaseIgnoreList, 
                                                        (void**)&pCaseIgnoreList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pCaseIgnoreList->get_CaseIgnoreList( &vValue );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      strText  = FromVariantArrayToString( vValue, NDS_SEPARATOR_S );
      _tcscpy( pszText, (LPCTSTR)strText );
      break;
   }

   RELEASE( pCaseIgnoreList );
   VariantClear( &vValue );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSNetAddress::COleDsNDSNetAddress
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSNetAddress::COleDsNDSNetAddress( )
{
   m_dwSyntaxID   = ADSTYPE_NETADDRESS;
}

      
/***********************************************************
  Function:    COleDsNDSNetAddress::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSNetAddress::Native2Value( ADSVALUE* pValue, CString& rText )
{
   ADS_NETADDRESS*  pNetAddress;
   TCHAR szText[ 16 ];

   ASSERT( ADSTYPE_NETADDRESS == pValue->dwType );
   
   if( ADSTYPE_NETADDRESS != pValue->dwType )
   {
      rText  = _T("ERROR: ADSTYPE_NETADDRESS != pValue->dwType");
      return E_FAIL;
   }   
   if( NULL == pValue->pNetAddress )
   {
      rText  = _T("ERROR: pValue->pNetAddress is NULL");
      return E_FAIL;
   }   
   
   pNetAddress = pValue->pNetAddress;
   _ultot( pNetAddress->AddressType, szText, 10 );
   rText = rText + SEPARATOR_S;

   if( NULL != pNetAddress->Address ) 
   {
      rText = rText + Blob2String( pNetAddress->Address, pNetAddress->AddressLength );
   }
   else
   {
      rText = rText + _T("NULL");
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSNetAddress::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSNetAddress::Value2Native( ADSVALUE* pValue, 
                                            CString& rText )
{
   HRESULT           hResult  = E_FAIL;
   DWORD             dwValues;
   CString           strAddressType;
   CString           strAddress;

   pValue->dwType       = ADSTYPE_NETADDRESS;
   pValue->pNetAddress  = NULL;

   while( TRUE )
   {
      dwValues = GetValuesCount( rText, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         ASSERT( FALSE );
         break;
      }
      
      pValue->pNetAddress  = (ADS_NETADDRESS*) AllocADsMem( sizeof(ADS_NETADDRESS) );
      if( NULL == pValue->pNetAddress )
         break;
   
      strAddressType = GetValueByIndex( rText, NDS_SEPARATOR, 0L );
      strAddress     = GetValueByIndex( rText, NDS_SEPARATOR, 1L );

      hResult  = String2Blob( strAddress.GetBuffer( strAddress.GetLength( ) ),
                             (void**) &(pValue->pNetAddress->Address), 
                             &(pValue->pNetAddress->AddressLength) );

      pValue->pNetAddress->AddressType  = (DWORD)_ttol( (LPCTSTR)strAddressType );
      break;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSNetAddress::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSNetAddress::FreeAttrValue( ADSVALUE* pValue )
{
   if( NULL != pValue->pNetAddress )
   {
      FREE_MEMORY( pValue->pNetAddress->Address );
   }
   FREE_MEMORY( pValue->pNetAddress );
}


/***********************************************************
  Function:    COleDsNDSNetAddress::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSNetAddress::String_2_VARIANT( TCHAR* pszText, 
                                                VARIANT& rValue )
{
   HRESULT              hResult     = E_FAIL;
   CString              strItem;
   CString              strAddressType;
   CString              strAddress;
   DWORD                dwValues;
   VARIANT              vVal, vBlob;
   IADsNetAddress*      pNetAddress  = NULL;
   IDispatch*           pDisp       = NULL;

   VariantInit( &vVal );
   VariantInit( &vBlob );
   VariantInit( &rValue );

   strItem  = pszText;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_NetAddress,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsNetAddress,
                                  (void **)&pNetAddress );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      dwValues = GetValuesCount( strItem, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         ASSERT( FALSE );
         break;
      }
      
      strAddressType = GetValueByIndex( strItem, NDS_SEPARATOR, 0L );
      strAddress     = GetValueByIndex( strItem, NDS_SEPARATOR, 1L );

      pNetAddress->put_AddressType( _ttol( (LPCTSTR)strAddressType ) );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = CreateBlobArray( strAddress, vBlob );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      pNetAddress->put_Address( vBlob );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pNetAddress->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      V_VT( &rValue )         = VT_DISPATCH;
      V_DISPATCH( &rValue )   = pDisp;
      break;

   }

   VariantClear( &vVal );
   VariantClear( &vBlob );

   RELEASE( pNetAddress );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSNetAddress::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSNetAddress::VARIANT_2_String( TCHAR* pszText, 
                                                VARIANT& rValue )
{
   IADsNetAddress*  pNetAddress= NULL;
   HRESULT  hResult;
   CString  strText;
   LONG     lAddressType;
   VARIANT  vItem;

   VariantInit( &vItem );

   while( TRUE )
   {
      hResult  = V_DISPATCH( &rValue )->QueryInterface( IID_IADsNetAddress, 
                                                        (void**)&pNetAddress );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pNetAddress->get_Address( &vItem );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pNetAddress->get_AddressType( &lAddressType );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      strText  = FromVariantToString( vItem );

      _ltot( lAddressType, pszText, 10 );
      _tcscat( pszText, NDS_SEPARATOR_S ) ;
      _tcscat( pszText, (LPCTSTR)strText );

      break;
   }

   RELEASE( pNetAddress );
   VariantClear( &vItem );

   return hResult;
}

/***********************************************************
  Function:    COleDsNDSOctetList::COleDsNDSOctetList
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSOctetList::COleDsNDSOctetList( )
{
   m_dwSyntaxID   = ADSTYPE_OCTET_LIST;
}

      
/***********************************************************
  Function:    COleDsNDSOctetList::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSOctetList::Native2Value( ADSVALUE* pValue, CString& rText )
{
   ADS_OCTET_LIST*  pOctetString;
   int              nIdx;

   ASSERT( ADSTYPE_OCTET_LIST == pValue->dwType );
   
   if( ADSTYPE_OCTET_LIST != pValue->dwType )
   {
      rText  = _T("ERROR: ADSTYPE_OCTET_LIST != pValue->dwType");
      return E_FAIL;
   }   
   nIdx  = 0;

   pOctetString   = pValue->pOctetList;
   while( NULL != pOctetString && NULL != pOctetString->Data ) 
   {
      if( 0 != nIdx )
         rText = rText + SEPARATOR_S;
      nIdx  = 1;

      rText = rText + Blob2String( pOctetString->Data, (DWORD)pOctetString->Length );

      pOctetString   = pOctetString->Next;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSOctetList::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSOctetList::Value2Native( ADSVALUE* pValue, 
                                           CString& rText )
{
   HRESULT           hResult  = E_FAIL;
   DWORD             dwValues, dwItem;
   CString           strItem;
   ADS_OCTET_LIST**  ppItem;

   pValue->dwType       = ADSTYPE_OCTET_LIST;
   pValue->pOctetList   = NULL;

   dwValues = GetValuesCount( rText, NDS_SEPARATOR );
   
   ppItem   = &(pValue->pOctetList);

   for( dwItem = 0; dwItem < dwValues ; dwItem++ )
   {
      strItem  = GetValueByIndex( rText, NDS_SEPARATOR, dwItem );
      *ppItem  = (ADS_OCTET_LIST*) AllocADsMem( sizeof( ADS_OCTET_LIST ) );

      hResult  = String2Blob( strItem.GetBuffer( strItem.GetLength( ) ),
                             (void**) &((*ppItem)->Data), 
                             &((*ppItem)->Length) );
      
      ASSERT( SUCCEEDED( hResult ) );

      (*ppItem)->Next    = NULL;
      ppItem   = &((*ppItem)->Next );
   }
   if( dwValues   == 0 )
   {
      pValue->pOctetList = (ADS_OCTET_LIST*) AllocADsMem( sizeof( ADS_OCTET_LIST ) );
      pValue->pOctetList->Data   = NULL;
      pValue->pOctetList->Next   = NULL;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSOctetList::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSOctetList::FreeAttrValue( ADSVALUE* pValue )
{
   ADS_OCTET_LIST*  pOctetList;
   ADS_OCTET_LIST*  pSaveOctetList;
   BOOL             bMark;

   pOctetList  = pValue->pOctetList;
   bMark       = FALSE;

   while( NULL != pOctetList )
   {
      FREE_MEMORY( pOctetList->Data );
      
      pSaveOctetList = pOctetList;
      pOctetList     = pOctetList->Next;

      FREE_MEMORY( pSaveOctetList );
   }
}


/***********************************************************
  Function:    COleDsNDSOctetList::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSOctetList::String_2_VARIANT( TCHAR* pszText, 
                                               VARIANT& rValue )
{
   HRESULT              hResult     = E_FAIL;
   CString              strItem;
   VARIANT              vVal;
   IADsOctetList*       pOctetList  = NULL;
   IDispatch*           pDisp       = NULL;

   VariantInit( &vVal );
   VariantInit( &rValue );

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_OctetList,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsOctetList,
                                  (void **)&pOctetList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      strItem  = pszText;
      hResult  = CreateBlobArrayEx( strItem, vVal, NDS_SEPARATOR );
      
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pOctetList->put_OctetList( vVal );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pOctetList->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      V_VT( &rValue )         = VT_DISPATCH;
      V_DISPATCH( &rValue )   = pDisp;
      break;

   }

   VariantClear( &vVal );
   RELEASE( pOctetList );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSOctetList::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSOctetList::VARIANT_2_String( TCHAR* pszText, 
                                               VARIANT& rValue )
{
   IADsOctetList*  pOctetList= NULL;
   HRESULT  hResult;
   VARIANT  vValue;
   CString  strText;
   LONG     lItems, lIdx;
   VARIANT  vItem;

   VariantInit( &vValue );

   *pszText = '\0';

   while( TRUE )
   {
      hResult  = V_DISPATCH( &rValue )->QueryInterface( IID_IADsOctetList, 
                                                        (void**)&pOctetList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pOctetList->get_OctetList( &vValue );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      lItems   = GetVARIANTSize ( vValue );
      for( lIdx = 0; lIdx < lItems ; lIdx++ )
      {
         hResult  = GetVARIANTAt( lIdx, vValue, vItem );
         strText  = FromVariantToString( vItem );
         if( lIdx != 0 )
         {
            _tcscat( pszText, NDS_SEPARATOR_S );
         }
         _tcscat( pszText, (LPCTSTR)strText );
         VariantClear( &vItem );
      }
	  break;
   }

   RELEASE( pOctetList );
   VariantClear( &vValue );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::COleDsNDSPostalAddress
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSPostalAddress::COleDsNDSPostalAddress  ( )
{
   m_dwSyntaxID   = ADSTYPE_POSTALADDRESS;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPostalAddress::Native2Value( ADSVALUE* pValue, 
                                               CString& rString )
{
   int   nIdx;

   ASSERT( ADSTYPE_POSTALADDRESS == pValue->dwType );
   
   if( ADSTYPE_POSTALADDRESS != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_POSTALADDRESS != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   rString  = _T("");

   for( nIdx = 0 ; nIdx < 6 ; nIdx++ )
   {
      LPWSTR   lpszPostalAddress;

      lpszPostalAddress = pValue->pPostalAddress->PostalAddress[ nIdx ];

      if( NULL != lpszPostalAddress )
      {
         TCHAR*   pszTemp;
         
         if( 0 != nIdx )
         {
            rString  = rString + NDS_SEPARATOR;
         }

         pszTemp  = (TCHAR*) AllocADsMem( sizeof(TCHAR) * ( 1 + wcslen( lpszPostalAddress ) ) );
         Convert( pszTemp, lpszPostalAddress );
         rString  = rString + pszTemp;
         FreeADsMem( pszTemp );
      }
      else
      {
         ASSERT( 0 != nIdx );
         break;
      }
   }

   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSPostalAddress::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPostalAddress::Value2Native( ADSVALUE* pValue, 
                                               CString& rString )
{
   DWORD dwIdx;
   DWORD dwValues;

   pValue->dwType = ADSTYPE_POSTALADDRESS;

   pValue->pPostalAddress  = (ADS_POSTALADDRESS*) AllocADsMem( sizeof(ADS_POSTALADDRESS) );

   for( dwIdx = 0; dwIdx < 6 ; dwIdx++ )
   {
      pValue->pPostalAddress->PostalAddress[ dwIdx ]  = NULL;
   }

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 0 == dwValues )
      return S_OK;

   for( dwIdx = 0; dwIdx < dwValues && dwIdx < 6; dwIdx++ )
   {
      CString  strItem;
      LPWSTR   lpszPostalAddress;

      strItem  = GetValueByIndex( rString, NDS_SEPARATOR, dwIdx );

      lpszPostalAddress = (LPWSTR) AllocADsMem( sizeof(TCHAR) * (strItem.GetLength( ) + 1 ) );
      Convert( lpszPostalAddress, strItem.GetBuffer( strItem.GetLength( ) ) );

      pValue->pPostalAddress->PostalAddress[ dwIdx ]  = lpszPostalAddress;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSPostalAddress::FreeAttrValue( ADSVALUE* pValue )
{
   DWORD dwIdx;

   for( dwIdx = 0; dwIdx < 6 ; dwIdx++ )
   {
      FREE_MEMORY( pValue->pPostalAddress->PostalAddress[ dwIdx ] );
   }
   FreeADsMem( pValue->pPostalAddress );
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPostalAddress::String_2_VARIANT( TCHAR* pszText, 
                                                   VARIANT& rVar )
{
   CString              strData;
   CString              strItem;
   DWORD                dwIdx;
   DWORD                dwValues;
   HRESULT              hResult;
   VARIANT              vArray;
   SAFEARRAY*           pSArray;
   SAFEARRAYBOUND       saBound;
   LONG                 lIdx;
   IADsPostalAddress*   pPostalAddress;
   IDispatch*           pDisp;

   hResult = CoCreateInstance(
                               CLSID_PostalAddress,
                               NULL,
                               CLSCTX_ALL,
                               IID_IADsPostalAddress,
                               (void **)&pPostalAddress );

   if( FAILED( hResult ) )
      return hResult;

   strData           = pszText;
   dwValues          = GetValuesCount( strData, NDS_SEPARATOR );
   saBound.lLbound   = LBOUND;
   saBound.cElements = dwValues;
   pSArray           = SafeArrayCreate( VT_VARIANT, 1, &saBound );
   if( NULL == pSArray )
   {
      ASSERT( FALSE );
      pPostalAddress->Release( );
      return E_FAIL;
   }

   for( dwIdx = 0; dwIdx < dwValues ; dwIdx++ )
   {
      VARIANT  vTemp;

      VariantInit( &vTemp );
      strItem           = GetValueByIndex( strData, NDS_SEPARATOR, dwIdx );
      V_VT( &vTemp )    = VT_BSTR;
      V_BSTR( &vTemp )  = AllocBSTR( strItem.GetBuffer( strItem.GetLength( ) ) );

      lIdx  = (long)dwIdx + LBOUND;
      hResult  = SafeArrayPutElement( pSArray, &lIdx, &vTemp );

      VariantClear( &vTemp );

      ASSERT( SUCCEEDED( hResult ) );
   }

   VariantInit( &vArray );
   V_VT( &vArray )      = VT_ARRAY | VT_VARIANT;
   V_ARRAY( &vArray )   = pSArray;

   hResult  = pPostalAddress->put_PostalAddress( vArray );
   ASSERT( SUCCEEDED( hResult ) );

   VariantClear( &vArray );

   hResult  = pPostalAddress->QueryInterface( IID_IDispatch, (void**)&pDisp );
   VariantInit( &rVar );

   V_VT( &rVar )        = VT_DISPATCH;
   V_DISPATCH( &rVar )  = pDisp;

   RELEASE( pPostalAddress );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPostalAddress::VARIANT_2_String( TCHAR* pszText, 
                                                   VARIANT& rVar )
{
   HRESULT           hResult  = E_FAIL;
   IADsPostalAddress* pPostalAddress = NULL;
   VARIANT           varData;
   CString           strText;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsPostalAddress,
                                                      (void**)&pPostalAddress );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pPostalAddress->get_PostalAddress( &varData );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      strText  = FromVariantArrayToString( varData, NDS_SEPARATOR_S );

      _tcscpy( pszText, (LPCTSTR)strText );

      VariantClear( &varData );

      break;
   }

   RELEASE( pPostalAddress )

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::COleDsNDSFaxNumber
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSFaxNumber::COleDsNDSFaxNumber  ( )
{
   m_dwSyntaxID   = ADSTYPE_FAXNUMBER;
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSFaxNumber::Native2Value( ADSVALUE* pValue, 
                                           CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_FAXNUMBER == pValue->dwType );
   
   if( ADSTYPE_FAXNUMBER != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_FAXNUMBER != pValue->dwType");
      return E_FAIL;
   }

   if( NULL == pValue->pFaxNumber )
   {
      ASSERT( FALSE );
      rString  = _T("ERROR: pValue->pFaxNumber Is NULL");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->pFaxNumber->TelephoneNumber )
   {
      _stprintf( szText, 
                 _T("%S"),
                 pValue->pFaxNumber->TelephoneNumber );
   }
   else
   {
      _tcscpy( szText, _T("NULL") );
   }
   _tcscat( szText, NDS_SEPARATOR_S );

   rString  = szText;

   if( NULL != pValue->pFaxNumber->Parameters )
   {
      rString = rString + Blob2String( pValue->pFaxNumber->Parameters, 
                                       pValue->pFaxNumber->NumberOfBits );
   }
   else
   {
      rString = rString + _T("NULL");
   }

   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSFaxNumber::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSFaxNumber::Value2Native( ADSVALUE* pValue, 
                                       CString& rString )
{
   DWORD    dwValues;
   CString  strTelephoneNumber;
   CString  strParameters;

   pValue->dwType = ADSTYPE_FAXNUMBER;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strTelephoneNumber   = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strParameters        = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   pValue->pFaxNumber   = (ADS_FAXNUMBER*) AllocADsMem( sizeof(ADS_FAXNUMBER) );
   ASSERT( NULL != pValue->pFaxNumber );
   if( NULL == pValue->pFaxNumber )
   {
      return E_FAIL;
   }
   pValue->pFaxNumber->TelephoneNumber = AllocWCHAR( (LPTSTR)(LPCTSTR)strTelephoneNumber );
   
   String2Blob( strParameters.GetBuffer( strParameters.GetLength( ) ),
                (void**) (pValue->pFaxNumber->Parameters), 
                &(pValue->pFaxNumber->NumberOfBits) );


   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSFaxNumber::FreeAttrValue( ADSVALUE* pValue )
{
   if( NULL !=  pValue->pFaxNumber )
   {
      FREE_MEMORY( pValue->pFaxNumber->TelephoneNumber );
      FREE_MEMORY( pValue->pFaxNumber->Parameters );
   }
   FREE_MEMORY( pValue->pFaxNumber );
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSFaxNumber::String_2_VARIANT( TCHAR* pszText, 
                                               VARIANT& rVar )
{
   DWORD          dwValues;
   CString        strTelephoneNumber, strVal;
   CString        strParameters;
   HRESULT        hResult;
   IADsFaxNumber* pFaxNumber  = NULL;
   IDispatch*     pDisp       = NULL;
   BSTR           bstrVal     = NULL;
   VARIANT        vVal;

   VariantInit( &vVal );

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_FaxNumber,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsFaxNumber,
                                  (void **)&pFaxNumber);
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strTelephoneNumber= GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strParameters     = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );

      bstrVal  = AllocBSTR( strTelephoneNumber.GetBuffer( strTelephoneNumber.GetLength( ) ) );

      hResult  = pFaxNumber->put_TelephoneNumber( bstrVal );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = CreateBlobArray( strParameters, vVal );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pFaxNumber->put_Parameters( vVal );
      ASSERT( SUCCEEDED( hResult ) );
      
      hResult  = pFaxNumber->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrVal );
   VariantClear( &vVal );
   RELEASE( pFaxNumber );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSFaxNumber::VARIANT_2_String( TCHAR* pszText, 
                                               VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsFaxNumber*  pFaxNumber = NULL;
   VARIANT     vParameters;
   BSTR        bstrTelephoneNumber  = NULL;
   CString     strText;

   VariantInit( &vParameters );
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsFaxNumber,
                                                      (void**)&pFaxNumber );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pFaxNumber->get_TelephoneNumber( &bstrTelephoneNumber );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pFaxNumber->get_Parameters( &vParameters );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      Convert( pszText, bstrTelephoneNumber );

      _tcscat( pszText, NDS_SEPARATOR_S );

      strText  = FromVariantToString( vParameters );

      _tcscat( pszText, (LPCTSTR)strText );

      break;
   }
   
   SysFreeString( bstrTelephoneNumber );
   VariantClear( &vParameters );
   RELEASE( pFaxNumber );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSEMail::COleDsNDSEMail
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSEMail::COleDsNDSEMail  ( )
{
   m_dwSyntaxID   = ADSTYPE_EMAIL;
}


/***********************************************************
  Function:    COleDsNDSEMail::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSEMail::Native2Value( ADSVALUE* pValue, 
                                       CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_EMAIL == pValue->dwType );
   
   if( ADSTYPE_EMAIL != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_EMAIL != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->Email.Address )
   {
      _stprintf( szText, 
                 _T("%ld & %S"),
                 pValue->Email.Type,  
                 pValue->Email.Address );
   }
   else
   {
      _stprintf( szText, 
                 _T("%ld & NULL"),
                 pValue->Email.Type );      
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSEMail::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSEMail::Value2Native( ADSVALUE* pValue, 
                                       CString& rString )
{
   DWORD    dwValues, dwSize;
   CString  strNumber;
   CString  strAddress;

   pValue->dwType = ADSTYPE_EMAIL;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strNumber   = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strAddress  = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   pValue->Email.Type   = (DWORD)_ttol( (LPCTSTR) strNumber );

   dwSize   = strAddress.GetLength( ) + 1;
   dwSize   = dwSize * sizeof(WCHAR);

   pValue->Email.Address   = (LPWSTR) AllocADsMem( dwSize );
   Convert( pValue->Email.Address, strAddress.GetBuffer( strAddress.GetLength( ) ) );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSEMail::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSEMail::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->Email.Address );
}


/***********************************************************
  Function:    COleDsNDSEMail::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSEMail::String_2_VARIANT( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   DWORD    dwValues;
   CString  strNumber, strVal;
   CString  strAddress;
   HRESULT              hResult;
   IADsEmail*   pEMail  = NULL;
   IDispatch*   pDisp   = NULL;
   BSTR         bstrVal = NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_Email,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsEmail,
                                  (void **)&pEMail);
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strNumber   = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strAddress  = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );

      hResult  = pEMail->put_Type( _ttol( (LPCTSTR) strNumber )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrVal  = AllocBSTR( strAddress.GetBuffer( strAddress.GetLength( ) ) );

      hResult  = pEMail->put_Address( bstrVal );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pEMail->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrVal );
   RELEASE( pEMail );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSEMail::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSEMail::VARIANT_2_String( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsEmail*  pEmail = NULL;
   LONG        lType;
   BSTR        bstrVal  = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsEmail,
                                                      (void**)&pEmail );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pEmail->get_Type( &lType );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pEmail->get_Address( &bstrVal );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      _ltot( lType, pszText, 10 );
      _tcscat( pszText, NDS_SEPARATOR_S );
      Convert( pszText + _tcslen(pszText), bstrVal );

      break;
   }
   
   SysFreeString( bstrVal );
   RELEASE( pEmail );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSTypedName::COleDsNDSTypedName
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSTypedName::COleDsNDSTypedName( )
{
   m_dwSyntaxID   = ADSTYPE_TYPEDNAME;
}


/***********************************************************
  Function:    COleDsNDSTypedName::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTypedName::Native2Value( ADSVALUE* pValue, 
                                       CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_TYPEDNAME == pValue->dwType );
   
   if( ADSTYPE_TYPEDNAME != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_TYPEDNAME != pValue->dwType");
      return E_FAIL;
   }

   if( NULL == pValue->pTypedName )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->pTypedName->ObjectName )
   {
      _stprintf( szText, 
                 _T("%S & %ld & %ld"),
                 pValue->pTypedName->ObjectName,
                 pValue->pTypedName->Level,
                 pValue->pTypedName->Interval );
   }
   else
   {
      _stprintf( szText, 
                 _T("NULL & %ld & %ld"),
                 pValue->pTypedName->Level,
                 pValue->pTypedName->Interval );
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSTypedName::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTypedName::Value2Native( ADSVALUE* pValue, 
                                          CString& rString )
{
   DWORD    dwValues;
   CString  strLevel;
   CString  strInterval;
   CString  strObjectName;

   pValue->dwType = ADSTYPE_TYPEDNAME;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 3 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   pValue->pTypedName   = (ADS_TYPEDNAME*) AllocADsMem( sizeof(ADS_TYPEDNAME) );

   strObjectName  = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strLevel       = GetValueByIndex( rString, NDS_SEPARATOR, 1L );
   strInterval    = GetValueByIndex( rString, NDS_SEPARATOR, 2L );

   pValue->pTypedName->Level     = (DWORD)_ttol( (LPCTSTR) strLevel );
   pValue->pTypedName->Interval  = (DWORD)_ttol( (LPCTSTR) strInterval );
   pValue->pTypedName->ObjectName= AllocWCHAR( (TCHAR*)(LPCTSTR)strObjectName );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSTypedName::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSTypedName::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->pTypedName->ObjectName );
   FREE_MEMORY( pValue->pTypedName );
}


/***********************************************************
  Function:    COleDsNDSEMail::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTypedName::String_2_VARIANT( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   DWORD          dwValues;
   CString        strLevel, strVal;
   CString        strInterval;
   CString        strObjectName;
   HRESULT        hResult;
   IADsTypedName* pTypedName = NULL;
   IDispatch*     pDisp = NULL;
   BSTR           bstrObjectName =  NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_TypedName,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsTypedName,
                                  (void **)&pTypedName );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 3 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strObjectName  = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strLevel       = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );
      strInterval    = GetValueByIndex( strVal, NDS_SEPARATOR, 2L );
      

      hResult  = pTypedName->put_Level( _ttol( (LPCTSTR) strLevel )  );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pTypedName->put_Interval( _ttol( (LPCTSTR) strInterval )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrObjectName = AllocBSTR( strObjectName.GetBuffer( strObjectName.GetLength( ) ) );

      hResult  = pTypedName->put_ObjectName( bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pTypedName->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrObjectName );
   RELEASE( pTypedName );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSTypedName::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTypedName::VARIANT_2_String( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsTypedName*   pTypedName = NULL;
   LONG        lLevel, lInterval;
   BSTR        bstrObjectName  = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsTypedName,
                                                      (void**)&pTypedName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pTypedName->get_Level( &lLevel );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pTypedName->get_Interval( &lInterval );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pTypedName->get_ObjectName( &bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      Convert( pszText, bstrObjectName );
      _tcscat( pszText, NDS_SEPARATOR_S );
      _ltot( lLevel, pszText + _tcslen( pszText), 10 );
      _tcscat( pszText, NDS_SEPARATOR_S );
      _ltot( lInterval, pszText + _tcslen( pszText), 10 );

      break;
   }
   
   SysFreeString( bstrObjectName );
   RELEASE( pTypedName );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSHold::COleDsNDSHold
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSHold::COleDsNDSHold( )
{
   m_dwSyntaxID   = ADSTYPE_HOLD;
}


/***********************************************************
  Function:    COleDsNDSHold::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSHold::Native2Value( ADSVALUE* pValue, 
                                      CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_HOLD == pValue->dwType );
   
   if( ADSTYPE_HOLD != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_HOLD != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->Hold.ObjectName )
   {
      _stprintf( szText, 
                 _T("%ld & %S"),
                 pValue->Hold.Amount,  
                 pValue->Hold.ObjectName );
   }
   else
   {
      _stprintf( szText, 
                 _T("NULL & %ld "),
                 pValue->Hold.Amount );      
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSHold::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSHold::Value2Native( ADSVALUE* pValue, 
                                      CString& rString )
{
   DWORD    dwValues;
   CString  strAmount;
   CString  strObjectName;

   pValue->dwType = ADSTYPE_HOLD;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strAmount      = GetValueByIndex( rString, NDS_SEPARATOR, 1L );
   strObjectName  = GetValueByIndex( rString, NDS_SEPARATOR, 0L );

   pValue->Hold.Amount    = (DWORD)_ttol( (LPCTSTR) strAmount );
   pValue->Hold.ObjectName = AllocWCHAR( (TCHAR*)(LPCTSTR)strObjectName );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSHold::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSHold::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->Hold.ObjectName );
}


/***********************************************************
  Function:    COleDsNDSEMail::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSHold::String_2_VARIANT( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   DWORD          dwValues;
   CString        strAmount, strVal;
   CString        strObjectName;
   HRESULT        hResult;
   IADsHold*      pHold = NULL;
   IDispatch*     pDisp = NULL;
   BSTR           bstrObjectName =  NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_Hold,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsHold,
                                  (void **)&pHold );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strAmount     = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );
      strObjectName  = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );

      hResult  = pHold->put_Amount( _ttol( (LPCTSTR) strAmount )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrObjectName = AllocBSTR( strObjectName.GetBuffer( strObjectName.GetLength( ) ) );

      hResult  = pHold->put_ObjectName( bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pHold->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrObjectName );
   RELEASE( pHold );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSHold::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSHold::VARIANT_2_String( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsHold*   pHold = NULL;
   LONG        lAmount;
   BSTR        bstrObjectName  = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsHold,
                                                      (void**)&pHold );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pHold->get_Amount( &lAmount );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pHold->get_ObjectName( &bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      Convert( pszText, bstrObjectName );
      _tcscat( pszText, NDS_SEPARATOR_S );
      _ltot( lAmount, pszText + _tcslen( pszText), 10 );

      break;
   }
   
   SysFreeString( bstrObjectName );
   RELEASE( pHold );

   return hResult;
}



/***********************************************************
  Function:    COleDsNDSBackLink::COleDsNDSBackLink
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSBackLink::COleDsNDSBackLink( )
{
   m_dwSyntaxID   = ADSTYPE_BACKLINK;
}


/***********************************************************
  Function:    COleDsNDSBackLink::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSBackLink::Native2Value( ADSVALUE* pValue, 
                                       CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_BACKLINK == pValue->dwType );
   
   if( ADSTYPE_BACKLINK != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_BACKLINK != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->BackLink.ObjectName )
   {
      _stprintf( szText, 
                 _T("%ld & %S"),
                 pValue->BackLink.RemoteID,  
                 pValue->BackLink.ObjectName );
   }
   else
   {
      _stprintf( szText, 
                 _T("%ld & NULL"),
                 pValue->BackLink.RemoteID );      
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSBackLink::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSBackLink::Value2Native( ADSVALUE* pValue, 
                                          CString& rString )
{
   DWORD    dwValues;
   CString  strRemoteID;
   CString  strObjectName;

   pValue->dwType = ADSTYPE_BACKLINK;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strRemoteID    = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strObjectName  = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   pValue->BackLink.RemoteID     = (DWORD)_ttol( (LPCTSTR) strRemoteID );
   pValue->BackLink.ObjectName   = AllocWCHAR( (TCHAR*)(LPCTSTR)strObjectName );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSBackLink::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSBackLink::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->BackLink.ObjectName );
}


/***********************************************************
  Function:    COleDsNDSEMail::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSBackLink::String_2_VARIANT( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   DWORD          dwValues;
   CString        strRemoteID, strVal;
   CString        strObjectName;
   HRESULT        hResult;
   IADsBackLink*  pBackLink  = NULL;
   IDispatch*     pDisp   = NULL;
   BSTR           bstrObjectName =  NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_BackLink,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsBackLink,
                                  (void **)&pBackLink );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strRemoteID    = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strObjectName  = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );

      hResult  = pBackLink->put_RemoteID( _ttol( (LPCTSTR) strRemoteID )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrObjectName = AllocBSTR( strObjectName.GetBuffer( strObjectName.GetLength( ) ) );

      hResult  = pBackLink->put_ObjectName( bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pBackLink->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrObjectName );
   RELEASE( pBackLink );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSBackLink::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSBackLink::VARIANT_2_String( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsBackLink*  pBackLink = NULL;
   LONG        lRemoteID;
   BSTR        bstrObjectName  = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsBackLink,
                                                      (void**)&pBackLink );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pBackLink->get_RemoteID( &lRemoteID );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pBackLink->get_ObjectName( &bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      _ltot( lRemoteID, pszText, 10 );
      _tcscat( pszText, NDS_SEPARATOR_S );
      Convert( pszText + _tcslen(pszText), bstrObjectName );

      break;
   }
   
   SysFreeString( bstrObjectName );
   RELEASE( pBackLink );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::COleDsNDSPostalAddress
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSPath::COleDsNDSPath  ( )
{
   m_dwSyntaxID   = ADSTYPE_PATH;
}


/***********************************************************
  Function:    COleDsNDSPath::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPath::Native2Value( ADSVALUE* pValue, 
                                       CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_PATH == pValue->dwType );
   
   if( ADSTYPE_PATH != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_PATH != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->pPath )
   {
      _stprintf( szText, 
                 _T("%ld & %S & %S"),
                 pValue->pPath->Type,  
                 pValue->pPath->VolumeName,
                 pValue->pPath->Path);
   }
   else
   {
      _stprintf( szText, 
                 _T("%ld & NULL & NULL"),
                 pValue->pPath->Type );      
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSPath::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPath::Value2Native( ADSVALUE* pValue, 
                                      CString& rString )
{
   DWORD    dwValues;
   CString  strType;
   CString  strVolName;
   CString  strPath;

   pValue->pPath  = (ADS_PATH*) AllocADsMem( sizeof(ADS_PATH) );
   if( NULL == pValue->pPath )
      return E_FAIL;

   pValue->pPath->VolumeName  = NULL;
   pValue->pPath->Path        = NULL;

   pValue->dwType = ADSTYPE_PATH;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 3 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strType     = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strVolName  = GetValueByIndex( rString, NDS_SEPARATOR, 1L );
   strPath     = GetValueByIndex( rString, NDS_SEPARATOR, 2L );

   pValue->pPath->Type  = (DWORD)_ttol( (LPCTSTR) strType );
   pValue->pPath->VolumeName  = AllocWCHAR( strVolName.GetBuffer( strVolName.GetLength( ) ) );
   pValue->pPath->Path  = AllocWCHAR( strPath.GetBuffer( strPath.GetLength( ) ) );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSEMail::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSPath::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->pPath->VolumeName );
   FREE_MEMORY( pValue->pPath->Path );
   FREE_MEMORY( pValue->pPath );
}


/***********************************************************
  Function:    COleDsNDSPath::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPath::String_2_VARIANT( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   DWORD    dwValues;
   CString  strType, strVal;
   CString  strVolName;
   CString  strPath;
   HRESULT     hResult;
   IADsPath*   pPath    = NULL;
   IDispatch*  pDisp   = NULL;
   BSTR        bstrVal = NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_Path,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsPath,
                                  (void **)&pPath );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 3 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strType     = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strVolName  = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );
      strPath     = GetValueByIndex( strVal, NDS_SEPARATOR, 2L );

      hResult  = pPath->put_Type( _ttol( (LPCTSTR) strType )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrVal  = AllocBSTR( strVolName.GetBuffer( strVolName.GetLength( ) ) );
      hResult  = pPath->put_VolumeName( bstrVal );
      ASSERT( SUCCEEDED( hResult ) );
      SysFreeString( bstrVal );

      bstrVal  = AllocBSTR( strPath.GetBuffer( strPath.GetLength( ) ) );
      hResult  = pPath->put_Path( bstrVal );
      ASSERT( SUCCEEDED( hResult ) );
      SysFreeString( bstrVal );


      hResult  = pPath->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   RELEASE( pPath );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSPath::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPath::VARIANT_2_String( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   HRESULT     hResult     = E_FAIL;
   IADsPath*   pPath       = NULL;
   LONG        lType;
   BSTR        bstrVolName = NULL;
   BSTR        bstrPath    = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsPath,
                                                      (void**)&pPath );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pPath->get_Type( &lType );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pPath->get_VolumeName( &bstrVolName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pPath->get_Path( &bstrPath );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      _ltot( lType, pszText, 10 );
      _tcscat( pszText, NDS_SEPARATOR_S );
      Convert( pszText + _tcslen(pszText), bstrVolName );
      _tcscat( pszText, NDS_SEPARATOR_S );
      Convert( pszText + _tcslen(pszText), bstrPath );
      break;
   }
   
   SysFreeString( bstrVolName );
   SysFreeString( bstrPath );
   RELEASE( pPath );

   return hResult;
}





/***********************************************************
  Function:    COleDsNDSTimeStamp::COleDsNDSTimeStamp
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSTimeStamp::COleDsNDSTimeStamp( )
{
   m_dwSyntaxID   = ADSTYPE_TIMESTAMP;
}


/***********************************************************
  Function:    COleDsNDSTimeStamp::GenerateString
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsNDSTimeStamp::GenerateString( TCHAR* szText,
                                              DWORD dwWholeSeconds,
                                              DWORD dwEventID )
{
   _tcscpy( szText, _T("WholeSeconds: ") );

   _ultot( dwWholeSeconds, 
           szText + _tcslen(szText), 
           10 );
   _tcscat( szText, _T("EventID: ") );

   _ultot( dwEventID, 
           szText + _tcslen(szText), 
           10 );

   return S_OK;
}


/***********************************************************
  Function: COleDsNDSTimeStamp::GetComponents
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTimeStamp::GetComponents( TCHAR* pszString, 
                                            DWORD* pdwWholeSeconds, 
                                            DWORD* pdwEventID )
{
   
   TCHAR szText1[ 128 ];
   TCHAR szText2[ 128 ];
   

   *pdwWholeSeconds  = 0xAABBCCDD;
   *pdwEventID       = 0xAABBCCDD;

   _stscanf( pszString, _T("%s%d%s%d"), szText1, 
              pdwWholeSeconds, szText2, pdwWholeSeconds );

   return ( (*pdwWholeSeconds  == 0xAABBCCDD) && (*pdwEventID == 0xAABBCCDD) ) ? 
            S_OK : E_FAIL;
}



/***********************************************************
  Function: COleDsNDSTimeStamp::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsNDSTimeStamp::Value2Native  ( ADSVALUE* pValue, 
                                              CString& rString )
{
   DWORD    dwValues;
   CString  strWholeSeconds;
   CString  strEventID;

   pValue->dwType = ADSTYPE_TIMESTAMP;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strWholeSeconds= GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strEventID     = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   pValue->Timestamp.WholeSeconds= (DWORD)_ttol( (LPCTSTR) strWholeSeconds );
   pValue->Timestamp.EventID     = (DWORD)_ttol( (LPCTSTR) strEventID );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSTimeStamp::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsNDSTimeStamp::Native2Value( ADSVALUE* pValue, 
                                            CString& rString)
{
   TCHAR szText[ 128 ];

   ASSERT( ADSTYPE_TIMESTAMP != pValue->dwType );
   
   if( ADSTYPE_TIMESTAMP != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_TIMESTAMP != pValue->dwType");
      return E_FAIL;
   }

   _ultot( pValue->Timestamp.WholeSeconds, 
           szText, 
           10 );

   _tcscat( szText, NDS_SEPARATOR_S );

   _ultot( pValue->Timestamp.EventID, 
           szText + _tcslen(szText), 
           10 );

   rString  = szText;

   return S_OK;
   
}


/***********************************************************
  Function:    COleDsNDSTimeStamp::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTimeStamp::String_2_VARIANT( TCHAR* pszText, 
                                               VARIANT& rVar )
{
   HRESULT        hResult;
   IADsTimestamp* pTimeStamp;
   DWORD    dwValues;
   CString  strWholeSeconds;
   CString  strEventID;
   CString  rString;

   rString  = pszText;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strWholeSeconds= GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strEventID     = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   hResult  =    hResult = CoCreateInstance(
                                             CLSID_Timestamp,
                                             NULL,
                                             CLSCTX_INPROC_SERVER,
                                             IID_IADsTimestamp,
                                             (void **)&pTimeStamp );

   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
      return hResult;

   hResult  = pTimeStamp->put_WholeSeconds( _ttol( (LPCTSTR) strWholeSeconds ) );
   ASSERT( SUCCEEDED( hResult ) );

   hResult  = pTimeStamp->put_EventID( _ttol( (LPCTSTR) strEventID ) );
   ASSERT( SUCCEEDED( hResult ) );
   

   if( SUCCEEDED( hResult ) )
   {
      IDispatch*  pDisp = NULL;

      V_VT( &rVar )   = VT_DISPATCH;
      hResult  = pTimeStamp->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_DISPATCH( &rVar )   = pDisp;
   }

   pTimeStamp->Release( );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSTimeStamp::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTimeStamp::VARIANT_2_String( TCHAR* pszText, VARIANT& rVar )
{
   IADsTimestamp* pTimeStamp = NULL;
   HRESULT        hResult;
   long           lWholeSeconds, lEventID;

   ASSERT( VT_DISPATCH == V_VT( &rVar) );
   if( VT_DISPATCH != V_VT( &rVar) )
   {
      _tcscpy( pszText, _T("ERROR: VT_DISPATCH != V_VT( &rVar)") );
      return E_FAIL;
   }

   hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsTimestamp, 
                                                   (void**)&pTimeStamp );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      _tcscpy( pszText, _T("ERROR: QI for IID_IADsTimeStamp fails") );
      return hResult;
   }

   hResult  = pTimeStamp->get_WholeSeconds( &lWholeSeconds );
   ASSERT( SUCCEEDED( hResult ) );

   hResult  = pTimeStamp->get_EventID( &lEventID );
   ASSERT( SUCCEEDED( hResult ) );

   pTimeStamp->Release( );

   _ultot( lWholeSeconds, 
           pszText, 
           10 );

   _tcscat( pszText, NDS_SEPARATOR_S );

   _ultot( lEventID, 
           pszText + _tcslen(pszText), 
           10 );

   return hResult;
}

/***********************************************************
  Function:    COleDsNDSComplexType::COleDsNDSComplexType
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSComplexType::COleDsNDSComplexType( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsNDSComplexType::VarToDisplayStringEx( VARIANT& var, 
                                                     BOOL bMultiValued )
{
   SAFEARRAY*  pSArray;
   HRESULT     hResult;
   LONG        uLow, uHigh, uIndex;
   VARIANT     vItem;
   CString     strVal;
   CString     strTemp;

   pSArray  = V_ARRAY( &var );

   hResult  = SafeArrayGetLBound( pSArray, 1, &uLow );
   hResult  = SafeArrayGetUBound( pSArray, 1, &uHigh );

   if( !bMultiValued )
   {
      ASSERT( uLow == uHigh );
   }

   for( uIndex = uLow; uIndex <= uHigh; uIndex++ )
   {
      if( uIndex != uLow )
      {
         strVal  += SEPARATOR_S;
      }

      VariantInit( &vItem );
      hResult  = SafeArrayGetElement( pSArray, &uIndex, &vItem );
      ASSERT( SUCCEEDED( hResult ) );

      strTemp   = VarToDisplayString( vItem, bMultiValued, FALSE );
      VariantClear( &vItem );
      strVal   += strTemp;

      if( strVal.GetLength( ) > 8096 )
         break;
   }

   return strVal;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsNDSComplexType::VarToDisplayString( VARIANT& var, 
                                                   BOOL bMultiValued, 
                                                   BOOL bUseEx )
{
   LONG        uLow, uHigh, uIndex;
   SAFEARRAY*  psa;
   VARIANT     vItem;
   CString     strVal, strTemp;
   HRESULT     hResult;
   TCHAR       szText[ 2048 ];

   if( bUseEx )
   {
      return VarToDisplayStringEx( var, bMultiValued );
   }
   
   if( bMultiValued )   
   {
      if( VT_DISPATCH == V_VT( &var ) )
      {
         VARIANT_2_String( szText, var );
         return CString( szText );
      }

      ASSERT( (VT_ARRAY | VT_VARIANT) == V_VT(&var) );
      if( (VT_ARRAY | VT_VARIANT) == V_VT(&var) )
      {
         return CString( _T("ERROR: (VT_ARRAY | VT_VARIANT) != V_VT(&var)") );
      }

      psa   = V_ARRAY( &var );
      ASSERT( NULL != psa );
      if( NULL == psa )
      {
         return CString( _T("ERROR: NULL == psa" ) );
      }

      hResult  = SafeArrayGetLBound( psa, 1, &uLow );
      hResult  = SafeArrayGetUBound( psa, 1, &uHigh );

      for( uIndex = uLow; uIndex <= uHigh; uIndex++ )
      {
         if( uIndex != uLow )
         {
            strVal  += SEPARATOR_S;
         }

         VariantInit( &vItem );
         hResult  = SafeArrayGetElement( psa, &uIndex, &vItem );
         ASSERT( SUCCEEDED( hResult ) );

         strTemp   = VarToDisplayString( vItem, FALSE, FALSE );
         VariantClear( &vItem );
         strVal   += strTemp;

         if( strVal.GetLength( ) > 8096 )
            break;
      }
   }
   else
   {
      hResult  = VARIANT_2_String( szText, var );

      if( SUCCEEDED( hResult ) )
      {
         strVal   = szText;
      }
      else
      {
         strVal   = OleDsGetErrorText( hResult );
      }
   }

   return strVal;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  COleDsNDSComplexType::DisplayStringToDispParamsEx( CString& rText, 
                                                         DISPPARAMS& dispParams, 
                                                         BOOL bMultiValued )
{
   SAFEARRAY*        pSArray;
   SAFEARRAYBOUND    saBound;
   HRESULT           hResult;
   LONG              lIdx = LBOUND;

   DisplayStringToDispParams( rText, dispParams, bMultiValued, FALSE );
   
   if( !bMultiValued )
   {
      saBound.lLbound   = LBOUND;
      saBound.cElements = 1;
      pSArray           = SafeArrayCreate( VT_VARIANT, 1, &saBound );
      hResult           = SafeArrayPutElement( pSArray, &lIdx, &dispParams.rgvarg[0] );
      
      VariantClear( &dispParams.rgvarg[0] );

      V_VT( &dispParams.rgvarg[0] )    = VT_ARRAY | VT_VARIANT;
      V_ARRAY( &dispParams.rgvarg[0] ) = pSArray;
   }

   return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsNDSComplexType::DisplayStringToDispParams( CString& rText, 
                                                          DISPPARAMS& dispParams, 
                                                          BOOL bMultiValued, 
                                                          BOOL bUseEx )
{
   HRESULT  hResult;
   int      x= 0;
  
   if( bUseEx )
   {
      return DisplayStringToDispParamsEx( rText, dispParams, bMultiValued );
   }

   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   if( bMultiValued )
   {
      SAFEARRAY*     psa;
      SAFEARRAYBOUND sab;
      TCHAR*         strText;
      TCHAR*         strStore;
      int            nItems   = 0;
      int            nIdx;
      int            nSize;
      HRESULT        hResult;

      //rText.MakeUpper( );

      strText  = (TCHAR*) new TCHAR[ rText.GetLength( ) + 1 ];
      strStore = strText;
      if( !strText )
      {
         return E_FAIL;
      }

      _tcscpy( strText, rText.GetBuffer( rText.GetLength( ) ) );
      nSize    = rText.GetLength( );
      nItems   = 1;
      for( nIdx = 0; nIdx < nSize ; nIdx++ )
      {
         if( strText[ nIdx ] == SEPARATOR_C )
         {
            strText[ nIdx ]   = _T('\0');
            nItems++;
         }
      }

      sab.cElements   = nItems;
      sab.lLbound     = LBOUND;
      psa             = SafeArrayCreate( VT_VARIANT, 1, &sab );
      ASSERT( NULL != psa );
      if ( psa )
      {
         for( nIdx = LBOUND; nIdx < ( LBOUND + nItems ) ; nIdx++ )
         {
            VARIANT  var;

            String_2_VARIANT( strText, var );
            strText += _tcslen( strText ) + 1;

            hResult  = SafeArrayPutElement( psa, (long FAR *)&nIdx, &var );
            VariantClear( &var );
         }

         V_VT( &dispParams.rgvarg[0] )     = VT_VARIANT | VT_ARRAY;
         V_ARRAY( &dispParams.rgvarg[0] )  = psa;
      }

      delete [] strStore;
   }
   else
   {
      hResult  = String_2_VARIANT( rText.GetBuffer( rText.GetLength( ) ), 
                                   dispParams.rgvarg[0] );
   }

   return SUCCEEDED( hResult );
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsVARIANT::VarToDisplayString( VARIANT& var, BOOL bMultiValued, BOOL bUseEx )
{
   return FromVariantArrayToString( var );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsVARIANT::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsVARIANT::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   return S_OK;
}
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  COleDsVARIANT::DisplayStringToDispParams( CString& rText, DISPPARAMS& dispParams, BOOL bMultiValued, BOOL bUseEx )
{
   HRESULT  hResult;
   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   hResult  = BuildVariantArray( VT_BSTR, rText, dispParams.rgvarg[0] );

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsOctetString::COleDsOctetString( )
{
   m_dwSyntaxID   = ADSTYPE_OCTET_STRING;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsOctetString::VarToDisplayStringEx( VARIANT& var, BOOL bMultiValued )
{
   SAFEARRAY*  pSArray;
   HRESULT     hResult;
   LONG        uLow, uHigh, uIndex;
   VARIANT     vItem;
   CString     strVal;
   CString     strTemp;

   pSArray  = V_ARRAY( &var );

   hResult  = SafeArrayGetLBound( pSArray, 1, &uLow );
   hResult  = SafeArrayGetUBound( pSArray, 1, &uHigh );

   if( !bMultiValued )
   {
      ASSERT( uLow == uHigh );
   }

   for( uIndex = uLow; uIndex <= uHigh; uIndex++ )
   {
      if( uIndex != uLow )
      {
         strVal  += SEPARATOR_S;
      }

      VariantInit( &vItem );
      hResult  = SafeArrayGetElement( pSArray, &uIndex, &vItem );
      ASSERT( SUCCEEDED( hResult ) );

      strTemp   = VarToDisplayString( vItem, bMultiValued, FALSE );
      VariantClear( &vItem );
      strVal   += strTemp;

      if( strVal.GetLength( ) > 8096 )
         break;
   }

   return strVal;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsOctetString::VarToDisplayString( VARIANT& var, BOOL bMultiValued, BOOL bUseEx )
{
   if( bUseEx )
   {
      return VarToDisplayStringEx( var, bMultiValued );
   }
   
   if( bMultiValued )   
   {
      return FromVariantArrayToString( var );
   }
   else
   {
      return FromVariantArrayToString( var );
   }
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  COleDsOctetString::DisplayStringToDispParamsEx( CString& rText, DISPPARAMS& dispParams, BOOL bMultiValued )
{
   SAFEARRAY*        pSArray;
   SAFEARRAYBOUND    saBound;
   HRESULT           hResult;
   LONG              lIdx = LBOUND;

   DisplayStringToDispParams( rText, dispParams, bMultiValued, FALSE );
   
   if( !bMultiValued )
   {
      saBound.lLbound   = LBOUND;
      saBound.cElements = 1;
      pSArray           = SafeArrayCreate( VT_VARIANT, 1, &saBound );
      hResult           = SafeArrayPutElement( pSArray, &lIdx, &dispParams.rgvarg[0] );
      
      VariantClear( &dispParams.rgvarg[0] );

      V_VT( &dispParams.rgvarg[0] )    = VT_ARRAY | VT_VARIANT;
      V_ARRAY( &dispParams.rgvarg[0] ) = pSArray;
   }

   return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsOctetString::DisplayStringToDispParams( CString& rText, DISPPARAMS& dispParams, 
                                                       BOOL bMultiValued, BOOL bUseEx )
{
   HRESULT  hResult;
   int      x= 0;

  
   if( bUseEx )
   {
      return DisplayStringToDispParamsEx( rText, dispParams, bMultiValued );
   }

   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   if( bMultiValued )
   {
      hResult  = CreateBlobArrayEx( rText, dispParams.rgvarg[0] );
   }
   else
   {
      hResult  = CreateBlobArray( rText, dispParams.rgvarg[0] );
   }

   return SUCCEEDED( hResult );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsOctetString::Native2Value( ADSVALUE* pADsObject, 
                                           CString& rVal )
{
   DWORD    dwItem;
   LPBYTE   lpByte;
   TCHAR    szText[ 128 ];

   lpByte   = pADsObject->OctetString.lpValue;

   ASSERT( lpByte );
   
   _tcscpy( szText, _T("[") );
   _ultot( pADsObject->OctetString.dwLength, szText + _tcslen( szText ), 10 );
   _tcscat( szText, _T("]") );


   for( dwItem = 0L; dwItem < pADsObject->OctetString.dwLength ; dwItem++ )
   {
#ifdef UNICODE
      swprintf( 
#else
      sprintf( 
#endif
               szText + _tcslen(szText), _T(" x%02x"), lpByte[ dwItem ] );

      if( _tcslen( szText ) > 120 )
         break;
   }
   rVal  = szText;

   return S_OK;
}


/***********************************************************
  Function: COleDsOctetString::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsOctetString::Value2Native( ADSVALUE* pADsObject, 
                                           CString& rVal )
{
   HRESULT  hResult  = E_FAIL;
   TCHAR*   strText;
   LPBYTE   lpByte;
   int      nSize, nItems, nIdx;
   
   rVal.MakeUpper( );

   strText  = (TCHAR*) new TCHAR[ rVal.GetLength( ) + 1 ];
   if( !strText )
   {
      return E_FAIL;
   }

   _tcscpy( strText, rVal.GetBuffer( rVal.GetLength( ) ) );
   nSize    = rVal.GetLength( );
   nItems   = 0;
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      if( strText[ nIdx ] == _T('X') )
      {
         nItems++;
      }
   }

   lpByte         = (LPBYTE) AllocADsMem( nItems );
   ASSERT( lpByte );
   if ( lpByte ) 
   {
      int   nItems = 0;

      for( nIdx = 0; nIdx < nSize ; nIdx++ )
      {
         if( strText[ nIdx ] == _T('X') )
         {
            lpByte[ nItems++] = GetByteValue( strText + nIdx + 1 );
            while( nIdx < nSize && !isspace( strText[ nIdx ] ) )
               nIdx++;
         }
      }
   }
   pADsObject->OctetString.lpValue  = lpByte;
   pADsObject->OctetString.dwLength = nItems;

   delete [] strText;

   return hResult;
}


/***********************************************************
  Function:    COleDsOctetString::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  COleDsOctetString::FreeAttrValue( ADSVALUE* pADsValue )
{
   ASSERT( NULL != pADsValue->OctetString.lpValue );

   FREE_MEMORY( pADsValue->OctetString.lpValue );
}


/*******************************************************************
  Function:    GetByteValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
*******************************************************************/
BYTE  COleDsOctetString::GetByteValue( TCHAR* szString )
{
   BYTE  bBytes[ 2 ];

   bBytes[ 0 ] = bBytes[ 1 ]  = 0;

   for( int i = 0; i < 2 ; i++ )
   {
      if( !szString[ i ] )
         break;

#ifdef UNICODE
      if( !iswdigit( szString[ i ] ) )
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x37; 
      }
#else
      if( !isdigit( szString[ i ] ) )
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x37; 
      }
#endif
      else
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x30; 
      }
   }

   return ( bBytes[ 0 ] << 4 ) + bBytes[ 1 ];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\delitem.cpp ===
// DeleteItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "delitem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CDeleteItem::CDeleteItem(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteItem)
	m_strClass = _T("");
	m_strName = _T("");
	m_strParent = _T("");
	m_bRecursive = FALSE;
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CDeleteItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteItem)
	DDX_Text(pDX, IDC_CLASS, m_strClass);
	DDX_Text(pDX, IDC_RELATIVENAME, m_strName);
	DDX_Text(pDX, IDC_PARENTNAME, m_strParent);
	DDX_Check(pDX, IDC_DELETERECURSIVE, m_bRecursive);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteItem, CDialog)
	//{{AFX_MSG_MAP(CDeleteItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\delgrpit.cpp ===
// DeleteGroupItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "delgrpit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CDeleteGroupItem::CDeleteGroupItem(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteGroupItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteGroupItem)
	m_strItemName = _T("");
	m_strParent = _T("");
	m_strItemType = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CDeleteGroupItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteGroupItem)
	DDX_Text(pDX, IDC_ITEMNAME, m_strItemName);
	DDX_Text(pDX, IDC_PARENT, m_strParent);
	DDX_Text(pDX, IDC_ITEMTYPE, m_strItemType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteGroupItem, CDialog)
	//{{AFX_MSG_MAP(CDeleteGroupItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteGroupItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\enterdlg.cpp ===
// enterdlg.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "viewex.h"
#include "enterdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnterDlg dialog

IMPLEMENT_DYNAMIC(CEnterDlg, CDialog)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CEnterDlg::CEnterDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEnterDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEnterDlg)
	m_strInput = "";
	//}}AFX_DATA_INIT
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CEnterDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEnterDlg)
	DDX_Text(pDX, IDC_EDIT1, m_strInput);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CEnterDlg, CDialog)
	//{{AFX_MSG_MAP(CEnterDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnterDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\delgrpit.h ===
// DeleteGroupItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeleteGroupItem dialog

class CDeleteGroupItem : public CDialog
{
// Construction
public:
	CDeleteGroupItem(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteGroupItem)
	enum { IDD = IDD_GROUPDELETEITEM };
	CString	m_strItemName;
	CString	m_strParent;
	CString	m_strItemType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteGroupItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteGroupItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\errordlg.cpp ===
// ErrorDialog.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "errordlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CErrorDialog dialog


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CErrorDialog::CErrorDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CErrorDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CErrorDialog)
	m_Operation = _T("");
	m_Result = _T("");
	m_Value = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CErrorDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CErrorDialog)
	DDX_Text(pDX, IDC_ERROROPERATION, m_Operation);
	DDX_Text(pDX, IDC_ERRORRESULT, m_Result);
	DDX_Text(pDX, IDC_ERRORVALUE, m_Value);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CErrorDialog, CDialog)
	//{{AFX_MSG_MAP(CErrorDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorDialog message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\enterdlg.h ===
// enterdlg.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CEnterDlg dialog

class CEnterDlg : public CDialog
{
	DECLARE_DYNAMIC(CEnterDlg)
// Construction
public:
	CEnterDlg(CWnd* pParent = NULL);    // standard constructor

// Dialog Data
	//{{AFX_DATA(CEnterDlg)
	enum { IDD = IDD_CHANGEDATA };
	CString m_strInput;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CEnterDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\delitem.h ===
// DeleteItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeleteItem dialog

class CDeleteItem : public CDialog
{
// Construction
public:
	CDeleteItem(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteItem)
	enum { IDD = IDD_DELETEITEM };
	CString	m_strClass;
	CString	m_strName;
	CString	m_strParent;
	BOOL	m_bRecursive;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\fltrdlg.h ===
// FilterDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog dialog

class CFilterDialog : public CDialog
{
// Construction
public:
	CFilterDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CFilterDialog)
	enum { IDD = IDD_FILTER };
	CListBox	m_DoNotDisplayThis;
	CListBox	m_DisplayThis;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFilterDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	void  SetDisplayFilter( BOOL* pFilters ) { m_pFilters  = pFilters ;}

   // Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFilterDialog)
	afx_msg void OnMoveToDisplay();
	afx_msg void OnMoveToNotDisplay();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
   void  DisplayThisType( DWORD, TCHAR* );
   BOOL* m_pFilters;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\errordlg.h ===
// ErrorDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CErrorDialog dialog

class CErrorDialog : public CDialog
{
// Construction
public:
	CErrorDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CErrorDialog)
	enum { IDD = IDD_ERRORPUTPROP };
	CString	m_Operation;
	CString	m_Result;
	CString	m_Value;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CErrorDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CErrorDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\fltrdlg.cpp ===
// FilterDialog.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "fltrdlg.h"
#include "testcore.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog dialog


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CFilterDialog::CFilterDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CFilterDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFilterDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CFilterDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFilterDialog)
	DDX_Control(pDX, IDC_DONOTDISPLAYTHIS, m_DoNotDisplayThis);
	DDX_Control(pDX, IDC_DISPLAYTHIS, m_DisplayThis);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFilterDialog, CDialog)
	//{{AFX_MSG_MAP(CFilterDialog)
	ON_BN_CLICKED(IDC_TODISPLAY, OnMoveToDisplay)
	ON_BN_CLICKED(IDC_TONOTDISPLAY, OnMoveToNotDisplay)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CFilterDialog::OnMoveToDisplay()
{
	// TODO: Add your control notification handler code here
   int      nIdx;
   DWORD    dwItemData;
   TCHAR    szText[ 128 ];

   nIdx        = m_DoNotDisplayThis.GetCurSel( );
   if( LB_ERR != nIdx )
   {
      dwItemData  = (DWORD)m_DoNotDisplayThis.GetItemData( nIdx );

      m_DoNotDisplayThis.DeleteString( nIdx );
      StringFromType( dwItemData, szText );

      nIdx  = m_DisplayThis.AddString( szText );
      m_DisplayThis.SetItemData( nIdx, dwItemData );

      m_pFilters[ dwItemData ]   = TRUE;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CFilterDialog::OnMoveToNotDisplay()
{
	// TODO: Add your control notification handler code here
	// TODO: Add your control notification handler code here
   int      nIdx;
   DWORD    dwItemData;
   TCHAR    szText[ 128 ];

   nIdx        = m_DisplayThis.GetCurSel( );
   if( LB_ERR != nIdx )
   {
      dwItemData  = (DWORD)m_DisplayThis.GetItemData( nIdx );

      m_DisplayThis.DeleteString( nIdx );
      StringFromType( dwItemData, szText );

      nIdx  = m_DoNotDisplayThis.AddString( szText );
      m_DoNotDisplayThis.SetItemData( nIdx, dwItemData );

      m_pFilters[ dwItemData ]   = FALSE;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CFilterDialog::DisplayThisType( DWORD dwType, TCHAR* pszText )
{
   CListBox*   pListBox;
   int         nIdx;

   if( m_pFilters[ dwType ] )
   {
      pListBox = &m_DisplayThis;
   }
   else
   {
      pListBox = &m_DoNotDisplayThis;
   }

   nIdx  = pListBox->AddString( pszText );
   pListBox->SetItemData( nIdx, dwType );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CFilterDialog::OnInitDialog()
{

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
   TCHAR szType[ 128 ];

   for( DWORD dwType = 0L ; dwType < LIMIT ; dwType++ )
   {
      if( OTHER == dwType || SCHEMA == dwType )
         continue;

      StringFromType( dwType, szType );
      DisplayThisType( dwType, szType );
   }

   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\grpcrtit.cpp ===
// GroupCreateItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "grpcrtit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupCreateItem dialog


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CGroupCreateItem::CGroupCreateItem(CWnd* pParent /*=NULL*/)
	: CDialog(CGroupCreateItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGroupCreateItem)
	m_strNewItemName = _T("");
	m_strParent = _T("");
	m_strItemType = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CGroupCreateItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupCreateItem)
	DDX_Text(pDX, IDC_ITEMNAME, m_strNewItemName);
	DDX_Text(pDX, IDC_PARENT, m_strParent);
	DDX_Text(pDX, IDC_ITEMTYPE, m_strItemType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupCreateItem, CDialog)
	//{{AFX_MSG_MAP(CGroupCreateItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGroupCreateItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\inputvw.h ===
// inputvw.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CInputView form view

class CInputView : public CFormView
{
	DECLARE_DYNCREATE(CInputView)
protected:
	CInputView();           // protected constructor used by dynamic creation

// Form Data
public:
	//{{AFX_DATA(CInputView)
	enum { IDD = IDD_INPUTFORM };
	CString m_strData;
	int     m_iColor;
	//}}AFX_DATA

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}

// Operations
public:

// Implementation
protected:
	virtual ~CInputView();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);

	// Generated message map functions
	//{{AFX_MSG(CInputView)
	afx_msg void OnDataChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\inputvw.cpp ===
// inputvw.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "viewex.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInputView

IMPLEMENT_DYNCREATE(CInputView, CFormView)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CInputView::CInputView()
	: CFormView(CInputView::IDD)
{
	//{{AFX_DATA_INIT(CInputView)
	m_strData = "";
	m_iColor = -1;
	//}}AFX_DATA_INIT
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CInputView::~CInputView()
{
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CInputView::OnUpdate(CView*, LPARAM, CObject*)
{
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CInputView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInputView)
	DDX_Text(pDX, IDC_EDIT1, m_strData);
	DDX_Radio(pDX, IDC_RADIO1, m_iColor);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CInputView, CFormView)
	//{{AFX_MSG_MAP(CInputView)
	ON_EN_CHANGE(IDC_EDIT1, OnDataChange)
	ON_BN_CLICKED(IDC_RADIO1, OnDataChange)
	ON_BN_CLICKED(IDC_RADIO2, OnDataChange)
	ON_BN_CLICKED(IDC_RADIO3, OnDataChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInputView message handlers

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CInputView::OnDataChange()
{
	/*if (!UpdateData())
		return;

	CMainDoc* pDoc = GetDocument();
	COLORREF color = RGB(255 * (m_iColor == 0),
						255 * (m_iColor == 1),
						255 * (m_iColor == 2));

	BOOL bUpdate = FALSE;
	if (m_strData != pDoc->m_strData)
	{
		pDoc->m_strData = m_strData;
		bUpdate = TRUE;
	}
	if (color != pDoc->m_colorData)
	{
		pDoc->m_colorData = color;
		bUpdate = TRUE;
	}
	if (bUpdate)
	{
		// if the document stored data then we would call SetModifiedFlag here
		pDoc->UpdateAllViews(this);
	}*/
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\maindoc.cpp ===
// maindoc.cpp : implementation of the CMainDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "schclss.h"
#include "viewex.h"
#include "enterdlg.h"
#include "fltrdlg.h"
#include "qstatus.h"
#include "newobj.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


TCHAR szOpen[ MAX_PATH ];

/////////////////////////////////////////////////////////////////////////////
// CMainDoc

IMPLEMENT_SERIAL(CMainDoc, CDocument, 0 /* schema number*/ )

BEGIN_MESSAGE_MAP(CMainDoc, CDocument)
    //{{AFX_MSG_MAP(CMainDoc)
    ON_COMMAND(IDM_CHANGEDATA, OnChangeData)
    ON_COMMAND(IDM_FILTER, OnSetFilter)
    ON_COMMAND(IDM_DISABLEFILTER, OnDisableFilter)
    ON_UPDATE_COMMAND_UI(IDM_DISABLEFILTER, OnUpdateDisablefilter)
    ON_COMMAND(IDM_USEGENERIC, OnUseGeneric)
    ON_UPDATE_COMMAND_UI(IDM_USEGENERIC, OnUpdateUseGeneric)
    ON_UPDATE_COMMAND_UI(IDM_USEGETEXPUTEX, OnUpdateUseGetExPutEx)
    ON_COMMAND(IDM_USEGETEXPUTEX, OnUseGetExPutEx)
    ON_COMMAND(IDM_USEPROPERTIESLIST, OnUsepropertiesList)
    ON_UPDATE_COMMAND_UI(IDM_USEPROPERTIESLIST, OnUpdateUsepropertiesList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainDoc construction/destruction

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
CMainDoc::CMainDoc()
{
   m_pClasses        = new CMapStringToOb;
   m_pItems          = new CMapStringToOb;
   m_bApplyFilter    = FALSE;
   m_dwRoot          = 0L;
   m_bUseGeneric     = TRUE;
   m_bUseGetEx       = TRUE;
   //m_bUseGetEx       = FALSE;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
CMainDoc::~CMainDoc()
{
   POSITION       pos;
   CObject*       pItem;
   CString        strItem;
   COleDsObject*  pRoot;

   if( NULL !=  m_pClasses )
   {
      for( pos = m_pClasses->GetStartPosition(); pos != NULL; )
       {
          m_pClasses->GetNextAssoc( pos, strItem, pItem );
         delete pItem;

         #ifdef _DEBUG
              //afxDump << strItem << "\n";
         #endif
       }

      m_pClasses->RemoveAll( );
      delete m_pClasses;
   }

   if( NULL !=  m_pItems )
   {
      for( pos = m_pItems->GetStartPosition(); pos != NULL; )
       {
          m_pItems->GetNextAssoc( pos, strItem, pItem );
         delete pItem;

         /*#ifdef _DEBUG
              afxDump << strItem << "\n";
         #endif*/
       }

      m_pItems->RemoveAll( );
      delete m_pItems;
   }

   pRoot = GetObject( &m_dwRoot );
   if( pRoot )
      delete pRoot;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::CreateFakeSchema( )
{
   CClass*     pClass;
   CProperty*  pProperty;

   pClass      = new CClass( _T("Class"), IID_IADsClass );

   pProperty   = new CProperty( _T("PrimaryInterface"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("CLSID"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("OID"), _T("String") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Abstract"), _T("Boolean") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Auxiliary"), _T("Boolean") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("MandatoryProperties"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("OptionalProperties"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("NamingProperties"), _T("String"), TRUE );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("DerivedFrom"), _T("String"), TRUE );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("AuxDerivedFrom"), _T("String"), TRUE );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("PossibleSuperiors"), _T("String"), TRUE );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Containment"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Container"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("HelpFileName"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("HelpFileContext"), _T("Integer") );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("Class"), pClass );

   // Property

   pClass      = new CClass( _T("Property"), IID_IADsProperty );

   pProperty   = new CProperty( _T("OID"), _T("String") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );
   pProperty   = new CProperty( _T("Syntax"), _T("String") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );
   pProperty   = new CProperty( _T("MaxRange"), _T("Integer") );
   pClass->AddProperty( pProperty );
   pProperty   = new CProperty( _T("MinRange"), _T("Integer") );
   pClass->AddProperty( pProperty );
   pProperty   = new CProperty( _T("MultiValued"), _T("Boolean") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("Property"), pClass );

   // Syntax

   pClass      = new CClass( _T("Syntax"), IID_IADsSyntax );
   pProperty   = new CProperty( _T("OleAutoDataType"), _T("Integer") );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("Syntax"), pClass );

   // AccessControlEntry

   pClass      = new CClass( _T("ACE"), IID_IADsAccessControlEntry );

   pProperty   = new CProperty( _T("Trustee"),     _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("AccessMask"),  _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("AceType"),     _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("AceFlags"),    _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Flags"),       _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("ObjectType"),  _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("InheritedObjectType"), _T("String") );
   pClass->AddProperty( pProperty );


   m_pClasses->SetAt( _T("ACE"), pClass );


   // SecurityDescriptor

   pClass      = new CClass( _T("SecurityDescriptor"), 
                             IID_IADsSecurityDescriptor );

   pProperty   = new CProperty( _T("Revision"), _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Control"), _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Owner"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("OwnerDefaulted"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Group"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("GroupDefaulted"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("SaclDefaulted"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("DaclDefaulted"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("SecurityDescriptor"), pClass );


   // ROOTDSE
   pClass      = new CClass( _T("ROOTDSE"), IID_IADs );

   pProperty   = new CProperty( _T("currentTime"), _T("UTCTime") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("subschemaSubentry"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("serverName"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("namingContexts"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("defaultNamingContext"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("schemaNamingContext"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("configurationNamingContext"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("rootDomainNamingContext"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("supportedControl"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("supportedVersion"), _T("Integer"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("highestCommittedUsn"), _T("Integer8") );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("ROOTDSE"), pClass );

   return TRUE;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
DWORD CMainDoc::GetToken( void* pVoid )
{
   DWORD dwToken;

   dwToken  = *(DWORD*) pVoid;

   return   dwToken;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
COleDsObject*  CMainDoc::GetObject( void* pVoid )
{
   COleDsObject*  pObject;

   pObject  = *(COleDsObject**) pVoid;

   return pObject;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void  CMainDoc::SetCurrentItem( DWORD dwToken )
{
   m_dwToken      = dwToken;

   if( NewActiveItem( ) )
   {
      UpdateAllViews( NULL );
   }
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
DWORD CMainDoc::GetChildItemList( DWORD dwToken, 
                                  DWORD* pTokens,
                                  DWORD dwMaxChildren )
{
   CQueryStatus      aQueryStatus;
   COleDsObject*     pOleDsObject   = NULL;
   DWORD             dwFilters, dwChildrenCount=0L;

   pOleDsObject   = GetObject( &dwToken );
   if( !pOleDsObject->HasChildren( ) )
   {
      return 0L;
   }

   aQueryStatus.Create( IDD_QUERYSTATUS );
   aQueryStatus.ShowWindow( SW_SHOW );
   aQueryStatus.UpdateWindow( );

   if( ! pOleDsObject->CreateTheObject( ) )
   {
      TRACE( _T("Warning: could not create the object\n") );
   }
   else
   {
      dwFilters         = m_bApplyFilter ? LIMIT : 0;
      dwChildrenCount   = pOleDsObject->GetChildren( pTokens, 
                                                     dwMaxChildren,
                                                     &aQueryStatus, 
                                                     m_arrFilters,
                                                     dwFilters );
      pOleDsObject->ReleaseIfNotTransient( );
   }
   aQueryStatus.DestroyWindow( );

   return dwChildrenCount;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL CMainDoc::OnOpenDocument( LPCTSTR lpszName )
{
   BOOL     bRez;
   TCHAR    szString[ 1024 ];

   GetPrivateProfileString( _T("Open_ADsPath"), 
                            _T("Value_1"), 
                            _T(""), 
                            szString, 
                            1023, 
                            ADSVW_INI_FILE );
   
   WritePrivateProfileString( _T("Open_ADsPath"), 
                              _T("Value_1"), 
                              lpszName, 
                              ADSVW_INI_FILE );

   bRez     = OnNewDocument( );

   WritePrivateProfileString( _T("Open_ADsPath"), 
                              _T("Value_1"), 
                              szString, 
                              ADSVW_INI_FILE );

   return bRez;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL CMainDoc::OnNewDocument()
{
   CNewObject     aNewObject;
   HRESULT        hResult;

    if (!CDocument::OnNewDocument())
        return FALSE;

   if( aNewObject.DoModal( ) != IDOK )
      return FALSE;

    m_strRoot            = aNewObject.m_strPath;
   m_strUser            = aNewObject.m_strOpenAs;
   m_strPassword        = aNewObject.m_strPassword;
   m_bUseOpenObject     = aNewObject.m_bUseOpen;
   m_bSecure            = aNewObject.m_bSecure;
   m_bEncryption        = aNewObject.m_bEncryption;
   m_bUseVBStyle        = !(aNewObject.m_bUseExtendedSyntax);
   m_bUsePropertiesList = FALSE;

   hResult     = CreateRoot( );

   if( FAILED( hResult ) )
   {
      CString  strErrorText;
      strErrorText   = OleDsGetErrorText ( hResult  );
      AfxMessageBox( strErrorText );
   }
   else
   {
      SetTitle( m_strRoot );
   }

   return SUCCEEDED( hResult );
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::NewActiveItem( )
{
   BOOL           bRez  = TRUE;
/*   TCHAR          szQName[ 128 ];
   CString        strName;
   COleDsObject*  pNewObject;

   MakeQualifiedName( szQName, m_strItemName.GetBuffer( 128 ),
                      m_dwItemType );
   strName  = szQName;
   bRez     = m_pItems->Lookup( strName, (CObject*&) pNewObject );
   ASSERT( bRez );
   m_strDisplayName  = szQName;
   if( m_pObject != NULL )
   {
      m_pObject->ReleaseIfNotTransient( );
   }
   m_pObject   = pNewObject;
   pNewObject->CreateTheObject( );*/

   return bRez;
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc serialization

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::Serialize(CArchive&)
{
    ASSERT(FALSE);      // this example program does not store data
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc commands

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnChangeData()
{
    CEnterDlg dlg;
    if (dlg.DoModal() != IDOK)
        return;
    UpdateAllViews(NULL);   // general update
}

/////////////////////////////////////////////////////////////////////////////

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnSetFilter()
{
    // TODO: Add your command handler code here
   CFilterDialog  aFilterDialog;

   aFilterDialog.SetDisplayFilter( m_arrFilters );

   aFilterDialog.DoModal( );
}

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnDisableFilter()
{
    // TODO: Add your command handler code here
   m_bApplyFilter = !m_bApplyFilter;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
COleDsObject* CMainDoc::GetCurrentObject( void )
{
   return GetObject( &m_dwToken );
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::GetUseGeneric( )   
{
   return m_bUseGeneric;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::UseVBStyle( )   
{
   return m_bUseVBStyle;
}



//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::UsePropertiesList( )   
{
   return m_bUsePropertiesList;
}


//***********************************************************
//  Function:  CMainDoc::XOleDsGetObject
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::GetUseGetEx( )   
{
   return m_bUseGetEx;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
CClass*  CMainDoc::CreateClass( COleDsObject* pObject )
{
   CClass*  pClass;
   CString  strSchema;
   CString  strClass;

   strSchema   = pObject->GetSchemaPath( );

   strClass    = pObject->GetClass( );

   if( !strClass.CompareNoCase( _T("Class") ) ||
       !strClass.CompareNoCase( _T("Property") ) ||
       !strClass.CompareNoCase( _T("Syntax") ) )
   {
      if( !strSchema.IsEmpty( ) )
      {
         TRACE(_T("[OLEDS] Error, nonempty schema path for Class, Property or Syntax objects\n" ) );
      }
      strSchema.Empty( );
   }


   if( strSchema.IsEmpty( ) )
   {
      strSchema   = strClass;
   }

   if( 0 == (pObject->GetItemName( ).CompareNoCase( _T("ROOTDSE") ) ) )
   {
      strSchema   = _T("ROOTDSE");
   }

   if( ! m_pClasses->Lookup( strSchema, ( CObject*& )pClass ) )
   {
      // we must create a new class item
      HCURSOR  oldCursor, newCursor;

      newCursor   = LoadCursor( NULL, IDC_WAIT );
      oldCursor   = SetCursor( newCursor );

      pClass   = new CClass( strSchema, this );
      ASSERT( NULL != pClass );

      if( !strClass.CompareNoCase( _T("User") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsUser") );
      }

      if( !strClass.CompareNoCase( _T("Computer") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsComputerOperations") );
      }

      if( !strClass.CompareNoCase( _T("Service") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsServiceOperations") );
      }

      if( !strClass.CompareNoCase( _T("FileService") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsFileServiceOperations") );
      }

      if( !strClass.CompareNoCase( _T("FPNWFileService") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsFileServiceOperations") );
      }

      if( !strClass.CompareNoCase( _T("PrintQueue") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsPrintQueueOperations") );
      }

      if( !strClass.CompareNoCase( _T("Queue") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsPrintQueueOperations") );
      }

      if( !strClass.CompareNoCase( _T("PrintJob") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsPrintJobOperations") );
      }

      if( !strClass.CompareNoCase( _T("Group") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("localGroup") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("GlobalGroup") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("GroupOfNames") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("GroupOfUniqueNames") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("person") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsUser") );
      }

      if( !strClass.CompareNoCase( _T("organizationalPerson") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsUser") );
      }

      if( !strClass.CompareNoCase( _T("residentialPerson") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsUser") );
      }

      m_pClasses->SetAt( strSchema, pClass );

      SetCursor( oldCursor );
   }

   return pClass;
}


//***********************************************************
//  Function:  CMainDoc::XOleDsGetObject
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
HRESULT  CMainDoc::XOleDsGetObject( WCHAR* pszwPath, REFIID refiid, 
                                    void** pVoid )
{
   // cahged to add the hack for Win95.
   HRESULT  hResult;
   WCHAR    szOpenAs[ MAX_PATH ];
   WCHAR    szPassword[ MAX_PATH ];
   LONG     lCode = 0L;

   Convert( szOpenAs, m_strUser.GetBuffer( MAX_PATH ) );
   Convert( szPassword, m_strPassword.GetBuffer( MAX_PATH ) );

   if( !m_bUseOpenObject )
   {
      hResult  = ADsGetObject( pszwPath, refiid, pVoid );
   }
   else
   {
      if( m_bSecure )
      {                          
         lCode |= ADS_SECURE_AUTHENTICATION;
      }

      if( m_bEncryption )
      {
         lCode |= ADS_USE_ENCRYPTION;
      }
       // hack fo rDavid...
       //if( L':' == pszwPath[ 3 ] )
      if( FALSE )
      {
         IADsOpenDSObject* pINamespace;
         
         hResult  = ADsGetObject( L"NDS:", 
                                  IID_IADsOpenDSObject, 
                                  (void**)&pINamespace );

         ASSERT( SUCCEEDED( hResult ) );

         if( SUCCEEDED( hResult ) )
         {
            IDispatch*  pIDisp;

            hResult  = pINamespace->OpenDSObject( pszwPath, 
                                                  _wcsicmp( szOpenAs, L"NULL") ? szOpenAs : NULL, 
                                                  _wcsicmp( szPassword, L"NULL") ? szPassword : NULL,
                                                  lCode, 
                                                  &pIDisp );
            if( SUCCEEDED( hResult ) )
            {
               hResult  = pIDisp->QueryInterface( refiid, pVoid );
               pIDisp->Release( );
            }
            
            pINamespace->Release( );
         }
      }
      else
      {
         hResult  = ADsOpenObject( pszwPath, 
                                   _wcsicmp( szOpenAs, L"NULL") ? szOpenAs : NULL, 
                                   _wcsicmp( szPassword, L"NULL") ? szPassword : NULL,
                                   lCode, 
                                   refiid, 
                                   pVoid );
      }
   }

   return hResult;
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CMainDoc::PurgeObject( IUnknown* pIUnknown, LPWSTR pszPrefix )
{
   IADs*    pObject;
   HRESULT  hResult;
   BSTR     bstrParent  = NULL;
   IADsContainer* pParent;

   while( TRUE )
   {
      hResult  = pIUnknown->QueryInterface( IID_IADs, (void**)&pObject );
      if( FAILED( hResult ) )
         break;

      hResult  = pObject->get_Parent( &bstrParent );
      pObject->Release( );

      if( NULL != bstrParent )
      {
         hResult  = XOleDsGetObject( bstrParent, IID_IADsContainer, (void**)&pParent );
         if( SUCCEEDED( hResult ) )
         {
            hResult  = ::PurgeObject( pParent, pIUnknown, pszPrefix );
            pParent->Release( );
         }
      }
      SysFreeString( bstrParent );

      break;
   }

   return hResult;
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CMainDoc::XOleDsGetObject( CHAR* pszPath, REFIID refiid, void** pVoid )
{
   int      nLength;
   WCHAR*   pszwPath;
   HRESULT  hResult;

   nLength  = strlen( pszPath );

   pszwPath = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   memset( pszwPath, 0, ( nLength + 1 ) * sizeof(WCHAR) );

   MultiByteToWideChar( CP_ACP,
                        MB_PRECOMPOSED,
                        pszPath,
                        nLength,
                        pszwPath,
                        nLength + 1 );

   hResult  = XOleDsGetObject( pszwPath, refiid, pVoid );

   free( pszwPath );

   return hResult;
}



//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
DWORD CMainDoc::CreateOleDsItem( COleDsObject* pParent, IADs* pIOleDs )
{
   COleDsObject*  pObject  = NULL;
   HRESULT        hResult;
   IUnknown*      pIUnk;
   BSTR           bstrOleDsPath  = NULL;
   BSTR           bstrClass;

   hResult  = pIOleDs->QueryInterface( IID_IUnknown, (void**)&pIUnk );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
      return 0L;

   hResult  = pIOleDs->get_Class( &bstrClass );
   hResult  = pIOleDs->get_ADsPath( &bstrOleDsPath );

   //if( FAILED( hResult ) || NULL == bstrOleDsPath );

   pObject  = CreateOleDsObject( TypeFromString( bstrClass ), pIUnk );
   pIUnk->Release( );

   pObject->SetParent( pParent );
   pObject->SetDocument( this );

   return GetToken( &pObject );
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
HRESULT  CMainDoc::CreateRoot( )
{
   IADs*        pIOleDs;
   HRESULT        hResult;
   HCURSOR        oldCursor, newCursor;
   BSTR            bstrPath;

   CreateFakeSchema( );

   newCursor   = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( newCursor );

   bstrPath    = AllocBSTR( m_strRoot.GetBuffer( 1024 ) );

   hResult     = XOleDsGetObject( bstrPath, IID_IADs, (void**) &pIOleDs );

   SysFreeString( bstrPath );
   if( SUCCEEDED( hResult ) )
   {
      m_dwToken   = CreateOleDsItem( NULL, pIOleDs );
      m_dwRoot    = m_dwToken;
      pIOleDs->Release( );
   }
   SetCursor( oldCursor );

   return hResult;
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void  CMainDoc::DeleteAllItems( )
{
   COleDsObject*  pObject;
   POSITION       pos;
   CString        strItem;
   CObject*       pItem;

   if( NULL !=  m_pClasses )
   {
      for( pos = m_pClasses->GetStartPosition(); pos != NULL; )
       {
          m_pClasses->GetNextAssoc( pos, strItem, pItem );
         delete pItem;

         #ifdef _DEBUG
              //afxDump << strItem << "\n";
         #endif
       }

      m_pClasses->RemoveAll( );
   }

   pObject  = GetObject( &m_dwRoot );

   delete pObject;

   CreateRoot( );
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUpdateDisablefilter(CCmdUI* pCmdUI)
{
    // TODO: Add your command update UI handler code here
    
   pCmdUI->SetCheck( !m_bApplyFilter );
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUseGeneric()
{
    // TODO: Add your command handler code here
    m_bUseGeneric = !m_bUseGeneric;
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUpdateUseGeneric(CCmdUI* pCmdUI)
{
    // TODO: Add your command update UI handler code here
   pCmdUI->SetCheck( m_bUseGeneric );   
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUpdateUseGetExPutEx(CCmdUI* pCmdUI) 
{
    // TODO: Add your command update UI handler code here
   pCmdUI->SetCheck( m_bUseGetEx ); 
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUseGetExPutEx() 
{
    // TODO: Add your command handler code here
   m_bUseGetEx = !m_bUseGetEx;
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUsepropertiesList() 
{
    // TODO: Add your command handler code here
   m_bUsePropertiesList = !m_bUsePropertiesList;
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUpdateUsepropertiesList(CCmdUI* pCmdUI) 
{
    // TODO: Add your command update UI handler code here
   pCmdUI->SetCheck( m_bUsePropertiesList );    
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::SetUseGeneric( BOOL bUseGeneric )
{
   m_bUseGeneric  = bUseGeneric;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\grpcrtit.h ===
// GroupCreateItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGroupCreateItem dialog

class CGroupCreateItem : public CDialog
{
// Construction
public:
	CGroupCreateItem(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGroupCreateItem)
	enum { IDD = IDD_GROUPCREATEITEM };
	CString	m_strNewItemName;
	CString	m_strParent;
	CString	m_strItemType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGroupCreateItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGroupCreateItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\maindoc.h ===
// maindoc.h : interface of the CMainDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "schclss.h"

class CQueryStatus;

class CMainDoc : public CDocument
{
protected: // create from serialization only
	CMainDoc();
	DECLARE_SERIAL(CMainDoc)

// Attributes
public:
	// an example of document specific data

// Implementation
public:
	virtual ~CMainDoc();

	virtual void   Serialize(CArchive& ar);   // overridden for document i/o

   void           SetUseGeneric( BOOL );
   void           SetCurrentItem    ( DWORD dwToken );
   void           DeleteAllItems    ( void          );
   
   DWORD          GetToken          ( void* );
   COleDsObject*  GetObject         ( void* );

   DWORD          GetChildItemList  ( DWORD dwToken, DWORD* pTokens, DWORD dwBufferSize );
   COleDsObject*  GetCurrentObject  ( void                  );
   CClass*        CreateClass       ( COleDsObject*         );
   DWORD          CreateOleDsItem   ( COleDsObject* pParent, IADs* pIOleDs );
   BOOL           GetUseGeneric     ( void );
   BOOL           GetUseGetEx       ( void );
   HRESULT        XOleDsGetObject   ( WCHAR*, REFIID, void**);
   HRESULT        XOleDsGetObject   ( CHAR*,  REFIID, void**);
   HRESULT        PurgeObject       ( IUnknown* pIUnknown, LPWSTR pszPrefix = NULL );
   BOOL           UseVBStyle        ( void );
   BOOL           UsePropertiesList ( void );


protected:
	virtual  BOOL    OnNewDocument( );
   virtual  BOOL    OnOpenDocument( LPCTSTR  );

   BOOL     NewActiveItem        ( );
   HRESULT  CreateRoot           ( );
   BOOL     CreateFakeSchema     ( );

protected:
   DWORD             m_dwToken;
   DWORD             m_dwRoot;
   
   CMapStringToOb*   m_pClasses;
   CMapStringToOb*   m_pItems;
   
   BOOL              m_bApplyFilter;
   BOOL              m_arrFilters[ LIMIT ];
   
   BOOL              m_bUseGeneric;
   BOOL              m_bUseGetEx;
   BOOL              m_bUseVBStyle;

   BOOL              m_bUseOpenObject;
   BOOL              m_bSecure;
   BOOL              m_bEncryption;
   BOOL              m_bUsePropertiesList;
   CString           m_strRoot;
   CString           m_strUser;
   CString           m_strPassword;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainDoc)
	afx_msg void OnChangeData();
	afx_msg void OnSetFilter();
	afx_msg void OnDisableFilter();
	afx_msg void OnUpdateDisablefilter(CCmdUI* pCmdUI);
	afx_msg void OnUseGeneric();
	afx_msg void OnUpdateUseGeneric(CCmdUI* pCmdUI);
	afx_msg void OnUpdateUseGetExPutEx(CCmdUI* pCmdUI);
	afx_msg void OnUseGetExPutEx();
	afx_msg void OnUsepropertiesList();
	afx_msg void OnUpdateUsepropertiesList(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\moveitem.h ===
// MoveItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMoveItem dialog

class CMoveItem : public CDialog
{
// Construction
public:
	CMoveItem(CWnd* pParent = NULL);   // standard constructor

public:
   void  SetContainerName( CString );

// Dialog Data
	//{{AFX_DATA(CMoveItem)
	enum { IDD = IDD_MOVEITEM };
	CString	m_strDestination;
	CString	m_strParent;
	CString	m_strSource;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoveItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMoveItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\moveitem.cpp ===
// MoveItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "MoveItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoveItem dialog

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CMoveItem::CMoveItem(CWnd* pParent /*=NULL*/)
	: CDialog(CMoveItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMoveItem)
	m_strDestination = _T("");
	m_strParent = _T("");
	m_strSource = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    CMoveItem::SetParentName
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CMoveItem::SetContainerName( CString strParent )
{
   m_strParent = strParent;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CMoveItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMoveItem)
	DDX_Text(pDX, IDC_DESTINATION, m_strDestination);
	DDX_Text(pDX, IDC_PARENT, m_strParent);
	DDX_Text(pDX, IDC_SOURCE, m_strSource);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMoveItem, CDialog)
	//{{AFX_MSG_MAP(CMoveItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMoveItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\newquery.cpp ===
// NewQuery.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "newquery.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewQuery dialog

#define  ENTRIES_HISTORY 15

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CNewQuery::CNewQuery(CWnd* pParent /*=NULL*/)
	: CDialog(CNewQuery::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewQuery)
	m_strPassword = _T("");
	m_bEncryptPassword = FALSE;
	m_bUseSQL = FALSE;
	m_strScope = _T("");
	m_strAttributes = _T("");
	m_strQuery = _T("");
	m_strSource = _T("");
	m_strUser = _T("");
	m_bUseSearch = FALSE;
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CNewQuery::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewQuery)
	DDX_Text(pDX, IDC_PASSWORD, m_strPassword);
	DDX_Check(pDX, IDC_ENCRYPT, m_bEncryptPassword);
	DDX_Check(pDX, IDC_USESQL, m_bUseSQL);
	DDX_CBString(pDX, IDC_SCOPE, m_strScope);
	DDX_Check(pDX, IDC_USESEARCH, m_bUseSearch);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewQuery, CDialog)
	//{{AFX_MSG_MAP(CNewQuery)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewQuery message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CNewQuery::OnInitDialog()
{
	CString  strLastValue;

  // GetLastProfileString( _T("LastADsQueryPassword"), m_strPassword );
   m_strPassword = _T("");
   SetLastProfileString( _T("LastADsQueryPassword"), m_strPassword);

   GetLastProfileString( _T("LastADsQueryEncryptPassword"), strLastValue );

   m_bEncryptPassword   = strLastValue.CompareNoCase( _T("No") );

   GetLastProfileString( _T("LastADsQueryUseSQL"), strLastValue );
   m_bUseSQL            = !( strLastValue.CompareNoCase( _T("Yes") ) );

   GetLastProfileString( _T("LastADsQueryUseDsSearch"), strLastValue );
   m_bUseSearch         = !( strLastValue.CompareNoCase( _T("Yes") ) );

   GetLRUList( IDC_ATTRIBUTES,  _T("Query_Attributes") );
   GetLRUList( IDC_QUERY,       _T("Query_Query")      );
   GetLRUList( IDC_SOURCE,      _T("Query_Source")     );
   GetLRUList( IDC_USER,        _T("Query_OpenAs")     );

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CNewQuery::OnOK()
{
	// TODO: Add extra validation here
   CString  strVal;
	
	CDialog::OnOK();

   GetDlgItemText( IDC_ATTRIBUTES,  m_strAttributes );
   GetDlgItemText( IDC_QUERY,       m_strQuery  );
   GetDlgItemText( IDC_SOURCE,      m_strSource );
   GetDlgItemText( IDC_PASSWORD,    m_strPassword );
   GetDlgItemText( IDC_USER,        m_strUser );
   GetDlgItemText( IDC_SCOPE,       m_strScope );

   m_bEncryptPassword   =  ( (CButton*)GetDlgItem( IDC_ENCRYPT ) )->GetCheck( );
   m_bUseSQL            =  ( (CButton*)GetDlgItem( IDC_USESQL ) )->GetCheck( );
   m_bUseSearch         =  ( (CButton*)GetDlgItem( IDC_USESEARCH ) )->GetCheck( );


//   SetLastProfileString( _T("LastADsQueryPassword"), m_strPassword );

   strVal   = m_bEncryptPassword ? _T("Yes") : _T("No");
   SetLastProfileString( _T("LastADsQueryEncryptPassword"), strVal );

   strVal   = m_bUseSQL ? _T("Yes") : _T("No");
   SetLastProfileString( _T("LastADsQueryUseSQL"), strVal );

   strVal   = m_bUseSearch ? _T("Yes") : _T("No");
   SetLastProfileString( _T("LastADsQueryUseDsSearch"), strVal );

   SaveLRUList( IDC_ATTRIBUTES,  _T("Query_Attributes"), 100 );
   SaveLRUList( IDC_QUERY,       _T("Query_Query"),      100 );
   SaveLRUList( IDC_SOURCE,      _T("Query_Source"),     100 );
   SaveLRUList( IDC_USER,        _T("Query_OpenAs"),     100 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CNewQuery::SaveLRUList( int idCBox, TCHAR* pszSection, int nMax )
{
   CComboBox*  pCombo;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   CString     strText, strItem;
   int         nVal, nIdx, nItems;

   pCombo   = (CComboBox*)GetDlgItem( idCBox );
   pCombo->GetWindowText( strText );

   _tcscpy( szEntry, _T("Value_1") );

   if( strText.GetLength( ) )
   {
      WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strText, ADSVW_INI_FILE );
   }

   nItems   = pCombo->GetCount( );
   nVal     = 2;

   for( nIdx = 0; nItems != CB_ERR && nIdx < nItems && nIdx < nMax ; nIdx ++ )
   {
      pCombo->GetLBText( nIdx, strItem );

      if( strItem.CompareNoCase( strText ) )
      {
         _itot( nVal++, szIndex, 10 );
         _tcscpy( szEntry, _T("Value_") );
         _tcscat( szEntry, szIndex );
         WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strItem, ADSVW_INI_FILE );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CNewQuery::GetLRUList( int idCBox, TCHAR* pszSection )
{
   CComboBox*  pCombo;
   int         nIter;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   TCHAR       szValue[ 1024 ];

   pCombo   = (CComboBox*)GetDlgItem( idCBox );

   for( nIter = 0; nIter < ENTRIES_HISTORY ; nIter++ )
   {
      _itot( nIter + 1, szIndex, 10 );
      _tcscpy( szEntry, _T("Value_") );
      _tcscat( szEntry, szIndex );
      GetPrivateProfileString( pszSection, szEntry,
                               _T(""), szValue, 1023, ADSVW_INI_FILE );
      if( _tcslen( szValue ) )
      {
         pCombo->AddString( szValue );
      }
   }

   pCombo->SetCurSel( 0 );
}
/////////////////////////////////////////////////////////////////////////////
// CSearchPreferencesDlg dialog


CSearchPreferencesDlg::CSearchPreferencesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSearchPreferencesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSearchPreferencesDlg)
	m_strAsynchronous = _T("");
	m_strAttributesOnly = _T("");
	m_strDerefAliases = _T("");
	m_strPageSize = _T("");
	m_strScope = _T("");
	m_strSizeLimit = _T("");
	m_strTimeLimit = _T("");
	m_strTimeOut = _T("");
   m_strChaseReferrals = _T("");
	//}}AFX_DATA_INIT
}


void CSearchPreferencesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchPreferencesDlg)
	DDX_Text(pDX, IDC_ASYNCHRONOUS, m_strAsynchronous);
	DDX_Text(pDX, IDC_ATTR_ONLY, m_strAttributesOnly);
	DDX_Text(pDX, IDC_DEREF_ALIASES, m_strDerefAliases);
	DDX_Text(pDX, IDC_PAGE_SIZE, m_strPageSize);
	DDX_Text(pDX, IDC_SCOPE, m_strScope);
	DDX_Text(pDX, IDC_SIZE_LIMIT, m_strSizeLimit);
	DDX_Text(pDX, IDC_TIME_LIMIT, m_strTimeLimit);
	DDX_Text(pDX, IDC_TIME_OUT, m_strTimeOut);
   DDX_Text(pDX, IDC_CHASE_REFERRALS, m_strChaseReferrals);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSearchPreferencesDlg, CDialog)
	//{{AFX_MSG_MAP(CSearchPreferencesDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchPreferencesDlg message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CSearchPreferencesDlg::OnInitDialog()
{
   GetLastProfileString( _T("SearchPref_Asynchronous"),  m_strAsynchronous );
   GetLastProfileString( _T("SearchPref_AttributesOnly"),m_strAttributesOnly );
   GetLastProfileString( _T("SearchPref_DerefAliases"),  m_strDerefAliases );
   GetLastProfileString( _T("SearchPref_PageSize"),      m_strPageSize );
   GetLastProfileString( _T("SearchPref_Scope"),         m_strScope );
   GetLastProfileString( _T("SearchPref_SizeLimit"),     m_strSizeLimit );
   GetLastProfileString( _T("SearchPref_TimeLimit"),     m_strTimeLimit );
   GetLastProfileString( _T("SearchPref_TimeOut"),       m_strTimeOut );
   GetLastProfileString( _T("SearchPref_ChaseReferrals"),m_strChaseReferrals );

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSearchPreferencesDlg::OnOK()
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();

   SetLastProfileString( _T("SearchPref_Asynchronous"),  m_strAsynchronous );
   SetLastProfileString( _T("SearchPref_AttributesOnly"),m_strAttributesOnly );
   SetLastProfileString( _T("SearchPref_DerefAliases"),  m_strDerefAliases );
   SetLastProfileString( _T("SearchPref_PageSize"),      m_strPageSize );
   SetLastProfileString( _T("SearchPref_Scope"),         m_strScope );
   SetLastProfileString( _T("SearchPref_SizeLimit"),     m_strSizeLimit );
   SetLastProfileString( _T("SearchPref_TimeLimit"),     m_strTimeLimit );
   SetLastProfileString( _T("SearchPref_TimeOut"),       m_strTimeOut );
   SetLastProfileString( _T("SearchPref_ChaseReferrals"),m_strChaseReferrals );
}
/////////////////////////////////////////////////////////////////////////////
// CACEDialog dialog


CACEDialog::CACEDialog(CWnd* pParent )
	: CDialog(CACEDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CACEDialog)
	m_strTrustee = _T("");
	//}}AFX_DATA_INIT
}


void CACEDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CACEDialog)
	DDX_Text(pDX, IDC_TRUSTEE, m_strTrustee);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CACEDialog, CDialog)
	//{{AFX_MSG_MAP(CACEDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\newobj.h ===
// NewObject.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewObject dialog

class CNewObject : public CDialog
{
// Construction
public:
	CNewObject(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewObject)
	enum { IDD = IDD_OLEDSPATH };
	CButton	m_UseExtendedSyntax;
	CComboBox	m_OpenAs;
	CComboBox	m_OleDsPath;
	CButton	m_Secure;
	CButton	m_Encryption;
	CButton	m_UseOpen;
	CEdit	   m_Password;
	//}}AFX_DATA

public:
   CString& GetObjectPath( );
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewObject)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewObject)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
   void  SaveLRUList( int idCBox, TCHAR* szSection, int nMax = 100 );
   void  GetLRUList( int idCBox, TCHAR* szSection );

public:
   CString  m_strPath;
   CString  m_strOpenAs;
   CString  m_strPassword;
   BOOL     m_bUseOpen;
   BOOL     m_bSecure;
   BOOL     m_bEncryption;
   BOOL     m_bUseExtendedSyntax;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\objects.h ===
#ifndef  _OBJECTS_H_
#define  _OBJECTS_H_

#include "schclss.h" 

#define  MEMBERS  IADsMembers

class CMainDoc;

class CClass;

class CDeleteStatus;

class COleDsObject: public CObject
{

public:   
   COleDsObject( IUnknown* );
   COleDsObject( );
   ~COleDsObject( );

public:
   BOOL              HasChildren          (           );
   CString           GetClass             (           );
   DWORD             GetType              (           );
   CString           GetOleDsPath         (           );
   CString           GetItemName          (           );
   CString*          PtrGetItemName       (           );
   CString           GetSchemaPath        (           );
   HRESULT           SetInfo              ( void      );
   HRESULT           GetInfo              ( void      );

   HRESULT           SetInfoVB            ( void      );
   HRESULT           GetInfoVB            ( void      );

   HRESULT           SetInfoCPP           ( void      );
   HRESULT           GetInfoCPP           ( void      );

   virtual  HRESULT  PutProperty          ( int, CString&, long Code = ADS_PROPERTY_UPDATE );
   virtual  HRESULT  PutProperty          ( CString&, CString& );

   virtual  HRESULT  GetProperty          ( int, CString&, BOOL* pbIsDescriptor = NULL );
   virtual  HRESULT  GetProperty          ( CString&, CString& );


   HRESULT        PutProperty             ( CString& strName, CString& strVal, BOOL bMultiValued, ADSTYPE eType );
   HRESULT        GetProperty             ( CString& strName, CString& strVal, BOOL bMultiValued, ADSTYPE eType );

   HRESULT        PutPropertyVB           ( int, CString&, long Code = ADS_PROPERTY_UPDATE );
   HRESULT        PutPropertyVB           ( CString&, CString& );
   HRESULT        GetPropertyVB           ( int, CString&, BOOL* pbIsDescriptor = NULL );
   HRESULT        GetPropertyVB           ( CString&, CString& );

   
   HRESULT        PutPropertyCPP          ( int, CString&, long Code = ADS_PROPERTY_UPDATE );
   HRESULT        PutPropertyCPP          ( CString&, CString& );                       
   HRESULT        GetPropertyCPP          ( int, CString&, BOOL* pbIsDescriptor = NULL );
   HRESULT        GetPropertyCPP          ( CString&, CString& );                       



   virtual        void   SetDocument          ( CMainDoc* );
   
   BOOL              CreateTheObject      (           );
   BOOL              HasMandatoryProperties( );
   void              UseSchemaInformation ( BOOL      );
   COleDsObject*     GetParent            ( );
   void              SetParent            ( COleDsObject* );

   virtual  BOOL     AddItemSuported      ( );
   virtual  BOOL     DeleteItemSuported   ( );
   virtual  BOOL     MoveItemSupported    ( );
   virtual  BOOL     CopyItemSupported    ( );
   virtual  HRESULT  AddItem              ( );
   virtual  HRESULT  DeleteItem           ( );
   virtual  HRESULT  DeleteItem           ( COleDsObject* );

   virtual  HRESULT  MoveItem             ( );
   virtual  HRESULT  CopyItem             ( );
   virtual  CString  GetDeleteName        ( );

   virtual  DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                                  CDialog*   pQueryStatus,
                                  BOOL*      pFilters, DWORD dwFilters );


   HRESULT  CallMethod     ( int nMethod         );
   //HRESULT  CallMethod     ( CString& strFuncSet, int nMethod  );

   virtual  DWORD    GetChildren( IADsContainer*             );
   virtual  DWORD    GetChildren( IADsCollection*            );
   virtual  DWORD    GetChildren( MEMBERS*          );

   virtual  HRESULT  ReleaseIfNotTransient( void               );

   void     AddNamesFromEnum     ( IUnknown*     pIEnum         );

   HRESULT  ContainerAddItem     ( void            );
   HRESULT  ContainerDeleteItem  ( COleDsObject*   );
   HRESULT  ContainerMoveItem    ( void            );
   HRESULT  ContainerCopyItem    (                 );

   virtual  HRESULT  GetInterface        ( IUnknown** );

   /*****************************************/
   virtual  int         GetPropertyCount           (  );
   virtual  CString     VarToDisplayString         ( int, VARIANT&, BOOL );
   virtual  BOOL        DisplayStringToDispParams  ( int, CString&, DISPPARAMS&, BOOL );

   virtual  BOOL        SupportContainer( void );

   virtual  CString  GetAttribute( CLASSATTR ); 
   virtual  HRESULT  PutAttribute( CLASSATTR, CString& ); 

   virtual  CString  GetAttribute( int, PROPATTR ); 
   virtual  HRESULT  PutAttribute( int, PROPATTR, CString& ); 

   virtual  CString  GetAttribute( int, METHODATTR ); 
   virtual  HRESULT  PutAttribute( int, METHODATTR, CString& ); 

protected:
   HRESULT        GetIDispatchForFuncSet( int, IDispatch** ); 

   HRESULT        CopyAttributeValue   ( ADS_ATTR_INFO* , int nAttribute = -1 );
   HRESULT        CreateAttributeValue ( ADS_ATTR_INFO* , int nAttribute = -1 );
   void           CreateClassInfo      ( void );
   HRESULT        GetDirtyAttributes   ( PADS_ATTR_INFO* ppAttrDef, DWORD* pdwCount );
   void           FreeDirtyAttributes  ( PADS_ATTR_INFO pAttrDef, DWORD dwCount );
   HRESULT        CreatePropertiesList ( );
   HRESULT        ClearPropertiesList  ( );
   HRESULT        GetPropertyFromList  ( int nProp, CString& strPropValue );
   BOOL           IsClassObject        ( );
   BOOL           IsSecurityDescriptor ( VARIANT& rValue, BOOL bUseGetEx );
   HRESULT        PurgeObject          ( IADsContainer* pParent, 
                                         IUnknown* pIUnknown, 
                                         LPWSTR pszPrefix = NULL );

protected:
   IUnknown*      m_pIUnk;
   CString        m_strOleDsPath;
   CString        m_strClassName;
   CString        m_strItemName;
   CString        m_strSchemaPath;
   DWORD          m_dwType;
   BOOL           m_bHasChildren;
   BOOL           m_bUseSchemaInformation;
   BOOL           m_bSupportAdd;
   BOOL           m_bSupportDelete;
   BOOL           m_bSupportMove;
   BOOL           m_bSupportCopy;

   // members for enumerating children
   DWORD*         m_pTokens;
   DWORD          m_dwMaxCount;
   DWORD          m_dwCount;
   DWORD          m_dwFilters;
   BOOL*          m_pFilters;
   CDialog*       m_pQueryStatus;
   BOOL           m_bAbort;
   CClass*        m_pClass;
   COleDsObject*  m_pParent;
   CMainDoc*      m_pDoc;
   CDWordArray*   m_pChildren;
   CDeleteStatus* m_pDeleteStatus;

   // operations information;
   int            m_nOperationsCount;
   CStringArray*  m_pOperationNames;
   REFIID         m_refOperations;

   // extended syntax values
   CString*       m_pCachedValues;
   BOOL*          m_pfReadValues;
   BOOL*          m_pfDirty;
   DWORD*         m_pdwUpdateType;

   // IPropertyList stuff
   int            m_nPropertiesCount;
   IUnknown**     m_ppPropertiesEntries;
};

#include "cdomain.h"
#include "cgeneric.h"
#include "ccomp.h"
#include "cuser.h"
#include "cgroup.h"
#include "cservice.h"
#include "cfserv.h"
#include "cpqueue.h"
#include "cpjob.h"
#include "cpdevice.h"
#include "cfshare.h"
#include "csession.h"
#include "cresourc.h"
#include "cnmsp.h"
#include "cnmsps.h"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\newquery.h ===
// NewQuery.h : header file
//
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CNewQuery dialog

class CNewQuery : public CDialog
{
// Construction
public:
	CNewQuery(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewQuery)
	enum { IDD = IDD_NEWQUERY };
   CString	m_strPassword;
	BOOL	m_bEncryptPassword;
	BOOL	m_bUseSQL;
	CString	m_strScope;
	BOOL	m_bUseSearch;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

   private:

   void  SaveLRUList( int idCBox, TCHAR* szSection, int nMax = 100 );
   void  GetLRUList( int idCBox, TCHAR* szSection );

   
public:
   
   CString	m_strAttributes;
	CString	m_strQuery;
	CString	m_strSource;
	CString	m_strUser;


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewQuery)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CSearchPreferencesDlg dialog

class CSearchPreferencesDlg : public CDialog
{
// Construction
public:
	CSearchPreferencesDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSearchPreferencesDlg)
	enum { IDD = IDD_SEARCHPREFERENCES };
	CString	m_strAsynchronous;
	CString	m_strAttributesOnly;
	CString	m_strDerefAliases;
	CString	m_strPageSize;
	CString	m_strScope;
	CString	m_strSizeLimit;
	CString	m_strTimeLimit;
	CString	m_strTimeOut;
   CString	m_strChaseReferrals;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchPreferencesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSearchPreferencesDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CACEDialog dialog

class CACEDialog : public CDialog
{
// Construction
public:
	CACEDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CACEDialog)
	enum { IDD = IDD_ADDACEDLG };
	CString	m_strTrustee;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CACEDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CACEDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\objprops.cpp ===
// ObjectProps.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "objprops.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CObjectProps

IMPLEMENT_DYNCREATE(CObjectProps, CFormView)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CObjectProps::CObjectProps()
	: CFormView(CObjectProps::IDD)
{
	//{{AFX_DATA_INIT(CObjectProps)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CObjectProps::~CObjectProps()
{
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CObjectProps::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CObjectProps)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CObjectProps, CFormView)
	//{{AFX_MSG_MAP(CObjectProps)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CObjectProps diagnostics

#ifdef _DEBUG
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CObjectProps::AssertValid() const
{
	CFormView::AssertValid();
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CObjectProps::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CObjectProps message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\objects.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "qstatus.h"
#include "createit.h"
#include "copyitem.h"
#include "moveitem.h"
#include "delitem.h"
#include "maindoc.h"
#include "objects.h"
#include "cacls.h"
#include "schemavw.h"
#include "csyntax.h"
#include "qstatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define  NEXT_COUNT  1

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject::COleDsObject( ):m_refOperations(IID_IUnknown)
{
   m_pIUnk                 = NULL;
   m_bUseSchemaInformation = TRUE;
   m_pClass                = NULL;
   m_pParent               = NULL;
   m_bSupportAdd           = FALSE;
   m_bSupportDelete        = TRUE;
   m_bSupportMove          = FALSE;
   m_bSupportCopy          = FALSE;
   m_dwCount               = 0L;
   m_pfReadValues          = NULL;
   m_pCachedValues         = NULL;
   m_pdwUpdateType         = NULL;
   m_pfDirty               = NULL;
   m_nPropertiesCount      = 0;
   m_ppPropertiesEntries   = NULL;
   m_pChildren             = NULL;
   m_pDeleteStatus         = NULL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::SetDocument( CMainDoc* pMainDoc )
{
   m_pDoc   = pMainDoc;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject::COleDsObject( IUnknown*  pIUnk ):m_refOperations(IID_IUnknown)
{
   IADs*    pIOleDs  = NULL;
   BSTR     bstrClass   = NULL;
   BSTR     bstrOleDsPath  = NULL;
   BSTR     bstrName    = NULL;
   BSTR     bstrSchemaPath = NULL;
   HRESULT  hResult;


   m_nPropertiesCount      = 0;
   m_ppPropertiesEntries   = NULL;
   m_pDoc                  = NULL;
   m_pChildren             = new CDWordArray;
   m_bUseSchemaInformation = TRUE;

   m_pIUnk                 = pIUnk;
   m_pIUnk->AddRef( );

   m_pClass                = NULL;
   m_pParent               = NULL;
   m_bSupportAdd           = FALSE;
   m_bSupportDelete        = TRUE;
   m_bSupportMove          = FALSE;
   m_bSupportCopy          = FALSE;
   m_dwType                = (DWORD)-1L;
   m_pfReadValues          = NULL;
   m_pCachedValues         = NULL;
   m_pfDirty               = NULL;
   m_pdwUpdateType         = NULL;


   hResult  = pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );

   {
      IADsContainer*  pIContainer;

      if( SUCCEEDED( pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer ) ) )
      {
         pIContainer->Release( );
         m_bSupportMove          = TRUE;
         m_bSupportCopy          = TRUE;
      }
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ))
   {
      pIOleDs->get_Class      ( &bstrClass      );
      CheckIfValidClassName   ( bstrClass );
      pIOleDs->get_ADsPath  ( &bstrOleDsPath  );
      pIOleDs->get_Name       ( &bstrName       );

      m_strClassName = bstrClass;
      m_strItemName  = bstrName;
      m_strOleDsPath = bstrOleDsPath;

      m_dwType       = TypeFromString( bstrClass );
      ASSERT( m_dwType != -1L );
      SysFreeString( bstrClass );
      SysFreeString( bstrOleDsPath );
      SysFreeString( bstrName );

      hResult           = pIOleDs->get_Schema( &bstrSchemaPath );
      if( SUCCEEDED( hResult ) )
      {
         m_strSchemaPath   = bstrSchemaPath;
         SysFreeString( bstrSchemaPath );
      }

      pIOleDs->Release( );
   }
   m_pDeleteStatus         = NULL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject*  COleDsObject::GetParent( )
{
   return m_pParent;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::SetParent( COleDsObject* pParent )
{
   m_pParent   = pParent;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     COleDsObject::AddItemSuported( )
{
   return   m_bSupportAdd;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::DeleteItemSuported( )
{
   return   m_bSupportDelete;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::MoveItemSupported( )
{
   return   m_bSupportMove;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::CopyItemSupported( )
{
   return   m_bSupportCopy;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::AddItem( )
{
   return E_FAIL;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::DeleteItem( )
{
   HRESULT  hResult;

   if( NULL == m_pParent )
   {
      return E_FAIL;
   }

   m_pParent->CreateTheObject( );
   hResult  = m_pParent->DeleteItem( this );
   m_pParent->ReleaseIfNotTransient( );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::DeleteItem( COleDsObject* )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::MoveItem( )
{
   CMoveItem         aMoveItem;
   BSTR              bstrSource;
   BSTR              bstrNewName;
   HRESULT           hResult  = E_FAIL;
   IADsContainer*  pIContainer;
   IDispatch*         pIUnk;
   ULONG             ulRef;

   aMoveItem.SetContainerName( m_strOleDsPath );
   if( IDOK == aMoveItem.DoModal( ) )
   {
      bstrSource        = AllocBSTR( aMoveItem.m_strSource.GetBuffer( 512 ) );
      bstrNewName       = AllocBSTR( aMoveItem.m_strDestination.GetBuffer( 512 ) );
      hResult           = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pIContainer->MoveHere( bstrSource, bstrNewName, &pIUnk );
         ulRef    = pIUnk->Release( );
         ASSERT( !ulRef );
         pIContainer->Release( );
      }
      SysFreeString( bstrSource );
      SysFreeString( bstrNewName );
   }

   return hResult;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CopyItem( )
{
   CCopyItem         aCopyItem;
   BSTR              bstrSource;
   BSTR              bstrNewName;
   HRESULT           hResult  = E_FAIL;;
   IADsContainer*  pIContainer;
   IDispatch*         pIUnk;
   ULONG             ulRef;

   aCopyItem.SetContainerName( m_strOleDsPath );
   if( IDOK == aCopyItem.DoModal( ) )
   {
      bstrSource        = AllocBSTR( aCopyItem.m_strSource.GetBuffer( 512 ) );
      bstrNewName       = AllocBSTR( aCopyItem.m_strDestination.GetBuffer( 512 ) );
      hResult           = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pIContainer->CopyHere( bstrSource, bstrNewName, &pIUnk );
         ulRef    = pIUnk->Release( );
         ASSERT( !ulRef );
         pIContainer->Release( );
      }
      SysFreeString( bstrSource );
      SysFreeString( bstrNewName );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ContainerAddItem( void )
{
   CCreateItem       aCreateItem;
   BSTR              bstrClass;
   BSTR              bstrRelativeName;
   IADsContainer*    pIContainer;
   HRESULT           hResult;
   IDispatch*        pNewItem;
   IADs*             pNewIOleDs;
   CString           strQualifiedName;

   // build the name for diplay purposes
   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aCreateItem.m_strParent = strQualifiedName;
   if( aCreateItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   // get object name and class
   bstrClass         = AllocBSTR( aCreateItem.m_strClass.GetBuffer(128) );
   bstrRelativeName  = AllocBSTR( aCreateItem.m_strRelativeName.GetBuffer(128) );

   // good point, check if the parent object implements the IADsContainer interface
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return hResult;
   }

   // make the call for create
   hResult  = pIContainer->Create( bstrClass, bstrRelativeName, &pNewItem );

   if( SUCCEEDED( hResult ) )
   {
      // ask the user for values on mandatory attributes
      COleDsObject*           pOleDsObject;
      CClass*                 pClass;

      pOleDsObject   = new COleDsObject( pNewItem );
      pClass         = m_pDoc->CreateClass( pOleDsObject );

      pOleDsObject->SetDocument( m_pDoc );

      if( pClass->HasMandatoryProperties( ) )
      {
         CSetMandatoryProperties aSetMandatoryProperties;

         aSetMandatoryProperties.SetOleDsObject( pOleDsObject );
         aSetMandatoryProperties.DoModal( );
      }

      HCURSOR  oldSursor, newCursor;

      newCursor   = LoadCursor( NULL, IDC_WAIT );
      oldSursor   = SetCursor( newCursor );

      if( IsClassObject( ) || m_pDoc->UseVBStyle( ) )
      {
         hResult  = pNewItem->QueryInterface( IID_IADs, (void**) &pNewIOleDs );
         ASSERT( SUCCEEDED( hResult ) );
         hResult  = pNewIOleDs->SetInfo( );
         pNewIOleDs->Release( );
      }
      else
      {
         DWORD          dwDirty  = 0L;
         ADS_ATTR_INFO* pAttrDef;
         IDirectoryObject*     pIADsObject;

         hResult  = pOleDsObject->GetDirtyAttributes( &pAttrDef, &dwDirty );

         if( SUCCEEDED( hResult ) )
         {
            hResult  = m_pIUnk->QueryInterface( IID_IDirectoryObject,
                                                (void**)&pIADsObject );

            ASSERT( SUCCEEDED( hResult ) );

            if( SUCCEEDED( hResult ) )
            {
               hResult  = pIADsObject->CreateDSObject( bstrRelativeName,
                                                       pAttrDef,
                                                       dwDirty,
                                                       NULL );
               pIADsObject->Release( );
            }
         }
      }

      SetCursor( oldSursor );
      pNewItem->Release( );

      delete   pOleDsObject;
   }

   SysFreeString( bstrClass );
   SysFreeString( bstrRelativeName );

   pIContainer->Release( );

   return hResult;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ContainerDeleteItem  ( COleDsObject* pObject )
{
   CDeleteItem       aDeleteItem;
   BSTR              bstrClass;
   BSTR              bstrName;
   IADsContainer*    pIContainer;
   IDirectoryObject*        pDSObject;
   HRESULT           hResult;
   CString           strQualifiedName;
   BOOL              bRecursive  = FALSE;

   ASSERT( NULL != pObject );

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aDeleteItem.m_strParent = strQualifiedName;
   aDeleteItem.m_strName   = pObject->GetItemName( );
   aDeleteItem.m_strClass  = pObject->GetClass( );

   if( aDeleteItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   bstrClass   = AllocBSTR( aDeleteItem.m_strClass.GetBuffer(128) );
   bstrName    = AllocBSTR( aDeleteItem.m_strName.GetBuffer(128) );

   bRecursive  = aDeleteItem.m_bRecursive;


   if( IsClassObject( ) || m_pDoc->UseVBStyle( ) )
   {
      hResult     = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         return hResult;
      }
      if( !bRecursive )
      {
         hResult  = pIContainer->Delete( bstrClass, bstrName );
      }
      else
      {
         IDispatch*  pDispChild;
         IUnknown*   pDispUnk;

         hResult  = pIContainer->GetObject( bstrClass, bstrName, &pDispChild );
         if( SUCCEEDED( hResult ) )
         {
            hResult  = pDispChild->QueryInterface( IID_IUnknown, (void**)&pDispUnk );
            pDispChild->Release( );
            if( SUCCEEDED( hResult ) )
            {
               hResult  = PurgeObject( pIContainer, pDispUnk, NULL );
               pDispUnk->Release( );
            }
         }
      }
      pIContainer->Release( );
   }
   else
   {
      hResult     = m_pIUnk->QueryInterface( IID_IDirectoryObject, (void**)&pDSObject );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         return hResult;
      }
      hResult  = pDSObject->DeleteDSObject( bstrName );
      pDSObject->Release( );
   }

   SysFreeString( bstrClass );
   SysFreeString( bstrName );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ContainerMoveItem( )
{
   CMoveItem         aMoveItem;
   BSTR              bstrSource;
   BSTR              bstrDestination;
   IADsContainer*  pIContainer;
   HRESULT           hResult;
   IDispatch*         pNewItem;
   IADs*           pNewIOleDs;
   CString           strQualifiedName;

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aMoveItem.m_strParent = strQualifiedName;

   if( aMoveItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   bstrSource        = AllocBSTR( aMoveItem.m_strSource.GetBuffer(128) );
   bstrDestination   = AllocBSTR( aMoveItem.m_strDestination.GetBuffer(128) );

   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return hResult;
   }

   hResult  = pIContainer->MoveHere( bstrSource, bstrDestination, &pNewItem );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pNewItem->QueryInterface( IID_IADs, (void**) &pNewIOleDs );

      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pNewIOleDs->SetInfo( );

      pNewIOleDs->Release( );
      pNewItem->Release( );
   }

   SysFreeString( bstrSource );
   SysFreeString( bstrDestination );

   pIContainer->Release( );

   return hResult;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ContainerCopyItem( )
{
   CCopyItem         aCopyItem;
   BSTR              bstrSource;
   BSTR              bstrDestination;
   IADsContainer*  pIContainer;
   HRESULT           hResult;
   IDispatch*        pNewItem;
   IADs*           pNewIOleDs;
   CString           strQualifiedName;

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aCopyItem.m_strParent = strQualifiedName;

   if( aCopyItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   bstrSource        = AllocBSTR( aCopyItem.m_strSource.GetBuffer(128) );
   bstrDestination   = AllocBSTR( aCopyItem.m_strDestination.GetBuffer(128) );

   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return hResult;
   }

   hResult  = pIContainer->CopyHere( bstrSource, bstrDestination, &pNewItem );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pNewItem->QueryInterface( IID_IADs, (void**) &pNewIOleDs );

      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pNewIOleDs->SetInfo( );

      pNewIOleDs->Release( );
      pNewItem->Release( );
   }

   SysFreeString( bstrSource );
   SysFreeString( bstrDestination );

   pIContainer->Release( );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetInterface( IUnknown** pIUnk )
{
   if( NULL != m_pIUnk )
   {
      m_pIUnk->AddRef( );
      *pIUnk   = m_pIUnk;

      return S_OK;
   }
   else
   {
      if( CreateTheObject( ) )
      {
         *pIUnk   = m_pIUnk;
         m_pIUnk  = NULL;

         return S_OK;
      }
      else
      {
         ASSERT( FALSE );
         TRACE( _T("Could not create the object\n") );
         return E_FAIL;
      }
   }
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     COleDsObject::CreateTheObject( )
{
   CString  m_strQualifiedName;
   HRESULT  hResult;

   if( NULL == m_pIUnk )
   {
      m_strQualifiedName   = m_strOleDsPath;
      m_strQualifiedName  += _T(',');
      m_strQualifiedName  += m_strClassName;

      hResult  = m_pDoc->XOleDsGetObject( m_strQualifiedName.GetBuffer( 128 ),
                                          IID_IUnknown, (void**)&m_pIUnk  );
      ASSERT( SUCCEEDED( hResult ) );
   }

   return ( NULL != m_pIUnk );
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ReleaseIfNotTransient( void )
{
   HRESULT        hResult  = S_OK;
   unsigned long  lRefs;

   return S_OK;
   /*hResult        = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
   ASSERT( SUCCEEDED( hResult ) );

   hResult        = pIOleDs->get_OleDsPath( &bstrOleDsPath );
   m_strOleDsPath = bstrOleDsPath;

   ASSERT( m_strOleDsPath.GetLength( ) );

   pIOleDs->Release( );
   m_pIUnk->Release( );*/

   if( NULL != m_pIUnk )
   {
      lRefs = m_pIUnk->Release( );
      if( 0 != lRefs )
      {
         /*TRACE( _T("ReleaseIfNotTransient detected that references to this object are still maintained\n") );
         TRACE( _T("Object:%s\t References:%ld"), m_strOleDsPath.GetBuffer( 128 ), lRefs );*/

         while( lRefs != 0 )
         {
            lRefs = m_pIUnk->Release( );
         }
      }
   }
   m_pIUnk        = NULL;

   return hResult;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject::~COleDsObject( )
{
   int            nIter, nSize;
   DWORD          dwToken;
   COleDsObject*  pChild;

   ClearPropertiesList( );

   if( NULL != m_pIUnk )
   {
      ULONG ulRef;

      ulRef = m_pIUnk->Release( );
      if( ulRef )
      {
         TRACE( _T("ERROR! Release din't returned 0 reference count for %s\n"), m_strOleDsPath );
      }
   }

   if( NULL != m_pChildren )
   {
      nSize = (int)m_pChildren->GetSize( );
      for( nIter = 0; nIter < nSize ; nIter++ )
      {
         dwToken  = m_pChildren->GetAt( nIter );
         ASSERT( dwToken );
         if( dwToken )
         {
            pChild   = m_pDoc->GetObject( &dwToken );
         }
         delete pChild;
      }

      m_pChildren->RemoveAll( );

      delete m_pChildren;
   }



   if( NULL != m_pfReadValues )
      delete [] m_pfReadValues;

   if( NULL != m_pCachedValues )
      delete []m_pCachedValues;

   if( NULL != m_pfDirty )
      delete [] m_pfDirty;

   if( NULL != m_pdwUpdateType )
      delete [] m_pdwUpdateType;
}


/***********************************************************
  Function:    COleDsObject::ClearPropertiesList
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ClearPropertiesList( void )
{
   int   nIdx;

   if( m_ppPropertiesEntries )
   {
      for( nIdx = 0; nIdx < m_nPropertiesCount ; nIdx++ )
      {
         if( NULL != m_ppPropertiesEntries[ nIdx ] )
         {
            m_ppPropertiesEntries[ nIdx ]->Release( );
         }
      }
      FreeADsMem( m_ppPropertiesEntries );
   }

   m_nPropertiesCount      = 0;
   m_ppPropertiesEntries   = NULL;

   return S_OK;
}


/***********************************************************
  Function:    COleDsObject::CreatePropertiesList
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CreatePropertiesList( void )
{
   HRESULT           hResult;
   long              lPropCount, lIdx;
   IADsPropertyList* pPropList   = NULL;
   VARIANT  var;

   if( m_nPropertiesCount )
      return S_OK;

   //ClearPropertiesList( );

   hResult  = m_pIUnk->QueryInterface( IID_IADsPropertyList,
                                       (void**)&pPropList );
   if( FAILED( hResult ) )
      return hResult;

   hResult  = pPropList->get_PropertyCount( &lPropCount );

   if( 0 == lPropCount )
   {
      pPropList->Release( );
      return hResult;
   }

   m_ppPropertiesEntries   = (IUnknown**) AllocADsMem( lPropCount *
                                                       sizeof(IUnknown*) );

   m_nPropertiesCount   = (int)lPropCount;
   lIdx                 = 0;

   while( TRUE )
   {
      hResult  = pPropList->Next( &var );
      if( FAILED( hResult ) )
         break;

      if( lIdx == m_nPropertiesCount )
      {
         ASSERT( FALSE );
         break;
      }

      hResult  =  V_DISPATCH( &var )->QueryInterface( IID_IUnknown,
                                             (void**)&m_ppPropertiesEntries[ lIdx++ ] );
      VariantClear( &var );
   }

   pPropList->Release( );

   return hResult;
}


/***********************************************************
  Function:    COleDsObject::IsClassObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::IsClassObject( )
{
   return ( !m_strClassName.CompareNoCase( _T("Schema") ) ) ||
          ( !m_strClassName.CompareNoCase( _T("Class") ) ) ||
          ( !m_strClassName.CompareNoCase( _T("Property") ) ) ||
          ( !m_strClassName.CompareNoCase( _T("Syntax") ) );
}


/***********************************************************
  Function:    COleDsObject::CreateClassInfo
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::CreateClassInfo( )
{
   int   nPropCount;

   if( !IsClassObject( ) && m_pDoc->UsePropertiesList( ) )
   {
      CreatePropertiesList( );
      return;
   }

   if( !m_pClass )
   {
      m_pClass    = m_pDoc->CreateClass( this );

      if( !IsClassObject( ) && !m_pDoc->UseVBStyle( ) )
      {
         nPropCount  = m_pClass->GetPropertyCount( );

         m_pCachedValues   = new CString[ nPropCount ];
         m_pfReadValues    = new BOOL[ nPropCount ];
         m_pfDirty         = new BOOL[ nPropCount ];
         m_pdwUpdateType   = new DWORD[ nPropCount ];

         for( int nIdx = 0; nIdx < nPropCount ; nIdx++ )
         {
            m_pfReadValues[ nIdx ]  = FALSE;
            m_pfDirty[ nIdx ]       = FALSE;
         }
      }
   }
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::HasChildren( )
{
   return m_bHasChildren;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetClass( )
{
   return m_strClassName;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetOleDsPath( )
{
   return m_strOleDsPath;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetItemName( )
{
   return m_strItemName;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString* COleDsObject::PtrGetItemName( )
{
   return &m_strItemName;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetSchemaPath( )
{
   return m_strSchemaPath;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetDeleteName( )
{
   return m_strItemName;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetChildren( DWORD*   pTokens,
                                    DWORD    dwMaxCount,
                                    CDialog* pQueryStatus,
                                    BOOL*    pFilters,
                                    DWORD    dwFilters )
{
   m_dwFilters       = dwFilters;
   m_pFilters        = pFilters;
   m_pTokens         = pTokens;
   m_dwMaxCount      = dwMaxCount;
   m_pQueryStatus    = pQueryStatus;
   m_dwCount         = 0L;

   m_bAbort = FALSE;
   ((CQueryStatus*)pQueryStatus)->SetAbortFlag( &m_bAbort );

   return 0L;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetChildren( IADsContainer* pIContainer )
{
   IUnknown*   pIEnum;
   HRESULT     hResult;

   SetFilter( pIContainer, m_pFilters, m_dwFilters );

   hResult  = pIContainer->get__NewEnum( &pIEnum );

   if( SUCCEEDED( hResult ) )
   {
      AddNamesFromEnum( pIEnum );
      pIEnum->Release( );
   }

   return 0L;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetChildren( IADsCollection* pIColl )
{
   IUnknown*   pIEnum;
   HRESULT     hResult;

   //SetFilter( pIColl, m_pFilters, m_dwFilters );

   hResult  = pIColl->get__NewEnum( &pIEnum );

   if( SUCCEEDED( hResult ) )
   {
      AddNamesFromEnum( pIEnum );
      pIEnum->Release( );
   }

   return 0L;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetChildren( MEMBERS* pIGroupMem )
{
   IUnknown*   pIEnum;
   HRESULT     hResult;

   SetFilter( pIGroupMem, m_pFilters, m_dwFilters );

   hResult  = pIGroupMem->get__NewEnum( &pIEnum );

   if( SUCCEEDED( hResult ) )
   {
      AddNamesFromEnum( pIEnum );
      pIEnum->Release( );
   }

   return 0L;
}


/***********************************************************
  Function:    AddNamesFromEnum
  Arguments:   pIEnum - IUnknown interface of the enumeration
                  (ususlly get through a get__NewEnum on
                  IADsContainer or IADsCollection or
                  IADsMembers)
  Return:      NA
  Purpose:     Walk the enumeration and retrieves the "child"
               objects
  Author(s):   CezarU
  Revision:    0
  Date:        04/05/1996
***********************************************************/
void  COleDsObject::AddNamesFromEnum( IUnknown* pIEnum )
{
   HRESULT        hResult;
   VARIANT        aVariant[ NEXT_COUNT ];
   IADs*          pChildOleDs;
   ULONG          ulGet, ulIdx;
   IEnumVARIANT*  pIEnumVar = NULL;
   BOOL           bDisplay;
   DWORD          dwToken;

   while( TRUE )
   {
      if( NULL == pIEnum )
      {
         break;
      }

      // query for EnumVARIANT interface
      hResult        = pIEnum->QueryInterface( IID_IEnumVARIANT, (void**)&pIEnumVar );
      if( FAILED( hResult ) )
      {
         ASSERT(FALSE);
         break;
      }

      // try dummy operations for Skip, Reset, Clone.
      {
         IEnumVARIANT*  pICloneVar   = NULL;

         hResult  = pIEnumVar->Skip( 1 );

         hResult  = pIEnumVar->Clone( &pICloneVar );
         if( pICloneVar )
         {
            pICloneVar->Release( );
         }

         hResult  = pIEnumVar->Reset( );
      }


      // ask for the next NEXT_COUNT objects
      hResult  = pIEnumVar->Next( NEXT_COUNT, aVariant, &ulGet );

      while( ulGet && m_dwCount < m_dwMaxCount )
      {
         // get the returned object
         bDisplay = FALSE;

         for( ulIdx = 0;
              m_dwCount < m_dwMaxCount && ulIdx < ulGet && !m_bAbort;
              ulIdx++ )
         {
            // query for the IADs interface
            hResult  = V_DISPATCH( &aVariant[ ulIdx ] )->QueryInterface( IID_IADs,
                                                                         (void**)&pChildOleDs );
            // Indirectly call release on IDispatch interface
            VariantClear( &aVariant[ ulIdx ] );
            if( SUCCEEDED( hResult ) )
            {
               // create an "browse" object based on the OleDs object
               dwToken  = m_pDoc->CreateOleDsItem( this, pChildOleDs );
               ASSERT( dwToken );

               // need no more the IADs interface
               pChildOleDs->Release( );

               // ad the token of the new "browse" object in the array
               m_pTokens[ m_dwCount++ ]   = dwToken;

               // make the token part of the children list
               m_pChildren->Add( dwToken );

               if( m_pQueryStatus )
               {
                  // increment object type counter in "QueryStatus" dialog
                  COleDsObject*  pObject;

                  pObject  = m_pDoc->GetObject( &dwToken );
                  ((CQueryStatus*)m_pQueryStatus)->IncrementType( pObject->GetType( ), TRUE );
               }
            }
         }
         for( ; ulIdx < ulGet ; ulIdx++ )
         {
            // get rid of the unused objects; this code is hit when
            // the user hits "Stop" in the "QueryStatus" dialog
            VariantClear( &aVariant[ ulIdx ] );
         }

         if( !m_bAbort && m_dwCount < m_dwMaxCount )
         {
            // ask for the NEXT_COUNT objects
            hResult  = pIEnumVar->Next( NEXT_COUNT, aVariant, &ulGet );
            if( m_bAbort )
            {
               for( ulIdx  = 0 ; ulIdx < ulGet ; ulIdx++ )
               {
                  // get rid of the unused objects; this code is hit when
                  // the user hits "Stop" in the "QueryStatus" dialog
                  VariantClear( &aVariant[ ulIdx ] );
               }
            }
         }

         if( m_bAbort )
            break;
      }
      break;
   }

   if( pIEnumVar )
   {
      pIEnumVar->Release( );
   }
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutProperty( int nProp, CString& strPropValue, LONG lnControlCode )
{
   CreateClassInfo( );

   if( IsClassObject( ) )
   {
      return PutPropertyVB( nProp, strPropValue, lnControlCode );
   }

   if( m_pDoc->UsePropertiesList( ) )
   {
      //return   PutPropertyList( int nProp, CString& strPropValue, LONG lnControlCode );
      return   E_FAIL;
   }

   if( m_pDoc->UseVBStyle( ) )
   {
      return PutPropertyVB( nProp, strPropValue, lnControlCode );
   }
   else
   {
      return PutPropertyCPP( nProp, strPropValue, lnControlCode );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutPropertyCPP( int nProp, CString& strPropValue,
                                       LONG lnControlCode )
{
   if( strPropValue.Compare( m_pCachedValues[ nProp ] ) )
   {
      m_pfDirty[ nProp ]         = TRUE;
      m_pCachedValues[ nProp ]   = strPropValue;
      m_pdwUpdateType[ nProp ]   = lnControlCode;
   }

   return S_OK;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutPropertyVB( int nProp,
                                      CString& strPropValue,
                                      LONG lnControlCode )
{
   HRESULT        hResult;
   IDispatch*     pIDispatchFS= NULL;
   CString        strProperty, strFuncSet;
   DISPID         dispid;
   BOOL           bRez;
   DISPPARAMS     dispParams;
   VARIANT        aVar[ 20 ];
   DISPID         adispidNamedArgs[ 20 ];
   BSTR           bstrPut;
   EXCEPINFO      aExcepInfo;
   BOOL           bUseGeneric;


    dispParams.rgdispidNamedArgs  = adispidNamedArgs;

   strProperty = GetAttribute( nProp, pa_Name );
   bUseGeneric = m_pDoc->GetUseGeneric( );
   bUseGeneric = bUseGeneric && !IsClassObject( );

   hResult     = GetIDispatchForFuncSet( 0, &pIDispatchFS );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      if( !bUseGeneric )
      {
         bstrPut  = AllocBSTR( strProperty.GetBuffer( 128 ) );
         hResult  = pIDispatchFS->GetIDsOfNames( IID_NULL, &bstrPut, 1,
                                                 LOCALE_SYSTEM_DEFAULT, &dispid ) ;
         SysFreeString( bstrPut );

         if( FAILED( hResult ) )
            break;
         dispParams.rgvarg = aVar;
         bRez              = DisplayStringToDispParams( nProp,
                                                        strPropValue,
                                                        dispParams,
                                                        FALSE );

         if( bRez )
         {
            hResult  = pIDispatchFS->Invoke( dispid, IID_NULL,
                                             LOCALE_SYSTEM_DEFAULT,
                                             DISPATCH_PROPERTYPUT,
                                             &dispParams,
                                             NULL, &aExcepInfo, NULL);
            if( DISP_E_EXCEPTION == hResult )
            {
               hResult  = aExcepInfo.scode;
            }

            VariantClear( &aVar[ 0 ] );
         }
      }
      else
      {
         bstrPut  = m_pDoc->GetUseGetEx( ) ?
                    AllocBSTR( _T("PutEx") ) : AllocBSTR( _T("Put") );

         hResult  = pIDispatchFS->GetIDsOfNames( IID_NULL, &bstrPut,
                                                 1, LOCALE_SYSTEM_DEFAULT,
                                                 &dispid );
         SysFreeString( bstrPut );

         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
            break;

         // we got the dispid of Put method...
         dispParams.rgvarg = &aVar[ 0 ];
         bRez              = DisplayStringToDispParams( nProp,
                                                        strPropValue,
                                                        dispParams,
                                                        bUseGeneric && m_pDoc->GetUseGetEx( ) );

         VariantInit( &aVar[ 1 ] );
         V_VT( &aVar[ 1 ] )      = VT_BSTR;
         V_BSTR( &aVar[ 1 ] )    = AllocBSTR( strProperty.GetBuffer( 128 ) );

         if( m_pDoc->GetUseGetEx( ) )
         {
            VariantInit( &aVar[ 2 ] );
            V_VT( &aVar[ 2 ] )   = VT_I4;
            V_I4( &aVar[ 2 ] )   = lnControlCode;
            dispParams.cArgs     = 3;
         }
         else
         {
            dispParams.cArgs        = 2;
         }
         dispParams.rgvarg       = aVar;
         dispParams.cNamedArgs   = 0;

         if( bRez )
         {
            hResult = pIDispatchFS->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                              DISPATCH_METHOD, &dispParams,
                                            NULL, &aExcepInfo, NULL);
            if( DISP_E_EXCEPTION == hResult )
            {
               hResult  = aExcepInfo.scode;
            }

            VariantClear( &aVar[ 0 ] );
         }
         VariantClear( &aVar[ 1 ] );
      }

      break;
   }


   if( NULL != pIDispatchFS )
   {
      pIDispatchFS->Release( );
   }

   if( FAILED( hResult ) )
   {
      ErrorOnPutProperty( strFuncSet,
                          strProperty,
                          strPropValue,
                          hResult,
                          bUseGeneric,
                          m_pDoc->GetUseGetEx( )
                          );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutProperty( CString&, CString& )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetAttribute( CLASSATTR classAttr )
{
   CreateClassInfo( );

   if( !m_pDoc->UsePropertiesList( ) )
   {
      return m_pClass->GetAttribute( classAttr );
   }
   else
   {
      return CString( _T("NA") );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutAttribute( CLASSATTR classAttr, CString& rValue )
{
   CreateClassInfo( );

   return m_pClass->PutAttribute( classAttr, rValue );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetAttribute( int nProp, PROPATTR propAttr )
{
   IADsPropertyEntry*   pPropEntry;
   HRESULT              hResult;
   CString              strText;

   CreateClassInfo( );

   if( !m_pDoc->UsePropertiesList( ) )
   {
      return m_pClass->GetAttribute( nProp, propAttr );
   }

   ASSERT( nProp < m_nPropertiesCount );

   if( !( nProp < m_nPropertiesCount ) )
      return CString (_T("ERROR") );

   if( NULL == m_ppPropertiesEntries[ nProp ] )
   {
      return CString (_T("ERROR") );
   }

   hResult  = m_ppPropertiesEntries[ nProp ]->QueryInterface( IID_IADsPropertyEntry,
                                                              (void**)&pPropEntry );

   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
      return CString (_T("ERROR") );

   switch( propAttr )
   {
      case  pa_Name:
      case  pa_DisplayName:
      {
         TCHAR szName[ 256 ];
         BSTR  bstrName;

         pPropEntry->get_Name( &bstrName );
         Convert( szName, bstrName );
         SysFreeString( bstrName );
         strText  = szName;

         break;
      }

      case  pa_Type:
      {
         long  lADsType;

         pPropEntry->get_ADsType( &lADsType );
         strText  = StringFromADsType( (ADSTYPE)lADsType  );
         break;
      }

      default:
         break;
   }
   pPropEntry->Release( );

   return strText;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutAttribute( int nProp,
                                     PROPATTR propAttr, CString& rValue )
{
   CreateClassInfo( );

   return m_pClass->PutAttribute( nProp, propAttr, rValue );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetAttribute( int nProp, METHODATTR methAttr )
{
   CreateClassInfo( );

   return m_pClass->GetAttribute( nProp, methAttr );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutAttribute( int nProp,
                                     METHODATTR methAttr, CString& rValue )
{
   CreateClassInfo( );

   return m_pClass->PutAttribute( nProp, methAttr, rValue );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CallMethod( int nMethod )
{
   CMethod*    pMethod;
   IDispatch*  pIDispatch;
   IUnknown*   pMethodInterf;
   HRESULT     hResult;
   CString     strCaption;
   CString     strMessage;
   BOOL        bDisplayMessage = TRUE;

   CreateClassInfo( );

   hResult  = m_pIUnk->QueryInterface( m_pClass->GetMethodsInterface( ),
                                       (void**)&pMethodInterf );

   if( FAILED( hResult ) )
      return hResult;

   pMethod  = m_pClass->GetMethod( nMethod );

   hResult  = pMethodInterf->QueryInterface( IID_IDispatch,
                                             (void**)&pIDispatch );

   pMethodInterf->Release( );

   if( SUCCEEDED( hResult ) )
   {
      void* pData;

      pData = LocalAlloc( LMEM_ZEROINIT, 100 );

      hResult  = pMethod->CallMethod( pIDispatch, &bDisplayMessage );
      pIDispatch->Release( );

      LocalFree( pData );
   }

   strCaption  = m_pClass->GetAttribute( nMethod, ma_Name );
   strMessage  = OleDsGetErrorText( hResult );


   if( ! (SUCCEEDED( hResult ) && !bDisplayMessage) )
   {
      AfxGetMainWnd()->MessageBox( strMessage, strCaption, MB_ICONINFORMATION );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetIDispatchForFuncSet( int nFuncSet,
                                               IDispatch** ppIDispatchFS )
{
   IDispatch*     pIDisp      = NULL;
   IUnknown*      pIPrimary   = NULL;
   CString        strFuncSet;
   CString        strPrimaryInterf;
   HRESULT        hResult;
   DISPPARAMS     dispparamsNoArgs = {NULL, NULL, 0, 0};
   CLSID          PrimaryIID;
   UINT           uTypeInfo;
   ITypeInfo*     pTypeInfo;

   *ppIDispatchFS = NULL;

   CreateClassInfo( );

   strPrimaryInterf  = m_pClass->GetAttribute( ca_PrimaryInterface );
   if( strPrimaryInterf != _T("NA") )
   {
      BSTR  bstrPrimaryInterface;

      bstrPrimaryInterface = AllocBSTR( strPrimaryInterf.GetBuffer( 128 ) );
      hResult  = CLSIDFromString( bstrPrimaryInterface, &PrimaryIID );
      SysFreeString( bstrPrimaryInterface );

      //ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         hResult  = S_OK;
         PrimaryIID  = IID_IADs;
         //return hResult;
      }
   }
   else
   {
      PrimaryIID  = IID_IADs;
   }

   hResult        = m_pIUnk->QueryInterface( PrimaryIID, (void**) &pIPrimary );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      hResult        = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIPrimary );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         return hResult;
      }
   }

   hResult        = pIPrimary->QueryInterface( IID_IDispatch, (void**) &pIDisp );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      return hResult;
   }

   {
      HRESULT  hResult;

      hResult  = pIDisp->GetTypeInfoCount( &uTypeInfo );
      hResult  = pIDisp->GetTypeInfo( 0, LOCALE_SYSTEM_DEFAULT, &pTypeInfo );
      if( SUCCEEDED( hResult ) )
      {
         pTypeInfo->Release( );
      }
   }

   *ppIDispatchFS   = pIDisp;
   pIDisp->AddRef( );

   pIDisp->Release( );
   pIPrimary->Release( );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetPropertyFromList( int nProp, CString& strPropValue )
{
   //IADsPropertyList*  pPropList;
   IADsPropertyEntry* pPropEntry;
   HRESULT           hResult;
   long              lADsType;
   BSTR              bstrName;
   VARIANT           vValues;
   long              lValueCount = 0;

   ASSERT( 0 <= nProp && nProp < m_nPropertiesCount );

   if( 0 > nProp || nProp >= m_nPropertiesCount )
      return E_FAIL;

   hResult  = m_ppPropertiesEntries[ nProp ]->QueryInterface( IID_IADsPropertyEntry,
                                                              (void**)&pPropEntry );
   if( FAILED( hResult ) )
      return hResult;

   hResult  = pPropEntry->get_Name( &bstrName );
   hResult  = pPropEntry->get_ADsType( &lADsType );
   //hResult  = pPropEntry->get_ValueCount( &lValueCount );
   hResult  = pPropEntry->get_Values( &vValues );

   if( SUCCEEDED( hResult ) )
   {
      COleDsSyntax*  pSyntax;

      pSyntax  = GetSyntaxHandler( (ADSTYPE)lADsType, strPropValue );

      if( NULL != pSyntax )
      {
         strPropValue  = pSyntax->VarToDisplayStringEx( vValues,
                                                        (lValueCount != 1) );
         delete pSyntax;
      }
   }

   pPropEntry->Release( );

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutProperty( CString& strName,
                                    CString& strVal,
                                    BOOL bMultiValued,
                                    ADSTYPE eType )
{
   HRESULT           hResult;
   IADsPropertyList* pPropList   = NULL;
   COleDsSyntax*     pSyntax     = NULL;
   DISPPARAMS        dispParams;
   VARIANT           aVar[ 20 ];
   CString           strText;

   dispParams.rgvarg = aVar;

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsPropertyList,
                                          (void**)&pPropList );
      if( FAILED( hResult ) )
         break;

      pSyntax  = GetSyntaxHandler( eType, strText );

      if( NULL != pSyntax )
      {
         /*BOOL  bOK;
         VARIANT  var;

         bOK   = pSyntax->CreatePropertyItem( strVal,
                                              var,
                                              bMultiValued,
                                              eType );
         bOK   = FALSE;

         if( bOK )
         {
            bstrName = AllocBSTR( strName.GetBuffer( 256 ) );
           hResult  = pPropList->PutPropertyItem( bstrName,
                                                   (long)ADS_ATTR_UPDATE,
                                                   var );
            VariantClear( &aVar[ 0 ] );
            SysFreeString( bstrName );
         }*/
         delete pSyntax;
      }
      pPropList->Release( );
      break;
   }
   if( FAILED( hResult ) )
   {
      AfxMessageBox( OleDsGetErrorText( hResult ) );
   }

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetProperty( CString& strName,
                                    CString& strVal,
                                    BOOL     bMultiValued,
                                    ADSTYPE  eType )
{
   HRESULT           hResult;
   IADsPropertyList* pPropList   = NULL;
   COleDsSyntax*     pSyntax     = NULL;
   BSTR              bstrName;
   VARIANT           aVar;
   CString           strText;

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsPropertyList, (void**)&pPropList );
      if( FAILED( hResult ) )
         break;

      bstrName = AllocBSTR( strName.GetBuffer( 256 ) );
      hResult  = pPropList->GetPropertyItem( bstrName, (long)eType, &aVar );
      SysFreeString( bstrName );

      if( FAILED( hResult ) )
      {
         pPropList->Release( );
         break;
      }

      pSyntax  = GetSyntaxHandler( eType, strText );

      if( NULL != pSyntax )
      {
         strVal   = pSyntax->VarToDisplayString( aVar, bMultiValued, TRUE );
         delete pSyntax;
      }

      VariantClear( &aVar );
      pPropList->Release( );
      break;
   }

   if( FAILED( hResult ) )
   {
      AfxMessageBox( OleDsGetErrorText( hResult ) );
   }

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetProperty( int nProp,
                                    CString& strPropValue,
                                    BOOL* pbSecurityDescriptor )
{
   CreateClassInfo( );

   if( IsClassObject( ) )
   {
      return GetPropertyVB( nProp,
                            strPropValue,
                            pbSecurityDescriptor );
   }

   if( m_pDoc->UsePropertiesList( ) )
      return GetPropertyFromList( nProp,
                                  strPropValue
                                  /*pbSecurityDescriptor*/ );

   if( m_pDoc->UseVBStyle( ) )
   {
      return GetPropertyVB( nProp,
                            strPropValue,
                            pbSecurityDescriptor );
   }
   else
   {
      return GetPropertyCPP( nProp,
                             strPropValue,
                             pbSecurityDescriptor );
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  COleDsObject::GetPropertyVB( int nProp,
                                      CString& strPropValue,
                                      BOOL* pbSecurityDescriptor )
{
   IDispatch*        pIDispatchFS   = NULL;
   CString           strProperty, strFuncSet;
   HRESULT           hResult;
   DISPID            dispid;
   VARIANT           varProp;
   DISPPARAMS        dispparamsArgs = {NULL, NULL, 0, 0};
   EXCEPINFO         aExcepInfo;
   BSTR              bstrGet;
   BOOL              bUseGeneric;
   BOOL              bSecDescriptor;

   strProperty    = GetAttribute( nProp, pa_Name );
   strPropValue   = _T("Error");
   hResult        = GetIDispatchForFuncSet( 0, &pIDispatchFS );
   bUseGeneric    = m_pDoc->GetUseGeneric( );
   bUseGeneric    = bUseGeneric && !IsClassObject( );


   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      VariantInit( &varProp );
      //if( !strFuncSet.IsEmpty( ) )
      if( !bUseGeneric )
      {
         bstrGet  = AllocBSTR( strProperty.GetBuffer( 128 ) );
         hResult  = pIDispatchFS->GetIDsOfNames( IID_NULL, &bstrGet,
                                                 1, LOCALE_SYSTEM_DEFAULT,
                                                 &dispid );
         SysFreeString( bstrGet );
         if( FAILED( hResult ) )
            break;
         hResult = pIDispatchFS->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                           DISPATCH_PROPERTYGET, &dispparamsArgs,
                                         &varProp, &aExcepInfo, NULL);
      }
      else
      {
         // we have the case when the property id not accessed using
         // functional sets.
         bstrGet  = AllocBSTR( m_pDoc->GetUseGetEx( ) ? _T("GetEx") : _T("Get") );
         hResult  = pIDispatchFS->GetIDsOfNames( IID_NULL, &bstrGet,
                                                 1, LOCALE_SYSTEM_DEFAULT,
                                                 &dispid );
         SysFreeString( bstrGet );

         // we got the dispid of Put method...
         dispparamsArgs.rgvarg   = new VARIANT[ 1 ];

         VariantInit( &dispparamsArgs.rgvarg[ 0 ] );

         V_VT( &dispparamsArgs.rgvarg[ 0 ] )    = VT_BSTR;
         V_BSTR( &dispparamsArgs.rgvarg[ 0 ] )  = AllocBSTR( strProperty.GetBuffer( 128 ) );

         dispparamsArgs.cArgs       = 1;
         dispparamsArgs.cNamedArgs  = 0;

         hResult = pIDispatchFS->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                           DISPATCH_METHOD, &dispparamsArgs,
                                         &varProp, &aExcepInfo, NULL);
         VariantClear( &dispparamsArgs.rgvarg[ 0 ] );

         delete (dispparamsArgs.rgvarg);
      }

      if( DISP_E_EXCEPTION == hResult )
      {
         hResult  = aExcepInfo.scode;
      }
      else
      {

         bSecDescriptor = IsSecurityDescriptor( varProp, m_pDoc->GetUseGetEx( ) );
         if( !bSecDescriptor )
         {
            strPropValue   = VarToDisplayString( nProp,
                                                 varProp,
                                                 bUseGeneric && m_pDoc->GetUseGetEx( ) );
         }
         else
         {
            strPropValue   = _T("This is a security descriptor");
         }

         VariantClear( &varProp );
         if( NULL != pbSecurityDescriptor )
         {
            *pbSecurityDescriptor   = bSecDescriptor;
         }
      }
      break;
   }

   if( FAILED( hResult ) )
   {
      strPropValue   = OleDsGetErrorText( hResult );
      //AfxMessageBox( strPropValue );
   }

   if( NULL != pIDispatchFS )
   {
      pIDispatchFS->Release( );
   }

   return hResult;
}



//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
BOOL  COleDsObject::IsSecurityDescriptor( VARIANT& rValue, BOOL bUseGetEx )
{
   BOOL     bIsSD = FALSE;
   HRESULT  hResult;
   IADsSecurityDescriptor* pDescriptor = NULL;

   if( !bUseGetEx )
   {
      switch( V_VT( &rValue ) )
      {
         case  VT_DISPATCH:
         {

            hResult  = V_DISPATCH( &rValue )->QueryInterface(
                              IID_IADsSecurityDescriptor,
                              (void**)&pDescriptor );
            if( SUCCEEDED( hResult ) )
            {
               pDescriptor->Release( );
               bIsSD = TRUE;
            }
            break;
         }

         default:
            break;
      }
   }
   else
   {
      SAFEARRAY*  pSafeArray;
      VARIANT     var;
      long        lBound, uBound;

      if( (VT_ARRAY | VT_VARIANT) != V_VT( &rValue )  )
         return FALSE;

      pSafeArray  = V_ARRAY( &rValue );

      hResult     = SafeArrayGetLBound(pSafeArray, 1, &lBound);
      ASSERT( SUCCEEDED( hResult ) );

      hResult     = SafeArrayGetUBound(pSafeArray, 1, &uBound);
      ASSERT( SUCCEEDED( hResult ) );

      hResult     = SafeArrayGetElement( pSafeArray, &lBound, &var );
      if( SUCCEEDED( hResult ) )
      {
         bIsSD = IsSecurityDescriptor( var, FALSE );
         VariantClear( &var );
      }
   }

   return bIsSD;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetPropertyCPP( int nProp, CString& strPropValue,
                                       BOOL * pbIsDescriptor )
{
   ADS_ATTR_INFO*  pAttrDef;
   BSTR           szwAttrName[ 2 ];
   HRESULT        hResult;
   DWORD          dwAttributes;
   IDirectoryObject*     pIADsObject;
   CString        strPropName;

   if( m_pfDirty[ nProp ] || m_pfReadValues[ nProp ] )
   {
      strPropValue   = m_pCachedValues[ nProp ];

      return S_OK;
   }

   hResult  = m_pIUnk->QueryInterface( IID_IDirectoryObject, (void**)&pIADsObject );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      strPropName = m_pClass->GetAttribute( nProp, pa_Name );

      szwAttrName[ 0 ]  = AllocBSTR( strPropName.GetBuffer( 255 ) );
      hResult  = pIADsObject->GetObjectAttributes( (LPWSTR*)szwAttrName,
                                                   1,
                                                   &pAttrDef,
                                                   &dwAttributes );
      if( FAILED( hResult ) )
      {
         strPropValue   = OleDsGetErrorText( hResult );
         break;
      }

      if( SUCCEEDED( hResult ) && !dwAttributes )
      {
         TRACE( _T("ERROR: GetObjectAttributes succeeds, but dwAttributes is 0\n") );
         strPropValue   = _T("ERROR: GetObjectAttributes succeeds, but dwAttributes is 0");
         //dwAttributes   = 1;
      }

      if( !dwAttributes )
         break;

      hResult  = CopyAttributeValue( pAttrDef, nProp );

      FreeADsMem( (void*) pAttrDef );
      break;
   }

   //ASSERT( m_pfReadValues[ nProp ] );
   if( m_pfReadValues[ nProp ] )
   {
      strPropValue   = m_pCachedValues[ nProp ];
   }

   if( pIADsObject )
   {
      pIADsObject->Release( );
   }

   return hResult;
}


/***********************************************************
  Function:    COleDsObject::CopyAttributeValue
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CopyAttributeValue( ADS_ATTR_INFO* pAttrDef, int nAttribute )
{
   HRESULT     hResult;
   CProperty*  pProperty;

   CreateClassInfo( );

   ASSERT( pAttrDef->pszAttrName );
   if( ! pAttrDef->pszAttrName )
   {
      return E_FAIL;
   }

   if( -1 == nAttribute )
   {
      // cool, we must gues the attribute index based on attribute name
      TCHAR    szAttrName[ 128 ];
      int      nProp;
      CString  strPropName;

      Convert( szAttrName, pAttrDef->pszAttrName );
      strPropName = szAttrName;
      nProp       = m_pClass->LookupProperty( strPropName );

      ASSERT( -1 != nProp );

      return (-1 == nProp) ?
             E_FAIL : CopyAttributeValue( pAttrDef, nProp );
   }

   pProperty      = m_pClass->GetProperty( nAttribute );
   hResult        = pProperty->Native2Value( pAttrDef, m_pCachedValues[ nAttribute ] );
   m_pfReadValues[ nAttribute ] = TRUE;
   //m_pCachedValues[ nAttribute ];

   return hResult;
}


/***********************************************************
  Function:    COleDsObject::CreateAttributeValue
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CreateAttributeValue ( ADS_ATTR_INFO* pAttrDef,
                                              int nAttribute  )
{
   HRESULT     hResult = S_OK;
   CProperty*  pProperty;
   CString     strPropName;

   pProperty               = m_pClass->GetProperty( nAttribute );
   strPropName             = m_pClass->GetAttribute( nAttribute, pa_Name );

   pAttrDef->pszAttrName   = (WCHAR*)AllocADsMem( sizeof(WCHAR) *
                                               ( strPropName.GetLength() + 1 ) );

   Convert( pAttrDef->pszAttrName, strPropName.GetBuffer( 256 ) );

   pAttrDef->dwControlCode = m_pdwUpdateType[ nAttribute ];

   if( ADS_PROPERTY_CLEAR != m_pdwUpdateType[ nAttribute ] )
   {
      hResult  = pProperty->Value2Native( pAttrDef,
                                          m_pCachedValues[ nAttribute ] );
   }

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetProperty( CString&, CString& )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
//void  COleDsObject::SetClass( CClass* pClass )
//{
//   ASSERT( pClass != NULL );
//
//   m_pClass = pClass;
//}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::UseSchemaInformation ( BOOL bUse )
{
   m_bUseSchemaInformation = bUse;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   COleDsObject::GetPropertyCount(  )
{
   CreateClassInfo( );

   if( !m_pDoc->UsePropertiesList( ) )
   {
      return m_pClass->GetPropertyCount( );
   }
   else
   {
      return m_nPropertiesCount;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::VarToDisplayString( int  nProp, VARIANT& var, BOOL bUseEx )
{
   CreateClassInfo( );

   return m_pClass->VarToDisplayString( nProp, var, bUseEx );
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::DisplayStringToDispParams( int  nProp,
                                               CString& rString, DISPPARAMS& dp,
                                               BOOL bUseEx )
{
   CreateClassInfo( );

   return m_pClass->DisplayStringToDispParams( nProp, rString, dp, bUseEx );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::SupportContainer( void )
{
   CreateClassInfo( );

   return m_pClass->SupportContainer( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetType( )
{
   return m_dwType;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetInfo( )
{
   HRESULT  hResult;

   if( m_pDoc->UseVBStyle( ) )
   {
      hResult  = GetInfoVB( );
   }
   else
   {
      hResult  = GetInfoCPP( );
   }

   ClearPropertiesList( );

   if( FAILED( hResult ) )
   {
      CString  strError;

      strError = OleDsGetErrorText( hResult );
      AfxGetMainWnd()->MessageBox( strError, _T("GetInfo ERROR") );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetInfoVB( )
{
   IADs*  pIOleDs;
   HRESULT  hResult;

   hResult  = E_FAIL;

   ASSERT( NULL != m_pIUnk );

   if( NULL != m_pIUnk )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         __try
         {
            hResult  = pIOleDs->GetInfo( );
         }
         __except( EXCEPTION_EXECUTE_HANDLER )
         {
            hResult  = E_FAIL;
            AfxMessageBox( _T("ERROR: AV caused by GetInfo") );
         }
         pIOleDs->Release( );
      }
   }
   else
   {
      CreateTheObject( );
      if( NULL != m_pIUnk )
      {
         hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
         ASSERT( SUCCEEDED( hResult ) );

         if( SUCCEEDED( hResult ) )
         {
            __try
            {
               hResult  = pIOleDs->GetInfo( );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
               hResult  = E_FAIL;
               AfxMessageBox( _T("ERROR: AV caused by GetInfo") );
            }
            pIOleDs->Release( );
         }

         ReleaseIfNotTransient( );
      }
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::SetInfo( )
{
   if( m_pDoc->UseVBStyle( ) )
   {
      return SetInfoVB( );
   }
   else
   {
      return SetInfoCPP( );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetInfoCPP( )
{
   HRESULT        hResult;
   ADS_ATTR_INFO* pAttrDef;
   DWORD          dwAttributes, dwIter;
   IDirectoryObject*     pIADsObject;
   CString        strPropName;


   for( dwIter = 0L ;dwIter < (DWORD)m_pClass->GetPropertyCount( );dwIter++ )
   {
      m_pfReadValues[ dwIter ]   = FALSE;
      m_pfDirty[ dwIter ]        = FALSE;
   }

   hResult  = m_pIUnk->QueryInterface( IID_IDirectoryObject, (void**)&pIADsObject );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      {
         ADS_OBJECT_INFO*  pInfo;
         HRESULT           hResult;
         TCHAR             szText[ 256 ];

         hResult  = pIADsObject->GetObjectInformation( &pInfo );

         while( TRUE )
         {
            if( FAILED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: GetObjectInformation retuns %lx\n"), hResult );
               break;
            }

            if( NULL != pInfo->pszRDN )
            {
               Convert( szText, pInfo->pszRDN );
               TRACE( _T("pszRDN = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszRDN is NULL\n") );

            }

            if( NULL != pInfo->pszObjectDN )
            {
               Convert( szText, pInfo->pszObjectDN );
               TRACE( _T("pszObjectDN = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszObjectDN is NULL\n") );
            }

            if( NULL != pInfo->pszParentDN )
            {
               Convert( szText, pInfo->pszParentDN );
               TRACE( _T("pszParentDN = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszParentDN is NULL\n") );
            }

            if( NULL != pInfo->pszSchemaDN )
            {
               Convert( szText, pInfo->pszSchemaDN );
               TRACE( _T("pszSchemaDN = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszSchemaDN is NULL\n") );
            }

            if( NULL != pInfo->pszClassName )
            {
               Convert( szText, pInfo->pszClassName );
               TRACE( _T("pszClassName = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszClassName is NULL\n") );
            }

            FreeADsMem( pInfo );
            break;
         }
      }

      hResult  = pIADsObject->GetObjectAttributes( NULL,
                                                   (ULONG)-1L,
                                                   &pAttrDef,
                                                   &dwAttributes );

      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      for( dwIter = 0L ; dwIter < dwAttributes ; dwIter++ )
      {
         CopyAttributeValue( pAttrDef + dwIter );
      }

      FreeADsMem( (void*) pAttrDef );
      break;
   }

   if( pIADsObject )
   {
      pIADsObject->Release( );
   }

   return hResult;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::SetInfoVB( )
{
   IADs*  pIOleDs;
   HRESULT  hResult;

   hResult  = E_FAIL;

   ASSERT( NULL != m_pIUnk );

   if( NULL != m_pIUnk )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pIOleDs->SetInfo( );
         if( FAILED( hResult ) )
         {
            CString  strError;

            strError = OleDsGetErrorText( hResult );
            AfxGetMainWnd()->MessageBox( strError, _T("SetInfo ERROR") );
         }
         pIOleDs->Release( );
      }
   }
   else
   {
      CreateTheObject( );
      if( NULL != m_pIUnk )
      {
         hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
         ASSERT( SUCCEEDED( hResult ) );

         if( SUCCEEDED( hResult ) )
         {
            hResult  = pIOleDs->SetInfo( );
            pIOleDs->Release( );
         }

         ReleaseIfNotTransient( );
      }
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetDirtyAttributes( PADS_ATTR_INFO* ppAttrDef, DWORD* pdwCount )
{
   HRESULT           hResult = S_OK;
   DWORD             dwDirty  = 0L;
   DWORD             dwIter, dwProps;
   ADS_ATTR_INFO*    pAttrDef;
   ADS_ATTR_INFO*    pAttrDefCurrent;
   CString           strPropName;

   *ppAttrDef  = NULL;
   *pdwCount   = 0L;

   dwProps  = (DWORD)m_pClass->GetPropertyCount( );
   for( dwIter = 0L ; dwIter < dwProps ; dwIter++ )
   {
      if( m_pfDirty[ dwIter ] )
         dwDirty++;
   }

   if( !dwDirty )
      return S_FALSE;

   pAttrDef = (ADS_ATTR_INFO*) AllocADsMem( sizeof(ADS_ATTR_INFO) *dwDirty );
   ASSERT( pAttrDef );
   if( !pAttrDef )
      return E_FAIL;

   pAttrDefCurrent   = pAttrDef;

   for( dwIter = 0L ; dwIter < dwProps ; dwIter++ )
   {
      if( m_pfDirty[ dwIter ] )
      {
         CreateAttributeValue( pAttrDefCurrent, dwIter );
         pAttrDefCurrent++;
      }
   }

   *ppAttrDef  = pAttrDef;
   *pdwCount   = dwDirty;

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::FreeDirtyAttributes( PADS_ATTR_INFO pAttrDef, DWORD dwCount )
{
   DWORD             dwIter;
   CProperty*        pProperty;
   CString           strPropName;
   TCHAR             szPropName[ 128 ];

   ASSERT( NULL != pAttrDef );
   if( NULL == pAttrDef )
      return;

   for( dwIter = 0L ; dwIter < dwCount ; dwIter++ )
   {
      ASSERT( NULL != pAttrDef[ dwIter ].pszAttrName );

      if( NULL != pAttrDef[ dwIter ].pszAttrName )
      {
         int   nIdx;

         Convert( szPropName, pAttrDef[ dwIter ].pszAttrName );
         strPropName = szPropName;

         nIdx  = m_pClass->LookupProperty( strPropName );
         if( -1 != nIdx )
         {
            pProperty   = m_pClass->GetProperty( nIdx );
            pProperty->FreeAttrInfo( pAttrDef + dwIter );
         }
      }
   }

   FreeADsMem( pAttrDef );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::SetInfoCPP( )
{
   HRESULT        hResult;
   DWORD          dwDirty  = 0L;
   DWORD          dwAttributesModified;
   ADS_ATTR_INFO* pAttrDef;
   IDirectoryObject*     pIADsObject;

   hResult  = GetDirtyAttributes( &pAttrDef, &dwDirty );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IDirectoryObject, (void**)&pIADsObject );

      if( FAILED( hResult ) )
         return hResult;

      hResult  = pIADsObject->SetObjectAttributes( pAttrDef,
                                                   dwDirty,
                                                   &dwAttributesModified );
      pIADsObject->Release( );

      FreeDirtyAttributes( pAttrDef, dwDirty );

      if( FAILED( hResult ) )
      {
         CString  strError;

         strError = OleDsGetErrorText( hResult );
         AfxGetMainWnd()->MessageBox( strError, _T("SetObjectAttributes ERROR") );
      }
   }

   return hResult;
}

/******************************************************************************
  Function:    PurgeObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT  COleDsObject::PurgeObject( IADsContainer* pParent,
                                    IUnknown*      pIUnknown,
                                    LPWSTR         pszPrefix
                                   )
{
   BSTR              bstrName       = NULL;
   BSTR              bstrClass      = NULL;
   VARIANT           var;
   HRESULT           hResult;
   IUnknown*         pIChildUnk     = NULL;
   IADs*             pIChildOleDs   = NULL;
   IADs*             pADs;
   BSTR              bstrObjName, bstrObjClass;
   IEnumVARIANT*     pIEnumVar   = NULL;
   IADsContainer*    pIContainer = NULL;
   ULONG             ulFetch     = 0L;
   BOOL              bFirst      = FALSE;
   TCHAR             szName[ 128 ];

   if( NULL == pParent || NULL == pIUnknown )
      return E_FAIL;

   hResult  = pIUnknown->QueryInterface( IID_IADs,
                                         (void**)&pADs );
   if( FAILED( hResult ) )
      return E_FAIL;

   if( NULL == m_pDeleteStatus )
   {
      m_bAbort          = FALSE;
      m_pDeleteStatus   = new CDeleteStatus;
      m_pDeleteStatus->SetAbortFlag( &m_bAbort );
      m_pDeleteStatus->Create( IDD_DELETESTATUS );
      m_pDeleteStatus->ShowWindow( SW_SHOW );
      m_pDeleteStatus->UpdateWindow( );
      bFirst            = TRUE;
   }

   if( !m_bAbort )
   {
      pADs->get_Name( &bstrObjName );
      pADs->get_Class( &bstrObjClass );
      pADs->Release( );

      hResult  = pIUnknown->QueryInterface( IID_IADsContainer,
                                            (void**)&pIContainer );
      if( FAILED( hResult ) )
      {
         Convert( szName, bstrObjName );

         if( NULL != pszPrefix && !_wcsnicmp( bstrObjName, pszPrefix, wcslen(pszPrefix) ) )
         {
            m_pDeleteStatus->SetCurrentObjectText( szName );
            m_pDeleteStatus->SetStatusText( _T("Pending") );

            hResult  = pParent->Delete( bstrObjClass, bstrObjName );

            m_pDeleteStatus->SetStatusText( SUCCEEDED( hResult) ?
                                            _T("OK"):_T("FAIL") );
            TRACE( _T("Delete %S returns %lx\n"), bstrObjName, hResult );
         }
         if( NULL == pszPrefix )
         {
            m_pDeleteStatus->SetCurrentObjectText( szName );
            m_pDeleteStatus->SetStatusText( _T("Pending") );

            hResult  = pParent->Delete( bstrObjClass, bstrObjName );

            m_pDeleteStatus->SetStatusText( SUCCEEDED( hResult) ?
                                            _T("OK"):_T("FAIL") );
            TRACE( _T("Delete %S returns %lx\n"), bstrObjName, hResult );
         }

         SysFreeString( bstrObjClass );
         SysFreeString( bstrObjName );
         return S_OK;
      }
   }
   if( !m_bAbort )
   {

      hResult  = ADsBuildEnumerator( pIContainer, &pIEnumVar );

      while( SUCCEEDED( hResult ) && !m_bAbort )
      {
         ulFetch  = 0L;

         hResult  = ADsEnumerateNext( pIEnumVar, 1, &var, &ulFetch );
         if( FAILED( hResult ) )
            continue;

         if( !ulFetch )
            break;

         V_DISPATCH( &var )->QueryInterface( IID_IUnknown, (void**)&pIChildUnk );

         VariantClear( &var );

         if( NULL != pIChildUnk )
         {
            PurgeObject( pIContainer, pIChildUnk, pszPrefix );
            pIChildUnk->Release( );
         }
         pIChildUnk  = NULL;
      }

      if( NULL != pIEnumVar )
      {
         ADsFreeEnumerator( pIEnumVar );
      }
      pIContainer->Release( );
   }

   if( !m_bAbort )
   {

      Convert( szName, bstrObjName );

      m_pDeleteStatus->SetCurrentObjectText( szName );
      m_pDeleteStatus->SetStatusText( _T("Pending") );

      hResult  = pParent->Delete( bstrObjClass, bstrObjName );

      m_pDeleteStatus->SetStatusText( SUCCEEDED( hResult) ?
                                      _T("OK"):_T("FAIL") );

      TRACE( _T("\tDelete %S (%S) ends with %lx\n"), bstrObjName, bstrObjClass );

      SysFreeString( bstrObjClass );
      SysFreeString( bstrObjName );
   }

   if( bFirst )
   {
      m_pDeleteStatus->DestroyWindow( );
      delete m_pDeleteStatus;
      m_pDeleteStatus   = NULL;
   }

   return hResult;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\newobj.cpp ===
// NewObject.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "newobj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewObject dialog


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CNewObject::CNewObject(CWnd* pParent /*=NULL*/)
	: CDialog(CNewObject::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewObject)
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CNewObject::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewObject)
	DDX_Control(pDX, IDC_USEEXTENDEDSYNTAX, m_UseExtendedSyntax);
	DDX_Control(pDX, IDC_OPENAS, m_OpenAs);
	DDX_Control(pDX, IDC_OLEDSPATH, m_OleDsPath);
	DDX_Control(pDX, IDC_SECUREAUTHENTICATION, m_Secure);
	DDX_Control(pDX, IDC_ENCRYPTION, m_Encryption);
	DDX_Control(pDX, IDC_USEOPEN, m_UseOpen);
	DDX_Control(pDX, IDC_PASSWORD, m_Password);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewObject, CDialog)
	//{{AFX_MSG_MAP(CNewObject)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewObject message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CNewObject::OnOK()
{
   CString strVal;

   // TODO: Add extra validation here
	m_OleDsPath.GetWindowText( m_strPath );
   SaveLRUList( IDC_OLEDSPATH, _T("Open_ADsPath"), 100 );

	m_OpenAs.GetWindowText( m_strOpenAs );
   SaveLRUList( IDC_OPENAS,  _T("Open_OpenAs"), 100 );

   m_Password.GetWindowText( m_strPassword );
   //SetLastProfileString( _T("LastPassword"), m_strPassword );

   //*******************
   m_bUseOpen  = m_UseOpen.GetCheck( );
   strVal      = m_bUseOpen ? _T("Yes") : _T("No");
   SetLastProfileString( _T("UseOpen"), strVal );

   //*******************
   m_bSecure   = m_Secure.GetCheck( );
   strVal      = m_bSecure ? _T("Yes") : _T("No");
   SetLastProfileString( _T("Secure"), strVal );

   //*******************
   m_bEncryption  = m_Encryption.GetCheck( );
   strVal         = m_bEncryption ? _T("Yes") : _T("No");
   SetLastProfileString( _T("Encryption"), strVal );

   //*******************
   m_bUseExtendedSyntax = m_UseExtendedSyntax.GetCheck( );
   strVal               = m_bUseExtendedSyntax ? _T("Yes") : _T("No");
   SetLastProfileString( _T("UseExtendedSyntax"), strVal );

   CDialog::OnOK();
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString& CNewObject::GetObjectPath()
{
	return m_strPath;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CNewObject::SaveLRUList( int idCBox, TCHAR* pszSection, int nMax )
{
   CComboBox*  pCombo;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   CString     strText, strItem;
   int         nVal, nIdx, nItems;

   pCombo   = (CComboBox*)GetDlgItem( idCBox );
   pCombo->GetWindowText( strText );

   _tcscpy( szEntry, _T("Value_1") );

   if( strText.GetLength( ) )
   {
      WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strText, ADSVW_INI_FILE );
   }

   nItems   = pCombo->GetCount( );
   nVal     = 2;

   for( nIdx = 0; nItems != CB_ERR && nIdx < nItems && nIdx < nMax ; nIdx ++ )
   {
      pCombo->GetLBText( nIdx, strItem );

      if( strItem.CompareNoCase( strText ) )
      {
         _itot( nVal++, szIndex, 10 );
         _tcscpy( szEntry, _T("Value_") );
         _tcscat( szEntry, szIndex );
         WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strItem, ADSVW_INI_FILE );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CNewObject::GetLRUList( int idCBox, TCHAR* pszSection )
{
   CComboBox*  pCombo;
   int         nIter;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   TCHAR       szValue[ 1024 ];

   pCombo   = (CComboBox*)GetDlgItem( idCBox );

   for( nIter = 0; nIter < 100 ; nIter++ )
   {
      _itot( nIter + 1, szIndex, 10 );
      _tcscpy( szEntry, _T("Value_") );
      _tcscat( szEntry, szIndex );
      GetPrivateProfileString( pszSection, szEntry,
                               _T(""), szValue, 1023, ADSVW_INI_FILE );
      if( _tcslen( szValue ) )
      {
         pCombo->AddString( szValue );
      }
   }

   pCombo->SetCurSel( 0 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CNewObject::OnInitDialog()
{
	CString  strLastValue;

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
   //*******************

   GetLRUList( IDC_OLEDSPATH, _T("Open_ADsPath") );

	GetLRUList( IDC_OPENAS,  _T("Open_OpenAs") );

   //*******************
   strLastValue = _T("");
   SetLastProfileString( _T("LastPassword"), strLastValue );
   //GetLastProfileString( _T("LastPassword"), strLastValue );
   if( !strLastValue.GetLength( ) )
   {
      strLastValue   = _T("");
   }
   m_Password.SetWindowText( strLastValue );

   //*******************
   GetLastProfileString( _T("UseOpen"), strLastValue );
   if( !strLastValue.CompareNoCase( _T("No") ) )
   {
      m_UseOpen.SetCheck( 0 );
   }
   else
   {
      m_UseOpen.SetCheck( 1 );
   }

   //*******************
   GetLastProfileString( _T("Secure"), strLastValue );
   if( !strLastValue.CompareNoCase( _T("No") ) )
   {
      m_Secure.SetCheck( 0 );
   }
   else
   {
      m_Secure.SetCheck( 1 );
   }

   //*******************
   GetLastProfileString( _T("Encryption"), strLastValue );
   if( !strLastValue.CompareNoCase( _T("No") ) )
   {
      m_Encryption.SetCheck( 0 );
   }
   else
   {
      m_Encryption.SetCheck( 1 );
   }

   //*******************
   GetLastProfileString( _T("UseExtendedSyntax"), strLastValue );
   if( !strLastValue.CompareNoCase( _T("Yes") ) )
   {
      m_UseExtendedSyntax.SetCheck( 1 );
   }
   else
   {
      m_UseExtendedSyntax.SetCheck( 0 );
   }


	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\objprops.h ===
// ObjectProps.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CObjectProps form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CObjectProps : public CFormView
{
protected:
	CObjectProps();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CObjectProps)

// Form Data
public:
	//{{AFX_DATA(CObjectProps)
	enum { IDD = IDD_SCHEMA };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CObjectProps)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CObjectProps();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CObjectProps)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Viewex.rc
//
#define IDR_COLORTYPE                   4
#define IDR_INPUTTYPE                   5
#define IDR_SPLIT2TYPE                  6
#define IDR_SPLIT3TYPE                  7
#define IDR_QUERYVIEW                   7
#define IDC_EDIT1                       100
#define IDC_QUERY                       101
#define IDC_ATTRIBUTES                  102
#define IDC_SCOPE                       103
#define IDD_SCHEMA                      104
#define IDD_FILTER                      105
#define IDD_QUERYSTATUS                 106
#define IDD_OLEDSPATH                   107
#define IDD_DEBUG                       109
#define IDD_CREATEITEM                  110
#define IDD_GROUPCREATEITEM             111
#define IDD_GROUPDELETEITEM             112
#define IDD_DELETEITEM                  113
#define IDD_COPYITEM                    114
#define IDD_MOVEITEM                    115
#define IDD_TYPEADDITEM                 116
#define IDD_TYPEDELETEITEM              117
#define IDD_ERRORPUTPROP                119
#define IDB_USER                        120
#define IDB_DOMAIN                      121
#define IDB_COMPUTER                    122
#define IDB_PRINTQUEUE                  123
#define IDB_DUMMY                       124
#define IDB_FILESHARE                   125
#define IDR_MAINFRAME                   128
#define IDB_GROUP                       128
#define IDR_TEXTTYPE                    129
#define IDB_SERVICE                     130
#define IDB_PRINTJOB                    132
#define IDB_SESSION                     133
#define IDB_RESOURCE                    134
#define IDD_SETPROPERTIES               135
#define IDB_ROOT                        137
#define IDB_ORGANISATION                138
#define IDB_ORGANISATIONUNIT            139
#define IDB_NAMESPACES                  140
#define IDB_NAMESPACE                   141
#define IDB_NDS_DIRECTORY_MAP           142
#define IDB_NDS_DISTRIBUTION_LIST       143
#define IDB_NDS_ALIAS                   144
#define IDB_NDS_AFP_SERVER              145
#define IDB_NDS_COMMUNICATIONS_SERVER   146
#define IDB_NDS_MESSAGE_ROUTING_GROUP   147
#define IDB_NDS_NETWARE_SERVER          148
#define IDB_NDS_ORGANIZATIONAL_ROLE     149
#define IDB_NDS_PRINT_QUEUE             150
#define IDB_NDS_PRINT_SERVER            151
#define IDB_NDS_PROFILE                 152
#define IDB_NDS_VOLUME                  153
#define IDB_CLASS                       155
#define IDB_PROPERTY                    156
#define IDB_SYNTAX                      157
#define IDD_CALLMETHOD                  158
#define IDD_COLLECTION                  159
#define IDI_ICON1                       161
#define IDD_QUERYVIEW                   162
#define IDD_NEWQUERY                    163
#define IDD_SEARCHPREFERENCES           165
#define IDD_ADDPROPERTY                 166
#define IDD_DIALOG1                     167
#define IDD_ADDACEDLG                   167
#define IDD_DELETESTATUS                168
#define IDC_RADIO1                      201
#define IDC_RADIO2                      202
#define IDC_RADIO3                      203
#define IDC_RADIO_DELET_VALUES          204
#define IDM_CHANGEDATA                  1001
#define IDC_GROUPBOX1                   1005
#define IDC_PROPERTIES                  1025
#define IDAPPLY                         1026
#define IDRELOAD                        1027
#define IDC_PROPLIST                    1030
#define IDC_PROPVALUE                   1031
#define IDC_CLASSTYPE                   1033
#define IDC_CLSID                       1034
#define IDC_PRIMARYINTERFACE            1035
#define IDC_DERIVEDFROM                 1036
#define IDC_CONTAINEMENT                1037
#define IDC_CONTAINER                   1038
#define IDC_HELPFILENAME                1039
#define IDC_HELPFILECONTEXT             1040
#define IDC_ITEMOLEDSPATH               1041
#define IDC_PROPERTYTYPE                1042
#define IDC_DISPLAYTHIS                 1043
#define IDC_DONOTDISPLAYTHIS            1044
#define IDC_TODISPLAY                   1045
#define IDC_TONOTDISPLAY                1046
#define IDS_USER                        1047
#define IDS_GROUP                       1048
#define IDS_PRINTQUEUE                  1049
#define IDS_SERVICE                     1050
#define IDS_FILESERVICE                 1051
#define IDC_FUNCSETCLSID                1051
#define IDS_COMPUTER                    1052
#define IDC_FUNCSETPRIMARYINTERFACE     1052
#define IDC_ITEMSTODISPLAY              1053
#define IDC_FUNCSETDERIVEDFROM          1053
#define IDS_OTHEROBJECTS                1054
#define IDC_PROPERTYMINRANGE            1056
#define IDC_PROPERTYMAXRANGE            1057
#define IDC_PROPERTYNORMAL              1058
#define IDC_PROPERTYOPTIONAL            1059
#define IDC_FUNCSETHELPFILENAME2        1060
#define IDC_OLEDSPATH                   1060
#define IDC_FUNCSETHELPFILECONTEXT      1061
#define IDC_PROMPTPUTPROPERTY           1061
#define IDC_PROMPTGETPROPERTY2          1062
#define IDC_RELATIVENAME                1062
#define IDC_CLASS                       1063
#define IDC_ITEMNAME                    1064
#define IDC_PARENTNAME                  1065
#define IDC_PARENT                      1066
#define IDC_SOURCE                      1067
#define IDC_DESTINATION                 1068
#define IDC_USER                        1068
#define IDC_ITEMTYPE                    1069
#define IDC_ERROROPERATION              1070
#define IDC_ERRORFUNCTIONALSET          1071
#define IDC_ERRORVALUE                  1072
#define IDC_ERRORRESULT                 1073
#define IDC_MULTIVALUED                 1075
#define IDC_PROPOID                     1076
#define IDC_PROPDSNAMES                 1077
#define IDC_CLASSOID                    1078
#define IDC_CLASSABSTRACT               1079
#define IDC_PROPERTYMANDATORY           1080
#define IDC_COLLECTONITEMSLIST          1082
#define IDC_ADD                         1083
#define IDC_REMOVE                      1084
#define IDC_REFRESH                     1085
#define IDC_METHOD                      1086
#define IDC_PARAM1                      1087
#define IDC_PARAM2                      1088
#define IDC_PARAM3                      1089
#define IDC_PARAM4                      1090
#define IDC_PARAM5                      1091
#define IDC_PARAM6                      1092
#define IDE_PARAM1                      1093
#define IDE_PARAM2                      1094
#define IDE_PARAM3                      1095
#define IDE_PARAM4                      1096
#define IDE_PARAM5                      1097
#define IDE_PARAM6                      1098
#define IDC_METHOD1                     2000
#define IDD_ABOUTBOX                    2000
#define IDC_METHOD2                     2001
#define IDD_INPUTFORM                   2001
#define IDC_METHOD3                     2002
#define IDD_CHANGEDATA                  2002
#define IDC_METHOD4                     2003
#define IDC_METHOD5                     2004
#define IDC_METHOD6                     2005
#define IDC_METHOD7                     2006
#define IDC_METHOD8                     2007
#define IDC_CLEAR                       2009
#define IDC_APPEND                      2010
#define IDC_CHANGE                      2011
#define IDC_PASSWORD                    2012
#define IDC_OPENAS                      2013
#define IDC_USEOPEN                     2015
#define IDC_SECUREAUTHENTICATION        2016
#define IDC_ENCRYPTION                  2017
#define IDC_ENCRYPT                     2018
#define IDC_COMBO1                      2019
#define IDC_NEWPROPERTYTYPE             2019
#define IDC_ACELIST                     2019
#define IDC_USESQL                      2025
#define IDC_USEEXTENDEDSYNTAX           2026
#define IDC_USESEARCH                   2027
#define IDC_ASYNCHRONOUS                2028
#define IDC_DEREF_ALIASES               2029
#define IDC_SIZE_LIMIT                  2030
#define IDC_TIME_LIMIT                  2031
#define IDC_ATTR_ONLY                   2032
#define IDC_TIME_OUT                    2034
#define IDC_PAGE_SIZE                   2035
#define IDC_NEWPROPERTYMULTIVALUED      2038
#define IDC_NEWPROPERTYNAME             2040
#define IDC_NEWPROPERTYVALUE            2041
#define IDC_ADDPROPERTY                 2042
#define IDC_GETPROPERTY                 2044
#define IDC_PUTPROPERTY                 2045
#define IDC_STATICCLASS                 2046
#define IDC_STATICCLSID                 2047
#define IDC_STATICPRIMARYINTERFACE      2048
#define IDC_STATICDERIVEDFROM           2049
#define IDC_GBSECURITYDESCRIPTORSTATIC  2050
#define IDC_GBACCESSCONTROLENTRIES      2051
#define IDC_SECURITYDESCRIPTORPROPERTIES 2053
#define IDC_SECURITYDESCRIPTORPROPERTYVALUE 2054
#define IDC_ACEPROPERTIESLIST           2055
#define IDC_ACEPROPERTYVALUE            2056
#define IDC_STATICCONTAINMENT           2057
#define IDC_STATICCONTAINER             2058
#define IDC_STATICHELPFILENAME          2059
#define IDC_STATICSTATICHELPFILECONTEXT 2060
#define IDC_STATICOID                   2061
#define IDC_STATICABSTRACT              2062
#define IDC_DACLSACL_LIST               2063
#define IDC_CHASE_REFERRALS             2064
#define IDC_COPYACE                     2066
#define IDC_PASTEACE                    2067
#define IDC_DELACE                      2068
#define IDC_ADDACE                      2069
#define IDC_TRUSTEE                     2070
#define IDC_COPYACL                     2071
#define IDC_PASTEACL                    2072
#define IDC_COPYSD                      2073
#define IDC_PASTESD                     2074
#define IDC_RADIO_CLEAR_VALUE           2075
#define IDC_RADIO_UPDATE_VALUE          2076
#define IDC_RADIO_ADD_VALUES            2077
#define IDC_DELETE                      2078
#define IDC_DELETERECURSIVE             2079
#define IDC_CURRENTDELETEOBJECT         2080
#define IDC_DELETESTATUS                2081
#define IDM_FILTER                      32769
#define IDM_DISABLEFILTER               32770
#define IDM_ADD                         32771
#define IDM_DELETE                      32772
#define IDM_MOVEITEM                    32773
#define IDM_COPYITEM                    32774
#define IDM_REFRESH                     32775
#define IDM_USEGENERIC                  32776
#define IDM_NEWQUERY                    32777
#define IDM_USEGETEXPUTEX               32778
#define IDM_USEPROPERTIESLIST           32779

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        169
#define _APS_NEXT_COMMAND_VALUE         32780
#define _APS_NEXT_CONTROL_VALUE         2082
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\qstatus.h ===
// QueryStatus.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueryStatus dialog

#ifndef __QSTATUS_H__
#define __QSTATUS_H__

class CQueryStatus : public CDialog
{
// Construction
public:
	CQueryStatus(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CQueryStatus)
	enum { IDD = IDD_QUERYSTATUS };
	//}}AFX_DATA

public:
   void  SetAbortFlag   ( BOOL*      );
   void  IncrementType  ( DWORD, BOOL );
   
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQueryStatus)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CQueryStatus)
	virtual BOOL OnInitDialog();
	afx_msg void OnStop();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
   void  DisplayStatistics( );

protected:
   int   m_nUser;
   int   m_nGroup;
   int   m_nComputer;
   int   m_nService;
   int   m_nFileService;
   int   m_nPrintQueue;
   int   m_nToDisplay;
   int   m_nOtherObjects;

   BOOL* m_pbAbort;  

};
/////////////////////////////////////////////////////////////////////////////
// CDeleteStatus dialog

class CDeleteStatus : public CDialog
{
// Construction
public:
	CDeleteStatus(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteStatus)
	enum { IDD = IDD_DELETESTATUS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteStatus)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

   public:
      void  SetAbortFlag         ( BOOL*     );
      void  SetCurrentObjectText ( TCHAR*    );
      void  SetStatusText        ( TCHAR*    );

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteStatus)
	afx_msg void OnStop();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
   BOOL* m_pbAbort;  
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\schemavw.cpp ===
// schemavw.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "cacls.h"
#include "schemavw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern   IDispatch*  pACEClipboard;
extern   IDispatch*  pACLClipboard;
extern   IDispatch*  pSDClipboard;

/////////////////////////////////////////////////////////////////////////////
// CSchemaView

IMPLEMENT_DYNCREATE(CSchemaView, CFormView)

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CSchemaView::CSchemaView()
	: CFormView(CSchemaView::IDD)
{
	//{{AFX_DATA_INIT(CSchemaView)
	//}}AFX_DATA_INIT

   int nIdx;

   m_nProperty    = -1;
   m_bDirty       = FALSE;
   m_bInitialized = FALSE;
   pSecurityDescriptor  = NULL;

   m_nLastSD         = -1;
   m_nLastSDValue    = -1;
   m_nLastACE        = -1;
   m_nLastACEValue   = -1;
   m_nLastACL        = acl_Invalid;
   m_bACLDisplayed   = FALSE;


   for( nIdx = 0; nIdx < 32 ; nIdx++ )
   {
      m_arrNormalControls[ 32 ]     = -1;
      m_arrSecurityControls[ 32 ]   = -1;
   }

   nIdx  = 0;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICCLASS;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICCLSID;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICPRIMARYINTERFACE;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICDERIVEDFROM;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICCONTAINMENT;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICCONTAINER;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICHELPFILENAME;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICSTATICHELPFILECONTEXT;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICOID;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICABSTRACT;

   m_arrNormalControls[ nIdx++ ] = IDC_CLASSTYPE;
   m_arrNormalControls[ nIdx++ ] = IDC_CLSID;
   m_arrNormalControls[ nIdx++ ] = IDC_PRIMARYINTERFACE;
   m_arrNormalControls[ nIdx++ ] = IDC_DERIVEDFROM;
   m_arrNormalControls[ nIdx++ ] = IDC_CONTAINEMENT;
   m_arrNormalControls[ nIdx++ ] = IDC_CONTAINER;
   m_arrNormalControls[ nIdx++ ] = IDC_HELPFILENAME;
   m_arrNormalControls[ nIdx++ ] = IDC_HELPFILECONTEXT;
   m_arrNormalControls[ nIdx++ ] = IDC_CLASSOID;
   m_arrNormalControls[ nIdx++ ] = IDC_CLASSABSTRACT;

   nIdx  = 0;
   m_arrSecurityControls[ nIdx++ ]  = IDC_GBSECURITYDESCRIPTORSTATIC;
   m_arrSecurityControls[ nIdx++ ]  = IDC_SECURITYDESCRIPTORPROPERTIES;
   m_arrSecurityControls[ nIdx++ ]  = IDC_SECURITYDESCRIPTORPROPERTYVALUE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_GBACCESSCONTROLENTRIES;
   m_arrSecurityControls[ nIdx++ ]  = IDC_DACLSACL_LIST;
   m_arrSecurityControls[ nIdx++ ]  = IDC_ACELIST;
   m_arrSecurityControls[ nIdx++ ]  = IDC_ACEPROPERTIESLIST;
   m_arrSecurityControls[ nIdx++ ]  = IDC_ACEPROPERTYVALUE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_COPYACE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_PASTEACE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_DELACE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_ADDACE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_COPYACL;
   m_arrSecurityControls[ nIdx++ ]  = IDC_PASTEACL;
   m_arrSecurityControls[ nIdx++ ]  = IDC_COPYSD;
   m_arrSecurityControls[ nIdx++ ]  = IDC_PASTESD;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CSchemaView::~CSchemaView()
{
   if( NULL != pSecurityDescriptor )
   {
      m_pDescriptor->Release( );
      delete pSecurityDescriptor;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSchemaView)
	DDX_Control(pDX, IDC_CLASSOID, m_ClassOID);
	DDX_Control(pDX, IDC_CLASSABSTRACT, m_Abstract);
	DDX_Control(pDX, IDC_MULTIVALUED, m_MultiValued);
	DDX_Control(pDX, IDC_PROPDSNAMES, m_DsNames);
	DDX_Control(pDX, IDC_PROPOID, m_PropOID);
	DDX_Control(pDX, IDC_PROPERTYMANDATORY, m_Mandatory);
	DDX_Control(pDX, IDC_CONTAINEMENT, m_Containment);
	DDX_Control(pDX, IDC_ITEMOLEDSPATH, m_ItemOleDsPath);
	DDX_Control(pDX, IDC_PROPERTYMINRANGE, m_PropertyMinRange);
	DDX_Control(pDX, IDC_PROPERTYMAXRANGE, m_PropertyMaxRange);
	DDX_Control(pDX, IDC_PROPERTYTYPE, m_PropertyType);
	DDX_Control(pDX, IDC_PRIMARYINTERFACE, m_PrimaryInterface);
	DDX_Control(pDX, IDC_HELPFILECONTEXT, m_HelpFileContext);
	DDX_Control(pDX, IDC_DERIVEDFROM, m_DerivedFrom);
	DDX_Control(pDX, IDC_HELPFILENAME, m_HelpFileName);
	DDX_Control(pDX, IDC_CLSID, m_CLSID);
	DDX_Control(pDX, IDC_CONTAINER, m_Container);
	DDX_Control(pDX, IDC_CLASSTYPE, m_ClassType);
	DDX_Control(pDX, IDC_PROPVALUE, m_PropValue);
	DDX_Control(pDX, IDC_PROPLIST, m_PropList);
	//DDX_Control(pDX, IDC_PROPERTIES, m_Schema);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSchemaView, CFormView)
	//{{AFX_MSG_MAP(CSchemaView)
	ON_CBN_SELCHANGE(IDC_PROPLIST, OnSelchangeProplist)
	ON_BN_CLICKED(IDRELOAD, OnReload)
	ON_BN_CLICKED(IDAPPLY, OnApply)
	ON_EN_SETFOCUS(IDC_PROPVALUE, OnSetfocusPropvalue)
	ON_BN_CLICKED(IDC_METHOD1, OnMethod1)
	ON_BN_CLICKED(IDC_METHOD2, OnMethod2)
	ON_BN_CLICKED(IDC_METHOD3, OnMethod3)
	ON_BN_CLICKED(IDC_METHOD4, OnMethod4)
	ON_BN_CLICKED(IDC_METHOD5, OnMethod5)
	ON_BN_CLICKED(IDC_METHOD6, OnMethod6)
	ON_BN_CLICKED(IDC_METHOD7, OnMethod7)
	ON_BN_CLICKED(IDC_METHOD8, OnMethod8)
	ON_BN_CLICKED(IDC_APPEND, OnAppend)
   ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_BN_CLICKED(IDC_CHANGE, OnChange)
	ON_BN_CLICKED(IDC_CLEAR, OnClear)
	ON_BN_CLICKED(IDC_GETPROPERTY, OnGetProperty)
	ON_BN_CLICKED(IDC_PUTPROPERTY, OnPutProperty)
	ON_CBN_SELCHANGE(IDC_ACELIST, OnACEChange)
	ON_CBN_SELCHANGE(IDC_ACEPROPERTIESLIST, OnACEPropertyChange)
	ON_CBN_SELCHANGE(IDC_DACLSACL_LIST, OnACLChange)
	ON_CBN_SELCHANGE(IDC_SECURITYDESCRIPTORPROPERTIES, OnSDPropertyChange)
	ON_BN_CLICKED(IDC_ADDACE, OnAddACE)
	ON_BN_CLICKED(IDC_COPYACE, OnCopyACE)
	ON_BN_CLICKED(IDC_PASTEACE, OnPasteACE)
	ON_BN_CLICKED(IDC_DELACE, OnRemoveACE)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSchemaView diagnostics

#ifdef _DEBUG
void CSchemaView::AssertValid() const
{
	CFormView::AssertValid();
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSchemaView message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::ResetObjectView( )
{
   COleDsObject*  pObject;
   int            nIndex;
   TC_ITEM        tcItem;
   CString        strName;
   CString        strMethCount;
   CString        strMethName;
   int            nMethCount;
   CHAR           szText[ 128 ];
   int            nFirst = 0;

   pObject   = GetDocument( )->GetCurrentObject( );
   if( NULL == pObject )
      return;

   //m_Schema.DeleteAllItems( );
   m_PropList.ResetContent( );

   memset( &tcItem, 0, sizeof(tcItem) );
   tcItem.mask       = TCIF_TEXT;
   tcItem.pszText    = (LPTSTR)szText;
   strName           = _T("");
   tcItem.pszText    = strName.GetBuffer( 128 );

   //bRez     = m_Schema.InsertItem( nIndex, &tcItem );

   // next, we'll get methods count/names
   nIndex   = 0;

   strMethCount   = pObject->GetAttribute( ca_MethodsCount );
   nMethCount     = _ttoi( strMethCount.GetBuffer( 128 ) );
   for( nIndex = 0; nIndex < nMethCount && nIndex < 8; nIndex++ )
   {
      GetDlgItem( nIndex + IDC_METHOD1 )->ShowWindow( SW_SHOW );
      GetDlgItem( nIndex + IDC_METHOD1 )->SetWindowText
            ( pObject->GetAttribute( nIndex, ma_Name ) );
   }

   for( ;nIndex < 8;nIndex++ )
   {
      GetDlgItem( nIndex + IDC_METHOD1 )->ShowWindow( SW_HIDE );
   }

   m_nProperty = -1;

   m_ItemOleDsPath.SetWindowText ( pObject->GetOleDsPath( ) );

   m_ClassType.SetWindowText     ( pObject->GetAttribute( ca_Name ) );
   m_CLSID.SetWindowText         ( pObject->GetAttribute( ca_CLSID ) );
   m_HelpFileName.SetWindowText  ( pObject->GetAttribute( ca_HelpFileName ) );
   m_HelpFileContext.SetWindowText ( pObject->GetAttribute( ca_HelpFileContext ) );
   m_PrimaryInterface.SetWindowText( pObject->GetAttribute( ca_PrimaryInterface ) );
   m_Containment.SetWindowText   ( pObject->GetAttribute( ca_Containment ) );
   m_Container.SetWindowText     ( pObject->GetAttribute( ca_Container ) );
   m_DerivedFrom.SetWindowText   ( pObject->GetAttribute( ca_DerivedFrom ) );
   m_ClassOID.SetWindowText      ( pObject->GetAttribute( ca_OID ) );
   m_Abstract.SetWindowText      ( pObject->GetAttribute( ca_Abstract ) );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
   if( !m_bInitialized )
   {
      return;
   }
   ResetObjectView( );

   DisplayPropertiesList( );
   m_PropList.SetCurSel( 0 );
   DisplayCurrentPropertyText( );
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::DisplayPropertiesList( )
{
	// TODO: Add your control notification handler code here
	int            nItems, nIter;
   COleDsObject*  pObject;
   CString        strPropName;
   CString        strPropValue;

   PutPropertyValue( );

   pObject  = GetDocument( )->GetCurrentObject( );
   if( NULL == pObject )
   {
      return;
   }

   m_PropList.ResetContent( );

   nItems   = pObject->GetPropertyCount( );

   for( nIter = 0; nIter < nItems ; nIter++ )
   {
      int   nIdx;

      strPropName = pObject->GetAttribute( nIter, pa_DisplayName );
      nIdx  = m_PropList.AddString( strPropName );
      m_PropList.SetItemData( nIdx, (DWORD)nIter );
   }

   m_PropValue.SetWindowText( _T("") );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::DisplayCurrentPropertyText()
{
	// TODO: Add your control notification handler code here
   int            nProp;
   COleDsObject*  pObject;
   HRESULT        hResult;
   CString        strPropValue, strTemp;
   CString        strName;
   BOOL           bSecurityDescriptor  = FALSE;
//   BOOL           bIsACL;

   nProp       = m_PropList.GetCurSel( );
   if( CB_ERR == nProp  )
   {
      return;
   }

   m_nProperty = nProp;

   pObject     = GetDocument()->GetCurrentObject( );
   hResult     = pObject->GetProperty( nProp, strPropValue, &bSecurityDescriptor );

   m_PropValue.SetWindowText( strPropValue );

   //*************

   strName  = pObject->GetAttribute( nProp, pa_Name );

   strTemp  = pObject->GetAttribute( nProp, pa_Type );
   m_PropertyType.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_MinRange );
   m_PropertyMinRange.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_MaxRange );
   m_PropertyMaxRange.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_MultiValued );
   m_MultiValued.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_OID );
   m_PropOID.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_DsNames );
   m_DsNames.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_Mandatory );
   m_Mandatory.SetWindowText( strTemp );

   strTemp  = pObject->GetAttribute( nProp, pa_Type );
   if( bSecurityDescriptor )
   {
      // we need to display the security descriptor stuff...
      if( !m_bACLDisplayed )
      {
         HideControls( TRUE );
         ShowControls( FALSE );
      }
	  if( NULL != pSecurityDescriptor )
	  {
		delete pSecurityDescriptor;
	  }
      if( NULL != m_pDescriptor )
	  {
		m_pDescriptor->Release( );	
	  }
      m_bACLDisplayed   = TRUE;
      DisplayACL( pObject, strName );
   }
   else
   {
      if( m_bACLDisplayed )
      {
         HideControls( FALSE );
         ShowControls( TRUE );
         delete pSecurityDescriptor;
         m_pDescriptor->Release( );
      }
      m_bACLDisplayed      = FALSE;
      m_pDescriptor        = NULL;
      pSecurityDescriptor  = NULL;

   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnSelchangeProplist()
{
	// TODO: Add your control notification handler code here
   PutPropertyValue( );
   DisplayCurrentPropertyText( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnReload()
{
   HRESULT        hResult;
   COleDsObject*  pObject;
   HCURSOR        aCursor, oldCursor;

   pObject  = GetDocument()->GetCurrentObject( );

   if( NULL == pObject )
   {
      return;
   }

   aCursor     = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( aCursor );

   hResult  = pObject->GetInfo( );

   DisplayPropertiesList( );

   if( -1 != m_nProperty )
   {
      m_PropList.SetCurSel( m_nProperty );
   }
   else
   {
      m_PropList.SetCurSel( 0 );
   }

   DisplayCurrentPropertyText( );

   m_bDirty = FALSE;

   SetCursor( oldCursor );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CSchemaView::PutPropertyValue()
{
   COleDsObject*  pObject;
   HRESULT        hResult;
   CString        strPropValue;

   // if we're displaying security descriptors, we'll force the dirty flag
   m_bDirty = m_bDirty || (NULL != pSecurityDescriptor);

   if( -1 == m_nProperty || !m_bDirty )
   {
      return S_OK;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return S_OK;

   if( NULL != pSecurityDescriptor )
   {
      // OK, so we need to set the security descriptor
      VARIANT     var;
      IUnknown*   pUnk;
      IADs*       pADs;
      CString     strName;
      BSTR        bstrName;

      strName  = pObject->GetAttribute( m_nProperty, pa_Name );
      bstrName = AllocBSTR( strName.GetBuffer( 128 ) );

      VariantInit( &var );
      V_VT( &var )         = VT_DISPATCH;
      V_DISPATCH( &var )   = m_pDescriptor;
      m_pDescriptor->AddRef( );

      pObject->GetInterface( &pUnk );
      pUnk->QueryInterface( IID_IADs, (void**)&pADs );

      hResult  = pADs->Put( bstrName, var );

      SysFreeString( bstrName );

      VariantClear( &var );

      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
   }
   else
   {
      m_PropValue.GetWindowText( strPropValue );

      hResult  = pObject->PutProperty( m_nProperty,
                                       strPropValue );
   }

   m_bDirty = FALSE;

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnApply()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;
   HCURSOR        aCursor, oldCursor;

   pObject  = GetDocument()->GetCurrentObject( );

   if( NULL == pObject )
   {
      return;
   }

   aCursor        = LoadCursor( NULL, IDC_WAIT );
   oldCursor      = SetCursor( aCursor );

   hResult        = PutPropertyValue( );

   hResult        = pObject->SetInfo( );
   //hResult        = pObject->GetInfo( );

   m_bDirty       = FALSE;

   DisplayPropertiesList( );

   if( -1 != m_nProperty )
   {
      m_PropList.SetCurSel( m_nProperty );
   }
   else
   {
      m_PropList.SetCurSel( 0 );
   }

   DisplayCurrentPropertyText( );

   SetCursor( oldCursor );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod1()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 0 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod2()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 1 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod3()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 2 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod4()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 3 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod5()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 4 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod6()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 5 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod7()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 6 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod8()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 7 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnSetfocusPropvalue()
{
	// TODO: Add your control notification handler code here
	m_bDirty = TRUE;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnInitialUpdate()
{
	m_bInitialized   = TRUE;

   CFormView::OnInitialUpdate();
	// TODO: Add your specialized code here and/or call the base class

   HideControls( FALSE );
   ShowControls( TRUE );
   m_bACLDisplayed   = FALSE;

   OnUpdate( NULL, 0L, NULL);
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::ShowControls( BOOL bNormal )
{
   int*  pControlArray;
   int   nIdx;

   pControlArray  = bNormal ? m_arrNormalControls : m_arrSecurityControls;
   for( nIdx = 0; nIdx < 32 ; nIdx++ )
   {
      CWnd* pWnd;

      if( pControlArray[ nIdx ] > 0 )
      {
         pWnd  = GetDlgItem( pControlArray[ nIdx ] );
         if( NULL != pWnd )
         {
            pWnd->ShowWindow( SW_SHOW );
         }
      }
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::HideControls(BOOL bNormal)
{
   int*  pControlArray;
   int   nIdx;

   pControlArray  = bNormal ? m_arrNormalControls : m_arrSecurityControls;
   for( nIdx = 0; nIdx < 32 ; nIdx++ )
   {
      CWnd* pWnd;

      if( pControlArray[ nIdx ] > 0 )
      {
         pWnd  = GetDlgItem( pControlArray[ nIdx ] );
         if( NULL != pWnd )
         {
            pWnd->ShowWindow( SW_HIDE );
         }
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnAppend()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   CString        strPropValue;
   COleDsObject*  pObject;

   if( -1 == m_nProperty )
   {
      return;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;


   m_PropValue.GetWindowText( strPropValue );
   hResult     = pObject->PutProperty(
                                       (int)( m_PropList.GetItemData( m_nProperty ) ),
                                       strPropValue,
                                       ADS_ATTR_APPEND
                                     );
   m_bDirty    = FALSE;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnDelete()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   CString        strPropValue;
   COleDsObject*  pObject;

   if( -1 == m_nProperty )
   {
      return;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;


   m_PropValue.GetWindowText( strPropValue );
   hResult     = pObject->PutProperty(
                                       (int)( m_PropList.GetItemData( m_nProperty ) ),
                                       strPropValue,
                                       ADS_ATTR_DELETE
                                     );
   m_bDirty    = FALSE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnChange()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   CString        strPropValue;
   COleDsObject*  pObject;

   if( -1 == m_nProperty )
   {
      return;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;


   m_PropValue.GetWindowText( strPropValue );
   hResult     = pObject->PutProperty(
                                      (int)( m_PropList.GetItemData( m_nProperty ) ),
                                      strPropValue,
                                      ADS_PROPERTY_UPDATE );
   m_bDirty = TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnClear()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   CString        strPropValue;
   COleDsObject*  pObject;

   if( -1 == m_nProperty  )
   {
      return;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;


   m_PropValue.GetWindowText( strPropValue );
   hResult     = pObject->PutProperty(
                                      (int)( m_PropList.GetItemData( m_nProperty ) ),
                                      strPropValue,
                                      ADS_PROPERTY_CLEAR );
   m_bDirty = FALSE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnGetProperty()
{
	// TODO: Add your control notification handler code here
   CPropertyDialog   pPropDialog;
   COleDsObject*     pObject;
   HRESULT           hResult;
   CString           strValue;

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;

   //pPropDialog.PutFlag( FALSE );
   if( pPropDialog.DoModal( ) != IDOK )
      return;


   hResult  = pObject->GetProperty( pPropDialog.m_PropertyName,
                                    strValue,
                                    TRUE,
                                    ADsTypeFromString( pPropDialog.m_PropertyType ) );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnPutProperty()
{
	// TODO: Add your control notification handler code here
// TODO: Add your control notification handler code here
   CPropertyDialog   pPropDialog;
   COleDsObject*     pObject;
   HRESULT           hResult;
   CString           strValue;

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;

   //pPropDialog.PutFlag( FALSE );
   if( pPropDialog.DoModal( ) != IDOK )
      return;

   hResult  = pObject->PutProperty( pPropDialog.m_PropertyName,
                                    pPropDialog.m_PropertyValue,
                                    TRUE,
                                    ADsTypeFromString( pPropDialog.m_PropertyType ) );
}

/////////////////////////////////////////////////////////////////////////////
// CSetMandatoryProperties dialog


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CSetMandatoryProperties::CSetMandatoryProperties(CWnd* pParent /*=NULL*/)
	: CDialog(CSetMandatoryProperties::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSetMandatoryProperties)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_nFuncSet     = -1;
   m_nProperty    = -1;
   m_bDirty       = FALSE;
   m_bInitialized = FALSE;
   m_pObject      = NULL;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSetMandatoryProperties)
   DDX_Control(pDX, IDC_CONTAINEMENT, m_Containment);
	DDX_Control(pDX, IDC_ITEMOLEDSPATH, m_ItemOleDsPath);
	DDX_Control(pDX, IDC_PROPERTYOPTIONAL, m_PropertyOptional);
	DDX_Control(pDX, IDC_PROPERTYNORMAL, m_PropertyNormal);
	DDX_Control(pDX, IDC_PROPERTYMINRANGE, m_PropertyMinRange);
	DDX_Control(pDX, IDC_PROPERTYMAXRANGE, m_PropertyMaxRange);
	DDX_Control(pDX, IDC_PROPERTYTYPE, m_PropertyType);
	DDX_Control(pDX, IDC_PRIMARYINTERFACE, m_PrimaryInterface);
	DDX_Control(pDX, IDC_HELPFILECONTEXT, m_HelpFileContext);
	DDX_Control(pDX, IDC_DERIVEDFROM, m_DerivedFrom);
	DDX_Control(pDX, IDC_HELPFILENAME, m_HelpFileName);
	DDX_Control(pDX, IDC_CLSID, m_CLSID);
	DDX_Control(pDX, IDC_CONTAINER, m_Container);
	DDX_Control(pDX, IDC_CLASSTYPE, m_ClassType);
	DDX_Control(pDX, IDC_PROPVALUE, m_PropValue);
	DDX_Control(pDX, IDC_PROPLIST, m_PropList);
	DDX_Control(pDX, IDC_PROPERTIES, m_Schema);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSetMandatoryProperties, CDialog)
	//{{AFX_MSG_MAP(CSetMandatoryProperties)
   ON_NOTIFY(TCN_SELCHANGE, IDC_PROPERTIES, OnSelchangeProperties)
	ON_CBN_SELCHANGE(IDC_PROPLIST, OnSelchangeProplist)
	ON_EN_SETFOCUS(IDC_PROPVALUE, OnSetfocusPropvalue)
	ON_BN_CLICKED(IDOK, OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSetMandatoryProperties message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::SetOleDsObject( COleDsObject* pObject )
{
   m_pObject   = pObject;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::OnSelchangeProperties(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
	int            nSel, nItems, nIter;
   CString        strPropName;
   CString        strPropValue;
   CString        strMandatory;

	*pResult = 0;

   PutPropertyValue( );
   nSel        = m_Schema.GetCurSel( );
   if( nSel == LB_ERR )
   {
      return;
   }
   m_nFuncSet  = nSel;
   m_nProperty = -1;

   m_PropList.ResetContent( );

   nItems   = m_pObject->GetPropertyCount( );

   for( nIter = 0; nIter < nItems ; nIter++ )
   {
      int   nIdx;

      strMandatory   = m_pObject->GetAttribute( nIter, pa_Mandatory );
      if( strMandatory == _T("Yes") )
      //if( TRUE )
      {
         strPropName = m_pObject->GetAttribute( nIter, pa_DisplayName );
         nIdx  = m_PropList.AddString( strPropName );
         m_PropList.SetItemData( nIdx, nIter );
      }
   }

   m_PropList.SetCurSel( 0 );

   OnSelchangeProplist( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::OnSelchangeProplist()
{
	// TODO: Add your control notification handler code here
   int            nMandProp, nProp, nFuncSet;
   HRESULT        hResult;
   CString        strPropValue;
   CString        strTemp;


   PutPropertyValue( );
   m_PropValue.SetWindowText( _T("") );
   nProp       = m_PropList.GetCurSel( );
   nMandProp   = (int)m_PropList.GetItemData( nProp );
   nFuncSet    = m_Schema.GetCurSel( );

   if( CB_ERR == nProp  || CB_ERR == nFuncSet )
   {
      return;
   }

   m_nProperty = nProp;
   m_nFuncSet  = nFuncSet;

   hResult  = m_pObject->GetProperty( nMandProp, strPropValue );

   m_PropValue.SetWindowText( strPropValue );

   //******************
   strTemp  = m_pObject->GetAttribute( nMandProp, pa_Type );
   m_PropertyType.SetWindowText( strTemp );

   //******************
   strTemp  = m_pObject->GetAttribute( nMandProp, pa_MinRange );
   m_PropertyMinRange.SetWindowText( strTemp );

   //******************
   strTemp  = m_pObject->GetAttribute( nMandProp, pa_MaxRange );
   m_PropertyMaxRange.SetWindowText( strTemp );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::OnSetfocusPropvalue()
{
	// TODO: Add your control notification handler code here
	m_bDirty = TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::OnOK()
{
	// TODO: Add your control notification handler code here
   PutPropertyValue( );
   CDialog::OnOK( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CSetMandatoryProperties::PutPropertyValue()
{
   HRESULT        hResult;
   CString        strPropValue;

   if( -1 == m_nProperty || -1 == m_nFuncSet || !m_bDirty )
   {
      return S_OK;
   }
   m_PropValue.GetWindowText( strPropValue );
   hResult  = m_pObject->PutProperty( (int)( m_PropList.GetItemData( m_nProperty ) ),
                                      strPropValue );
   m_bDirty = FALSE;

   return S_OK;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CSetMandatoryProperties::OnInitDialog()
{
   int         nIndex;
   TC_ITEM     tcItem;
   CString     strName;
   CHAR        szText[ 128 ];
   BOOL        bRez;
   LRESULT     lResult;

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
   m_Schema.DeleteAllItems( );

   memset( &tcItem, 0, sizeof(tcItem) );
   tcItem.mask       = TCIF_TEXT;
   tcItem.pszText    = (LPTSTR)szText;


   nIndex = 0;

   strName           = _T("");
   tcItem.pszText    = strName.GetBuffer( 128 );
   bRez              = m_Schema.InsertItem( nIndex, &tcItem );

   m_nFuncSet  = -1;
   m_nProperty = -1;
   m_Schema.SetCurSel( 0 );

   m_ItemOleDsPath.SetWindowText( m_pObject->GetOleDsPath( ) );

   m_ClassType.SetWindowText( m_pObject->GetAttribute( ca_Name ) );

   m_CLSID.SetWindowText( m_pObject->GetAttribute( ca_CLSID ) );

   m_HelpFileName.SetWindowText( m_pObject->GetAttribute( ca_HelpFileName ) );

   m_PrimaryInterface.SetWindowText( m_pObject->GetAttribute( ca_PrimaryInterface ) );

   m_Containment.SetWindowText( m_pObject->GetAttribute( ca_Containment ) );

   m_Container.SetWindowText  ( m_pObject->GetAttribute( ca_Container ) );

   m_DerivedFrom.SetWindowText( m_pObject->GetAttribute( ca_DerivedFrom ) );

   OnSelchangeProperties( NULL, &lResult );
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyDialog dialog


CPropertyDialog::CPropertyDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CPropertyDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPropertyDialog)
	m_PropertyName = _T("");
	m_PropertyType = _T("");
	m_PropertyValue = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CPropertyDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropertyDialog)
	DDX_CBString(pDX, IDC_NEWPROPERTYNAME, m_PropertyName);
	DDX_CBString(pDX, IDC_NEWPROPERTYTYPE, m_PropertyType);
	DDX_CBString(pDX, IDC_NEWPROPERTYVALUE, m_PropertyValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropertyDialog, CDialog)
	//{{AFX_MSG_MAP(CPropertyDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropertyDialog message handlers


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CPropertyDialog::OnInitDialog()
{
	
   CString     strLastValue;
   CComboBox*  pCombo;

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
   //*******************

   GetLRUList( IDC_NEWPROPERTYNAME,  _T("PropertyDialog_Name") );

	// TODO: Add extra initialization here
   //*******************
   pCombo   = (CComboBox*)GetDlgItem( IDC_NEWPROPERTYTYPE );
   pCombo->AddString( _T("ADSTYPE_DN_STRING") );
	pCombo->AddString( _T("ADSTYPE_CASE_EXACT_STRING") );
   pCombo->AddString( _T("ADSTYPE_CASE_IGNORE_STRING") );
	pCombo->AddString( _T("ADSTYPE_PRINTABLE_STRING") );
	pCombo->AddString( _T("ADSTYPE_NUMERIC_STRING") );
	pCombo->AddString( _T("ADSTYPE_BOOLEAN") );
	pCombo->AddString( _T("ADSTYPE_INTEGER") );
	pCombo->AddString( _T("ADSTYPE_OCTET_STRING") );
	pCombo->AddString( _T("ADSTYPE_UTC_TIME") );
	pCombo->AddString( _T("ADSTYPE_LARGE_INTEGER") );
	pCombo->AddString( _T("ADSTYPE_PROV_SPECIFIC") );

	
	// TODO: Add extra initialization here
   //*******************
   GetLRUList( IDC_NEWPROPERTYVALUE, _T("PropertyDialog_Value") );

   //GetLastProfileString( _T("PropertyDialog_IsMultiValued"),
   //                      strLastValue );
   //if( strLastValue.CompareNoCase( _T("Yes") ) )
   //{
      //m_Secure.SetCheck( 0 );
   //}

	return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CPropertyDialog::OnOK()
{
   // TODO: Add extra validation here
   //*******************
	GetDlgItemText( IDC_NEWPROPERTYNAME, m_PropertyName );
   SaveLRUList( IDC_NEWPROPERTYNAME,  _T("PropertyDialog_Name"), 20 );

	//*******************
   GetDlgItemText( IDC_NEWPROPERTYTYPE, m_PropertyType );

   //*******************
   GetDlgItemText( IDC_NEWPROPERTYVALUE, m_PropertyValue );
   SaveLRUList( IDC_NEWPROPERTYVALUE, _T("PropertyDialog_Value"), 20 );

   CDialog::OnOK();
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CPropertyDialog::SaveLRUList( int idCBox, TCHAR* pszSection, int nMax )
{
   CComboBox*  pCombo;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   CString     strText, strItem;
   int         nVal, nIdx, nItems;

   pCombo   = (CComboBox*)GetDlgItem( idCBox );
   pCombo->GetWindowText( strText );

   _tcscpy( szEntry, _T("Value_1") );

   if( strText.GetLength( ) )
   {
      WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strText, ADSVW_INI_FILE );
   }

   nItems   = pCombo->GetCount( );
   nVal     = 2;

   for( nIdx = 0; nItems != CB_ERR && nIdx < nItems && nIdx < nMax ; nIdx ++ )
   {
      pCombo->GetLBText( nIdx, strItem );

      if( strItem.CompareNoCase( strText ) )
      {
         _itot( nVal++, szIndex, 10 );
         _tcscpy( szEntry, _T("Value_") );
         _tcscat( szEntry, szIndex );
         WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strItem, ADSVW_INI_FILE );
      }
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CPropertyDialog::GetLRUList( int idCBox, TCHAR* pszSection )
{
   CComboBox*  pCombo;
   int         nIter;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   TCHAR       szValue[ 1024 ];

   pCombo   = (CComboBox*)GetDlgItem( idCBox );

   for( nIter = 0; nIter < 100 ; nIter++ )
   {
      _itot( nIter + 1, szIndex, 10 );
      _tcscpy( szEntry, _T("Value_") );
      _tcscat( szEntry, szIndex );
      GetPrivateProfileString( pszSection, szEntry,
                               _T(""), szValue, 1023, ADSVW_INI_FILE );
      if( _tcslen( szValue ) )
      {
         pCombo->AddString( szValue );
      }
   }

   pCombo->SetCurSel( 0 );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACL(COleDsObject * pObject, CString strAttrName)
{
   VARIANT     var;
   BSTR        bstrName;
   IADs*       pIADs = NULL;
   IUnknown*   pIUnk = NULL;
   HRESULT     hResult;

   while( TRUE )
   {
      hResult  = pObject->GetInterface( &pIUnk );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      hResult  = pIUnk->QueryInterface( IID_IADs, (void**)&pIADs );
      pIUnk->Release( );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      bstrName = AllocBSTR( strAttrName.GetBuffer( 128 ) );
      hResult  = pIADs->Get( bstrName, &var );
      SysFreeString( bstrName );
      pIADs->Release( );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      m_pDescriptor  = CopySD( V_DISPATCH( &var ) );
      VariantClear( &var );
      {
         IUnknown*   pIUnk;

         hResult  = m_pDescriptor->QueryInterface( IID_IUnknown,
                                                   (void**)&pIUnk );
         pSecurityDescriptor  = new CADsSecurityDescriptor( pIUnk );
		 pIUnk->Release( );
         pSecurityDescriptor->SetDocument( GetDocument( ) );
      }

      VariantClear( &var );



      FillACLControls( );

      break;
   }
}


//***********************************************************
//  Function:    CSchemaView::FillACLControls
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CSchemaView::FillACLControls()
{
   DisplaySDPropertiesList( 0 );

   DisplaySDPropertyValue( );

   DisplayACLNames( 0 );

   DisplayACENames( 0 );

   DisplayACEPropertiesList( 0 );

   DisplayACEPropertyValue( );


}


//***********************************************************
//  Function:    CSchemaView::DisplayACLNames
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACLNames( int nSelect )
{
   CComboBox*   pACLNames;

   pACLNames   = (CComboBox*)GetDlgItem( IDC_DACLSACL_LIST );
   pACLNames->ResetContent( );

   pACLNames->AddString( _T("DACL") );
   pACLNames->AddString( _T("SACL") );

   pACLNames->SetCurSel( nSelect );

   m_nLastACL  = GetCurrentACL( );
}


//***********************************************************
//  Function:    CSchemaView::DisplayACENames
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACENames( int nSelect )
{
   ACLTYPE                    eType;
   int                        nACECount, nIdx;
   CComboBox*                 pACENames;
   CString                    strACEName;
   CADsAccessControlEntry*    pACE;
   CADsAccessControlList*     pACL;

   eType       = GetCurrentACL( );

   pACENames   = (CComboBox*)GetDlgItem( IDC_ACELIST );
   pACENames->ResetContent( );

   pACL        = pSecurityDescriptor->GetACLObject( eType );
   if( NULL != pACL )
   {
	   nACECount   = pACL->GetACECount( );

	   for( nIdx = 0; nIdx < nACECount ; nIdx++ )
	   {
	      pACE        = pACL->GetACEObject( nIdx );
         if( NULL != pACE )
         {
            strACEName  = pACE->GetItemName(  );
            pACENames->AddString( strACEName );
         }
      }
   }

   m_nLastACE  = nSelect;

   pACENames->SetCurSel( nSelect );
}


//***********************************************************
//  Function:    CSchemaView::DisplayACEPropertiesList
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACEPropertiesList( int nSelect )
{
   ACLTYPE                    eType;
   int                        nACE;
   CComboBox*                 pACEPropList;
   int                        nAttrCount, nIdx;
   CString                    strPropName;
   CADsAccessControlEntry*    pACE;
   CADsAccessControlList*     pACL;

   eType       = GetCurrentACL( );
   nACE        = GetCurrentACE( );
   if( -1 == nACE )
   {
      return;
   }

   pACEPropList= (CComboBox*)GetDlgItem( IDC_ACEPROPERTIESLIST );
   pACEPropList->ResetContent( );

   pACL        = pSecurityDescriptor->GetACLObject( eType );
	if(NULL == pACL)
		return;

   pACE        = pACL->GetACEObject( nACE );
	if(NULL == pACE)
		return;

   nAttrCount  = pACE->GetPropertyCount( );
   for( nIdx = 0; nIdx < nAttrCount ; nIdx++ )
   {
      int   nPos;

      strPropName = pACE->GetAttribute( nIdx, pa_DisplayName );
      nPos        = pACEPropList->AddString( strPropName );
      m_PropList.SetItemData( nPos, (DWORD)nIdx );
   }

   pACEPropList->SetCurSel( nSelect );
}


//***********************************************************
//  Function:    CSchemaView::DisplaySDPropertiesList
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplaySDPropertiesList(int nSelect)
{
   CComboBox*  pSDPropList;
   int         nAttrCount, nIdx;
   CString     strPropName;

   pSDPropList = (CComboBox*)GetDlgItem( IDC_SECURITYDESCRIPTORPROPERTIES );
   pSDPropList->ResetContent( );

   nAttrCount  = pSecurityDescriptor->GetPropertyCount( );

   for( nIdx = 0; nIdx < nAttrCount ; nIdx++ )
   {
      int   nPos;

      strPropName = pSecurityDescriptor->GetAttribute( nIdx, pa_DisplayName );
      nPos        = pSDPropList->AddString( strPropName );
      m_PropList.SetItemData( nPos, (DWORD)nIdx );
   }

   pSDPropList->SetCurSel( nSelect );
}


//***********************************************************
//  Function:    CSchemaView::DisplayACEPropertyValue
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACEPropertyValue( )
{
   CString                    strPropValue;
   HRESULT                    hResult;
   CADsAccessControlEntry*    pACE;
   CADsAccessControlList*     pACL;
   LONG                       lValue;
   TCHAR                      szHex[ 128 ];

   m_nLastACEValue = GetCurrentACEProperty( );

   if( -1 == m_nLastACEValue )
      return;

   if( acl_Invalid == m_nLastACL )
      return;

   if( -1 == m_nLastACE )
      return;

   pACL        = pSecurityDescriptor->GetACLObject( m_nLastACL );
   if( NULL == pACL )
   {
      return;
   }

   pACE        = pACL->GetACEObject( m_nLastACE );

   if( NULL == pACE )
      return;

   hResult     = pACE->GetProperty( m_nLastACEValue, strPropValue );

   switch( m_nLastACEValue )
   {
      case  1:
      case  2:
      case  3:
      case  4:
         lValue   = _ttol( strPropValue.GetBuffer( 128 ) );
         _tcscpy( szHex, _T("0x" ) );
         _ltot( lValue, szHex + _tcslen(szHex), 16 );
         strPropValue   = szHex;
         break;

      default:
         break;
   }


   GetDlgItem( IDC_ACEPROPERTYVALUE )->SetWindowText(
               strPropValue );

}


//***********************************************************
//  Function:    CSchemaView::DisplaySDPropertyValue
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplaySDPropertyValue( )
{
   CString  strPropValue, strEditValue;
   HRESULT  hResult;

   m_nLastSDValue = GetCurrentSDProperty( );

   hResult     = pSecurityDescriptor->GetProperty( m_nLastSDValue,
                                                   strPropValue );
   GetDlgItem( IDC_SECURITYDESCRIPTORPROPERTYVALUE )->SetWindowText(
               strPropValue );

}


//***********************************************************
//  Function:    CSchemaView::PutACEPropertyValue
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::PutACEPropertyValue( )
{
   ACLTYPE                    eType;
   int                        nACE;
   CString                    strPropValue, strEditValue;
   CADsAccessControlEntry*    pACE;
   CADsAccessControlList*     pACL;
   HRESULT                    hResult;

   if( -1 == m_nLastACEValue )
      return;

   if( acl_Invalid == m_nLastACL )
      return;

   if( -1 == m_nLastACE )
      return;

   eType       = m_nLastACL;
   nACE        = m_nLastACE;

   pACL        = pSecurityDescriptor->GetACLObject( eType );
   if( NULL == pACL )
      return;

   pACE        = pACL->GetACEObject( nACE );

   GetDlgItem( IDC_ACEPROPERTYVALUE )->GetWindowText( strEditValue );

   switch( m_nLastACEValue )
   {
      case  1:
      case  2:
      case  3:
      case  4:
      {
         LONG  lValue   = 0;
         TCHAR szText[ 16 ];

         _stscanf( strEditValue.GetBuffer( 128 ), _T("%lx"), &lValue );
         _ltot( lValue, szText, 10 );
         strEditValue   = szText;
         break;
      }

      default:
         break;
   }
   hResult     = pACE->GetProperty( m_nLastACEValue, strPropValue );


   if( strEditValue.Compare( strPropValue ) )
   {
      hResult  = pACE->PutProperty( m_nLastACEValue, strEditValue );
   }
}


//***********************************************************
//  Function:    CSchemaView::PutSDPropertyValue
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::PutSDPropertyValue()
{
   CString  strPropValue, strEditValue;
   HRESULT  hResult;

   if( -1 == m_nLastSDValue )
      return;

   hResult     = pSecurityDescriptor->GetProperty( m_nLastSDValue,
                                                   strPropValue );

   GetDlgItem( IDC_SECURITYDESCRIPTORPROPERTYVALUE )->GetWindowText(
               strEditValue );

   if( strEditValue.Compare( strPropValue ) )
   {
      hResult  = pSecurityDescriptor->PutProperty( m_nLastACEValue,
                                                   strEditValue );
   }

}


//***********************************************************
//  Function:    CSchemaView::GetCurrentACL
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
ACLTYPE CSchemaView::GetCurrentACL()
{
   CComboBox*  pList;

   pList = (CComboBox*) GetDlgItem( IDC_DACLSACL_LIST );

   return (ACLTYPE) ( 1 + pList->GetCurSel( ) );
}


//***********************************************************
//  Function:    CSchemaView::GetCurrentACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
int   CSchemaView::GetCurrentACE()
{
   CComboBox*  pList;

   pList = (CComboBox*) GetDlgItem( IDC_ACELIST );

   return pList->GetCurSel( );

}


//***********************************************************
//  Function:    CSchemaView::GetCurrentSDProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
int   CSchemaView::GetCurrentSDProperty( )
{
   CComboBox*  pList;

   pList = (CComboBox*) GetDlgItem( IDC_SECURITYDESCRIPTORPROPERTIES );

   return pList->GetCurSel( );
}


//***********************************************************
//  Function:    CSchemaView::GetCurrentACEProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
int   CSchemaView::GetCurrentACEProperty( )
{
   CComboBox*  pList;

   pList = (CComboBox*) GetDlgItem( IDC_ACEPROPERTIESLIST );

   return pList->GetCurSel( );
}


//***********************************************************
//  Function:    CSchemaView::OnACEChange
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnACEChange( )
{
	// TODO: Add your control notification handler code here
	PutACEPropertyValue( );

   m_nLastACE  = GetCurrentACE( );

   DisplayACEPropertiesList( 0 );

   DisplayACEPropertyValue( );
}


//***********************************************************
//  Function:    CSchemaView::OnACEPropertyChange
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnACEPropertyChange()
{
	// TODO: Add your control notification handler code here
   PutACEPropertyValue( );

   DisplayACEPropertyValue( );
}


//***********************************************************
//  Function:    CSchemaView::OnACLChange
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnACLChange()
{
	// TODO: Add your control notification handler code here
   PutACEPropertyValue( );

   m_nLastACL  = GetCurrentACL( );

   DisplayACENames( 0 );

   DisplayACEPropertiesList( 0 );

   DisplayACEPropertyValue( );
}


//***********************************************************
//  Function:    CSchemaView::OnSDPropertyChange
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnSDPropertyChange()
{
	// TODO: Add your control notification handler code here
	PutSDPropertyValue( );

   DisplaySDPropertyValue( );
}


//***********************************************************
//  Function:    CSchemaView::OnAddACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnAddACE()
{
	// TODO: Add your control notification handler code here
   ACLTYPE  aclType;
   HRESULT  hResult;

   aclType  = GetCurrentACL( );

   if( acl_Invalid != aclType )
   {
      IDispatch*  pACEDisp;
      IUnknown*   pACEUnk;
      CADsAccessControlEntry* pACE  = new CADsAccessControlEntry;

      pACEDisp = pACE->CreateACE( );

      delete   pACE;

      if( NULL != pACEDisp )
      {
         hResult  = pACEDisp->QueryInterface( IID_IUnknown, (void**)&pACEUnk );
         pACEDisp->Release( );

         hResult  = pSecurityDescriptor->AddACE( aclType, pACEUnk );
         pACEUnk->Release( );
         FillACLControls( );
      }
   }
}


//***********************************************************
//  Function:    CSchemaView::OnCopyACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnCopyACE()
{
	// TODO: Add your control notification handler code here
   int         nACE;
   IDispatch*  pDisp;
   ACLTYPE     aclType;

   aclType  = GetCurrentACL( );	
   nACE     = GetCurrentACE( );

   pDisp    = CopyACE( pSecurityDescriptor->GetACLObject( aclType )->GetACEObject( nACE )->GetACE( ) );

   if( NULL != pACEClipboard )
   {
      pACEClipboard->Release( );
   }

   pACEClipboard  = pDisp;
}


//***********************************************************
//  Function:    CSchemaView::OnPasteACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnPasteACE()
{
   // TODO: Add your control notification handler code here
   IUnknown*   pACEUnk;
   ACLTYPE     aclType;
   HRESULT     hResult;

   aclType  = GetCurrentACL( );	
   if( NULL != pACEClipboard )
   {
      hResult  = pACEClipboard->QueryInterface( IID_IUnknown, (void**)&pACEUnk );

      hResult  = pSecurityDescriptor->AddACE( aclType, pACEUnk );
      pACEUnk->Release( );
      FillACLControls( );
   }
}

void CSchemaView::OnRemoveACE()
{
	// TODO: Add your control notification handler code here
	// TODO: Add your control notification handler code here
   ACLTYPE  aclType;
   HRESULT  hResult;
   int      nCurrentACE;

   aclType     = GetCurrentACL( );
   nCurrentACE = GetCurrentACE( );

   if( acl_Invalid != aclType )
   {
      IDispatch*  pACEDisp;
      IUnknown*   pACEUnk;

      pACEDisp = pSecurityDescriptor->GetACLObject( aclType )->GetACEObject( nCurrentACE )->GetACE( );

      if( NULL != pACEDisp )
      {
         hResult  = pACEDisp->QueryInterface( IID_IUnknown, (void**)&pACEUnk );
         pACEDisp->Release( );

         hResult  = pSecurityDescriptor->RemoveACE( aclType, pACEUnk );
         pACEUnk->Release( );
         FillACLControls( );
      }
   }
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\schclss.h ===
#ifndef  _SCHEMACLASSES_H_
#define  _SCHEMACLASSES_H_

//#include "csyntax.h"

class COleDsSyntax;
class CMainDoc;

typedef enum _tagCLASSATTR
{
   ca_ERROR=0,
   ca_Name,
   ca_DisplayName,
   ca_CLSID,
   ca_PrimaryInterface,
   ca_OID,
   ca_Abstract,
   ca_DerivedFrom,
   ca_Containment,
   ca_Container,
   ca_HelpFileName,
   ca_HelpFileContext,
   ca_MethodsCount,
   ca_Limit
} CLASSATTR;

typedef enum _tagFUNCSETATTR
{
   fa_ERROR=0,
   fa_Name,
   fa_DisplayName,
   fa_Limit
} FUNCSETATTR;


typedef enum _tagMETHODATTR
{
   ma_ERROR=0,
   ma_Name,
   ma_DisplayName,
   ma_Limit
} METHODATTR;


typedef enum _tagPROPATTR
{
   pa_ERROR=0,
   pa_Name,
   pa_DisplayName,
   pa_Type,
   pa_DsNames,
   pa_OID,
   pa_MaxRange,
   pa_MinRange,
   pa_Mandatory,
   pa_MultiValued,
   pa_Limit
} PROPATTR;


class CMethod: public CObject
{
   public:
      CMethod( );
      CMethod( ITypeInfo*, FUNCDESC* );
      ~CMethod( );

      CString  GetName( );
      int      GetArgCount( );
      int      GetArgOptionalCount( );
      VARTYPE  GetMethodReturnType( );
      BOOL     ConvertArgument( int nArg, CString strArg, VARIANT* );
      HRESULT  CallMethod     ( IDispatch* pIDispatch, BOOL* pDisplay );
      CString  GetAttribute   ( METHODATTR  );
      HRESULT  PutAttribute   ( METHODATTR, CString& );

   private:
      int            m_nArgs;
      int            m_nArgsOpt;
      CString        m_strName;
      VARTYPE*       m_pArgTypes;
      VARTYPE        m_ReturnType;
      CStringArray   m_strArgNames;
      CString        m_strAttributes[ ma_Limit ];
};

class CProperty: public CObject
{
   public:
      CProperty   ( IADs*         );
      CProperty   (                 );
      ~CProperty  (                 );
		CProperty	( TCHAR* pszName, TCHAR* pszSyntax, BOOL bMultiValued = FALSE );

   //methods
      CString     VarToDisplayString( VARIANT&, BOOL bUseEx );
      BOOL        DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL bEx );
      BOOL        SetMandatory         ( BOOL      );
      BOOL        GetMandatory         (           );
      CString     GetAttribute         ( PROPATTR  );
      HRESULT     PutAttribute         ( PROPATTR, CString& );
      BOOL        SetSyntaxID          ( DWORD );
      DWORD       GetSyntaxID          ( );
      
      HRESULT     Native2Value         ( ADS_ATTR_INFO*, CString& );
      HRESULT     Value2Native         ( ADS_ATTR_INFO*, CString& );
      void        FreeAttrInfo         ( ADS_ATTR_INFO* );

   protected:
	   void CreateSyntax( ADSTYPE );
      BOOL        m_bMandatory;
      BOOL        m_bMultiValued;
      DWORD       m_dwSyntaxID;
      CString     m_strAttributes[ pa_Limit ];
      BOOL        m_bDefaultSyntax;

      COleDsSyntax*    m_pSyntax;
};


/*class CFuncSet: public CObject
{
   public:
      CFuncSet ( CString&   );
      CFuncSet (                             );
      ~CFuncSet(                             );

   //methods
      BOOL           HasMandatoryProperties     (              );
      void           AddProperty                ( CProperty*   );
      int            GetPropertyCount           (               );
      
      CString        GetAttribute               ( int, PROPATTR );
      HRESULT        PutAttribute               ( int, PROPATTR, CString& );

      CString        GetAttribute               ( int, METHODATTR );
      HRESULT        PutAttribute               ( int, METHODATTR, CString& );
      
      CString        GetAttribute               ( FUNCSETATTR );
      HRESULT        PutAttribute               ( FUNCSETATTR, CString& );

      CString        VarToDisplayString         ( int, VARIANT&, BOOL bUseEx );
      BOOL           DisplayStringToDispParams  ( int, CString&, DISPPARAMS&, BOOL bUseEx  );
      int            LookupProperty					( CString& );
      CProperty*     GetProperty						( int        );   
      CMethod*       GetMethod                  ( int        );   
      HRESULT        LoadMethodsInformation     ( ITypeInfo* );

   protected:
      CProperty*     GetProperty( CString&   );

   
   protected:
      CString     m_strAttributes[ fa_Limit ];
      CObArray*   m_pProperties;
      CObArray*   m_pMethods;
};*/

class CClass: public CObject
{

   public:   
      CClass   ( CString&, CMainDoc* pMainDoc );
      CClass   (           );
      ~CClass  (           );   
		CClass	( TCHAR* pszClass, REFIID rPrimaryInterface );

   //methods
      BOOL           HasMandatoryProperties              ( void );
      void           AddProperty                         ( CProperty*   );
      //**************
      CString        GetAttribute                        ( CLASSATTR );
      HRESULT        PutAttribute                        ( CLASSATTR, CString& );

      //**************
      CString        GetAttribute                        ( int, METHODATTR );
      HRESULT        PutAttribute                        ( int, METHODATTR,  CString& );
                                                         
      //**************                                   
      CString        GetAttribute                        ( int, PROPATTR );
      HRESULT        PutAttribute                        ( int, PROPATTR, CString& );

      int            GetPropertyCount                    ( void );
      int            GetMethodsCount                     ( void );
      
      CMethod*       GetMethod                           ( int );
      CProperty*     GetProperty						         ( int        );   

      CString        VarToDisplayString                  ( int, VARIANT&, BOOL bUseEx );
      
      BOOL           DisplayStringToDispParams           ( int, CString&, DISPPARAMS&, BOOL bUseEx );
      BOOL           SupportContainer                    ( void ) 
                           { return m_bContainer; };
      HRESULT        LoadMethodsInformation  ( TCHAR* );
      HRESULT        LoadMethodsInformation  ( ITypeInfo* );
      int            LookupProperty				( CString& );
      REFIID         GetMethodsInterface     ( );
      

   protected:
      HRESULT        ReadMandatoryPropertiesInformation  ( VARIANT* );
      HRESULT        BuildOptionalPropertiesList         ( IADsClass* );
      HRESULT        BuildOptionalPropertiesList         ( IADsContainer* );
      HRESULT        BuildMandatoryPropertiesList        ( IADsClass* );
      HRESULT        AddProperties                       ( IADsClass*, VARIANT&, BOOL bMandatory );
      HRESULT        AddProperty                         ( BSTR,        BSTR,     BOOL bMandatory );
      CProperty*     GetProperty( CString&   );


   protected:
      BOOL           m_bContainer;
      CString        m_strAttributes[ ca_Limit ];
      CMainDoc*      m_pMainDoc;
      REFIID         m_refMethods;

   public:
      CObArray*   m_pProperties;
      CObArray*   m_pMethods;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\prmsdlg.h ===
// prmsdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CParamsDialog dialog

class CParamsDialog : public CDialog
{
// Construction
public:
	CParamsDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CParamsDialog)
	enum { IDD = IDD_CALLMETHOD };
	CStatic	m_strMethodName;
	CEdit	m_eParamValue6;
	CEdit	m_eParamValue5;
	CEdit	m_eParamValue4;
	CEdit	m_eParamValue3;
	CEdit	m_eParamValue2;
	CEdit	m_eParamValue1;
	CStatic	m_strParamName6;
	CStatic	m_strParamName5;
	CStatic	m_strParamName4;
	CStatic	m_strParamName3;
	CStatic	m_strParamName2;
	CStatic	m_strParamName1;
	//}}AFX_DATA

public:
   void  SetMethodName  ( CString& );
   void  SetArgNames    ( CStringArray* );
   void  SetArgValues   ( CStringArray* );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CParamsDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CParamsDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
//   CStringArray   m_ArgNames;
//   CStringArray   m_ArgValues;
   int            m_nArgs;
   CString        m_strMethName;
   CStringArray*  m_pArgNames;
   CStringArray*  m_pArgValues;
   CEdit*         m_pValues[ 100 ];
   CStatic*       m_pNames[ 100 ];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\prmsdlg.cpp ===
// prmsdlg.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "resource.h"
#include "prmsdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CParamsDialog dialog


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CParamsDialog::CParamsDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CParamsDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CParamsDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_nArgs  = 0;

   m_pValues[ 0 ] = &m_eParamValue1;
   m_pValues[ 1 ] = &m_eParamValue2;
   m_pValues[ 2 ] = &m_eParamValue3;
   m_pValues[ 3 ] = &m_eParamValue4;
   m_pValues[ 4 ] = &m_eParamValue5;
   m_pValues[ 5 ] = &m_eParamValue6;

   m_pNames[ 0 ]  = &m_strParamName1;
   m_pNames[ 1 ]  = &m_strParamName2;
   m_pNames[ 2 ]  = &m_strParamName3;
   m_pNames[ 3 ]  = &m_strParamName4;
   m_pNames[ 4 ]  = &m_strParamName5;
   m_pNames[ 5 ]  = &m_strParamName6;

   m_pArgNames    = NULL;
   m_pArgValues   = NULL;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CParamsDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CParamsDialog)
	DDX_Control(pDX, IDC_METHOD, m_strMethodName);
	DDX_Control(pDX, IDE_PARAM6, m_eParamValue6);
	DDX_Control(pDX, IDE_PARAM5, m_eParamValue5);
	DDX_Control(pDX, IDE_PARAM4, m_eParamValue4);
	DDX_Control(pDX, IDE_PARAM3, m_eParamValue3);
	DDX_Control(pDX, IDE_PARAM2, m_eParamValue2);
	DDX_Control(pDX, IDE_PARAM1, m_eParamValue1);
	DDX_Control(pDX, IDC_PARAM6, m_strParamName6);
	DDX_Control(pDX, IDC_PARAM5, m_strParamName5);
	DDX_Control(pDX, IDC_PARAM4, m_strParamName4);
	DDX_Control(pDX, IDC_PARAM3, m_strParamName3);
	DDX_Control(pDX, IDC_PARAM2, m_strParamName2);
	DDX_Control(pDX, IDC_PARAM1, m_strParamName1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CParamsDialog, CDialog)
	//{{AFX_MSG_MAP(CParamsDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CParamsDialog message handlers


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CParamsDialog::SetMethodName  ( CString& strMethodName )
{
   m_strMethName  = strMethodName;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CParamsDialog::SetArgNames( CStringArray* pArgNames )
{
   m_pArgNames = pArgNames;
   m_nArgs     = (int)pArgNames->GetSize( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CParamsDialog::SetArgValues( CStringArray* pArgValues )
{
   m_pArgValues   = pArgValues;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CParamsDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

   int nIdx;

   for( nIdx = 0; nIdx < m_nArgs && nIdx < 6 ; nIdx++ )
   {
      m_pNames[ nIdx ]->SetWindowText( m_pArgNames->GetAt( nIdx ) );
      m_pValues[ nIdx ]->SetWindowText( _T("") );
   }

   for( ; nIdx < 6 ; nIdx++ )
   {
      m_pNames[ nIdx ]->ShowWindow( SW_HIDE );
      m_pValues[ nIdx ]->ShowWindow( SW_HIDE );
   }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CParamsDialog::OnOK()
{
	// TODO: Add extra validation here
	for( int nIdx = 0; nIdx < m_nArgs && m_nArgs < 6; nIdx++ )
   {
      CString  strValue;

      m_pValues[ nIdx ]->GetWindowText( strValue );
      m_pArgValues->Add( strValue );
   }

	CDialog::OnOK();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\qstatus.cpp ===
// QueryStatus.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "qstatus.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueryStatus dialog


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CQueryStatus::CQueryStatus(CWnd* pParent /*=NULL*/)
	: CDialog(CQueryStatus::IDD, pParent)
{
	//{{AFX_DATA_INIT(CQueryStatus)
	//}}AFX_DATA_INIT

   m_nUser           = 0;
   m_nGroup          = 0;
   m_nService        = 0;
   m_nFileService    = 0;
   m_nPrintQueue     = 0;
   m_nToDisplay      = 0;
   m_nComputer       = 0;
   m_nOtherObjects   = 0;

   m_pbAbort         = NULL;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CQueryStatus::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQueryStatus)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQueryStatus, CDialog)
	//{{AFX_MSG_MAP(CQueryStatus)
	ON_BN_CLICKED(IDCANCEL, OnStop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueryStatus message handlers

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CQueryStatus::IncrementType( DWORD  dwType, BOOL bDisplay )
{
   switch(  dwType )
   {
      case  USER:
         m_nUser++;
         break;
         
      case GROUP:
         m_nGroup++;
         break;

      case  SERVICE:
         m_nService++;
         break;

      case  FILESERVICE:
         m_nFileService++;
         break;

      case  PRINTQUEUE:
         m_nPrintQueue++;
         break;

      case  COMPUTER:
         m_nComputer++;
         break;

      default:
         m_nOtherObjects++;
         break;
   }

   if( bDisplay )
   {
      m_nToDisplay++;
   }

   DisplayStatistics( );
   UpdateWindow( );

   MSG   aMsg;

   while( PeekMessage( &aMsg, NULL, 0, 0, PM_REMOVE ) && 
          !IsDialogMessage( &aMsg ) )
   {
      TranslateMessage( &aMsg );
      DispatchMessage( &aMsg );
   }
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CQueryStatus::DisplayStatistics( void )
{
   SetDlgItemInt( IDS_USER,            m_nUser           );
   SetDlgItemInt( IDS_GROUP,           m_nGroup          );
   SetDlgItemInt( IDS_SERVICE,         m_nService        );
   SetDlgItemInt( IDS_FILESERVICE,     m_nFileService    );
   SetDlgItemInt( IDS_PRINTQUEUE,      m_nPrintQueue     );
   SetDlgItemInt( IDS_OTHEROBJECTS,    m_nOtherObjects   );
   SetDlgItemInt( IDS_COMPUTER,        m_nComputer       );
   SetDlgItemInt( IDC_ITEMSTODISPLAY,  m_nToDisplay      );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CQueryStatus::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	
   DisplayStatistics( );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CQueryStatus::SetAbortFlag( BOOL* pAbort )
{
   m_pbAbort   = pAbort;
   *pAbort     = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CQueryStatus::OnStop() 
{
	// TODO: Add your control notification handler code here

   if( NULL != m_pbAbort )
   {
      *m_pbAbort = TRUE;
   }
}
/////////////////////////////////////////////////////////////////////////////
// CDeleteStatus dialog


CDeleteStatus::CDeleteStatus(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteStatus::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteStatus)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_pbAbort   = NULL;
}


void CDeleteStatus::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteStatus)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteStatus, CDialog)
	//{{AFX_MSG_MAP(CDeleteStatus)
	ON_BN_CLICKED(IDCANCEL, OnStop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CDeleteStatus::SetAbortFlag( BOOL* pAbort )
{
   m_pbAbort   = pAbort;
   *pAbort     = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CDeleteStatus::SetCurrentObjectText ( TCHAR* szName )
{
   SetDlgItemText( IDC_CURRENTDELETEOBJECT, szName );   

   UpdateWindow( );

   MSG   aMsg;

   while( PeekMessage( &aMsg, NULL, 0, 0, PM_REMOVE ) && 
          !IsDialogMessage( &aMsg ) )
   {
      TranslateMessage( &aMsg );
      DispatchMessage( &aMsg );
   }
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CDeleteStatus::SetStatusText( TCHAR* szStatus )
{
   //SetDlgItemText( IDC_DELETESTATUS, szStatus );   
   GetDlgItem( IDC_DELETESTATUS )->ShowWindow( SW_HIDE );

   //UpdateWindow( );

   /*MSG   aMsg;

   while( PeekMessage( &aMsg, NULL, 0, 0, PM_REMOVE ) && 
          !IsDialogMessage( &aMsg ) )
   {
      TranslateMessage( &aMsg );
      DispatchMessage( &aMsg );
   }*/
}

/////////////////////////////////////////////////////////////////////////////
// CDeleteStatus message handlers

void CDeleteStatus::OnStop() 
{
	// TODO: Add your control notification handler code here
   if( NULL != m_pbAbort )
   {
      *m_pbAbort = TRUE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\schclss.cpp ===
#include "stdafx.h"
#include "schclss.h"
#include "maindoc.h"
#include "resource.h"
#include "bwsview.h"
#include "ole2.h"
#include "csyntax.h"
#include "colldlg.h"
#include "prmsdlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CMethod::CMethod( )
{
   m_nArgs     = 0;
   m_pArgTypes = NULL;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CMethod::~CMethod( )
{
   if( m_pArgTypes != NULL )
      delete[] m_pArgTypes;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CMethod::GetName( )
{
   return m_strName;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CMethod::CMethod( ITypeInfo* pITypeInfo, FUNCDESC* pFuncDesc )
{
   HRESULT  hResult;
   BSTR     bstrNames[ 256 ];
   UINT     cNames;
   UINT     nIdx;
   TCHAR    szTemp[ 128 ];

   m_nArgs     = 0;
   m_pArgTypes = NULL;

   hResult  = pITypeInfo->GetNames( pFuncDesc->memid, bstrNames,
                                    256, &cNames );



   if( SUCCEEDED( hResult ) )
   {
      m_strName                  = bstrNames[ 0 ];
      m_strAttributes[ ma_Name ] = bstrNames[ 0 ];
      m_strAttributes[ ma_DisplayName ] = bstrNames[ 0 ];
      m_nArgs                    = pFuncDesc->cParams;
      m_nArgsOpt                 = pFuncDesc->cParamsOpt;
      m_ReturnType               = pFuncDesc->elemdescFunc.tdesc.vt;
      if( m_nArgs )
      {
         m_pArgTypes = new VARTYPE[ m_nArgs ];
         for( nIdx = 0; nIdx < (UINT)m_nArgs ; nIdx++ )
         {
            m_pArgTypes[ nIdx ]  =
               pFuncDesc->lprgelemdescParam[ nIdx ].tdesc.vt;
            _tcscpy( szTemp, _T("") );
            StringCat( szTemp, bstrNames[ nIdx + 1] );
            m_strArgNames.Add( szTemp );
         }
      }
      for( nIdx = 0; nIdx < cNames ; nIdx++ )
      {
         SysFreeString( bstrNames[ nIdx ] );
      }

   }
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CMethod::GetArgCount( )
{
   return m_nArgs;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CMethod::GetArgOptionalCount( )
{
   return m_nArgsOpt;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
VARTYPE  CMethod::GetMethodReturnType( )
{
   return m_ReturnType;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CMethod::ConvertArgument( int nArg, CString strArg, VARIANT* )
{
   return FALSE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CMethod::GetAttribute( METHODATTR methAttr )
{
   switch( methAttr )
   {
      case  ma_Name:
      case  ma_DisplayName:
         return m_strAttributes[ methAttr ];

      default:
         ASSERT( FALSE );
         return CString( _T("???") );
   }

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CMethod::PutAttribute( METHODATTR methAttr, CString& rValue )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CMethod::CallMethod( IDispatch* pIDispatch, BOOL* pbDisplayMessage )
{
   CStringArray      aParamValues;
   int               nIdx;
   DISPPARAMS        dispparamsArgs    = {NULL, NULL, 0, 0};
   DISPPARAMS        dispparamsNoArgs  = {NULL, NULL, 0, 0};
   DISPID            dispid;
   OLECHAR FAR*      szName;
   BSTR              bstrName;
   VARIANT           var;
   EXCEPINFO         aExcepInfo;
   UINT              uErr;
   HRESULT           hResult, hResultX;
   IADsCollection* pICollection;
   IADsMembers*    pIMembers;
   IDispatch*        pIResult;

   if( m_nArgs )
   {
      CParamsDialog  aParamsDialog;

      aParamsDialog.SetMethodName( m_strName );
      aParamsDialog.SetArgNames( &m_strArgNames );
      aParamsDialog.SetArgValues( &aParamValues );
      if( aParamsDialog.DoModal( ) != IDOK )
         return E_FAIL;

      dispparamsArgs.rgvarg   = new VARIANT[ m_nArgs ];

      for( nIdx = 0; nIdx < m_nArgs ; nIdx++ )
      {
         VARIANT  varString;

         VariantInit( &dispparamsArgs.rgvarg[ m_nArgs - nIdx - 1] );
         VariantInit( &varString );
         V_VT( &varString )   = VT_BSTR;
         V_BSTR( &varString ) = AllocBSTR( aParamValues[ nIdx ].GetBuffer( 128 ) );
         if( VT_VARIANT != m_pArgTypes[ nIdx ] )
         {
            hResult  = VariantChangeType( &dispparamsArgs.rgvarg[ m_nArgs - nIdx - 1],
                                          &varString,
                                          VARIANT_NOVALUEPROP,
                                          m_pArgTypes[ nIdx ] );
         }
         else
         {
            BuildVariantArray( VT_BSTR, aParamValues[ nIdx ], dispparamsArgs.rgvarg[ m_nArgs - nIdx - 1] );
         }
         VariantClear( &varString );
      }
   }

   bstrName    = AllocBSTR( m_strName.GetBuffer( 128 ) );
   szName      = (OLECHAR FAR*) bstrName;
   hResult     = pIDispatch->GetIDsOfNames( IID_NULL, &szName, 1,
                                            LOCALE_SYSTEM_DEFAULT, &dispid ) ;
   SysFreeString( bstrName );

   ASSERT( SUCCEEDED( hResult ) );
   while( TRUE )
   {
      HCURSOR  aCursor, oldCursor;

      if( FAILED( hResult ) )
         break;

      memset( &aExcepInfo, 0, sizeof( aExcepInfo) );
      dispparamsArgs.cArgs       = m_nArgs;
      dispparamsArgs.cNamedArgs  = 0;

      aCursor     = LoadCursor( NULL, IDC_WAIT );
      oldCursor   = SetCursor( aCursor );
      hResult     = pIDispatch->Invoke( dispid,
                                        IID_NULL,
                                        LOCALE_SYSTEM_DEFAULT,
                                          DISPATCH_METHOD,
                                        &dispparamsArgs,
                                        &var,
                                        &aExcepInfo,
                                        &uErr );
      SetCursor( oldCursor );

      if( DISP_E_EXCEPTION == hResult )
      {
         hResult  = aExcepInfo.scode;
      }

      if( FAILED( hResult ) )
      {
         break;
      }

      if( VT_VOID == m_ReturnType )
         break;

      // now, we have a return value we must work on.

      switch( m_ReturnType )
      {
         case  VT_DISPATCH:
         case  VT_PTR:
            pIResult = V_DISPATCH( &var );
            pIResult->AddRef( );

            hResultX = pIResult->QueryInterface( IID_IADsCollection,
                                                 (void**)&pICollection );
            if( SUCCEEDED( hResultX ) )
            {
               CCollectionDialog aCollectionDialog;

               aCollectionDialog.SetCollectionInterface( pICollection );
               aCollectionDialog.DoModal( );

               pICollection->Release( );
               *pbDisplayMessage = FALSE;
            }
            else
            {
               hResult  = pIResult->QueryInterface( IID_IADsMembers,
                                                    (void**)&pIMembers );
               if( SUCCEEDED( hResult ) )
               {
                  CCollectionDialog aCollectionDialog;
                  IADsGroup*  pGroup;
                  HRESULT     hResult;

                  hResult  = pIDispatch->QueryInterface( IID_IADsGroup,
                                                         (void**)&pGroup );
                  if( SUCCEEDED( hResult ) )
                  {
                     aCollectionDialog.SetGroup( pGroup );
                  }
                  else
                  {
                     aCollectionDialog.SetMembersInterface( pIMembers );
                  }
                  aCollectionDialog.DoModal( );

                  if( SUCCEEDED( hResult ) )
                     pGroup->Release( );

                  pIMembers->Release( );
                  *pbDisplayMessage = FALSE;
               }
            }
            pIResult->Release( );
            break;

         case  VT_BOOL:
            AfxGetMainWnd()->MessageBox(  VARIANT_FALSE == V_BOOL( &var ) ?
                                          _T("Result: FALSE") :
                                          _T("Result: TRUE"),
                                          m_strName,
                                          MB_ICONINFORMATION );
            *pbDisplayMessage = FALSE;

            break;

         default:
            ASSERT( FALSE );
      }

      VariantClear( &var );
      break;
   }

   if( dispparamsArgs.rgvarg )
   {
      for( nIdx = 0; nIdx < m_nArgs ; nIdx++ )
      {
         if( V_VT( &dispparamsArgs.rgvarg[ nIdx ] ) != VT_EMPTY )
         {
            VariantClear( &dispparamsArgs.rgvarg[ nIdx ] );
         }
      }

      delete [] dispparamsArgs.rgvarg;
   }

   return hResult;
}




/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty::CProperty( )
{
   m_bMandatory   = FALSE;
   m_dwSyntaxID   = 0L;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty::CProperty    ( TCHAR* pszName, TCHAR* szSyntax, BOOL bMultiValued )
{
   HRESULT  hResult  = S_OK;
   BSTR     pszSyntax;

   for( int nIdx = 0; nIdx < pa_Limit ; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("NA");
   }

   m_bMandatory   = FALSE;
   m_bDefaultSyntax  = TRUE;
   m_bMultiValued = bMultiValued;
   m_dwSyntaxID   = 0L;

   m_strAttributes[ pa_Name ]          = pszName;
   m_strAttributes[ pa_DisplayName ]   = pszName;

   pszSyntax   = AllocBSTR( szSyntax );

   m_pSyntax   = GetSyntaxHandler( pszSyntax );

   /*if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"String" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Counter" ) )
   {
      m_pSyntax   = new COleDsLONG;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"OleDsPath" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"EmailAddress" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"FaxNumber" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Integer" ) )
   {
      m_pSyntax   = new COleDsLONG;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Interval" ) )
   {
      m_pSyntax   = new COleDsLONG;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"List" ) )
   {
      m_pSyntax   = new COleDsVARIANT;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"NetAddress" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"OctetString" ) )
   {
      m_pSyntax   = new COleDsVARIANT;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Path" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"PhoneNumber" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"PostalAddress" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"SmallInterval" ) )
   {
      m_pSyntax   = new COleDsLONG;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Time" ) )
   {
      m_pSyntax   = new COleDsDATE;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"boolean" ) )
   {
      m_pSyntax   = new COleDsBOOL;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"TimeStamp" ) )
   {
      m_pSyntax   = new COleDsNDSTimeStamp;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"UTCTime" ) )
   {
      //m_pSyntax   = new COleDsString;
       m_pSyntax   = new COleDsDATE;
   }

   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"GeneralizedTime" ) )
   {
      //m_pSyntax   = new COleDsString;
       m_pSyntax   = new COleDsDATE;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Integer8" ) )
   {
      m_pSyntax   = new COleDsLargeInteger;
   }

   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Postal Address" ) )
   {
      m_pSyntax   = new COleDsNDSPostalAddress;
   }

   else
   {
      ASSERT( FALSE );
      m_pSyntax   = new COleDsString;
   }*/

   m_strAttributes[ pa_Type ] = szSyntax;

   m_strAttributes[ pa_MultiValued ] = bMultiValued ? _T("Yes") : _T("No");

   SysFreeString( pszSyntax );
}


/***********************************************************
  Function:    CProperty::CreateSyntax
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CProperty::CreateSyntax( ADSTYPE eType )
{
   COleDsSyntax*  pNewSyntax  = NULL;
   CString        strText;

   if( !m_bDefaultSyntax )
      return;

   pNewSyntax  = GetSyntaxHandler( eType, strText );

   if( NULL != pNewSyntax )
   {
      delete m_pSyntax;

      m_pSyntax         = pNewSyntax;
      m_bDefaultSyntax  = FALSE;
   }

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty::CProperty( IADs* pIOleDs )
{
   HRESULT        hResult;
   BSTR           bstrText;
   CString        strTemp;
   TCHAR          szText[ 128 ];
   long           lTemp;
   VARIANT        aVar, vGet;
   VARIANT_BOOL   aBool;
   IADsProperty* pIProp  = NULL;

   m_bMandatory   = FALSE;
   m_bMultiValued = FALSE;
   m_bDefaultSyntax  = TRUE;
   m_dwSyntaxID   = 0L;
   //**************
   hResult                             = pIOleDs->get_Name( &bstrText );
   m_strAttributes[ pa_Name ]          = bstrText;
   m_strAttributes[ pa_DisplayName ]   = bstrText;
   SysFreeString( bstrText );

   //**************

   m_strAttributes[ pa_Mandatory ]     = _T("No");

   //**************

   hResult  = pIOleDs->QueryInterface( IID_IADsProperty, (void**) &pIProp );

   if( pIProp )
   {

      VariantInit( &vGet );
      hResult  = Get( pIOleDs, L"Syntax", &vGet );
      bstrText = V_BSTR( &vGet );
      if( FAILED( hResult ) )
      {
         hResult  = pIProp->get_Syntax( &bstrText );
         if( FAILED( hResult ) )
         {
            bstrText = AllocBSTR( _T("Unknown") );
         }
      }
      m_strAttributes[ pa_Type ] = bstrText;

      m_pSyntax   = GetSyntaxHandler( bstrText );

      SysFreeString( bstrText );

      //**************

      /*
      hResult  = Get( pIOleDs, _T("MaxRange"), &vGet );
      lTemp    = V_I4( &vGet );
      if( FAILED( hResult ) )
      {
         hResult  = pIProp->get_MaxRange( &lTemp );
      }

      if( SUCCEEDED( hResult ) )
      {
         _ltot( lTemp, szText, 10 );
         m_strAttributes[ pa_MaxRange ] = szText;
      }
      else
      {
         m_strAttributes[ pa_MaxRange ] = _T("NA");
      }

      //**************
      hResult  = Get( pIOleDs, _T("MinRange"), &vGet );
      lTemp    = V_I4( &vGet );
      if( FAILED( hResult ) )
      {
         hResult     = pIProp->get_MinRange( &lTemp );
      }
      if( SUCCEEDED( hResult ) )
      {
         _ltot( lTemp, szText, 10 );
         m_strAttributes[ pa_MinRange ] = szText;
      }
      else
      {
         m_strAttributes[ pa_MinRange ] = _T("NA");
      }
      */

      //**************
      V_BOOL( &vGet )   = FALSE;
      hResult           = Get( pIOleDs, _T("MultiValued"), &vGet );
      aBool             = V_BOOL( &vGet );
      if( FAILED( hResult ) )
      {
         hResult     = pIProp->get_MultiValued( &aBool );
      }
      m_bMultiValued = aBool;
      if( SUCCEEDED( hResult ) )
      {
         m_strAttributes[ pa_MultiValued ] = aBool ? _T("Yes") : _T("No");
      }
      else
      {
         m_strAttributes[ pa_MultiValued ] = _T("NA");
      }

      //**************
      hResult  = Get( pIOleDs, _T("OID"), &vGet );
      bstrText = V_BSTR( &vGet );
      if( FAILED( hResult ) )
      {
         hResult  = pIProp->get_OID( &bstrText );
      }
      if( bstrText && SUCCEEDED( hResult ) )
      {
         m_strAttributes[ pa_OID ]  = bstrText;
         SysFreeString( bstrText );
      }
      else
      {
         m_strAttributes[ pa_OID ]  = _T("NA");
      }

      //**************
      hResult  = Get( pIOleDs, _T("DsNames"), &aVar );
      if( FAILED( hResult ) )
      {
         //hResult  = pIProp->get_DsNames( &aVar );
      }
      if( SUCCEEDED( hResult ) )
      {
         m_strAttributes[ pa_DsNames ] = FromVariantToString( aVar );
         VariantClear( &aVar );
      }
      else
      {
         m_strAttributes[ pa_DsNames ] = _T("NA");
      }
      pIProp->Release( );
   }
   else
   {
       m_pSyntax   = new COleDsString;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty::~CProperty( )
{
   delete   m_pSyntax;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CProperty::GetAttribute( PROPATTR propAttr )
{
   switch( propAttr )
   {
      case  pa_Name:
      case  pa_DisplayName:
      case  pa_Type:
      case  pa_DsNames:
      case  pa_OID:
      case  pa_MaxRange:
      case  pa_MinRange:
      case  pa_Mandatory:
      case  pa_MultiValued:
         return m_strAttributes[ propAttr ];

      default:
         ASSERT( FALSE );
         return CString( _T("???") );
   }
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CProperty::PutAttribute( PROPATTR propAttr, CString& )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CProperty::SetMandatory( BOOL bMandatory )
{
   m_bMandatory   = bMandatory;

   m_strAttributes[ pa_Mandatory ]  = bMandatory ? _T("Yes") : _T("No");

   return TRUE;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CProperty::GetMandatory( )
{
   return m_bMandatory;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString CProperty::VarToDisplayString( VARIANT& var, BOOL bUseEx )
{
   return m_pSyntax->VarToDisplayString( var, m_bMultiValued, bUseEx );
}

/***********************************************************
  Function:    CProperty::Value2Native
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT CProperty::Value2Native( ADS_ATTR_INFO* pAttr, CString& rVal )
{
   HRESULT  hResult;
   ADSTYPE  eADsType;

   hResult  = m_pSyntax->Value2Native( pAttr, rVal );

   eADsType = (ADSTYPE)(m_pSyntax->m_dwSyntaxID);

   if( ADSTYPE_INVALID != eADsType )
   {
      pAttr->dwADsType  = eADsType;

      if( SUCCEEDED( hResult ) )
      {
         for( DWORD idx = 0; idx < pAttr->dwNumValues ; idx++ )
         {
            pAttr->pADsValues[ idx ].dwType  = eADsType;
         }
      }
   }

   return hResult;
}


/***********************************************************
  Function:    CProperty::Value2Native
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CProperty::FreeAttrInfo( ADS_ATTR_INFO* pAttrInfo )
{
   m_pSyntax->FreeAttrInfo( pAttrInfo );
}


/***********************************************************
  Function:    CProperty::Native2Value
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT CProperty::Native2Value( ADS_ATTR_INFO* pAttr, CString& rVal )
{
   if( pAttr->dwNumValues )
   {
      SetSyntaxID( pAttr->dwADsType );
      if( pAttr->pADsValues[ 0 ].dwType != pAttr->dwADsType )
      {
         TRACE( _T("ERROR: Property type differs from value type\n") );
      }
   }
   //if( ADSTYPE_INVALID != pAttr->dwADsType )
   //{
   CreateSyntax( (ADSTYPE) pAttr->dwADsType );

   return m_pSyntax->Native2Value( pAttr, rVal );
   //}
   //else
   //{
   //   rVal  = _T("ERROR: ADSTYPE_INVALID") ;
   //   return S_OK;
   //}
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CProperty::DisplayStringToDispParams( CString& rText, DISPPARAMS& dispParams, BOOL bUseEx )
{
   return m_pSyntax->DisplayStringToDispParams( rText, dispParams, m_bMultiValued, bUseEx );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CProperty::SetSyntaxID( DWORD dwSyntaxID )
{
   if( m_dwSyntaxID )
   {
      ASSERT( dwSyntaxID == m_dwSyntaxID );
   }
   m_dwSyntaxID   = dwSyntaxID;

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD CProperty::GetSyntaxID( )
{
   ASSERT( m_dwSyntaxID );

   return m_dwSyntaxID;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
/*CFuncSet::CFuncSet( )
{
   m_pProperties  = new CObArray;
   m_pMethods     = new CObArray;

   for( int nIdx = fa_ERROR; nIdx < fa_Limit ; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("???");
   }

   m_strAttributes[ fa_MethodsCount ] = _T("0");
} */


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
/*CFuncSet::CFuncSet( CString& strName )
{
   m_pProperties     = new CObArray;
   m_pMethods        = new CObArray;

   for( int nIdx = fa_ERROR; nIdx < fa_Limit ; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("???");
   }

   m_strAttributes[ fa_MethodsCount ] = _T("0");

   m_strAttributes[ fa_Name ]          = strName;
   m_strAttributes[ fa_DisplayName ]   = strName;
}*/



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CClass::AddProperty( CProperty* pProperty )
{
   m_pProperties->Add( pProperty );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
/*CFuncSet::~CFuncSet( )
{
   int nSize, nIdx;

   nSize = m_pProperties->GetSize( );

   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      delete m_pProperties->GetAt( nIdx );
   }

   m_pProperties->RemoveAll( );
   delete m_pProperties;

   // ****
   nSize = m_pMethods->GetSize( );

   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      delete m_pMethods->GetAt( nIdx );
   }

   m_pMethods->RemoveAll( );
   delete m_pMethods;
}*/


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CClass::GetPropertyCount( )
{
   return (int)m_pProperties->GetSize( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CClass::GetAttribute( int nProp, PROPATTR propAttr )
{
   CProperty*  pProperty;

   pProperty   = GetProperty( nProp );

   return pProperty->GetAttribute( propAttr );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::PutAttribute( int nProp, PROPATTR propAttr, CString& rValue )
{
   CProperty*  pProperty;

   pProperty   = GetProperty( nProp );

   return pProperty->PutAttribute( propAttr, rValue );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CClass::GetAttribute( int nMethod, METHODATTR methAttr )
{
   CMethod*  pMethod;

   pMethod   = GetMethod( nMethod );

   return pMethod->GetAttribute( methAttr );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::PutAttribute( int nMethod, METHODATTR methAttr, CString& rValue )
{
   CMethod*  pMethod;

   pMethod   = GetMethod( nMethod );

   return pMethod->PutAttribute( methAttr, rValue );
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CClass::VarToDisplayString( int nPropIndex, VARIANT& var, BOOL bUseEx )
{
   return GetProperty( nPropIndex )->VarToDisplayString( var, bUseEx );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CClass::DisplayStringToDispParams( int nPropIndex, CString& strText, DISPPARAMS& var, BOOL bUseEx )
{
   return GetProperty( nPropIndex )->DisplayStringToDispParams( strText, var, bUseEx );
}


/***********************************************************
  Function: CClass::GetFunctionalSet
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CClass::LookupProperty( CString&  strProperty )
{
   int         nMax, nIter;
   CProperty*  pProperty;
   BOOL        bFound   = FALSE;

   nMax  = (int)m_pProperties->GetSize( );

   for( nIter = 0; nIter < nMax && !bFound ; nIter++ )
   {
      pProperty   = (CProperty*) ( m_pProperties->GetAt( nIter ) );
      bFound        = bFound || ( strProperty == pProperty->GetAttribute( pa_Name ) );
      if( bFound )
         break;
   }

   return ( bFound ? nIter : -1 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty*  CClass::GetProperty( int nIndex )
{
   int         nMax;
   CProperty*  pProp;

   nMax  = (int)m_pProperties->GetSize( );

   ASSERT( nIndex >= 0 && nIndex < nMax );

   pProp = (CProperty*) ( m_pProperties->GetAt( nIndex  ) );

   return pProp;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CMethod*  CClass::GetMethod( int nIndex )
{
   int         nMax;
   CMethod*  pProp;

   nMax  = (int)m_pMethods->GetSize( );

   ASSERT( nIndex >= 0 && nIndex < nMax );

   pProp = (CMethod*) ( m_pMethods->GetAt( nIndex  ) );

   return pProp;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
REFIID   CClass::GetMethodsInterface( )
{
   return m_refMethods;
}

/***********************************************************
  Function:    CClass::HasMandatoryProperties
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     CClass::HasMandatoryProperties( )
{
   BOOL  bHas  = FALSE;
   int   nIter, nSize;

   nSize = (int)m_pProperties->GetSize( );

   for( nIter = 0; nIter < nSize && !bHas ; nIter++ )
   {
      bHas |= GetProperty( nIter )->GetMandatory( );
   }

   return bHas;
}


/***********************************************************
  Function:    CFuncSet::LoadMethodsInformation
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::LoadMethodsInformation( ITypeInfo* pITypeInfo )
{
   HRESULT     hResult= S_OK;
   int         nIdx;
   CString     strMethodName;
   FUNCDESC*   pFuncDesc;
   CMethod*    pMethod;
   TCHAR       szCount[ 16 ];

   while( TRUE )
   {
      for( nIdx = 0; nIdx < 200 ; nIdx++ )
      {
         hResult  = pITypeInfo->GetFuncDesc( nIdx, &pFuncDesc );
         // now, we have function description, we must search for function type
         if( FAILED( hResult ) )
            continue;

         if( INVOKE_FUNC != pFuncDesc->invkind || pFuncDesc->memid > 1000 )
         {
            pITypeInfo->ReleaseFuncDesc( pFuncDesc );
            continue;
         }

         pMethod  = new CMethod( pITypeInfo, pFuncDesc );

         pITypeInfo->ReleaseFuncDesc( pFuncDesc );

         strMethodName  = pMethod->GetAttribute( ma_Name );
         if( !strMethodName.CompareNoCase( _T("Get") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("GetEx") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("Put") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("PutEx") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("GetInfo") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("SetInfo") ) )
         {
            delete pMethod;
            continue;
         }

         m_pMethods->Add( pMethod );
      }

      break;
   }

   _itot( (int)m_pMethods->GetSize( ), szCount, 10 );

   m_strAttributes [ ca_MethodsCount ] = szCount;

   return hResult;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  GetFuncSetName( VARIANT& v, CString& strFuncSet, int nIdx )
{
   SAFEARRAY*  pSafeArray;
   TCHAR       szText[ 256 ];
   VARIANT     varString;
   long        lBound, uBound, lItem;
   HRESULT     hResult;
   BOOL        bFirst;
   BSTR        bstrVal;
   CString     strTemp;


   strFuncSet.Empty( );

   ASSERT( V_VT( &v ) & VT_ARRAY );

   pSafeArray   = V_ARRAY( &v );

   hResult = SafeArrayGetLBound(pSafeArray, 1, &lBound);
   hResult = SafeArrayGetUBound(pSafeArray, 1, &uBound);

   VariantInit( &varString );
   szText[ 0 ]    = _T('\0');
   bFirst         = TRUE;

   lItem    = lBound + nIdx;
   hResult  = SafeArrayGetElement( pSafeArray, &lItem, &bstrVal );
   if( FAILED( hResult ) )
   {
      return FALSE;
   }

   strTemp  = bstrVal;
   SysFreeString( bstrVal );
   if( -1 != strTemp.Find( _T('.') ) )
   {
      strFuncSet  = strTemp.SpanExcluding( _T(".") );
   }

   strFuncSet.TrimLeft( );

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CClass::CClass  ( TCHAR* pszClass, REFIID rPrimaryInterface )
:m_refMethods( IID_IADs )
{
   LPOLESTR pOleStr;
   HRESULT  hResult;

   m_pProperties     = new CObArray;
   m_pMethods        = new CObArray;

   for( int nIdx = ca_ERROR; nIdx < ca_Limit; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("NA");
   }

   m_strAttributes[ ca_Name ] = pszClass;

   hResult  = StringFromIID( rPrimaryInterface, &pOleStr );

   if( SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_PrimaryInterface ] = pOleStr;
      //SysFreeString( pOleStr );
      CoTaskMemFree( pOleStr );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CClass::CClass( CString& strSchema, CMainDoc* pMainDoc )
:m_refMethods( IID_IADs )
{
   HRESULT           hResult;
   IADsClass*      pIOleDsClass   = NULL;
   IADs*           pIOleDsCls     = NULL;
   IADsContainer*  pContainer     = NULL;
   IUnknown*         pEnum          = NULL;
   IEnumVARIANT*     pIEnumVar      = NULL;
   BSTR              bstrText= NULL;
   VARIANT           aVar;
   CString           strAliased;
   IADsProperty*   pIProperty     = NULL;
   IADs*           pIOleDs        = NULL;
   VARIANT_BOOL      varBOOL;
   CString           strFuncSet;
   CString           strProperty;
   CString           strTemp;
   long              lTemp;
   VARIANT           vGet;

   m_pMainDoc        = pMainDoc;
   m_pProperties     = new CObArray;
   m_pMethods        = new CObArray;

   for( int nIdx = ca_ERROR; nIdx < ca_Limit; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("???");
   }


   {
      TCHAR szPath [ 512 ];

      hResult        = m_pMainDoc->XOleDsGetObject( strSchema.GetBuffer( 128 ),
                                                    IID_IADsClass,
                                                    (void**) &pIOleDsClass );
      if( FAILED( hResult ) )
      {
         _tcscpy( szPath, strSchema.GetBuffer( 256 ) );
         _tcscat( szPath, _T(",Class") );
         hResult  = m_pMainDoc->XOleDsGetObject( szPath, IID_IADsClass, (void**) &pIOleDsClass );
      }
   }

   if( FAILED( hResult ) )
   {
      TRACE( _T("Could not open schema object\n") );
      return;
   }

   hResult  = pIOleDsClass->QueryInterface( IID_IADs, (void**) &pIOleDsCls );

   //*******************
   hResult                    = pIOleDsClass->get_Name( &bstrText );
   ASSERT( SUCCEEDED( hResult ) );
   m_strAttributes[ ca_Name ] = bstrText;
   SysFreeString( bstrText );
   bstrText       = NULL;

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("CLSID"), &vGet );
   bstrText = V_BSTR( &vGet );
   if( FAILED(  hResult ) )
   {
      hResult  = pIOleDsClass->get_CLSID( &bstrText );
   }
   if( bstrText && SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_CLSID ]   = bstrText;
      SysFreeString( bstrText );
   }
   else
   {
      m_strAttributes[ ca_CLSID ]   = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("PrimaryInterface"), &vGet );
   bstrText = V_BSTR( &vGet );
   if( FAILED( hResult ) )
   {
      hResult  = pIOleDsClass->get_PrimaryInterface( &bstrText );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( bstrText && SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_PrimaryInterface ]   = bstrText;
      SysFreeString( bstrText );
   }
   else
   {
      m_strAttributes[ ca_PrimaryInterface ]   = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("HelpFileName"), &vGet );
   bstrText = V_BSTR( &vGet );
   if( FAILED( hResult ) )
   {
      hResult        = pIOleDsClass->get_HelpFileName( &bstrText );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( bstrText && SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_HelpFileName ]   = bstrText;
      SysFreeString( bstrText );
   }
   else
   {
      m_strAttributes[ ca_HelpFileName ]   = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("HelpFileContext"), &vGet );
   lTemp    = V_I4( &vGet );
   if( FAILED( hResult ) )
   {
      hResult        = pIOleDsClass->get_HelpFileContext( &lTemp );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ) )
   {
      TCHAR szText[ 128 ];

      _ltot( lTemp, szText, 10 );
      m_strAttributes[ ca_HelpFileContext ]   = szText;
   }
   else
   {
      m_strAttributes[ ca_HelpFileContext ]   = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("OID"), &vGet );
   bstrText = V_BSTR( &vGet );
   if( FAILED( hResult ) )
   {
      hResult        = pIOleDsClass->get_OID( &bstrText );
   }
   //ASSERT( bstrText && SUCCEEDED( hResult ) );
   if( bstrText && SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_OID ]   = bstrText;
      SysFreeString( bstrText );
   }
   else
   {
      m_strAttributes[ ca_OID ]   = _T("NA");
   }


   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("Container"), &vGet );
   varBOOL  = V_BOOL( &vGet );
   if( FAILED( hResult ) )
   {
      hResult  = pIOleDsClass->get_Container( (VARIANT_BOOL*)&varBOOL );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ) )
   {
      m_bContainer   = (BOOL)varBOOL;
      m_strAttributes[ ca_Container ]  = m_bContainer ? _T("YES") :_T("No");
   }
   else
   {
      m_strAttributes[ ca_Container ]  = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("Abstract"), &vGet );
   varBOOL  = V_BOOL( &vGet );
   if( FAILED( hResult ) )
   {
      hResult        = pIOleDsClass->get_Abstract( (VARIANT_BOOL*)&varBOOL );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_Abstract ]  = varBOOL ? _T("YES") :_T("No");
   }
   else
   {
      m_strAttributes[ ca_Abstract ]  = _T("NA");
   }


   //*******************
   hResult  = Get( pIOleDsCls, _T("DerivedFrom"), &aVar );
   if( FAILED( hResult ) )
   {
      hResult  = pIOleDsClass->get_DerivedFrom( &aVar );
   }
   if( SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_DerivedFrom ]   = FromVariantToString( aVar );
      VariantClear( &aVar );
   }
   else
   {
      m_strAttributes[ ca_DerivedFrom ]   = _T("NA");
   }

   //*******************
   hResult  = Get( pIOleDsCls, _T("Containment"), &aVar );
   if( FAILED( hResult ) )
   {
      hResult           = pIOleDsClass->get_Containment( &aVar );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ) )
   {
      //m_strAttributes[ ca_Containment ]   = FromVariantToString( aVar );
      m_strAttributes[ ca_Containment ]   = FromVariantArrayToString( aVar );
      VariantClear( &aVar );
   }
   else
   {
      m_strAttributes[ ca_Containment ]   = _T("NA");
   }

   //strFuncSet.Empty( );
   //pFuncSet = new CFuncSet( strFuncSet );
   //m_pFuncSets->Add( pFuncSet );

   BuildMandatoryPropertiesList( pIOleDsClass );

   //********************
   BuildOptionalPropertiesList( pIOleDsClass );

   pIOleDsClass->Release( );
   pIOleDsCls->Release( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::BuildOptionalPropertiesList( IADsClass* pIClass )
{
   HRESULT  hResult;
   VARIANT  aOptionalProperty;

   hResult  = Get( pIClass, _T("OptionalProperties"), &aOptionalProperty );
   if( FAILED( hResult ) )
   {
      hResult  = pIClass->get_OptionalProperties( &aOptionalProperty );
   }
   if( SUCCEEDED( hResult ) )
   {
      AddProperties( pIClass, aOptionalProperty, FALSE );
      VariantClear( &aOptionalProperty );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::AddProperties( IADsClass* pIClass, VARIANT& rVar, BOOL bMandatory )
{
   HRESULT  hResult;
   IADs*  pIOleDs  = NULL;
   BSTR     bstrParent;

   while( TRUE )
   {
      hResult  = pIClass->QueryInterface( IID_IADs, (void**)&pIOleDs );
      if( FAILED( hResult ) )
         break;

      hResult  = pIClass->get_Parent( &bstrParent );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      if( VT_BSTR == V_VT( &rVar ) )
      {
         AddProperty( bstrParent, V_BSTR( &rVar ), bMandatory );
      }
      else
      {
         SAFEARRAY*  pSafeArray;
         VARIANT     varString;
         long        lBound, uBound, lItem;
         HRESULT     hResult;

         ASSERT( V_VT( &rVar ) & (VT_VARIANT | VT_ARRAY) );

         pSafeArray   = V_ARRAY( &rVar );

         hResult = SafeArrayGetLBound(pSafeArray, 1, &lBound);
         hResult = SafeArrayGetUBound(pSafeArray, 1, &uBound);

         VariantInit( &varString );
         for( lItem = lBound; lItem <= uBound ; lItem++ )
         {
            hResult  = SafeArrayGetElement( pSafeArray, &lItem, &varString );
            ASSERT( VT_BSTR == V_VT( &varString ) );

            if( FAILED( hResult ) )
            {
               break;
            }
            AddProperty( bstrParent, V_BSTR( &varString ), bMandatory );
            VariantClear( &varString );
         }
      }
      SysFreeString( bstrParent );

      break;
   }

   if( pIOleDs )
      pIOleDs->Release( );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::AddProperty( BSTR bstrSchema, BSTR bstrName, BOOL bMandatory )
{
   HRESULT  hResult;
   WCHAR    szPath[ 1024 ];
   IADs*  pIOleDs;

   szPath[0] = L'\0';
   wcscpy( szPath, bstrSchema );
   wcscat( szPath, L"/" );
   wcscat( szPath, bstrName );

   hResult  = m_pMainDoc->XOleDsGetObject( szPath, IID_IADs, (void**)&pIOleDs );
   if( FAILED( hResult ) )
   {
      // OK, let's qualify it...
      wcscat( szPath, L",Property" );
      hResult  = m_pMainDoc->XOleDsGetObject( szPath, IID_IADs, (void**)&pIOleDs );
   }
   if( SUCCEEDED( hResult ) )
   {
      CProperty*  pProperty;

      //hResult     = pIOleDs->GetInfo( );
      pProperty   = new CProperty( pIOleDs );
      pProperty->SetMandatory( bMandatory );
      AddProperty( pProperty );

      pIOleDs->Release( );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::BuildOptionalPropertiesList( IADsContainer* pIContainer )
{
   return S_OK;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::BuildMandatoryPropertiesList( IADsClass* pIClass )
{
   HRESULT  hResult;
   VARIANT  aMandatoryProperties;

   hResult  = Get( pIClass, _T("MandatoryProperties"), &aMandatoryProperties );
   if( FAILED( hResult ) )
   {
      hResult  = pIClass->get_MandatoryProperties( &aMandatoryProperties );
   }
   if( SUCCEEDED( hResult ) )
   {
      AddProperties( pIClass, aMandatoryProperties, TRUE );
      VariantClear( &aMandatoryProperties );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::LoadMethodsInformation( TCHAR* pszOperationsInterface )
{
   HRESULT     hResult= S_OK;
   ITypeLib*   pITypeLib   = NULL;
   ITypeInfo*  pITypeInfo  = NULL;
   BSTR        bstrPath;
   BSTR        bstrOperationsInterface;
   CString     strGUID;
   MEMBERID    aMemId;
   unsigned short     aFind = 1;

   while( TRUE )
   {
      hResult  = QueryPathOfRegTypeLib( LIBID_ADs, 1, 0,
                                        LOCALE_SYSTEM_DEFAULT, &bstrPath );
      if( FAILED( hResult ) )
         break;

      hResult  = LoadTypeLib( bstrPath, &pITypeLib );
      SysFreeString( bstrPath );

      if( FAILED( hResult ) )
         break;

      bstrOperationsInterface = AllocBSTR( pszOperationsInterface );
      hResult  = pITypeLib->FindName( (OLECHAR FAR* )bstrOperationsInterface,
                                      0,
                                      &pITypeInfo,
                                      &aMemId,
                                      &aFind );
      SysFreeString( bstrOperationsInterface );

      if( FAILED( hResult ) || !aFind )
         break;

      LoadMethodsInformation( pITypeInfo );

      break;
   }

   if( NULL != pITypeInfo )
      pITypeInfo->Release( );

   if( NULL != pITypeLib )
      pITypeLib->Release( );

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::ReadMandatoryPropertiesInformation( VARIANT* pVar )
{
   CString     strTemp;
   CString     strWork;
   CString     strProperty;
   CProperty*  pProperty;
   int         nProp;

   strTemp  = FromVariantToString( *pVar );
   strTemp.TrimLeft( );

   while( strTemp.GetLength( ) )
   {
      CString  strMandProp;
      int      nPos;

      strMandProp = strTemp.SpanExcluding( _T("#") );
      nPos        = strMandProp.Find( _T('.') );

      nPos++;
      strProperty    = strMandProp.GetBuffer( 128 ) + nPos;

      // get rid of leading spaces
      strProperty.TrimLeft( );

      nProp    = LookupProperty( strProperty );
      ASSERT( -1 != nProp    );

      if( -1 == nProp  )
         break;

      pProperty   = GetProperty( nProp );

      pProperty->SetMandatory( TRUE );

      strWork     = strTemp;
      nPos        = strWork.Find( _T('#') );
      if( -1 == nPos )
      {
         strWork.Empty( );
      }
      nPos++;
      strTemp     = strWork.GetBuffer( 128 ) + nPos;

      strTemp.TrimLeft( );
   }

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CClass::CClass( )
:m_refMethods( IID_IADs )

{
   for( int nIdx = ca_ERROR; nIdx < ca_Limit; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("???");
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CClass::~CClass( )
{
   int   nSize, nIdx;

   nSize = (int)m_pProperties->GetSize( );
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      delete m_pProperties->GetAt( nIdx );
   }

   m_pProperties->RemoveAll( );
   delete m_pProperties;

   // ****
   nSize = (int)m_pMethods->GetSize( );
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      delete m_pMethods->GetAt( nIdx );
   }

   m_pMethods->RemoveAll( );
   delete m_pMethods;
}


/***********************************************************
  Function:    CClass::GetAttribute
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CClass::GetAttribute( CLASSATTR classAttr )
{
   switch( classAttr )
   {
      case  ca_Name:
      case  ca_DisplayName:
      case  ca_CLSID:
      case  ca_OID:
      case  ca_Abstract:
      case  ca_DerivedFrom:
      case  ca_Containment:
      case  ca_Container:
      case  ca_PrimaryInterface:
      case  ca_HelpFileName:
      case  ca_HelpFileContext:
      case  ca_MethodsCount:
         return m_strAttributes[ classAttr ];

      default:
         ASSERT( FALSE );
         return m_strAttributes[ ca_ERROR ];
   }
}


/***********************************************************
  Function:    CClass::PutAttribute
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::PutAttribute( CLASSATTR classAttr, CString& )
{
   return E_FAIL;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\service.h ===
#ifndef  _CSERVICE_H_
#define  _CSERVICE_H_

class COleDsService: public COleDsObject
{

public:   
   COleDsService( IUnknown* );
   COleDsService( );
   ~COleDsService( );

public:
   virtual  HRESULT  PutProperty( int, int, CString& );
   virtual  HRESULT  PutProperty( CString&, CString&, CString& );
   virtual  HRESULT  GetProperty( int, int, CString& );
   virtual  HRESULT  GetProperty( CString&, CString&, CString& );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\splitter.cpp ===
// splitter.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "viewex.h"
#include "schemavw.h"
#include "bwsview.h"
//#include "queryvw.h"
#include "splitter.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSplitterFrame

// Create a splitter window which splits an output text view and an input view
//                           |
//    TEXT VIEW (CTextView)  | INPUT VIEW (CInputView)
//                           |

IMPLEMENT_DYNCREATE(CSplitterFrame, CMDIChildWnd)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CSplitterFrame::CSplitterFrame()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CSplitterFrame::~CSplitterFrame()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CSplitterFrame::OnCreateClient(LPCREATESTRUCT,
	 CCreateContext* pContext)
{
	// create a splitter with 1 row, 2 columns
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
	{
		TRACE0("Failed to CreateStaticSplitter\n");
		return FALSE;
	}

	// add the first splitter pane - the default view in column 0
	if (!m_wndSplitter.CreateView(0, 0,
		pContext->m_pNewViewClass, CSize(150, 180), pContext))
	{
		TRACE0("Failed to create first pane\n");
		return FALSE;
	}

	// add the second splitter pane - an input view in column 1
	if (!m_wndSplitter.CreateView(0, 1,
		RUNTIME_CLASS(CSchemaView), CSize(0, 0), pContext))
	{
		TRACE0("Failed to create second pane\n");
		return FALSE;
	}

	// activate the input view
	SetActiveView((CView*)m_wndSplitter.GetPane(0,1));

	return TRUE;
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
int CSplitterFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// TODO: Add your specialized creation code here

   //ShowWindow( SW_MAXIMIZE ); 
	return 0;
}


BEGIN_MESSAGE_MAP(CSplitterFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CSplitterFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CQuerySplitterFrame

// Create a splitter window which splits an output text view and an input view
//                           |
//    TEXT VIEW (CTextView)  | INPUT VIEW (CInputView)
//                           |

IMPLEMENT_DYNCREATE(CQuerySplitterFrame, CMDIChildWnd)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CQuerySplitterFrame::CQuerySplitterFrame()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CQuerySplitterFrame::~CQuerySplitterFrame()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CQuerySplitterFrame::OnCreateClient(LPCREATESTRUCT,
	 CCreateContext* pContext)
{
	// create a splitter with 1 row, 2 columns
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
	{
		TRACE0("Failed to CreateStaticSplitter\n");
		return FALSE;
	}

	// add the first splitter pane - the default view in column 0
	if (!m_wndSplitter.CreateView(0, 0,
		pContext->m_pNewViewClass, CSize(150, 180), pContext))
	{
		TRACE0("Failed to create first pane\n");
		return FALSE;
	}

	// add the second splitter pane - an input view in column 1
//#ifdef   TRIAL
//	if (!m_wndSplitter.CreateView(0, 1,
//		RUNTIME_CLASS(CQueryView), CSize(0, 0), pContext))
//	{
//		TRACE0("Failed to create second pane\n");
//		return FALSE;
//	}
//#endif

	// activate the input view
	SetActiveView((CView*)m_wndSplitter.GetPane(0,1));

	return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
int CQuerySplitterFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// TODO: Add your specialized creation code here

   //ShowWindow( SW_MAXIMIZE ); 
	return 0;
}


BEGIN_MESSAGE_MAP(CQuerySplitterFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CQuerySplitterFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define VC_EXTRALEAN

#pragma warning( disable: 4237 )
#pragma warning( disable: 4005 )
#include "dswarn.h"

//#define  UNICODE
//#define  _UNICODE

//#define  _DEBUG
//#define  DEBUG


#include <afxwin.h>
#include <afxext.h>         // MFC extensions like CFormView, CSplitterWnd
#include <afxcview.h>
#include <ole2.h>
#include <activeds.h>
#include <oledb.h>
#include "objects.h"
#include "testcore.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\schemavw.h ===
// schemavw.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSchemaView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "cacls.h"

class CSchemaView : public CFormView
{
protected:
	CSchemaView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CSchemaView)

// Form Data
public:
	//{{AFX_DATA(CSchemaView)
	enum { IDD = IDD_SCHEMA };
	CStatic	m_ClassOID;
	CStatic	m_Abstract;
	CStatic	m_MultiValued;
	CStatic	m_DsNames;
	CStatic	m_PropOID;
	CStatic	m_Mandatory;
	CStatic	m_Containment;
	CStatic	m_ItemOleDsPath;
	CStatic	m_PropertyMinRange;
	CStatic	m_PropertyMaxRange;
	CStatic	m_PropertyType;
	CStatic	m_PrimaryInterface;
	CStatic	m_HelpFileContext;
	CStatic	m_DerivedFrom;
	CStatic	m_HelpFileName;
	CStatic	m_CLSID;
	CStatic	m_Container;
	CStatic	m_ClassType;
	CEdit	m_PropValue;
	CComboBox	m_PropList;
	//CTabCtrl	m_Schema;
	//}}AFX_DATA

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSchemaView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual  ~CSchemaView         ( );
   HRESULT  PutPropertyValue     ( );
   void     ResetObjectView      ( );
   void     DisplayPropertiesList( );
   void     DisplayCurrentPropertyText( );
   ADSTYPE  ConvertToADsType     ( CString strText );

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CSchemaView)
	afx_msg void OnSelchangeProplist();
	afx_msg void OnReload();
	afx_msg void OnApply();
	afx_msg void OnSetfocusPropvalue();
	afx_msg void OnMethod1();
	afx_msg void OnMethod2();
	afx_msg void OnMethod3();
	afx_msg void OnMethod4();
	afx_msg void OnMethod5();
	afx_msg void OnMethod6();
	afx_msg void OnMethod7();
	afx_msg void OnMethod8();
	afx_msg void OnAppend();
   afx_msg void OnDelete();
	afx_msg void OnChange();
	afx_msg void OnClear();
	afx_msg void OnGetProperty();
	afx_msg void OnPutProperty();
	afx_msg void OnACEChange();
	afx_msg void OnACEPropertyChange();
	afx_msg void OnACLChange();
	afx_msg void OnSDPropertyChange();
	afx_msg void OnAddACE();
	afx_msg void OnCopyACE();
	afx_msg void OnPasteACE();
	afx_msg void OnRemoveACE();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Other members
protected:
	void  FillACLControls( void );
	IDispatch* m_pDescriptor;

	ACLTYPE  GetCurrentACL( void );
   int      GetCurrentACE( void );
   int      GetCurrentSDProperty( void );
   int      GetCurrentACEProperty( void );
   
   void DisplayACL   ( COleDsObject* pObject, CString strAttrName );
	void HideControls ( BOOL bNormal );
	void ShowControls ( BOOL bNormal );

   void PutACEPropertyValue       ( void );
   void PutSDPropertyValue       ( void );

	void DisplaySDPropertyValue   ( void );
	void DisplayACEPropertyValue  ( void );

   void DisplaySDPropertiesList  ( int nSelect = 0 );
	void DisplayACEPropertiesList ( int nSelect = 0 );

   void DisplayACLNames          ( int nSelect = 0 );
   void DisplayACENames          ( int nSelect = 0 );

protected:
	void MoveSecurityWindows( void );
	ACLTYPE GetSelectedACL( void );
	BOOL              m_bACLDisplayed;
   int               m_nProperty;
   BOOL              m_bStatus;
   BOOL              m_bDirty;
   BOOL              m_bInitialized;
	int               m_arrNormalControls[ 64 ];
   int               m_arrSecurityControls[ 64 ];
   
   CADsSecurityDescriptor*     pSecurityDescriptor;

   int               m_nLastSD;
   int               m_nLastSDValue;
   
   int               m_nLastACE;
   int               m_nLastACEValue;

   ACLTYPE           m_nLastACL;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSetMandatoryProperties dialog

class CSetMandatoryProperties : public CDialog
{
// Construction
public:
	CSetMandatoryProperties(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSetMandatoryProperties)
	enum { IDD = IDD_SETPROPERTIES };
	CStatic	m_Containment;
	CStatic	m_ItemOleDsPath;
	CStatic	m_PropertyOptional;
	CStatic	m_PropertyNormal;
	CStatic	m_PropertyMinRange;
	CStatic	m_PropertyMaxRange;
	CStatic	m_PropertyType;
	CStatic	m_PrimaryInterface;
	CStatic	m_HelpFileContext;
	CStatic	m_DerivedFrom;
	CStatic	m_HelpFileName;
	CStatic	m_CLSID;
	CStatic	m_Container;
	CStatic	m_ClassType;
	CEdit	m_PropValue;
	CComboBox	m_PropList;
	CTabCtrl	m_Schema;

		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSetMandatoryProperties)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
   void  SetOleDsObject( COleDsObject* );

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSetMandatoryProperties)
	afx_msg void OnSelchangeProperties(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchangeProplist();
	afx_msg void OnOK();
	afx_msg void OnSetfocusPropvalue();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:   
   HRESULT  PutPropertyValue( );

protected:
   COleDsObject*  m_pObject;
   int   m_nFuncSet;
   int   m_nProperty;
   BOOL  m_bStatus;
   BOOL  m_bDirty;
   BOOL  m_bInitialized;

};
/////////////////////////////////////////////////////////////////////////////
// CPropertyDialog dialog

class CPropertyDialog : public CDialog
{
// Construction
public:
	CPropertyDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPropertyDialog)
	enum { IDD = IDD_ADDPROPERTY };
	CString	m_PropertyName;
	CString	m_PropertyType;
	CString	m_PropertyValue;
	//}}AFX_DATA

   void  SaveLRUList ( int idCBox, TCHAR* szSection, int nMax = 100 );
   void  GetLRUList  ( int idCBox, TCHAR* szSection );

public:
   BOOL  m_bMultiValued;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertyDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPropertyDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\splitter.h ===
// splitter.h : custom splitter control and frame that contains it
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CSplitterFrame frame with splitter/wiper

class CSplitterFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CSplitterFrame)
protected:
	CSplitterFrame();   // protected constructor used by dynamic creation

// Attributes
protected:
	CSplitterWnd m_wndSplitter;

// Implementation
public:
	virtual ~CSplitterFrame();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// Generated message map functions
	//{{AFX_MSG(CSplitterFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CQuerySplitterFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CQuerySplitterFrame)
protected:
	CQuerySplitterFrame();   // protected constructor used by dynamic creation

// Attributes
protected:
	CSplitterWnd m_wndSplitter;

// Implementation
public:
	virtual ~CQuerySplitterFrame();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// Generated message map functions
	//{{AFX_MSG(CSplitterFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

class C3WaySplitterFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(C3WaySplitterFrame)
protected:
	C3WaySplitterFrame();   // protected constructor used by dynamic creation

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
	CSplitterWnd m_wndSplitter2;        // embedded in the first

// Implementation
public:
	virtual ~C3WaySplitterFrame();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// Generated message map functions
	//{{AFX_MSG(C3WaySplitterFrame)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\simpvw.cpp ===
// simpvw.cpp : implementation of the simple view classes
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.



#include "stdafx.h"
#include "viewex.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTextView

IMPLEMENT_DYNCREATE(CTextView, CView)

BEGIN_MESSAGE_MAP(CTextView, CView)
	//{{AFX_MSG_MAP(CTextView)
	ON_WM_MOUSEACTIVATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTextView construction/destruction

CTextView::CTextView()
{
}

CTextView::~CTextView()
{
}

/////////////////////////////////////////////////////////////////////////////
// CTextView drawing

void CTextView::OnDraw(CDC* pDC)
{
	CMainDoc* pDoc = GetDocument();

	CRect rect;
	GetClientRect(rect);
	pDC->SetTextAlign(TA_BASELINE | TA_CENTER);
	pDC->SetBkMode(TRANSPARENT);
	// center in the window
	/*pDC->TextOut(rect.Width() / 2, rect.Height() / 2,
		pDoc->m_strData, pDoc->m_strData.GetLength());*/
}


int CTextView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	// side-step CView's implementation since we don't want to activate
	//  this view
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

/////////////////////////////////////////////////////////////////////////////
// CColorView

IMPLEMENT_DYNCREATE(CColorView, CView)

BEGIN_MESSAGE_MAP(CColorView, CView)
	//{{AFX_MSG_MAP(CColorView)
	ON_WM_MOUSEACTIVATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CColorView construction/destruction

CColorView::CColorView()
{
}

CColorView::~CColorView()
{
}

/////////////////////////////////////////////////////////////////////////////
// CColorView drawing

void CColorView::OnDraw(CDC* pDC)
{
	CMainDoc* pDoc = GetDocument();

	CRect rect;
	GetClientRect(rect);

	// fill the view with the specified color

}

int CColorView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	// side-step CView's implementation since we don't want to activate
	//  this view
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

void CColorView::OnActivateView(BOOL, CView*, CView*)
{
	ASSERT(FALSE);      // output only view - should never be active
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CNameView

IMPLEMENT_DYNCREATE(CNameView, CEditView)

CNameView::CNameView()
{
}

CNameView::~CNameView()
{
}


BEGIN_MESSAGE_MAP(CNameView, CEditView)
	//{{AFX_MSG_MAP(CNameView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNameView drawing


/////////////////////////////////////////////////////////////////////////////
// CNameView diagnostics

#ifdef _DEBUG
void CNameView::AssertValid() const
{
	CEditView::AssertValid();
}

void CNameView::Dump(CDumpContext& dc) const
{
	CEditView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNameView message handlers

void CNameView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// TODO: Add your specialized code here and/or call the base class
	//CString  strText;

   //GetDocument( )->GetItemName( strText );
   
   //GetEditCtrl().SetWindowText( strText );

   CEditView::OnUpdate( pSender, lHint, pHint );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\stdafx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\simpvw.h ===
// simpvw.h : interface of the simple view classes
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// CTextView - text output
// CColorView - color output

/////////////////////////////////////////////////////////////////////////////

class CTextView : public CView
{
protected: // create from serialization only
	CTextView();
	DECLARE_DYNCREATE(CTextView)

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}

// Operations
public:

// Implementation
public:
	virtual ~CTextView();
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view

// Generated message map functions
protected:
	//{{AFX_MSG(CTextView)
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

class CColorView : public CView
{
protected: // create from serialization only
	CColorView();
	DECLARE_DYNCREATE(CColorView)

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}

// Operations
public:

// Implementation
public:
	virtual ~CColorView();
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);

// Generated message map functions
protected:
	//{{AFX_MSG(CColorView)
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};





/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CNameView view

class CNameView : public CEditView
{
protected:
	CNameView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CNameView)

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}


// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNameView)
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CNameView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CNameView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\viewex.cpp ===
// viewex.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "adsqdoc.h"
#include "viewex.h"
#include "schemavw.h"
#include "adsqview.h"
#include "bwsview.h"

#include "splitter.h"
#include "schclss.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IDispatch*  pACEClipboard;
IDispatch*  pACLClipboard;
IDispatch*  pSDClipboard;

/////////////////////////////////////////////////////////////////////////////
// CViewExApp

BEGIN_MESSAGE_MAP(CViewExApp, CWinApp)
	//{{AFX_MSG_MAP(CViewExApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CViewExApp construction
// Place all significant initialization in InitInstance

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CViewExApp::CViewExApp()
{
   //afxMemDF |= delayFreeMemDF | checkAlwaysMemDF;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CViewExApp::~CViewExApp()
{
//   DUMP_TRACKING_INFO();
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CViewExApp object

CViewExApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////
// CViewExApp initialization

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CViewExApp::InitInstance()
{
   // Standard initialization
	Enable3dControls();

   
   if( FAILED(OleInitialize( NULL )) )
   {
      TRACE0( "OleInitialize failed" );
      return 0;
   }


	// splitter frame with both simple text output and form input view
	AddDocTemplate(new CMultiDocTemplate(IDR_SPLIT2TYPE,
			RUNTIME_CLASS(CMainDoc),
			RUNTIME_CLASS(CSplitterFrame),
			RUNTIME_CLASS(CBrowseView)));

   AddDocTemplate( new CMultiDocTemplate(
		   IDR_QUERYVIEW,
		   RUNTIME_CLASS(CAdsqryDoc),
		   RUNTIME_CLASS(CMDIChildWnd), // custom MDI child frame
		   RUNTIME_CLASS(CAdsqryView)) );

	// create main MDI Frame window
	// Please note that for simple MDI Frame windows with no toolbar,
	//   status bar or other special behavior, the CMDIFrameWnd class
	//   can be used directly for the main frame window just as the
	//   CMDIChildWnd can be use for a document frame window.

	CMDIFrameWnd* pMainFrame = new CMDIFrameWnd;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;

	// Also in this example, there is only one menubar shared between
	//  all the views.  The automatic menu enabling support of MFC
	//  will disable the menu items that don't apply based on the
	//  currently active view.  The one MenuBar is used for all
	//  document types, including when there are no open documents.

	// Now finally show the main menu
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();
	m_pMainWnd = pMainFrame;

	#ifndef _MAC
	// command line arguments are ignored, create a new (empty) document
	OnFileNew();
	#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CViewExApp commands

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CViewExApp::OnAppAbout()
{
	CDialog(IDD_ABOUTBOX).DoModal();
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
int CViewExApp::ExitInstance()
{
   if( NULL != pACEClipboard )
   {
      pACEClipboard->Release( );
   }

   if( NULL != pACLClipboard )
   {
      pACLClipboard->Release( );
   }

   if( NULL != pSDClipboard )
   {
      pSDClipboard->Release( );
   }

   OleUninitialize( );

   return CWinApp::ExitInstance( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\testcore.h ===
#ifndef  _TESTCORE_H_
#define  _TESTCORE_H_

#define  FIRST       0x00000000L
#define  NAMESPACE   0x00000000L
#define  NAMESPACES  0x00000001L
#define  USER        0x00000002L
#define  GROUP       0x00000003L
#define  DOMAIN      0x00000004L
#define  COMPUTER    0x00000005L
#define  SERVICE     0x00000006L
#define  FILESERVICE 0x00000007L
#define  SCHEMA      0x00000008L
#define  PRINTJOB    0x00000009L
#define  PRINTER     0x0000000AL
#define  PRINTQUEUE  0x0000000BL
#define  PRINTDEVICE 0x0000000CL
#define  SESSION     0x0000000DL
#define  RESOURCE    0x0000000EL
#define  FILESHARE   0x0000000FL
#define  OTHER       0x00000010L
#define  NDSROOT     0x00000011L
#define  NDSORG      0x00000012L
#define  NDSOU       0x00000013L

#define  NDSALIAS             0x00000014L
#define  NDSDIRECTORYMAP      0x00000015L
#define  NDSDISTRIBUTIONLIST  0x00000016L
#define  NDSAFPSERVER         0x00000017L
#define  NDSCOMMUNICATIONSSERVER    0x00000018L
#define  NDSMESSAGEROUTINGGROUP     0x00000019L
#define  NDSNETWARESERVER           0x0000001AL
#define  NDSORGANIZATIONALROLE      0x0000001BL
#define  NDSPRINTQUEUE              0x0000001CL
#define  NDSPRINTSERVER             0x0000001DL
#define  NDSPROFILE                 0x0000001EL
#define  NDSVOLUME                  0x0000001FL
#define  CLASS                      0x00000020L
#define  PROPERTY                   0x00000021L
#define  SYNTAX                     0x00000022L

#define  LIMIT                      0x00000023L

#define  ADSVW_INI_FILE             _T("adsvw.ini")
#define  LBOUND                     0

#define  SEPARATOR_S   _T("# ")
#define  SEPARATOR_C   _T('#')


#define  RELEASE( p )            \
   if( NULL != p )               \
   {                             \
      p->Release( );             \
   }

#define  FREE_MEMORY( mem )       \
   if( NULL != mem )              \
   {                              \
      FreeADsMem( mem );          \
   }

#define  FREE_ARRAY( mem, count )  \
   if( NULL != mem )               \
   {                               \
      FreeADsMem( mem );           \
   }

//*******************************************************************


ADSTYPE        ADsTypeFromSyntaxString( WCHAR* pszSyntax );
ADSTYPE        ADsTypeFromString( CString& strText );
CString        StringFromADsType( ADSTYPE );
DWORD          TypeFromString( WCHAR* );
DWORD          TypeFromString( CHAR*  );

void           StringFromType( DWORD, WCHAR* );
void           StringFromType( DWORD, CHAR* );
void           StringFromType( DWORD, CString& );

BOOL           MakeQualifiedName ( CHAR*,    CHAR*, DWORD );
BOOL           MakeQualifiedName ( WCHAR*,   WCHAR*, DWORD );
BOOL           MakeQualifiedName ( CString&, CString&, DWORD );

CString        OleDsGetErrorText ( HRESULT );

HRESULT        BuildFilter( BOOL*, DWORD, VARIANT* );
BOOL           GetFilter( DWORD, VARIANT*, VARIANT*   );
BOOL           SetFilter( MEMBERS*, BOOL*, DWORD );
BOOL           SetFilter( IADsContainer*, BOOL*, DWORD );

CString        FromVariantToString( VARIANT& );
CString        FromVariantArrayToString( VARIANT& v, TCHAR* pszSeparator = NULL );
HRESULT        BuildVariantArray( VARTYPE, CString&, VARIANT&, TCHAR cSeparator = SEPARATOR_C );


COleDsObject*  CreateOleDsObject ( DWORD  dwType, IUnknown* );

void           ErrorOnPutProperty( CString& strFuncSet, 
                                   CString& strProperty, 
                                   CString& strPropValue, 
                                   HRESULT  hResult,
                                   BOOL     bUseGeneric,
                                   BOOL     bUserEx ); 

BOOL           CheckIfValidClassName( CHAR*  );
BOOL           CheckIfValidClassName( WCHAR*  );

int            GetImageListIndex ( DWORD );
UINT           GetBitmapImageId  ( DWORD );

BSTR           AllocBSTR      ( WCHAR* );
BSTR           AllocBSTR      ( CHAR*  );

TCHAR*         AllocTCHAR     ( CHAR* );
TCHAR*         AllocTCHAR     ( WCHAR* );

WCHAR*         AllocWCHAR     ( CHAR* );
WCHAR*         AllocWCHAR     ( WCHAR* );

HRESULT        Get( IADs*, CHAR*, VARIANT* );
HRESULT        Get( IADs*, WCHAR*, VARIANT* );

HRESULT        Put( IADs*, CHAR*, VARIANT );
HRESULT        Put( IADs*, WCHAR*, VARIANT );

void           StringCat( CHAR*, BSTR );
void           StringCat( WCHAR*, BSTR );

void           GetLastProfileString( TCHAR*, CString& );
void           SetLastProfileString( TCHAR*, CString& );

HRESULT        CreateBlobArrayFromFile ( CString&, VARIANT& );
HRESULT        CreateBlobArray         ( CString&, VARIANT& );
HRESULT        CreateBlobArrayEx       ( CString&, VARIANT&, TCHAR cSeparator = SEPARATOR_C );

CString        Blob2String             ( void*,  DWORD );
HRESULT        String2Blob             ( TCHAR*, void**, DWORD* );

void           Convert             ( CHAR*  , CHAR*  );
void           Convert             ( WCHAR* , CHAR*  );
void           Convert             ( CHAR*  , WCHAR* );
void           Convert             ( WCHAR* , WCHAR* );

IDispatch*     CopyACE  ( IDispatch* );
IDispatch*     CopyACL  ( IDispatch* );
IDispatch*     CopySD   ( IDispatch* );


HRESULT        LARGE_INTEGERToString( TCHAR* szString, LARGE_INTEGER* pValue );
HRESULT        StringToLARGE_INTEGER( TCHAR* szString, LARGE_INTEGER* pValue );

BOOL           ConvertFromPropertyValue( VARIANT& rVar, TCHAR* szText );

long           GetVARIANTSize ( VARIANT &rVar );
HRESULT        GetVARIANTAt   ( long lIdx, VARIANT& vArray, VARIANT &vItem );

CString        FromLargeInteger( IDispatch* pDisp );
IDispatch*     CreateLargeInteger( CString& strText );
CString        GetValueAt( CString& szText, TCHAR cSep, long lValue );
long           GetValuesCount( CString& szText, TCHAR cSep  );

#ifdef _DEBUG
   #define  ERROR_HERE( szText )                            \
   {                                                        \
      TCHAR* pszText;                                       \
                                                            \
      pszText  = szText;                                    \
      Convert( pszText, __FILE__ );                         \
      _tcscat( pszText, _T( "  Line: " ) );                 \
      _itot( __LINE__, pszText + _tcslen( pszText ), 10 );  \
   }
#else
   #define  ERROR_HERE( szText ) NULL   
#endif

HRESULT  PurgeObject( IADsContainer* pParent, IUnknown* pIUnknown, LPWSTR pszPrefix = NULL );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\atl.cxx ===
// stdafx.cpp : source file that includes just the standard includes

#include "oleds.hxx"
#include "atl.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\adscopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       adscopy.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"


HRESULT
AdsClear(
    PADSVALUE lpAdsValue
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsValue->dwType){

    case ADSTYPE_DN_STRING:
        FreeADsStr(lpAdsValue->DNString);
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        FreeADsStr(lpAdsValue->CaseExactString);
        break;

    case ADSTYPE_CASE_IGNORE_STRING:
        FreeADsStr(lpAdsValue->CaseIgnoreString);
        break;

    case ADSTYPE_PRINTABLE_STRING:
        FreeADsStr(lpAdsValue->PrintableString);
        break;

    case ADSTYPE_NUMERIC_STRING:
        FreeADsStr(lpAdsValue->NumericString);
        break;

    case ADSTYPE_BOOLEAN:
        break;

    case ADSTYPE_INTEGER:
        break;

    case ADSTYPE_OCTET_STRING:
        if (lpAdsValue->OctetString.lpValue) {
            FreeADsMem(lpAdsValue->OctetString.lpValue);
        }
        break;

    case ADSTYPE_PROV_SPECIFIC:
        if (lpAdsValue->ProviderSpecific.lpValue) {
            FreeADsMem(lpAdsValue->ProviderSpecific.lpValue);
        }
        break;

    case ADSTYPE_UTC_TIME:
        break;

    case ADSTYPE_CASEIGNORE_LIST:
    {
        PADS_CASEIGNORE_LIST pCurrent = NULL;
        PADS_CASEIGNORE_LIST pNext = NULL;

        pNext = lpAdsValue->pCaseIgnoreList;
        while (pNext) {
            pCurrent = pNext;
            pNext = pCurrent->Next;
            if (pCurrent->String) {
                FreeADsStr(pCurrent->String);
            }
            FreeADsMem(pCurrent);
        }
        break;
    }

    case ADSTYPE_FAXNUMBER:
        if (lpAdsValue->pFaxNumber) {
            if (lpAdsValue->pFaxNumber->Parameters) {
                FreeADsMem(lpAdsValue->pFaxNumber->Parameters);
            }
            if (lpAdsValue->pFaxNumber->TelephoneNumber) {
                FreeADsMem(lpAdsValue->pFaxNumber->TelephoneNumber);
            }
            FreeADsMem(lpAdsValue->pFaxNumber);
        }
        break;

    case ADSTYPE_NETADDRESS:
        if (lpAdsValue->pNetAddress) {
            if (lpAdsValue->pNetAddress->Address) {
                FreeADsMem(lpAdsValue->pNetAddress->Address);
            }
            FreeADsMem(lpAdsValue->pNetAddress);
        }
        break;

    case ADSTYPE_OCTET_LIST:
    {
        PADS_OCTET_LIST pCurrent = NULL;
        PADS_OCTET_LIST pNext = NULL;

        pNext = lpAdsValue->pOctetList;
        while (pNext) {
            pCurrent = pNext;
            pNext = pCurrent->Next;
            if (pCurrent->Data) {
                FreeADsMem(pCurrent->Data);
            }
            FreeADsMem(pCurrent);
        }
        break;
    }

    case ADSTYPE_EMAIL:
        if (lpAdsValue->Email.Address) {
            FreeADsStr(lpAdsValue->Email.Address);
        }
        break;

    case ADSTYPE_PATH:
        if (lpAdsValue->pPath) {
            if (lpAdsValue->pPath->VolumeName) {
                FreeADsStr(lpAdsValue->pPath->VolumeName);
            }
            if (lpAdsValue->pPath->Path) {
                FreeADsStr(lpAdsValue->pPath->Path);
            }
            FreeADsMem(lpAdsValue->pPath);
        }
        break;

    case ADSTYPE_REPLICAPOINTER:
        if (lpAdsValue->pReplicaPointer) {
            if (lpAdsValue->pReplicaPointer->ServerName) {
                FreeADsStr(lpAdsValue->pReplicaPointer->ServerName );
            }
            if (lpAdsValue->pReplicaPointer->ReplicaAddressHints->Address) {
                FreeADsMem(lpAdsValue->pReplicaPointer->ReplicaAddressHints->Address);
            }
            FreeADsMem(lpAdsValue->pReplicaPointer);
        }
        break;


    case ADSTYPE_TIMESTAMP:
        break;

    case ADSTYPE_POSTALADDRESS:
    {
        long i;
        if (lpAdsValue->pPostalAddress) {
            for (i=0;i<6;i++) {
                if (lpAdsValue->pPostalAddress->PostalAddress[i]) {
                    FreeADsStr(lpAdsValue->pPostalAddress->PostalAddress[i]);
                }
            }
            FreeADsMem(lpAdsValue->pPostalAddress);
        }
        break;
    }

    case ADSTYPE_BACKLINK:
        if (lpAdsValue->BackLink.ObjectName) {
            FreeADsStr(lpAdsValue->BackLink.ObjectName);
        }
        break;

    case ADSTYPE_TYPEDNAME:
        if (lpAdsValue->pTypedName) {
            if (lpAdsValue->pTypedName->ObjectName) {
                FreeADsStr(lpAdsValue->pTypedName->ObjectName);
            }
            FreeADsMem(lpAdsValue->pTypedName);
        }

        break;

    case ADSTYPE_HOLD:
        if (lpAdsValue->Hold.ObjectName) {
            FreeADsStr(lpAdsValue->Hold.ObjectName);
        }
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        if (lpAdsValue->SecurityDescriptor.lpValue) {
            FreeADsMem(lpAdsValue->SecurityDescriptor.lpValue);
        }
        break;

    case ADSTYPE_OBJECT_CLASS:
        FreeADsStr(lpAdsValue->ClassName);
        break;

    case ADSTYPE_DN_WITH_BINARY:
        if (lpAdsValue->pDNWithBinary) {

            if (lpAdsValue->pDNWithBinary->lpBinaryValue) {
                FreeADsMem(lpAdsValue->pDNWithBinary->lpBinaryValue);
            }

            if (lpAdsValue->pDNWithBinary->pszDNString) {
                FreeADsStr(lpAdsValue->pDNWithBinary->pszDNString);
            }
            FreeADsMem(lpAdsValue->pDNWithBinary);
        }
        break;

    case ADSTYPE_DN_WITH_STRING:
        if (lpAdsValue->pDNWithString) {
            if (lpAdsValue->pDNWithString->pszStringValue) {
                FreeADsMem(lpAdsValue->pDNWithString->pszStringValue);
            }

            if (lpAdsValue->pDNWithString->pszDNString) {
                FreeADsStr(lpAdsValue->pDNWithString->pszDNString);
            }
            FreeADsMem(lpAdsValue->pDNWithString);
        }
        break;

    default:
        break;
    }

    memset(lpAdsValue, 0, sizeof(ADSVALUE));
    RRETURN(S_OK);
}

HRESULT
AdsCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    lpAdsDestValue->DNString =
                        AllocADsStr(
                            lpAdsSrcValue->DNString
                        );

    if (lpAdsSrcValue->DNString
        && !lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    lpAdsDestValue->CaseExactString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseExactString
                        );

    if (lpAdsSrcValue->CaseExactString
        && !lpAdsDestValue->CaseExactString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}


HRESULT
AdsCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->CaseIgnoreString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );
    if (lpAdsSrcValue->CaseIgnoreString
        && !lpAdsDestValue->CaseIgnoreString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);

}


HRESULT
AdsCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    lpAdsDestValue->PrintableString =
                        AllocADsStr(
                            lpAdsSrcValue->PrintableString
                        );

    if (lpAdsSrcValue->PrintableString
        && !lpAdsDestValue->PrintableString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    lpAdsDestValue->NumericString =
                        AllocADsStr(
                                lpAdsSrcValue->NumericString
                        );

    if (lpAdsSrcValue->NumericString
        && !lpAdsDestValue->NumericString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}



HRESULT
AdsCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}


HRESULT
AdsCopyLargeInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_LARGE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_LARGE_INTEGER;

    lpAdsDestValue->LargeInteger =
                                lpAdsSrcValue->LargeInteger;



    RRETURN(hr);
}

HRESULT
AdsCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);

    if (dwNumBytes && !lpByteStream) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpByteStream;

error :

    RRETURN(hr);
}


HRESULT
AdsCopyProvSpecific(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PROV_SPECIFIC){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_PROV_SPECIFIC;

    dwNumBytes =  lpAdsSrcValue->ProviderSpecific.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);

    if (!lpByteStream) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->ProviderSpecific.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->ProviderSpecific.dwLength = dwNumBytes;

    lpAdsDestValue->ProviderSpecific.lpValue =  lpByteStream;

    RRETURN(hr);
error:


    RRETURN(hr);
}


//
// Was overloaded to handle IDispatch.
// Removed overloading during code cleanup.
//
HRESULT
AdsCopyNTSecurityDescriptor(
    PADSVALUE lpAdsSrcValue,
    CPropertyValue * lpPropValue,
    LPWSTR pszServerName,
    CCredentials& Credentials,
    BOOL fNTDSType
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;
    PADSVALUE lpAdsDestValue = lpPropValue->getADsValue();
    VARIANT vVarSec;

    VariantInit(&vVarSec);

    if(lpAdsSrcValue->dwType != ADSTYPE_NT_SECURITY_DESCRIPTOR){
        VariantClear(&vVarSec);
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);

    if (!lpByteStream) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpByteStream;

    //
    // Now attempt to conver to security descriptor
    //
    hr = ConvertSecDescriptorToVariant(
             pszServerName,
             Credentials,
             lpAdsSrcValue->OctetString.lpValue,
             &vVarSec,
             fNTDSType
             );

    BAIL_ON_FAILURE(hr);

    hr = lpPropValue->put_SecurityDescriptor(V_DISPATCH(&vVarSec));

    BAIL_ON_FAILURE(hr);

    VariantClear(&vVarSec);

    RRETURN(hr);

error:

    if(lpByteStream){
        FreeADsMem(lpByteStream);
    }

    VariantClear(&vVarSec);

    RRETURN(hr);
}


HRESULT
AdsCopyTime(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    lpAdsDestValue->UTCTime = lpAdsSrcValue->UTCTime;

    RRETURN(hr);

}

HRESULT
AdsCopyEmail(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_EMAIL;

    lpAdsDestValue->Email.Type = lpAdsSrcValue->Email.Type;
    lpAdsDestValue->Email.Address = AllocADsStr(lpAdsSrcValue->Email.Address);
    if (!lpAdsDestValue->Email.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);

}


HRESULT
AdsCopyNetAddress(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pNetAddress) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->dwType = ADSTYPE_NETADDRESS;

    lpAdsDestValue->pNetAddress = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!lpAdsDestValue->pNetAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pNetAddress->AddressType = lpAdsSrcValue->pNetAddress->AddressType;

    dwNumBytes =  lpAdsSrcValue->pNetAddress->AddressLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
    if (!lpByteStream) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->pNetAddress->Address,
        dwNumBytes
        );

    lpAdsDestValue->pNetAddress->AddressLength = dwNumBytes;
    lpAdsDestValue->pNetAddress->Address =  lpByteStream;

    RRETURN(hr);

error:

    if(lpAdsDestValue->pNetAddress) {
        FreeADsMem(lpAdsDestValue->pNetAddress);
    }

    RRETURN(hr);

}

HRESULT
AdsCopyOctetList(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    PADS_OCTET_LIST pCurrent = NULL;
    PADS_OCTET_LIST pResult = NULL;
    PADS_OCTET_LIST pNext = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }
    if (!lpAdsSrcValue->pOctetList) {
        RRETURN(hr = E_FAIL);
    }


    lpAdsDestValue->dwType = ADSTYPE_OCTET_LIST;

    lpAdsDestValue->pOctetList = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
    if (!lpAdsDestValue->pOctetList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = lpAdsSrcValue->pOctetList;
    pResult = lpAdsDestValue->pOctetList;
    hr = CopyOctetString(
                    pCurrent->Length,
                    pCurrent->Data,
                    &pResult->Length,
                    &pResult->Data);
    BAIL_ON_FAILURE(hr);
    while (pCurrent->Next) {
        pResult->Next = (PADS_OCTET_LIST)AllocADsMem(
                                        sizeof(ADS_OCTET_LIST));
        if (!pResult->Next) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pResult = pResult->Next;
        pCurrent = pCurrent->Next;
        hr = CopyOctetString(
                        pCurrent->Length,
                        pCurrent->Data,
                        &pResult->Length,
                        &pResult->Data);
        BAIL_ON_FAILURE(hr);
    }
    pResult->Next = NULL;
    RRETURN(hr);

error:
    
    pResult = lpAdsDestValue->pOctetList;
    while ( pResult) {
        pNext = pResult->Next;
        FreeADsMem(pResult);
        pResult = pNext;
    }
    RRETURN(hr);
}

HRESULT
AdsCopyCaseIgnoreList(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    PADS_CASEIGNORE_LIST pCurrent = NULL;
    PADS_CASEIGNORE_LIST pResult = NULL;
    PADS_CASEIGNORE_LIST pNext = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pCaseIgnoreList) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->pCaseIgnoreList = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
    if (!lpAdsDestValue->pCaseIgnoreList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASEIGNORE_LIST;
    pCurrent = lpAdsSrcValue->pCaseIgnoreList;
    pResult = lpAdsDestValue->pCaseIgnoreList;
    pResult->String = AllocADsStr(pCurrent->String);
    if (!pResult->String) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    while (pCurrent->Next) {
        pResult->Next = (PADS_CASEIGNORE_LIST)AllocADsMem(
                                        sizeof(ADS_CASEIGNORE_LIST));
        if (!pResult->Next) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pResult = pResult->Next;
        pCurrent = pCurrent->Next;
        pResult->String = AllocADsStr(pCurrent->String);
        if (!pResult->String) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    pResult->Next = NULL;
    RRETURN(hr);

error:
    
    pResult = lpAdsDestValue->pCaseIgnoreList;
    while ( pResult) {
        pNext = pResult->Next;
        if (pResult->String) {
            FreeADsStr(pResult->String);
        }
        FreeADsMem(pResult);
        pResult = pNext;
    }
    RRETURN(hr);
}

HRESULT
AdsCopyPath(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pPath) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->dwType = ADSTYPE_PATH;
    lpAdsDestValue->pPath = (PADS_PATH)AllocADsMem(sizeof(ADS_PATH));
    if (!lpAdsDestValue->pPath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Type = lpAdsSrcValue->pPath->Type;
    lpAdsDestValue->pPath->VolumeName = AllocADsStr(lpAdsSrcValue->pPath->VolumeName);
    if (!lpAdsDestValue->pPath->VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Path = AllocADsStr(lpAdsSrcValue->pPath->Path);
    if (!lpAdsDestValue->pPath->Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    RRETURN(hr);

error:

    if (lpAdsDestValue->pPath) {
        if (lpAdsDestValue->pPath->VolumeName) {
            FreeADsStr(lpAdsDestValue->pPath->VolumeName);     
        }
        FreeADsMem(lpAdsDestValue->pPath);
    }
    RRETURN(hr);

}

HRESULT
AdsCopyPostalAddress(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pPostalAddress) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
    if (!lpAdsDestValue->pPostalAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    lpAdsDestValue->dwType = ADSTYPE_POSTALADDRESS;

    for (i=0;i<6;i++) {
        lpAdsDestValue->pPostalAddress->PostalAddress[i] = AllocADsStr(lpAdsSrcValue->pPostalAddress->PostalAddress[i]);
        if (!lpAdsDestValue->pPostalAddress->PostalAddress[i]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    RRETURN(hr);

error:

    if (lpAdsDestValue->pPostalAddress) {
        
        //
        // Ideally I would need to loop only until i<5
        // Being extra cautious over here in case some other code gets
        // added after the for loop that returns an error which would
        // bring us over here
        //
        
        for (i=0;i<6;i++) {
            if (lpAdsDestValue->pPostalAddress->PostalAddress[i]) {
                FreeADsStr(lpAdsDestValue->pPostalAddress->PostalAddress[i]);
            }
        }

        FreeADsMem(lpAdsDestValue->pPostalAddress);
    }

    RRETURN(hr);

}

HRESULT
AdsCopyBackLink(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_BACKLINK;

    lpAdsDestValue->BackLink.RemoteID = lpAdsSrcValue->BackLink.RemoteID;
    lpAdsDestValue->BackLink.ObjectName = AllocADsStr(lpAdsSrcValue->BackLink.ObjectName);
    if (!lpAdsDestValue->BackLink.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);

}

HRESULT
AdsCopyTypedName(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pTypedName) {
        RRETURN(hr = E_FAIL);
    }
    lpAdsDestValue->dwType = ADSTYPE_TYPEDNAME;
    lpAdsDestValue->pTypedName = (PADS_TYPEDNAME)AllocADsMem(sizeof(ADS_TYPEDNAME));
    if (!lpAdsDestValue->pTypedName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pTypedName->Level = lpAdsSrcValue->pTypedName->Level;
    lpAdsDestValue->pTypedName->Interval = lpAdsSrcValue->pTypedName->Interval;
    lpAdsDestValue->pTypedName->ObjectName = AllocADsStr(lpAdsSrcValue->pTypedName->ObjectName);
    if (!lpAdsDestValue->pTypedName->ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    RRETURN(hr);

error:
    if (lpAdsDestValue->pTypedName) {
        FreeADsMem(lpAdsDestValue->pTypedName);
    }

    RRETURN(hr);

}

HRESULT
AdsCopyHold(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_HOLD;

    lpAdsDestValue->Hold.Amount = lpAdsSrcValue->Hold.Amount;
    lpAdsDestValue->Hold.ObjectName = AllocADsStr(lpAdsSrcValue->Hold.ObjectName);
    if (!lpAdsDestValue->Hold.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);

}

HRESULT
AdsCopyReplicaPointer(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pReplicaPointer) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->dwType = ADSTYPE_REPLICAPOINTER;
    lpAdsDestValue->pReplicaPointer = (PADS_REPLICAPOINTER)AllocADsMem(sizeof(ADS_REPLICAPOINTER));
    if (!lpAdsDestValue->pReplicaPointer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ReplicaType = lpAdsSrcValue->pReplicaPointer->ReplicaType;
    lpAdsDestValue->pReplicaPointer->ReplicaNumber = lpAdsSrcValue->pReplicaPointer->ReplicaNumber;
    lpAdsDestValue->pReplicaPointer->Count = lpAdsSrcValue->pReplicaPointer->Count;
    lpAdsDestValue->pReplicaPointer->ServerName = AllocADsStr(lpAdsSrcValue->pReplicaPointer->ServerName);
    if (!lpAdsDestValue->pReplicaPointer->ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Doing NetAddress
    //

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!lpAdsDestValue->pReplicaPointer->ReplicaAddressHints) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressType = lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressType;

    hr = CopyOctetString(
                lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressLength,
                lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->Address,
                &lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressLength,
                &lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->Address);
    BAIL_ON_FAILURE(hr);
    
    RRETURN(hr);
    
error:
    if (lpAdsDestValue->pReplicaPointer) {
        if (lpAdsDestValue->pReplicaPointer->ServerName) {
            FreeADsStr(lpAdsDestValue->pReplicaPointer->ServerName);     
        }
        if (lpAdsDestValue->pReplicaPointer->ReplicaAddressHints) {
            FreeADsMem(lpAdsDestValue->pReplicaPointer->ReplicaAddressHints);
        }
        FreeADsMem(lpAdsDestValue->pReplicaPointer);
    }

    RRETURN(hr);

}

HRESULT
AdsCopyFaxNumber(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pFaxNumber) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
    if (!lpAdsDestValue->pFaxNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    lpAdsDestValue->dwType = ADSTYPE_FAXNUMBER;

    dwNumBytes =  lpAdsSrcValue->pFaxNumber->NumberOfBits;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
    if (!lpByteStream) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->pFaxNumber->Parameters,
        dwNumBytes
        );

    lpAdsDestValue->pFaxNumber->NumberOfBits = dwNumBytes;
    lpAdsDestValue->pFaxNumber->Parameters =  lpByteStream;

    lpAdsDestValue->pFaxNumber->TelephoneNumber = AllocADsStr(lpAdsSrcValue->pFaxNumber->TelephoneNumber);
    if (!lpAdsDestValue->pFaxNumber->TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    RRETURN(hr);

error:

    if (lpAdsDestValue->pFaxNumber) {
        FreeADsMem(lpAdsDestValue->pFaxNumber);
    }
    if (lpByteStream) {
        FreeADsMem(lpByteStream);
    }
    RRETURN(hr);

}

HRESULT
AdsCopyNDSTimestamp(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_TIMESTAMP;

    lpAdsDestValue->Timestamp.WholeSeconds = lpAdsSrcValue->Timestamp.WholeSeconds;
    lpAdsDestValue->Timestamp.EventID = lpAdsSrcValue->Timestamp.EventID;
    RRETURN(hr);

}

HRESULT
AdsCopyDNWithBinary(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    PADS_DN_WITH_BINARY pDestDNBin = NULL;
    PADS_DN_WITH_BINARY pSrcDNBin  = NULL;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_BINARY) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pDNWithBinary) {
        //
        // No source object so return
        //
        RRETURN(hr);
    }

    pSrcDNBin = lpAdsSrcValue->pDNWithBinary;

    pDestDNBin = (PADS_DN_WITH_BINARY)
                    AllocADsMem(sizeof(ADS_DN_WITH_BINARY));

    if (!pDestDNBin) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (pSrcDNBin->dwLength) {

        //
        // Copy the octet string over.
        //
        pDestDNBin->lpBinaryValue = (LPBYTE) AllocADsMem(pSrcDNBin->dwLength);
        if (!pDestDNBin->lpBinaryValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pDestDNBin->dwLength = pSrcDNBin->dwLength;

        memcpy(
            pDestDNBin->lpBinaryValue,
            pSrcDNBin->lpBinaryValue,
            pSrcDNBin->dwLength
            );
    }

    if (pSrcDNBin->pszDNString) {
        //
        // Copy the DNString value over
        //
        pDestDNBin->pszDNString = AllocADsStr(pSrcDNBin->pszDNString);
        if (!pDestDNBin->pszDNString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    lpAdsDestValue->pDNWithBinary = pDestDNBin;
    lpAdsDestValue->dwType = ADSTYPE_DN_WITH_BINARY;

    RRETURN(hr);

error:

    if (pDestDNBin) {
        //
        // Clean up the mem for string and byte array
        //
        if (pDestDNBin->pszDNString) {
            FreeADsStr(pDestDNBin->pszDNString);
        }

        if (pDestDNBin->lpBinaryValue) {
            FreeADsMem(pDestDNBin->lpBinaryValue);
        }
        FreeADsMem(pDestDNBin);
    }

    RRETURN(hr);

}


HRESULT
AdsCopyDNWithString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    PADS_DN_WITH_STRING pDestDNStr = NULL;
    PADS_DN_WITH_STRING pSrcDNStr  = NULL;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_STRING) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pDNWithString) {
        //
        // No source object so return
        //
        RRETURN(hr);
    }

    pSrcDNStr = lpAdsSrcValue->pDNWithString;

    pDestDNStr = (PADS_DN_WITH_STRING)
                    AllocADsMem(sizeof(ADS_DN_WITH_STRING));

    if (!pDestDNStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (pSrcDNStr->pszStringValue) {

        //
        // Copy the string over.
        //
        pDestDNStr->pszStringValue = AllocADsStr(pSrcDNStr->pszStringValue);
        if (!pDestDNStr->pszStringValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

    }

    if (pSrcDNStr->pszDNString) {
        //
        // Copy the DNString value over
        //
        pDestDNStr->pszDNString = AllocADsStr(pSrcDNStr->pszDNString);
        if (!pDestDNStr->pszDNString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    lpAdsDestValue->pDNWithString = pDestDNStr;
    lpAdsDestValue->dwType = ADSTYPE_DN_WITH_STRING;

    RRETURN(hr);

error:

    if (pDestDNStr) {
        //
        // Clean up the mem for string and byte array
        //
        if (pDestDNStr->pszDNString) {
            FreeADsStr(pDestDNStr->pszDNString);
        }

        if (pDestDNStr->pszStringValue) {
            FreeADsMem(pDestDNStr->pszStringValue);
        }
        FreeADsMem(pDestDNStr);
    }

    RRETURN(hr);
}

HRESULT
AdsCopy(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = E_FAIL;

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        hr = AdsCopyDNString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        hr = AdsCopyCaseExactString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        hr = AdsCopyPrintableString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        hr = AdsCopyNumericString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;


    case ADSTYPE_BOOLEAN:
        hr = AdsCopyBoolean(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsCopyInteger(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_LARGE_INTEGER:
        hr = AdsCopyLargeInteger(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_OCTET_STRING:
        hr = AdsCopyOctetString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_PROV_SPECIFIC:
        hr = AdsCopyProvSpecific(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );
        break;

    case ADSTYPE_UTC_TIME:
        hr = AdsCopyTime(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_CASEIGNORE_LIST:
        hr = AdsCopyCaseIgnoreList(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_FAXNUMBER:
        hr = AdsCopyFaxNumber(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_NETADDRESS:
        hr = AdsCopyNetAddress(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_OCTET_LIST:
        hr = AdsCopyOctetList(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_EMAIL:
        hr = AdsCopyEmail(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_PATH:
        hr = AdsCopyPath(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_REPLICAPOINTER:
        hr = AdsCopyReplicaPointer(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_TIMESTAMP:
        hr = AdsCopyNDSTimestamp(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_POSTALADDRESS:
        hr = AdsCopyPostalAddress(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_BACKLINK:
        hr = AdsCopyBackLink(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_TYPEDNAME:
        hr = AdsCopyTypedName(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_HOLD:
        hr = AdsCopyHold(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;


    case ADSTYPE_DN_WITH_BINARY:
        hr = AdsCopyDNWithBinary(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );
        break;

    case ADSTYPE_DN_WITH_STRING:
        hr = AdsCopyDNWithString(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        //
        // This should be handled elsewhere not here !
        //
        ADsAssert(!"Invalid option to adscopy");
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);

}
//
// This routine is typically used by GetPropertyItem calls.
//
HRESULT
AdsCopyADsValueToPropObj(
    PADSVALUE lpAdsSrcValue,
    CPropertyValue* lpPropObj,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    )
{
    HRESULT hr = S_OK;
    PADSVALUE lpAdsDestValue = lpPropObj->getADsValue();
    CCredentials localCredentials(NULL, NULL, 0);

    switch (lpAdsSrcValue->dwType){


    case ADSTYPE_NT_SECURITY_DESCRIPTOR:

        if (pCredentials) {
            localCredentials = *pCredentials;
        }
        hr = AdsCopyNTSecurityDescriptor(
                    lpAdsSrcValue,
                    lpPropObj,
                    pszServerName,
                    localCredentials,
                    fNTDSType
                    );
        break;


    default:
        hr = AdsCopy(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );

        break;
    }

    RRETURN(hr);
}

//
// This routine is typically used from PutPropertyItem.
//
HRESULT
AdsCopyPropObjToADsValue(
    CPropertyValue *lpPropObj,
    PADSVALUE lpAdsDestValue,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    )
{
    HRESULT hr = E_FAIL;
    PADSVALUE lpAdsSrcValue = lpPropObj->getADsValue();
    DWORD dwDataType = 0;
    DWORD dwSDLength = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    CCredentials locCredentials(NULL, NULL, 0);
    IDispatch *pIDispatch = NULL;
    IADsSecurityDescriptor *pIADsSecDesc = NULL;

    switch (lpAdsSrcValue->dwType) {

    case ADSTYPE_NT_SECURITY_DESCRIPTOR :

        dwDataType = lpPropObj->getExtendedDataTypeInfo();
        //
        // if we have the octet blob send it back
        //
        if (dwDataType == CPropertyValue::VAL_IDISPATCH_SECDESC_ALL) {

            hr = AdsCopyOctetString(
                     lpAdsSrcValue,
                     lpAdsDestValue
                     );
            BAIL_ON_FAILURE(hr);
        }
        else if (dwDataType == CPropertyValue::VAL_IDISPATCH_SECDESC_ONLY) {

            if (pCredentials) {
                locCredentials = *pCredentials;
            }

            pIDispatch = lpPropObj->getDispatchPointer();

            if (pIDispatch) {

                hr = pIDispatch->QueryInterface(
                                     IID_IADsSecurityDescriptor,
                                     (void **) &pIADsSecDesc
                                     );

                BAIL_ON_FAILURE(hr);
            }

            hr = ConvertSecurityDescriptorToSecDes(
                     pszServerName,
                     locCredentials,
                     pIADsSecDesc,
                     &pSecurityDescriptor,
                     &dwSDLength,
                     fNTDSType
                     );
            BAIL_ON_FAILURE(hr);

            lpAdsDestValue->OctetString.lpValue
                                = (LPBYTE) AllocADsMem(dwSDLength);

            if (!(lpAdsDestValue->OctetString.lpValue)) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                lpAdsDestValue->OctetString.lpValue,
                pSecurityDescriptor,
                dwSDLength
                );

            lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;
            lpAdsDestValue->OctetString.dwLength = dwSDLength;

        } // secdesc idispatch only
        break;

    default:

        hr = AdsCopy(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );
        break;
    } // end case

error :

    //
    // Needs to be executed in all cases, currently only ret is below
    //
    if (pIADsSecDesc) {
        pIADsSecDesc->Release();
    }

    if (pSecurityDescriptor) {
        FreeADsMem(pSecurityDescriptor);
    }

    RRETURN(hr);

}


HRESULT
PropVariantToAdsType(
    PVARIANT pVariant,
    DWORD dwNumVariant,
    PADSVALUE *ppAdsValues,
    PDWORD pdwNumValues
    )
{
    return(PropVariantToAdsType2(
               pVariant,
               dwNumVariant,
               ppAdsValues,
               pdwNumValues,
               NULL,        // serverName,
               NULL,        // pCredentials
               TRUE         // NTDS Type
               ));

}


HRESULT
PropVariantToAdsType2(
    PVARIANT pVariant,
    DWORD dwNumVariant,
    PADSVALUE *ppAdsValues,
    PDWORD pdwNumValues,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    )
{
    DWORD i = 0;
    VARIANT * pVar = NULL;
    DWORD dwCount = 0;
    IDispatch FAR * pDispatch = NULL;
    IADsValue FAR * pPropValue = NULL;
    PADSVALUE pADsValues = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassWord = NULL;
    DWORD dwFlags = 0;

    pADsValues = (PADSVALUE)AllocADsMem(dwNumVariant * sizeof(ADSVALUE));
    if (!pADsValues) {
        RRETURN(E_OUTOFMEMORY);
    }

    //
    // If !pCredentials, use the initialized values as they
    // represent an object with CCredentials(NULL, NULL, 0)
    //
    if (pCredentials) {

        hr = pCredentials->GetUserName(&pszUserName);

        BAIL_ON_FAILURE(hr);

        hr = pCredentials->GetPassword(&pszPassWord);

        BAIL_ON_FAILURE(hr);

        dwFlags = pCredentials->GetAuthFlags();

    }

    for (i = 0; i < dwNumVariant; i++ ) {

        pVar = pVariant + i;

        pDispatch = V_DISPATCH(pVar);

        hr = pDispatch->QueryInterface(
                    IID_IADsValue,
                    (void **)&pPropValue
                    );
        CONTINUE_ON_FAILURE(hr);


        hr = pPropValue->ConvertPropertyValueToADsValue2(
                                    (pADsValues + dwCount),
                                    pszServerName,
                                    pszUserName,
                                    pszPassWord,
                                    dwFlags,
                                    fNTDSType
                                    );
        pPropValue->Release();
        BAIL_ON_FAILURE(hr);

        dwCount++;

    }

    *ppAdsValues = pADsValues;
    *pdwNumValues = dwCount;

error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassWord) {
        FreeADsStr(pszPassWord);
    }

    if (FAILED(hr) && pADsValues) {
        FreeADsMem(pADsValues);
    }

    RRETURN(hr);

}



HRESULT
AdsTypeToPropVariant2(
    PADSVALUE pAdsValues,
    DWORD dwNumValues,
    PVARIANT pVarDestObjects,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    )
{

    long i = 0;
    HRESULT hr = S_OK;
    CPropertyValue * pAdsValue = NULL;

    VariantInit( pVarDestObjects );

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumValues;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long)dwNumValues; i++ )
    {
        VARIANT v;
        IDispatch FAR * pDispatch = NULL;

        VariantInit(&v);

        hr = CPropertyValue::AllocatePropertyValueObject(&pAdsValue);

        BAIL_ON_FAILURE(hr);

        hr = pAdsValue->ConvertADsValueToPropertyValue2(
                    pAdsValues + i,
                    pszServerName,
                    pCredentials,
                    fNTDSType
                    );
        BAIL_ON_FAILURE(hr);

        pAdsValue->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
        BAIL_ON_FAILURE(hr);


        V_DISPATCH(&v) = pDispatch;
        V_VT(&v) = VT_DISPATCH;

        if (pAdsValue) {
           pAdsValue->Release();
        }

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        pDispatch = NULL;


        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}


HRESULT
AdsTypeToPropVariant(
    PADSVALUE pAdsValues,
    DWORD dwNumValues,
    PVARIANT pVarDestObjects
    )
{
    RRETURN( AdsTypeToPropVariant2(
                 pAdsValues,
                 dwNumValues,
                 pVarDestObjects,
                 NULL,  // serverName
                 NULL,  // pCredentials
                 TRUE   // serverType
                 )
             );
}


void
AdsFreeAdsValues(
    PADSVALUE pAdsValues,
    DWORD dwNumValues
    )
{
   LPBYTE pMem = NULL;

   for ( DWORD i = 0; i < dwNumValues; i++ )
   {
      AdsClear(&pAdsValues[i]);
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\testcore.cpp ===
#define _LARGE_INTEGER_SUPPORT_
#include "stdafx.h"
#include "winnls.h"
#include "resource.h"
#include "errordlg.h"

typedef DWORD ( *LARGEINTTOSTRING )( LARGE_INTEGER*, ULONG, LONG, PSZ );

LARGEINTTOSTRING LargeIntegerToString;

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
ADSTYPE  ADsTypeFromString( CString& strText )
{
   if( !strText.CompareNoCase( _T("ADSTYPE_DN_STRING") ) )
      return ADSTYPE_DN_STRING;

	if( !strText.CompareNoCase( _T("ADSTYPE_CASE_EXACT_STRING") ) )
      return ADSTYPE_CASE_EXACT_STRING;

   if( !strText.CompareNoCase( _T("ADSTYPE_CASE_IGNORE_STRING") ) )
      return ADSTYPE_CASE_IGNORE_STRING;


	if( !strText.CompareNoCase( _T("ADSTYPE_PRINTABLE_STRING") ) )
      return ADSTYPE_PRINTABLE_STRING;


	if( !strText.CompareNoCase( _T("ADSTYPE_NUMERIC_STRING") ) )
      return ADSTYPE_NUMERIC_STRING;


	if( !strText.CompareNoCase( _T("ADSTYPE_BOOLEAN") ) )
      return ADSTYPE_BOOLEAN;


	if( !strText.CompareNoCase( _T("ADSTYPE_INTEGER") ) )
      return ADSTYPE_INTEGER;


	if( !strText.CompareNoCase( _T("ADSTYPE_OCTET_STRING") ) )
      return ADSTYPE_OCTET_STRING;


	if( !strText.CompareNoCase( _T("ADSTYPE_UTC_TIME") ) )
      return ADSTYPE_UTC_TIME;


	if( !strText.CompareNoCase( _T("ADSTYPE_LARGE_INTEGER") ) )
      return ADSTYPE_LARGE_INTEGER;


	if( !strText.CompareNoCase( _T("ADSTYPE_PROV_SPECIFIC") ) )
      return ADSTYPE_PROV_SPECIFIC;

   if( !strText.CompareNoCase( _T("ADSTYPE_CASEIGNORE_LIST") ) )
      return ADSTYPE_CASEIGNORE_LIST;

   if( !strText.CompareNoCase( _T("ADSTYPE_POSTALADDRESS") ) )
      return ADSTYPE_POSTALADDRESS;

	if( !strText.CompareNoCase( _T("ADSTYPE_OCTET_LIST") ) )
      return ADSTYPE_OCTET_LIST;

	if( !strText.CompareNoCase( _T("ADSTYPE_PATH") ) )
      return ADSTYPE_PATH;

	if( !strText.CompareNoCase( _T("ADSTYPE_POSTALADDRESS") ) )
      return ADSTYPE_POSTALADDRESS;

	if( !strText.CompareNoCase( _T("ADSTYPE_TIMESTAMP") ) )
      return ADSTYPE_TIMESTAMP;

	if( !strText.CompareNoCase( _T("ADSTYPE_BACKLINK") ) )
      return ADSTYPE_BACKLINK;

	if( !strText.CompareNoCase( _T("ADSTYPE_TYPEDNAME") ) )
      return ADSTYPE_TYPEDNAME;

	if( !strText.CompareNoCase( _T("ADSTYPE_HOLD") ) )
      return ADSTYPE_HOLD;

	if( !strText.CompareNoCase( _T("ADSTYPE_NETADDRESS") ) )
      return ADSTYPE_NETADDRESS;

	if( !strText.CompareNoCase( _T("ADSTYPE_REPLICAPOINTER") ) )
      return ADSTYPE_REPLICAPOINTER;

	if( !strText.CompareNoCase( _T("ADSTYPE_FAXNUMBER") ) )
      return ADSTYPE_FAXNUMBER;

	if( !strText.CompareNoCase( _T("ADSTYPE_EMAIL") ) )
      return ADSTYPE_EMAIL;

   return ADSTYPE_INVALID;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
ADSTYPE  ADsTypeFromSyntaxString( WCHAR* pszSyntax )
{
   ADSTYPE  eType = ADSTYPE_CASE_IGNORE_STRING;

   if( !_wcsicmp( pszSyntax, L"String" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"DN" ) )
   {
      eType = ADSTYPE_DN_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"ObjectSecurityDescriptor" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"OID" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Object Class" ) )
   {
      eType = ADSTYPE_OBJECT_CLASS;
   }
   else if( !_wcsicmp( pszSyntax, L"DirectoryString" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"ORName" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"IA5String" ) )
   {
      eType = ADSTYPE_NUMERIC_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"NumericString" ) )
   {
      eType = ADSTYPE_NUMERIC_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"CaseIgnoreString" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"PrintableString" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Counter" ) )
   {
      eType = ADSTYPE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"OleDsPath" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Email" ) )
   {
      eType = ADSTYPE_EMAIL;
   }
   else if( !_wcsicmp( pszSyntax, L"Hold" ) )
   {
      eType = ADSTYPE_HOLD;
   }
   else if( !_wcsicmp( pszSyntax, L"Octet" ) )
   {
      eType = ADSTYPE_OCTET_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Back Link" ) )
   {
      eType = ADSTYPE_BACKLINK;
   }
   else if( !_wcsicmp( pszSyntax, L"Typed Name" ) )
   {
      eType = ADSTYPE_TYPEDNAME;
   }
   else if( !_wcsicmp( pszSyntax, L"EmailAddress" ) )
   {
      eType = ADSTYPE_EMAIL;
   }
   else if( !_wcsicmp( pszSyntax, L"Path" ) )
   {
      eType = ADSTYPE_PATH;
   }
   else if( !_wcsicmp( pszSyntax, L"Case Ignore List" ) )
   {
      eType = ADSTYPE_CASEIGNORE_LIST;
   }
   else if( !_wcsicmp( pszSyntax, L"Octet List" ) )
   {
      eType = ADSTYPE_OCTET_LIST;
   }
   else if( !_wcsicmp( pszSyntax, L"FaxNumber" ) )
   {
      eType = ADSTYPE_FAXNUMBER;
   }
   else if( !_wcsicmp( pszSyntax, L"Integer" ) )
   {
      eType = ADSTYPE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"Integer8" ) )
   {
      eType = ADSTYPE_LARGE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"Postal Address" ) )
   {
      eType = ADSTYPE_POSTALADDRESS;
   }
   else if( !_wcsicmp( pszSyntax, L"Interval" ) )
   {
      eType = ADSTYPE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"List" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"NetAddress" ) )
   {
      eType = ADSTYPE_NETADDRESS;
   }
   else if( !_wcsicmp( pszSyntax, L"OctetString" ) )
   {
      eType = ADSTYPE_OCTET_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Path" ) )
   {
      eType = ADSTYPE_PATH;
   }
   else if( !_wcsicmp( pszSyntax, L"PhoneNumber" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"PostalAddress" ) )
   {
      eType = ADSTYPE_POSTALADDRESS;
   }
   else if( !_wcsicmp( pszSyntax, L"SmallInterval" ) )
   {
      eType = ADSTYPE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"Time" ) )
   {
      eType = ADSTYPE_UTC_TIME;
   }
   else if( !_wcsicmp( pszSyntax, L"TimeStamp" ) )
   {
      eType = ADSTYPE_TIMESTAMP;
   }
  else if( !_wcsicmp( pszSyntax, L"UTCTime" ) )
   {
      eType = ADSTYPE_UTC_TIME;
   }
  else if( !_wcsicmp( pszSyntax, L"GeneralizedTime" ) )
   {
      eType = ADSTYPE_UTC_TIME;
   }
   else if( !_wcsicmp( pszSyntax, L"boolean" ) )
   {
      eType = ADSTYPE_BOOLEAN;
   }
   else
   {
      TCHAR szText[ 128 ];

      Convert( szText, pszSyntax );
      TRACE( _T("ERROR: unknown %s syntax\n"), szText );
      //ASSERT( FALSE );
   }

   return eType;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  StringFromADsType( ADSTYPE eType )
{

   switch( eType )
   {
      case  ADSTYPE_DN_STRING:
         return CString( _T("ADSTYPE_DN_STRING") );

      case  ADSTYPE_CASE_EXACT_STRING:
	      return CString( _T("ADSTYPE_CASE_EXACT_STRING") );

      case  ADSTYPE_CASE_IGNORE_STRING:
         return CString( _T("ADSTYPE_CASE_IGNORE_STRING") );

      case  ADSTYPE_PRINTABLE_STRING:
	      return CString( _T("ADSTYPE_PRINTABLE_STRING") );

      case  ADSTYPE_NUMERIC_STRING:
	      return CString( _T("ADSTYPE_NUMERIC_STRING") );

      case  ADSTYPE_BOOLEAN:
	      return CString( _T("ADSTYPE_BOOLEAN") );

      case  ADSTYPE_INTEGER:
	      return CString( _T("ADSTYPE_INTEGER") );

      case  ADSTYPE_OCTET_STRING:
	      return CString( _T("ADSTYPE_OCTET_STRING") );

      case  ADSTYPE_UTC_TIME:
	      return CString( _T("ADSTYPE_UTC_TIME") );


      case  ADSTYPE_LARGE_INTEGER:
	      return CString( _T("ADSTYPE_LARGE_INTEGER") );


      case  ADSTYPE_PROV_SPECIFIC:
	      return CString( _T("ADSTYPE_PROV_SPECIFIC") );

      default:
         return CString( _T("ADSTYPE_UNKNOWN") );

   }
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD TypeFromString( LPWSTR lpszBuffer )
{
   if( !lpszBuffer )
      return OTHER;

   if( !_wcsicmp( lpszBuffer, L"Namespace" ) )
      return NAMESPACE;

   if( !_wcsicmp(  lpszBuffer, L"Namespaces" ) )
      return NAMESPACES;

   if( !_wcsicmp( lpszBuffer, L"User" ) )
      return USER;

   if( !_wcsicmp( lpszBuffer, L"Group" ) )
      return GROUP;

   if( !_wcsicmp( lpszBuffer, L"LocalGroup" ) )
      return GROUP;

   if( !_wcsicmp( lpszBuffer, L"GlobalGroup" ) )
      return GROUP;

   if( !_wcsicmp( lpszBuffer, L"groupofuniquenames" ) )
      return GROUP;

   if( !_wcsicmp( lpszBuffer, L"Domain" ) )
      return DOMAIN;

   if( !_wcsicmp( lpszBuffer, L"Computer" ) )
      return  COMPUTER;

   if( !_wcsicmp( lpszBuffer, L"Service" ) )
      return  SERVICE;

   if( !_wcsicmp( lpszBuffer, L"FileService" ) )
      return  FILESERVICE;

   if( !_wcsicmp( lpszBuffer, L"Printqueue" ) )
      return  PRINTQUEUE;

   if( !_wcsicmp( lpszBuffer, L"Printer" ) )
      return  PRINTER;

   if( !_wcsicmp( lpszBuffer, L"Printjob" ) )
      return  PRINTJOB;

   if( !_wcsicmp( lpszBuffer, L"PrintDevice" ) )
      return  PRINTDEVICE;

   if( !_wcsicmp( lpszBuffer, L"Session" ) )
      return   SESSION;

   if( !_wcsicmp( lpszBuffer, L"Resource" ) )
      return   RESOURCE;

   if( !_wcsicmp( lpszBuffer, L"FileShare" ) )
      return   FILESHARE;

   if( !_wcsicmp( lpszBuffer, L"Organization" ) )
      return NDSORG;

   if( !_wcsicmp( lpszBuffer, L"Root" ) )
      return NDSROOT;

   if( !_wcsicmp( lpszBuffer, L"Tree" ) )
      return NDSROOT;

   if( !_wcsicmp( lpszBuffer, L"Top" ) )
      return NDSROOT;

   if( !_wcsicmp( lpszBuffer, L"Organizational Unit" ) )
      return NDSOU;

   if( !_wcsicmp( lpszBuffer, L"OrganizationalUnit" ) )
      return NDSOU;

   if( !_wcsicmp( lpszBuffer, L"DomainOrganizationalUnit" ) )
      return NDSOU;

   if( !_wcsicmp( lpszBuffer, L"Alias" ) )
      return   NDSALIAS;

   if( !_wcsicmp( lpszBuffer, L"Directory Map" ) )
      return   NDSDIRECTORYMAP;

   if( !_wcsicmp( lpszBuffer, L"Distribution List" ) )
      return   NDSDISTRIBUTIONLIST;

   if( !_wcsicmp( lpszBuffer, L"AFP Server" ) )
      return   NDSAFPSERVER;

   if( !_wcsicmp( lpszBuffer, L"Communications Server" ) )
      return   NDSCOMMUNICATIONSSERVER;

   if( !_wcsicmp( lpszBuffer, L"Message Routing Group" ) )
      return   NDSMESSAGEROUTINGGROUP;

   if( !_wcsicmp( lpszBuffer, L"NCP Server" ) )
      return   NDSNETWARESERVER;

   if( !_wcsicmp( lpszBuffer, L"Organizational Role" ) )
      return   NDSORGANIZATIONALROLE;

   if( !_wcsicmp( lpszBuffer, L"Queue" ) )
      return   NDSPRINTQUEUE;

   if( !_wcsicmp( lpszBuffer, L"Print Server" ) )
      return   NDSPRINTSERVER;

   if( !_wcsicmp( lpszBuffer, L"Profile" ) )
      return   NDSPROFILE;

   if( !_wcsicmp( lpszBuffer, L"Volume" ) )
      return   NDSVOLUME;

   if( !_wcsicmp( lpszBuffer, L"Class" ) )
      return   CLASS;

   if( !_wcsicmp( lpszBuffer, L"Schema" ) )
      return   SCHEMA;

   if( !_wcsicmp( lpszBuffer, L"Syntax" ) )
      return   SYNTAX;

   if( !_wcsicmp( lpszBuffer, L"Property" ) )
      return   PROPERTY;

   return OTHER;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD TypeFromString( LPSTR lpszBuffer )
{
   int      nLength;
   WCHAR*   pszwType;
   DWORD    dwType;

   nLength  = strlen( lpszBuffer );

   pszwType = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   memset( pszwType, 0, ( nLength + 1 ) * sizeof(WCHAR) );

   MultiByteToWideChar( CP_ACP,
                        MB_PRECOMPOSED,
                        lpszBuffer,
                        nLength,
                        pszwType,
                        nLength + 1 );

   dwType   = TypeFromString( pszwType );
   free( pszwType );

   return dwType;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  StringFromType( DWORD dwType, CString& rString )
{
   TCHAR szText[ 128 ];

   StringFromType( dwType, szText );

   rString  = szText;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  StringFromType( DWORD dwType, TCHAR* lpszBuffer )
{
   switch( dwType )
   {
      case  NAMESPACE:
         _tcscpy( lpszBuffer, _T("Namespace") );
         break;

      case  NAMESPACES:
         _tcscpy( lpszBuffer, _T("Namespaces") );
         break;

      case  USER:
         _tcscpy( lpszBuffer, _T("User") );
         break;

      case  GROUP:
         _tcscpy( lpszBuffer, _T("Group") );
         break;

      case  DOMAIN:
         _tcscpy( lpszBuffer, _T("Domain") );
         break;

      case  COMPUTER:
         _tcscpy( lpszBuffer, _T("Computer") );
         break;

      case  SERVICE:
         _tcscpy( lpszBuffer, _T("Service") );
         break;

      case  FILESERVICE:
         _tcscpy( lpszBuffer, _T("FileService") );
         break;

      case  PRINTQUEUE:
         _tcscpy( lpszBuffer, _T("Printqueue") );
         break;

      case  PRINTER:
         _tcscpy( lpszBuffer, _T("Printer") );
         break;

      case  PRINTJOB:
         _tcscpy( lpszBuffer, _T("PrintJob") );
         break;

      case  PRINTDEVICE:
         _tcscpy( lpszBuffer, _T("PrintDevice") );
         break;

      case  SESSION:
         _tcscpy( lpszBuffer, _T("Session") );
         break;

      case  FILESHARE:
         _tcscpy( lpszBuffer, _T("FileShare") );
         break;

      case  RESOURCE:
         _tcscpy( lpszBuffer, _T("Resource") );
         break;

      case  NDSORG:
         _tcscpy( lpszBuffer, _T("Organization") );
         break;

      case  NDSROOT:
         _tcscpy( lpszBuffer, _T("Tree") );
         break;

      case  NDSOU:
         _tcscpy( lpszBuffer, _T("Organizational Unit") );
         break;

      case  NDSALIAS:
         _tcscpy( lpszBuffer, _T("Alias") );
         break;

      case  NDSDIRECTORYMAP:
         _tcscpy( lpszBuffer, _T("Directory Map") );
         break;

      case  NDSDISTRIBUTIONLIST:
         _tcscpy( lpszBuffer, _T("Distribution List") );
         break;

      case  NDSAFPSERVER:
         _tcscpy( lpszBuffer, _T("AFP Server") );
         break;

      case  NDSCOMMUNICATIONSSERVER:
         _tcscpy( lpszBuffer, _T("Communications Server") );
         break;

      case  NDSMESSAGEROUTINGGROUP:
         _tcscpy( lpszBuffer, _T("Message Routing Group") );
         break;

      case  NDSNETWARESERVER:
         _tcscpy( lpszBuffer, _T("NCP Server") );
         break;

      case  NDSORGANIZATIONALROLE:
         _tcscpy( lpszBuffer, _T("Organizational Role") );
         break;

      case  NDSPRINTQUEUE:
         _tcscpy( lpszBuffer, _T("Queue") );
         break;

      case  NDSPRINTSERVER:
         _tcscpy( lpszBuffer, _T("Print Server") );
         break;

      case  NDSPROFILE:
         _tcscpy( lpszBuffer, _T("Profile") );
         break;

      case  NDSVOLUME:
         _tcscpy( lpszBuffer, _T("Volume") );
         break;

      case  SCHEMA:
         _tcscpy( lpszBuffer, _T("Schema") );
         break;

      case  OTHER:
         _tcscpy( lpszBuffer, _T("Other") );
         break;

      case  CLASS:
         _tcscpy( lpszBuffer, _T("Class") );
         break;

      case  PROPERTY:
         _tcscpy( lpszBuffer, _T("Property") );
         break;

      case  SYNTAX:
         _tcscpy( lpszBuffer, _T("Syntax") );
         break;

      default:
         ASSERT( FALSE );
         _tcscpy( lpszBuffer, _T("") );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  MakeQualifiedName( TCHAR* strDest, TCHAR* strName, DWORD dwType )
{
   TCHAR szTemp[ 128 ];

   _tcscpy( strDest, strName );

   if( OTHER == dwType )
      return TRUE;

   StringFromType( dwType, szTemp );

   if( _tcslen( szTemp ) )
   {
      _tcscat( strDest, _T(",") );
   }
   _tcscat( strDest, szTemp );

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  MakeQualifiedName ( CString& strDest, CString& strName, DWORD dwType )
{
   TCHAR szTemp[ 128 ];

   strDest  = strName;

   if( OTHER != dwType )
   {
      StringFromType( dwType, szTemp );
      strDest  = strDest + _T(',');
      strDest  = strDest + CString( szTemp );
   }

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     TryThisFilter( BSTR bstrObjectType, MEMBERS* pIGroup )
{
   VARIANT        v, varFilter, varOld;
   SAFEARRAY      *psaTry     = NULL;
   SAFEARRAYBOUND sabTryArray;
   HRESULT        hr;
   long           i;

   sabTryArray.cElements   = 1;
   sabTryArray.lLbound     = LBOUND;
   psaTry = SafeArrayCreate( VT_VARIANT, 1, &sabTryArray );

   if (!psaTry)
   {
      return FALSE;
   }

   VariantInit(&v);
   V_VT(&v)    = VT_BSTR;
   V_BSTR(&v)  = SysAllocString( bstrObjectType );
   i           = LBOUND;
   hr          = SafeArrayPutElement( psaTry, (long FAR *)&i, &v );

   while( TRUE )
   {
      if( FAILED( hr ) )
         break;

      hr = pIGroup->get_Filter( &varOld );
      if( FAILED( hr ) )
         break;

      VariantInit(&varFilter);

      V_VT(&varFilter)     = VT_VARIANT | VT_ARRAY;
      V_ARRAY( &varFilter)   = psaTry;
      hr = pIGroup->put_Filter( varFilter );
      if( FAILED( hr ) )
         break;

      hr = pIGroup->put_Filter( varOld );
      ASSERT( SUCCEEDED( hr ) );

      hr = VariantClear( &varOld );
      ASSERT( SUCCEEDED( hr ) );
      break;
   }
   SafeArrayDestroy( psaTry );

   return SUCCEEDED( hr );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  BuildFilter( BOOL* pFilters, DWORD dwFilters, VARIANT* pvarFilter )
{
   VARIANT        varFilter;
   DWORD          dwIter, dwCount, dwType;
   SAFEARRAY      *psaFilter  = NULL;
   HRESULT        hResult;
   SAFEARRAYBOUND sabFilterArray;
   BSTR           bstrTexts[ LIMIT ];
   TCHAR          szType[ 128 ];

   dwCount  = 0L;

   for( dwType = 0L ; dwType < dwFilters ; dwType++ )
   {
      if( OTHER == dwType )
         continue;

      if( pFilters[ dwType ] )
      {
         StringFromType( dwType, szType );
         bstrTexts[ dwCount++ ]  = AllocBSTR( szType );
      }
   }

   sabFilterArray.cElements   = dwCount;
   sabFilterArray.lLbound     = LBOUND;
   psaFilter                  = SafeArrayCreate( VT_VARIANT, 1, &sabFilterArray );

   if ( psaFilter )
   {
      for( dwIter = LBOUND; dwIter < ( LBOUND + dwCount ); dwIter++ )
      {
         VariantInit(&varFilter);
         V_VT(&varFilter)    = VT_BSTR;

         V_BSTR(&varFilter)  = bstrTexts[ dwIter ];
         hResult     = SafeArrayPutElement( psaFilter,
                                            (long FAR *)&dwIter, &varFilter );
         ASSERT( SUCCEEDED( hResult ) );
         VariantClear( &varFilter );
      }

      V_VT(pvarFilter)     = VT_VARIANT | VT_ARRAY;
      V_ARRAY(pvarFilter)  = psaFilter;
   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     SetFilter( IADsCollection* pIColl, BOOL* pFilters, DWORD dwFilters )
{
   VARIANT        v;
   HRESULT        hResult;

   hResult  = BuildFilter( pFilters, dwFilters, &v );

   if( SUCCEEDED( hResult ) )
   {
      /*hResult  = pIColl->put_Filter( v );
      if( FAILED( hResult ) )
      {
         TRACE( _T( "ERROR! put_Filter failed") );
      } */

      VariantClear( &v );
   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  SetFilter( MEMBERS* pIGroup, BOOL* pFilters, DWORD dwFilters )
{
   VARIANT        v;
   HRESULT        hResult;

   hResult  = BuildFilter( pFilters, dwFilters, &v );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pIGroup->put_Filter( v );
      if( FAILED( hResult ) )
      {
         TRACE( _T( "ERROR! put_Filter failed") );
      }

      VariantClear( &v );
   }

   return SUCCEEDED( hResult );
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  SetFilter( IADsContainer* pIContainer, BOOL* pFilters, DWORD dwFilters )
{
   VARIANT        v;
   HRESULT        hResult;

   hResult  = BuildFilter( pFilters, dwFilters, &v );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pIContainer->put_Filter( v );
      if( FAILED( hResult ) )
      {
         TRACE( _T( "ERROR! put_Filter failed") );
      }

      VariantClear( &v );
   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  OleDsGetErrorText ( HRESULT  hResult  )
{
   TCHAR szText[ 128 ];

   switch( hResult )
   {
      case  E_ADS_BAD_PATHNAME:
         return CString( _T("E_ADS_BAD_PATHNAME") );
         break;

      case  E_ADS_INVALID_DOMAIN_OBJECT:
         return CString( _T("E_ADS_INVALID_DOMAIN_OBJECT") );
         break;

      case  E_ADS_INVALID_USER_OBJECT:
         return CString( _T("E_ADS_INVALID_USER_OBJECT") );
         break;

      case  E_ADS_INVALID_COMPUTER_OBJECT:
         return CString( _T("E_ADS_INVALID_COMPUTER_OBJECT") );
         break;

      case  E_ADS_UNKNOWN_OBJECT:
         return CString( _T("E_ADS_UNKNOWN_OBJECT") );
         break;

      case  E_ADS_PROPERTY_NOT_SET:
         return CString( _T("E_ADS_PROPERTY_NOT_SET") );
         break;

      case  E_ADS_PROPERTY_NOT_SUPPORTED:
         return CString( _T("E_ADS_PROPERTY_NOT_SUPPORTED") );
         break;

      case  E_ADS_PROPERTY_INVALID:
         return CString( _T("E_ADS_PROPERTY_INVALID") );
         break;

      case  E_ADS_BAD_PARAMETER:
         return CString( _T("E_ADS_BAD_PARAMETER") );
         break;

      case  E_ADS_OBJECT_UNBOUND:
         return CString( _T("E_ADS_OBJECT_UNBOUND") );
         break;

      case  E_ADS_PROPERTY_NOT_MODIFIED:
         return CString( _T("E_ADS_PROPERTY_NOT_MODIFIED") );
         break;

      case  E_ADS_PROPERTY_MODIFIED:
         return CString( _T("E_ADS_PROPERTY_MODIFIED") );
         break;

      case  E_ADS_CANT_CONVERT_DATATYPE:
         return CString( _T("E_ADS_CANT_CONVERT_DATATYPE") );
         break;

      case  E_ADS_PROPERTY_NOT_FOUND:
         return CString( _T("E_ADS_PROPERTY_NOTFOUND") );
         break;

      case  E_ADS_OBJECT_EXISTS:
         return CString( _T("E_ADS_OBJECT_EXISTS") );
         break;

      case  E_ADS_SCHEMA_VIOLATION:
         return CString( _T("E_ADS_SCHEMA_VIOLATION") );
         break;

      case  E_ADS_COLUMN_NOT_SET:
         return CString( _T("E_ADS_COLUMN_NOT_SET") );
         break;

      case  E_ADS_INVALID_FILTER:
         return CString( _T("E_ADS_INVALID_FILTER") );
         break;

      //case  E_ADS_LDAP_BASE:
      //   return CString( _T("E_ADS_LDAP_BASE") );
      //   break;

      case  HRESULT_FROM_WIN32(ERROR_DS_OPERATIONS_ERROR):
         return CString( _T("ERROR_DS_OPERATIONS_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_PROTOCOL_ERROR):
         return CString( _T("ERROR_DS_PROTOCOL_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED):
         return CString( _T("ERROR_DS_TIMELIMIT_EXCEEDED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_SIZELIMIT_EXCEEDED):
         return CString( _T("ERROR_DS_SIZELIMIT_EXCEEDED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_COMPARE_FALSE):
         return CString( _T("ERROR_DS_COMPARE_FALSE") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_DS_COMPARE_TRUE):
         return CString( _T("ERROR_DS_COMPARE_TRUE") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED):
         return CString( _T("ERROR_DS_AUTH_METHOD_NOT_SUPPORTED") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_DS_STRONG_AUTH_REQUIRED):
         return CString( _T("ERROR_DS_STRONG_AUTH_REQUIRED") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_MORE_DATA):
         return CString( _T("ERROR_MORE_DATA") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_REFERRAL):
         return CString( _T("(ERROR_DS_REFERRAL") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED):
         return CString( _T("ERROR_DS_ADMIN_LIMIT_EXCEEDED") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE_CRIT_EXTENSION):
         return CString( _T("(ERROR_DS_UNAVAILABLE_CRIT_EXTENSION") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED):
         return CString( _T("HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE):
         return CString( _T("ERROR_DS_NO_ATTRIBUTE_OR_VALUE") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED):
         return CString( _T("(ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_MATCHING):
         return CString( _T("(ERROR_DS_INAPPROPRIATE_MATCHING") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION):
         return CString( _T("ERROR_DS_CONSTRAINT_VIOLATION") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS):
         return CString( _T("ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX):
         return CString( _T("ERROR_DS_INVALID_ATTRIBUTE_SYNTAX") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
         return CString( _T("ERROR_DS_NO_SUCH_OBJECT") );
         break;

      // case  HRESULT_FROM_WIN32(E_ADS_LDAP_ALIAS_PROBLEM:
         // return CString( _T("HRESULT_FROM_WIN32(E_ADS_LDAP_ALIAS_PROBLEM") );
         // break;

      case  HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX):
         return CString( _T("(ERROR_DS_INVALID_DN_SYNTAX") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_IS_LEAF):
         return CString( _T("(ERROR_DS_IS_LEAF") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ALIAS_DEREF_PROBLEM):
         return CString( _T("(ERROR_DS_ALIAS_DEREF_PROBLEM") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_AUTH):
         return CString( _T("(ERROR_DS_INAPPROPRIATE_AUTH") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
         return CString( _T("(ERROR_INVALID_PASSWORD") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
         return CString( _T("ERROR_ACCESS_DENIED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_BUSY):
         return CString( _T("ERROR_DS_BUSY") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE):
         return CString( _T("ERROR_DS_UNAVAILABLE") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM):
         return CString( _T("ERROR_DS_UNWILLING_TO_PERFORM") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_LOOP_DETECT):
         return CString( _T("ERROR_DS_LOOP_DETECT") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION):
         return CString( _T("ERROR_DS_NAMING_VIOLATION") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION):
         return CString( _T("ERROR_DS_OBJ_CLASS_VIOLATION") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_NON_LEAF):
         return CString( _T("ERROR_DS_CANT_ON_NONLEAF") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_RDN):
         return CString( _T("ERROR_DS_CANT_ON_RDN") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
         return CString( _T("ERROR_ALREADY_EXISTS") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CANT_MOD_OBJ_CLASS):
         return CString( _T("ERROR_DS_CANT_MOD_OBJ_CLASS") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_OBJECT_RESULTS_TOO_LARGE):
         return CString( _T("ERROR_DS_OBJECT_RESULTS_TOO_LARGE") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_AFFECTS_MULTIPLE_DSAS):
         return CString( _T("ERROR_DS_AFFECTS_MULTIPLE_DSAS") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_GEN_FAILURE):
         return CString( _T("(ERROR_GEN_FAILURE") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
         return CString( _T("ERROR_DS_SERVER_DOWN") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_LOCAL_ERROR):
         return CString( _T("ERROR_DS_LOCAL_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ENCODING_ERROR):
         return CString( _T("ERROR_DS_ENCODING_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_DECODING_ERROR):
         return CString( _T("(ERROR_DS_DECODING_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_TIMEOUT):
         return CString( _T("(ERROR_TIMEOUT") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN):
         return CString( _T("ERROR_DS_AUTH_UNKNOWN") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN):
         return CString( _T("(ERROR_DS_FILTER_UNKNOWN") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_CANCELLED):
         return CString( _T("(ERROR_CANCELLED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR):
         return CString( _T("ERROR_DS_PARAM_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
         return CString( _T("ERROR_NOT_ENOUGH_MEMORY") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_CONNECTION_REFUSED):
         return CString( _T("ERROR_CONNECTION_REFUSED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NOT_SUPPORTED):
         return CString( _T("ERROR_DS_NOT_SUPPORTED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED):
         return CString( _T("ERROR_DS_NO_RESULTS_RETURNED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CONTROL_NOT_FOUND):
         return CString( _T("ERROR_DS_CONTROL_NOT_FOUND") );
         break;

      // case  HRESULT_FROM_WIN32(E_ADS_LDAP_MORE_RESULTS_TO_RETURN:
         // return CString( _T("HRESULT_FROM_WIN32(E_ADS_LDAP_MORE_RESULTS_TO_RETURN") );
         // break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CLIENT_LOOP):
         return CString( _T("(ERROR_DS_CLIENT_LOOP") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_REFERRAL_LIMIT_EXCEEDED):
         return CString( _T("ERROR_DS_REFERRAL_LIMIT_EXCEEDED") );
         break;

      // case  HRESULT_FROM_WIN32(E_ADS_LDAP_LAST:
         // return CString( _T("HRESULT_FROM_WIN32(E_ADS_LDAP_LAST") );
         // break;

      case  E_FAIL:
         return CString( _T("E_FAIL") );
         break;

      case  E_NOTIMPL:
         return CString( _T("E_NOIMPL") );
         break;

      case  S_OK:
         return CString( _T("OK") );
         break;

      case  0x800704b8:
      // we have an extended error
      {
         TCHAR szError[ 1024 ];
         WCHAR szErrorBuff[ 1024 ];
         WCHAR szNameBuff[ 1024 ];
         DWORD dwError;

         ADsGetLastError( &dwError,
                          szErrorBuff,
                          1023,
                          szNameBuff,
                          1023 );
         wcscat( szNameBuff, L" : " );
         wcscat( szNameBuff, szErrorBuff );

         _tcscpy( szError, _T("ERROR: ") );
         Convert( szError + _tcslen( szError ), szNameBuff );

         return CString( szError );
      }

      default:
      {
         LPVOID lpMsgBuf;
         UINT   nChars;

         nChars   = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            SCODE_CODE(hResult),
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPTSTR) &lpMsgBuf,
                            0,
                            NULL
                           );

         if( nChars )
         {
            if( nChars != _tcslen( (LPTSTR)lpMsgBuf ) )
            {
               ((LPTSTR)lpMsgBuf)[nChars]  = _T('\0');
            }
            wsprintf( szText, _T("ERROR: %lx - %s"), hResult, (LPTSTR)lpMsgBuf );
            LocalFree( lpMsgBuf );

         }
         else
         {
            DWORD dwLastError;

            wsprintf( szText, _T("ERROR: %lx"), hResult );
            dwLastError = GetLastError();
         }
         return CString( szText );
         break;
      }
   }
}


/***********************************************************
  Function: BuildVariantArray
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  BuildVariantArray( VARTYPE vType,
                            CString& rText,
                            VARIANT& varRes,
                            TCHAR cSeparator )
{
   VARIANT        vTemp, vTyped;
   SAFEARRAY*     psa;
   SAFEARRAYBOUND sab;
   CStringArray   strArray;
   TCHAR*         strText;
   int            nItems   = 0;
   int            nIdx;
   int            nSize;
   LPTSTR         lpName;
   HRESULT        hResult;

   strText  = (TCHAR*) new TCHAR[ rText.GetLength( ) + 1 ];

   if( !strText )
   {
      return E_FAIL;
   }

   if( VT_I8 == vType )
   {
      vType = VT_R8;
   }

   _tcscpy( strText, rText.GetBuffer( rText.GetLength( ) ) );

   nSize    = rText.GetLength( );
   nItems   = nSize ? 1 : 0;
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      if( strText[ nIdx ] == cSeparator )
      {
         nItems++;
         strText[ nIdx ] = _T('\0');
      }
   }

   sab.cElements   = nItems;
   sab.lLbound     = LBOUND;
   psa             = SafeArrayCreate( VT_VARIANT, 1, &sab );

   ASSERT( NULL != psa );

   if ( psa )
   {

      lpName      = strText;
      for( nIdx = LBOUND; nIdx < ( LBOUND + nItems ) ; nIdx++ )
      {
         while( *lpName == _T(' ') )
         {
            lpName++;
         }

         VariantInit( &vTemp );
         V_VT(&vTemp)  = VT_BSTR;

         V_BSTR(&vTemp) = AllocBSTR( lpName );
         lpName         = lpName + ( _tcslen( lpName ) + 1 );

         VariantInit( &vTyped );
         hResult  = VariantChangeType( &vTyped, &vTemp, VARIANT_NOVALUEPROP, vType );

         hResult  = SafeArrayPutElement( psa, (long FAR *)&nIdx, &vTyped );

         VariantClear( &vTyped );
         VariantClear( &vTemp );
         ASSERT( SUCCEEDED( hResult ) );
      }

      V_VT( &varRes )     = VT_VARIANT | VT_ARRAY;
      V_ARRAY( &varRes )  = psa;
   }

   delete [] strText;

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function: FromVariantArrayToString
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  FromVariantArrayToString( VARIANT& v, TCHAR* pszSeparator )
{
   SAFEARRAY*  pSafeArray;
   TCHAR       szText[ 2048 ];
   VARIANT     var, varString;
   long        lBound, uBound, lItem;
   HRESULT     hResult;
   BOOL        bFirst;
   CString     strResult;


   // array of VT_UI1 (probably OctetString)
   if( (VT_ARRAY | VT_UI1) == V_VT( &v ) )
   {
      BYTE        bValue;

      pSafeArray  = V_ARRAY( &v );

      hResult     = SafeArrayGetLBound(pSafeArray, 1, &lBound);
      hResult     = SafeArrayGetUBound(pSafeArray, 1, &uBound);

      szText[ 0 ]    = _T('\0');

      for( lItem = lBound; lItem <= uBound ; lItem++ )
      {
         hResult  = SafeArrayGetElement( pSafeArray, &lItem, &bValue );
         if( FAILED( hResult ) )
         {
            break;
         }

         _stprintf( szText + _tcslen(szText), _T(" x%02x"), bValue );
         if( _tcslen( szText ) > 2044 )
            break;
      }

      return CString( szText );
   }

   if( V_VT( &v ) != (VT_VARIANT | VT_ARRAY) )
   {
      VARIANT  vString;

      TRACE( _T("Warning: Non array variant!!!\n") );
      VariantInit( &vString );

      hResult  = VariantChangeType( &vString, &v, VARIANT_NOVALUEPROP, VT_BSTR );
      if( FAILED( hResult ) )
      {
         V_VT( &vString )     = VT_BSTR;
         V_BSTR( &vString )   = AllocBSTR( _T("ERROR on conversion") );
      }
      _tcscpy( szText, _T("") );
      StringCat( szText, V_BSTR(&vString) );
      VariantClear( &vString);

      return CString( szText );
   }

   pSafeArray   = V_ARRAY( &v );

   hResult = SafeArrayGetLBound(pSafeArray, 1, &lBound);
   hResult = SafeArrayGetUBound(pSafeArray, 1, &uBound);

   VariantInit( &varString );
   szText[ 0 ]    = _T('\0');
   bFirst         = TRUE;

   for( lItem = lBound; lItem <= uBound ; lItem++ )
   {
      hResult  = SafeArrayGetElement( pSafeArray, &lItem, &var );
      if( FAILED( hResult ) )
      {
         break;
      }

      if( ConvertFromPropertyValue( var, szText ) )
      {
         V_VT( &varString )   = VT_BSTR;
         V_BSTR( &varString ) = AllocBSTR( szText );
         hResult  = S_OK;
      }
      else
      {
         hResult  = VariantChangeType( &varString, &var,
                                       VARIANT_NOVALUEPROP, VT_BSTR );
      }

      if( SUCCEEDED( hResult ) )
      {
         _tcscpy( szText, _T("") );
         if( !bFirst )
         {
            if( NULL == pszSeparator )
            {
               _tcscat( szText, SEPARATOR_S );
            }
            else
            {
               _tcscat( szText, pszSeparator );
            }
         }

         StringCat( szText, V_BSTR( &varString ) );

         bFirst   = FALSE;
         VariantClear( &varString );

         strResult  += szText;
      }

      VariantClear( &var );
   }

   return strResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  FromVariantToString( VARIANT& v)
{
   return FromVariantArrayToString( v );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject*  CreateOleDsObject( DWORD  dwType, IUnknown* pIUnk )
{
   COleDsObject*  pObject;

   switch( dwType )
   {
      case  DOMAIN:
         pObject  = new COleDsDomain( pIUnk );
         break;

      case  COMPUTER:
         pObject  = new COleDsComputer( pIUnk );
         break;

      case  USER:
         pObject  = new COleDsUser( pIUnk );
         break;

      case  GROUP:
         pObject  = new COleDsGroup( pIUnk );
         break;

      case  SERVICE:
         pObject  = new COleDsService( pIUnk );
         break;

      case  FILESERVICE:
         pObject  = new COleDsFileService( pIUnk );
         break;

      case  PRINTQUEUE:
         pObject  = new COleDsPrintQueue( pIUnk );
         break;

      case  PRINTJOB:
         pObject  = new COleDsPrintJob( pIUnk );
         break;

      case  PRINTDEVICE:
         pObject  = new COleDsPrintDevice( pIUnk );
         break;

      case  SESSION:
         pObject  = new COleDsSession( pIUnk );
         break;

      case  FILESHARE:
         pObject  = new COleDsFileShare( pIUnk );
         break;

      case  RESOURCE:
         pObject  = new COleDsResource( pIUnk );
         break;

      case  NAMESPACE:
         pObject  = new COleDsNamespace( pIUnk );
         break;

      case  NAMESPACES:
         pObject  = new COleDsNamespaces( pIUnk );
         break;
      case  NDSROOT:
      case  NDSORG:
      case  NDSOU:
      case  PRINTER:
      case  NDSALIAS:
      case  NDSDIRECTORYMAP:
      case  NDSDISTRIBUTIONLIST:
      case  NDSAFPSERVER:
      case  NDSCOMMUNICATIONSSERVER:
      case  NDSMESSAGEROUTINGGROUP:
      case  NDSNETWARESERVER:
      case  NDSORGANIZATIONALROLE:
      case  NDSPRINTQUEUE:
      case  NDSPRINTSERVER:
      case  NDSPROFILE:
      case  NDSVOLUME:
      case  OTHER:
      case  CLASS:
      case  SCHEMA:
      case  PROPERTY:
      case  SYNTAX:
         pObject  = new COleDsGeneric( pIUnk );
         break;

      default:
         ASSERT( FALSE );
         pObject  = new COleDsObject( pIUnk );
         break;

   }

   return pObject;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  ErrorOnPutProperty( CString& strFuncSet,
						        CString& strProperty,
                          CString& strPropValue,
                          HRESULT  hResult,
                          BOOL     bGeneric,
                          BOOL     bUseEx )
{
   CErrorDialog   aErrorDialog;
   CString        strOperation;

   if( !bGeneric )
   {
      strOperation   = _T("put_");
      strOperation  += strProperty;
   }
   else
   {
      strOperation   = _T("Put");
      if( bUseEx )
      {
         strOperation  += _T("Ex");
      }
      strOperation  += _T("( ");
      strOperation  += strProperty;
      strOperation  += _T(", ...)");
   }


   //aErrorDialog.m_FuncSet  = strFuncSet;
   aErrorDialog.m_Operation   = strOperation;
   aErrorDialog.m_Value       = strPropValue;
   aErrorDialog.m_Result      = OleDsGetErrorText( hResult );

   aErrorDialog.DoModal( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CheckIfValidClassName( WCHAR* lpszClassName )
{
   TCHAR szClassName[ 512 ];

   if( !lpszClassName )
   {
      TRACE( _T("Oops! Found NULL class name: %s\n"), lpszClassName );
      return TRUE;
   }

   if( !_wcsicmp( lpszClassName, L"Namespace") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"Namespaces") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"User") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"Group") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"Domain") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"Computer") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"Service") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"FileService") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"Printqueue") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"Printjob") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"PrintDevice") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"Session") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Resource") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"FileShare") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Tree") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Organization") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Organizational Unit") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"OrganizationalUnit") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Printer") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Class") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Property") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Syntax") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Schema") )
      return   TRUE;

   _tcscpy( szClassName, _T("") );
   StringCat( szClassName, lpszClassName );

   TRACE( _T("Oops! Found unknown class name: %s\n"), szClassName );

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CheckIfValidClassName( CHAR* pszClassName )
{
   int      nLength;
   WCHAR*   pszwClassName;
   BOOL     bRez;

   nLength        = strlen( pszClassName );

   pszwClassName  = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   memset( pszwClassName, 0, ( nLength + 1 ) * sizeof(WCHAR) );

   MultiByteToWideChar( CP_ACP,
                        MB_PRECOMPOSED,
                        pszClassName,
                        nLength,
                        pszwClassName,
                        nLength + 1 );

   bRez  = CheckIfValidClassName( pszwClassName );

   free( pszwClassName );

   return bRez;


   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   GetImageListIndex( DWORD dwObjectType )
{
   int   nIndex;

   nIndex   = 0;
   dwObjectType   = dwObjectType >> 1;
   while( dwObjectType )
   {
      nIndex++;
      dwObjectType   = dwObjectType >> 1;
   }

   return nIndex;
}


/***********************************************************
  Function:    GetBitmapImageId
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
UINT  GetBitmapImageId( DWORD dwObjectType )
{
   switch( dwObjectType )
   {
      case  USER:
         return IDB_USER;

      case  SERVICE:
         return IDB_SERVICE;

      case  DOMAIN:
         return IDB_DOMAIN;

      case  COMPUTER:
         return IDB_COMPUTER;

      case  PRINTQUEUE:
      case  PRINTER:
         return IDB_PRINTQUEUE;

      case  FILESHARE:
         return IDB_FILESHARE;

      case  GROUP:
         return IDB_GROUP;

      case  SESSION:
         return IDB_SESSION;

      case  RESOURCE:
         return IDB_RESOURCE;

      case  PRINTJOB:
         return IDB_PRINTJOB;

      case  NDSROOT:
         return IDB_ROOT;

      case  NDSORG:
         return IDB_ORGANISATION;

      case  NDSOU:
         return IDB_ORGANISATIONUNIT;

      case  NAMESPACES:
         return IDB_NAMESPACES;

      case  NAMESPACE:
         return IDB_NAMESPACE;

      case  NDSALIAS:
         return IDB_NDS_ALIAS;

      case  NDSDIRECTORYMAP:
         return IDB_NDS_DIRECTORY_MAP;

      case  NDSDISTRIBUTIONLIST:
         return IDB_NDS_DISTRIBUTION_LIST;

      case  NDSAFPSERVER:
         return IDB_NDS_AFP_SERVER;

      case  NDSCOMMUNICATIONSSERVER:
         return IDB_NDS_COMMUNICATIONS_SERVER;

      case  NDSMESSAGEROUTINGGROUP:
         return IDB_NDS_MESSAGE_ROUTING_GROUP;

      case  NDSNETWARESERVER:
         return IDB_NDS_NETWARE_SERVER;

      case  NDSORGANIZATIONALROLE:
         return IDB_NDS_ORGANIZATIONAL_ROLE;

      case  NDSPRINTQUEUE:
         return IDB_NDS_PRINT_QUEUE;

      case  NDSPRINTSERVER:
         return IDB_NDS_PRINT_SERVER;

      case  NDSPROFILE:
         return IDB_NDS_PROFILE;

      case  NDSVOLUME:
         return IDB_NDS_VOLUME;

      case  SYNTAX:
         return IDB_SYNTAX;

      case  PROPERTY:
         return IDB_PROPERTY;

      case  CLASS:
      case  SCHEMA:
         return IDB_CLASS;

      default:
         return IDB_DUMMY;
   }
}


/***********************************************************
  Function:    AllocBSTR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BSTR  AllocBSTR( WCHAR* pszwString )
{
   return SysAllocString( pszwString );
}


/***********************************************************
  Function:    AllocBSTR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BSTR  AllocBSTR( CHAR* pszString )
{
   int      nLength;
   WCHAR*   pszwString;
   BSTR     bstrText;

   nLength     = strlen( pszString );

   pszwString  = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   memset( pszwString, 0, ( nLength + 1 ) * sizeof(WCHAR) );

   MultiByteToWideChar( CP_ACP,
                        MB_PRECOMPOSED,
                        pszString,
                        nLength,
                        pszwString,
                        nLength + 1 );

   bstrText    = AllocBSTR( pszwString );
   free( pszwString );

   return bstrText;
}


/*******************************************************************
  Function:    Get
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  Get( IADs* pIOleDs, CHAR* pszProperty, VARIANT* pVar)
{
   int      nLength;
   WCHAR*   pszwProperty;
   HRESULT  hResult;

   nLength        = strlen( pszProperty );

   pszwProperty   = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   memset( pszwProperty, 0, ( nLength + 1 ) * sizeof(WCHAR) );

   MultiByteToWideChar( CP_ACP,
                        MB_PRECOMPOSED,
                        pszProperty,
                        nLength,
                        pszwProperty,
                        nLength + 1 );

   hResult  = Get( pIOleDs, pszwProperty, pVar );
   free( pszwProperty );

   return hResult;
}


/*******************************************************************
  Function:    Get
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  Get( IADs* pIOleDs, WCHAR* pszwProperty, VARIANT* pVar)
{
   HRESULT  hResult;

   VariantInit( pVar );

   hResult  = pIOleDs->Get( pszwProperty, pVar );

   return hResult;
}


/*******************************************************************
  Function:    Put
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  Put( IADs* pIOleDs, CHAR* pszProperty, VARIANT Var)
{
   int      nLength;
   WCHAR*   pszwProperty;
   HRESULT  hResult;

   nLength        = strlen( pszProperty );

   pszwProperty   = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   memset( pszwProperty, 0, ( nLength + 1 ) * sizeof(WCHAR) );

   MultiByteToWideChar( CP_ACP,
                        MB_PRECOMPOSED,
                        pszProperty,
                        nLength,
                        pszwProperty,
                        nLength + 1 );

   hResult  = Put( pIOleDs, pszwProperty, Var );
   free( pszwProperty );

   return hResult;
}


/*******************************************************************
  Function:    Put
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  Put( IADs* pIOleDs, WCHAR* pszwProperty, VARIANT Var)
{
   HRESULT  hResult;

   hResult  = pIOleDs->Put( pszwProperty, Var );

   return hResult;
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  XOleDsGetObject( WCHAR* pszwPath, REFIID refiid, void** pVoid )
{
   // cahged to add the hack for Win95.
   HRESULT  hResult;

   hResult  = ADsGetObject( pszwPath, refiid, pVoid );
   if( FAILED( hResult ) )
   {
      // now's the hack.
      // Danilo says take OLE DS paths and prepent a "@"
      // to and change the first ":" into a "!"
      WCHAR szHackPath[ 256 ];

      // first, add @
      wcscpy( szHackPath, L"@" );
      wcscat( szHackPath, pszwPath );

      // second, change the first ":" into a "!"
      for( UINT nIdx = 0 ; nIdx < wcslen( szHackPath ); nIdx++ )
      {
         if( szHackPath[ nIdx ] == L':' )
         {
            szHackPath[ nIdx ] = L'!';
            break;
         }
      }

      hResult  = ADsGetObject( szHackPath, refiid, pVoid );
   }

   return hResult;
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  XOleDsGetObject( CHAR* pszPath, REFIID refiid, void** pVoid )
{
   int      nLength;
   WCHAR*   pszwPath;
   HRESULT  hResult;

   nLength  = strlen( pszPath );

   pszwPath = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   memset( pszwPath, 0, ( nLength + 1 ) * sizeof(WCHAR) );

   MultiByteToWideChar( CP_ACP,
                        MB_PRECOMPOSED,
                        pszPath,
                        nLength,
                        pszwPath,
                        nLength + 1 );

   hResult  = XOleDsGetObject( pszwPath, refiid, pVoid );

   free( pszwPath );

   return hResult;
}


/*******************************************************************
  Function:    XOleDsOpenObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  XOleDsOpenObject( WCHAR* lpszPathName,
                           WCHAR* lpszUserName,
                           WCHAR* lpszPassword,
                           REFIID refiid,
                           void** pVoid )
{
   HRESULT  hResult;

   hResult  = ADsOpenObject(
                             lpszPathName,
                             lpszUserName,
                             lpszPassword,
                             NULL,
                             refiid,
                             pVoid );
   if( FAILED( hResult ) )
   {
      // now's the hack.
      // Danilo says take OLE DS paths and prepent a "@"
      // to and change the first ":" into a "!"
      WCHAR szHackPath[ 256 ];

      // first, add @
      wcscpy( szHackPath, L"@" );
      wcscat( szHackPath, lpszPathName );

      // second, change the first ":" into a "!"
      for( UINT nIdx = 0 ; nIdx < wcslen( szHackPath ); nIdx++ )
      {
         if( szHackPath[ nIdx ] == L':' )
         {
            szHackPath[ nIdx ] = L'!';
            break;
         }
      }
      hResult  = ADsOpenObject( szHackPath,
                                lpszUserName,
                                lpszPassword,
                                NULL,
                                refiid,
                                pVoid );
   }

   return hResult;
}


/*******************************************************************
  Function:    XOleDsOpenObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  XOleDsOpenObject( CHAR* lpszPathName,
                           CHAR* lpszUserName,
                           CHAR* lpszPassword,
                           REFIID refiid,
                           void** pVoid )
{
   BSTR     bstrPathName, bstrUserName, bstrPassword;
   HRESULT  hResult;

   bstrPathName   = AllocBSTR( lpszPathName );
   bstrUserName   = AllocBSTR( lpszUserName );
   bstrPassword   = AllocBSTR( lpszPassword );

   hResult  = XOleDsOpenObject( bstrPathName, bstrUserName, bstrPassword,
                                refiid, pVoid );

   SysFreeString( bstrPathName );
   SysFreeString( bstrUserName );
   SysFreeString( bstrPassword );

   return hResult;
}



/*******************************************************************
  Function:    StringCat
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
void  StringCat( WCHAR* pszString, BSTR bstrText )
{
   wcscat( pszString, bstrText );
}


/*******************************************************************
  Function:    StringCat
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
void  StringCat( CHAR* pszString, BSTR bstrText )
{
   CHAR* pszText;
   UINT  nLength;
   CHAR  defChar  = ' ';
   BOOL  bUseDefault;
   int   nRez;
   DWORD dwError;

   nLength  = SysStringLen( bstrText );
   pszText  = (CHAR*) malloc( (nLength + 1) * sizeof(CHAR) );
   memset( pszText, 0, (nLength + 1) * sizeof(CHAR) );

   nRez  = WideCharToMultiByte( CP_ACP,
                                0L,
                                bstrText,
                                nLength,
                                pszText,
                                nLength + 1,
                                &defChar,
                                &bUseDefault );
   if( !nRez )
   {
      dwError  = GetLastError( );
   }

   strcat( pszString, pszText );

   free( pszText );
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
void  SetLastProfileString( TCHAR* szSection, CString& rValue )
{
   WritePrivateProfileString( _T("LastParameters"), szSection,
                              rValue.GetBuffer( 256 ), _T("adsvw.ini") );
}


/*******************************************************************
  Function:    SetLastProfileString
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
void  GetLastProfileString( TCHAR* szSection, CString& rValue )
{
   TCHAR szValue[ 256 ];

   GetPrivateProfileString( _T("LastParameters"), szSection,
                            _T(""), szValue, 255, _T("adsvw.ini") );

   rValue   = szValue;
}


/*******************************************************************
  Function:    GetByteValue
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
BYTE  GetByteValue( TCHAR* szString )
{
   BYTE  bBytes[ 2 ];

   bBytes[ 0 ] = bBytes[ 1 ]  = 0;

   for( int i = 0; i < 2 ; i++ )
   {
      if( !szString[ i ] )
         break;

#ifdef UNICODE
      if( !iswdigit( szString[ i ] ) )
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x37;
      }
#else
      if( !isdigit( szString[ i ] ) )
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x37;
      }
#endif
      else
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x30;
      }
   }

   return ( bBytes[ 0 ] << 4 ) + bBytes[ 1 ];
}

/*******************************************************************
  Function:    CreateBlobArray
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CreateBlobArrayFromFile( CString& rText, VARIANT& rBlob )
{
   TCHAR*         pszFileName;
   TCHAR          pszTemp[ 2 * MAX_PATH ];
   CFile          aFile;
   CFileException e;

   rText.TrimLeft( );

   _tcscpy( pszTemp, (LPCTSTR)rText );
   pszFileName = pszTemp;

   pszFileName   += _tcslen( _T("[FILE]") );
   while( *pszFileName == _T(' ') )
      pszFileName++;

   if( !aFile.Open( pszFileName, CFile::modeRead, &e ) )
   {

#ifdef _DEBUG
      afxDump << "File could not be opened " << e.m_cause << "\n";
#endif
   }
   else
   {
      SAFEARRAY*     psa;
      SAFEARRAYBOUND sab;
      LONG           lItem;
      DWORD          dwIdx;
      DWORD          dwRead;
      HRESULT        hResult;
      BYTE           bBuffer[ 128 ];

      sab.cElements  = (ULONG)(aFile.GetLength( ));
      sab.lLbound    = LBOUND;
      psa            = SafeArrayCreate( VT_UI1, 1, &sab );
      lItem          = LBOUND;

      while( TRUE )
      {
         dwRead   = aFile.Read( (LPVOID)bBuffer, 128 );

         for( dwIdx = 0; dwIdx < dwRead ; dwIdx++ )
         {
            hResult  = SafeArrayPutElement( psa, &lItem, bBuffer + dwIdx );
            ASSERT( SUCCEEDED( hResult ) );
         }
         if( dwRead != 128 )
            break;
      }

      V_VT( &rBlob )     = VT_UI1 | VT_ARRAY;
      V_ARRAY( &rBlob )  = psa;

      aFile.Close( );
   }

   return S_OK;
}


/*******************************************************************
  Function:    CreateBlobArray
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CreateBlobArray( CString& rText, VARIANT& rBlob )
{
   SAFEARRAY*     psa;
   SAFEARRAYBOUND sab;
   TCHAR*         strText;
   int            nItems   = 0;
   int            nIdx;
   int            nSize;
   HRESULT        hResult;
   BYTE           bVal;

   rText.MakeUpper( );
   rText.TrimLeft( );

   if( !_tcsnicmp( (LPCTSTR)rText,
                   _T("[FILE]"),
                   min( (int)rText.GetLength( ), (int)_tcslen( _T("[FILE]") ) )
                 )
     )
   {
      hResult  = CreateBlobArrayFromFile( rText, rBlob );
      return hResult;
   }

   strText  = (TCHAR*) new TCHAR[ rText.GetLength( ) + 1 ];
   if( !strText )
   {
      return E_FAIL;
   }

   _tcscpy( strText, rText.GetBuffer( rText.GetLength( ) ) );
   nSize    = rText.GetLength( );
   nItems   = 0;
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      if( strText[ nIdx ] == _T('X') )
      {
         nItems++;
      }
   }

   sab.cElements   = nItems;
   sab.lLbound     = LBOUND;
   psa             = SafeArrayCreate( VT_UI1, 1, &sab );
   ASSERT( NULL != psa );
   if ( psa )
   {
      int   nItems = 0;

      for( nIdx = LBOUND; nIdx < ( LBOUND + nSize ); nIdx++ )
      {
         if( strText[ nIdx ] == _T('X') )
         {
            bVal  = GetByteValue( strText + nIdx + 1 );
            hResult  = SafeArrayPutElement( psa, (long FAR *)&nItems, &bVal );
            nIdx += 3;
            nItems++;
         }
      }
      V_VT( &rBlob )     = VT_UI1 | VT_ARRAY;
      V_ARRAY( &rBlob )  = psa;
   }

   delete [] strText;

   return hResult;
}


/*******************************************************************
  Function:    CreateBlobArrayEx
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CreateBlobArrayEx( CString& rText, VARIANT& rBlob, TCHAR cSeparator )
{
   SAFEARRAY*     psa;
   SAFEARRAYBOUND sab;
   TCHAR*         strText;
   TCHAR*         strStore;
   int            nItems   = 0;
   int            nIdx;
   int            nSize;
   HRESULT        hResult;

   rText.MakeUpper( );

   strText  = (TCHAR*) new TCHAR[ rText.GetLength( ) + 1 ];
   strStore = strText;
   if( !strText )
   {
      return E_FAIL;
   }

   _tcscpy( strText, rText.GetBuffer( rText.GetLength( ) ) );
   nSize    = rText.GetLength( );
   nItems   = 1;
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      if( strText[ nIdx ] == cSeparator )
      {
         strText[ nIdx ]   = _T('\0');
         nItems++;
      }
   }

   sab.cElements   = nItems;
   sab.lLbound     = LBOUND;
   psa             = SafeArrayCreate( VT_VARIANT, 1, &sab );
   ASSERT( NULL != psa );
   if ( psa )
   {
      for( nIdx = LBOUND; nIdx < ( LBOUND + nItems ) ; nIdx++ )
      {
         VARIANT  var;
         CString  strTemp;

         strTemp  = strText;
         strText += _tcslen( strText ) + 1;

         CreateBlobArray( strTemp, var );
         hResult  = SafeArrayPutElement( psa, (long FAR *)&nIdx, &var );
         VariantClear( &var );
      }

      V_VT( &rBlob )     = VT_VARIANT | VT_ARRAY;
      V_ARRAY( &rBlob )  = psa;
   }

   delete [] strStore;

   return hResult;
}


/******************************************************************************
  Function:    Convert
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
void  Convert( CHAR* pszDest, WCHAR* pszwSrc )
{
   int   nRes  = 0;

   if( wcslen( pszwSrc ) )
   {
      nRes  = WideCharToMultiByte( CP_ACP,
                                   WC_COMPOSITECHECK,
                                   pszwSrc,
                                   wcslen( pszwSrc ),
                                   pszDest,
                                   wcslen( pszwSrc ) + 1,
                                   NULL,
                                   NULL );
      ASSERT( nRes );
   }

   pszDest[ nRes ]	= '\0';

}


/******************************************************************************
  Function:    Convert
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
void  Convert  ( WCHAR* pszwDest, CHAR* pszSrc )
{
   BSTR  bstrTemp;

   bstrTemp = AllocBSTR( pszSrc );
   wcscpy( pszwDest, bstrTemp );
   SysFreeString( bstrTemp );
}


/******************************************************************************
  Function:    Convert
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
void  Convert  ( WCHAR* pszwDest, WCHAR* pszwSrc )
{
   wcscpy( pszwDest, pszwSrc );
}


/******************************************************************************
  Function:    Convert
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
void  Convert( CHAR* pszDest, CHAR* pszSrc )
{
   strcpy( pszDest, pszSrc );
}


/******************************************************************************
  Function:    StringToLARGE_INTEGER
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT     StringToLARGE_INTEGER( TCHAR* szString, LARGE_INTEGER* pValue )
{
   _stscanf( szString, _T("%I64d"), pValue );

   return S_OK;

   HRESULT  hResult;
   VARIANT  vString, vR8;
   double   dLowPart, dHighPart;
   ULONG    ulLowPart, ulHighPart;
   WCHAR    szValue[ 32 ];

   VariantInit( &vString );
   VariantInit( &vR8 );

   V_VT( &vString )   = VT_BSTR;
   Convert( szValue, szString );
   V_BSTR( &vString ) = szValue;

   hResult  = VariantChangeType( &vR8, &vString, VARIANT_NOVALUEPROP, VT_R8 );
   if( SUCCEEDED( hResult ) )
   {
      dHighPart   = V_R8( &vR8 ) / ((double) 1.0 + (double)(ULONG_MAX));
      ulHighPart  = (ULONG)dHighPart;
      dHighPart   = (double)ulHighPart;
      dLowPart    = V_R8( &vR8 ) - dHighPart*((double) 1.0 + (double)(ULONG_MAX));
      ulLowPart   = (ULONG)dLowPart;

      pValue->HighPart= (LONG)ulHighPart;
      pValue->LowPart = ulHighPart;
   }

   return hResult;
}


/******************************************************************************
  Function:    StringToLARGE_INTEGER
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT     LARGE_INTEGERToString( TCHAR* szString,
                                   LARGE_INTEGER* pValue )
{
   _stprintf( szString, _T("%I64d"), *pValue );

   return S_OK;

   /*TCHAR    szText[ 32 ];
   DWORD    dwStatus;
   BOOL     bOK   = FALSE;

   HMODULE  hModule;

   while( TRUE )
   {
      hModule  = LoadLibrary( _T("NTDLL.DLL" ) );
      if( NULL == hModule )
         break;

      LargeIntegerToString = (LARGEINTTOSTRING)GetProcAddress( hModule, _T("RtlLargeIntegerToChar") );
      if( NULL == LargeIntegerToString )
         break;

      dwStatus = LargeIntegerToString( pValue, 10, 31, szText );
      if( 0 == dwStatus )
      {
         Convert( szString, szText );
         bOK   = TRUE;
      }

      break;
   }

   if( NULL != hModule )
   {
      FreeLibrary( hModule );
   }

   if( bOK )
   {
      return S_OK;
   }


   HRESULT  hResult;
   double   dVal;
   VARIANT  vString, vR8;

   dVal  = (double)pValue->HighPart;
   dVal  = dVal * ( (double) 1.0 + (double)(ULONG_MAX) );

   dVal  = dVal + (double)pValue->LowPart;


   VariantInit( &vString );
   VariantInit( &vR8 );

   V_VT( &vR8 )   = VT_R8;
   V_R8( &vR8 )   = dVal;

   hResult  = VariantChangeType( &vString, &vR8, VARIANT_NOVALUEPROP, VT_BSTR );
   ASSERT( SUCCEEDED( hResult ) );

   if( SUCCEEDED( hResult ) )
   {

      Convert( szString, V_BSTR( &vString ) );
      VariantClear( &vString );
   }

   return hResult;*/
}


/******************************************************************************
  Function:    CopyACE
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
IDispatch*  CopyACE( IDispatch*  pSrc )
{
   IADsAccessControlEntry* pACE;
   IADsAccessControlEntry* pSrcACE;
   IDispatch*              pNewACE  = NULL;
   HRESULT                 hResult;
   LONG                    lValue;
   BSTR                    bstrValue   = NULL;

   hResult  = pSrc->QueryInterface( IID_IADsAccessControlEntry, (void**)&pSrcACE );

   if( FAILED( hResult ) )
      return NULL;


   hResult = CoCreateInstance(
                               CLSID_AccessControlEntry,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IADsAccessControlEntry,
                               (void **)&pACE );
   if( SUCCEEDED( hResult ) )
   {
      //******************************************
      hResult  = pSrcACE->get_AccessMask( &lValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_AccessMask( lValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_AccessMask returns %lx\n"), hResult );
         }
      }

      //******************************************
      hResult  = pSrcACE->get_AceType( &lValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_AceType( lValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_AceType returns %lx\n"), hResult );
         }
      }

      //******************************************
      hResult  = pSrcACE->get_AceFlags( &lValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_AceFlags( lValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_AceFlags returns %lx\n"), hResult );
         }
      }

      //******************************************
      hResult  = pSrcACE->get_Flags( &lValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_Flags( lValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_Flags returns %lx\n"), hResult );
         }
      }

      //******************************************
      hResult  = pSrcACE->get_ObjectType( &bstrValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_ObjectType( bstrValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_ObjectType returns %lx\n"), hResult );
         }
         SysFreeString( bstrValue );
         bstrValue   = NULL;

      }

      //******************************************
      hResult  = pSrcACE->get_InheritedObjectType( &bstrValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_InheritedObjectType( bstrValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_InheritedObjectType returns %lx\n"), hResult );
         }
         SysFreeString( bstrValue );
         bstrValue   = NULL;
      }


      //******************************************
      hResult  = pSrcACE->get_Trustee( &bstrValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_Trustee( bstrValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_Trustee returns %lx\n"), hResult );
         }
         SysFreeString( bstrValue );
         bstrValue   = NULL;
      }
      hResult  = pACE->QueryInterface( IID_IDispatch, (void**)&pNewACE );
      pACE->Release( );

   }

   pSrcACE->Release( );

   return pNewACE;
}


/******************************************************************************
  Function:    CopyACL
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
IDispatch*  CopyACL( IDispatch*  pSrcACL )
{
   IADsAccessControlList*  pACL        = NULL;
   IADsAccessControlList*  pADsNewACL  = NULL;
   IDispatch*              pNewACL     = NULL;
   IUnknown*               pEnum       = NULL;
   IEnumVARIANT*           pEnumVAR    = NULL;
   HRESULT                 hResult;
   LONG                    lValue;
   ULONG                   lGet;
   VARIANT                 var;

   hResult  = pSrcACL->QueryInterface( IID_IADsAccessControlList, (void**)&pACL );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      hResult  = pACL->CopyAccessList( &pNewACL );
      if( FAILED( hResult ) )
      {
         TRACE( _T("[ADSI] Error: CopyAccessList returns %lx\n"), hResult );
      }

      if( SUCCEEDED( hResult ) )
         break;

      hResult  = CoCreateInstance(
                                   CLSID_AccessControlList,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IADsAccessControlList,
                                   (void **)&pADsNewACL );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pACL->get_AclRevision( &lValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewACL->put_AclRevision( lValue );
         ASSERT( SUCCEEDED( hResult ) );
      }

      hResult  = pACL->get__NewEnum( &pEnum );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pEnum->QueryInterface( IID_IEnumVARIANT, (void**)&pEnumVAR );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      while( TRUE )
      {
         lGet  = 0;
         VariantInit( &var );

         hResult  = pEnumVAR->Next( 1, &var,  &lGet );
         if( 0 == lGet )
            break;

         hResult  = pADsNewACL->AddAce( CopyACE( V_DISPATCH( &var ) ) );
         VariantClear( &var );
      }

      hResult  = pADsNewACL->QueryInterface( IID_IDispatch, (void**)& pNewACL );
      break;
   }

   if( NULL != pACL )
      pACL->Release( );

   if( NULL != pADsNewACL )
      pADsNewACL->Release( );

   if( NULL != pEnum )
      pEnum->Release( );

   if( NULL != pEnumVAR )
      pEnumVAR->Release( );

   return pNewACL;
}


/******************************************************************************
  Function:    CopySD
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
IDispatch*  CopySD( IDispatch*  pSrcSD )
{
   IADsSecurityDescriptor* pSD;
   IDispatch*              pNewSD  = NULL;
   IADsSecurityDescriptor* pADsNewSD  = NULL;
   HRESULT                 hResult;
   LONG                    lValue;
   BSTR                    bstrValue;
   IDispatch*              pACL;

   //hResult  = pSrcSD->QueryInterface( IID_IDispatch, (void**)&pNewSD );

   //return pNewSD;

   hResult  = pSrcSD->QueryInterface( IID_IADsSecurityDescriptor, (void**)&pSD );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      hResult  = pSD->CopySecurityDescriptor( &pNewSD );
      if( FAILED( hResult ) )
      {
         TRACE( _T("[ADSI] Error: CopySecurityDescriptor returns %lx\n"), hResult );
      }

      if( SUCCEEDED( hResult ) )
      {
         pSD->Release( );
         break;
      }

      hResult  = CoCreateInstance(
                                   CLSID_SecurityDescriptor,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IADsSecurityDescriptor,
                                   (void **)&pADsNewSD );

      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      hResult  = pSD->get_Revision( &lValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewSD->put_Revision( lValue );
         ASSERT( SUCCEEDED( hResult ) );
      }

      hResult  = pSD->get_Control( &lValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewSD->put_Control( lValue );
         ASSERT( SUCCEEDED( hResult ) );
      }

      hResult  = pSD->get_Owner( &bstrValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewSD->put_Owner( bstrValue );
         ASSERT( SUCCEEDED( hResult ) );
         SysFreeString( bstrValue );
      }

      hResult  = pSD->get_Group( &bstrValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewSD->put_Group( bstrValue );
         ASSERT( SUCCEEDED( hResult ) );
         SysFreeString( bstrValue );
      }

      hResult  = pSD->get_DiscretionaryAcl( &pACL );
      if( SUCCEEDED( hResult ) && NULL != pACL )
      {
         IDispatch*  pCopy;

         pCopy = CopyACL( pACL );
         if( NULL != pCopy )
         {
            hResult  = pADsNewSD->put_DiscretionaryAcl( pCopy );
            ASSERT( SUCCEEDED( hResult ) );
            pCopy->Release( );
         }
         pACL->Release( );
      }

      hResult  = pSD->get_SystemAcl( &pACL );
      if( SUCCEEDED( hResult ) && NULL != pACL )
      {
         IDispatch*  pCopy;

         pCopy = CopyACL( pACL );
         if( NULL != pCopy )
         {
            hResult  = pADsNewSD->put_SystemAcl( pCopy );
            ASSERT( SUCCEEDED( hResult ) );
            pCopy->Release( );
         }
         pACL->Release( );
      }

      hResult  = pADsNewSD->QueryInterface( IID_IDispatch, (void**)&pNewSD );
      ASSERT( SUCCEEDED( hResult ) );

      pADsNewSD->Release( );

      break;
   }

   return pNewSD;
}

/******************************************************************************
  Function:    ConvertFromPropertyValue
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
BOOL  ConvertFromPropertyValue( VARIANT& rVar, TCHAR* szText )
{
   IADsPropertyValue*   pPropValue  = NULL;
   HRESULT              hResult;
   long                 lType;
   BSTR                 bstrVal = NULL;

   if( VT_DISPATCH != V_VT(&rVar ) )
      return FALSE;

   hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsPropertyValue, (void**)&pPropValue );
   if( FAILED( hResult ) )
      return FALSE;

   while( TRUE )
   {
      hResult  = pPropValue->get_ADsType( &lType );
      if( FAILED( hResult ) )
         break;

      switch( (ADSTYPEENUM)lType )
      {
         case  ADSTYPE_DN_STRING:
         {
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_DNString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_CaseExactString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_CaseExactString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_CASE_EXACT_STRING:
         {
            hResult  = pPropValue->get_CaseExactString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_CaseExactString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_DNString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_CASE_IGNORE_STRING:
         {
            hResult  = pPropValue->get_CaseIgnoreString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_CaseIgnoreString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_DNString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_PRINTABLE_STRING:
         {
            hResult  = pPropValue->get_PrintableString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_PrintableString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_DNString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_NUMERIC_STRING:
         {
            hResult  = pPropValue->get_NumericString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_NumericString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_DNString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_BOOLEAN:
         {
            long  lValue;

            hResult  = pPropValue->get_Boolean( &lValue );
            if( SUCCEEDED( hResult ) )
            {
               _ltot( lValue, szText, 10 );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_Boolean returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_Integer( &lValue );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_Integer should fail\n") );
            }

            break;
         }


         default:
            ASSERT( FALSE );
            break;
      }

      break;
   }

   pPropValue->Release( );

   return TRUE;
}


/******************************************************************************
  Function:    PurgeObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT  PurgeObject( IADsContainer* pParent, IUnknown* pIUnknown, LPWSTR pszPrefix )
{
   BSTR              bstrName       = NULL;
   BSTR              bstrClass      = NULL;
   VARIANT           var;
   HRESULT           hResult;
   IUnknown*         pIChildUnk     = NULL;
   IADs*             pIChildOleDs   = NULL;
   IADs*             pADs;
   BSTR              bstrObjName, bstrObjClass;
   IEnumVARIANT*     pIEnumVar   = NULL;
   IADsContainer*    pIContainer = NULL;
   ULONG             ulFetch     = 0L;
   //BOOL              bDelete;

   if( NULL == pParent || NULL == pIUnknown )
      return FALSE;

   hResult  = pIUnknown->QueryInterface( IID_IADs,
                                         (void**)&pADs );
   if( FAILED( hResult ) )
      return FALSE;

   pADs->get_Name( &bstrObjName );
   pADs->get_Class( &bstrObjClass );
   pADs->Release( );


   hResult  = pIUnknown->QueryInterface( IID_IADsContainer,
                                         (void**)&pIContainer );
   if( FAILED( hResult ) )
   {
      if( NULL != pszPrefix && !_wcsnicmp( bstrObjName, pszPrefix, wcslen(pszPrefix) ) )
      {
         hResult  = pParent->Delete( bstrObjClass, bstrObjName );
         TRACE( _T("Delete %S returns %lx\n"), bstrObjName, hResult );
      }
      if( NULL == pszPrefix )
      {
         hResult  = pParent->Delete( bstrObjClass, bstrObjName );
         TRACE( _T("Delete %S returns %lx\n"), bstrObjName, hResult );
      }

      SysFreeString( bstrObjClass );
      SysFreeString( bstrObjName );
      return S_OK;
   }


   hResult  = ADsBuildEnumerator( pIContainer, &pIEnumVar );

   while( SUCCEEDED( hResult ) )
   {
      ulFetch  = 0L;

      hResult  = ADsEnumerateNext( pIEnumVar, 1, &var, &ulFetch );
      if( FAILED( hResult ) )
         continue;

      if( !ulFetch )
         break;

      V_DISPATCH( &var )->QueryInterface( IID_IUnknown, (void**)&pIChildUnk );

      VariantClear( &var );

      if( NULL != pIChildUnk )
      {
         PurgeObject( pIContainer, pIChildUnk, pszPrefix );
         pIChildUnk->Release( );
      }
      pIChildUnk  = NULL;
   }

   if( NULL != pIEnumVar )
   {
      ADsFreeEnumerator( pIEnumVar );
   }
   pIContainer->Release( );

   hResult  = pParent->Delete( bstrObjClass, bstrObjName );

   TRACE( _T("\tDelete %S (%S) ends with %lx\n"), bstrObjName, bstrObjClass );

   SysFreeString( bstrObjClass );
   SysFreeString( bstrObjName );

   return hResult;
}


/******************************************************************************
  Function:    Bolb2String
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
CString  Blob2String( void* pData, DWORD dwSize )
{
   DWORD    dwIdx;
   TCHAR*   pText;
   BYTE*    pByte = (BYTE*)pData;
   CString  strText;

   pText = (TCHAR*)AllocADsMem( 1 + dwSize * 3 * sizeof( TCHAR ) );
   memset( pText, 0, 1 + dwSize * 3 * sizeof( TCHAR ) );


   for( dwIdx = 0; dwIdx < dwSize ; dwIdx++ )
   {
      _stprintf( pText + _tcslen(pText),
                 _T("%02x"),
                 ((BYTE*)pData)[ dwIdx ] );
   }

   strText  = pText;
   FreeADsMem( pText );

   return strText;
}


/******************************************************************************
  Function:    String2Blob
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT  String2Blob( TCHAR* pszText, void** ppData, DWORD* pdwLength )
{
   HRESULT     hResult;
   CString     strText;
   VARIANT     vBlob;
   SAFEARRAY*  pSafeArray;
   long        lBound, uBound, lItem;
   BYTE*       pbData;

   strText     = pszText;
   *pdwLength  = 0;

   hResult     = CreateBlobArray( strText, vBlob );
   if( FAILED( hResult ) )
   {
      return hResult;
   }

   pSafeArray  = V_ARRAY( &vBlob );

   hResult     = SafeArrayGetLBound(pSafeArray, 1, &lBound);
   hResult     = SafeArrayGetUBound(pSafeArray, 1, &uBound);
   *pdwLength  = (uBound - lBound + 1);

   pbData      = (BYTE*) AllocADsMem( sizeof(BYTE) * (uBound - lBound + 1) );

   for( lItem = lBound; lItem <= uBound ; lItem++ )
   {
      hResult  = SafeArrayGetElement( pSafeArray,
                                      &lItem,
                                      pbData + (lItem - lBound) );
      if( FAILED( hResult ) )
      {
         ASSERT( FALSE );
         break;
      }
   }

   *ppData  = (void*)pbData;

   return hResult;
}


/******************************************************************************
  Function:    AllocTCHAR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
TCHAR*   AllocTCHAR ( CHAR* pszText )
{
   TCHAR*   pszAlloc = NULL;

   while( TRUE )
   {
      ASSERT( NULL != pszText );
      if( NULL == pszText )
         break;

      pszAlloc = (TCHAR*) AllocADsMem( sizeof(TCHAR)*(strlen(pszText) + 1) );
      if( NULL == pszAlloc )
         break;

      Convert( pszAlloc, pszText );
      break;
   }

   return pszAlloc;
}



/******************************************************************************
  Function:    AllocTCHAR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
WCHAR*   AllocWCHAR ( CHAR* pszText )
{
   WCHAR*   pszAlloc = NULL;

   while( TRUE )
   {
      ASSERT( NULL != pszText );
      if( NULL == pszText )
         break;

      pszAlloc = (WCHAR*) AllocADsMem( sizeof(WCHAR)*(strlen(pszText) + 1) );
      if( NULL == pszAlloc )
         break;

      Convert( pszAlloc, pszText );
      break;
   }

   return pszAlloc;
}


/******************************************************************************
  Function:    AllocTCHAR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
TCHAR*   AllocTCHAR( WCHAR* pszText )
{
   TCHAR*   pszAlloc = NULL;

   while( TRUE )
   {
      ASSERT( NULL != pszText );
      if( NULL == pszText )
         break;

      pszAlloc = (TCHAR*) AllocADsMem( sizeof(TCHAR)*(wcslen(pszText) + 1) );
      if( NULL == pszAlloc )
         break;

      Convert( pszAlloc, pszText );
      break;
   }

   return pszAlloc;
}

/******************************************************************************
  Function:    AllocTCHAR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
WCHAR*   AllocWCHAR( WCHAR* pszText )
{
   WCHAR*   pszAlloc = NULL;

   while( TRUE )
   {
      ASSERT( NULL != pszText );
      if( NULL == pszText )
         break;

      pszAlloc = (WCHAR*) AllocADsMem( sizeof(WCHAR)*(wcslen(pszText) + 1) );
      if( NULL == pszAlloc )
         break;

      Convert( pszAlloc, pszText );
      break;
   }

   return pszAlloc;
}


/*****************************************************************************
  Function:    GetVARIANTSize
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
long  GetVARIANTSize( VARIANT &rVar )
{
   SAFEARRAY      *psa = NULL;
   HRESULT        hResult;
   long           lLow, lUp;

   ASSERT( VT_ARRAY & V_VT( &rVar ) );

   if( !( VT_ARRAY & V_VT( &rVar ) ) )
      return -1;

   psa   = V_ARRAY(&rVar);

   if( NULL == psa )
      return 0;

   hResult  = SafeArrayGetLBound( psa, 1, &lLow );
   hResult  = SafeArrayGetUBound( psa, 1, &lUp );

   return (lUp - lLow + 1);
}

/*****************************************************************************
  Function:    GetVARIANTAt
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT  GetVARIANTAt( long lIdx, VARIANT& vArray, VARIANT &vItem )
{
   SAFEARRAY      *psa = NULL;
   HRESULT        hResult;
   long           lLow, lUp, lPos;

   if( !( VT_ARRAY & V_VT( &vArray ) ) )
      return E_FAIL;

   psa   = V_ARRAY(&vArray);

   if( NULL == psa )
      return E_FAIL;

   VariantInit( &vItem );

   hResult  = SafeArrayGetLBound( psa, 1, &lLow );
   hResult  = SafeArrayGetUBound( psa, 1, &lUp );

   lPos     = lLow + lIdx;
   hResult  = SafeArrayGetElement( psa, &lPos, &vItem );

   return hResult;
}


/******************************************************************************
  Function:    GetValuesCount
  Arguments:   szText   - ptr to TCHAR string to be "tokanized"
               cSep     - Token separator
  Return:      number of tokens in szText (cSep being the token separator)
  Purpose:     The method id used to parse strings. The most common usage is for
               a string containing multiple values.
  Author(s):   cezaru
  Revision:    1
  Date:        08/10/97
******************************************************************************/
long  GetValuesCount( CString& szText, TCHAR cSep  )
{
   int   nIter;
   long  lCount   = 0;

   for( nIter = 0; nIter < szText.GetLength( ) ; nIter++ )
   {
      if( cSep == szText.GetAt( nIter ) )
         lCount++;
   }

   return ++lCount;
}


/******************************************************************************
  Function:    GetElements
  Arguments:   szText   string to be parsed
               cSep     token separator character
               lValues  tokens count
  Return:      an array of strings, each string being a token
  Purpose:     breaks a string into multiple tokens
  Author(s):   cezaru
  Revision:    1
  Date:        08/10/97
******************************************************************************/
CString GetValueAt( CString& szText, TCHAR cSep, long lValue )
{
   TCHAR*  pszString;
   long    lIter, lPos, lVal, lLength;
   TCHAR*  pszTemp;
   CString  strRes;

   if( lValue >=  GetValuesCount( szText, cSep ) )
      return _T("");

   lIter = 0;
   lPos  = 0;
   lLength     = sizeof(TCHAR) * ( 1 + szText.GetLength( ) );
   pszTemp     = (TCHAR*)  AllocADsMem( lLength );

   pszString   = (TCHAR*) AllocADsMem( lLength );


   while( lIter < lValue )
   {
      if( szText.GetAt( lPos++ ) == cSep )
         lIter++;
   }

   lVal  = 0;

   while( lPos < szText.GetLength( ) && szText.GetAt( lPos ) != cSep )
   {
      pszTemp[ lVal++ ] = szText.GetAt( lPos );
      pszTemp[ lVal ]   = _T('\0');
      lPos++;
   }

   strRes   = pszTemp;

   FreeADsMem( pszTemp );

   return strRes;
}


/******************************************************************************
  Function:    CreateLargeInteger
  Arguments:
  Return:
  Purpose:
  Author(s):   cezaru
  Revision:    1
  Date:        08/10/97
******************************************************************************/
IDispatch* CreateLargeInteger( CString& strText )
{
   LARGE_INTEGER     aLargeInteger;
   IADsLargeInteger* pLInt = NULL;
   IDispatch*        pDisp = NULL;
   HRESULT           hResult;


   while( TRUE )
   {
      hResult  = StringToLARGE_INTEGER( strText.GetBuffer( 128 ), &aLargeInteger );

      hResult = CoCreateInstance(
                               CLSID_LargeInteger,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IADsLargeInteger,
                               (void **)&pLInt );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         TRACE( "\tERROR: CoCreateInstance(CLSID_LargeInteger,...) fails with %lx\n", hResult );
         break;
      }

      pLInt->put_HighPart( (LONG)aLargeInteger.HighPart );
      pLInt->put_LowPart(  (LONG)aLargeInteger.LowPart );

      hResult  = pLInt->QueryInterface( IID_IDispatch, (void**)&pDisp );

      pLInt->Release( );
      break;
   }

   return pDisp;
}



/******************************************************************************
  Function:    FromLargeInteger
  Arguments:
  Return:
  Purpose:
  Author(s):   cezaru
  Revision:    1
  Date:        08/10/97
******************************************************************************/
CString FromLargeInteger( IDispatch* pDisp )
{
   LARGE_INTEGER     aLargeInteger;
   IADsLargeInteger* pLInt = NULL;
   HRESULT           hResult;
   TCHAR             szText[ 128 ];

   _tcscpy( szText, _T("") );

   while( TRUE )
   {
      hResult  = pDisp->QueryInterface( IID_IADsLargeInteger, (void**)&pLInt );
      if( FAILED( hResult ) )
         break;

      hResult  = pLInt->get_HighPart( &aLargeInteger.HighPart );
      hResult  = pLInt->get_LowPart( (long*) &aLargeInteger.LowPart );
      pLInt->Release( );

      hResult  = LARGE_INTEGERToString( szText, &aLargeInteger );
      break;
   }

   return szText;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\adsrc.h ===
#ifndef __ADSRC_H__
#define __ADSRC_H__

#define ADS_BUILTIN             500000
#define ADS_NT_AUTHORITY        500001
#define ADS_ACCOUNT_OPERATORS   500002
#define ADS_PRINT_OPERATORS     500003
#define ADS_BACKUP_OPERATORS    500004
#define ADS_SERVER_OPERATORS    500005
#define ADS_PRE_WIN2000         500006

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\oledsvw\viewex.h ===
// viewex.h : main header file for the VIEWEX application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#if !defined(__AFXWIN_H__) || !defined(__AFXEXT_H__)
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#include "maindoc.h"        // main document data
#include "simpvw.h"         // simple read-only view
#include "inputvw.h"        // editable view

/////////////////////////////////////////////////////////////////////////////
// CViewExApp:
// See viewex.cpp for the implementation of this class
//

class CViewExApp : public CWinApp
{
public:
	int ExitInstance( void );
	CViewExApp();
   ~CViewExApp();

// Overrides
	virtual BOOL InitInstance();

// Implementation

	//{{AFX_MSG(CViewExApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class foo  
{
public:
	foo();
	virtual ~foo();

};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\acledit.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Acledit.c

Abstract:

    This Module implements the Acl rtl editing functions that are defined in
    ntseapi.h

Author:

    Gary Kimura     (GaryKi)    9-Nov-1989

Environment:

    Pure Runtime Library Routine

Revision History:

--*/

#include "oleds.hxx"
#pragma hdrstop

#include "seopaque.h"

//
// This is used to determine if we are going to call our private
// security API's (ADSIRtlFucntions) or if we should use the standard
// Win32 API's. By default we will assume we are running on Win2k+
// Win9x is not an issue for this as there is no sec api support.
//
BOOL g_fPlatformNotNT4 = TRUE;
BOOL g_fPlatformDetermined = FALSE;

//
// Helper routine that updates the g_fPlatformNotNt4 variable
// to the correct value.
//
void 
UpdatePlatformInfo()
{
    DWORD dwError;
    OSVERSIONINFO osVerInfo;

    //
    // Needed for the GetVersionEx call.
    //
    osVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&osVerInfo)) {
        //
        // Call failed, so we will default to Win2k
        //
        g_fPlatformNotNT4 = TRUE;
    }
    else {
        //
        // !(is this NT4).
        //
        g_fPlatformNotNT4 = 
            ! ((osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) 
              && (osVerInfo.dwMajorVersion == 4));
    }

    g_fPlatformDetermined = TRUE;
    return;
}

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    );

//
//  Define the local macros and procedure for this module
//

//
//  Return a pointer to the first Ace in an Acl (even if the Acl is empty).
//
//      PACE_HEADER
//      FirstAce (
//          IN PACL Acl
//          );
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Return a pointer to the next Ace in a sequence (even if the input
//  Ace is the one in the sequence).
//
//      PACE_HEADER
//      NextAce (
//          IN PACE_HEADER Ace
//          );
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

#define LongAligned( ptr )  (LongAlign(ptr) == ((PVOID)(ptr)))
#define WordAligned( ptr )  (WordAlign(ptr) == ((PVOID)(ptr)))


//++
//
//  ULONG
//  SeLengthSid(
//      IN PSID Sid
//      );
//
//  Routine Description:
//
//      This routine computes the length of a SID.
//
//  Arguments:
//
//      Sid - Points to the SID whose length is to be returned.
//
//  Return Value:
//
//      The length, in bytes of the SID.
//
//--

#define SeLengthSid( Sid ) \
    (8 + (4 * ((SID *)Sid)->SubAuthorityCount))


VOID
ADSIRtlpAddData (
    IN PVOID From,
    IN ULONG FromSize,
    IN PVOID To,
    IN ULONG ToSize
    );

VOID
ADSIRtlpDeleteData (
    IN PVOID Data,
    IN ULONG RemoveSize,
    IN ULONG TotalSize
    );



NTSTATUS
ADSIRtlCreateAcl (
    IN PACL Acl,
    IN ULONG AclLength,
    IN ULONG AclRevision
    )

/*++

Routine Description:

    This routine initializes an ACL data structure.  After initialization
    it is an ACL with no ACE (i.e., a deny all access type ACL)

Arguments:

    Acl - Supplies the buffer containing the ACL being initialized

    AclLength - Supplies the length of the ace buffer in bytes

    AclRevision - Supplies the revision for this Acl

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful

               STATUS_BUFFER_TOO_SMALL if the AclLength is too small,

               STATUS_INVALID_PARAMETER if the revision is out of range

--*/

{

    //
    //  Check to see the size of the buffer is large enough to hold at
    //  least the ACL header
    //

    if (AclLength < sizeof(ACL)) {

        //
        //  Buffer to small even for the ACL header
        //

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  Check to see if the revision is currently valid.  Later versions
    //  of this procedure might accept more revision levels
    //

    if (AclRevision < MIN_ACL_REVISION || AclRevision > MAX_ACL_REVISION) {

        //
        //  Revision not current
        //

        return STATUS_INVALID_PARAMETER;

    }

    if ( AclLength > MAXUSHORT ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Initialize the ACL
    //

    Acl->AclRevision = (UCHAR)AclRevision;  // Used to hardwire ACL_REVISION2 here
    Acl->Sbz1 = 0;
    Acl->AclSize = (USHORT) (AclLength & 0xfffc);
    Acl->AceCount = 0;
    Acl->Sbz2 = 0;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


BOOLEAN
ADSIRtlValidAcl (
    IN PACL Acl
    )

/*++

Routine Description:

    This procedure validates an ACL.

    This involves validating the revision level of the ACL and ensuring
    that the number of ACEs specified in the AceCount fit in the space
    specified by the AclSize field of the ACL header.

Arguments:

    Acl - Pointer to the ACL structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Acl is valid.

--*/

{
    PACE_HEADER Ace;
    PISID Sid;
    PISID Sid2;
    ULONG i;
    UCHAR AclRevision = ACL_REVISION2;


    //
    //  Check the ACL revision level
    //
    if (!ValidAclRevision(Acl)) {
        return(FALSE);
    }


    if (!LongAligned(Acl->AclSize)) {
        return(FALSE);
    }

    //
    // Validate all of the ACEs.
    //

    Ace = (PACE_HEADER)((PVOID)((PUCHAR)(Acl) + sizeof(ACL)));

    for (i = 0; i < Acl->AceCount; i++) {

        //
        //  Check to make sure we haven't overrun the Acl buffer
        //  with our ace pointer.  Make sure the ACE_HEADER is in
        //  the ACL also.
        //

        if ((PUCHAR)Ace + sizeof(ACE_HEADER) >= ((PUCHAR)Acl + Acl->AclSize)) {
            return(FALSE);
        }

        if (!WordAligned(&Ace->AceSize)) {
            return(FALSE);
        }

        if ((PUCHAR)Ace + Ace->AceSize > ((PUCHAR)Acl + Acl->AclSize)) {
            return(FALSE);
        }

        //
        // It is now safe to reference fields in the ACE header.
        //

        //
        // The ACE header fits into the ACL, if this is a known type of ACE,
        // make sure the SID is within the bounds of the ACE
        //

        if (IsKnownAceType(Ace)) {

            if (!LongAligned(Ace->AceSize)) {
                return(FALSE);
            }

            if (Ace->AceSize < sizeof(KNOWN_ACE) - sizeof(ULONG) + sizeof(SID)) {
                return(FALSE);
            }

            //
            // It's now safe to reference the parts of the SID structure, though
            // not the SID itself.
            //

            Sid = (PISID) & (((PKNOWN_ACE)Ace)->SidStart);

            if (Sid->Revision != SID_REVISION) {
                return(FALSE);
            }

            if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return(FALSE);
            }

            //
            // SeLengthSid computes the size of the SID based on the subauthority count,
            // so it is safe to use even though we don't know that the body of the SID
            // is safe to reference.
            //

            if (Ace->AceSize < sizeof(KNOWN_ACE) - sizeof(ULONG) + SeLengthSid( Sid )) {
                return(FALSE);
            }


        //
        // If it's a compound ACE, then perform roughly the same set of tests, but
        // check the validity of both SIDs.
        //

        } else if (IsCompoundAceType(Ace)) {

            //
            // Compound ACEs became valid in revision 3
            //
            if ( Acl->AclRevision < ACL_REVISION3 ) {
                return FALSE;
            }

            if (!LongAligned(Ace->AceSize)) {
                return(FALSE);
            }

            if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + sizeof(SID)) {
                return(FALSE);
            }

            //
            // The only currently defined Compound ACE is an Impersonation ACE.
            //

            if (((PKNOWN_COMPOUND_ACE)Ace)->CompoundAceType != COMPOUND_ACE_IMPERSONATION) {
                return(FALSE);
            }

            //
            // Examine the first SID and make sure it's structurally valid,
            // and it lies within the boundaries of the ACE.
            //

            Sid = (PISID) & (((PKNOWN_COMPOUND_ACE)Ace)->SidStart);

            if (Sid->Revision != SID_REVISION) {
                return(FALSE);
            }

            if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return(FALSE);
            }

            //
            // Compound ACEs contain two SIDs.  Make sure this ACE is large enough to contain
            // not only the first SID, but the body of the 2nd.
            //

            if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + SeLengthSid( Sid ) + sizeof(SID)) {
                return(FALSE);
            }

            //
            // It is safe to reference the interior of the 2nd SID.
            //

            Sid2 = (PISID) ((PUCHAR)Sid + SeLengthSid( Sid ));

            if (Sid2->Revision != SID_REVISION) {
                return(FALSE);
            }

            if (Sid2->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return(FALSE);
            }

            if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + SeLengthSid( Sid ) + SeLengthSid( Sid2 )) {
                return(FALSE);
            }


        //
        // If it's an object ACE, then perform roughly the same set of tests.
        //

        } else if (IsObjectAceType(Ace)) {
            ULONG GuidSize=0;

            //
            // Object ACEs became valid in revision 4
            //
            if ( Acl->AclRevision < ACL_REVISION4 ) {
                return FALSE;
            }

            if (!LongAligned(Ace->AceSize)) {
                return(FALSE);
            }

            //
            // Ensure there is room for the ACE header.
            //
            if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG)) {
                return(FALSE);
            }


            //
            // Ensure there is room for the GUIDs and SID header
            //
            if ( RtlObjectAceObjectTypePresent( Ace ) ) {
                GuidSize += sizeof(GUID);
            }

            if ( RtlObjectAceInheritedObjectTypePresent( Ace ) ) {
                GuidSize += sizeof(GUID);
            }

            if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG) + GuidSize + sizeof(SID)) {
                return(FALSE);
            }

            //
            // It's now safe to reference the parts of the SID structure, though
            // not the SID itself.
            //

            Sid = (PISID) RtlObjectAceSid( Ace );

            if (Sid->Revision != SID_REVISION) {
                return(FALSE);
            }

            if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return(FALSE);
            }

            if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG) + GuidSize + SeLengthSid( Sid ) ) {
                return(FALSE);
            }
        }

        //
        //  And move Ace to the next ace position
        //

        Ace = (PACE_HEADER)((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize));
    }

    return(TRUE);

}


NTSTATUS
ADSIRtlQueryInformationAcl (
    IN PACL Acl,
    OUT PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    )

/*++

Routine Description:

    This routine returns to the caller information about an ACL.  The requested
    information can be AclRevisionInformation, or AclSizeInformation.

Arguments:

    Acl - Supplies the Acl being examined

    AclInformation - Supplies the buffer to receive the information being
        requested

    AclInformationLength - Supplies the length of the AclInformation buffer
        in bytes

    AclInformationClass - Supplies the type of information being requested

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PACL_REVISION_INFORMATION RevisionInfo;
    PACL_SIZE_INFORMATION SizeInfo;


    PVOID FirstFree;
    NTSTATUS Status;


    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision( Acl )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Case on the information class being requested
    //

    switch (AclInformationClass) {

    case AclRevisionInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_REVISION_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Get the Acl revision and return
        //

        RevisionInfo = (PACL_REVISION_INFORMATION)AclInformation;
        RevisionInfo->AclRevision = Acl->AclRevision;

        break;

    case AclSizeInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_SIZE_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Locate the first free spot in the Acl
        //

        if (!RtlFirstFreeAce( Acl, &FirstFree )) {

            //
            //  The input Acl is ill-formed
            //

            return STATUS_INVALID_PARAMETER;

        }

        //
        //  Given a pointer to the first free spot we can now easily compute
        //  the number of free bytes and used bytes in the Acl.
        //

        SizeInfo = (PACL_SIZE_INFORMATION)AclInformation;
        SizeInfo->AceCount = Acl->AceCount;

        if (FirstFree == NULL) {

            //
            //  With a null first free we don't have any free space in the Acl
            //

            SizeInfo->AclBytesInUse = Acl->AclSize;

            SizeInfo->AclBytesFree = 0;

        } else {

            //
            //  The first free is not null so we have some free room left in
            //  the acl
            //

            SizeInfo->AclBytesInUse = (ULONG)((PUCHAR)FirstFree - (PUCHAR)Acl);

            SizeInfo->AclBytesFree = Acl->AclSize - SizeInfo->AclBytesInUse;

        }

        break;

    default:

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ADSIRtlSetInformationAcl (
    IN PACL Acl,
    IN PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    )

/*++

Routine Description:

    This routine sets the state of an ACL.  For now only the revision
    level can be set and for now only a revision level of 1 is accepted
    so this procedure is rather simple

Arguments:

    Acl - Supplies the Acl being altered

    AclInformation - Supplies the buffer containing the information being
        set

    AclInformationLength - Supplies the length of the Acl information buffer

    AclInformationClass - Supplies the type of information begin set

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PACL_REVISION_INFORMATION RevisionInfo;


    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision( Acl )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Case on the information class being requested
    //

    switch (AclInformationClass) {

    case AclRevisionInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_REVISION_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Get the Acl requested ACL revision level
        //

        RevisionInfo = (PACL_REVISION_INFORMATION)AclInformation;

        //
        //  Don't let them lower the revision of an ACL.
        //

        if (RevisionInfo->AclRevision < Acl->AclRevision ) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Assign the new revision.
        //

        Acl->AclRevision = (UCHAR)RevisionInfo->AclRevision;

        break;

    default:

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ADSIRtlAddAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG StartingAceIndex,
    IN PVOID AceList,
    IN ULONG AceListLength
    )

/*++

Routine Description:

    This routine adds a string of ACEs to an ACL.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    StartingAceIndex - Supplies the ACE index which will be the index of
        the first ace inserted in the acl. 0 for the beginning of the list
        and MAXULONG for the end of the list.

    AceList - Supplies the list of Aces to be added to the Acl

    AceListLength - Supplies the size, in bytes, of the AceList buffer

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful, and an appropriate error
        status otherwise

--*/

{
    PVOID FirstFree;

    PACE_HEADER Ace;
    ULONG NewAceCount;

    PVOID AcePosition;
    ULONG i;
    UCHAR NewRevision;


    //
    //  Check the ACL structure
    //

    if (!ADSIRtlValidAcl(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // If the AceRevision is greater than the ACL revision, then we want to
    // increase the ACL revision to be the same as the new ACE revision.
    // We can do this because our previously defined ACE types ( 0 -> 3 ) have
    // not changed structure nor been discontinued in the new revision.  So
    // we can bump the revision and the older types will not be misinterpreted.
    //
    // Compute what the final revision of the ACL is going to be, and save it
    // for later so we can update it once we know we're going to succeed.
    //

    NewRevision = (UCHAR)AceRevision > Acl->AclRevision ? (UCHAR)AceRevision : Acl->AclRevision;

    //
    // Check that the AceList is well formed, we do this by simply zooming
    // down the Ace list until we're equal to or have exceeded the ace list
    // length.  If we are equal to the length then we're well formed otherwise
    // we're ill-formed.  We'll also calculate how many Ace's there are
    // in the AceList
    //
    // In addition, now we have to make sure that we haven't been handed an
    // ACE type that is inappropriate for the AceRevision that was passed
    // in.
    //

    for (Ace = (PACE_HEADER)AceList, NewAceCount = 0;
         Ace < (PACE_HEADER)((PUCHAR)AceList + AceListLength);
         Ace = (PACE_HEADER)NextAce( Ace ), NewAceCount++) {

        //
        // Ensure the ACL revision allows this ACE type.
        //

        if ( Ace->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE ) {
            // V2 ACE are always valid.
        } else if ( Ace->AceType <= ACCESS_MAX_MS_V3_ACE_TYPE ) {
            if ( AceRevision < ACL_REVISION3 ) {
                return STATUS_INVALID_PARAMETER;
            }
        } else if ( Ace->AceType <= ACCESS_MAX_MS_V4_ACE_TYPE ) {
            if ( AceRevision < ACL_REVISION4 ) {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    //  Check to see if we've exceeded the ace list length
    //

    if (Ace > (PACE_HEADER)((PUCHAR)AceList + AceListLength)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Check to see if there is enough room in the Acl to store the additional
    //  Ace list
    //

    if (FirstFree == NULL ||
        (PUCHAR)FirstFree + AceListLength > (PUCHAR)Acl + Acl->AclSize) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  All of the input has checked okay, we now need to locate the position
    //  where to insert the new ace list.  We won't check the acl for
    //  validity because we did earlier when got the first free ace position.
    //

    AcePosition = FirstAce( Acl );

    for (i = 0; i < StartingAceIndex && i < Acl->AceCount; i++) {

        AcePosition = NextAce( AcePosition );

    }

    //
    //  Now Ace points to where we want to insert the ace list,  We do the
    //  insertion by adding ace list to the acl and shoving over the remainder
    //  of the list down the acl.  We know this will work because we earlier
    //  check to make sure the new acl list will fit in the acl size
    //

    ADSIRtlpAddData( AceList, AceListLength,
             AcePosition, (ULONG)((PUCHAR)FirstFree - (PUCHAR)AcePosition));

    //
    //  Update the Acl Header
    //

    Acl->AceCount = (USHORT)(Acl->AceCount + NewAceCount);

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ADSIRtlDeleteAce (
    IN OUT PACL Acl,
    IN ULONG AceIndex
    )

/*++

Routine Description:

    This routine deletes one ACE from an ACL.

Arguments:

    Acl - Supplies the Acl being modified

    AceIndex - Supplies the index of the Ace to delete.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PVOID FirstFree;

    PACE_HEADER Ace;
    ULONG i;


    //
    //  Check the ACL structure
    //

    if (!ADSIRtlValidAcl(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Make sure the AceIndex is within proper range, it's ulong so we know
    //  it can't be negative
    //

    if (AceIndex >= Acl->AceCount) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Locate the first free spot, this will tell us how much data
    //  we'll need to colapse.  If the results is false then the acl is
    //  ill-formed
    //

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Now locate the ace that we're going to delete.  This loop
    //  doesn't need to check the acl for being well formed.
    //

    Ace = (PACE_HEADER)FirstAce( Acl );

    for (i = 0; i < AceIndex; i++) {

        Ace = (PACE_HEADER)NextAce( Ace );

    }

    //
    //  We've found the ace to delete to simply copy over the rest of
    //  the acl over this ace.  The delete data procedure also deletes
    //  rest of the string that it's moving over so we don't have to
    //

    ADSIRtlpDeleteData( Ace, Ace->AceSize, (ULONG)((PUCHAR)FirstFree - (PUCHAR)Ace));

    //
    //  Update the Acl header
    //

    Acl->AceCount--;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ADSIRtlGetAce (
    IN PACL Acl,
    ULONG AceIndex,
    OUT PVOID *Ace
    )

/*++

Routine Description:

    This routine returns a pointer to an ACE in an ACl referenced by
    ACE index

Arguments:

    Acl - Supplies the ACL being queried

    AceIndex - Supplies the Ace index to locate

    Ace - Receives the address of the ACE within the ACL

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    ULONG i;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return GetAce(Acl, AceIndex, Ace);
    }   

    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Check the AceIndex against the Ace count of the Acl, it's ulong so
    //  we know it can't be negative
    //

    if (AceIndex >= Acl->AceCount) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  To find the Ace requested by zooming down the Ace List.
    //

    *Ace = FirstAce( Acl );

    for (i = 0; i < AceIndex; i++) {

        //
        //  Check to make sure we haven't overrun the Acl buffer
        //  with our ace pointer.  If we have then our input is bogus
        //

        if (*Ace >= (PVOID)((PUCHAR)Acl + Acl->AclSize)) {

            return STATUS_INVALID_PARAMETER;

        }

        //
        //  And move Ace to the next ace position
        //

        *Ace = NextAce( *Ace );

    }

    //
    //  Now Ace points to the Ace we're after, but make sure we aren't
    //  beyond the Acl.
    //

    if (*Ace >= (PVOID)((PUCHAR)Acl + Acl->AclSize)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  The Ace is still within the Acl so return success to our caller
    //

    return STATUS_SUCCESS;

}



BOOL
ADSIIsValidAcl (
    PACL pAcl
    )
/*++

Routine Description:

    This procedure validates an ACL.

    This involves validating the revision level of the ACL and ensuring
    that the number of ACEs specified in the AceCount fit in the space
    specified by the AclSize field of the ACL header.

Arguments:

    pAcl - Pointer to the ACL structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Acl is valid.


--*/
{
    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return IsValidAcl(pAcl);
    }
    return (BOOL) ADSIRtlValidAcl (
                    pAcl
                    );
}


BOOL
ADSIInitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    )
/*++

Routine Description:

    InitializeAcl creates a new ACL in the caller supplied memory
    buffer.  The ACL contains zero ACEs; therefore, it is an empty ACL
    as opposed to a nonexistent ACL.  That is, if the ACL is now set
    to an object it will implicitly deny access to everyone.

Arguments:

    pAcl - Supplies the buffer containing the ACL being initialized

    nAclLength - Supplies the length of the ace buffer in bytes

    dwAclRevision - Supplies the revision for this Acl

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return InitializeAcl(pAcl, nAclLength, dwAclRevision);
    }

    Status = ADSIRtlCreateAcl (
                pAcl,
                nAclLength,
                dwAclRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
ADSIGetAclInformation (
    PACL pAcl,
    PVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    )
/*++

Routine Description:

    This routine returns to the caller information about an ACL.  The requested
    information can be AclRevisionInformation, or AclSizeInformation.

Arguments:

    pAcl - Supplies the Acl being examined

    pAclInformation - Supplies the buffer to receive the information
        being requested

    nAclInformationLength - Supplies the length of the AclInformation
        buffer in bytes

    dwAclInformationClass - Supplies the type of information being
        requested

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return GetAclInformation(
                   pAcl,
                   pAclInformation,
                   nAclInformationLength,
                   dwAclInformationClass
                   );
    }

    Status = ADSIRtlQueryInformationAcl (
                pAcl,
                pAclInformation,
                nAclInformationLength,
                dwAclInformationClass
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
ADSISetAclInformation (
    PACL pAcl,
    PVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    )
/*++

Routine Description:

    This routine sets the state of an ACL.  For now only the revision
    level can be set and for now only a revision level of 1 is accepted
    so this procedure is rather simple

Arguments:

    pAcl - Supplies the Acl being altered

    pAclInformation - Supplies the buffer containing the information
        being set

    nAclInformationLength - Supplies the length of the Acl information
        buffer

    dwAclInformationClass - Supplies the type of information begin set

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    
    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return SetAclInformation(
                   pAcl,
                   pAclInformation,
                   nAclInformationLength,
                   dwAclInformationClass
                   );
    }

    Status = ADSIRtlSetInformationAcl (
                pAcl,
                pAclInformation,
                nAclInformationLength,
                dwAclInformationClass
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
ADSIAddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    PVOID pAceList,
    DWORD nAceListLength
    )
/*++

Routine Description:

    This routine adds a string of ACEs to an ACL.

Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being
        added

    dwStartingAceIndex - Supplies the ACE index which will be the
        index of the first ace inserted in the acl.  0 for the
        beginning of the list and MAXULONG for the end of the list.

    pAceList - Supplies the list of Aces to be added to the Acl

    nAceListLength - Supplies the size, in bytes, of the AceList
        buffer

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return AddAce( 
                   pAcl,
                   dwAceRevision,
                   dwStartingAceIndex,
                   pAceList,
                   nAceListLength
                   );
    }

    Status = ADSIRtlAddAce (
        pAcl,
        dwAceRevision,
        dwStartingAceIndex,
        pAceList,
        nAceListLength
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
ADSIDeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    )
/*++

Routine Description:

    This routine deletes one ACE from an ACL.

Arguments:

    pAcl - Supplies the Acl being modified

    dwAceIndex - Supplies the index of the Ace to delete.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return DeleteAce(pAcl, dwAceIndex);
    }

    Status = ADSIRtlDeleteAce (
                pAcl,
                dwAceIndex
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
ADSIGetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    PVOID *pAce
    )
/*++

Routine Description:

    This routine returns a pointer to an ACE in an ACl referenced by
    ACE index

Arguments:

    pAcl - Supplies the ACL being queried

    dwAceIndex - Supplies the Ace index to locate

    pAce - Receives the address of the ACE within the ACL

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = ADSIRtlGetAce (
                pAcl,
                dwAceIndex,
                pAce
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



//
//  Internal support routine
//

VOID
ADSIRtlpAddData (
    IN PVOID From,
    IN ULONG FromSize,
    IN PVOID To,
    IN ULONG ToSize
    )

/*++

Routine Description:

    This routine copies data to a string of bytes.  It does this by moving
    over data in the to string so that the from string will fit.  It also
    assumes that the checks that the data will fit in memory have already
    been done.  Pictorally the results are as follows.

    Before:

        From -> ffffffffff

        To   -> tttttttttttttttt

    After:

        From -> ffffffffff

        To   -> fffffffffftttttttttttttttt

Arguments:

    From - Supplies a pointer to the source buffer

    FromSize - Supplies the size of the from buffer in bytes

    To - Supplies a pointer to the destination buffer

    ToSize - Supplies the size of the to buffer in bytes

Return Value:

    None

--*/

{
    LONG i;

    //
    //  Shift over the To buffer enough to fit in the From buffer
    //

    for (i = ToSize - 1; i >= 0; i--) {

        ((PUCHAR)To)[i+FromSize] = ((PUCHAR)To)[i];
    }

    //
    //  Now copy over the From buffer
    //

    for (i = 0; (ULONG)i < FromSize; i += 1) {

        ((PUCHAR)To)[i] = ((PUCHAR)From)[i];

    }

    //
    //  and return to our caller
    //

    return;

}


//
//  Internal support routine
//

VOID
ADSIRtlpDeleteData (
    IN PVOID Data,
    IN ULONG RemoveSize,
    IN ULONG TotalSize
    )

/*++

Routine Description:

    This routine deletes a string of bytes from the front of a data buffer
    and compresses the data.  It also zeros out the part of the string
    that is no longer in use.  Pictorially the results are as follows

    Before:

        Data       = DDDDDddddd
        RemoveSize = 5
        TotalSize  = 10

    After:

        Data      = ddddd00000

Arguments:

    Data - Supplies a pointer to the data being altered

    RemoveSize - Supplies the number of bytes to delete from the front
        of the data buffer

    TotalSize - Supplies the total number of bytes in the data buffer
        before the delete operation

Return Value:

    None

--*/

{
    ULONG i;

    //
    //  Shift over the buffer to remove the amount
    //

    for (i = RemoveSize; i < TotalSize; i++) {

        ((PUCHAR)Data)[i-RemoveSize] = ((PUCHAR)Data)[i];

    }

    //
    //  Now as a safety precaution we'll zero out the rest of the string
    //

    for (i = TotalSize - RemoveSize; i < TotalSize; i++) {

        ((PUCHAR)Data)[i] = 0;
    }

    //
    //  And return to our caller
    //

    return;

}



ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}




NTSTATUS
ADSIRtlGetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    )

/*++

Routine Description:

    This procedure retrieves the control information from a security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Control - Receives the control information.

    Revision - Receives the revision of the security descriptor.
               This value will always be returned, even if an error
               is returned by this routine.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{

    //
    // Always return the revision value - even if this isn't a valid
    // security descriptor
    //

    *Revision = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision;


    if ( ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision
         != SECURITY_DESCRIPTOR_REVISION ) {
        return STATUS_UNKNOWN_REVISION;
    }


    *Control = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Control;

    return STATUS_SUCCESS;

}

NTSTATUS
ADSIRtlSetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
/*++

Routine Description:

    This procedure sets the control information in a security descriptor.


    For instance,

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED );

    marks the DACL on the security descriptor as protected. And

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      0 );


    marks the DACL as not protected.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    ControlBitsOfInterest - A mask of the control bits being changed, set,
        or reset by this call.  The mask is the logical OR of one or more of
        the following flags:

            SE_DACL_UNTRUSTED
            SE_SERVER_SECURITY
            SE_DACL_AUTO_INHERIT_REQ
            SE_SACL_AUTO_INHERIT_REQ
            SE_DACL_AUTO_INHERITED
            SE_SACL_AUTO_INHERITED
            SE_DACL_PROTECTED
            SE_SACL_PROTECTED

    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest
        should be set to.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )
    //
    // Ensure the caller passed valid bits.
    //

    if ( (ControlBitsOfInterest & ~SE_VALID_CONTROL_BITS) != 0 ||
         (ControlBitsToSet & ~ControlBitsOfInterest) != 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)->Control &= ~ControlBitsOfInterest;
    ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)->Control |= ControlBitsToSet;

    return STATUS_SUCCESS;
}



BOOL
ADSIGetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    )

/*++

Routine Description:

    This procedure retrieves the control information from a security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Control - Receives the control information.

    Revision - Receives the revision of the security descriptor.
               This value will always be returned, even if an error
               is returned by this routine.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{
    NTSTATUS Status;

    Status = ADSIRtlGetControlSecurityDescriptor (
                SecurityDescriptor,
                Control,
                Revision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
ADSISetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
/*++

Routine Description:

    This procedure sets the control information in a security descriptor.


    For instance,

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED );

    marks the DACL on the security descriptor as protected. And

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      0 );


    marks the DACL as not protected.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    ControlBitsOfInterest - A mask of the control bits being changed, set,
        or reset by this call.  The mask is the logical OR of one or more of
        the following flags:

            SE_DACL_UNTRUSTED
            SE_SERVER_SECURITY
            SE_DACL_AUTO_INHERIT_REQ
            SE_SACL_AUTO_INHERIT_REQ
            SE_DACL_AUTO_INHERITED
            SE_SACL_AUTO_INHERITED
            SE_DACL_PROTECTED
            SE_SACL_PROTECTED

    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest
        should be set to.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        //
        // In this case we should be able to load
        // the function from advapi32 and should not
        // use our private api.
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    Status = ADSIRtlSetControlSecurityDescriptor (
                pSecurityDescriptor,
                ControlBitsOfInterest,
                ControlBitsToSet
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_cs.h ===
//
// auto_cs.h    CRITICAL_SECTION
//

#pragma once


class auto_leave;

class auto_cs
{
public:
    auto_cs()
    {   InitializeCriticalSection(&m_cs); }

    ~auto_cs()
    {
        DeleteCriticalSection(&m_cs);
    };

    // return value of current dumb pointer
    LPCRITICAL_SECTION  get() 
    { return &m_cs; };

    LPCRITICAL_SECTION  get() const
    { return (LPCRITICAL_SECTION)&m_cs; };

protected:
    CRITICAL_SECTION m_cs;
};


class auto_leave
{
public:
    auto_leave(auto_cs& cs)
        : m_ulCount(0), m_pcs(cs.get()) {}
    auto_leave(const auto_cs&  cs) 
    {
        m_ulCount =0;
        m_pcs = cs.get();
    }
  
    ~auto_leave()
    {
        reset();
    }
	auto_leave& operator=(auto_cs& cs)
	{
		reset();
		m_pcs = cs.get();
		return *this;
	}

    void EnterCriticalSection()
    { ::EnterCriticalSection(m_pcs); m_ulCount++; }
    void LeaveCriticalSection()
    {
    	if (m_ulCount)
    	{
    		m_ulCount--;
    		::LeaveCriticalSection(m_pcs);
    	}
	}
	//Note: Win95 doesn't support TryEnterCriticalSection.
	//Commenting out this since we don't use it. [mgorti]

	//BOOL TryEnterCriticalSection()
	//{
	//	if (::TryEnterCriticalSection(m_pcs))
	//	{
	//		m_ulCount++;
	//		return TRUE;
	//	}
	//	return FALSE;
	//}
protected:
	void reset()
	{
		while (m_ulCount)
        {
            LeaveCriticalSection();
        }
        m_pcs = 0;
	}
	ULONG				m_ulCount;
    LPCRITICAL_SECTION	m_pcs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\atl.h ===
#if (!defined(BUILD_FOR_NT40))
#pragma once

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include "atlcom.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_bstr.h ===
// auto_bstr.h
//
// Same as auto_ptr but for BSTR

#pragma once

#include <xstddef>

class auto_bstr
{
public:
	auto_bstr( BSTR b= 0, bool o= true)
	: _bstr(b), _Owns(o)
	{}
	~auto_bstr()
	{
		if(_bstr && _Owns)
			::SysFreeString(_bstr);
	}

	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }

	operator BSTR() { return _bstr; }
	operator const BSTR() const { return _bstr; }
	BSTR* operator &() {return &_bstr; }
	auto_bstr& operator=(auto_bstr& rhs)
	{
		if(_bstr == rhs._bstr)
			return *this;

		clear();
		_Owns= rhs._Owns;
		_bstr= rhs.release();

		return *this;
	}
	
	auto_bstr& operator=(BSTR bstr)
	{
		clear();
		_bstr= bstr;
		_Owns= true;
		return *this;
	}
	operator bool()
		{ return NULL != _bstr; }
	operator !()
		{ return NULL == _bstr; }

	void clear()
	{
		if(_bstr && _Owns)
		{
			::SysFreeString(_bstr);
		}
		_bstr= NULL;
	}

	BSTR release()
	{
		BSTR bstr= _bstr;

		_bstr= NULL;
		return bstr;
	}
	
protected:
	bool _Owns;
	BSTR _bstr;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_h.h ===
//
// auto_h.h
//

#pragma once

template<class T> class auto_handle;

template<class T>
class CHandleProxy
{
public:
    CHandleProxy (auto_handle<T>& ah) :
        m_ah(ah) {};
    CHandleProxy (const auto_handle<T>& ah) :
        m_ah(const_cast<auto_handle<T>&> (ah)) {};
    
    operator T* () { return &m_ah.h; }
    operator const T* () const { return &m_ah.h; }
  
    operator auto_handle<T>* () { return &m_ah; }

protected:
    mutable auto_handle<T>& m_ah;
};

template<class T>
class auto_handle
{
public:
    auto_handle(T p = 0)
        : h(p) {};
    auto_handle(const auto_handle<T>& rhs)
        : h(rhs.release()) {};

    ~auto_handle()
        { if (h && INVALID_HANDLE_VALUE != h) CloseHandle(h); };

    auto_handle<T>& operator= (const auto_handle<T>& rhs)
    {   if (this != rhs.getThis())
            reset (rhs.release() );
        return *this;
    };
    auto_handle<T>& operator= (HANDLE rhs)
    {   if ((NULL == rhs) || (INVALID_HANDLE_VALUE == rhs))
        {   
        	AssertSz(false, "assigning invalid HANDLE to auto_handle- use .reset instead");
        	// be sure and go through auto_os for dbg.lib
            //auto_os os;
            //os = (BOOL)FALSE;
            //AssertSz(FALSE, "auto_handle<T>::op= Shouldn't ever get here");
        }
        reset (rhs);
        return *this;
    };

    CHandleProxy<T> operator& ()
        { reset(); return CHandleProxy<T> (*this); };  // &h; 
    const CHandleProxy<T> operator& () const
        {  return CHandleProxy<T> (*this); };  // &h; 
    operator T ()
        { return h; };
    
    // Checks for NULL
	bool operator! ()
		{ return h == NULL; }
	operator bool()
		{ return h != NULL; }
    bool operator== (LPVOID lpv) const
        { return h == lpv; };
    bool operator!= (LPVOID lpv) const
        { return h != lpv; };
    bool operator== (const auto_handle<T>& rhs) const
        { return h == rhs.h; };
    bool operator< (const auto_handle<T>& rhs) const
        { return h < rhs.h; };

    // return value of current dumb pointer
    T  get() const
        { return h; };

    // relinquish ownership
    T  release() const
    {   T oldh = h;
        h = 0;
        return oldh;
    };

    // delete owned pointer; assume ownership of p
    BOOL reset (T p = 0)
    {
        BOOL rt = TRUE;

        if (h && INVALID_HANDLE_VALUE != h)
			rt = CloseHandle(h);
        h = p;
        
        return rt;
    };

private:
    friend class CHandleProxy<T>;

    // operator& throws off operator=
    const auto_handle<T> * getThis() const
    {   return this; };

    // mutable is needed for release call in ctor and copy ctor
    mutable T h;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_hr.h ===
//
// auto_chk.h
//

#pragma once

#ifdef _DEBUG_AUTOHR
#include "dbg.h" // CDebug
#endif

class auto_hr
{
public:
    auto_hr() : hr(0) {}

    auto_hr& operator= (HRESULT rhs)
    {   
        hr = rhs;

#ifdef _DEBUG_AUTOHR
        if (debug().CheckHrFail())
            throw HRESULT (debug().m_pInfo->m_hr);
#endif

        if (FAILED(rhs))
        {
#ifdef _DEBUG_AUTOHR
            if (debug().m_pInfo->m_bDebugBreakOnError)
#ifdef _M_IX86
                __asm int 3;
#else
                DebugBreak();
#endif
#endif
            throw HRESULT(rhs);
        }
        return *this;
    };

    operator HRESULT ()
        { return hr; }

	HRESULT operator <<(HRESULT h)
	{
        hr = h;
        
		return hr;
	}

protected:
    auto_hr& operator= (bool rhs) { return *this; }
    auto_hr& operator= (int rhs)  { return *this; }
    auto_hr& operator= (ULONG rhs) { return *this; }

    HRESULT hr;
};

class auto_os
{
public:
    auto_os() : dw(0) {}

    auto_os& operator= (LONG rhs)
    {   
        dw = rhs;

#ifdef _DEBUG_AUTOHR
        if (debug().CheckOsFail())
            throw int (debug().m_pInfo->m_os);
#endif

        if (rhs)
        {
#ifdef _DEBUG_AUTOHR
            if (debug().m_pInfo->m_bDebugBreakOnError)
#ifdef _M_IX86
                __asm int 3;
#else
                DebugBreak();
#endif
#endif
            throw int (rhs);
        }
        return *this;
    };
    auto_os& operator= (BOOL rhs)
    {   
        dw = rhs;

#ifdef _DEBUG_AUTOHR
        if (debug().CheckOsFail())
            throw int (debug().m_pInfo->m_os);
#endif

        if (!rhs)
        {
#ifdef _DEBUG_AUTOHR
            if (debug().m_pInfo->m_bDebugBreakOnError)
#ifdef _M_IX86
                __asm int 3;
#else
                DebugBreak();
#endif
#endif
            throw int (GetLastError());
        }
        return *this;
    };

    operator LONG ()
        { return dw; }
protected:
    DWORD dw;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_pv.h ===
#pragma once

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
// auto_pv- auto PROPVARIANT releaser.
//
// pretty minimal functionality, designed to provide auto release only
// 
class auto_pv : public ::tagPROPVARIANT {
public:
	// Constructors
	//
	auto_pv() throw();

	// Destructor
	//
	~auto_pv() throw();

	// Low-level operations
	//
	void Clear() throw();

	void Attach(PROPVARIANT& varSrc) throw();
	PROPVARIANT Detach() throw();

	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }

protected:
	bool _Owns;
};

// Default constructor
//
inline auto_pv::auto_pv() throw()
: _Owns(true)
{
	::PropVariantInit(this);
}

// destructor
inline auto_pv::~auto_pv() throw()
{
	if(_Owns)
		::PropVariantClear(this);
	else
		::PropVariantInit(this);
}


// Clear the auto_var
//
inline void auto_pv::Clear() throw()
{
	if(_Owns)
		::PropVariantClear(this);
	else
		::PropVariantInit(this);
}

inline void auto_pv::Attach(PROPVARIANT& varSrc) throw()
{
	//
	// Free up previous VARIANT
	//
	Clear();

	//
	// Give control of data to auto_var
	//
	memcpy(this, &varSrc, sizeof(varSrc));
	varSrc.vt = VT_EMPTY;
}

inline PROPVARIANT auto_pv::Detach() throw()
{
	PROPVARIANT varResult = *this;
	this->vt = VT_EMPTY;

	return varResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_prg.h ===
// auto_prg.h
//
// Same as auto_ptr but for a

#pragma once

#include <xstddef>

template<class _Ty>
class auto_prg
{
public:
	typedef _Ty element_type;

    explicit auto_prg(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	auto_prg(const auto_prg<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	auto_prg<_Ty>& operator=(const auto_prg<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns)
				delete [] _Ptr;
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	auto_prg<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns)
				delete [] _Ptr;
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~auto_prg()
		{if (_Owns)
			delete [] _Ptr; }
	_Ty** operator&() _THROW0()
		{ return &_Ptr; }
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((auto_prg<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
	};

template<class _Ty>
class pointer
{
public:
	typedef _Ty element_type;

    explicit pointer(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	pointer(const pointer<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	pointer<_Ty>& operator=(const pointer<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns)
				delete _Ptr;
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	pointer<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns)
				delete _Ptr;
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~pointer()
		{if (_Owns)
			delete _Ptr; }
	_Ty** operator&() _THROW0()
		{ return &_Ptr; }
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((pointer<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_sa.h ===
//
// auto_sa.h   SAFEARRAY
//

#pragma once


class auto_sa
{
public:
	auto_sa()
	: _psa(0),
	  _Owns(true)
	{}
	~auto_sa()
	{
		if(_psa && _Owns)
		{
			_psa->cLocks= 0;
			::SafeArrayDestroy(_psa);
		}
	}

	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }

	operator SAFEARRAY *() { return _psa; }
	operator const SAFEARRAY *() const { return _psa; }
	auto_sa& operator=(auto_sa& rhs)
	{
		if(_psa == rhs._psa)
			return *this;

		clear();
		_Owns= rhs._Owns;
		_psa= rhs.release();

		return *this;
	}

	auto_sa& operator=(SAFEARRAY* psa)
	{
		clear();
		_psa= psa;
		_Owns= true;
		return *this;
	}
	operator bool()
		{ return NULL != _psa; }
	operator !()
		{ return NULL == _psa; }

	void clear()
	{
		if(_psa && _Owns)
		{
			_psa->cLocks= 0;
			::SafeArrayDestroy(_psa);
		}
		_psa= NULL;
	}

	SAFEARRAY* release()
	{
		SAFEARRAY* psa= _psa;

		_psa= NULL;
		return psa;
	}
		

protected:
	SAFEARRAY *_psa;
	bool _Owns;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_rel.h ===
//
// auto_rel.h
//

#pragma once

// class I - Multi-Inheritance casting for ATL type classes
// ergo C2385 - T::Release() is ambiguous
//
template<class T, class I = T>
class auto_rel
{
public:
    explicit auto_rel(T* p = 0)
        : pointee(p) {};
        // Don't AddRef()

    auto_rel(auto_rel<T,I>& rhs)
        : pointee(rhs.get()) { if (pointee) ((I*)pointee)->AddRef(); }

    ~auto_rel()
        {
        	if (pointee)
        		((I*)pointee)->Release();
		};

    auto_rel<T,I>& operator= (const auto_rel<T,I>& rhs)
    {   
        if (this != rhs.getThis())
        {
            reset (rhs.get());
            if (pointee) ((I*)pointee)->AddRef();
        }
        return *this;
    };

    auto_rel<T,I>& operator= (T*rhs)
    {   
        reset (rhs);
        // Don't AddRef()
        return *this;
    };

    T& operator*() const 
        { return *pointee; };
    T*  operator-> () const
        { return pointee; };
    T** operator& ()                // for OpenEntry etc...
        { reset(); return &pointee; };
    operator T* ()
        { return pointee; };
#ifdef MAPIDEFS_H
    operator LPMAPIPROP ()
        { return (LPMAPIPROP)pointee; };
#endif
	operator bool ()
		{ return pointee != NULL; };
	operator bool () const
		{ return pointee != NULL; };
	bool operator! ()
		{ return pointee == NULL; };
	bool operator! () const
		{ return pointee == NULL; };

    // Checks for NULL
    bool operator== (LPVOID lpv)
        { return pointee == lpv; };
    bool operator!= (LPVOID lpv)
        { return pointee != lpv; };
    bool operator== (const auto_rel<T,I>& rhs)
        { return pointee == rhs.pointee; }
    bool operator< (const auto_rel<T,I>& rhs)
        { return pointee < rhs.pointee; }

    // return value of current dumb pointer
    T*  get() const
        { return pointee; };

    // relinquish ownership
    T*  release()
    {   T * oldPointee = pointee;
        pointee = 0;
        return oldPointee;
    };

    // delete owned pointer; assume ownership of p
    ULONG reset (T* p = 0)
    {   ULONG ul = 0;
        if (pointee)
			ul = ((I*)pointee)->Release();
        pointee = p;
        
        return ul;
    };

private:
#ifdef MAPIDEFS_H
    // these are here on purpose, better to find out at compile time
    // use auto_padr<T,I> or auto_prow<T,I>
    operator LPADRLIST () { return 0; };
    operator LPSRowSet () { return 0; };
#endif

    // operator& throws off operator=
    const auto_rel<T,I> * getThis() const
    {   return this; };

    T* pointee;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_sid.h ===
// auto_sid.h
//

#pragma once

class auto_sid
{
public:
    explicit auto_sid(SID* p = 0)
        : m_psid(p) {};
    auto_sid(auto_sid& rhs)
        : m_psid(rhs.release()) {};

    ~auto_sid()
        { if (m_psid) FreeSid(m_psid); };

    auto_sid& operator= (auto_sid& rhs)
    {   if (this != rhs.getThis())
            reset (rhs.release() );
        return *this;
    };

    SID operator*() const 
        { return *m_psid; };
    void** operator& ()
        { reset(); return (void**)&m_psid; };
    operator SID* ()
        { return m_psid; };
    
    // Checks for NULL
    BOOL operator== (LPVOID lpv)
        { return m_psid == lpv; };
    BOOL operator!= (LPVOID lpv)
        { return m_psid != lpv; };

    // return value of current dumb pointer
    SID*  get() const
        { return m_psid; };

    // relinquish ownership
    SID*  release()
    {   SID* oldpsid = m_psid;
        m_psid = 0;
        return oldpsid;
    };

    // delete owned pointer; assume ownership of p
    void reset (SID* p = 0)
    {   
        if (m_psid)
			FreeSid(m_psid);
        m_psid = p;
    };

private:
    // operator& throws off operator=
    const auto_sid* getThis() const
    {   return this; };

    SID* m_psid;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_tm.h ===
// auto_tm.h
//
// Same as auto_ptr but for memory freed with CoTaskFreeMem

#pragma once

#include <xstddef>

template<class _Ty>
class auto_tm
{
public:
	typedef _Ty element_type;

    explicit auto_tm(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	auto_tm(const auto_tm<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	auto_tm<_Ty>& operator=(const auto_tm<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns)
				CoTaskMemFree(_Ptr);
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	auto_tm<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns)
				CoTaskMemFree(_Ptr);
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~auto_tm()
		{if (_Owns)
			CoTaskMemFree(_Ptr);}
	_Ty** operator&() _THROW0()
		{ return &_Ptr; }
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((auto_tm<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_reg.h ===
//
// auto_h.h
//

#pragma once

class auto_reg
{
public:
    auto_reg(HKEY p = 0)
        : h(p) {};
    auto_reg(auto_reg& rhs)
        : h(rhs.release()) {};

    ~auto_reg()
        { if (h) RegCloseKey(h); };

    auto_reg& operator= (auto_reg& rhs)
    {   if (this != rhs.getThis())
            reset (rhs.release() );
        return *this;
    };
    auto_reg& operator= (HKEY rhs)
    {   if ((NULL == rhs) || (INVALID_HANDLE_VALUE == rhs))
        {   // be sure and go through auto_os for dbg.lib
            auto_os os;
            os = (BOOL)FALSE;
        }
        reset (rhs);
        return *this;
    };

    HKEY* operator& ()
        { reset(); return &h; };
    operator HKEY ()
        { return h; };
    
    // Checks for NULL
    bool operator== (LPVOID lpv)
        { return h == lpv; };
    bool operator!= (LPVOID lpv)
        { return h != lpv; };

    // return value of current dumb pointer
    HKEY  get() const
        { return h; };

    // relinquish ownership
    HKEY  release()
    {   HKEY oldh = h;
        h = 0;
        return oldh;
    };

    // delete owned pointer; assume ownership of p
    BOOL reset (HKEY p = 0)
    {
        BOOL rt = TRUE;

        if (h)
			rt = RegCloseKey(h);
        h = p;
        
        return rt;
    };

private:
    // operator& throws off operator=
    const auto_reg* getThis() const
    {   return this; };

    HKEY h;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\auto_var.h ===
//
// comutil.h - Native C++ compiler COM support - BSTR, VARIANT wrappers header
//

#pragma once

//////////////////////////////////////////////////////////////////////////////

class _bstr_t;
class auto_var;

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for VARIANT
//
//////////////////////////////////////////////////////////////////////////////

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 * * [C] - supported by class auto_var
 *
 *
 *  VT_EMPTY            [V]   [P]        nothing
 *  VT_NULL             [V]   [P]        SQL style Null
 *  VT_I2               [V][T][P][S][C]  2 byte signed int
 *  VT_I4               [V][T][P][S][C]  4 byte signed int
 *  VT_R4               [V][T][P][S][C]  4 byte real
 *  VT_R8               [V][T][P][S][C]  8 byte real
 *  VT_CY               [V][T][P][S][C]  currency
 *  VT_DATE             [V][T][P][S][C]  date
 *  VT_BSTR             [V][T][P][S][C]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S][C]  IDispatch *
 *  VT_ERROR            [V][T]   [S][C]  SCODE
 *  VT_BOOL             [V][T][P][S][C]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]     VARIANT *
 *  VT_UNKNOWN          [V][T]   [S][C]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S][C]  16 byte fixed point
 *  VT_I1                  [T]           signed char
 *  VT_UI1              [V][T][P][S][C]  unsigned char
 *  VT_UI2                 [T][P]        unsigned short
 *  VT_UI4                 [T][P]        unsigned short
 *  VT_I8                  [T][P]        signed 64-bit int
 *  VT_UI8                 [T][P]        unsigned 64-bit int
 *  VT_INT                 [T]           signed machine int
 *  VT_UINT                [T]           unsigned machine int
 *  VT_VOID                [T]           C style void
 *  VT_HRESULT             [T]           Standard return type
 *  VT_PTR                 [T]           pointer type
 *  VT_SAFEARRAY           [T]          (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]           C style array
 *  VT_USERDEFINED         [T]           user defined type
 *  VT_LPSTR               [T][P]        null terminated string
 *  VT_LPWSTR              [T][P]        wide null terminated string
 *  VT_FILETIME               [P]        FILETIME
 *  VT_BLOB                   [P]        Length prefixed bytes
 *  VT_STREAM                 [P]        Name of the stream follows
 *  VT_STORAGE                [P]        Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]        Stream contains an object
 *  VT_STORED_OBJECT          [P]        Storage contains an object
 *  VT_BLOB_OBJECT            [P]        Blob contains an object
 *  VT_CF                     [P]        Clipboard format
 *  VT_CLSID                  [P]        A Class ID
 *  VT_VECTOR                 [P]        simple counted array
 *  VT_ARRAY            [V]              SAFEARRAY*
 *  VT_BYREF            [V]              void* for local use
 */

class auto_var : public ::tagVARIANT {
public:
	// Constructors
	//
	auto_var() throw();

	auto_var(const VARIANT& varSrc) throw(_com_error);
	auto_var(const VARIANT* pSrc) throw(_com_error);
	auto_var(const auto_var& varSrc) throw(_com_error);

	auto_var(VARIANT& varSrc, bool fCopy) throw(_com_error);			// Attach VARIANT if !fCopy

	auto_var(short sSrc, VARTYPE vtSrc = VT_I2) throw(_com_error);	// Creates a VT_I2, or a VT_BOOL
	auto_var(long lSrc, VARTYPE vtSrc = VT_I4) throw(_com_error);		// Creates a VT_I4, a VT_ERROR, or a VT_BOOL
	auto_var(float fltSrc) throw();									// Creates a VT_R4
	auto_var(double dblSrc, VARTYPE vtSrc = VT_R8) throw(_com_error);	// Creates a VT_R8, or a VT_DATE
	auto_var(const CY& cySrc) throw();								// Creates a VT_CY
	auto_var(const _bstr_t& bstrSrc) throw(_com_error);				// Creates a VT_BSTR
	auto_var(const wchar_t *pSrc) throw(_com_error);					// Creates a VT_BSTR
	auto_var(const char* pSrc) throw(_com_error);						// Creates a VT_BSTR
	auto_var(IDispatch* pSrc, bool fAddRef = true) throw();			// Creates a VT_DISPATCH
	auto_var(bool bSrc) throw();										// Creates a VT_BOOL
	auto_var(IUnknown* pSrc, bool fAddRef = true) throw();			// Creates a VT_UNKNOWN
	auto_var(const DECIMAL& decSrc) throw();							// Creates a VT_DECIMAL
	auto_var(BYTE bSrc) throw();										// Creates a VT_UI1

	// Destructor
	//
	~auto_var() throw(_com_error);

	// Extractors
	//
	operator short() const throw(_com_error);			// Extracts a short from a VT_I2
	operator long() const throw(_com_error);			// Extracts a long from a VT_I4
	operator float() const throw(_com_error);			// Extracts a float from a VT_R4
	operator double() const throw(_com_error);			// Extracts a double from a VT_R8
	operator CY() const throw(_com_error);				// Extracts a CY from a VT_CY
	operator _bstr_t() const throw(_com_error);			// Extracts a _bstr_t from a VT_BSTR
	operator IDispatch*() const throw(_com_error);		// Extracts a IDispatch* from a VT_DISPATCH
	operator bool() const throw(_com_error);			// Extracts a bool from a VT_BOOL
	operator IUnknown*() const throw(_com_error);		// Extracts a IUnknown* from a VT_UNKNOWN
	operator DECIMAL() const throw(_com_error);			// Extracts a DECIMAL from a VT_DECIMAL
	operator BYTE() const throw(_com_error);			// Extracts a BTYE (unsigned char) from a VT_UI1
	
	// Assignment operations
	//
	auto_var& operator=(const VARIANT& varSrc) throw(_com_error);
	auto_var& operator=(const VARIANT* pSrc) throw(_com_error);
	auto_var& operator=(const auto_var& varSrc) throw(_com_error);

	auto_var& operator=(short sSrc) throw(_com_error);				// Assign a VT_I2, or a VT_BOOL
	auto_var& operator=(long lSrc) throw(_com_error);					// Assign a VT_I4, a VT_ERROR or a VT_BOOL
	auto_var& operator=(float fltSrc) throw(_com_error);				// Assign a VT_R4
	auto_var& operator=(double dblSrc) throw(_com_error);				// Assign a VT_R8, or a VT_DATE
	auto_var& operator=(const CY& cySrc) throw(_com_error);			// Assign a VT_CY
	auto_var& operator=(const _bstr_t& bstrSrc) throw(_com_error);	// Assign a VT_BSTR
	auto_var& operator=(const wchar_t* pSrc) throw(_com_error);		// Assign a VT_BSTR
	auto_var& operator=(const char* pSrc) throw(_com_error);			// Assign a VT_BSTR
	auto_var& operator=(IDispatch* pSrc) throw(_com_error);			// Assign a VT_DISPATCH
 	auto_var& operator=(bool bSrc) throw(_com_error);					// Assign a VT_BOOL
	auto_var& operator=(IUnknown* pSrc) throw(_com_error);			// Assign a VT_UNKNOWN
	auto_var& operator=(const DECIMAL& decSrc) throw(_com_error);		// Assign a VT_DECIMAL
	auto_var& operator=(BYTE bSrc) throw(_com_error);					// Assign a VT_UI1

	// Comparison operations
	//
	bool operator==(const VARIANT& varSrc) const throw(_com_error);
	bool operator==(const VARIANT* pSrc) const throw(_com_error);

	bool operator!=(const VARIANT& varSrc) const throw(_com_error);
	bool operator!=(const VARIANT* pSrc) const throw(_com_error);

	// Low-level operations
	//
	void Clear() throw(_com_error);

	void Attach(VARIANT& varSrc) throw(_com_error);
	VARIANT Detach() throw(_com_error);

	void ChangeType(VARTYPE vartype, const auto_var* pSrc = NULL) throw(_com_error);

	void SetString(const char* pSrc) throw(_com_error); // used to set ANSI string
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline auto_var::auto_var() throw()
{
	::VariantInit(this);
}

// Construct a auto_var from a const VARIANT&
//
inline auto_var::auto_var(const VARIANT& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));
}

// Construct a auto_var from a const VARIANT*
//
inline auto_var::auto_var(const VARIANT* pSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));
}

// Construct a auto_var from a const auto_var&
//
inline auto_var::auto_var(const auto_var& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));
}

// Construct a auto_var from a VARIANT&.  If fCopy is FALSE, give control of
// data to the auto_var without doing a VariantCopy.
//
inline auto_var::auto_var(VARIANT& varSrc, bool fCopy) throw(_com_error)
{
	if (fCopy) {
		::VariantInit(this);
		_com_util::CheckError(::VariantCopy(this, &varSrc));
	} else {
		memcpy(this, &varSrc, sizeof(varSrc));
		V_VT(&varSrc) = VT_EMPTY;
	}
}

// Construct either a VT_I2 VARIANT or a VT_BOOL VARIANT from
// a short (the default is VT_I2)
//
inline auto_var::auto_var(short sSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I2) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}
}

// Construct either a VT_I4 VARIANT, a VT_BOOL VARIANT, or a
// VT_ERROR VARIANT from a long (the default is VT_I4)
//
inline auto_var::auto_var(long lSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I4) && (vtSrc != VT_ERROR) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_ERROR) {
		V_VT(this) = VT_ERROR;
		V_ERROR(this) = lSrc;
	}
	else if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}
}

// Construct a VT_R4 VARIANT from a float
//
inline auto_var::auto_var(float fltSrc) throw()
{
	V_VT(this) = VT_R4;
	V_R4(this) = fltSrc;
}

// Construct either a VT_R8 VARIANT, or a VT_DATE VARIANT from
// a double (the default is VT_R8)
//
inline auto_var::auto_var(double dblSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_R8) && (vtSrc != VT_DATE)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_DATE) {
		V_VT(this) = VT_DATE;
		V_DATE(this) = dblSrc;
	}
	else {
		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}
}

// Construct a VT_CY from a CY
//
inline auto_var::auto_var(const CY& cySrc) throw()
{
	V_VT(this) = VT_CY;
	V_CY(this) = cySrc;
}

// Construct a VT_BSTR VARIANT from a const _bstr_t&
//
inline auto_var::auto_var(const _bstr_t& bstrSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;

	BSTR bstr = static_cast<wchar_t*>(bstrSrc);
	V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
										   ::SysStringByteLen(bstr));

	if (V_BSTR(this) == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_BSTR VARIANT from a const wchar_t*
//
inline auto_var::auto_var(const wchar_t* pSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;
	V_BSTR(this) = ::SysAllocString(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_BSTR VARIANT from a const char*
//
inline auto_var::auto_var(const char* pSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_DISPATCH VARIANT from an IDispatch*
//
inline auto_var::auto_var(IDispatch* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_DISPATCH(this)->AddRef();
	}
}

// Construct a VT_BOOL VARIANT from a bool
//
inline auto_var::auto_var(bool bSrc) throw()
{
	V_VT(this) = VT_BOOL;
	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);
}

// Construct a VT_UNKNOWN VARIANT from an IUnknown*
//
inline auto_var::auto_var(IUnknown* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_UNKNOWN(this)->AddRef();
	}
}

// Construct a VT_DECIMAL VARIANT from a DECIMAL
//
inline auto_var::auto_var(const DECIMAL& decSrc) throw()
{
	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	//
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;
}

// Construct a VT_UI1 VARIANT from a BYTE (unsigned char)
//
inline auto_var::auto_var(BYTE bSrc) throw()
{
	V_VT(this) = VT_UI1;
	V_UI1(this) = bSrc;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Extracts a VT_I2 into a short
//
inline auto_var::operator short() const throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		return V_I2(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_I2, this);

	return V_I2(&varDest);
}

// Extracts a VT_I4 into a long
//
inline auto_var::operator long() const throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		return V_I4(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_I4, this);

	return V_I4(&varDest);
}

// Extracts a VT_R4 into a float
//
inline auto_var::operator float() const throw(_com_error)
{
	if (V_VT(this) == VT_R4) {
		return V_R4(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_R4, this);

	return V_R4(&varDest);
}

// Extracts a VT_R8 into a double
//
inline auto_var::operator double() const throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		return V_R8(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_R8, this);

	return V_R8(&varDest);
}

// Extracts a VT_CY into a CY
//
inline auto_var::operator CY() const throw(_com_error)
{
	if (V_VT(this) == VT_CY) {
		return V_CY(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_CY, this);

	return V_CY(&varDest);
}

// Extracts a VT_BSTR into a _bstr_t
//
inline auto_var::operator _bstr_t() const throw(_com_error)
{
	if (V_VT(this) == VT_BSTR) {
		return V_BSTR(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_BSTR, this);

	return V_BSTR(&varDest);
}

// Extracts a VT_DISPATCH into an IDispatch*
//
inline auto_var::operator IDispatch*() const throw(_com_error)
{
	if (V_VT(this) == VT_DISPATCH) {
		V_DISPATCH(this)->AddRef();
		return V_DISPATCH(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_DISPATCH, this);

	V_DISPATCH(&varDest)->AddRef();
	return V_DISPATCH(&varDest);
}

// Extract a VT_BOOL into a bool
//
inline auto_var::operator bool() const throw(_com_error)
{
	if (V_VT(this) == VT_BOOL) {
		return V_BOOL(this) ? true : false;
	}

	auto_var varDest;

	varDest.ChangeType(VT_BOOL, this);

	return V_BOOL(&varDest) ? true : false;
}

// Extracts a VT_UNKNOWN into an IUnknown*
//
inline auto_var::operator IUnknown*() const throw(_com_error)
{
	if (V_VT(this) == VT_UNKNOWN) {
		return V_UNKNOWN(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_UNKNOWN, this);

	return V_UNKNOWN(&varDest);
}

// Extracts a VT_DECIMAL into a DECIMAL
//
inline auto_var::operator DECIMAL() const throw(_com_error)
{
	if (V_VT(this) == VT_DECIMAL) {
		return V_DECIMAL(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_DECIMAL, this);

	return V_DECIMAL(&varDest);
}

// Extracts a VT_UI1 into a BYTE (unsigned char)
//
inline auto_var::operator BYTE() const throw(_com_error)
{
	if (V_VT(this) == VT_UI1) {
		return V_UI1(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_UI1, this);

	return V_UI1(&varDest);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Assignment operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Assign a const VARIANT& (::VariantCopy handles everything)
//
inline auto_var& auto_var::operator=(const VARIANT& varSrc) throw(_com_error)
{
    Clear();
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));

	return *this;
}

// Assign a const VARIANT* (::VariantCopy handles everything)
//
inline auto_var& auto_var::operator=(const VARIANT* pSrc) throw(_com_error)
{
    Clear();
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));

	return *this;
}

// Assign a const auto_var& (::VariantCopy handles everything)
//
inline auto_var& auto_var::operator=(const auto_var& varSrc) throw(_com_error)
{
    Clear();
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));

	return *this;
}

// Assign a short creating either VT_I2 VARIANT or a 
// VT_BOOL VARIANT (VT_I2 is the default)
//
inline auto_var& auto_var::operator=(short sSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		V_I2(this) = sSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I2
		//
		Clear();

		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}

	return *this;
}

// Assign a long creating either VT_I4 VARIANT, a VT_ERROR VARIANT
// or a VT_BOOL VARIANT (VT_I4 is the default)
//
inline auto_var& auto_var::operator=(long lSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		V_I4(this) = lSrc;
	}
	else if (V_VT(this) == VT_ERROR) {
		V_ERROR(this) = lSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I4
		//
		Clear();

		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}

	return *this;
}

// Assign a float creating a VT_R4 VARIANT 
//
inline auto_var& auto_var::operator=(float fltSrc) throw(_com_error)
{
	if (V_VT(this) != VT_R4) {
		// Clear the VARIANT and create a VT_R4
		//
		Clear();

		V_VT(this) = VT_R4;
	}

	V_R4(this) = fltSrc;

	return *this;
}

// Assign a double creating either a VT_R8 VARIANT, or a VT_DATE
// VARIANT (VT_R8 is the default)
//
inline auto_var& auto_var::operator=(double dblSrc) throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		V_R8(this) = dblSrc;
	}
	else if(V_VT(this) == VT_DATE) {
		V_DATE(this) == dblSrc;
	}
	else {
		// Clear the VARIANT and create a VT_R8
		//
		Clear();

		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}

	return *this;
}

// Assign a CY creating a VT_CY VARIANT 
//
inline auto_var& auto_var::operator=(const CY& cySrc) throw(_com_error)
{
	if (V_VT(this) != VT_CY) {
		// Clear the VARIANT and create a VT_CY
		//
		Clear();

		V_VT(this) = VT_CY;
	}

	V_CY(this) = cySrc;

	return *this;
}

// Assign a const _bstr_t& creating a VT_BSTR VARIANT
//
inline auto_var& auto_var::operator=(const _bstr_t& bstrSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;

	if (!bstrSrc) {
		V_BSTR(this) = NULL;
	}
	else {
		BSTR bstr = static_cast<wchar_t*>(bstrSrc);
		V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
											   ::SysStringByteLen(bstr));

		if (V_BSTR(this) == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return *this;
}

// Assign a const wchar_t* creating a VT_BSTR VARIANT
//
inline auto_var& auto_var::operator=(const wchar_t* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;

	if (pSrc == NULL) {
		V_BSTR(this) = NULL;
	}
	else {
		V_BSTR(this) = ::SysAllocString(pSrc);

		if (V_BSTR(this) == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return *this;
}

// Assign a const char* creating a VT_BSTR VARIANT
//
inline auto_var& auto_var::operator=(const char* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}

	return *this;
}

// Assign an IDispatch* creating a VT_DISPATCH VARIANT 
//
inline auto_var& auto_var::operator=(IDispatch* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_DISPATCH(this)->AddRef();

	return *this;
}

// Assign a bool creating a VT_BOOL VARIANT 
//
inline auto_var& auto_var::operator=(bool bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_BOOL) {
		// Clear the VARIANT and create a VT_BOOL
		//
		Clear();

		V_VT(this) = VT_BOOL;
	}

	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);

	return *this;
}

// Assign an IUnknown* creating a VT_UNKNOWN VARIANT 
//
inline auto_var& auto_var::operator=(IUnknown* pSrc) throw(_com_error)
{
	// Clear VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_UNKNOWN(this)->AddRef();

	return *this;
}

// Assign a DECIMAL creating a VT_DECIMAL VARIANT
//
inline auto_var& auto_var::operator=(const DECIMAL& decSrc) throw(_com_error)
{
	if (V_VT(this) != VT_DECIMAL) {
		// Clear the VARIANT
		//
		Clear();
	}

	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;

	return *this;
}

// Assign a BTYE (unsigned char) creating a VT_UI1 VARIANT
//
inline auto_var& auto_var::operator=(BYTE bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_UI1) {
		// Clear the VARIANT and create a VT_UI1
		//
		Clear();

		V_VT(this) = VT_UI1;
	}

	V_UI1(this) = bSrc;

	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Comparison operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Compare a auto_var against a const VARIANT& for equality
//
inline bool auto_var::operator==(const VARIANT& varSrc) const throw()
{
	return *this == &varSrc;
}

// Compare a auto_var against a const VARIANT* for equality
//
inline bool auto_var::operator==(const VARIANT* pSrc) const throw()
{
	if (this == pSrc) {
		return true;
	}

	//
	// Variants not equal if types don't match
	//
	if (V_VT(this) != V_VT(pSrc)) {
		return false;
	}

	//
	// Check type specific values
	//
	switch (V_VT(this)) {
		case VT_EMPTY:
		case VT_NULL:
			return true;

		case VT_I2:
			return V_I2(this) == V_I2(pSrc);

		case VT_I4:
			return V_I4(this) == V_I4(pSrc);

		case VT_R4:
			return V_R4(this) == V_R4(pSrc);

		case VT_R8:
			return V_R8(this) == V_R8(pSrc);

		case VT_CY:
			return memcmp(&(V_CY(this)), &(V_CY(pSrc)), sizeof(CY)) == 0;

		case VT_DATE:
			return V_DATE(this) == V_DATE(pSrc);

		case VT_BSTR:
			return (::SysStringByteLen(V_BSTR(this)) == ::SysStringByteLen(V_BSTR(pSrc))) &&
					(memcmp(V_BSTR(this), V_BSTR(pSrc), ::SysStringByteLen(V_BSTR(this))) == 0);

		case VT_DISPATCH:
			return V_DISPATCH(this) == V_DISPATCH(pSrc);

		case VT_ERROR:
			return V_ERROR(this) == V_ERROR(pSrc);

		case VT_BOOL:
			return V_BOOL(this) == V_BOOL(pSrc);

		case VT_UNKNOWN:
			return V_UNKNOWN(this) == V_UNKNOWN(pSrc);

		case VT_DECIMAL:
			return memcmp(&(V_DECIMAL(this)), &(V_DECIMAL(pSrc)), sizeof(DECIMAL)) == 0;

		case VT_UI1:
			return V_UI1(this) == V_UI1(pSrc);

		default:
			_com_issue_error(E_INVALIDARG);
			// fall through
	}

	return false;
}

// Compare a auto_var against a const VARIANT& for in-equality
//
inline bool auto_var::operator!=(const VARIANT& varSrc) const throw()
{
	return !(*this == &varSrc);
}

// Compare a auto_var against a const VARIANT* for in-equality
//
inline bool auto_var::operator!=(const VARIANT* pSrc) const throw()
{
	return !(*this == pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Low-level operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Clear the auto_var
//
inline void auto_var::Clear() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}

inline void auto_var::Attach(VARIANT& varSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	//
	// Give control of data to auto_var
	//
	memcpy(this, &varSrc, sizeof(varSrc));
	V_VT(&varSrc) = VT_EMPTY;
}

inline VARIANT auto_var::Detach() throw(_com_error)
{
	VARIANT varResult = *this;
	V_VT(this) = VT_EMPTY;

	return varResult;
}

// Change the type and contents of this auto_var to the type vartype and
// contents of pSrc
//
inline void auto_var::ChangeType(VARTYPE vartype, const auto_var* pSrc) throw(_com_error)
{
	//
	// If pDest is NULL, convert type in place
	//
	if (pSrc == NULL) {
		pSrc = this;
	}

	if ((this != pSrc) || (vartype != V_VT(this))) {
		_com_util::CheckError(::VariantChangeType(static_cast<VARIANT*>(this),
												  const_cast<VARIANT*>(static_cast<const VARIANT*>(pSrc)),
												  0, vartype));
	}
}

inline void auto_var::SetString(const char* pSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////////////////

inline auto_var::~auto_var() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\caclcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsAccessControlListCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsAccessControlListCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CAccessControlList::CreateAccessControlList(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\binder.cxx ===
// Binder.cpp : Implementation of CBinder


#include "oleds.hxx"

#if (!defined(BUILD_FOR_NT40))

#include "atl.h"
#include "binder.hxx"
#include "row.hxx"

//property description constants
const PWSTR DESC_DBPROP_INIT_LCID =                     L"Location ID";
const PWSTR DESC_DBPROP_INIT_MODE =                     L"Mode";
const PWSTR DESC_DBPROP_INIT_BINDFLAGS =        L"Bind Flags";
const PWSTR DESC_DBPROP_INIT_LOCKOWNER =        L"Lock Owner";
const PWSTR DESC_DBPROP_USERID =                L"User ID";
const PWSTR DESC_DBPROP_PASSWORD =              L"Password";
const PWSTR DESC_DBPROP_ENCRYPT_PASSWORD =      L"Encrypt Password";

#define DEFAULT_DBPROP_INIT_MODE                DB_MODE_READ

/////////////////////////////////////////////////////////////////////////////
// CBinder

//ISupportErrorInfo methods

//+---------------------------------------------------------------------------
//
//  Function:  CBinder::InterfaceSupportsErrorInfo
//
//  Synopsis: Given an interface ID, tells if that interface supports
//            the interface ISupportErrorInfo
//
//  Arguments:
//              REFIID riid
//
//  Returns:
//              S_OK             yes, the interface supports ISupportErrorInfo
//              S_FALSE                  no, the interface doesn't support it.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
            &IID_IBindResource, &IID_IDBBinderProperties
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
            if (InlineIsEqualGUID(*arr[i],riid))
                    RRETURN(S_OK);
    }
    RRETURN(S_FALSE);
}

//IBindResource methods
//+---------------------------------------------------------------------------
//
//  Function:  CBinder::Bind
//
//  Synopsis: Binds to a row or rowset object given a URL.
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::Bind(
                           IUnknown *                   punkOuter,
                           LPCOLESTR                    pwszURL,
                           DBBINDURLFLAG                dwBindFlags,
                           REFGUID                              rguid,
                           REFIID                               riid,
                           IAuthenticate *              pAuthenticate,
                           DBIMPLICITSESSION *  pImplSession,
                           DWORD *                              pdwBindStatus,
                           IUnknown **                  ppUnk
                           )
{
    HRESULT hr = S_OK;

	TRYBLOCK
		//if caller passed a null value for dwBindFlags,
		//get them from initialization properties.
		if (dwBindFlags == 0)
			dwBindFlags = BindFlagsFromDbProps();

		//Forward the Bind call to CSessionObject for actual binding
		ADsAssert(m_pSession);
		hr = m_pSession->Bind(punkOuter, pwszURL, dwBindFlags, rguid, riid,
			pAuthenticate, pImplSession, pdwBindStatus, ppUnk);

		if (FAILED(hr))
				RRETURN(hr);
	
	CATCHBLOCKRETURN

	RRETURN(hr);
}

//IDBBinderProperties : IDBProperties
//(most of this code has been copied form exoledb and reorganized).
//IDBProperties
//+---------------------------------------------------------------------------
//
//  Function:  CBinder::GetProperties
//
//  Synopsis: Gets the requested Binder properties
//
//  For more info see OLE DB 2.1 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::GetProperties(
                                                           ULONG cPropertySets,
                                                           const DBPROPIDSET rgPropertySets[  ],
                                                           ULONG *pcPropertySets,
                                                           DBPROPSET **prgPropertySets)
{
    BOOL            fPropInError, fSpecialSets, fCopy = FALSE;
    HRESULT         hr = S_OK;
    LONG            ipropset =0, iprop =0;
    ULONG           cprop = 0, cpropError =0, ipropT;
    DBPROPSET       *rgPropertySetsOutput = NULL, *ppropset = NULL;
    DBPROP          *pprop;
    auto_leave      cs_auto_leave(m_autocs);

	TRYBLOCK
			//Let property manager object check and init the arguments
            hr = m_dbProperties.CheckAndInitPropArgs(cPropertySets,
                                                                       rgPropertySets,
                                                                       pcPropertySets,
                                                                       (void **)prgPropertySets,
                                                                       &fPropInError,
                                                                       &fSpecialSets);

            //if all the requested sets are special,
            //we just return error because this method
            //doesn't support special sets. Otherwise,
            //we attempt to return information about other
            //non-special sets.
            if(fSpecialSets && SUCCEEDED(hr))
                    RRETURN(DB_E_ERRORSOCCURRED);
            else if(!fSpecialSets && FAILED(hr))
                    RRETURN(hr);

            cs_auto_leave.EnterCriticalSection();

            //if cPropertySets is zero, return INIT property set.
            if(cPropertySets == 0)
            {
                    cPropertySets = 1;
                    fCopy = TRUE;
            }
            //or if DBPROPSET_PROPERTIESINERROR is requested,
            //check for invalid status values
            else if(fPropInError)
            {
                    ppropset = m_dbProperties.GetPropertySet(DBPROPSET_DBINIT);
                    for(iprop = 0, cpropError = 0;
                        (ULONG)iprop < ppropset->cProperties;
                            iprop++)
                            if( ppropset->rgProperties[iprop].dwStatus != DBPROPSTATUS_OK )
                                    cpropError++;
            }

            //Allocate memory for returning property sets.
            rgPropertySetsOutput =
                    (DBPROPSET *)CoTaskMemAlloc(cPropertySets *sizeof(DBPROPSET));
            if (!rgPropertySetsOutput)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            //If properties in error were requested, look for all properties
            //with invalid status values and return the info.
            if(fPropInError)
            {
                    if(cpropError)
                    {
                            rgPropertySetsOutput[0].rgProperties
                                    =(DBPROP *)CoTaskMemAlloc(cpropError *sizeof(DBPROP));
                            if(rgPropertySetsOutput[0].rgProperties == NULL)
                            {
                                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                            }
                            rgPropertySetsOutput[0].guidPropertySet = DBPROPSET_DBINIT;
                            for(ipropT =0, iprop =0;
                                ipropT <ppropset->cProperties;
                                    ipropT++)

                                    if( ppropset->rgProperties[ipropT].dwStatus
                                            != DBPROPSTATUS_OK )
                                    {
                                            memcpy(&(rgPropertySetsOutput[0].rgProperties[iprop]),
                                                    &(ppropset->rgProperties[ipropT]),
                                                    sizeof(DBPROP));
                                            VariantInit(
                                                    &(rgPropertySetsOutput[0].rgProperties[iprop].vValue));

                                            hr = VariantCopy(
                                                    &(rgPropertySetsOutput[0].rgProperties[iprop].vValue),
                                                    &(ppropset->rgProperties[ipropT].vValue));

                                            BAIL_ON_FAILURE(hr);
                                            iprop++;
                                    }
                    }
                    else
                            rgPropertySetsOutput[0].rgProperties = NULL;

                    rgPropertySetsOutput[0].cProperties = cpropError;
                    cpropError =0;
            }
            //if fCopy is set, copy the init property set to the return array
            else if(fCopy)
            {
                    for (ipropset=0; (ULONG)ipropset<cPropertySets; ++ipropset)
                    {
                            hr = m_dbProperties.CopyPropertySet(
                                    ipropset, &rgPropertySetsOutput[ipropset]);
                            BAIL_ON_FAILURE(hr);
                    }
            }
            //caller requested for some regular property sets
            //return the info.
            else
            {
                    //copy passed in information from rgPropertySets
                    //to output array.
                    memcpy(rgPropertySetsOutput,
                               rgPropertySets,
                               cPropertySets *sizeof(DBPROPSET));
                    //cycle thru each property set, get properties
                    //allocate necessary memory and assign values.
                    for(ipropset = 0, cprop = 0, cpropError =0;
                        (ULONG)ipropset<cPropertySets;
                            ipropset++)
                    {
                            ppropset = m_dbProperties.GetPropertySet(
                                    rgPropertySets[ipropset].guidPropertySet);

                            if(rgPropertySets[ipropset].cPropertyIDs)
                            {
                                    iprop =0;
                                    cprop += rgPropertySets[ipropset].cPropertyIDs;

                                    //Allocate memory for all the propertyIDs in this set.
                                    rgPropertySetsOutput[ipropset].rgProperties     =
                                            (DBPROP *) CoTaskMemAlloc(
                                            rgPropertySets[ipropset].cPropertyIDs *sizeof(DBPROP));

                                    if(rgPropertySetsOutput[ipropset].rgProperties == NULL)
                                    {
                                            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                                    }

                                    //zero memory
                                    memset( rgPropertySetsOutput[ipropset].rgProperties,
                                            0x00,
                                            rgPropertySets[ipropset].cPropertyIDs *sizeof(DBPROP));

                                    //DBPROPSET_DATASOURCEINFO is not valid on this object.
                                    if( ppropset == NULL ||
                                            (rgPropertySets[ipropset].guidPropertySet ==
                                             DBPROPSET_DATASOURCEINFO)
                                      )
                                    {
                                            cpropError += rgPropertySets[ipropset].cPropertyIDs;
                                            for(;
                                                (ULONG)iprop<rgPropertySets[ipropset].cPropertyIDs;
                                                    iprop++
                                               )
                                            {
                                                    rgPropertySetsOutput[ipropset].
                                                            rgProperties[iprop].dwPropertyID
                                                            = rgPropertySets[ipropset].rgPropertyIDs[iprop];

                                                    rgPropertySetsOutput[ipropset].
                                                            rgProperties[iprop].dwStatus =
                                                            DBPROPSTATUS_NOTSUPPORTED;
                                            }

                                            continue; //continue with next property set.
                                    }

                                    //we have a valid property set. Cycle thru each
                                    //property and assign values in output array.
                                    for(;
                                        (ULONG)iprop < rgPropertySets[ipropset].cPropertyIDs;
                                            iprop++
                                       )
                                    {
                                            pprop = (DBPROP *)m_dbProperties.GetProperty(
                                                    rgPropertySets[ipropset].guidPropertySet,
                                                    rgPropertySets[ipropset].rgPropertyIDs[iprop]);
                                            if(pprop)
                                            {
                                                    rgPropertySetsOutput[ipropset].rgProperties[iprop]
                                                            = *pprop;
                                                    VariantInit(
                                                            &(rgPropertySetsOutput[ipropset].
                                                               rgProperties[iprop].vValue));

                                                    hr = VariantCopy(
                                                            &(rgPropertySetsOutput[ipropset].
                                                                rgProperties[iprop].vValue),
                                                            &(pprop->vValue));

                                                    BAIL_ON_FAILURE(hr);
                                            }
                                            //If unable to get property, set dwStatus
                                            else
                                            {
                                                    cpropError++;
                                                    rgPropertySetsOutput[ipropset].
                                                            rgProperties[iprop].dwPropertyID =
                                                            rgPropertySets[ipropset].rgPropertyIDs[iprop];

                                                    rgPropertySetsOutput[ipropset].
                                                            rgProperties[iprop].dwStatus =
                                                            DBPROPSTATUS_NOTSUPPORTED;
                                            }
                                    }
                            }
                            else //no propertyIDs requested for this set
                            {
                                    rgPropertySetsOutput[ipropset].rgProperties = NULL;
                                    //DBPROPSET_DATASOURCEINFO is invalid for this object.
                                    //Return error if it is the one requested.
                                    if(ppropset == NULL ||
                                            (rgPropertySets[ipropset].guidPropertySet ==
                                             DBPROPSET_DATASOURCEINFO)
                                      )
                                    {
                                            cprop++;
                                            cpropError++;
                                    }
                                    else //otherwise, copy all propertyIDs
                                    {
                                            hr = m_dbProperties.CopyPropertySet(
                                                    rgPropertySets[ipropset].guidPropertySet,
                                                    &rgPropertySetsOutput[ipropset]);

                                            BAIL_ON_FAILURE(hr);
                                    }
                            }
                    } //for (ipropset = 0....
            }

	CATCHBLOCKBAIL(hr)

        ADsAssert(pcPropertySets && prgPropertySets);

        *pcPropertySets  = cPropertySets;
        *prgPropertySets = rgPropertySetsOutput;

        hr = cpropError ?
                ((cpropError < cprop) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED)
                : S_OK;

        RRETURN(hr);

error:
        while(ipropset >= 0)
        {
                while(--iprop >= 0)
                        VariantClear(
                                &(rgPropertySetsOutput[ipropset].rgProperties[iprop].vValue));
                if( rgPropertySetsOutput
                        && rgPropertySetsOutput[ipropset].cProperties
                        && rgPropertySetsOutput[ipropset].rgProperties)
                        CoTaskMemFree(rgPropertySetsOutput[ipropset].rgProperties);
                ipropset--;
        }
        if(rgPropertySetsOutput)
            CoTaskMemFree(rgPropertySetsOutput);
        RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:  CBinder::GetPropertyInfo
//
//  Synopsis: Gets information about requested properties
//
//  For more info see OLE DB 2.1 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::GetPropertyInfo(
                                                                          ULONG cPropertySets,
                                                                          const DBPROPIDSET rgPropertySets[  ],
                                                                          ULONG *pcPropertyInfoSets,
                                                                          DBPROPINFOSET **prgPropertyInfoSets,
                                                                          OLECHAR **ppDescBuffer)
{
    HRESULT                         hr;
    BOOL                            fPropInError, fSpecialSets, fCopy =FALSE;
    ULONG                           ipropset = 0, iprop, cProperty, cprop = 0, cpropError=0;
    ULONG_PTR                       cchDescBuffer, ichDescBuffer;
    DBPROPINFOSET           *rgPropertyInfoSetsOutput = NULL, *ppropinfoset;
    const DBPROPINFO UNALIGNED *pdbpropinfoSrc;
    PDBPROPINFO                      pdbpropinfo;
    auto_leave                      cs_auto_leave(m_autocs);

    TRYBLOCK
            if(ppDescBuffer)
            {
                    *ppDescBuffer = NULL;
                    cchDescBuffer = 0;
                    ichDescBuffer = 0;
            }
            //Let the property manager object check and init arguments
            hr = m_dbProperties.CheckAndInitPropArgs(cPropertySets,
                    rgPropertySets,
                    pcPropertyInfoSets,
                    (void **)prgPropertyInfoSets,
                    &fPropInError,
                    &fSpecialSets);

            if(FAILED(hr))
                    RRETURN(hr);
            else if(fPropInError)
                    RRETURN(E_INVALIDARG);

            cs_auto_leave.EnterCriticalSection();

            //if cPropertySets is zero, return INIT property set info
            if(cPropertySets == 0)
            {
                    cPropertySets = 1;
                    fCopy = TRUE;
            }

            rgPropertyInfoSetsOutput = (DBPROPINFOSET *)
                    CoTaskMemAlloc(cPropertySets*sizeof(DBPROPINFOSET));
            if (!rgPropertyInfoSetsOutput)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            if(fCopy)
            {
                    for (ipropset=0; ipropset <cPropertySets; ++ipropset)
                    {
                            hr = m_dbProperties.CopyPropertyInfoSet(
                                    ipropset,
                                    &rgPropertyInfoSetsOutput[ipropset],
                                    ppDescBuffer,
                                    &cchDescBuffer,
                                    &ichDescBuffer);
                            if (FAILED(hr))
                                    break;
                    }
                    BAIL_ON_FAILURE(hr);
            }
            else
            {
                    //copy passed in property set info to output array.
                    memcpy( rgPropertyInfoSetsOutput,
                            rgPropertySets,
                            cPropertySets *sizeof(DBPROPSET));

                    //Cycle thru each requested property set
                    for(ipropset=0, cprop =0; ipropset<cPropertySets; ipropset++)
                    {
                            iprop =0;

                            //Handle each special set
                            if( rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_DBINITALL)
                            {
                                    cprop++;
                                    hr = m_dbProperties.CopyPropertyInfoSet(DBPROPSET_DBINIT,
                                            &rgPropertyInfoSetsOutput[ipropset],
                                            ppDescBuffer,
                                            &cchDescBuffer,
                                            &ichDescBuffer);
                                    BAIL_ON_FAILURE(hr);
                            }
                            else if(fSpecialSets)
                            {
                                    if(rgPropertySets[ipropset].guidPropertySet ==
                                            DBPROPSET_DATASOURCEALL)
                                            rgPropertyInfoSetsOutput[ipropset].guidPropertySet =
                                            DBPROPSET_DATASOURCE;

                                    else if (rgPropertyInfoSetsOutput[ipropset].guidPropertySet ==
                                            DBPROPSET_SESSIONALL)
                                            rgPropertyInfoSetsOutput[ipropset].guidPropertySet =
                                            DBPROPSET_SESSION;

                                    else if(rgPropertyInfoSetsOutput[ipropset].guidPropertySet ==
                                            DBPROPSET_ROWSETALL)
                                            rgPropertyInfoSetsOutput[ipropset].guidPropertySet =
                                            DBPROPSET_ROWSET;

                                    else
                                            rgPropertyInfoSetsOutput[ipropset].guidPropertySet =
                                            DBPROPSET_DATASOURCEINFO;

                                    rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos = NULL;
                                    rgPropertyInfoSetsOutput[ipropset].cPropertyInfos = 0;
                                    cprop++;
                                    cpropError++;
                            }
                            else //Now the regular property sets
                            {
                                    ppropinfoset =
                                            m_dbProperties.GetPropertyInfoSet(
                                            rgPropertySets[ipropset].guidPropertySet);

                                    cProperty = rgPropertySets[ipropset].cPropertyIDs;

                                    if(cProperty)
                                    {
                                            cprop += cProperty;

                                            //allocate memory for each property info
                                            rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos
                                                    = (DBPROPINFO *)
                                                    CoTaskMemAlloc(cProperty *sizeof(DBPROPINFO));

                                            if( rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos
                                                    == NULL)
                                            {
                                                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                                            }

                                            //zero memory
                                            memset(rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos,
                                                    0x00,
                                                    cProperty*sizeof(DBPROPINFO));

                                            //if the requested property info set is empty,
                                            //store error information into the output array.
                                            if(ppropinfoset == 0)
                                            {
                                                    cpropError += cProperty;

                                                    for(iprop =0; iprop <cProperty; iprop++)
                                                    {
                                                            rgPropertyInfoSetsOutput[ipropset].
                                                                    rgPropertyInfos[iprop].dwPropertyID     =
                                                                    rgPropertySets[ipropset].rgPropertyIDs[iprop];

                                                            rgPropertyInfoSetsOutput[ipropset].
                                                                    rgPropertyInfos[iprop].dwFlags =
                                                                    DBPROPFLAGS_NOTSUPPORTED;
                                                    }
                                            }
                                            //otherwise, try to get property info for each property.
                                            else
                                            {
                                                    pdbpropinfo =
                                                            rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos;

                                                    for(; iprop <cProperty; iprop++, pdbpropinfo++)
                                                    {
                                                            pdbpropinfoSrc = m_dbProperties.GetPropertyInfo(
                                                                    rgPropertySets[ipropset].guidPropertySet,
                                                                    rgPropertySets[ipropset].rgPropertyIDs[iprop]);
                                                            if(pdbpropinfoSrc)
                                                                    *pdbpropinfo = *pdbpropinfoSrc;
                                                            else
                                                            {
                                                                    //unable to get property info
                                                                    //for this property. Store error info.
                                                                    pdbpropinfo->dwPropertyID =
                                                                            rgPropertySets[ipropset].
                                                                            rgPropertyIDs[iprop];

                                                                    pdbpropinfo->dwFlags =
                                                                            DBPROPFLAGS_NOTSUPPORTED;
                                                                    cpropError++;
                                                            }
                                                    }
                                                    //Now copy property descriptions
                                                    //for all properties in this set
                                                    hr = m_dbProperties.CopyPropertyDescriptions(
                                                            &rgPropertyInfoSetsOutput[ipropset],
                                                            ppDescBuffer,
                                                            &cchDescBuffer,
                                                            &ichDescBuffer);
                                                    BAIL_ON_FAILURE(hr);
                                            }
                                    }
                                    else //no properties stored in this set.
                                    {
                                            cprop++;

                                            //if the returned set itself is NULL, nothing
                                            //to copy.
                                            if(ppropinfoset == NULL)
                                            {
                                                    cpropError++;
                                                    rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos =
                                                            NULL;
                                            }
                                            //otherwise, just copy whatever info we have
                                            //in the set.
                                            else
                                            {
                                                    hr = m_dbProperties.CopyPropertyInfoSet(
                                                            rgPropertySets[ipropset].guidPropertySet,
                                                            &rgPropertyInfoSetsOutput[ipropset],
                                                            ppDescBuffer,
                                                            &cchDescBuffer,
                                                            &ichDescBuffer);
                                                    BAIL_ON_FAILURE(hr);
                                            }
                                    }
                            }
                    } //for (ipropset = 0 ....
            } //if (fcopy) ... else ...

    CATCHBLOCKBAIL(hr)

        *pcPropertyInfoSets  = cPropertySets;
        *prgPropertyInfoSets = rgPropertyInfoSetsOutput;

        // So far we have put relative offsets into pointers to property
        // descriptions. They have to be rebased on the beginning of the
        // desription strings buffer.
        if(ppDescBuffer && *ppDescBuffer)
        {
                for(ipropset=0; ipropset < cPropertySets; ipropset++)
                        for(iprop =0;
                            iprop <rgPropertyInfoSetsOutput[ipropset].cPropertyInfos;
                                iprop++)
                        {

                                //      Only do this if we really support the property:
                                //

                                if ( rgPropertyInfoSetsOutput[ipropset].
                                             rgPropertyInfos[iprop].dwFlags !=
                                         DBPROPFLAGS_NOTSUPPORTED )
                                {
                                        rgPropertyInfoSetsOutput[ipropset].
                                                rgPropertyInfos[iprop].pwszDescription =
                                                (WCHAR *)(*ppDescBuffer) +
                                                (ULONG_PTR)(rgPropertyInfoSetsOutput[ipropset].
                                                    rgPropertyInfos[iprop].pwszDescription);
                                }
                                else {
                                        ADsAssert ( rgPropertyInfoSetsOutput[ipropset].
                                                        rgPropertyInfos[iprop].pwszDescription
                                                                == NULL );
                                }
                        }
        }
        else
        {
                //      Assert that we're not passing back any strings:
                //

                for(ipropset=0; ipropset < cPropertySets; ipropset++)
                {
                        for(iprop =0;
                            iprop < rgPropertyInfoSetsOutput[ipropset].cPropertyInfos;
                                iprop++)
                        {
                                ADsAssert ( rgPropertyInfoSetsOutput[ipropset].
                                        rgPropertyInfos[iprop].pwszDescription == NULL );
                        }
                }
        }

        hr = cpropError ?
                ((cpropError <cprop) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED)
                : S_OK;

        RRETURN(hr);

error:
        ULONG           i;

        for ( i = 0; i < ipropset; i++ )
        {
                if( rgPropertyInfoSetsOutput
                        && rgPropertyInfoSetsOutput[i].cPropertyInfos
                        && rgPropertyInfoSetsOutput[i].rgPropertyInfos)
                        CoTaskMemFree(rgPropertyInfoSetsOutput[i].rgPropertyInfos);
        }

        if(rgPropertyInfoSetsOutput)
            CoTaskMemFree(rgPropertyInfoSetsOutput);

        if(ppDescBuffer && *ppDescBuffer)
        {
                CoTaskMemFree(*ppDescBuffer);
                *ppDescBuffer = NULL;
        }
        RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CBinder::GetProperties
//
//  Synopsis: Sets Binder properties
//
//  For more info see OLE DB 2.1 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::SetProperties(
                                                                        ULONG cPropertySets,
                                                                        DBPROPSET rgPropertySets[  ])
{
    ULONG                   ipropset, cprop, cpropError;
    DBPROPSTATUS    dbpropstat;
    DBPROP                  *ppropNew, *ppropEnd, *ppropStored;
    BOOL                    fEqualOnly, fRestore;
    HRESULT                 hr;
    DBPROPSET               *ppropset;
    auto_leave              cs_auto_leave(m_autocs);

    TRYBLOCK
        //Let the property manager object verify the args.
        hr = m_dbProperties.VerifySetPropertiesArgs(cPropertySets,
                                                        rgPropertySets);
        if (FAILED(hr))
                RRETURN(hr);

        cs_auto_leave.EnterCriticalSection();

        //Cycle thru each property set.
        for(ipropset =0, cprop =0,
                cpropError =0; ipropset < cPropertySets;
            ipropset++)
        {
                dbpropstat = DBPROPSTATUS_OK;
                fEqualOnly = FALSE;
                cprop += rgPropertySets[ipropset].cProperties;

                //Get the property set.
                ppropset = m_dbProperties.GetPropertySet(
                        rgPropertySets[ipropset].guidPropertySet);

                //Error if this is NOT init property set,
                if(rgPropertySets[ipropset].guidPropertySet != DBPROPSET_DBINIT)
                {
                        dbpropstat = DBPROPSTATUS_NOTSUPPORTED;
                }

                //ppropnew is beginning of property struct in memory
                //and ppropEnd is the end.
                ppropNew = rgPropertySets[ipropset].rgProperties;
                ppropEnd = ppropNew +rgPropertySets[ipropset].cProperties;

                if(fEqualOnly || dbpropstat == DBPROPSTATUS_OK)
                {
                        //Cycle thru each property
                        for(; ppropNew !=ppropEnd; ppropNew++)
                        {
                                ppropStored = (DBPROP *)m_dbProperties.GetProperty(
                                        rgPropertySets[ipropset].guidPropertySet,
                                        ppropNew->dwPropertyID);

                                //if property is already there....
                                if(ppropStored)
                                {
                                        ppropNew->dwStatus = DBPROPSTATUS_OK;
                                        //Set error status if validation fails or
                                        //if type doesn't match
                                        //or if bad option or fEqualOnly is set
                                        //but new and existing values aren't the same.
                                        if (ppropNew->dwPropertyID == DBPROP_INIT_MODE && (V_VT(&(ppropNew->vValue)) == VT_I4) &&
                                                V_I4(&ppropNew->vValue) != DB_MODE_READ)
                                                ppropNew->dwStatus = DBPROPSTATUS_BADVALUE;
                                        else if(V_VT(&(ppropNew->vValue)) !=
                                                (m_dbProperties.GetPropertyInfo(
                                                rgPropertySets[ipropset].guidPropertySet,
                                                ppropNew->dwPropertyID))->vtType)
                                        {
                                                if(V_VT(&(ppropNew->vValue)) != VT_EMPTY)
                                                        ppropNew->dwStatus = DBPROPSTATUS_BADVALUE;
                                                else if(fEqualOnly)
                                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSETTABLE;
                                        }
                                        else if(!GoodPropOption(ppropNew->dwOptions))
                                                ppropNew->dwStatus = DBPROPSTATUS_BADOPTION;
                                        else if(fEqualOnly && !VariantsEqual(
                                                &(ppropNew->vValue),
                                                &(ppropStored->vValue)))
                                                ppropNew->dwStatus = DBPROPSTATUS_NOTSETTABLE;

                                        //fEqualOnly was not set
                                        if(!fEqualOnly && ppropNew->dwStatus ==
                                                DBPROPSTATUS_OK)
                                        {
                                                // If VT_EMPTY we need to reset the default.
                                                if(V_VT(&(ppropNew->vValue)) == VT_EMPTY)
                                                {
                                                        //      Reset our initialization properties
                                                        //  to the default:
                                                        if(ppropNew->dwPropertyID == DBPROP_INIT_LCID)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_I4;
                                                                V_I4(&(ppropNew->vValue)) =
                                                                        GetUserDefaultLCID();
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                DBPROP_INIT_MODE)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_I4;
                                                                V_I4(&(ppropNew->vValue)) = DEFAULT_DBPROP_INIT_MODE;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                DBPROP_INIT_BINDFLAGS)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_I4;
                                                                V_I4(&(ppropNew->vValue)) = 0;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                DBPROP_INIT_LOCKOWNER)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_BSTR;
                                                                V_BSTR(&(ppropNew->vValue)) = NULL;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                DBPROP_AUTH_USERID)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_BSTR;
                                                                V_BSTR(&(ppropNew->vValue)) = NULL;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                  DBPROP_AUTH_PASSWORD)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_BSTR;
                                                                V_BSTR(&(ppropNew->vValue)) = NULL;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                   DBPROP_AUTH_ENCRYPT_PASSWORD)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_BOOL;
                                                                V_BOOL(&(ppropNew->vValue)) = VARIANT_FALSE;
                                                        }
                                                        fRestore = TRUE;
                                                }
                                                else
                                                        fRestore = FALSE;

                                                //copy new value into the property variant.
                                                if(FAILED(VariantCopy(
                                                        &(ppropStored->vValue),
                                                        &(ppropNew->vValue))))
                                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSET;
                                                else if( ppropNew->dwPropertyID == DBPROP_AUTH_USERID ) {
                                                    if(S_OK != m_pSession->SetUserName(V_BSTR(&(ppropNew->vValue))))
                                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSET;
                                                }
                                                else if( ppropNew->dwPropertyID == DBPROP_AUTH_PASSWORD ) {
                                                    if(S_OK != m_pSession->SetPassword(V_BSTR(&(ppropNew->vValue))))
                                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSET;
                                                }
                                                else if( ppropNew->dwPropertyID == DBPROP_AUTH_ENCRYPT_PASSWORD ) {
                                                    if(V_BOOL(&(ppropNew->vValue)) == VARIANT_TRUE)
                                                        m_pSession->SetAuthFlag(ADS_SECURE_AUTHENTICATION);
                                                }
                                                

                                                if(fRestore)
                                                        VariantInit(&(ppropNew->vValue));
                                        }
                                }
                                else
                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSUPPORTED;

                                if(ppropNew->dwStatus != DBPROPSTATUS_OK)
                                        cpropError++;
                        }
                }
                else
                {
                        cpropError += rgPropertySets[ipropset].cProperties;
                        for(; ppropNew !=ppropEnd; ppropNew++)
                                ppropNew->dwStatus = dbpropstat;
                }
            } //for (ipropset = 0 ...

    CATCHBLOCKRETURN

        hr = cpropError ?
                ((cpropError <cprop) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED)
                : S_OK;
        RRETURN(hr);
}

//IDBBinderProperties
//+---------------------------------------------------------------------------
//
//  Function:  CBinder::Reset
//
//  Synopsis: Resets binder properties to default values.
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::Reset( void)
{
    HRESULT                 hr              = NOERROR;
    DBPROP *                pprop;
    auto_leave              cs_auto_leave(m_autocs);

    TRYBLOCK
		cs_auto_leave.EnterCriticalSection();
        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_LCID );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_I4;
        V_I4(&pprop->vValue)    = GetUserDefaultLCID();

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_MODE );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_I4;
        V_I4(&pprop->vValue)    = DEFAULT_DBPROP_INIT_MODE;

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_BINDFLAGS );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_I4;
        V_I4(&pprop->vValue)    = 0;

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_LOCKOWNER );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_BSTR;
        V_BSTR(&pprop->vValue)  = NULL;

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_USERID );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_BSTR;
        V_BSTR(&pprop->vValue)  = NULL;
        m_pSession->SetUserName(NULL);

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_PASSWORD );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_BSTR;
        V_BSTR(&pprop->vValue)  = NULL;
        m_pSession->SetPassword(NULL);

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_ENCRYPT_PASSWORD );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_BOOL;
        V_BOOL(&pprop->vValue)  = VARIANT_FALSE;
        m_pSession->SetAuthFlag(0);
	
	CATCHBLOCKRETURN

	RRETURN(hr);
}

//Helper functions

//+---------------------------------------------------------------------------
//
//  Function: CBinder::InitializeProperties
//
//  Synopsis: Initializes binder init property group to default values.
//
//----------------------------------------------------------------------------
HRESULT CBinder::InitializeProperties()
{
        HRESULT                 hr;
        DBPROP                  prop;
        DBPROPINFO *    ppropinfo;

        //      Initialize the DBPROP structure:
        //

        ZeroMemory ( &prop, sizeof (prop) );
        prop.dwOptions          = DBPROPOPTIONS_OPTIONAL;
        prop.dwStatus           = DBPROPSTATUS_OK;

        //      Add the LCID:
        //

        prop.dwPropertyID       = DBPROP_INIT_LCID;
        V_VT(&prop.vValue)      = VT_I4;
        V_I4(&prop.vValue)      = GetUserDefaultLCID ();

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_INIT_LCID
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *)m_dbProperties.GetPropertyInfo(
                DBPROPSET_DBINIT,
                DBPROP_INIT_LCID);
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the DB_MODE:
        //

        prop.dwPropertyID               = DBPROP_INIT_MODE;
        V_VT(&prop.vValue)              = VT_I4;
        V_I4(&prop.vValue)              = DEFAULT_DBPROP_INIT_MODE;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_INIT_MODE
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_INIT_MODE );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the BindFlags property:
        //

        prop.dwPropertyID               = DBPROP_INIT_BINDFLAGS;
        V_VT(&prop.vValue)              = VT_I4;
        V_I4(&prop.vValue)              = 0;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_INIT_BINDFLAGS
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_INIT_BINDFLAGS );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the LOCKOWNER property:
        //

        prop.dwPropertyID               = DBPROP_INIT_LOCKOWNER;
        V_VT(&prop.vValue)              = VT_BSTR;
        V_BSTR(&prop.vValue)    = NULL;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_INIT_LOCKOWNER
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_INIT_LOCKOWNER );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the USERID property:
        //

        prop.dwPropertyID               = DBPROP_AUTH_USERID;
        V_VT(&prop.vValue)              = VT_BSTR;
        V_BSTR(&prop.vValue)    = NULL;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_USERID
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_USERID );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the PASSWORD property:
        //

        prop.dwPropertyID               = DBPROP_AUTH_PASSWORD;
        V_VT(&prop.vValue)              = VT_BSTR;
        V_BSTR(&prop.vValue)    = NULL;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_PASSWORD
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_PASSWORD );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the ENCRYPT_PASSWORD property:
        //

        prop.dwPropertyID               = DBPROP_AUTH_ENCRYPT_PASSWORD;
        V_VT(&prop.vValue)              = VT_BOOL;
        V_BOOL(&prop.vValue)    = VARIANT_FALSE;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_ENCRYPT_PASSWORD
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_ENCRYPT_PASSWORD );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;


error:
        RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CBinder::BindFlagsFromDbProps
//
//  Synopsis: extracts bind flags from initialization properties.
//
//----------------------------------------------------------------------------
DWORD CBinder::BindFlagsFromDbProps ( )
{
        const DBPROP *          ppropMode;
        const DBPROP *          ppropBindFlags;

        ppropMode = m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_MODE );
        ADsAssert ( ppropMode );

        ppropBindFlags = m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_BINDFLAGS );
        ADsAssert ( ppropBindFlags );

        const VARIANT * pvarMode = &ppropMode->vValue;
        const VARIANT * pvarBindFlags = &ppropBindFlags->vValue;

        DWORD           dwResult                = 0;

        if ( V_VT(pvarMode) == VT_I4 ) {
                DWORD           dwModeMask      =
                        DB_MODE_READ |
                        DB_MODE_WRITE |
                        DB_MODE_READWRITE |
                        DB_MODE_SHARE_DENY_READ |
                        DB_MODE_SHARE_DENY_WRITE |
                        DB_MODE_SHARE_EXCLUSIVE |
                        DB_MODE_SHARE_DENY_NONE;

                dwResult |= V_I4(pvarMode) & dwModeMask;
        }

        if ( V_VT(pvarBindFlags) == VT_I4 ) {
                DWORD           dwBindFlagProp  = V_I4(pvarBindFlags);
                DWORD           dwBindFlags             = 0;

                if ( dwBindFlagProp & DB_BINDFLAGS_DELAYFETCHCOLUMNS ) {
                        dwBindFlags |= DBBINDURLFLAG_DELAYFETCHCOLUMNS;
                }
                if ( dwBindFlagProp & DB_BINDFLAGS_DELAYFETCHSTREAM ) {
                        dwBindFlags |= DBBINDURLFLAG_DELAYFETCHSTREAM;
                }
                if ( dwBindFlagProp & DB_BINDFLAGS_RECURSIVE ) {
                        dwBindFlags |= DBBINDURLFLAG_RECURSIVE;
                }
                if ( dwBindFlagProp & DB_BINDFLAGS_OUTPUT ) {
                        dwBindFlags |= DBBINDURLFLAG_OUTPUT;
                }

                dwResult |= V_I4(pvarBindFlags) | dwBindFlags;
        }

        RRETURN (dwResult);
}

//+---------------------------------------------------------------------------
//
//  Function: CBinder::CreateDataSource
//
//  Synopsis: Creates an implicit DataSource object for this binder object.
//
//----------------------------------------------------------------------------
HRESULT CBinder::CreateDataSource()
{
        //Call this function only at creation time.
        ADsAssert(m_pDataSource == NULL && m_pDBInitialize.get() == NULL);

        HRESULT hr = S_OK;

        //Create a DataSource object. Note: starts with refcount = 1.
        m_pDataSource = new CDSOObject( NULL );
        if (m_pDataSource == NULL)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        //Initialize the object
        if (!m_pDataSource->FInit())
        {
                delete m_pDataSource;
                m_pDataSource = NULL;
                BAIL_ON_FAILURE(hr = E_FAIL);
        }

        //Get IDBInitialize interface and store it in (auto)member variable.
        //This will also make sure the DataSource object stays alive during
        //the lifetime of binder object.
        hr = m_pDataSource->QueryInterface(__uuidof(IDBInitialize),
                                           (void**)&m_pDBInitialize);
        BAIL_ON_FAILURE(hr);

        //We already stored datasource object reference in auto_rel object,
        //Now release once, since datasource object is created with refcount = 1.
        m_pDataSource->Release();

error:
        RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CBinder::CreateSession
//
//  Synopsis: Creates an implicit Session object for this binder object.
//
//----------------------------------------------------------------------------
HRESULT CBinder::CreateSession()
{
        //Call this function only at creation time.
        ADsAssert(m_pSession == NULL && m_pOpenRowset.get() == NULL);

        HRESULT hr = S_OK;
        CCredentials creds;

        //create a session object. Note: starts with refcount = 1
        m_pSession = new CSessionObject( NULL );
        if (m_pSession == NULL)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        //Initialize session object passing null credentials.
        //Note: This increments refcount on DataSource object.
        if (!m_pSession->FInit(m_pDataSource, creds))
                BAIL_ON_FAILURE(hr = E_FAIL);

        hr = m_pSession->QueryInterface(__uuidof(IOpenRowset),
                                                                        (void **)&m_pOpenRowset);
        BAIL_ON_FAILURE(hr);

        //We already stored session reference in auto_rel object.
        //Now release once, since session object is created
        //with refcount = 1
        m_pSession->Release();

        RRETURN ( S_OK );

error:
        //if we're here, the Session object is no good.
        if (m_pSession)
        {
                delete m_pSession;
                m_pSession = NULL;
        }

        RRETURN ( hr );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\bindercf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:  bindercf.cxx
//
//  Contents:  ADSI OLE DB Provider Binder Factory Code
//
//             CADsBinderCF::CreateInstance
//
//  History:   7-23-98     mgorti    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#if (!defined(BUILD_FOR_NT40))
#include "atl.h"
#endif

#include "bindercf.hxx"

#if (!defined(BUILD_FOR_NT40))
#include "binder.hxx"
#endif

#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CBinderF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    7-23-98   mgorti     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsBinderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT     hr = S_OK;

    // Create Instance code here

	CComObject<CBinder>		*pBinder = NULL;
    hr = CComObject<CBinder>::CreateInstance(&pBinder);
	if (FAILED(hr))
		return hr;

	//To make sure we delete the binder object in case we encounter errors after this point.
	pBinder->AddRef();
	auto_rel<IBindResource> pBinderDelete(pBinder);

	hr = pBinder->QueryInterface(iid, (void**)ppv);
	if (FAILED(hr))
		return hr;

    return hr;
#else
    return E_FAIL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cacecf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsAccessControlEntryCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsAccessControlEntryCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CAccessControlEntry::CreateAccessControlEntry(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\caccess.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  caccess.cxx
//
//  Contents:  Microsoft OleDB/OleDS Data Source Object for ADSI
//
//             CImpIAccessor object implementing the IAccessor interface.
//
//  History:   10-01-96     shanksh    Created.
//-------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//-------------------------------------------------------------------------
// CImpIAccessor::CImpIAccessor
//
// CImpIAccessor constructor.
//
//-------------------------------------------------------------------------

CImpIAccessor::CImpIAccessor (
    void      *pParentObj,        //@parm IN | Parent object pointer
    LPUNKNOWN pUnkOuter            //@parm IN | Outer Unknown pointer
    )
{
    //    Initialize simple member vars
    _pUnkOuter   = pUnkOuter;
    _pObj        = pParentObj;
    _pextbuffer  = NULL;
    _dwStatus    = 0;
    _pIDC        = NULL;

    ENLIST_TRACKING(CImpIAccessor);

    // This section is for serializing &CreateAccessor.
    InitializeCriticalSection(&_criticalsectionAccessor);

    return;
}


//-------------------------------------------------------------------------
// CImpIAccessor::~CImpIAccessor
//
// @mfunc CImpIAccessor destructor.
//
// @rdesc NONE
//-------------------------------------------------------------------------

CImpIAccessor::~CImpIAccessor (
    void
    )
{
    ULONG_PTR         hAccessor,   hAccessorLast;
    PADSACCESSOR pADsaccessor, pADsaccessorBadHandle;

    // Cleanup only if there's anything to clean.
    if( _pextbuffer ) {
        // Get a pointer to the special "BadHandle" accessor.
        _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

        // Get the number of available accessor handles.
        _pextbuffer->GetLastItemHandle(hAccessorLast);

        // Loop through the reminding accessor handles deleting those which
        // are referenced only by this object and refcount decrementing the
        // other ones
        for (hAccessor =1; hAccessor <=hAccessorLast; hAccessor++) {
            // Get a pointer to the next accessor.
            _pextbuffer->GetItemOfExtBuffer(hAccessor, &pADsaccessor);

            // For valid accessors just delete them.
            if( pADsaccessor != pADsaccessorBadHandle )
                DeleteADsAccessor(pADsaccessor);
        }
        // Now delete the buffer which holds accessor handles.
        delete _pextbuffer;
    }

    if( _pIMalloc )
        _pIMalloc->Release();

    if( _pIDC )
        _pIDC->Release();

    // Get rid of the critical section.
    DeleteCriticalSection(&_criticalsectionAccessor);

    return;
}


//-------------------------------------------------------------------------
// CImpIAccessor::FInit
//
// @mfunc Initialize the Accessor implementation object.
//
// @rdesc Did the Initialization Succeed
//         @flag S_OK               initialization succeeded,
//         @flag E_OUTOFMEMORY      initialization failed because of
//                                  memory allocation problem,
//-------------------------------------------------------------------------

STDMETHODIMP
CImpIAccessor::FInit (
    void
    )
{
    HRESULT hr;
    PADSACCESSOR pADsaccessorBadHandle;

    // Prepare a special, "Bad Handle" accessor.
    pADsaccessorBadHandle = (PADSACCESSOR)((BYTE *)&_dwGetDataTypeBadHandle);
    _dwGetDataTypeBadHandle = ACCESSORTYPE_INERROR;

    // Create the ExtBuffer array to hold pointers to malloc'd accessors.
    _pextbuffer = (LPEXTBUFF) new CExtBuff;
    if (_pextbuffer == NULL    ||
        !(_pextbuffer->FInit(
              sizeof(PADSACCESSOR),
              &pADsaccessorBadHandle
              ) ))
                RRETURN( E_OUTOFMEMORY );

    if( !_pIDC ) {
        hr = CoCreateInstance(
                 CLSID_OLEDB_CONVERSIONLIBRARY,
                 NULL,
                 CLSCTX_INPROC_SERVER,
                 IID_IDataConvert,
                 (void **)&_pIDC
                 );
        if ( FAILED(hr) ) {
            RRETURN (hr);
                }
    }

    hr = CoGetMalloc(MEMCTX_TASK, &_pIMalloc);
    RRETURN (hr);
}



//-------------------------------------------------------------------------
// CImpIAccessor::AddRefAccessor
//
// @mfunc Adds a reference count to an existing accessor.
//
// @rdesc Did release of the accessor Succeed
//         @flag S_OK                   | accessor addrefed successfully,
//         @flag DB_E_BADACCESSORHANDLE | accessor could not be addrefed
//                                        because its handle was invalid.
//-------------------------------------------------------------------------

STDMETHODIMP CImpIAccessor::AddRefAccessor(
    HACCESSOR   hAccessor,    //@parm IN  | handle of the accessor to release
    DBREFCOUNT *pcRefCounts    //@parm OUT | count of references
    )
{
    PADSACCESSOR pADsaccessor, pADsaccessorBadHandle;
    HRESULT hr;

    // Clear in case of error below.
    if( pcRefCounts )
        *pcRefCounts = 0;

    CAutoBlock     cab( &(_criticalsectionAccessor) );

    // Get a pointer to the accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessor, &pADsaccessor);

    // Get a pointer to the special "BadHandle" accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

    // If the handle is valid
    if (pADsaccessor != pADsaccessorBadHandle) {
        if (pADsaccessor->cRef <= 0)
            BAIL_ON_FAILURE( hr = E_FAIL );

        pADsaccessor->cRef++;

        if (pcRefCounts)
            *pcRefCounts = pADsaccessor->cRef;

        RRETURN( S_OK );
    }
    // otherwise complain about a bad handle.
    else
        RRETURN( DB_E_BADACCESSORHANDLE );

error:

    RRETURN( hr );
}



//-------------------------------------------------------------------------
// CImpIAccessor::CreateAccessor
//
// @mfunc Creates an accessor, which is a set of bindings that can be used to
// send data to or retrieve data from the data cache. The method performs
// extensive validations on the input bindings which include verification of
// the access type requested, column availability, data conversions involved,
// etc.
//
// @rdesc Returns one of the following values:
//    S_OK                    | creation of the accessor succeeded,
//    E_INVALIDARG            | creation of the accessor failed because
//                              phAccessor was a NULL pointer,
//    E_OUTOFMEMORY           | creation of the accessor failed because of
//                              memory allocation problem,
//    DB_E_CANTCREATEACCESSOR | DBROWSETFLAGS_MULTIPLEACCESSOR flag was not
//                              set and a row-fetching method has already
//                              been called.
//    OTHER                   | other result codes returned by called functions.
//-------------------------------------------------------------------------

STDMETHODIMP CImpIAccessor::CreateAccessor(
    DBACCESSORFLAGS dwAccessorFlags,
    DBCOUNTITEM     cBindings,
    const DBBINDING rgBindings[],
    DBLENGTH        cbRowSize,
    HACCESSOR       *phAccessor,
    DBBINDSTATUS    rgStatus[]
    )
{
    PADSACCESSOR pADsaccessor;
    ULONG_PTR hADsaccessor;
    HRESULT hr;
    ULONG dwGetDataType, dwSetDataType;
    DBCOUNTITEM ibind;
    BOOL fProviderOwned;
    DBBINDSTATUS bindstatus;
    ULONG wMask, wBaseType;

    if (phAccessor)
        *phAccessor = (HACCESSOR)0;

    // At the creation of the CAutoBlock object a critical section
    // is entered. Concurrent calls to CreateAccessor are entirely
    // legal but their interleaving cannot be allowed. The critical
    // section is left when this method terminate and the destructor
    // for CAutoBlock is called.
    CAutoBlock     cab( &(_criticalsectionAccessor) );

    // phAccessor must never be NULL, non-zero bindings count implies a
    // non-NULL array of bindings.
    if( phAccessor == NULL || (cBindings && rgBindings == NULL) )
        RRETURN( E_INVALIDARG );

    // cBindings is 0 and was called on the Command.
    if( cBindings == 0 )
        RRETURN( DB_E_NULLACCESSORNOTSUPPORTED );

    // dwAccessorFlags cannot take any other values than those legal.
    if( dwAccessorFlags & (~DBACCESSOR_VALID_FLAGS) )
        RRETURN( DB_E_BADACCESSORFLAGS );

    // Compute internal types for use by methods using accessors,
    DetermineTypes(
        dwAccessorFlags,
        &dwGetDataType,
        &dwSetDataType
        );

    // and detect possible inconsistencies in AccessorFlags.
    if( dwGetDataType == GD_ACCESSORTYPE_INERROR ||
        dwSetDataType == SD_ACCESSORTYPE_INERROR )
        RRETURN( DB_E_BADACCESSORFLAGS );

    // fix conformance test failure. If BYREF accessors are not supported,
    // (indicated by DBPROP_BYREFACCESSORS being FALSE), we should return 
    // the right error
    else if( (DB_E_BYREFACCESSORNOTSUPPORTED == dwGetDataType) ||
             (DB_E_BYREFACCESSORNOTSUPPORTED == dwSetDataType) )
        RRETURN( DB_E_BYREFACCESSORNOTSUPPORTED );

    // Initialize the status array to DBBINDSTATUS_OK.
    if( rgStatus )
        memset(rgStatus, 0x00, (size_t)(cBindings*sizeof(DBBINDSTATUS)));

    hr             = S_OK;
    fProviderOwned = FALSE;

    // Perform validations that apply to all types of accessors.
    for (ibind=0; ibind < cBindings; ibind++) {
        bindstatus = DBBINDSTATUS_OK;

        if( rgBindings[ibind].dwMemOwner != DBMEMOWNER_PROVIDEROWNED &&
                        rgBindings[ibind].dwMemOwner != DBMEMOWNER_CLIENTOWNED )
            bindstatus = DBBINDSTATUS_BADBINDINFO;

        // The part to be bound must specify one or more out of three values, and
        if( (rgBindings[ibind].dwPart &
            (DBPART_VALUE |DBPART_LENGTH |DBPART_STATUS)) == 0 ||
             // nothing else.
            (rgBindings[ibind].dwPart &
             ~(DBPART_VALUE |DBPART_LENGTH |DBPART_STATUS)) ||
             // Is it a good type to bind to?
            !IsGoodBindingType(rgBindings[ibind].wType) )
            bindstatus = DBBINDSTATUS_BADBINDINFO;

        // DBTYPE_BYREF, DBTYPE_VECTOR and DBTYPE_ARRAY cannot be combined.
        else if( (wMask = (rgBindings[ibind].wType & TYPE_MODIFIERS)) &&
                        wMask != DBTYPE_BYREF &&
                        wMask != DBTYPE_VECTOR &&
                        wMask != DBTYPE_ARRAY )
                        bindstatus = DBBINDSTATUS_BADBINDINFO;

        else if ((wBaseType = (rgBindings[ibind].wType & ~TYPE_MODIFIERS)) ==
                  DBTYPE_EMPTY ||
                 wBaseType == DBTYPE_NULL)
            bindstatus = DBBINDSTATUS_BADBINDINFO;

        // DBTYPE_ARRAY and DBTYPE_VECTOR are not supported types
        else if( (rgBindings[ibind].wType & DBTYPE_ARRAY) ||
                 (rgBindings[ibind].wType & DBTYPE_VECTOR) )
            bindstatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;

        // dwFlags was DBBINDFLAG_HTML and the type was not a String
        else if ( rgBindings[ibind].dwFlags &&
                  (rgBindings[ibind].dwFlags != DBBINDFLAG_HTML ||
                   (wBaseType != DBTYPE_STR  &&
                    wBaseType != DBTYPE_WSTR &&
                    wBaseType != DBTYPE_BSTR)) )
        {
            // Set Bind status to DBBINDSTATUS_BADBINDINFO
            bindstatus = DBBINDSTATUS_BADBINDINFO;
        }
        else if( rgBindings[ibind].wType == (DBTYPE_RESERVED | DBTYPE_BYREF) )
            bindstatus = DBBINDSTATUS_BADBINDINFO;

        else if( rgBindings[ibind].dwMemOwner == DBMEMOWNER_PROVIDEROWNED ) {
            if( (rgBindings[ibind].wType & TYPE_MODIFIERS) == 0
                && rgBindings[ibind].wType != DBTYPE_BSTR )
                bindstatus = DBBINDSTATUS_BADBINDINFO;
            else
                fProviderOwned = TRUE;
        }

        if( bindstatus != DBBINDSTATUS_OK )
            hr = DB_E_ERRORSOCCURRED;

        if( rgStatus )
            rgStatus[ibind] = bindstatus;
    }

    // Check for errors in the bindings
    BAIL_ON_FAILURE( hr );

    if( fProviderOwned &&
        (dwGetDataType == GD_ACCESSORTYPE_READ ||
         dwGetDataType == GD_ACCESSORTYPE_READ_OPTIMIZED) )
        dwGetDataType = GD_ACCESSORTYPE_READ_COLS_BYREF;

    // Allocate space for the accessor structure.
    pADsaccessor = (ADSACCESSOR *) new BYTE
                                     [(size_t)(sizeof(ADSACCESSOR) + (cBindings ? (cBindings-1) : 0)*
                                                                                           sizeof(DBBINDING))];

        if( pADsaccessor == NULL )
        RRETURN( E_OUTOFMEMORY );

    if( cBindings )
        memcpy(
            &(pADsaccessor->rgBindings[0]),
            &rgBindings[0],
            (size_t)(cBindings*sizeof(DBBINDING))
            );
    pADsaccessor->cBindings = cBindings;

    // For accessors valid for writing fill out a list of columns
    // so that notifications about their changes can be properly issued.
    if( dwSetDataType == SD_ACCESSORTYPE_READWRITE && cBindings ) {
        pADsaccessor->rgcol = new DBORDINAL [ (size_t)cBindings ];
        if( pADsaccessor->rgcol == NULL ) {
            dwSetDataType = SD_ACCESSORTYPE_INERROR;
        }
        else
            for (ibind =0; ibind <cBindings; ibind++)
                (pADsaccessor->rgcol)[ibind] = rgBindings[ibind].iOrdinal;
    }
    else
        pADsaccessor->rgcol = NULL;

    // Allocate DBOBJECT structures supporting IUnknown types.
    for (ibind =0; ibind <cBindings; ibind++)
        pADsaccessor->rgBindings[ibind].pObject = NULL;

    // Set accessor flags now, so that possible accessor cleanup routine would
    // know about additional structures for IUnknown types support.
    pADsaccessor->dwFlags = dwAccessorFlags;

    // Insert the new accessor pointer into the extensible buffer in which
    // accessors are stored.
    if( FAILED(hr = _pextbuffer->InsertIntoExtBuffer(
                         &pADsaccessor,
                         hADsaccessor
                         )) ) {
        DeleteADsAccessor(pADsaccessor);
        RRETURN (hr);
    }

    pADsaccessor->cRef = 1;

    // Fill out the new accessor structure with the binding info.
    //pADsaccessor->obRowData = obRowData;
    pADsaccessor->cbRowSize = cbRowSize;

    // Return the accessor index in the extensible buffer as the accessor
    // handle.
    *phAccessor = (HACCESSOR) hADsaccessor;

    // Now can safely leave.
    RRETURN( NOERROR );

error:

    RRETURN( hr );
}


//-------------------------------------------------------------------------
// CImpIAccessor::DetermineTypes
//
// @mfunc Determines internal accessor type classification for use by GetData,
// SetData and parameter handling code. Each of these has a separate type indicator
// variable and a separate set of defined types. This allows a very efficient
// handling of different accessors by methods that utilize them.
// Types are determined on the basis of AccessorFlags. Incorrect combinations of
// flags result in assignment of INERROR types.
//
// @rdesc NONE
//-------------------------------------------------------------------------

STDMETHODIMP_(void)
CImpIAccessor::DetermineTypes(
    DBACCESSORFLAGS    dwAccessorFlags,
    ULONG            *pdwGetDataType,
    ULONG            *pdwSetDataType
    )
{
    if( dwAccessorFlags & DBACCESSOR_PASSBYREF )
    {
        *pdwGetDataType = (ULONG) DB_E_BYREFACCESSORNOTSUPPORTED;
        *pdwSetDataType = (ULONG) DB_E_BYREFACCESSORNOTSUPPORTED;

        return;
    }
    else if( dwAccessorFlags & DBACCESSOR_PARAMETERDATA )
    {
         *pdwGetDataType = GD_ACCESSORTYPE_INERROR;
         *pdwSetDataType = GD_ACCESSORTYPE_INERROR;
         return;
    }

    // Determine types used in row data manipulations.
    if( dwAccessorFlags & DBACCESSOR_ROWDATA ) {
        // Determine accessor type from the point of
        // view of GetData.
        if( dwAccessorFlags & DBACCESSOR_OPTIMIZED )
            *pdwGetDataType = GD_ACCESSORTYPE_READ_OPTIMIZED;
        else
            *pdwGetDataType = GD_ACCESSORTYPE_READ;

        // Determine accessor type from the point of
        // view of SetData. PASSBYREF is disallowed.
        *pdwSetDataType = SD_ACCESSORTYPE_READWRITE;
    }
    else {
        *pdwGetDataType = GD_ACCESSORTYPE_INERROR;
        *pdwSetDataType = GD_ACCESSORTYPE_INERROR;
    }

    return;
}


//-------------------------------------------------------------------------
// CImpIAccessor::GetBindings
//
// @mfunc Returns bindings of an accessor.
//
// @rdesc Returns one of the following values:
//         S_OK           | getting bindings succeeded,
//         E_INVALIDARG   | getting bindings failed because
//                          pdwAccessorFlags or pcBindings or
//                          prgBindings was a NULL pointer,
//         E_OUTOFMEMORY  | getting bindings failed because memory
//                          allocation for the bindings array failed,
//         OTHER          | other result codes stored on the accessor
//                          object and singifying invalid accessor handle.
//-------------------------------------------------------------------------

STDMETHODIMP CImpIAccessor::GetBindings
(
HACCESSOR         hAccessor,            // IN  | accessor handle
DBACCESSORFLAGS    *pdwAccessorFlags,   // OUT | stores accessor flags
DBCOUNTITEM       *pcBindings,          // OUT | stores # of bindings
DBBINDING        **prgBindings          // OUT | stores array of bindings
)
{
    PADSACCESSOR  pADsaccessor;
    PADSACCESSOR  pADsaccessorBadHandle;
    DBCOUNTITEM   ibind;
    DBOBJECT     *pObject;

    if( pcBindings )
       *pcBindings = 0;

    if( prgBindings )
        *prgBindings = NULL;

    if( pdwAccessorFlags )
        *pdwAccessorFlags = DBACCESSOR_INVALID;

    // Are arguments valid?
    if( pdwAccessorFlags == NULL || pcBindings == NULL || prgBindings == NULL )
        RRETURN( E_INVALIDARG );

    // Obtain pointer to the accessor to be used.
    _pextbuffer->GetItemOfExtBuffer(hAccessor, &pADsaccessor);

    // Get a pointer to the special "BadHandle" accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

    // Recognize bad accessor handles and return appropriate HRESULT.
    if( pADsaccessor == pADsaccessorBadHandle )
        return DB_E_BADACCESSORHANDLE;

    // If necessary allocate the array of binding structures.
    if( pADsaccessor->cBindings ) {
        *prgBindings = (DBBINDING *) _pIMalloc->Alloc((ULONG)(
                           pADsaccessor->cBindings*sizeof(DBBINDING) ));

        if( *prgBindings == NULL )
            RRETURN ( E_OUTOFMEMORY );

        // Copy bindings.
        memcpy(
            *prgBindings,
            pADsaccessor->rgBindings,
            (size_t)(pADsaccessor->cBindings*sizeof(DBBINDING))
            );

        // Loop through bindings and allocate and copy DBOBJECT structs.
        for (ibind=0; ibind <pADsaccessor->cBindings; ibind++) {
            // If the accessor had failed bindings for SetData, we have
            // overloaded an unused structure member with status info, and
            // this needs to be cleaned now.
            (*prgBindings)[ibind].pTypeInfo = NULL;

            if( (*prgBindings)[ibind].pObject ) {
                pObject = (DBOBJECT *) _pIMalloc->Alloc( sizeof(DBOBJECT) );
                if( pObject ) {
                    memcpy(
                        pObject,
                        (*prgBindings)[ibind].pObject,
                        sizeof(DBOBJECT)
                        );
                    (*prgBindings)[ibind].pObject = pObject;
                }
                else {
                    while (ibind--)
                        if( (*prgBindings)[ibind].pObject )
                            _pIMalloc->Free((*prgBindings)[ibind].pObject);

                    _pIMalloc->Free( *prgBindings );
                    *prgBindings = NULL;
                    RRETURN( E_OUTOFMEMORY );
                }
            }
        }
    }

    // Return the count of bindings,
    *pcBindings = pADsaccessor->cBindings;
    // and accessor flags.
    *pdwAccessorFlags = (pADsaccessor->dwFlags & ~DBACCESSOR_REFERENCES_BLOB);

    return S_OK;
}



//-------------------------------------------------------------------------
// CImpIAccessor::ReleaseAccessor
//
// @mfunc Releases accessor. If accessor handle is valid the corresponding accessor
// is either freed (if no one else is using it) or its ref count is decremented.
//
// @rdesc Did release of the accessor Succeed
//         @flag S_OK                      | accessor released successfully,
//         @flag DB_E_BADACCESSORHANDLE | accessor could not be released because its
//                                     | handle was invalid.
//-------------------------------------------------------------------------

STDMETHODIMP CImpIAccessor::ReleaseAccessor
(
HACCESSOR    hAccessor,        //@parm IN  | handle of the accessor to release
DBREFCOUNT  *pcRefCounts    //@parm OUT | ref count of the released accessor
)
{
    PADSACCESSOR pADsaccessor, pADsaccessorBadHandle;

    if( pcRefCounts )
        *pcRefCounts = 0;

    CAutoBlock     cab( &(_criticalsectionAccessor) );

    // Get a pointer to the accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessor, &pADsaccessor);

    // Get a pointer to the special "BadHandle" accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

    // If the handle is valid
    if( pADsaccessor != pADsaccessorBadHandle ) {
        ADsAssert(pADsaccessor->cRef > 0);

        // Delete if no one else is    using it, otherwise
        if( pADsaccessor->cRef == 1 ) {
            // Delete the accessor structure itself, as well as allocations
            // hanging off this structure.
            DeleteADsAccessor(pADsaccessor);

            // Make sure this handle is marked as "Bad" for future.
            _pextbuffer->DeleteFromExtBuffer(hAccessor);
        }
        // decrement the refcount.
        else {
            pADsaccessor->cRef--;

            if( pcRefCounts )
                *pcRefCounts = pADsaccessor->cRef;
        }

        return NOERROR;
    }
    // otherwise complain about a bad handle.
    else
                RRETURN( DB_E_BADACCESSORHANDLE );
}

//-------------------------------------------------------------------------
// CImpIAccessor::DeleteADsAccessor
//
// @mfunc Deletes structures hanging off the ADSACCESSOR and then deletes the
// accessor structure itself.
//
// @rdesc NONE
//-------------------------------------------------------------------------

STDMETHODIMP_(void) CImpIAccessor::DeleteADsAccessor
(
PADSACCESSOR   pADsaccessor        //@parm IN  | Kagera accessor ptr
)
{
    DBCOUNTITEM ibind;

    // Delete the list of affected columns.
    if( pADsaccessor->rgcol )
        delete [] pADsaccessor->rgcol;

    // If the accessor references BLOBS then DBOBJECT structures describing
    // objects dealing with BLOBS need to be deallocated.
    for (ibind =0; ibind <pADsaccessor->cBindings; ibind++)
        if( pADsaccessor->rgBindings[ibind].pObject )
            delete pADsaccessor->rgBindings[ibind].pObject;

    delete [] pADsaccessor;
}


STDMETHODIMP
CImpIAccessor::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    // Is the pointer bad?
    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    if( IsEqualIID(iid, IID_IUnknown) ) {
        *ppv = (IAccessor FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IAccessor) ) {
        *ppv = (IAccessor FAR *) this;
    }
    else {
        RRETURN( E_NOINTERFACE );
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
// CreateBadAccessor
//
// Inserts a bad accessor into the array of accessors (indexed by accessor
// handles). This is required so that inheritance of accessors from commands
// works correctly. If there are any 'holes' in the command's array of 
// accessors, then a rowset created from the command should also inherit these 
// 'holes' i,e, the array of accessor handles should not be compacted to
// eliminate these holes. This is done using this function.
//
//--------------------------------------------------------------------------- 
HRESULT
CImpIAccessor::CreateBadAccessor(void)
{
    PADSACCESSOR pADsaccessorBadHandle;
    ULONG_PTR        hADsaccessor;
    HRESULT      hr;

    // Get a pointer to the special "BadHandle" accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

    // ignore the returned accessor handle
    hr = _pextbuffer->InsertIntoExtBuffer(
                       &pADsaccessorBadHandle, hADsaccessor);

    RRETURN( hr );
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cacl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cAccessControlList.cxx
//
//  Contents:  AccessControlList object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CAccessControlList

DEFINE_IDispatch_Implementation(CAccessControlList)

CAccessControlList::CAccessControlList():
        _pDispMgr(NULL),
        _dwAclRevision(0),
        _dwAceCount(0),
        _pAccessControlEntry(NULL),
        _pCurrentEntry(NULL),
        _pACLEnums(NULL)
{
    ENLIST_TRACKING(CAccessControlList);
}


HRESULT
CAccessControlList::CreateAccessControlList(
    REFIID riid,
    void **ppvObj
    )
{
    CAccessControlList FAR * pAccessControlList = NULL;
    HRESULT hr = S_OK;

    hr = AllocateAccessControlListObject(&pAccessControlList);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlList->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pAccessControlList->Release();

    RRETURN(hr);

error:
    delete pAccessControlList;

    RRETURN_EXP_IF_ERR(hr);

}


CAccessControlList::~CAccessControlList( )
{
    PACCESS_CONTROL_ENTRY pTemp = NULL;
    PACCESS_CONTROL_ENTRY pNext = NULL;

    PACL_ENUM_ENTRY pACL = _pACLEnums;


    delete _pDispMgr;

    pTemp = _pAccessControlEntry;

    while (pTemp) {

        pNext = pTemp->pNext;

        if (pTemp->pAccessControlEntry) {

            (pTemp->pAccessControlEntry)->Release();
        }
        FreeADsMem(pTemp);
        pTemp = pNext;
    }


    //
    // since each enumerator hold ref count on this ACL, this destructor should
    // never be called unless all of its enumerators' destructors have been
    // invoked. In the enumerator's destructor, RemoveEnumerator is called
    // first before release ref count on this. Thus, by the time, at this
    // point, pACL should be empty.
    //

    ADsAssert(!pACL);

    //
    // just in case we have bug in codes, e.g enumerators not all destroyed
    // before dll detachement. don't want to leak here anyway
    //

    while (pACL) {

        _pACLEnums = pACL->pNext;

        //
        // free the entry but do not destroy the enumerator since clients
        // should release all interface ptrs to enumerator for destruction.
        //

        FreeADsMem(pACL);
        pACL = _pACLEnums;
    }
}

STDMETHODIMP
CAccessControlList::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsAccessControlList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAccessControlList))
    {
        *ppv = (IADsAccessControlList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsAccessControlList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IEnumVARIANT))
    {

        *ppv = (IEnumVARIANT FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CAccessControlList::AllocateAccessControlListObject(
    CAccessControlList ** ppAccessControlList
    )
{
    CAccessControlList FAR * pAccessControlList = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pAccessControlList = new CAccessControlList();
    if (pAccessControlList == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsAccessControlList,
                (IADsAccessControlList *)pAccessControlList,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    pAccessControlList->_pDispMgr = pDispMgr;
    *ppAccessControlList = pAccessControlList;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CAccessControlList::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsAccessControlList) ||
        IsEqualIID(riid, IID_IEnumVARIANT)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CAccessControlList::CopyAccessList(
    THIS_ IDispatch FAR * FAR * ppAccessControlList
    )
{
    HRESULT hr = S_OK;
    DWORD dwAceCount = 0;
    DWORD dwNewAceCount = 0;
    DWORD dwAclRevision = 0;
    DWORD i = 0;
    VARIANT varAce;
    IADsAccessControlEntry * pSourceAce = NULL;
    IADsAccessControlEntry * pTargetAce = NULL;
    IDispatch * pTargDisp = NULL;
    DWORD cElementFetched = 0;
    IADsAccessControlList * pAccessControlList = NULL;

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    dwAceCount = _dwAceCount;
    dwAclRevision = _dwAclRevision;

    //
    // Reset the enumerator
    //

    _pCurrentEntry = _pAccessControlEntry;

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);
        hr = Next(1, &varAce, &cElementFetched);
        CONTINUE_ON_FAILURE(hr);

        hr = (V_DISPATCH(&varAce))->QueryInterface(
                        IID_IADsAccessControlEntry,
                        (void **)&pSourceAce
                        );
        CONTINUE_ON_FAILURE(hr);

        hr = CopyAccessControlEntry(
                    pSourceAce,
                    &pTargetAce
                    );
        BAIL_ON_FAILURE(hr);

        hr = pTargetAce->QueryInterface(
                            IID_IDispatch,
                            (void **)&pTargDisp
                            );
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlList->AddAce(pTargDisp);
        BAIL_ON_FAILURE(hr);

        dwNewAceCount++;

        if (pTargDisp) {
            pTargDisp->Release();
            pTargDisp = NULL;
        }

        if (pTargetAce) {
            pTargetAce->Release();
            pTargetAce = NULL;
        }

        if (pSourceAce) {
            pSourceAce->Release();
            pSourceAce = NULL;
        }

        VariantClear(&varAce);
    }

    hr= pAccessControlList->put_AceCount(dwNewAceCount);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlList->put_AclRevision((long)dwAclRevision);
    BAIL_ON_FAILURE(hr);

    *ppAccessControlList = pAccessControlList;

error:

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CAccessControlList::AddAce(
    THIS_ IDispatch FAR *  pAccessControlEntry
    )
{

    HRESULT hr = S_OK;
    PACCESS_CONTROL_ENTRY pAccessEntry = NULL;
    PACCESS_CONTROL_ENTRY pTemp = NULL;
    IADsAccessControlEntry * pAce = NULL;

    hr = pAccessControlEntry->QueryInterface(
                            IID_IADsAccessControlEntry,
                            (void **)&pAce
                            );
    BAIL_ON_FAILURE(hr);

    pAccessEntry = (PACCESS_CONTROL_ENTRY)AllocADsMem(
                                sizeof(ACCESS_CONTROL_ENTRY)
                                );
    if (!pAccessEntry) {

        pAce->Release();
        RRETURN(E_OUTOFMEMORY);
    }

    pAccessEntry->pAccessControlEntry = pAce;

    //
    // - Now append this ace to the very end.
    // - Since ACE is added to the end, no need to call
    //  AdjustCurPtrOfEnumerators().
    //

    if (!_pAccessControlEntry) {

        _pAccessControlEntry = pAccessEntry;

    }else {

        pTemp = _pAccessControlEntry;

        while (pTemp->pNext) {

            pTemp = pTemp->pNext;
        }

        pTemp->pNext = pAccessEntry;

    }

    //
    // Now up the ace count
    //

    _dwAceCount++;

error:

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CAccessControlList::RemoveAce(
    THIS_ IDispatch FAR *  pAccessControlEntry
    )
{
    HRESULT hr = S_OK;
    PACCESS_CONTROL_ENTRY pTemp = NULL;
    IADsAccessControlEntry * pAce = NULL;
    PACCESS_CONTROL_ENTRY pAccessEntry = NULL;
    DWORD dwRemovePos = 1;      // one-based indexing since enumerator was
                                // written that way

    if (!_pAccessControlEntry) {

        RRETURN(E_FAIL);
    }


    hr =  pAccessControlEntry->QueryInterface(
                                    IID_IADsAccessControlEntry,
                                    (void **)&pAce
                                    );
    BAIL_ON_FAILURE(hr);


    pAccessEntry = _pAccessControlEntry;


    //
    // It is the first entry
    //


    if (EquivalentAces(pAccessEntry->pAccessControlEntry, pAce)) {

        //
        //  Check if we have an enumerator pointed to us
        //

        if (pAccessEntry == _pCurrentEntry) {

            _pCurrentEntry = pAccessEntry->pNext;
        }

        _pAccessControlEntry = pAccessEntry->pNext;

        (pAccessEntry->pAccessControlEntry)->Release();

         FreeADsMem(pAccessEntry);


         if (pAce) {
             pAce->Release();
         }

         //
         // Decrement the Ace count
         //

         _dwAceCount--;

        //
        // Adjust "current" ptr of all enumerators if necessary
        //

        AdjustCurPtrOfEnumerators(dwRemovePos, FALSE);

         RRETURN(S_OK);

    }

    while (pAccessEntry->pNext) {

        pTemp = pAccessEntry->pNext;
        dwRemovePos++;

        if (EquivalentAces(pTemp->pAccessControlEntry, pAce)){

            //
            //  Check if we have an enumerator pointed to us
            //

            if (pAccessEntry == _pCurrentEntry) {

                _pCurrentEntry = pAccessEntry->pNext;
            }

            pAccessEntry->pNext = pTemp->pNext;

            (pTemp->pAccessControlEntry)->Release();

             FreeADsMem(pTemp);

             if (pAce) {
                 pAce->Release();
             }

             //
             // Decrement the Ace count
             //

             _dwAceCount--;

            //
            // Adjust "current" ptr of all enumerators if necessary
            //

            AdjustCurPtrOfEnumerators(dwRemovePos, FALSE);


             RRETURN(S_OK);

        }

        pAccessEntry = pAccessEntry->pNext;
    }


    if (pAce) {
        pAce->Release();

    }

error:

    RRETURN_EXP_IF_ERR(E_FAIL);
}

STDMETHODIMP
CAccessControlList::get_AclRevision(THIS_ long FAR * retval)
{

    *retval = _dwAclRevision;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlList::put_AclRevision(THIS_ long lnAclRevision)
{

    _dwAclRevision = lnAclRevision;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlList::get_AceCount(THIS_ long FAR * retval)
{

    *retval = _dwAceCount;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlList::put_AceCount(THIS_ long lnAceCount)
{

    _dwAceCount = lnAceCount;
    RRETURN(S_OK);
}


STDMETHODIMP
CAccessControlList::Next(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched)
{
   DWORD i = 0;
   DWORD j = 0;
   IDispatch * pDispatch = NULL;
   IADsAccessControlEntry * pAccessControlEntry = NULL;
   PACCESS_CONTROL_ENTRY pTemp = NULL;
   PVARIANT pThisVar;
   HRESULT hr = S_OK;


   pTemp = _pCurrentEntry;

   if (!pTemp) {
       if (pcElementFetched) {
           *pcElementFetched = 0;
       }

       RRETURN(S_FALSE);
   }


   while (pTemp && (j < cElements)){

      pThisVar = pvar + j;
      VariantInit(pThisVar);

      pAccessControlEntry = pTemp->pAccessControlEntry;

      hr = pAccessControlEntry->QueryInterface(
                                     IID_IDispatch,
                                     (void **)&pDispatch
                                     );

      V_DISPATCH(pThisVar) = pDispatch;
      V_VT(pThisVar) = VT_DISPATCH;

      pTemp = pTemp->pNext;
      j++;
   }

   if (pcElementFetched) {
      *pcElementFetched = j;
   }

   //
   // Advance _pCurrentEntry
   //


   _pCurrentEntry = pTemp;

   if (j < cElements) {
      RRETURN (S_FALSE);
   }

   RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlList::GetElement
//
//  Synopsis:   Get the dwPos'th ACE in the ACL. Note that no
//            refCount is added to the ACE, it is the responsibility
//            of the caller to handle that.
//
//  Arguments:  [dwPos] the ACE required
//              [pAce] Pointer to ACE returned in this param.
//
//  Returns:    HRESULT
//
//  Modifies:   [pAce]
//
//----------------------------------------------------------------------------
HRESULT
CAccessControlList::GetElement(
    DWORD dwPos,
    IADsAccessControlEntry ** pAce
    )
{
    HRESULT hr = S_OK;
    DWORD j = 1;
    PACCESS_CONTROL_ENTRY pTemp = NULL;

    *pAce = NULL;
    // set to the acl head
    pTemp = _pAccessControlEntry;

    if (_dwAceCount < dwPos) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    while (pTemp && (j < dwPos)) {
        pTemp = pTemp->pNext;
        j++;
    }

    if (!pTemp || pTemp == NULL) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    // we should have the correct ACE here
    *pAce = pTemp->pAccessControlEntry;

error:
    if (FAILED(hr)) {
        hr = S_FALSE;
    }
    RRETURN(hr);
}


STDMETHODIMP
CAccessControlList::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;
    IEnumVARIANT * penum = NULL;

    *retval = NULL;

    hr = CAccCtrlListEnum::CreateAclEnum(
             (CAccCtrlListEnum **)&penum,
             this
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                   IID_IUnknown,
                   (VOID FAR* FAR*)retval
                   );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    //
    // keep a linked list of all enumerators that enumerate on this ACL
    // But don't hold on to inteface ptr of enumerators; otherwise, cycle
    // reference count. Do this only after above succeed.
    //

    hr = AddEnumerator(
            (CAccCtrlListEnum *)penum
            );
    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr) && penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CAccessControlList::
AddEnumerator(
    CAccCtrlListEnum *pACLEnum
    )
{
    PACL_ENUM_ENTRY pNewACLEnum = NULL;

    //
    // don't want add NULL enumerator as an entry to add complication everywhere
    //

    ADsAssert(pACLEnum);


    pNewACLEnum = (PACL_ENUM_ENTRY) AllocADsMem(sizeof(ACL_ENUM_ENTRY));

    if (!pNewACLEnum)
        RRETURN(E_OUTOFMEMORY);

    //
    // We are only adding a ptr to the enumerator.
    // Don't hold on to inteface ptr. Otherwise, this has ref count on
    // enumerator has ref count on this. Cycle reference count.
    //

    pNewACLEnum->pACLEnum = pACLEnum;

    pNewACLEnum->pNext = _pACLEnums;
    _pACLEnums = pNewACLEnum;

    RRETURN(S_OK);
}

HRESULT
CAccessControlList::
RemoveEnumerator(
    CAccCtrlListEnum *pACLEnum
    )
{
    PACL_ENUM_ENTRY pCurACLEnum = _pACLEnums;
    PACL_ENUM_ENTRY pPrevACLEnum = NULL;

    //
    // can't think of a case needing to remove a pACLEnum which may be
    // NULL now. Don't want to add complication. Probably coding error.
    //

    ADsAssert(pACLEnum);


    //
    // optional, but we really shouldn't call this if _pACLEnums is NULL
    //

    ADsAssert(_pACLEnums);


    //
    // check the first enumerator
    //

    if (pCurACLEnum) {

        //
        // match what we want to remove
        //

        if (pCurACLEnum->pACLEnum == pACLEnum) {

            //
            // remove the enumerator from our list but don't destroy
            // the enumerator
            //

            _pACLEnums = pCurACLEnum->pNext;
            FreeADsMem(pCurACLEnum);

            RRETURN(S_OK);
        }

    } else {

        RRETURN(E_FAIL);
    }


    //
    // start checking from the second element, if any, of the list
    //

    pPrevACLEnum = pCurACLEnum;
    pCurACLEnum = pCurACLEnum->pNext;

    while (pCurACLEnum && (pCurACLEnum->pACLEnum!=pACLEnum)) {

        pPrevACLEnum = pCurACLEnum;
        pCurACLEnum = pCurACLEnum->pNext;
    }


    if (pCurACLEnum) {

        //
        // match found
        //

        pPrevACLEnum->pNext = pCurACLEnum->pNext;
        FreeADsMem(pCurACLEnum);

        RRETURN(S_OK);

    } else {

        RRETURN(E_FAIL);
    }

}


BOOL
EquivalentStrings(
    BSTR bstrSrcString,
    BSTR bstrDestString
    )
{
    if (!bstrSrcString && !bstrDestString) {
        return(TRUE);
    }
    if (!bstrSrcString && bstrDestString) {
        return(FALSE);
    }
    if (!bstrDestString && bstrSrcString) {
        return(FALSE);
    }
#ifdef WIN95
    if (!_wcsicmp(bstrSrcString, bstrDestString)) {
#else
    if (CompareStringW(
            LOCALE_SYSTEM_DEFAULT,
            NORM_IGNORECASE,
            bstrSrcString,
            -1,
            bstrDestString,
            -1
            ) 
        == CSTR_EQUAL) {
#endif
        return(TRUE);
    }

    return(FALSE);
}


BOOL
EquivalentAces(
    IADsAccessControlEntry  * pSourceAce,
    IADsAccessControlEntry  * pDestAce
    )
{
    HRESULT hr = S_OK;

    BSTR bstrSrcTrustee = NULL;
    BSTR bstrDestTrustee = NULL;

    DWORD dwSrcMask = 0;
    DWORD dwDestMask = 0;

    DWORD dwSrcAceFlags = 0;
    DWORD dwDestAceFlags = 0;

    DWORD dwSrcAceType = 0;
    DWORD dwDestAceType = 0;

    DWORD dwSrcFlags  = 0;
    DWORD dwDestFlags = 0;

    BSTR bstrSrcObjectType = NULL;
    BSTR bstrDestObjectType = NULL;

    BSTR bstrSrcInherObjType = NULL;
    BSTR bstrDestInherObjType = NULL;

    BOOL dwRet = FALSE;

    hr = pSourceAce->get_Trustee(&bstrSrcTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_Trustee(&bstrDestTrustee);
    BAIL_ON_FAILURE(hr);

    if (!EquivalentStrings(bstrSrcTrustee, bstrDestTrustee)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = pSourceAce->get_AccessMask((long *)&dwSrcMask);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_AccessMask((long *)&dwDestMask);
    BAIL_ON_FAILURE(hr);

    if (dwSrcMask != dwDestMask) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = pSourceAce->get_AceFlags((long *)&dwSrcAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_AceFlags((long *)&dwDestAceFlags);
    BAIL_ON_FAILURE(hr);

    if (dwSrcAceFlags != dwDestAceFlags) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = pSourceAce->get_AceType((long *)&dwSrcAceType);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_AceType((long *)&dwDestAceType);
    BAIL_ON_FAILURE(hr);

    if (dwSrcAceType != dwDestAceType) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = pSourceAce->get_Flags((long *)&dwSrcFlags);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_Flags((long *)&dwDestFlags);
    BAIL_ON_FAILURE(hr);

    if (dwSrcFlags != dwDestFlags) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = pSourceAce->get_ObjectType(&bstrSrcObjectType);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_ObjectType(&bstrDestObjectType);
    BAIL_ON_FAILURE(hr);

    if (!EquivalentStrings(bstrSrcObjectType, bstrDestObjectType)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }



    hr = pSourceAce->get_InheritedObjectType(&bstrSrcInherObjType);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_InheritedObjectType(&bstrDestInherObjType);
    BAIL_ON_FAILURE(hr);

    if (!EquivalentStrings(bstrSrcInherObjType, bstrDestInherObjType)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    dwRet = TRUE;

cleanup:

    if (bstrSrcTrustee) {
        ADsFreeString(bstrSrcTrustee);
    }

    if (bstrDestTrustee) {
        ADsFreeString(bstrDestTrustee);
    }

    if (bstrSrcObjectType) {
        ADsFreeString(bstrSrcObjectType);
    }

    if (bstrDestObjectType) {
        ADsFreeString(bstrDestObjectType);
    }

    if (bstrSrcInherObjType) {
        ADsFreeString(bstrSrcInherObjType);
    }

    if (bstrDestInherObjType) {
        ADsFreeString(bstrDestInherObjType);
    }

    return(dwRet);

error:

    dwRet = FALSE;

    goto cleanup;
}


void
CAccessControlList::
AdjustCurPtrOfEnumerators(
    DWORD dwPosNewOrDeletedACE,
    BOOL  fACEAdded
    )
{
    PACL_ENUM_ENTRY pACLEnum = _pACLEnums;
    CAccCtrlListEnum * pEnum = NULL;
    BOOL fOk = FALSE;


    if (fACEAdded) {

        while (pACLEnum) {

            pEnum = pACLEnum->pACLEnum;
            ADsAssert(pEnum);

            //
            // NOTE: - Problem may occur in multithreaded model (manipulation
            //       on the enumerator & the actual ACL in two threads).
            //       - ADSI CLIENTS should use critical section protection, as
            //       with property cache.
            //

            if (dwPosNewOrDeletedACE <= pEnum->GetCurElement()) {
                //
                // the new ACE is added in front of the last ACE enumerated
                // so, increment the position of the last enumerated element
                // by one

                fOk = pEnum->IncrementCurElement();

                ADsAssert(fOk);     // should be within bound after increment;
                                    // otherwise, coding error
            }

            // else {

                //
                // the new ACE is added after the last ACE enumerated, so
                // no effect on the position of the last enumerated element
                //
            // }

            pACLEnum=pACLEnum->pNext;
        }

    } else {    // ACE deleted

        while (pACLEnum) {

            pEnum = pACLEnum->pACLEnum;
            ADsAssert(pEnum);

            //
            // NOTE: - Problem may occur in multithreaded model (manipulation
            //       on the enumerator & the actual ACL in two threads).
            //       - ADSI CLIENTS should use critical section protection,
            //       as with property cache.
            //

            if ( dwPosNewOrDeletedACE <= pEnum->GetCurElement() )  {

                //
                // the ACE deleted is in front of, or is, the last ACE
                // enumerated, so decrement the position of the last
                // enumerated element by one

                fOk = pEnum->DecrementCurElement();

                ADsAssert(fOk);     // should be within bound after decrement;
                                    // otherwise, coding error
            }

            // else {

                //
                // the new ACE deleted is after the last ACE enumerated, so
                // no effect on the position of the last enumerated element
                //
            // }

            pACLEnum=pACLEnum->pNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cace.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cAccessControlEntry.cxx
//
//  Contents:  AccessControlEntry object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CAccessControlEntry

DEFINE_IDispatch_Implementation(CAccessControlEntry)

CAccessControlEntry::CAccessControlEntry():
        _pDispMgr(NULL),
        _dwAceType(0),
        _dwAccessMask(0),
        _dwAceFlags(0),
        _dwFlags(0),
        _lpObjectType(NULL),
        _lpInheritedObjectType(NULL),
        _lpTrustee(NULL),
        _pSid(NULL),
        _dwSidLen(0)
{
    ENLIST_TRACKING(CAccessControlEntry);
}


HRESULT
CAccessControlEntry::CreateAccessControlEntry(
    REFIID riid,
    void **ppvObj
    )
{
    CAccessControlEntry FAR * pAccessControlEntry = NULL;
    HRESULT hr = S_OK;

    hr = AllocateAccessControlEntryObject(&pAccessControlEntry);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pAccessControlEntry->Release();

    RRETURN(hr);

error:
    delete pAccessControlEntry;

    RRETURN_EXP_IF_ERR(hr);

}


CAccessControlEntry::~CAccessControlEntry( )
{
    delete _pDispMgr;
    if (_lpInheritedObjectType) {
        FreeADsStr(_lpInheritedObjectType);
        _lpInheritedObjectType = NULL;
    }
    if (_lpObjectType) {
        FreeADsStr(_lpObjectType);
        _lpObjectType = NULL;
    }
    if (_lpTrustee) {
        FreeADsStr(_lpTrustee);
    }
    if (_pSid) {
        FreeADsMem(_pSid);
    }

}

STDMETHODIMP
CAccessControlEntry::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsAccessControlEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAccessControlEntry))
    {
        *ppv = (IADsAccessControlEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsAccessControlEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAcePrivate)) {
        *ppv = (IADsAcePrivate FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CAccessControlEntry::AllocateAccessControlEntryObject(
    CAccessControlEntry ** ppAccessControlEntry
    )
{
    CAccessControlEntry FAR * pAccessControlEntry = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pAccessControlEntry = new CAccessControlEntry();
    if (pAccessControlEntry == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsAccessControlEntry,
                (IADsAccessControlEntry *)pAccessControlEntry,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pAccessControlEntry->_pDispMgr = pDispMgr;
    *ppAccessControlEntry = pAccessControlEntry;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}


//
// ISupportErrorInfo method
//
STDMETHODIMP
CAccessControlEntry::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsAccessControlEntry)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//
// IADsAccessControlEntry implementation
//

STDMETHODIMP
CAccessControlEntry::get_AceType(THIS_ long FAR * retval)
{
    *retval = _dwAceType;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::put_AceType(THIS_ long  lnAceType)
{
    _dwAceType = lnAceType;

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::get_AceFlags(THIS_ long FAR * retval)
{
    *retval = _dwAceFlags;

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::put_AceFlags(THIS_ long lnAceFlags)
{
    _dwAceFlags = lnAceFlags;

    RRETURN(S_OK);
}


STDMETHODIMP
CAccessControlEntry::get_Flags(THIS_ long FAR * retval)
{
    *retval = _dwFlags;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::put_Flags(THIS_ long  lnFlags)
{
    _dwFlags = lnFlags;

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::get_AccessMask(THIS_ long FAR * retval)
{

    *retval = (long)_dwAccessMask;

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::put_AccessMask(THIS_ long lnAccessMask)
{
    _dwAccessMask = (DWORD)lnAccessMask;

    RRETURN(S_OK);
}


STDMETHODIMP
CAccessControlEntry::get_ObjectType(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectType, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAccessControlEntry::put_ObjectType(THIS_ BSTR bstrObjectType)
{

    if (_lpObjectType) {
        FreeADsStr(_lpObjectType);
        _lpObjectType = NULL;
    }

    if (bstrObjectType) {

        _lpObjectType = AllocADsStr(bstrObjectType);

        if (!_lpObjectType) {
            RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
        }

    }
    RRETURN(S_OK);
}


STDMETHODIMP
CAccessControlEntry::get_InheritedObjectType(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpInheritedObjectType, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAccessControlEntry::put_InheritedObjectType(THIS_ BSTR bstrInheritedObjectType)
{
    if (_lpInheritedObjectType) {
        FreeADsStr(_lpInheritedObjectType);
        _lpInheritedObjectType = NULL;
    }

    if (bstrInheritedObjectType) {
        _lpInheritedObjectType = AllocADsStr(bstrInheritedObjectType);

        if (!_lpInheritedObjectType) {
            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::get_Trustee(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpTrustee, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAccessControlEntry::put_Trustee(THIS_ BSTR bstrTrustee)
{

    if (!bstrTrustee) {
        RRETURN(E_FAIL);
    }

    if (_lpTrustee) {
        FreeADsStr(_lpTrustee);
    }

    //
    // Since we are changing the trustee, we need to make
    // sure the sid value is cleared.
    //
    if (_dwSidLen) {
        _dwSidLen = 0;
    }

    if (_pSid) {
        FreeADsMem(_pSid);
        _pSid = NULL;
    }

    _lpTrustee = AllocADsStr(bstrTrustee);

    if (!_lpTrustee) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}


HRESULT
CopyAccessControlEntry(
    IADsAccessControlEntry * pSourceAce,
    IADsAccessControlEntry ** ppTargetAce
    )
{
    IADsAccessControlEntry * pTargetAce = NULL;
    IADsAcePrivate *pPrivAceTarget = NULL;
    IADsAcePrivate *pPrivAceSource = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;
    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrTrustee = NULL;
    HRESULT hr = S_OK;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwFlags = 0;
    DWORD dwSidLen = 0;
    BOOL fSidValid = FALSE;
    PSID pSid = NULL;

    hr = pSourceAce->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_Flags((LONG *)&dwFlags);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_ObjectType(&bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pTargetAce
                );
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_AccessMask(dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_AceFlags(dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_AceType(dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_Trustee(bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_Flags((LONG)dwFlags);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_ObjectType(bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_InheritedObjectType(bstrInheritedObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->QueryInterface(
             IID_IADsAcePrivate,
             (void **) &pPrivAceTarget
             );

    if (SUCCEEDED(hr)) {
        hr = pSourceAce->QueryInterface(
                 IID_IADsAcePrivate,
                 (void **) &pPrivAceSource
                 );

        if (SUCCEEDED(hr)) {
            hr = pPrivAceSource->isSidValid(&fSidValid);

            if (SUCCEEDED(hr) && fSidValid) {
                //
                // Get the sid and try putting it.
                //
                hr = pPrivAceSource->getSid(
                         &pSid,
                         &dwSidLen
                         );

                if (SUCCEEDED(hr)) {
                    pPrivAceTarget->putSid(
                        pSid,
                        dwSidLen
                        );
                }
            }
        }
    }

    *ppTargetAce =  pTargetAce;

error:

    if (bstrTrustee) {
        ADsFreeString(bstrTrustee);
    }

    if (bstrObjectTypeClsid) {
        ADsFreeString(bstrObjectTypeClsid);
    }

    if (bstrInheritedObjectTypeClsid) {
        ADsFreeString(bstrInheritedObjectTypeClsid);
    }

    if (pPrivAceTarget) {
        pPrivAceTarget->Release();
    }

    if (pPrivAceSource) {
        pPrivAceSource->Release();
    }

    if (pSid) {
        FreeADsMem(pSid);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//
// IADsAcePrivate methods.
//

//+---------------------------------------------------------------------------
// Function:   CAccessControlEntry::getSid  - IADsAcePrivate method.
//
// Synopsis:   Returns the SID associated with the trustee on this ACE
//          object assuming there is one that is correct.
//          
// Arguments:  ppSid              -   Return pointer to SID.
//             pdwLength          -   Return lenght of the SID.
//
// Returns:    S_OK or appropriate failure error code.
//
// Modifies:   ppSid and pdwLength
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccessControlEntry::getSid(
    OUT PSID *ppSid,
    OUT DWORD *pdwLength
    ) 
{
    HRESULT hr = S_OK;
    PSID pSid = NULL;

    if (!ppSid || !pdwLength) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }
    if (!_pSid) {
        //
        // This means that the there is no usable value for the sid.
        //
        RRETURN(E_FAIL);
    }

    pSid = (PSID) AllocADsMem(_dwSidLen);
    
    if (!pSid) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pSid, _pSid, _dwSidLen);

    *pdwLength = _dwSidLen;

    *ppSid = pSid;

error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CAccessControlEntry::putSid  - IADsAcePrivate method.
//
// Synopsis:   Updates the SID associated with the trustee on this Ace 
//          object to the value specified.
//          
// Arguments:  PSID              -   Pointer to SID.
//             dwLength          -   Lenght of the SID.
//
// Returns:    S_OK on success or E_ADS_BAD_PARAMETER, E_OUTOFMEMORY 
//          on failure.
//
// Modifies:   _pSid and _dwSidLen.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccessControlEntry::putSid(
    IN PSID pSid,
    IN DWORD dwLength
    )
{
    HRESULT hr = S_OK;
    PSID pLocalSid = NULL;

    if (dwLength && !pSid) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    if (_pSid) {
        FreeADsMem(_pSid);
        _pSid = NULL;
        _dwSidLen = 0;
    }

    if (dwLength) {
        //
        // pSid also has to be valid at this point
        //
        _pSid = (PSID) AllocADsMem(dwLength);
        if (!_pSid) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(_pSid, pSid, dwLength);

        _dwSidLen = dwLength;
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CAccessControlEntry::isSidValid  - IADsAcePrivate method.
//
// Synopsis:   Returns status of the sid associated with this ACE's trustee.
//          
// Arguments:  pfSidValid       -   Return value.
//
// Returns:    S_OK or E_ADS_BAD_PARAMETER.
//
// Modifies:   pfSidValid set to TRUE or FALSE as appropriate.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccessControlEntry::isSidValid(
    OUT BOOL *pfSidValid
    )
{
    if (!pfSidValid) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    //
    // If the Sid length is zero, then there is no sid for trustee.
    //
    *pfSidValid = (_dwSidLen != 0);
    RRETURN(S_OK);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\ccolinfo.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccolinfo.cxx
//
//  Contents:  IColumnsInfo implementation for LDAP rowsets
//
//
//  History:   07/10/96   RenatoB    Created, lifted  from EricJ code
//
//------------------------------------------------------------------------------


// Includes
#include "oleds.hxx"


//-----------------------------------------------------------------------------
// CLdap_ColumnsInfo object
//
// This object is just a wrapper for the CColInfo object.
// It is separate because of refcount usage.
// (It is also shared by Command and Rowset objects.)
//
// - Delegate QI, AddRef, Release to CLdap_RowProvider.
// - Delegate IColumnsInfo functions to CColInfo.
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Function:  CLdap_ColumnsInfo::CLdap_ColumnsInfo
//
//  Synopsis:  @mfunc Ctor
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//
//  Modifies:
//
//  History:    07/10/96   RenatoB          Created
//
//----------------------------------------------------------------------------

PUBLIC
CLdap_ColumnsInfo::CLdap_ColumnsInfo(
    CLdap_RowProvider * pObj)            // @parm IN |
{
    m_pObj        = pObj;
};



//+---------------------------------------------------------------------------
//
//  Function:  CLdap_ColumnsInfo::FInit
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    07/10/96   RenatoB          Created
//
//----------------------------------------------------------------------------
PUBLIC STDMETHODIMP
CLdap_ColumnsInfo::FInit(
    ULONG cColumns,
    DBCOLUMNINFO *rgInfo,
    OLECHAR *pStringsBuffer
    )
{
    ULONG cChars;
    ULONG cCharDispl;
    ULONG i;
    HRESULT hr;
    void* Null1 = NULL;
    void* Null2 = NULL;

    m_ColInfo = NULL;
    m_pwchBuf = NULL;

    hr = CoGetMalloc(
             MEMCTX_TASK,
             &m_pMalloc);

    if (! SUCCEEDED(hr)) {
        goto error;
    }

    m_cColumns= cColumns;

    Null1 = m_pMalloc->Alloc(
                 cColumns*sizeof(DBCOLUMNINFO)
                 );
    if (Null1 == NULL)
        goto error;

    memset(Null1, 0, cColumns*sizeof(DBCOLUMNINFO));

    memcpy( (void*) Null1, (void*) rgInfo, cColumns*sizeof(DBCOLUMNINFO));
    m_ColInfo = (DBCOLUMNINFO*) Null1;

    cChars= m_pMalloc->GetSize(pStringsBuffer);
    Null2 = m_pMalloc->Alloc(cChars);
    if (Null2 == NULL)
        goto error;

    memset(Null2, 0, cChars);
    memcpy( (void*) Null2, (void*)pStringsBuffer , cChars);
    m_pwchBuf= (OLECHAR*) Null2;

    for (i=0; i<m_cColumns; i++) {
        cCharDispl = rgInfo[i].pwszName - pStringsBuffer;
        m_ColInfo[i].pwszName = m_pwchBuf+ cCharDispl;
    };

    RRETURN(S_OK);

error:
    if (m_ColInfo != NULL)
        m_pMalloc->Free(m_ColInfo);
    if (m_pwchBuf != NULL)
        m_pMalloc->Free(m_pwchBuf);

    m_ColInfo = NULL;
    m_pwchBuf = NULL;
    m_cColumns = 0;

    m_pMalloc->Release();

    RRETURN(E_FAIL);

}


//+---------------------------------------------------------------------------
//
//  Function:  CLdap_ColumnsInfo::~CLdap_ColumnsInfo
//
//  Synopsis:  @mfunc Dtor
//
//  Arguments:
//
//  Returns:  @rdesc NONE
//
//  Modifies:
//
//  History:    07/10/96   RenatoB          Created
//
//----------------------------------------------------------------------------

PUBLIC CLdap_ColumnsInfo::~CLdap_ColumnsInfo()
{

    //
    // Assume we are only being called by CLdap_RowProvider
    // (i.e. backpointer) therefore we don't delete.
    // Delete m_ColInfo, m_CharBuf, and release the memory allocator
    //
    if (m_pMalloc != NULL) {
        if (m_ColInfo != NULL)
            m_pMalloc->Free(m_ColInfo);

        if (m_pwchBuf != NULL)
            m_pMalloc->Free(m_pwchBuf);

        m_pMalloc->Release();
    }

}


//+---------------------------------------------------------------------------
//
//  Function:  CLdap_ColumnsInfo::QueryInterface
//
//  Synopsis:  @mfunc QueryInterface.
//             We delegate to the CLdap_RowProvider.
//
//             Called by: Client.
//             Called when: Any time.
//
//  Arguments:
//
//  Returns:   @rdesc HRESULT
//
//  Modifies:
//
//  History:    07/10/96   RenatoB          Created
//
//----------------------------------------------------------------------------

PUBLIC STDMETHODIMP
CLdap_ColumnsInfo::QueryInterface(
    REFIID riid,        // IN | Interface ID of the interface being queried for
    LPVOID * ppv        // OUT | Pointer to interface that was instantiated
    )
{
    return m_pObj->QueryInterface(riid, ppv);
}


//+---------------------------------------------------------------------------
//
//  Function:  CLdap_ColumnsInfo::AddRef
//
//  Synopsis:  @mfunc AddRef.
//             We delegate to the CLdap_RowProvider.
//
//             Called by: Client.
//             Called when: Any time.
//
//  Arguments:
//
//  Returns:   @rdesc Refcount
//
//  Modifies:
//
//  History:    07/10/96   RenatoB          Created
//
//----------------------------------------------------------------------------

PUBLIC STDMETHODIMP_(ULONG) CLdap_ColumnsInfo::AddRef()
{
    return m_pObj->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Function:  CLdap_ColumnsInfo::Release
//
//  Synopsis:  @mfunc Release.
//             We delegate to the CLdap_RowProvider.
//
//             Called by: Client.
//             Called when: Any time.
//
//  Arguments:
//
//  Returns:   @rdesc Refcount
//
//  Modifies:
//
//  History:    07/10/96   RenatoB          Created
//
//----------------------------------------------------------------------------

PUBLIC STDMETHODIMP_(ULONG) CLdap_ColumnsInfo::Release()
{
    return m_pObj->Release();
}


//+---------------------------------------------------------------------------
//
//  Function:  CLdap_ColumnsInfo::GetColumnInfo
//
//  Synopsis:  @mfunc Get Column Info.
//             Delegate.
//
//             @rdesc See CColInfo::GetColumnInfo.
//
//  Arguments:
//
//  Returns:   @rdesc See CColInfo::GetColumnInfo.
//
//  Modifies:
//
//  History:    07/10/96   RenatoB          Created
//
//----------------------------------------------------------------------------

PUBLIC STDMETHODIMP
CLdap_ColumnsInfo::GetColumnInfo(
    DBORDINAL *pcColumns,        //@parm OUT | .
    DBCOLUMNINFO **prgInfo,      //@parm OUT | .
    WCHAR **ppStringsBuffer      //@parm OUT | .
    )
{

    ULONG i, cChars, cCharDispl;
    HRESULT hr= S_OK;
    void* Null1 = NULL;
    void* Null2 = NULL;

    if ((pcColumns == NULL ) || (prgInfo == NULL) || (ppStringsBuffer == NULL))
        BAIL_ON_FAILURE(hr=E_INVALIDARG);

    *pcColumns= m_cColumns;
    Null1 = m_pMalloc->Alloc(m_cColumns*sizeof(DBCOLUMNINFO));
    if (Null1 == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    };
    memset(Null1, 0, m_cColumns*sizeof(DBCOLUMNINFO));
    memcpy( (void*) Null1, (void*) m_ColInfo,m_cColumns*sizeof(DBCOLUMNINFO));
    *prgInfo = (DBCOLUMNINFO*) Null1;

    cChars= m_pMalloc->GetSize(m_pwchBuf);
    Null2 = m_pMalloc->Alloc(cChars);
    if (Null2 == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    };

    memset(Null2, 0, cChars);
    memcpy( (void*) Null2, (void*)m_pwchBuf , cChars);
    *ppStringsBuffer= (OLECHAR*) Null2;

    for (i=0; i<m_cColumns; i++) {
        cCharDispl = m_ColInfo[i].pwszName - m_pwchBuf;
        (*prgInfo)[i].pwszName =(*ppStringsBuffer) + cCharDispl;
    };

    RRETURN(hr);

error:
    if (Null1 != NULL)
        m_pMalloc->Free(Null1);
    if (Null2 != NULL)
        m_pMalloc->Free(Null2);

    *prgInfo = NULL;
    *ppStringsBuffer = NULL;
    *pcColumns= 0;

    RRETURN(hr);

};


//+---------------------------------------------------------------------------
//
//  Function:  CLdap_ColumnsInfo::MapColumnIDs
//
//  Synopsis:  @mfunc Map Column IDs.
//             Just delegate to the CColInfo object we have.
//
//             @rdesc See CColInfo::MapColumnIDs.
//
//  Arguments:
//
//  Returns:   @rdesc See CColInfo::MapColumnIDs
//
//  Modifies:
//
//  History:    07/10/96   RenatoB          Created
//
//----------------------------------------------------------------------------

PUBLIC STDMETHODIMP
CLdap_ColumnsInfo::MapColumnIDs(
    DBORDINAL cColumnIDs,        //@parm IN | .
    const DBID rgColumnIDs[],    //@parm IN | .
    DBORDINAL rgColumns[]        //@parm INOUT | .
    )
{
    // It is a logical (programming) error to fail here.
    // this data must have already been established.

    // Delegate the actual work.
    ULONG found = 0;
    DBORDINAL  i;

    if (cColumnIDs == 0)
        RRETURN(S_OK);

    if (rgColumnIDs == NULL || rgColumns == NULL)
        RRETURN(E_INVALIDARG);

    for (i=0; i<cColumnIDs; i++) {
        if (rgColumnIDs[i].eKind!= DBKIND_PROPID) {
            found = 1;
            rgColumns[i]= DB_INVALIDCOLUMN;
        }
        else {
            if ((rgColumnIDs[i].uName.ulPropid > 3) ||
                (rgColumnIDs[i].uName.ulPropid<2)) {
                found = 1;
                rgColumns[i]= DB_INVALIDCOLUMN;
            }
            else rgColumns[i] = rgColumnIDs[i].uName.ulPropid -2;
        }
    }

    if (found == 1)
        RRETURN(DB_S_ERRORSOCCURRED);
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cdnbin.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:  CDNWithBinary.cxx
//
//  Contents:  DNWithBinary object
//
//  History:   4-23-99     AjayR    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CDNWithBinary

DEFINE_IDispatch_Implementation(CDNWithBinary)

CDNWithBinary::CDNWithBinary():
        _pDispMgr(NULL),
        _pszDNStr(NULL),
        _dwLength(0),
        _lpOctetStr(NULL)
{
    ENLIST_TRACKING(CDNWithBinary);
}


HRESULT
CDNWithBinary::CreateDNWithBinary(
    REFIID riid,
    void **ppvObj
    )
{
    CDNWithBinary FAR * pDNWithBinary = NULL;
    HRESULT hr = S_OK;

    hr = AllocateDNWithBinaryObject(&pDNWithBinary);
    BAIL_ON_FAILURE(hr);

    hr = pDNWithBinary->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pDNWithBinary->Release();

    RRETURN(hr);

error:
    delete pDNWithBinary;

    RRETURN_EXP_IF_ERR(hr);

}


CDNWithBinary::~CDNWithBinary( )
{
    delete _pDispMgr;

    if (_lpOctetStr) {
        FreeADsMem(_lpOctetStr);
    }

    if (_pszDNStr) {
        FreeADsStr(_pszDNStr);
    }
}

STDMETHODIMP
CDNWithBinary::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsDNWithBinary FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDNWithBinary))
    {
        *ppv = (IADsDNWithBinary FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsDNWithBinary FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CDNWithBinary::AllocateDNWithBinaryObject(
    CDNWithBinary ** ppDNWithBinary
    )
{
    CDNWithBinary FAR * pDNWithBinary = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pDNWithBinary = new CDNWithBinary();
    if (pDNWithBinary == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsDNWithBinary,
                (IADsDNWithBinary *)pDNWithBinary,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pDNWithBinary->_pDispMgr = pDispMgr;
    *ppDNWithBinary = pDNWithBinary;

    RRETURN(hr);

error:

    delete pDNWithBinary;
    delete pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CDNWithBinary::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsDNWithBinary)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//
// Methods to get and put the octet string part.
//

STDMETHODIMP
CDNWithBinary::get_BinaryValue(THIS_ VARIANT FAR* pvBinaryValue)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    /*
    if (!pvBinaryValue) {
    }
        RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);
    }
    */

    aBound.lLbound = 0;
    aBound.cElements = _dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, _lpOctetStr, aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pvBinaryValue) = VT_ARRAY | VT_UI1;
    V_ARRAY(pvBinaryValue) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}


STDMETHODIMP
CDNWithBinary::put_BinaryValue(THIS_ VARIANT vBinaryValue)
{
    HRESULT hr = S_OK;
    VARIANT *pvProp = NULL;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    //
    // Check for variant by ref.
    //
    pvProp = &vBinaryValue;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vBinaryValue);
    }

    if (_lpOctetStr) {
        FreeADsMem(_lpOctetStr);
        _lpOctetStr = NULL;
        _dwLength = 0;
    }

    if( pvProp->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_BAD_PARAMETER);
    }

    hr = SafeArrayGetLBound(
             V_ARRAY(pvProp),
             1,
             (long FAR *) &dwSLBound
             );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
             V_ARRAY(pvProp),
             1,
             (long FAR *) &dwSUBound
             );
    BAIL_ON_FAILURE(hr);

    _dwLength = dwSUBound -dwSLBound + 1;

    _lpOctetStr = (LPBYTE) AllocADsMem(_dwLength);

    if (!_lpOctetStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData(
             V_ARRAY(pvProp),
             (void HUGEP * FAR *) &pArray
             );
    BAIL_ON_FAILURE(hr);

    memcpy(_lpOctetStr, pArray, _dwLength);

    SafeArrayUnaccessData( V_ARRAY(pvProp) );

error:

    if (_lpOctetStr && FAILED(hr)) {
        FreeADsMem(_lpOctetStr);
        _lpOctetStr = NULL;
        _dwLength = NULL;
    }

    RRETURN(hr);

}


//
// Methods to get and put the DN string.
//

STDMETHODIMP
CDNWithBinary::get_DNString(THIS_ BSTR FAR* pbstrDNString)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = ValidateOutParameter(pbstrDNString))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_pszDNStr, pbstrDNString);

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CDNWithBinary::put_DNString(THIS_ BSTR bstrDNString)
{

    HRESULT hr = S_OK;

    if (_pszDNStr) {
        FreeADsStr(_pszDNStr);
        _pszDNStr = NULL;
    }

    _pszDNStr = AllocADsStr(bstrDNString);

    if (bstrDNString && !_pszDNStr) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cadssec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cadssec.cxx
//
//  Contents: This file contains the support ADsSecurityUtility class
//          implementation and the support routines it requires. The
//          default interface for the ADsSecurityClassUtility class
//          is IADsSecurityUtility. 
//
//  History:    10-11-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"

//
// Helper functions.
//

//+---------------------------------------------------------------------------
// Function:   GetServerAndResource - Helper routine.
//
// Synopsis:   Splits the string into a serverName piece and rest piece.
//          This is used for fileshare paths like \\Computer\share to return
//          \\computer and share. In the case of registry a string like
//          \\Computer\HKLM\Microsoft will be split into \\Computer and
//          HKLM\Microsoft. if there is no computer name specified, then
//          the serverName will be NULL.
//
// Arguments:  pszName           -   Name to be split.
//             ppszServer        -   Return value for server name.
//             ppszResource      -   Return value for rest of string.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSD and pdwLength on success.
//
//----------------------------------------------------------------------------
HRESULT
GetServerAndResource(
    LPWSTR pszName,
    LPWSTR *ppszServer,
    LPWSTR *ppszResource
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = wcslen(pszName);
    LPWSTR pszTemp = pszName;
    LPWSTR pszServer = NULL;
    LPWSTR pszResource = NULL;
    DWORD dwLen = 0;
    BOOL fNoServer = FALSE;

    *ppszServer = NULL;
    *ppszResource = NULL;

    //
    // If we have just 1 \ or no \'s there is no server name.
    //
    if ((dwLength < 2)
        || (pszName[0] != L'\\') 
        || (pszName[1] != L'\\')
        ) {
        fNoServer = TRUE;
    }
    
    if (fNoServer) {
        //
        // Name is the entire string passed in.
        //
        pszResource = AllocADsStr(pszName);
        if (!pszResource) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        *ppszResource = pszResource;
        RRETURN(hr);
    }

    //
    // Make sure that the first 2 chars are \\
    //
    if (pszTemp[0] != L'\\'
        || pszTemp[1] != L'\\' )
         {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
   
    pszTemp += 2;

    while (pszTemp && *pszTemp != L'\\') {
        dwLen++;
        pszTemp++;
    }

    if (!pszTemp 
        || !*pszTemp
        || !dwLen
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    dwLen += 2; // the 2 \\ in the serverName
    
    //
    // Advance past the \ in \\testShare\FileShare.
    //
    pszTemp++;
    if (!pszTemp || !*pszTemp) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG)
    }

    //
    // If we get here we have valid server and share names.
    //
    pszServer = (LPWSTR) AllocADsMem((dwLen+1) * sizeof(WCHAR));
    if (!pszServer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wcsncpy(pszServer, pszName, dwLen);

    pszResource = AllocADsStr(pszTemp);
    if (!pszResource) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    *ppszServer = pszServer;
    *ppszResource = pszResource;

error:

    if (FAILED(hr)) {
        if (pszResource) {
            FreeADsMem(pszResource);
        }

        if (pszServer) {
            FreeADsMem(pszServer);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetKeyRootAndSubKey - Helper routine.
//
// Synopsis:   Gets the root (such as HKLM) from the registry key path. This
//          is needed when we open a handle to the key. The rest of the path
//          constitutes the SubKey name.
//
// Arguments:  pszKeyName        -   Name of the key we need to open.
//             ppszSubKey        -   Return value for the subKey
//             phKey             -   Return value for key root to open.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   phKey, NULL on failure and one of 
//                  HKEY_USERS, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG,
//                  HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT
//                  or HKEY_PERFORMANCE_DATA on success.
//
//----------------------------------------------------------------------------
HRESULT 
GetKeyRootAndSubKey(
    LPWSTR pszKeyName,
    LPWSTR * ppszSubKey,
    HKEY * phKey
    )
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    LPWSTR pszRoot = NULL;
    LPWSTR pszTemp = pszKeyName;
    LPWSTR pszSubKey = NULL;
    DWORD dwLen = 0;

    *phKey = NULL;
    *ppszSubKey = NULL;

    while (pszTemp 
           && *pszTemp 
           && *pszTemp != L'\\') {
        dwLen++;
        pszTemp++;
    }

    //
    // If the length is less than 3 something is wrong.
    //
    if ((dwLen < 3)
        || !pszTemp
        || !*pszTemp
        ) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // To get the subkey, we need to move past the \.
    //
    pszTemp++;
    if (pszTemp && *pszTemp) {
        pszSubKey = AllocADsStr(pszTemp);
        if (!pszSubKey) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    pszRoot = (LPWSTR) AllocADsMem((dwLen+1) * sizeof(WCHAR));
    if (!pszRoot) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Copy over the root so we can use it in the subsequent comparisions.
    //
    wcsncpy(pszRoot, pszKeyName, dwLen);

    if (_wcsicmp( pszRoot, L"HKEY_CLASSES_ROOT") == 0
         || _wcsicmp( pszRoot, L"HKCR") == 0
        ) {
        hKey = HKEY_CLASSES_ROOT;
    }
    else if (_wcsicmp( pszRoot, L"HKEY_LOCAL_MACHINE") == 0
             || _wcsicmp( pszRoot, L"HKLM") == 0
             ) {
        hKey = HKEY_LOCAL_MACHINE;
    }
    else if (_wcsicmp(pszRoot, L"HKEY_CURRENT_CONFIG") == 0
             || _wcsicmp(pszRoot, L"HKCC") == 0
             ) {
        hKey = HKEY_CURRENT_CONFIG;
    }
    else if (_wcsicmp(pszRoot, L"HKEY_CURRENT_USER" ) == 0
             || _wcsicmp( pszRoot, L"HKCU") == 0 
             ) {
        hKey = HKEY_CURRENT_USER;
    }
    else if (_wcsicmp(pszRoot, L"HKEY_USERS") == 0
             || _wcsicmp(pszRoot, L"HKU")
             ) {
        hKey = HKEY_USERS;
    }
    else if ( _wcsicmp(pszRoot, L"HKEY_PERFORMANCE_DATA") == 0) {
        hKey = HKEY_PERFORMANCE_DATA;
    } 
    else {
        //
        // Has to be one of the above.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }
        
    *phKey = hKey;
    *ppszSubKey = pszSubKey;

error:

    if (pszRoot) {
        FreeADsStr(pszRoot);
    }

    if (FAILED(hr) && pszSubKey) {
        FreeADsStr(pszSubKey);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertRawSDToBinary - Helper routine.
//
// Synopsis:   Converts the binary SD to a VT_UI1 | VT_ARRAY.
//
// Arguments:  pSecurityDescriptor   -   Binary sd to convert.
//             dwLength              -   Length of SD.
//             pVariant              -   Return value.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pVariant to point to IID_IADsSecurityDescriptor on success.
//
//----------------------------------------------------------------------------
HRESULT
ConvertRawSDToBinary(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwLength,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY * aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    
    aBound.lLbound = 0;
    aBound.cElements = dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );
    if (!aList) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, pSecurityDescriptor, aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVariant) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVariant) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertRawSDToHexString - Helper routine.
//
// Synopsis:   Converts the binary SD to a VT_BSTR in hex string format.
//
// Arguments:  pSecurityDescriptor   -   Binary sd to convert.
//             dwLength              -   Length of SD.
//             pVariant              -   Return value for VT_BSTR.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pVariant to point to IID_IADsSecurityDescriptor on success.
//
//----------------------------------------------------------------------------
HRESULT
ConvertRawSDToHexString(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwLength,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszHexStr = NULL;
    BSTR bstrHexSD = NULL;
    WCHAR szSmallStr[10];
    
    pszHexStr = (LPWSTR) AllocADsMem((dwLength+1) * 2 * sizeof(WCHAR));
    if (!pszHexStr) {
        BAIL_ON_FAILURE(hr);
    }

    for (DWORD dwCtr = 0; dwCtr < dwLength; dwCtr++) {
        wsprintf(
            szSmallStr,
            L"%02x",
            ((BYTE*)pSecurityDescriptor)[dwCtr]
            );
        wcscat(pszHexStr, szSmallStr);
    }

    hr = ADsAllocString(pszHexStr, &bstrHexSD);

    if (SUCCEEDED(hr)) {
        pVariant->vt = VT_BSTR;
        pVariant->bstrVal = bstrHexSD;
    }

error:

    if (pszHexStr) {
        FreeADsMem(pszHexStr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertHexSDToRawSD - Helper routine.
//
// Synopsis:   Converts the hex string SD to a binary SD.
//
// Arguments:  pVarHexSD             -   Variant with hex string.
//             ppSecurityDescriptor  -   Return value for binary SD
//             pdwLength             -   Return value for length of SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSecurityDescriptor and pdwLength updated accordingly.
//
//----------------------------------------------------------------------------
HRESULT
ConvertHexSDToRawSD(
    PVARIANT pVarHexSD,
    PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    DWORD *pdwLength
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszHexSD = V_BSTR(pVarHexSD);
    DWORD dwLen;
    LPBYTE lpByte = NULL;

    *ppSecurityDescriptor = NULL;
    *pdwLength = 0;

    if (!pszHexSD
        || ((dwLen = wcslen(pszHexSD)) == 0)
        ) {
        //
        // NULL SD.
        //
        RRETURN(S_OK);
    }

    dwLen = wcslen(pszHexSD);

    //
    // Length has to be even.
    //
    if (((dwLen/2) * 2) != dwLen) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    dwLen /= 2;

    if (dwLen) {
        
        lpByte = (LPBYTE) AllocADsMem(dwLen);
        if (!lpByte) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        //
        // Go through and read one 2 hex chars at a time.
        //
        for (
             DWORD dwCtr = 0;
             (dwCtr < dwLen) && (pszHexSD && *pszHexSD);
             dwCtr++ ) {

            DWORD dwCount, dwHexVal;
            dwCount = swscanf(pszHexSD, L"%02x", &dwHexVal);
            
            //
            // The read has to be successful and the data valid.
            //
            if (dwCount != 1) {
                BAIL_ON_FAILURE(hr = E_FAIL);
            }

            //
            // Make sure that the value is in the correct range.
            //
            if (dwHexVal & (0xFFFFFF00)) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            lpByte[dwCtr] = (BYTE) dwHexVal;

            pszHexSD++;
            if (!pszHexSD) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            pszHexSD++;
        } // for loop

        //
        // The sd translation was succesful.
        //
        *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR)(LPVOID) lpByte;
        *pdwLength = dwLen;
    } // if the string had any data in it.
    
error:

    if (FAILED(hr) && lpByte) {
        FreeADsMem(lpByte);
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertBinarySDToRawSD - Helper routine.
//
// Synopsis:   Converts a VT_UI1 | VT_ARRAY to a binary SD.
//
// Arguments:  pvVarBinSD            -   The input variant array to convert.
//             ppSecurityDescriptor  -   Return value for binary sd.
//             pdwLength             -   Return value for length of binary sd.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSecurityDescriptor and pdwLength modified appropriately.
//
//----------------------------------------------------------------------------
HRESULT
ConvertBinarySDToRawSD(
    PVARIANT pvVarBinSD,
    PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    DWORD *pdwLength
    )
{
    HRESULT hr = S_OK;
    LPVOID lpMem = NULL;
    long lBoundLower = -1;
    long lBoundUpper = -1;
    CHAR HUGEP *pArray = NULL;

    *ppSecurityDescriptor = NULL;
    *pdwLength = 0;
    
    //
    // Make sure we have an array and then get length.
    //
    if( pvVarBinSD->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(
             V_ARRAY(pvVarBinSD),
             1,
             &lBoundLower
             );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
             V_ARRAY(pvVarBinSD),
             1,
             &lBoundUpper
             );
    BAIL_ON_FAILURE(hr);

    if ((lBoundUpper == -1)
        && (lBoundLower == -1)
        ) {
        //
        // Nothing further to do in this case.
        //
        ;
    } 
    else {
        long lLength;

        lLength = (lBoundUpper - lBoundLower) + 1;
        lpMem = AllocADsMem(lLength);
        if (!lpMem) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = SafeArrayAccessData(
                 V_ARRAY(pvVarBinSD),
                 (void HUGEP * FAR *) &pArray
                 );
        BAIL_ON_FAILURE(hr);

        memcpy(lpMem, pArray, lLength);

        SafeArrayUnaccessData(V_ARRAY(pvVarBinSD));

        *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) lpMem;
        *pdwLength = (DWORD) lLength;
    }

error:

    if (FAILED(hr) && lpMem) {
        FreeADsMem(lpMem);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetRawSDFromFile - Helper routine.
//
// Synopsis:   Gets the security descriptor from the file in binary format.
//
// Arguments:  pszFileName       -   Name of file to get sd from.
//             secInfo           -   Security mask to use for the operation.
//             ppSD              -   Return value for the SD.
//             pdwLength         -   Return value for the lenght of the SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSD and pdwLength on success.
//
//----------------------------------------------------------------------------
HRESULT
GetRawSDFromFile(
    LPWSTR pszFileName,
    SECURITY_INFORMATION secInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PDWORD pdwLength
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;
                                

    *ppSD = NULL;
    *pdwLength = 0;

    //
    // Get the length of the SD.
    //
    if (!GetFileSecurity(
             pszFileName,
             secInfo,
             NULL,
             0,
             &dwLength
             )
        && (dwLength == 0)
        ) {
        //
        // There was an error.
        //
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    if (dwLength == 0) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }
    
    pSD = (PSECURITY_DESCRIPTOR) AllocADsMem(dwLength);
    
    if (!pSD) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!GetFileSecurity(
             pszFileName,
             secInfo,
             pSD,
             dwLength,
             &dwLength
             )
        ) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    *pdwLength = dwLength;
    *ppSD = pSD;

error:

    if (FAILED(hr) && pSD) {
        FreeADsMem(pSD);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   SetRawSDToFile - Helper routine.
//
// Synopsis:   Sets the binary security descriptor on the file.
//
// Arguments:  pszFileName       -   Name of file to set sd on.
//             secInfo           -   Security mask to use for the operation.
//             pSD               -   Value of SD to set.
//             dwLength          -   Length of the sd.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
SetRawSDToFi