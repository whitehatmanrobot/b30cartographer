NG)((ULONG_PTR) currentOffset -
                                      (ULONG_PTR) Descriptor);

    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // now the product id
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->ProductId,
                  min(bytesRemaining, 16));
    bytesRemaining -= 17;                   // include trailing null

    if(bytesRemaining >= 0) {

        Descriptor->ProductIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                       (ULONG_PTR) Descriptor);
    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // And the product revision
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->ProductRevisionLevel,
                  min(bytesRemaining, 4));
    bytesRemaining -= 5;

    if(bytesRemaining >= 0) {
        Descriptor->ProductRevisionOffset = (ULONG)((ULONG_PTR) currentOffset -
                                             (ULONG_PTR) Descriptor);
    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // If the device provides a SCSI serial number (vital product data page 80)
    // the report it.
    //

    if(LogicalUnit->SerialNumber.Length != 0) {

        //
        // And the product revision
        //

        RtlCopyMemory(currentOffset,
                      LogicalUnit->SerialNumber.Buffer,
                      min(bytesRemaining, serialNumberLength));
        bytesRemaining -= serialNumberLength;

        if(bytesRemaining >= 0) {
            Descriptor->SerialNumberOffset = (ULONG)((ULONG_PTR) currentOffset -
                                                     (ULONG_PTR) Descriptor);
        }

        if(bytesRemaining <= 0) {
            *DescriptorLength = maxLength;
            return STATUS_SUCCESS;
        }
    }


    *DescriptorLength = maxLength - bytesRemaining;
    return STATUS_SUCCESS;
}


NTSTATUS
SpBuildAdapterDescriptor(
    IN PADAPTER_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )
{
    PSCSIPORT_DRIVER_EXTENSION driverExtension =
        IoGetDriverObjectExtension(Adapter->DeviceObject->DriverObject,
                                   ScsiPortInitialize);

    PIO_SCSI_CAPABILITIES capabilities = &(Adapter->Capabilities);

    STORAGE_ADAPTER_DESCRIPTOR tmp;

    PAGED_CODE();

    ASSERT_FDO(Adapter->DeviceObject);

    //
    // Call to IoGetDriverObjectExtension can return NULL
    //
    if (driverExtension == NULL) {
        *DescriptorLength = 0;
        return STATUS_UNSUCCESSFUL;
    }

    tmp.Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
    tmp.Size = sizeof(STORAGE_ADAPTER_DESCRIPTOR);

    tmp.MaximumTransferLength = capabilities->MaximumTransferLength;
    tmp.MaximumPhysicalPages = capabilities->MaximumPhysicalPages;

    tmp.AlignmentMask = capabilities->AlignmentMask;

    tmp.AdapterUsesPio = capabilities->AdapterUsesPio;
    tmp.AdapterScansDown = capabilities->AdapterScansDown;
    tmp.CommandQueueing = capabilities->TaggedQueuing;
    tmp.AcceleratedTransfer = TRUE;

    tmp.BusType = (BOOLEAN) driverExtension->BusType;
    tmp.BusMajorVersion = 2;
    tmp.BusMinorVersion = 0;

    RtlCopyMemory(Descriptor,
                  &tmp,
                  min(*DescriptorLength, sizeof(STORAGE_ADAPTER_DESCRIPTOR)));

    *DescriptorLength = min(*DescriptorLength, sizeof(STORAGE_ADAPTER_DESCRIPTOR));

    return STATUS_SUCCESS;
}


NTSTATUS
SpQueryDeviceText(
    IN PDEVICE_OBJECT LogicalUnit,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    )

{
    PLOGICAL_UNIT_EXTENSION luExtension = LogicalUnit->DeviceExtension;

    UCHAR ansiBuffer[256];
    ANSI_STRING ansiText;

    UNICODE_STRING unicodeText;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(&unicodeText, NULL);

    if(TextType == DeviceTextDescription) {

        PSCSIPORT_DEVICE_TYPE deviceInfo =
            SpGetDeviceTypeInfo(luExtension->InquiryData.DeviceType);

        PUCHAR c;
        LONG i;

        RtlZeroMemory(ansiBuffer, sizeof(ansiBuffer));
        RtlCopyMemory(ansiBuffer,
                      luExtension->InquiryData.VendorId,
                      sizeof(luExtension->InquiryData.VendorId));
        c = ansiBuffer;

        for(i = sizeof(luExtension->InquiryData.VendorId); i >= 0; i--) {
            if((c[i] != '\0') &&
               (c[i] != ' ')) {
                break;
            }
            c[i] = '\0';
        }
        c = &(c[i + 1]);

        sprintf(c, " ");
        c++;

        RtlCopyMemory(c,
                      luExtension->InquiryData.ProductId,
                      sizeof(luExtension->InquiryData.ProductId));

        for(i = sizeof(luExtension->InquiryData.ProductId); i >= 0; i--) {
            if((c[i] != '\0') &&
               (c[i] != ' ')) {
                break;
            }
            c[i] = '\0';
        }
        c = &(c[i + 1]);

        sprintf(c, " SCSI %s Device", deviceInfo->DeviceTypeString);

    } else if (TextType == DeviceTextLocationInformation) {

        sprintf(ansiBuffer, "Bus Number %d, Target ID %d, LUN %d",
                luExtension->PathId,
                luExtension->TargetId,
                luExtension->Lun);

    } else {

        return STATUS_NOT_SUPPORTED;
    }

    RtlInitAnsiString(&ansiText, ansiBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeText,
                                          &ansiText,
                                          TRUE);

    *DeviceText = unicodeText.Buffer;
    return status;
}

NTSTATUS
SpBuildDeviceIdDescriptor(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )

/*++

Routine Description:

    This routine will create a device id descriptor based on the device
    identifier page retrieved during discovery.  It is an error to call this
    routine if no device identifier page exists.

    This routine will copy as much data as possible into the Descriptor and
    will update the DescriptorLength to indicate the number of bytes copied.

Arguments:

    DeviceObject - a pointer to the PDO we are building a descriptor for

    Descriptor - a buffer to store the descriptor in

    DescriptorLength - the length of the buffer and the number of bytes
                       returned

    QueryIrp - unused

Return Value:

    status

--*/

{
    PVPD_IDENTIFICATION_PAGE idPage = LogicalUnit->DeviceIdentifierPage;
    ULONG idOffset;

    ULONG maxLength = *DescriptorLength;
    PUCHAR destOffset;

    LONG identifierLength;
    ULONG identifierCount = 0;

    PAGED_CODE();

    ASSERT_PDO(LogicalUnit->DeviceObject);
    ASSERT(Descriptor != NULL);
    ASSERT(LogicalUnit->DeviceIdentifierPage != NULL);

    if(maxLength < sizeof(STORAGE_DESCRIPTOR_HEADER)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize the header of the descriptor.
    //

    RtlZeroMemory(Descriptor, *DescriptorLength);
    Descriptor->Version = sizeof(STORAGE_DEVICE_ID_DESCRIPTOR);

    Descriptor->Size = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

    //
    // Prepare to copy the identifiers directly into the buffer.
    //

    destOffset = Descriptor->Identifiers;

    //
    // Walk through the id page.  Count the number of descriptors and
    // calculate the size of the descriptor page.
    //

    for(idOffset = 0; idOffset < idPage->PageLength;) {
        PVPD_IDENTIFICATION_DESCRIPTOR src;
        USHORT identifierSize;

        src = (PVPD_IDENTIFICATION_DESCRIPTOR) &(idPage->Descriptors[idOffset]);

        identifierSize = FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
        identifierSize += src->IdentifierLength;

        //
        // Align the identifier size to 32-bits.
        //

        identifierSize += sizeof(ULONG);
        identifierSize &= ~(sizeof(ULONG) - 1);

        identifierCount += 1;

        Descriptor->Size += identifierSize;

        if(Descriptor->Size <= maxLength) {
            PSTORAGE_IDENTIFIER dest;

            dest = (PSTORAGE_IDENTIFIER) destOffset;

            dest->CodeSet = src->CodeSet;
            dest->Type = src->IdentifierType;
            dest->Association = src->Association;

            dest->IdentifierSize = src->IdentifierLength;
            dest->NextOffset = identifierSize;

            RtlCopyMemory(dest->Identifier,
                          src->Identifier,
                          src->IdentifierLength);

            destOffset += dest->NextOffset;
        }

        idOffset += sizeof(PVPD_IDENTIFICATION_DESCRIPTOR);
        idOffset += src->IdentifierLength;
    }

    if(*DescriptorLength >= FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR,
                                        Identifiers)) {

        Descriptor->NumberOfIdentifiers = identifierCount;
    }

    *DescriptorLength = min(Descriptor->Size, *DescriptorLength);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\port.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    port.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a dll for the kernel.

Revision History:

--*/



#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

#if SCSIDBG_ENABLED

ULONG ScsiDebug = 0;
ULONG ScsiPortCheckSrbDataHashTable = 1;
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PscS')
#endif


//
// Routines providing service to hardware dependent driver.
//

PVOID
ScsiPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )

/*++

Routine Description:

    Walk port driver's logical unit extension list searching
    for entry.

Arguments:

    HwDeviceExtension - The port driver's device extension follows
        the miniport's device extension and contains a pointer to
        the logical device extension list.

    PathId, TargetId and Lun - identify which logical unit on the
        SCSI buses.

Return Value:

    If entry found return miniport driver's logical unit extension.
    Else, return NULL.

--*/

{
    PADAPTER_EXTENSION deviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    DebugPrint((3, "ScsiPortGetLogicalUnit: TargetId %d\n",
        TargetId));

    //
    // Get pointer to port driver device extension.
    //

    deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    //
    // Get a pointer to the logical unit.
    //

    logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                          PathId,
                                          TargetId,
                                          Lun,
                                          FALSE,
                                          FALSE);

    if(logicalUnit != NULL) {

        return logicalUnit->HwLogicalUnitExtension;
    }

    return NULL;

} // end ScsiPortGetLogicalUnit()


VOID
ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSRB_DATA               srbData;
    PSCSI_REQUEST_BLOCK     srb;
    UCHAR                   pathId;
    UCHAR                   targetId;
    UCHAR                   lun;
    va_list                 ap;

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case NextRequest:

            //
            // Start next packet on adapter's queue.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;
            break;

        case RequestComplete:

            srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            ASSERT(srb->SrbStatus != SRB_STATUS_PENDING);

            ASSERT(srb->SrbStatus != SRB_STATUS_SUCCESS ||
                   srb->ScsiStatus == SCSISTAT_GOOD ||
                   srb->Function != SRB_FUNCTION_EXECUTE_SCSI);

            //
            // If this srb has already been completed then return, otherwise
            // clear the active flag.
            //

            if (srb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                srb->SrbFlags &= ~SRB_FLAGS_IS_ACTIVE;
            } else {
                va_end(ap);
                return;
            }

            //
            // Treat abort completions as a special case.
            //

            if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

                ASSERT(FALSE);
                logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                                      srb->PathId,
                                                      srb->TargetId,
                                                      srb->Lun,
                                                      FALSE,
                                                      FALSE);

                logicalUnit->CompletedAbort =
                    deviceExtension->InterruptData.CompletedAbort;

                deviceExtension->InterruptData.CompletedAbort = logicalUnit;

            } else {

                //
                // Validate the srb data.
                //

                srbData = srb->OriginalRequest;

#if DBG
                ASSERT_SRB_DATA(srbData);

                ASSERT(srbData->CurrentSrb == srb);

                ASSERT(srbData->CurrentSrb != NULL &&
                       srbData->CompletedRequests == NULL);

                if ((srb->SrbStatus == SRB_STATUS_SUCCESS) &&
                    ((srb->Cdb[0] == SCSIOP_READ) ||
                     (srb->Cdb[0] == SCSIOP_WRITE))) {
                    ASSERT(srb->DataTransferLength);
                }
#endif

                if(((srb->SrbStatus == SRB_STATUS_SUCCESS) ||
                    (srb->SrbStatus == SRB_STATUS_DATA_OVERRUN)) &&
                   (TEST_FLAG(srb->SrbFlags, SRB_FLAGS_UNSPECIFIED_DIRECTION))) {
                    ASSERT(srbData->OriginalDataTransferLength >=
                           srb->DataTransferLength);
                }

                srbData->CompletedRequests =
                    deviceExtension->InterruptData.CompletedRequests;
                deviceExtension->InterruptData.CompletedRequests = srbData;

                //
                // Cache away the last logical unit we touched in the miniport.
                // This is cleared when we come out of the miniport
                // synchronization but provides a shortcut for finding the
                // logical unit before going into the hash table.
                //

                deviceExtension->CachedLogicalUnit = srbData->LogicalUnit;
            }

            break;

        case ResetDetected:

            //
            // Notifiy the port driver that a reset has been reported.
            //

            deviceExtension->InterruptData.InterruptFlags |=
                PD_RESET_REPORTED | PD_RESET_HOLD;
            break;

        case NextLuRequest:

            //
            // The miniport driver is ready for the next request and
            // can accept a request for this logical unit.
            //

            pathId = va_arg(ap, UCHAR);
            targetId = va_arg(ap, UCHAR);
            lun = va_arg(ap, UCHAR);

            //
            // A next request is impiled by this notification so set the
            // ready for next reqeust flag.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;

            logicalUnit = deviceExtension->CachedLogicalUnit;

            if((logicalUnit == NULL) ||
               (logicalUnit->TargetId != targetId) ||
               (logicalUnit->PathId != pathId) ||
               (logicalUnit->Lun != lun)) {

                logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                                      pathId,
                                                      targetId,
                                                      lun,
                                                      FALSE,
                                                      FALSE);
            }

            if (logicalUnit != NULL && logicalUnit->ReadyLogicalUnit != NULL) {

                //
                // Since our ReadyLogicalUnit link field is not NULL we must
                // have already been linked onto a ReadyLogicalUnit list.
                // There is nothing to do.
                //

                break;
            }

            //
            // Don't process this as request for the next logical unit, if
            // there is a untagged request for active for this logical unit.
            // The logical unit will be started when untagged request completes.
            //

            if (logicalUnit != NULL && logicalUnit->CurrentUntaggedRequest == NULL) {

                //
                // Add the logical unit to the chain of logical units that
                // another request maybe processed for.
                //

                logicalUnit->ReadyLogicalUnit =
                    deviceExtension->InterruptData.ReadyLogicalUnit;
                deviceExtension->InterruptData.ReadyLogicalUnit = logicalUnit;
            }

            break;

        case CallDisableInterrupts:

            ASSERT(deviceExtension->InterruptData.InterruptFlags &
                   PD_DISABLE_INTERRUPTS);

            //
            // The miniport wants us to call the specified routine
            // with interrupts disabled.  This is done after the current
            // HwRequestInterrutp routine completes. Indicate the call is
            // needed and save the routine to be called.
            //

            deviceExtension->Flags |= PD_DISABLE_CALL_REQUEST;

            if (SpVerifierActive(deviceExtension)) {
                deviceExtension->VerifierExtension->RealHwRequestInterrupt = 
                   va_arg(ap, PHW_INTERRUPT);
                deviceExtension->HwRequestInterrupt = SpHwRequestInterruptVrfy;
            } else {
                deviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);
            }

            break;

        case CallEnableInterrupts:

            //
            // The miniport wants us to call the specified routine
            // with interrupts enabled this is done from the DPC.
            // Disable calls to the interrupt routine, indicate the call is
            // needed and save the routine to be called.
            //

            deviceExtension->InterruptData.InterruptFlags |=
                PD_DISABLE_INTERRUPTS | PD_ENABLE_CALL_REQUEST;

            if (SpVerifierActive(deviceExtension)) {
                deviceExtension->VerifierExtension->RealHwRequestInterrupt = 
                   va_arg(ap, PHW_INTERRUPT);
                deviceExtension->HwRequestInterrupt = SpHwRequestInterruptVrfy;
            } else {
                deviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);
            }

            break;

        case RequestTimerCall:

            //
            // The driver wants to set the miniport timer.
            // Save the timer parameters.
            //

            deviceExtension->InterruptData.InterruptFlags |=
                PD_TIMER_CALL_REQUEST;
            deviceExtension->InterruptData.HwTimerRequest =
                va_arg(ap, PHW_INTERRUPT);
            deviceExtension->InterruptData.MiniportTimerValue =
                va_arg(ap, ULONG);
            break;

        case WMIEvent: {

            //
            // The miniport wishes to post a WMI event for the adapter
            // or a specified SCSI target.
            //

            PWMI_MINIPORT_REQUEST_ITEM lastMiniPortRequest;
            PWMI_MINIPORT_REQUEST_ITEM wmiMiniPortRequest;
            PWNODE_EVENT_ITEM          wnodeEventItem;
            PWNODE_EVENT_ITEM          wnodeEventItemCopy;

            wnodeEventItem     = va_arg(ap, PWNODE_EVENT_ITEM);
            pathId             = va_arg(ap, UCHAR);

            //
            // if pathID is 0xFF, that means that the WmiEevent is from the
            // adapter, no targetId or lun is neccesary
            //
            if (pathId != 0xFF) {
                targetId = va_arg(ap, UCHAR);
                lun      = va_arg(ap, UCHAR);
            }

            //
            // Validate the event first.  Then attempt to obtain a free
            // WMI_MINIPORT_REQUEST_ITEM structure so that we may store
            // this request and process it at DPC level later.  If none
            // are obtained or the event is bad, we ignore the request.
            //

            if ((wnodeEventItem == NULL) ||
                (wnodeEventItem->WnodeHeader.BufferSize >
                 WMI_MINIPORT_EVENT_ITEM_MAX_SIZE)) {

                va_end(ap);    //  size, no free WMI_MINIPORT_REQUEST_ITEMs left]
                return;
            }

            //
            // Remove the WMI_MINIPORT_REQUEST_ITEM from the free list.
            //
            wmiMiniPortRequest = SpWmiPopFreeRequestItem(deviceExtension);

            //
            // Log an error if a free request item could not be dequeued
            // (log only once in the lifetime of this adapter).
            //
            if (wmiMiniPortRequest == NULL) {

                if (!deviceExtension->WmiFreeMiniPortRequestsExhausted) {
                    deviceExtension->WmiFreeMiniPortRequestsExhausted = TRUE;

                    //
                    // If pathId is 0xFF that means that pathId and targetId
                    // will be not be defined
                    // 
                    if (pathId != 0xFF) {
                        ScsiPortLogError(HwDeviceExtension,
                                             NULL,
                                             pathId,
                                             targetId,
                                             lun,
                                             SP_LOST_WMI_MINIPORT_REQUEST,
                                             0);
                    } else {
                        ScsiPortLogError(HwDeviceExtension,
                                             NULL,
                                             pathId,
                                             0,
                                             0,
                                             SP_LOST_WMI_MINIPORT_REQUEST,
                                             0);
                    } // pathId != 0xFF
                }

                va_end(ap);
                return;
            }

            //
            // Save information pertaining to this WMI request for later
            // processing.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_WMI_REQUEST;

            wmiMiniPortRequest->TypeOfRequest = (UCHAR)WMIEvent;
            wmiMiniPortRequest->PathId        = pathId;

            //
            // If pathId was 0xFF, then there is no defined value for
            // targetId or lun
            //
            if (pathId != 0xFF) {
                wmiMiniPortRequest->TargetId      = targetId;
                wmiMiniPortRequest->Lun           = lun;
            }

            RtlCopyMemory(wmiMiniPortRequest->WnodeEventItem,
                          wnodeEventItem,
                          wnodeEventItem->WnodeHeader.BufferSize);

            //
            // Queue the new WMI_MINIPORT_REQUEST_ITEM to the end of list in the
            // interrupt data structure.
            //
            wmiMiniPortRequest->NextRequest = NULL;

            lastMiniPortRequest =
                deviceExtension->InterruptData.WmiMiniPortRequests;

            if (lastMiniPortRequest) {

                while (lastMiniPortRequest->NextRequest) {
                    lastMiniPortRequest = lastMiniPortRequest->NextRequest;
                }
                lastMiniPortRequest->NextRequest = wmiMiniPortRequest;

            } else {
                deviceExtension->InterruptData.WmiMiniPortRequests =
                    wmiMiniPortRequest;
            }

            break;
        }

        case WMIReregister: {
            //
            // The miniport wishes to re-register the GUIDs for the adapter or
            // a specified SCSI target.
            //

            PWMI_MINIPORT_REQUEST_ITEM lastMiniPortRequest;
            PWMI_MINIPORT_REQUEST_ITEM wmiMiniPortRequest;

            pathId             = va_arg(ap, UCHAR);

            //
            // if pathID is 0xFF, that means that we're re-registering the
            // adapter no targetId or lun is neccesary
            //
            if (pathId != 0xFF) {
                targetId = va_arg(ap, UCHAR);
                lun      = va_arg(ap, UCHAR);
            } 

            //
            // Attempt to obtain a free WMI_MINIPORT_REQUEST_ITEM structure
            // so that we may store this request and process it at DPC
            // level later. If none are obtained or the event is bad, we
            // ignore the request.
            //
            // Remove a WMI_MINPORT_REQUEST_ITEM from the free list.
            //
            wmiMiniPortRequest = SpWmiPopFreeRequestItem(deviceExtension);

            if (wmiMiniPortRequest == NULL) {

                //
                // Log an error if a free request item could not be dequeued
                // (log only once in the lifetime of this adapter).
                //
                if (!deviceExtension->WmiFreeMiniPortRequestsExhausted) {

                    deviceExtension->WmiFreeMiniPortRequestsExhausted = TRUE;

                    //
                    // If pathId is 0xFF that means that pathId and targetId
                    // will be not be defined
                    // 
                    if (pathId != 0xFF) {
                        ScsiPortLogError(HwDeviceExtension,
                                         NULL,
                                         pathId,
                                         targetId,
                                         lun,
                                         SP_LOST_WMI_MINIPORT_REQUEST,
                                         0);
                    } else {
                        ScsiPortLogError(HwDeviceExtension,
                                         NULL,
                                         pathId,
                                         0,
                                         0,
                                         SP_LOST_WMI_MINIPORT_REQUEST,
                                         0);
                    } // pathId != 0xFF
                 }

                va_end(ap);
                return;
            }

            //
            // Save information pertaining to this WMI request for later
            // processing.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_WMI_REQUEST;
            wmiMiniPortRequest->TypeOfRequest = (UCHAR)WMIReregister;
            wmiMiniPortRequest->PathId        = pathId;

            //
            // If pathId was 0xFF, then there is no defined value for
            // targetId or lun
            //
            if (pathId != 0xFF) {
                wmiMiniPortRequest->TargetId      = targetId;
                wmiMiniPortRequest->Lun           = lun;
            }

            //
            // Queue the new WMI_MINIPORT_REQUEST_ITEM to the end of list in the
            // interrupt data structure.
            //
            wmiMiniPortRequest->NextRequest = NULL;

            lastMiniPortRequest =
                deviceExtension->InterruptData.WmiMiniPortRequests;

            if (lastMiniPortRequest) {

                while (lastMiniPortRequest->NextRequest) {
                    lastMiniPortRequest = lastMiniPortRequest->NextRequest;
                }
                lastMiniPortRequest->NextRequest = wmiMiniPortRequest;

            } else {
                deviceExtension->InterruptData.WmiMiniPortRequests =
                    wmiMiniPortRequest;
            }

            break;
        }

        case BusChangeDetected: {

            SET_FLAG(deviceExtension->InterruptData.InterruptFlags,
                     PD_BUS_CHANGE_DETECTED);
            break;
        }

        default: {
             ASSERT(0);
             break;
        }
    }

    va_end(ap);

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

} // end ScsiPortNotification()


VOID
ScsiPortFlushDma(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine checks to see if the perivious IoMapTransfer has been done
    started.  If it has not, then the PD_MAP_TRANSER flag is cleared, and the
    routine returns; otherwise, this routine schedules a DPC which will call
    IoFlushAdapter buffers.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.


Return Value:

    None.

--*/

{

    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    if(Sp64BitPhysicalAddresses) {
        KeBugCheckEx(PORT_DRIVER_INTERNAL, 
                     0,
                     STATUS_NOT_SUPPORTED,
                     (ULONG_PTR) HwDeviceExtension,
                     (ULONG_PTR) deviceExtension->DeviceObject->DriverObject);
    }

    if (deviceExtension->InterruptData.InterruptFlags & PD_MAP_TRANSFER) {

        //
        // The transfer has not been started so just clear the map transfer
        // flag and return.
        //

        deviceExtension->InterruptData.InterruptFlags &= ~PD_MAP_TRANSFER;
        return;
    }

    deviceExtension->InterruptData.InterruptFlags |= PD_FLUSH_ADAPTER_BUFFERS;

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

    return;

}

VOID
ScsiPortIoMapTransfer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    )
/*++

Routine Description:

    Saves the parameters for the call to IoMapTransfer and schedules the DPC
    if necessary.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.

    Srb - Supplies the particular request that data transfer is for.

    LogicalAddress - Supplies the logical address where the transfer should
        begin.

    Length - Supplies the maximum length in bytes of the transfer.

Return Value:

   None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PSRB_DATA srbData = Srb->OriginalRequest;

    ASSERT_SRB_DATA(srbData);

    //
    // If this is a 64-bit system then this call is illegal.  Bugcheck.
    //

    if(Sp64BitPhysicalAddresses) {
        KeBugCheckEx(PORT_DRIVER_INTERNAL, 
                     1,
                     STATUS_NOT_SUPPORTED,
                     (ULONG_PTR) HwDeviceExtension,
                     (ULONG_PTR) deviceExtension->DeviceObject->DriverObject);
    }

    //
    // Make sure this host bus adapter has an Dma adapter object.
    //

    if (deviceExtension->DmaAdapterObject == NULL) {

        //
        // No DMA adapter, no work.
        //

        return;
    }

    ASSERT((Srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) != SRB_FLAGS_UNSPECIFIED_DIRECTION);

    deviceExtension->InterruptData.MapTransferParameters.SrbData = srbData;

    deviceExtension->InterruptData.MapTransferParameters.LogicalAddress = LogicalAddress;
    deviceExtension->InterruptData.MapTransferParameters.Length = Length;
    deviceExtension->InterruptData.MapTransferParameters.SrbFlags = Srb->SrbFlags;

    deviceExtension->InterruptData.InterruptFlags |= PD_MAP_TRANSFER;

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

} // end ScsiPortIoMapTransfer()


VOID
ScsiPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine saves the error log information, and queues a DPC if necessary.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    Srb - Supplies an optional pointer to srb if there is one.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PDEVICE_OBJECT DeviceObject = deviceExtension->CommonExtension.DeviceObject;
    PSRB_DATA srbData;
    PERROR_LOG_ENTRY errorLogEntry;

    //
    // If the error log entry is already full, then dump the error.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_LOG_ERROR) {

#if SCSIDBG_ENABLED
        DebugPrint((1,"ScsiPortLogError: Dumping scsi error log packet.\n"));
        DebugPrint((1,
            "PathId = %2x, TargetId = %2x, Lun = %2x, ErrorCode = %x, UniqueId = %x.",
            PathId,
            TargetId,
            Lun,
            ErrorCode,
            UniqueId
            ));
#endif
        return;
    }

    //
    // Save the error log data in the log entry.
    //

    errorLogEntry = &deviceExtension->InterruptData.LogEntry;

    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->TargetId = TargetId;
    errorLogEntry->Lun = Lun;
    errorLogEntry->PathId = PathId;
    errorLogEntry->UniqueId = UniqueId;

    //
    // Get the sequence number from the SRB data.
    //

    if (Srb != NULL) {

        srbData = Srb->OriginalRequest;

        ASSERT_SRB_DATA(srbData);

        errorLogEntry->SequenceNumber = srbData->SequenceNumber;
        errorLogEntry->ErrorLogRetryCount = srbData->ErrorLogRetryCount++;
    } else {
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->ErrorLogRetryCount = 0;
    }

    //
    // Indicate that the error log entry is in use.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_LOG_ERROR;

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

    return;

} // end ScsiPortLogError()


VOID
ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    ULONG binNumber;

    for (binNumber = 0; binNumber < NUMBER_LOGICAL_UNIT_BINS; binNumber++) {

        PLOGICAL_UNIT_BIN bin = &deviceExtension->LogicalUnitList[binNumber];
        PLOGICAL_UNIT_EXTENSION logicalUnit;
        ULONG limit = 0;

        logicalUnit = bin->List;

        DebugPrint((2, "ScsiPortCompleteRequest: Completing requests in "
                       "bin %d [%#p]\n",
                    binNumber, bin));

        for(logicalUnit = bin->List;
            logicalUnit != NULL;
            logicalUnit = logicalUnit->NextLogicalUnit) {

            PLIST_ENTRY entry;

            ASSERT(limit++ < 1000);

            //
            // See if this logical unit matches the pattern.  Check for -1
            // first since this seems to be the most popular way to complete
            // requests.
            //

            if (((PathId == SP_UNTAGGED) || (PathId == logicalUnit->PathId)) &&
                ((TargetId == SP_UNTAGGED) ||
                 (TargetId == logicalUnit->TargetId)) &&
                ((Lun == SP_UNTAGGED) || (Lun == logicalUnit->Lun))) {

                //
                // Complete any pending abort reqeusts.
                //

                if (logicalUnit->AbortSrb != NULL) {
                    logicalUnit->AbortSrb->SrbStatus = SrbStatus;

                    ScsiPortNotification(
                        RequestComplete,
                        HwDeviceExtension,
                        logicalUnit->AbortSrb
                        );
                }

                if(logicalUnit->CurrentUntaggedRequest != NULL) {

                    SpCompleteSrb(deviceExtension,
                                  logicalUnit->CurrentUntaggedRequest,
                                  SrbStatus);
                }

                //
                // Complete each of the requests in the queue.
                //

                entry = logicalUnit->RequestList.Flink;
                while (entry != &logicalUnit->RequestList) {
                    PSRB_DATA srbData;

                    ASSERT(limit++ < 1000);
                    srbData = CONTAINING_RECORD(entry, SRB_DATA, RequestList);
                    SpCompleteSrb(deviceExtension,  srbData, SrbStatus);
                    entry = srbData->RequestList.Flink;
                }

            }
        }
    }

    return;

} // end ScsiPortCompleteRequest()


VOID
ScsiPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    Copy from one buffer into another.

Arguments:

    ReadBuffer - source
    WriteBuffer - destination
    Length - number of bytes to copy

Return Value:

    None.

--*/

{

    //
    // See if the length, source and desitination are word aligned.
    //

    if (Length & LONG_ALIGN || (ULONG_PTR) WriteBuffer & LONG_ALIGN ||
        (ULONG_PTR) ReadBuffer & LONG_ALIGN) {

        PCHAR destination = WriteBuffer;
        PCHAR source = ReadBuffer;

        for (; Length > 0; Length--) {
            *destination++ = *source++;
        }
    } else {

        PLONG destination = WriteBuffer;
        PLONG source = ReadBuffer;

        Length /= sizeof(LONG);
        for (; Length > 0; Length--) {
            *destination++ = *source++;
        }
    }

} // end ScsiPortMoveMemory()


#if SCSIDBG_ENABLED

VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for scsi miniports.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None
    
Note:
    Using the new debug API (systemwide API) DebugPrintEx
    renders the variable scsidebug meaningless, since the
    level of debug is now controlled int he debug filter
    the mask for scsiprot is Kd_ScsiMiniPort_Mask

    From the debugger do: ed Kd_ScsiPort_Mask X
    where X is the desired value of debug spew.

    DPFLTR_ERROR_LEVEL      - Are always printed.
    DPFLTR_WARNING_LEVEL    - 0x01  (bit 1)
    DPFLTR_TRACE_LEVEL      - 0x02  (bit 2)
    DPFLTR_INFO_LEVEL       - 0x04  (bit 3)
    
    If you'd like to get WARNING and TRACE, you muyst set bit 1 and 2 (etc)
    
    The Mask is a 32-bit value
    
    I can only see 1 bad thing about changing this function.
    Before the _vsnprintf operations would only occurr if we KNEW
    that the debug message was going to be printed.  Now it
    occurs before we deternime wether it will be printed.  This changes
    the timing of the checked build a bit.

--*/

{
    va_list ap;
    ULONG   DebugLevel;

    //
    // This code should be removed soon
    // Its place here is to remind people debugging scsiport
    // that the methods that control debug spew have changed
    //
    // NOTE - Eventually we should be able to remove this.
    //
    if (ScsiDebug != 0) {
        // This means that someone changed the value of ScsiDebug
        // (ie. they want debug spew)
        DbgPrintEx(DPFLTR_SCSIMINIPORT_ID, DPFLTR_ERROR_LEVEL,
                   "Debug messages in SCSI Miniports are no longer controlled by\n"
                   "scsiport!scsidebug.  Please use the correct debug maski\n\n"
                   "Kd_ScsiPort_Mask -- controls debug msgs from ScsiPort\n"
                   "Kd_ScsiMiniPort_Mask  --  controls debug msgs from SCSI-Miniports\n\n"
                   "\t0x01 - Error Level\t(bit 0)\n"
                   "\t0x02 - Warning Level\t(bit 1)\n"
                   "\t0x04 - Trace Level\t(bit 2)\n"
                   "\t0x08 - Info Level\t(bit 3)\n\n"
                   "To get multiple levels, OR the bit-values\n");
        DbgBreakPoint();
        ScsiDebug = 0;
    }

    va_start(ap, DebugMessage);

    //
    // Map the debugprintlevels of scsiport into the new
    // debug print API
    //
    switch (DebugPrintLevel) {
    case 0:
        DebugLevel = DPFLTR_WARNING_LEVEL;
        break;
    case 1:
    case 2:
        DebugLevel = DPFLTR_TRACE_LEVEL;
        break;

    case 3:
        DebugLevel = DPFLTR_INFO_LEVEL;
        break;

    default:
        DebugLevel = DebugPrintLevel;
        break;

    }

    vDbgPrintExWithPrefix("ScsiMiniport: ",
                          DPFLTR_SCSIMINIPORT_ID, 
                          DebugLevel, 
                          DebugMessage, 
                          ap);

    va_end(ap);

} // end ScsiDebugPrint()

VOID
ScsiDebugPrintInt(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for Internal DebugPrints (SCSIPORT Internal).

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None
    
Note:
    Using the new debug API (systemwide API) DebugPrintEx
    renders the variable scsidebug meaningless, since the
    level of debug is now controlled int he debug filter
    the mask for scsiprot is Kd_ScsiPort_Mask

    From the debugger do: ed Kd_ScsiPort_Mask X
    where X is the desired value of debug spew.

    DPFLTR_ERROR_LEVEL      - Are always printed.
    DPFLTR_WARNING_LEVEL    - 0x01  (bit 1)
    DPFLTR_TRACE_LEVEL      - 0x02  (bit 2)
    DPFLTR_INFO_LEVEL       - 0x04  (bit 3)
    
    The Mask is a 32-bit value
    
    I can only see 1 bad thing about changing this function.
    Before the _vsnprintf operations would only occurr if we KNEW
    that the debug message was going to be printed.  Now it
    occurs before we deternime wether it will be printed.  This changes
    the timing of the checked build a bit.

--*/

{
    va_list ap;
    ULONG   DebugLevel;

    //
    // This code should be removed soon
    // Its place here is to remind people debugging scsiport
    // that the methods that control debug spew have changed
    //
    // NOTE - Eventually we should be able to remove this.
    //
    if (ScsiDebug != 0) {
        // This means that someone changed the value of ScsiDebug
        // (ie. they want debug spew)
        DbgPrintEx(DPFLTR_SCSIPORT_ID, DPFLTR_ERROR_LEVEL,
                   "Debug messages in SCSI Miniports are no longer controlled by\n"
                   "scsiport!scsidebug.  Please use the correct debug maski\n\n"
                   "Kd_ScsiPort_Mask -- controls debug msgs from ScsiPort\n"
                   "Kd_ScsiMiniPort_Mask  --  controls debug msgs from SCSI-Miniports\n\n"
                   "\t0x01 - Error Level\t(bit 0)\n"
                   "\t0x02 - Warning Level\t(bit 1)\n"
                   "\t0x04 - Trace Level\t(bit 2)\n"
                   "\t0x08 - Info Level\t(bit 3)\n\n"
                   "To get multiple levels, OR the bit-values\n");
        DbgBreakPoint();
        ScsiDebug = 0;
    }

    va_start(ap, DebugMessage);

    //
    // Map the debugprintlevels of scsiport into the new
    // debug print API
    //
    switch (DebugPrintLevel) {
    case 0:
        DebugLevel = DPFLTR_ERROR_LEVEL;
        break;
    case 1:
    case 2:
        DebugLevel = DPFLTR_WARNING_LEVEL;
        break;

    case 3:
        DebugLevel = DPFLTR_TRACE_LEVEL;
        break;

    default:
        DebugLevel = DPFLTR_INFO_LEVEL;
        break;

    }

    vDbgPrintExWithPrefix("ScsiPort: ",
                          DPFLTR_SCSIPORT_ID, 
                          DebugLevel, 
                          DebugMessage, 
                          ap);

    va_end(ap);

} // end ScsiDebugPrint()

#else

//
// ScsiDebugPrint stub
//

VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

VOID
ScsiDebugPrintInt(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif

//
// The below I/O access routines are forwarded to the HAL or NTOSKRNL on
// Alpha and Intel platforms.
//
#if !defined(_ALPHA_) && !defined(_X86_)

UCHAR
ScsiPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_UCHAR(Port));

}

USHORT
ScsiPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_USHORT(Port));

}

ULONG
ScsiPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_ULONG(Port));

}

VOID
ScsiPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
ScsiPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
ScsiPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

UCHAR
ScsiPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_UCHAR(Register));

}

USHORT
ScsiPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_USHORT(Register));

}

ULONG
ScsiPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_ULONG(Register));

}

VOID
ScsiPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
ScsiPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
ScsiPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
ScsiPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_UCHAR(Port, Value);

}

VOID
ScsiPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_USHORT(Port, Value);

}

VOID
ScsiPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_ULONG(Port, Value);


}

VOID
ScsiPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
ScsiPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_UCHAR(Register, Value);

}

VOID
ScsiPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_USHORT(Register, Value);
}

VOID
ScsiPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_ULONG(Register, Value);
}
#endif  // !defined(_ALPHA_) && !defined(_X86_)


PSCSI_REQUEST_BLOCK
ScsiPortGetSrb(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )

/*++

Routine Description:

    This routine retrieves an active SRB for a particuliar logical unit.

Arguments:

    HwDeviceExtension
    PathId, TargetId, Lun - identify logical unit on SCSI bus.
    QueueTag - -1 indicates request is not tagged.

Return Value:

    SRB, if one exists. Otherwise, NULL.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PSRB_DATA srbData;
    PSCSI_REQUEST_BLOCK srb;
    UCHAR pathId;
    UCHAR targetId;
    UCHAR lun;

    srbData = SpGetSrbData(deviceExtension,
                           PathId,
                           TargetId,
                           Lun,
                           (UCHAR)QueueTag,
                           FALSE);

    if (srbData == NULL || srbData->CurrentSrb == NULL) {
        return(NULL);
    }

    srb = srbData->CurrentSrb;

    //
    // If the srb is not active then return NULL;
    //

    if (!(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {
        return(NULL);
    }

    return (srb);

} // end ScsiPortGetSrb()


SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
)

/*++

Routine Description:

    Convert virtual address to physical address for DMA.

Arguments:

Return Value:

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    ULONG             byteOffset;
    PHYSICAL_ADDRESS  address;
    ULONG             length;

    if (Srb == NULL || Srb->SenseInfoBuffer == VirtualAddress) {

        byteOffset = (ULONG)((PCCHAR) VirtualAddress - (PCCHAR)
                deviceExtension->SrbExtensionBuffer);

        ASSERT(byteOffset < deviceExtension->CommonBufferSize);
            
        length = deviceExtension->CommonBufferSize - byteOffset;
        address.QuadPart = deviceExtension->PhysicalCommonBuffer.QuadPart + byteOffset;

    } else if (deviceExtension->MasterWithAdapter) {

        PSRB_SCATTER_GATHER scatterList;
        PSRB_DATA srbData;

        //
        // A scatter/gather list has already been allocated use it to determine
        // the physical address and length.  Get the scatter/gather list.
        //

        srbData = Srb->OriginalRequest;

        ASSERT_SRB_DATA(srbData);

        scatterList = srbData->ScatterGatherList;

        //
        // Calculate byte offset into the data buffer.
        //

        byteOffset = (ULONG)((PCHAR) VirtualAddress - (PCHAR) Srb->DataBuffer);

        //
        // Find the appropriate entry in the scatter/gatter list.
        //

        while (byteOffset >= scatterList->Length) {

            byteOffset -= scatterList->Length;
            scatterList++;
        }

        //
        // Calculate the physical address and length to be returned.
        //

        length = scatterList->Length - byteOffset;

        address.QuadPart = scatterList->Address.QuadPart + byteOffset;

    } else {
        length = 0;
        address.QuadPart = (LONGLONG)(SP_UNINITIALIZED_VALUE);
    }

    *Length = length;

    return address;

} // end ScsiPortGetPhysicalAddress()


PVOID
ScsiPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine is returns a virtual address associated with a
    physical address, if the physical address was obtained by a
    call to ScsiPortGetPhysicalAddress.

Arguments:

    PhysicalAddress

Return Value:

    Virtual address

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PVOID address;
    ULONG smallphysicalBase;
    ULONG smallAddress;

    smallAddress = ScsiPortConvertPhysicalAddressToUlong(PhysicalAddress);

    smallphysicalBase = ScsiPortConvertPhysicalAddressToUlong(deviceExtension->PhysicalCommonBuffer);

    //
    // Check that the physical address is within the proper range.
    //

    if (smallAddress < smallphysicalBase ||
        smallAddress >= smallphysicalBase + deviceExtension->CommonBufferSize) {

        //
        // This is a bugous physical address return back NULL.
        //

        return(NULL);

    }

    address = smallAddress - smallphysicalBase +
       (PUCHAR) deviceExtension->SrbExtensionBuffer;

    return address;

} // end ScsiPortGetVirtualAddress()


BOOLEAN
ScsiPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine should take an IO range and make sure that it is not already
    in use by another adapter. This allows miniport drivers to probe IO where
    an adapter could be, without worrying about messing up another card.

Arguments:

    HwDeviceExtension - Used to find scsi managers internal structures
    BusType - EISA, PCI, PC/MCIA, MCA, ISA, what?
    SystemIoBusNumber - Which system bus?
    IoAddress - Start of range
    NumberOfBytes - Length of range
    InIoSpace - Is range in IO space?

Return Value:

    TRUE if range not claimed by another driver.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);

        //
        // This is not implemented in NT.
        //

        return TRUE;
}


SCSI_PHYSICAL_ADDRESS
ScsiPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    )

{
    SCSI_PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = UlongAddress;
    return(physicalAddress);
}


//
// Leave these routines at the end of the file.
//

#undef ScsiPortConvertPhysicalAddressToUlong

ULONG
ScsiPortConvertPhysicalAddressToUlong(
    SCSI_PHYSICAL_ADDRESS Address
    )

/*++

Routine Description:

    This routine converts a 64-bit physical address to a ULONG

Arguments:

    Address - Supplies a 64-bit address to be converted.

Return Value:

    Returns a 32-bit address.

--*/
{
    return(Address.LowPart);
}

VOID
ScsiPortStallExecution(
    ULONG Delay
    )

/*++

Routine Description:

    This routine stalls the process for the specified number of microseconds.

Arguments:

    Delay - the number of microseconds to stall.

Return Value:

--*/

{
    KeStallExecutionProcessor(Delay);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\port.h ===
/*++

Copyright (C) 1990-4  Microsoft Corporation

Module Name:

    port.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the common SCSI port driver.

Author:

    Jeff Havens  (jhavens) 28-Feb-1991
    Mike Glass

Revision History:

--*/


#ifndef _PORT_H_
#define _PORT_H_

#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "string.h"

#include "ntddk.h"
#include "scsi.h"

#include <ntddscsi.h>
#include <ntdddisk.h>
#include "ntddstor.h"

#include "wmistr.h"

#include "wdmguid.h"
#include "devguid.h"

//
// feature/debugginging #define switches
//

#define TEST_LISTS 0

//
// ScsiPort global variable declarations.  These should be static data (like
// lookup tables) to avoid synchronization problems.
//

extern PDRIVER_DISPATCH AdapterMajorFunctionTable[];
extern PDRIVER_DISPATCH DeviceMajorFunctionTable[];
extern PDRIVER_DISPATCH Scsi1DeviceMajorFunctionTable[];

//
// Global list of scsi adapters.  This is used by the srb data allocator routine
// to convert the "tag" provided into a pointer to the device object.
//

extern KSPIN_LOCK ScsiGlobalAdapterListSpinLock;
extern PDEVICE_OBJECT *ScsiGlobalAdapterList;
extern ULONG ScsiGlobalAdapterListElements;

//
// Count of how many times we've locked down the PAGELOCK section.
//

extern LONG SpPAGELOCKLockCount;

//
// Whether the system can do 64 bit PA's or not.
//

extern ULONG Sp64BitPhysicalAddresses;

//
// Handle to pageable verifier code section.  We manually lock the verify
// code into memory iff we need it.
//

extern PVOID VerifierCodeSectionHandle;
extern PVOID VerifierApiCodeSectionHandle;
extern ULONG SpVrfyLevel;

//
// Constants and macros to enforce good use of Ex[Allocate|Free]PoolWithTag.
// Remeber that all pool tags will display in the debugger in reverse order
//

#if USE_EXFREEPOOLWITHTAG_ONLY
#define TAG(x)  (x | 0x80000000)
#else
#define TAG(x)  (x)
#endif

#define SCSIPORT_TAG_MINIPORT_PARAM     TAG('aPcS')  // Hold registry data
#define SCSIPORT_TAG_ACCESS_RANGE       TAG('APcS')  // Access Ranges
#define SCSIPORT_TAG_BUS_DATA           TAG('bPcS')  // Get Bus Data holder
#define SCSIPORT_TAG_QUEUE_BITMAP       TAG('BPcS')  // QueueTag BitMap
#define SCSIPORT_TAG_COMMON_BUFFER      TAG('cPcS')  // Fake Common Buffer
#define SCSIPORT_TAG_RESET              TAG('CPcS')  // reset bus code
#define SCSIPORT_TAG_PNP_ID             TAG('dPcS')  // Pnp id strings
#define SCSIPORT_TAG_SRB_DATA           TAG('DPcS')  // SRB_DATA allocations
#define SCSIPORT_TAG_PAE                TAG('ePcS')  // MDLs allocated for PAE requests
#define SCSIPORT_TAG_EMERGENCY_SG_ENTRY TAG('EPcS')  // Scatter gather lists
#define SCSIPORT_TAG_VERIFIER           TAG('fPcS')  // Scsiport verifier entry
#define SCSIPORT_TAG_GLOBAL             TAG('GPcS')  // Global memory
#define SCSIPORT_TAG_DEV_EXT            TAG('hPcS')  // HwDevice Ext
#define SCSIPORT_TAG_LUN_EXT            TAG('HPcS')  // HwLogicalUnit Extension
#define SCSIPORT_TAG_SENSE_BUFFER       TAG('iPcS')  // Sense info
#define SCSIPORT_TAG_INIT_CHAIN         TAG('IPcS')  // Init data chain
#define SCSIPORT_TAG_LOCK_TRACKING      TAG('lPcS')  // remove lock tracking
#define SCSIPORT_TAG_LARGE_SG_ENTRY     TAG('LPcS')  // Scatter gather lists
#define SCSIPORT_TAG_MAPPING_LIST       TAG('mPcS')  // Address mapping lists
#define SCSIPORT_TAG_MEDIUM_SG_ENTRY    TAG('MPcS')  // Scatter gather lists
#define SCSIPORT_TAG_ENABLE             TAG('pPcS')  // device & adapter enable
#define SCSIPORT_TAG_PORT_CONFIG        TAG('PpcS')  // Scsi PortConfig copies
#define SCSIPORT_TAG_INQUIRY            TAG('qPcS')  // inquiry data
#define SCSIPORT_TAG_REQUEST_SENSE      TAG('QPcS')  // request sense
#define SCSIPORT_TAG_RESOURCE_LIST      TAG('rPcS')  // resource list copy
#define SCSIPORT_TAG_REGISTRY           TAG('RPcS')  // registry allocations
#define SCSIPORT_TAG_STOP_DEVICE        TAG('sPcS')  // stop device
#define SCSIPORT_TAG_STOP_ADAPTER       TAG('SPcS')  // stop Adapter
#define SCSIPORT_TAG_REROUTE            TAG('tPcS')  // Legacy request rerouting
#define SCSIPORT_TAG_INTERFACE_MAPPING  TAG('TPcS')  // Interface Mapping
#define SCSIPORT_TAG_DEVICE_RELATIONS   TAG('uPcS')  // device relation structs
#define SCSIPORT_TAG_EVENT              TAG('vPcS')  // KEVENT
#define SCSIPORT_TAG_DEVICE_MAP         TAG('VPcS')  // Device map allocations

#define SCSIPORT_TAG_WMI_EVENT          TAG('wPcS')  // WMI Events
#define SCSIPORT_TAG_WMI_REQUEST        TAG('WPcS')  // WMI Requests

#define SCSIPORT_TAG_REPORT_LUNS        TAG('xPcS')  // Report Luns
#define SCSIPORT_TAG_REPORT_TARGETS     TAG('XPcS')  // Report Targets
#define SCSIPORT_TAG_TEMP_ID_BUFFER     TAG('yPcS')  // Temporary id buffer
#define SCSIPORT_TAG_ID_BUFFER          TAG('YPcS')  // Id buffer
#define SCSIPORT_TAG_SYMBOLIC_LINK      TAG('zPcS')  // Symbolic link strings
#define SCSIPORT_TAG_DEVICE_NAME        TAG('ZPcS')  // Device name buffer

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool #assert(0)
#endif

#if defined(FORWARD_PROGRESS)
#define SP_RESERVED_PAGES 4
#endif

//
// The tag to use for the base remove lock.  This lock is only released when
// the device is finally ready to be destroyed.
//

#define SP_BASE_REMOVE_LOCK (UIntToPtr(0xabcdabcd))


//
// I/O System API routines which should not be called inside scsiport -
// these generally have scsiport versions which perform sanity checks before
// calling the real i/o routine in checked builds.
//

#if 0
#ifdef IoCompleteRequest
#ifndef KEEP_COMPLETE_REQUEST
#undef IoCompleteRequest
#endif
#endif
#endif

// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )

// LPVOID
// ROUND_UP_POINTER(
//     IN LPVOID Ptr,
//     IN DWORD Pow2
//     );

// If Ptr is not already aligned, then round it up until it is.
#define ROUND_UP_POINTER(Ptr,Pow2) \
        ( (PVOID) ( (((ULONG_PTR)(Ptr))+(Pow2)-1) & (~(((LONG)(Pow2))-1)) ) )


//
// Macros, constants and declarations for debug code and debug print
// routines.
//

#define DEBUG_BUFFER_LENGTH 256

#if SCSIDBG_ENABLED
extern ULONG ScsiDebug;

#ifdef DebugPrint
#undef DebugPrint
#endif

#if SCSIDBG_ENABLED

//
// Forward definition of ScsiDebugPrintInt (internal and not exported)
//
VOID
ScsiDebugPrintInt(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x) ScsiDebugPrintInt x
#else
#define DebugPrint(x)
#endif

#endif

#define ASSERT_FDO(x) ASSERT(!(((PCOMMON_EXTENSION) (x)->DeviceExtension)->IsPdo))
#define ASSERT_PDO(x) ASSERT((((PCOMMON_EXTENSION) (x)->DeviceExtension)->IsPdo))
#define ASSERT_SRB_DATA(x) ASSERT(((PSRB_DATA)(x))->Type == SRB_DATA_TYPE)

#if DBG
#define SpStartNextPacket(DevObj, Cancelable)                       \
    {                                                               \
        PADAPTER_EXTENSION ext = (DevObj)->DeviceExtension;         \
        ASSERT(!(TEST_FLAG(ext->Flags, PD_PENDING_DEVICE_REQUEST)));\
        IoStartNextPacket((DevObj), (Cancelable));                  \
    }
#else
#define SpStartNextPacket IoStartNextPacket
#endif

//
// Some type defines and random macros which don't seem to be in the
// header files i've included (or didn't exist at all)
//

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#if 0   // DBG
#undef INLINE
#define INLINE
#else
#define INLINE __inline
#endif

#define INTERLOCKED /* Should only be accessed using InterlockedXxx routines*/

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

#define TEST(Value)             ((BOOLEAN) ((Value) ? TRUE : FALSE));

#define ARRAY_ELEMENTS_FOR_BITMAP(NumberOfBits, ArrayType) \
        ((NumberOfBits) / sizeof(ArrayType))

//
// Assorted constant definifitions
//
#define NUMBER_LOGICAL_UNIT_BINS 8

#define SP_DEFAULT_PHYSICAL_BREAK_VALUE 17
#define SP_SMALL_PHYSICAL_BREAK_VALUE 4
#define SP_LARGE_PHYSICAL_BREAK_VALUE (SP_DEFAULT_PHYSICAL_BREAK_VALUE + 1)

#define SCSIPORT_CONTROL_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ScsiPort\\"
#define DISK_SERVICE_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Disk"
#define SCSIPORT_SPECIAL_TARGET_KEY L"SpecialTargetList"
#define SCSIPORT_VERIFIER_KEY L"Verifier"

//
// WMI constants
//
#define SPMOFRESOURCENAME      L"SCSIPORTWMI"
#define SPMOFREGISTRYPATH      L"SCSIPORT"

//
// NT uses a system time measured in 100 nanosecond intervals.  define
// conveninent constants for setting the timer.
//

#define MICROSECONDS        10              // 10 nanoseconds
#define MILLISECONDS        (MICROSECONDS * 1000)
#define SECONDS             (MILLISECONDS * 1000)
#define MINUTES             (SECONDS * 60)

#define TIMEOUT(x)          ((x) * -1)

//
// Possible values for the IsRemoved flag
//

#define NO_REMOVE       0
#define REMOVE_PENDING  1
#define REMOVE_COMPLETE 2

#define NUMBER_HARDWARE_STRINGS 6

#define SRB_DATA_TYPE 'wp'
#define SRB_LIST_DEPTH 20

#define NUMBER_BYPASS_SRB_DATA_BLOCKS 4

#define WMI_MINIPORT_EVENT_ITEM_MAX_SIZE 128

//
// Define the mimimum and maximum number of srb extensions which will be allocated.
//

#define MINIMUM_SRB_EXTENSIONS        16
#define MAXIMUM_SRB_EXTENSIONS       255

//
// Size of the buffer used for registry operations.
//

#define SP_REG_BUFFER_SIZE 512

//
// Number of times to retry when a BUSY status is returned.
//

#define BUSY_RETRY_COUNT 20

//
// Number of times to retry an INQUIRY request.
//

#define INQUIRY_RETRY_COUNT 2

//
// Number of irp stack locations to allocate for an INQUIRY command.
//

#define INQUIRY_STACK_LOCATIONS 1

//
// Bitmask used for aligning values.
//

#define LONG_ALIGN (sizeof(LONG) - 1)

//
// Size of the ADAPTER_EXTENSION
//

#define ADAPTER_EXTENSION_SIZE sizeof(ADAPTER_EXTENSION)

//
// Size of the buffer used for inquiry operations.  This is one more than the
// max bytes which can be requested from an inquiry operation so that we can
// zero out the buffer and be sure that the last string is null terminated.
//

#define SP_INQUIRY_BUFFER_SIZE (VPD_MAX_BUFFER_SIZE + 1)

//
// Assorted macros.
//

#define NEED_REQUEST_SENSE(Srb) (Srb->ScsiStatus == SCSISTAT_CHECK_CONDITION \
        && !(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&                 \
        Srb->SenseInfoBuffer && Srb->SenseInfoBufferLength )

#define GET_FDO_EXTENSION(HwExt) ((CONTAINING_RECORD(HwExt, HW_DEVICE_EXTENSION, HwDeviceExtension))->FdoExtension)

#define ADDRESS_TO_HASH(PathId, TargetId, Lun) (((TargetId) + (Lun)) % NUMBER_LOGICAL_UNIT_BINS)

#define IS_CLEANUP_REQUEST(irpStack)                                                                    \
        (((irpStack)->MajorFunction == IRP_MJ_CLOSE) ||                                                 \
         ((irpStack)->MajorFunction == IRP_MJ_CLEANUP) ||                                               \
         ((irpStack)->MajorFunction == IRP_MJ_SHUTDOWN) ||                                              \
         (((irpStack)->MajorFunction == IRP_MJ_SCSI) &&                                                 \
          (((irpStack)->Parameters.Scsi.Srb->Function == SRB_FUNCTION_RELEASE_DEVICE) ||                \
           ((irpStack)->Parameters.Scsi.Srb->Function == SRB_FUNCTION_FLUSH_QUEUE) ||                   \
           (TEST_FLAG((irpStack)->Parameters.Scsi.Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE |        \
                                                                 SRB_FLAGS_BYPASS_LOCKED_QUEUE)))))


#define IS_MAPPED_SRB(Srb)                                  \
        ((Srb->Function == SRB_FUNCTION_IO_CONTROL) ||      \
         ((Srb->Function == SRB_FUNCTION_EXECUTE_SCSI) &&   \
          ((Srb->Cdb[0] == SCSIOP_INQUIRY) ||               \
           (Srb->Cdb[0] == SCSIOP_REQUEST_SENSE))))

#define LU_OPERATING_IN_DEGRADED_STATE(luFlags)             \
        ((luFlags) | LU_PERF_MAXQDEPTH_REDUCED)

//
// SpIsQueuePausedForSrb(lu, srb) -
//  determines if the queue has been paused for this particular type of
//  srb.  This can be used with SpSrbIsBypassRequest to determine whether the
//  srb needs to be handled specially.
//

#define SpIsQueuePausedForSrb(luFlags, srbFlags)                                                            \
    ((BOOLEAN) ((((luFlags) & LU_QUEUE_FROZEN) && !(srbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) ||           \
                (((luFlags) & LU_QUEUE_PAUSED) && !(srbFlags & SRB_FLAGS_BYPASS_LOCKED_QUEUE))))

#define SpIsQueuePaused(lu) ((lu)->LuFlags & (LU_QUEUE_FROZEN           |   \
                                              LU_QUEUE_LOCKED))

#define SpSrbRequiresPower(srb)                                             \
    ((BOOLEAN) ((srb->Function == SRB_FUNCTION_EXECUTE_SCSI) ||             \
                 (srb->Function == SRB_FUNCTION_IO_CONTROL) ||              \
                 (srb->Function == SRB_FUNCTION_SHUTDOWN) ||                \
                 (srb->Function == SRB_FUNCTION_FLUSH) ||                   \
                 (srb->Function == SRB_FUNCTION_ABORT_COMMAND) ||           \
                 (srb->Function == SRB_FUNCTION_RESET_BUS) ||               \
                 (srb->Function == SRB_FUNCTION_RESET_DEVICE) ||            \
                 (srb->Function == SRB_FUNCTION_TERMINATE_IO) ||            \
                 (srb->Function == SRB_FUNCTION_REMOVE_DEVICE) ||           \
                 (srb->Function == SRB_FUNCTION_WMI)))

//
// Forward declarations of data structures
//

typedef struct _SRB_DATA SRB_DATA, *PSRB_DATA;

typedef struct _REMOVE_TRACKING_BLOCK
               REMOVE_TRACKING_BLOCK,
               *PREMOVE_TRACKING_BLOCK;

typedef struct _LOGICAL_UNIT_EXTENSION LOGICAL_UNIT_EXTENSION, *PLOGICAL_UNIT_EXTENSION;
typedef struct _ADAPTER_EXTENSION ADAPTER_EXTENSION, *PADAPTER_EXTENSION;

typedef struct _SP_INIT_CHAIN_ENTRY SP_INIT_CHAIN_ENTRY, *PSP_INIT_CHAIN_ENTRY;

typedef struct _HW_DEVICE_EXTENSION HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;
//
// Macros for using the DMA functions.
//

#define AllocateCommonBuffer(DmaAdapter, Length,                        \
                               LogicalAddress, CacheEnabled)            \
            ((DmaAdapter)->DmaOperations->AllocateCommonBuffer)(        \
                (DmaAdapter),                                           \
                (Length),                                               \
                (LogicalAddress),                                       \
                (CacheEnabled))
#define FreeCommonBuffer(DmaAdapter, Length, LogicalAddress,            \
                         VirtualAddress, CacheEnabled)                  \
            ((DmaAdapter)->DmaOperations->FreeCommonBuffer)(            \
                (DmaAdapter),                                           \
                (Length),                                               \
                (LogicalAddress),                                       \
                (VirtualAddress),                                       \
                (CacheEnabled))

#define GetScatterGatherList(DmaAdapter, DeviceObject, Mdl, CurrentVa,      \
                             Length, ExecutionRoutine, Context,             \
                             WriteToDevice)                                 \
            ((DmaAdapter)->DmaOperations->GetScatterGatherList)(            \
                (DmaAdapter),                                               \
                (DeviceObject),                                             \
                (Mdl),                                                      \
                (CurrentVa),                                                \
                (Length),                                                   \
                (ExecutionRoutine),                                         \
                (Context),                                                  \
                (WriteToDevice))

#define PutScatterGatherList(DmaAdapter, ScatterGather, WriteToDevice)      \
            ((DmaAdapter)->DmaOperations->PutScatterGatherList)(            \
                (DmaAdapter),                                               \
                (ScatterGather),                                            \
                (WriteToDevice))

#define AllocateAdapterChannel(DmaAdapter, DeviceObject,                    \
                               NumberOfMapRegisters, ExecutionRoutine,      \
                               Context)                                     \
            ((DmaAdapter)->DmaOperations->AllocateAdapterChannel)(          \
                (DmaAdapter),                                               \
                (DeviceObject),                                             \
                (NumberOfMapRegisters),                                     \
                (ExecutionRoutine),                                         \
                (Context))

#define FlushAdapterBuffers(DmaAdapter, Mdl, MapRegisterBase, CurrentVa,    \
                            Length, WriteToDevice)                          \
            ((DmaAdapter)->DmaOperations->FlushAdapterBuffers)(             \
                (DmaAdapter),                                               \
                (Mdl),                                                      \
                (MapRegisterBase),                                          \
                (CurrentVa),                                                \
                (Length),                                                   \
                (WriteToDevice))

#define MapTransfer(DmaAdapter, Mdl, MapRegisterBase, CurrentVa, Length,    \
                    WriteToDevice)                                          \
            ((DmaAdapter)->DmaOperations->MapTransfer)(                     \
                (DmaAdapter),                                               \
                (Mdl),                                                      \
                (MapRegisterBase),                                          \
                (CurrentVa),                                                \
                (Length),                                                   \
                (WriteToDevice))

#define FreeAdapterChannel(DmaAdapter)                                      \
            ((DmaAdapter)->DmaOperations->FreeAdapterChannel)((DmaAdapter))

#define FreeMapRegisters(DmaAdapter, MapRegisterBase, NumberOfMapRegisters) \
            ((DmaAdapter)->DmaOperations->FreeMapRegisters)(                \
                (DmaAdapter),                                               \
                (MapRegisterBase),                                          \
                (NumberOfMapRegisters))

#define PutDmaAdapter(DmaAdapter)                                           \
            ((DmaAdapter)->DmaOperations->PutDmaAdapter)((DmaAdapter))

//
// Type Definitions
//

//
// Structure used for tracking remove lock allocations in checked builds
//

struct _REMOVE_TRACKING_BLOCK {
    PREMOVE_TRACKING_BLOCK NextBlock;
    PVOID Tag;
    LARGE_INTEGER TimeLocked;
    PCSTR File;
    ULONG Line;
};

#if DBG
#define SpAcquireRemoveLock(devobj, tag) \
    SpAcquireRemoveLockEx(devobj, tag, __file__, __LINE__)
#endif

typedef struct _RESET_COMPLETION_CONTEXT {
    PIRP           OriginalIrp;
    PDEVICE_OBJECT SafeLogicalUnit;
    PDEVICE_OBJECT AdapterDeviceObject;

    SCSI_REQUEST_BLOCK Srb;
} RESET_COMPLETION_CONTEXT, *PRESET_COMPLETION_CONTEXT;

//
// Define a pointer to the synchonize execution routine.
//

typedef
BOOLEAN
(*PSYNCHRONIZE_ROUTINE) (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

typedef
VOID
(*PSP_ENABLE_DISABLE_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    );

typedef
VOID
(*PSP_POWER_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

//
// device type table to build id's from
//

typedef const struct _SCSIPORT_DEVICE_TYPE {

    const PCSTR DeviceTypeString;

    const PCSTR GenericTypeString;

    const PCWSTR DeviceMapString;

    const BOOLEAN IsStorage;

} SCSIPORT_DEVICE_TYPE, *PSCSIPORT_DEVICE_TYPE;

//
// SCSI Get Configuration Information
//
// LUN Information
//

typedef struct _LOGICAL_UNIT_INFO {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    struct _LOGICAL_UNIT_INFO *NextLunInfo;
    UCHAR InquiryData[INQUIRYDATABUFFERSIZE];
} LOGICAL_UNIT_INFO, *PLOGICAL_UNIT_INFO;

typedef struct _SCSI_BUS_SCAN_DATA {
    USHORT Length;
    UCHAR InitiatorBusId;
    UCHAR NumberOfLogicalUnits;
    PLOGICAL_UNIT_INFO LunInfoList;
} SCSI_BUS_SCAN_DATA, *PSCSI_BUS_SCAN_DATA;

typedef struct _SCSI_CONFIGURATION_INFO {
    UCHAR NumberOfBuses;
    PSCSI_BUS_SCAN_DATA BusScanData[1];
} SCSI_CONFIGURATION_INFO, *PSCSI_CONFIGURATION_INFO;

//
// Adapter object transfer information.
//

typedef struct _ADAPTER_TRANSFER {
    PSRB_DATA SrbData;
    ULONG SrbFlags;
    PVOID LogicalAddress;
    ULONG Length;
}ADAPTER_TRANSFER, *PADAPTER_TRANSFER;

#ifdef USE_DMA_MACROS

typedef SCATTER_GATHER_ELEMENT SRB_SCATTER_GATHER, *PSRB_SCATTER_GATHER;

#else 

typedef struct _SRB_SCATTER_GATHER {
    SCSI_PHYSICAL_ADDRESS Address;
    ULONG Length;
}SRB_SCATTER_GATHER, *PSRB_SCATTER_GATHER;

#endif

//
// Port driver error logging
//

typedef struct _ERROR_LOG_ENTRY {
    UCHAR MajorFunctionCode;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG ErrorCode;
    ULONG UniqueId;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;
} ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;

//
// Context item for asynchronous enumerators.
//

typedef struct _SP_ENUMERATION_REQUEST SP_ENUMERATION_REQUEST, *PSP_ENUMERATION_REQUEST;

typedef
VOID
(*PSP_ENUMERATION_COMPLETION_ROUTINE) (
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Status
    );

struct _SP_ENUMERATION_REQUEST {

    //
    // A pointer to the next enumeration request on the list.
    //

    PSP_ENUMERATION_REQUEST NextRequest;

    //
    // The completion routine to be run.  This routine will be run regardless
    // of whether the enumeration actually succeeds.  The
    // EnumerationDeviceMutex and the EnumerationWorklistMutex will both be
    // held when this is called.  The completion routine should free the Request
    // structure if necessary.
    //

    PSP_ENUMERATION_COMPLETION_ROUTINE CompletionRoutine;

    //
    // If this filed contains a pointer to an IO_STATUS_BLOCK then the
    // completion routine should write it's status value out.  This is so a
    // synchronous waiter can return something other than STATUS_PENDING to the
    // caller.  If this field is NULL then there is no consumer for the status
    // value.
    //

    PNTSTATUS OPTIONAL CompletionStatus;

    //
    // Arbitrary context value for the completion routine to use.  In most cases
    // this will be an IRP or an event.
    //

    PVOID Context;

    //
    // Indicates whether this request is being handled synchronously.
    //

    BOOLEAN Synchronous;
};

//
// SCSI request extension for port driver.
//

typedef
VOID
(FASTCALL *PSRB_DATA_FREE_ROUTINE) (
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );

struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _SRB_DATA {

    //
    // Single list entry.  The lookaside list will be maintained in this
    // memory.
    //

    SINGLE_LIST_ENTRY Reserved;

    //
    // Header for debugging purposes.
    //

    CSHORT Type;
    USHORT Size;

    //
    // The free routine for this srb data block.
    //

    PSRB_DATA_FREE_ROUTINE FreeRoutine;

    //
    // The list of requests for a particular logical unit.
    //

    LIST_ENTRY RequestList;

    //
    // The logical unit this request is intended for.
    //

    PLOGICAL_UNIT_EXTENSION LogicalUnit;

    //
    // The irp for the CurrentSrb.
    //

    PIRP CurrentIrp;

    //
    // The srb this is block is tracking.
    //

    PSCSI_REQUEST_BLOCK CurrentSrb;

    //
    // The chain of requests which have been completed by the miniport and are
    // waiting for the CompletionDpc to be run.
    //

    struct _SRB_DATA *CompletedRequests;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;

#ifdef USE_DMA_MACROS
    PSCATTER_GATHER_LIST MapRegisterBase;
#else 
    PVOID MapRegisterBase;
#endif

    ULONG NumberOfMapRegisters;

    //
    // The offset between the  data buffer for this request and the data
    // buffer described by the MDL in the irp.
    //

    ULONG_PTR DataOffset;

    PVOID RequestSenseSave;

    //
    // These data values will be restored to the SRB when it is retried within
    // the port driver.
    //

    ULONG OriginalDataTransferLength;

    //
    // SRB Data flags.
    //

    ULONG Flags;

    //
    // Pointer to the adapter this block was allocated from.  This is used
    // when freeing srbdata blocks from the lookaside list back to pool.
    //

    PADAPTER_EXTENSION Adapter;

    //
    // The queue tag which was initially allocated for this srb_data block.
    // This tag will be used for any tagged srb's which are associated with
    // this block.
    //

    ULONG QueueTag;

    //
    // Internal status value - only returned if srb->SrbStatus is set to
    // SRBP_STATUS_INTERNAL_ERROR.
    //

    NTSTATUS InternalStatus;

    //
    // The tick count when this request was last touched.
    //

    ULONG TickCount;

    //
    // The MDL of the remapped buffer (per IoMapTransfer or GET_SCATTER_GATHER)
    //

    PMDL RemappedMdl;

    //
    // The original data buffer pointer for this request - this will be
    // restored when the request is completed.
    //

    PVOID OriginalDataBuffer;

    //
    // Pointer to the scatter gather list for this request
    //

    PSRB_SCATTER_GATHER ScatterGatherList;

    //
    // The original length of the sense data buffer supplied by the above
    // driver.
    //

    UCHAR RequestSenseLengthSave;

    //
    // Pointer to the orignal SRB DataBuffer.  We use this to store
    // the original when we replace it with our buffer to unmapped
    // memory in the case where the MapBuffer is FALSE.
    //

    PVOID UnmappedDataBuffer;

#ifndef USE_DMA_MACROS
    //
    // The "small" scatter gather list for this request.  Small
    // by the constant SP_SMALL_PHYSICAL_BREAK_VALUE - small lists contain
    // this many entries or less.
    //

    SRB_SCATTER_GATHER SmallScatterGatherList[SP_SMALL_PHYSICAL_BREAK_VALUE];
#endif

};

typedef struct _LOGICAL_UNIT_BIN {
    KSPIN_LOCK Lock;
    PLOGICAL_UNIT_EXTENSION List;
} LOGICAL_UNIT_BIN, *PLOGICAL_UNIT_BIN;

//
// WMI request item, queued on a miniport request.
//

typedef struct _WMI_MINIPORT_REQUEST_ITEM {
   //
   // WnodeEventItem MUST be the first field in WMI_MINIPORT_REQUEST_ITEM, in
   // order to accommodate a copy optimization in ScsiPortCompletionDpc().
   //
   UCHAR  WnodeEventItem[WMI_MINIPORT_EVENT_ITEM_MAX_SIZE];
   UCHAR  TypeOfRequest;                                  // [Event/Reregister]
   UCHAR  PathId;                                         // [0xFF for adapter]
   UCHAR  TargetId;
   UCHAR  Lun;
   struct _WMI_MINIPORT_REQUEST_ITEM * NextRequest;
} WMI_MINIPORT_REQUEST_ITEM, *PWMI_MINIPORT_REQUEST_ITEM;

//
// WMI parameters.
//

typedef struct _WMI_PARAMETERS {
   ULONG_PTR ProviderId; // ProviderId parameter from IRP
   PVOID DataPath;      // DataPath parameter from IRP
   ULONG BufferSize;    // BufferSize parameter from IRP
   PVOID Buffer;        // Buffer parameter from IRP
} WMI_PARAMETERS, *PWMI_PARAMETERS;

//
// SpInsertFreeWmiMiniPortItem context structure.
//

typedef struct _WMI_INSERT_CONTEXT {
   PDEVICE_OBJECT             DeviceObject;                     // [FDO or PDO]
   PWMI_MINIPORT_REQUEST_ITEM ItemsToInsert;
} WMI_INSERT_CONTEXT, *PWMI_INSERT_CONTEXT;

//
// SpRemoveFreeWmiMiniPortItem context structure.
//

typedef struct _WMI_REMOVE_CONTEXT {
   PDEVICE_OBJECT             DeviceObject;                     // [FDO or PDO]
   USHORT                     NumberToRemove;
} WMI_REMOVE_CONTEXT, *PWMI_REMOVE_CONTEXT;

//
// Define data storage for access at interrupt Irql.
//

typedef struct _INTERRUPT_DATA {

    //
    // SCSI port interrupt flags
    //

    ULONG InterruptFlags;

    //
    // List head for singlely linked list of complete IRPs.
    //

    PSRB_DATA CompletedRequests;

    //
    // Adapter object transfer parameters.
    //

    ADAPTER_TRANSFER MapTransferParameters;

    //
    // Error log information.
    //

    ERROR_LOG_ENTRY  LogEntry;

    //
    // Logical unit to start next.
    //

    PLOGICAL_UNIT_EXTENSION ReadyLogicalUnit;

    //
    // List of completed abort reqeusts.
    //

    PLOGICAL_UNIT_EXTENSION CompletedAbort;

    //
    // Miniport timer request routine.
    //

    PHW_INTERRUPT HwTimerRequest;

    //
    // Mini port timer request time in micro seconds.
    //

    ULONG MiniportTimerValue;

    //
    // Queued WMI request items.
    //

    PWMI_MINIPORT_REQUEST_ITEM WmiMiniPortRequests;

} INTERRUPT_DATA, *PINTERRUPT_DATA;

#define NON_STANDARD_VPD_SUPPORTS_PAGE80 0x00000001
#define NON_STANDARD_VPD_SUPPORTS_PAGE83 0x00000002

typedef struct {
    ULONG SparseLun;
    ULONG OneLun;
    ULONG LargeLuns;
    ULONG SetLunInCdb;
    ULONG NonStandardVPD;
    ULONG BinarySN;
} SP_SPECIAL_CONTROLLER_FLAGS, *PSP_SPECIAL_CONTROLLER_FLAGS;

typedef struct _CONFIGURATION_CONTEXT {
    BOOLEAN DisableTaggedQueueing;
    BOOLEAN DisableMultipleLu;
    ULONG AdapterNumber;
    ULONG BusNumber;
    PVOID Parameter;
    PACCESS_RANGE AccessRanges;
    UNICODE_STRING RegistryPath;
    PORT_CONFIGURATION_INFORMATION PortConfig;
}CONFIGURATION_CONTEXT, *PCONFIGURATION_CONTEXT;

typedef struct _DEVICE_MAP_HANDLES {
    HANDLE BusKey;
    HANDLE InitiatorKey;
} DEVICE_MAP_HANDLES, *PDEVICE_MAP_HANDLES;

typedef struct _COMMON_EXTENSION {

    //
    // Back pointer to the device object
    //

    PDEVICE_OBJECT DeviceObject;

    struct {

        //
        // True if this device object is a physical device object
        //

        BOOLEAN IsPdo : 1;

        //
        // True if this device object has processed it's first start and
        // has been initialized.
        //

        BOOLEAN IsInitialized : 1;

        //
        // Has WMI been initialized for this device object?
        //

        BOOLEAN WmiInitialized : 1;

        //
        // Has the miniport associated with this FDO or PDO indicated WMI
        // support?
        //

        BOOLEAN WmiMiniPortSupport : 1;

        //
        // Has the miniport been initialized for WMI.
        //

        BOOLEAN WmiMiniPortInitialized : 1;

    };

    //
    // Current plug and play state or 0xff if no state operations have been
    // sent yet.
    //

    UCHAR CurrentPnpState;

    //
    // Previous plug and play state or 0xff if there is no requirement that we
    // be able to roll back in the current state (current state is not a query)
    //

    UCHAR PreviousPnpState;

    //
    // Interlocked counter indicating that the device has been removed.
    //

    ULONG IsRemoved;


    //
    // Pointer to the device object this is on top of
    //

    PDEVICE_OBJECT LowerDeviceObject;

    //
    // Srb flags to OR into all SRBs coming through this device object.
    //

    ULONG SrbFlags;

    //
    // Pointer to the dispatch table for this object
    //

    PDRIVER_DISPATCH *MajorFunction;


    //
    // Current and desired power state for this device and the system.
    //

    SYSTEM_POWER_STATE CurrentSystemState;

    DEVICE_POWER_STATE CurrentDeviceState;

    DEVICE_POWER_STATE DesiredDeviceState;

    //
    // Idle timer for this device
    //

    PULONG IdleTimer;

    //
    // Pointer to the SCSIPORT-provided WMIREGINFO structures registered on
    // behalf of the miniport for this device object.  Size is the size of the
    // entire WMIREGINFO buffer in bytes.
    //

    PWMIREGINFO WmiScsiPortRegInfoBuf;
    ULONG       WmiScsiPortRegInfoBufSize;

    //
    // INTERLOCKED counter of the number of consumers of this device object.
    // When this count goes to zero the RemoveEvent will be set.
    //

    //
    // This variable is only manipulated by SpAcquireRemoveLock and
    // SpReleaseRemoveLock.
    //

    LONG RemoveLock;

    //
    // This event will be signalled when it is safe to remove the device object
    //

    KEVENT RemoveEvent;

    //
    // The spinlock and the list are only used in checked builds to track who
    // has acquired the remove lock.  Free systems will leave these initialized
    // to 0xff (they are still in the structure to make debugging easier)
    //

    KSPIN_LOCK RemoveTrackingSpinlock;

    PVOID RemoveTrackingList;

    LONG RemoveTrackingUntrackedCount;

    NPAGED_LOOKASIDE_LIST RemoveTrackingLookasideList;

    BOOLEAN RemoveTrackingLookasideListInitialized;

    //
    // Count of different services this device is being used for (ala
    // IRP_MN_DEVICE_USAGE_NOTIFICATION)
    //

    ULONG PagingPathCount;
    ULONG HibernatePathCount;
    ULONG DumpPathCount;

} COMMON_EXTENSION, *PCOMMON_EXTENSION;

typedef struct _VERIFIER_EXTENSION {

    //
    // Miniport routines we verify.
    //

    PHW_FIND_ADAPTER    RealHwFindAdapter;
    PHW_INITIALIZE      RealHwInitialize;
    PHW_STARTIO         RealHwStartIo;
    PHW_INTERRUPT       RealHwInterrupt;
    PHW_RESET_BUS       RealHwResetBus;
    PHW_DMA_STARTED     RealHwDmaStarted;
    PHW_INTERRUPT       RealHwRequestInterrupt;
    PHW_INTERRUPT       RealHwTimerRequest;
    PHW_ADAPTER_CONTROL RealHwAdapterControl;

    //
    // Indicates the number of common buffer blocks that have been allocated.
    //

    ULONG CommonBufferBlocks;

    //
    // Points to an array that holds the VAs of all the common blocks.
    //

    PVOID* CommonBufferVAs;

    //
    // Points to an array that holds the PAs of all the common blocks.
    //

    PHYSICAL_ADDRESS* CommonBufferPAs;

    //
    // Indicates the size of the non-cached extension.
    //

    ULONG NonCachedBufferSize;

    //
    // Controls how aggressively we verify.
    //

    ULONG VrfyLevel;

    //
    // Pointer to an invalid page of memory.  Used to catch miniports
    // that touch memory when they're not supposed to.
    //

    PVOID InvalidPage;

    //
    // Indicates whether the common buffer blocks were allocated using
    // DMA common buffer allocation routine.
    //

    BOOLEAN IsCommonBuffer;

} VERIFIER_EXTENSION, *PVERIFIER_EXTENSION;


struct _ADAPTER_EXTENSION {

    union {
        PDEVICE_OBJECT DeviceObject;
        COMMON_EXTENSION CommonExtension;
    };

    //
    // Pointer to the PDO we attached to - necessary for PnP routines
    //

    PDEVICE_OBJECT LowerPdo;

#if TEST_LISTS

    //
    // Some simple performance counters to determine how often we use the
    // small vs. medium vs. large scatter gather lists.
    //

    ULONGLONG ScatterGatherAllocationCount;

    //
    // Counters used to calculate the average size of a small medium and
    // large allocation.  There are two values for each counter - a total
    // count and an overflow count.  The total count will be right-shifted one
    // bit if it overflows on an increment.  When this happens the overflow
    // count will also be incremented.  This count is used to adjust the
    // allocation count when determining averages.
    //

    ULONGLONG SmallAllocationSize;
    ULONGLONG MediumAllocationSize;
    ULONGLONG LargeAllocationSize;

    ULONG SmallAllocationCount;
    ULONG LargeAllocationCount;

    //
    // Counters to determine how often we can service a request off the
    // srb data list, how often we need to queue a request and how often
    // we can resurrect a free'd srb data to service something off the queue.
    //

    INTERLOCKED ULONGLONG SrbDataAllocationCount;
    INTERLOCKED ULONGLONG SrbDataQueueInsertionCount;
    INTERLOCKED ULONGLONG SrbDataEmergencyFreeCount;
    INTERLOCKED ULONGLONG SrbDataServicedFromTickHandlerCount;
    INTERLOCKED ULONGLONG SrbDataResurrectionCount;

#endif

    //
    // Device extension for miniport routines.
    //

    PVOID HwDeviceExtension;

    //
    // Miniport noncached device extension
    //

    PVOID NonCachedExtension;
    ULONG NonCachedExtensionSize;

    ULONG PortNumber;

    ULONG AdapterNumber;

    //
    // Active requests count.  This count is biased by -1 so a value of -1
    // indicates there are no requests out standing.
    //

    LONG ActiveRequestCount;

    //
    // Binary Flags
    //

    typedef struct {

        //
        // Did pnp or the port driver detect this device and provide resources
        // to the miniport, or did the miniport detect the device for us.  This
        // flag also indicates whether the AllocatedResources list is non-null
        // going into the find adapter routine.
        //

        BOOLEAN IsMiniportDetected : 1;

        //
        // Do we need to virtualize this adapter and make it look like the only
        // adapter on it's own bus?
        //

        BOOLEAN IsInVirtualSlot : 1;

        //
        // Is this a pnp adapter?
        //

        BOOLEAN IsPnp : 1;

        //
        // Was an interrupt assigned to this device by the system?
        //

        BOOLEAN HasInterrupt : 1;

        //
        // Can this device be powered off?
        //

        BOOLEAN DisablePower : 1;

        //
        // Can this device be stopped?
        //

        BOOLEAN DisableStop : 1;

        //
        // Does this device need power notification on shutdown?
        //

        BOOLEAN NeedsShutdown : 1;

    };

    //
    // For most virtual slot devices this will be zero.  However for some
    // the real slot/function number is needed by the miniport to access
    // hardware shared by multiple slots/functions.
    //

    PCI_SLOT_NUMBER VirtualSlotNumber;

    //
    // The bus and slot number of this device as returned by the PCI driver.
    // This is used when building the ConfigInfo block for crashdump so that
    // the dump drivers can talk directly with the hal.  These are only
    // valid if IsInVirtualSlot is TRUE above.
    //

    ULONG RealBusNumber;

    ULONG RealSlotNumber;

    //
    // Number of SCSI buses
    //

    UCHAR NumberOfBuses;
    UCHAR MaximumTargetIds;
    UCHAR MaxLuCount;

    //
    // SCSI port driver flags
    //

    ULONG Flags;

    INTERLOCKED ULONG DpcFlags;

    //
    // The number of times this adapter has been disabled.
    //

    ULONG DisableCount;

    LONG PortTimeoutCounter;

    //
    // A pointer to the interrupt object to be used with
    // the SynchronizeExecution routine.  If the miniport is
    // using SpSynchronizeExecution then this will actually point
    // back to the adapter extension.
    //

    PKINTERRUPT InterruptObject;

    //
    // Second Interrupt object (PCI IDE work-around)
    //

    PKINTERRUPT InterruptObject2;

    //
    // Routine to call to synchronize execution for the miniport.
    //

    PSYNCHRONIZE_ROUTINE  SynchronizeExecution;

    //
    // Global device sequence number.
    //

    ULONG SequenceNumber;
    KSPIN_LOCK SpinLock;

    //
    // Second spin lock (PCI IDE work-around).  This is only initalized
    // if the miniport has requested multiple interrupts.
    //

    KSPIN_LOCK MultipleIrqSpinLock;

    //
    // Dummy interrupt spin lock.
    //

    KSPIN_LOCK InterruptSpinLock;

    //
    // Dma Adapter information.
    //

    PVOID MapRegisterBase;
    PDMA_ADAPTER DmaAdapterObject;
    ADAPTER_TRANSFER FlushAdapterParameters;

    //
    // miniport's copy of the configuraiton informaiton.
    // Used only during initialization.
    //

    PPORT_CONFIGURATION_INFORMATION PortConfig;

    //
    // Resources allocated and translated for this particular adapter.
    //

    PCM_RESOURCE_LIST AllocatedResources;

    PCM_RESOURCE_LIST TranslatedResources;

    //
    // Common buffer size.  Used for HalFreeCommonBuffer.
    //

    ULONG CommonBufferSize;
    ULONG SrbExtensionSize;

    //
    // Indicates whether the common buffer was allocated using
    // ALLOCATE_COMMON_BUFFER or MmAllocateContiguousMemorySpecifyCache.
    //

    BOOLEAN UncachedExtensionIsCommonBuffer;

    //
    // The number of srb extensions which were allocated.
    //

    ULONG SrbExtensionCount;

    //
    // Placeholder for the minimum number of requests to allocate for.
    // This can be a registry parameter.
    //

    ULONG NumberOfRequests;

    //
    // SrbExtension and non-cached common buffer
    //

    PVOID SrbExtensionBuffer;

    //
    // List head of free SRB extentions.
    //

    PVOID SrbExtensionListHeader;

    //
    // A bitmap for keeping track of which queue tags are in use.
    //

    KSPIN_LOCK QueueTagSpinLock;
    PRTL_BITMAP QueueTagBitMap;

    UCHAR MaxQueueTag;

    //
    // Hint for allocating queue tags.  Value will be the last queue
    // tag allocated + 1.
    //

    ULONG QueueTagHint;

    //
    // Logical Unit Extensions
    //

    ULONG HwLogicalUnitExtensionSize;

    //
    // List of mapped address entries for use when powering up the adapter
    // or cleaning up its mappings.
    //

    PMAPPED_ADDRESS MappedAddressList;

    //
    // List of free mapped address blocks preallocated by scsiport before 
    // calling HwFindAdapter.  One is allocated for each memory range in the 
    // miniport's resource list.  As ranges are unmapped their blocks will 
    // be placed here for potential reuse by the miniport's HwFindAdapter 
    // routine.
    //

    PMAPPED_ADDRESS FreeMappedAddressList;

    //
    // Miniport service routine pointers.
    //

    PHW_FIND_ADAPTER HwFindAdapter;
    PHW_INITIALIZE HwInitialize;
    PHW_STARTIO HwStartIo;
    PHW_INTERRUPT HwInterrupt;
    PHW_RESET_BUS HwResetBus;
    PHW_DMA_STARTED HwDmaStarted;
    PHW_INTERRUPT HwRequestInterrupt;
    PHW_INTERRUPT HwTimerRequest;
    PHW_ADAPTER_CONTROL HwAdapterControl;

    ULONG InterruptLevel;
    ULONG IoAddress;

    //
    // BitMap containing the list of supported adapter control types for this
    // adapter/miniport.
    //

    RTL_BITMAP SupportedControlBitMap;
    ULONG SupportedControlBits[ARRAY_ELEMENTS_FOR_BITMAP(
                                    (ScsiAdapterControlMax),
                                    ULONG)];

    //
    // Array of logical unit extensions.
    //

    LOGICAL_UNIT_BIN LogicalUnitList[NUMBER_LOGICAL_UNIT_BINS];

    //
    // The last logical unit for which the miniport completed a request.  This
    // will give us a chance to stay out of the LogicalUnitList for the common
    // completion type.
    //
    // This value is set by ScsiPortNotification and will be cleared by
    // SpRemoveLogicalUnitFromBin.
    //

    PLOGICAL_UNIT_EXTENSION CachedLogicalUnit;

    //
    // Interrupt level data storage.
    //

    INTERRUPT_DATA InterruptData;

    //
    // Whether or not an interrupt has occured since the last timeout.
    // Used to determine if interrupts may not be getting delivered.
    // This value must be set within KeSynchronizeExecution
    //

    ULONG WatchdogInterruptCount;

    //
    // SCSI Capabilities structure
    //

    IO_SCSI_CAPABILITIES Capabilities;

    //
    // Miniport timer object.
    //

    KTIMER MiniPortTimer;

    //
    // Miniport DPC for timer object.
    //

    KDPC MiniPortTimerDpc;

    //
    // Physical address of common buffer
    //

    PHYSICAL_ADDRESS PhysicalCommonBuffer;

    //
    // Buffers must be mapped into system space.
    //

    BOOLEAN MapBuffers;

    //
    // Buffers must be remapped into system space after IoMapTransfer has been
    // called.
    //

    BOOLEAN RemapBuffers;

    //
    // Is this device a bus master and does it require map registers.
    //

    BOOLEAN MasterWithAdapter;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Supports auto request sense.
    //

    BOOLEAN AutoRequestSense;

    //
    // Supports multiple requests per logical unit.
    //

    BOOLEAN MultipleRequestPerLu;

    //
    // Support receive event function.
    //

    BOOLEAN ReceiveEvent;

    //
    // Indicates an srb extension needs to be allocated.
    //

    BOOLEAN AllocateSrbExtension;

    //
    // Indicates the contorller caches data.
    //

    BOOLEAN CachesData;

    //
    // Indicates that the adapter can handle 64-bit DMA.
    //

    BOOLEAN Dma64BitAddresses;

    //
    // Indicates that the adapter can handle 32-bit DMA.
    //

    BOOLEAN Dma32BitAddresses;

    //
    // Queued WMI request items that are not in use.
    //
    INTERLOCKED SLIST_HEADER    WmiFreeMiniPortRequestList;
    KSPIN_LOCK                  WmiFreeMiniPortRequestLock;
    INTERLOCKED ULONG           WmiFreeMiniPortRequestWatermark;
    INTERLOCKED ULONG           WmiFreeMiniPortRequestCount;
    BOOLEAN                     WmiFreeMiniPortRequestInitialized;

    //
    // Free WMI request items were exhausted at least once in the lifetime
    // of this adapter (used to log error only once).
    //

    BOOLEAN                    WmiFreeMiniPortRequestsExhausted;

    //
    // This mutex is used to synchronize access & modification of the list
    // of devices during enumeration & reporting.
    //

    KMUTEX EnumerationDeviceMutex;

    //
    // This fast-mutex is used to protect the enumeration work-item and
    // the list of completion routines to be run once an enumeration is
    // finished.
    //

    FAST_MUTEX EnumerationWorklistMutex;

    //
    // System time of the last bus scan.  This is protected by the
    // EnumerationWorkListMutex.
    //

    LARGE_INTEGER LastBusScanTime;

    //
    // Indicates that the next rescan which comes in should be "forced", ie.
    // it should rescan no matter how recent the last one was.
    //

    INTERLOCKED LONG ForceNextBusScan;

    //
    // A work item to use in enumerating the bus.
    //

    WORK_QUEUE_ITEM EnumerationWorkItem;

    //
    // A pointer to the thread the workitem is running on.  This is for
    // debugging purposes.
    //

    PKTHREAD EnumerationWorkThread;

    //
    // If this is TRUE then there is already an enumeration worker thread
    // running.  If FALSE then the work item must be requeued.  This flag is
    // protected by the EnumerationWorklistMutex
    //

    BOOLEAN EnumerationRunning;

    //
    // A list of enumeration requests.  When an bus scan is completed the
    // scanner should run through the list of enumeration requests and complete
    // each one.  This list is protected by the EnumerationWorklistMutex.
    //

    PSP_ENUMERATION_REQUEST EnumerationWorkList;

    //
    // A pointer to the PNP enumeration request object.  This is used so
    // so we can use interlocked exchange to determine if the block is
    // in use.
    //

    PSP_ENUMERATION_REQUEST PnpEnumRequestPtr;

    //
    // An enumeration request to use for PNP enumeration requests.  Since there
    // will only be one of these outstanding at any time we can statically
    // allocate one for that case.
    //

    SP_ENUMERATION_REQUEST PnpEnumerationRequest;

    //
    // A lookaside list to pull SRB_DATA blocks off of.
    //

    NPAGED_LOOKASIDE_LIST SrbDataLookasideList;

    //
    // The following members are used to keep an SRB_DATA structure allocated
    // for emergency use and to queue requests which need to use it.  The
    // structures are synchronized with the EmergencySrbDataSpinLock.
    // The routines Sp[Allocate|Free]SrbData & ScsiPortTickHandler will
    // handle queueing and eventual restarting of these requests.
    //

    //
    // This spinlock protects the blocked request list.
    //

    KSPIN_LOCK EmergencySrbDataSpinLock;

    //
    // Contains a queue of irps which could not be dispatched because of
    // low memory conditions and because the EmergencySrbData block is already
    // allocated.
    //

    LIST_ENTRY SrbDataBlockedRequests;

    //
    // The SRB_DATA reserved for "emergency" use.  This pointer should be set
    // to NULL if the SRB_DATA is in use.  Any SRB_DATA block may be used
    // for the emergency request.
    //

    INTERLOCKED PSRB_DATA EmergencySrbData;

    //
    // Flags to indicate whether the srbdata and scatter gather lookaside
    // lists have been allocated already.
    //

    BOOLEAN SrbDataListInitialized;

#ifndef USE_DMA_MACROS
    BOOLEAN MediumScatterGatherListInitialized;

    //
    // Sizes for small, medium and large scatter gather lists.  This is the
    // number of entries in the list, not the number of bytes.
    //

    UCHAR LargeScatterGatherListSize;

    //
    // Lookaside list for medium scatter gather lists.  Medium lists are used
    // to service anything between a small and large number of physical
    // breaks.
    //

    NPAGED_LOOKASIDE_LIST MediumScatterGatherLookasideList;
#endif

    //
    // Bus standard interface.  Retrieved from the lower driver immediately
    // after it completes the start irp.
    //

    BOOLEAN LowerBusInterfaceStandardRetrieved;
    BUS_INTERFACE_STANDARD LowerBusInterfaceStandard;

    //
    // Handles into the device map for the various entries this adapter will
    // have created.
    //

    //
    // An array of handles for each

    HANDLE PortDeviceMapKey;

    PDEVICE_MAP_HANDLES BusDeviceMapKeys;

    //
    // Unicode string containing the device name of this object
    //

    PWSTR DeviceName;

    //
    // The guid for the underlying bus.  Saved here so we don't have to
    // retrieve it so often.
    //

    GUID BusTypeGuid;

    //
    // The pnp interface name for this device.
    //

    UNICODE_STRING InterfaceName;

    //
    // The device state for this adapter.
    //

    PNP_DEVICE_STATE DeviceState;

    //
    // The number of calls to ScsiPortTickHandler for this adapter since
    // the machine was booted.
    //

    INTERLOCKED ULONG TickCount;

    //
    // Preallocated memory to use for IssueInquiry.  The InquiryBuffer is used
    // to retreive the inquiry data and the serial number for the device.
    //

    PVOID InquiryBuffer;
    PSENSE_DATA InquirySenseBuffer;
    PIRP InquiryIrp;
    PMDL InquiryMdl;

    //
    // Mutex used to synchronize multiple threads all synchronously waiting for
    // a power up to occur.
    //

    FAST_MUTEX PowerMutex;

    //
    // A pointer to a logical unit which is used to scan empty locations on the
    // bus.
    //

    PLOGICAL_UNIT_EXTENSION RescanLun;

    //
    // The number of additional sense bytes supported by this adapter.
    //

    UCHAR AdditionalSenseBytes;

    //
    // Configurable timeout value for request sense commands.
    //

    UCHAR RequestSenseTimeout;

    //
    // Indicates whether the SenseData WMI event is enabled.
    //

    BOOLEAN EnableSenseDataEvent;

    //
    // Identifies the event class used to generate sense data wmi events.
    //

    GUID SenseDataEventClass;

    //
    // Pointer to verifier state that gets allocated and initialized when
    // scsiport's verifier is enabled.
    //

    PVERIFIER_EXTENSION VerifierExtension;

    //
    // The minimum & maximum addresses for common buffer.  These are loaded 
    // from [Minimum|Maximum]UCXAddress in the registry.
    //

    PHYSICAL_ADDRESS MinimumCommonBufferBase;
    PHYSICAL_ADDRESS MaximumCommonBufferBase;

#if defined(FORWARD_PROGRESS)
    //
    // Pointer to a block of reserved pages we use to make forward progress
    // in low memory conditons.
    //

    PVOID ReservedPages;

    //
    // Pointer to an emergency MDL we can use if we cannot allocate one
    //

    PMDL ReservedMdl;
#endif

    //
    // Identified how many successfully completed requests are required to
    // restore a LUN on this adapter from a degraded performation state
    // with respect to MaxQueueDepth.
    //

    ULONG RemainInReducedMaxQueueState;

    //
    // This value dictates on what type of boundary an adapter's uncached extension
    // must be aligned.
    //

    ULONG UncachedExtAlignment;

    //
    // This value is used to keep track of the number of instances of the
    // SRB_DATA free routine is running.  This helps us avoid a nasty recursion
    // brought on by synchronously completing requests and starting blocked
    // requests waiting for SRB_DATA objects.
    //

    LONG SrbDataFreeRunning;

    //
    // This boolean indicates whether the adapter supports multiconcurrent
    // requests.  This means it either supports tagged queuing or multiple
    // requests per logical unit.
    //
    
    BOOLEAN SupportsMultipleRequests;
};

struct _LOGICAL_UNIT_EXTENSION {

    union {
        PDEVICE_OBJECT DeviceObject;
        COMMON_EXTENSION CommonExtension;
    };

    //
    // Logical Unit flags
    //

    ULONG LuFlags;

    //
    // The adapter number this device is attached to
    //

    ULONG PortNumber;

    //
    // Has this device been claimed by a driver (legacy or pnp)
    //

    BOOLEAN IsClaimed;

    BOOLEAN IsLegacyClaim;

    //
    // Has this device been enumerated yet?  If so then we cannot actually
    // delete it until we've explicitly told the PNP system that it's gone
    // (by not enumerating it)
    //

    BOOLEAN IsEnumerated;

    //
    // Has this device gone missing?
    //

    BOOLEAN IsMissing;

    //
    // Is this device visible - should it be exposed to PNP?
    //

    BOOLEAN IsVisible;

    //
    // Was this device marked missing because we found something different at
    // it's bus location?  If so then the removal of this device from the
    // logical unit bins will trigger a new bus scan.
    //

    BOOLEAN IsMismatched;

    //
    // Is this lun temporary?  Temporary luns are used to scan bus locations
    // which are believed to be empty.  They are the only luns which can be
    // swapped out of the logical unit list.
    //

    BOOLEAN IsTemporary;

    //
    // Indicates that this device needs to have an inquiry sent to it to
    // determine if it's still present.  This flag is cleared if the inquiry
    // succeeds and the inquiry data matches what was previously read at that
    // address.  If this flag is set when SpPurgeTarget is called then the
    // lun will be marked as missing.
    //

    ULONG NeedsVerification;

    //
    // The bus address of this device.
    //

    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;

    //
    // The number of times the current busy request has been retried
    //

    UCHAR RetryCount;

    //
    // The current queue sort key
    //

    ULONG CurrentKey;

    //
    // A pointer to the miniport's logical unit extension.
    //

    PVOID HwLogicalUnitExtension;

    //
    // A pointer to the device extension for the adapter.
    //

    PADAPTER_EXTENSION AdapterExtension;

    //
    // The number of unreleased queue locks on this device
    //

    ULONG QueueLockCount;

    //
    // Reference counts for pausing & unpausing the queue (see LU_QUEUE_PAUSED)
    //

    ULONG QueuePauseCount;

    //
    // List of lock & unlock requests which are waiting to be dispatched.
    //

    KDEVICE_QUEUE LockRequestQueue;

    //
    // The currently operating lock request.
    //

    PSRB_DATA CurrentLockRequest;

    //
    // A pointer to the next logical unit extension in the logical unit bin.
    //

    PLOGICAL_UNIT_EXTENSION NextLogicalUnit;

    //
    // Used to chain logical units in the interrupt data block.
    //

    PLOGICAL_UNIT_EXTENSION ReadyLogicalUnit;

    //
    // Used to chain completed abort requests in the interrupt data block.
    //

    PLOGICAL_UNIT_EXTENSION CompletedAbort;

    //
    // The current abort request for this logical unit
    //

    PSCSI_REQUEST_BLOCK AbortSrb;

    //
    // Timeout counter for this logical unit
    //

    LONG RequestTimeoutCounter;

    //
    // The list of requests for this logical unit.
    //

    LIST_ENTRY RequestList;

    //
    // The next request to be executed.
    //

    PSRB_DATA PendingRequest;

    //
    // This irp could not be executed before because the
    // device returned BUSY.
    //

    PSRB_DATA BusyRequest;

    //
    // The current untagged request for this logical unit.
    //

    PSRB_DATA CurrentUntaggedRequest;

    //
    // The maximum number of request which we will issue to the device
    //

    UCHAR MaxQueueDepth;

    //
    // The current number of outstanding requests.
    //

    UCHAR QueueCount;

    //
    // The inquiry data for this logical unit.
    //

    INQUIRYDATA InquiryData;

    //
    // The handles for the target & logical unit keys in the device map.
    //

    HANDLE TargetDeviceMapKey;
    HANDLE LunDeviceMapKey;

    //
    // Our fixed set of SRB_DATA blocks for use when processing bypass requests.
    // If this set is exhausted then scsiport will bugcheck - this should be
    // okay since bypass requests are only sent in certain extreme conditions
    // and should never be overlapped (we should only see one bypass request
    // at a time).
    //

    SRB_DATA BypassSrbDataBlocks[NUMBER_BYPASS_SRB_DATA_BLOCKS];

    //
    // A list of the free bypass SRB_DATA blocks.
    //

    KSPIN_LOCK BypassSrbDataSpinLock;
    SLIST_HEADER BypassSrbDataList;

    //
    // A pointer to the request for which we have issued a request-sense irp
    // (if any).  This field is protected by the port spinlock.
    //

    PSRB_DATA ActiveFailedRequest;

    //
    // A pointer to the request for which we need to issue a request-sense irp
    // (if any).  RequestSenseCompletion will promote this to the active
    // failed request and issue a new RS operation when it runs.
    // This field is protected by the port spinlock.
    //

    PSRB_DATA BlockedFailedRequest;

    //
    // Resources for issuing request-sense commands.
    //

    PIRP RequestSenseIrp;
    SCSI_REQUEST_BLOCK RequestSenseSrb;

    struct {
        MDL RequestSenseMdl;
        PFN_NUMBER RequestSenseMdlPfn1;
        PFN_NUMBER RequestSenseMdlPfn2;
    };

    //
    // The "lun-list" associated with this target.  SpIssueReportLuns will
    // store this value in the logical unit extension for LUN 0 of each target
    // for use in the event that we are unable to retrieve it from the LUN.
    //

    PLUN_LIST TargetLunList;

    //
    // The special controller flags for this target.  These flags are valid
    // for LUN 0 only.
    //

    SP_SPECIAL_CONTROLLER_FLAGS SpecialFlags;

    //
    // Flags to keep track of what EVPD pages this device supports.
    //

    BOOLEAN DeviceIdentifierPageSupported : 1;
    BOOLEAN SerialNumberPageSupported : 1;

    //
    // The vital product data for this device - this buffer contains the
    // device serial number.  The other fields contain the length of the
    // data in the buffer and the page code used to retrieve this buffer.
    //

    ANSI_STRING SerialNumber;

    //
    // The device identifier page retreived from the device's vital product
    // data.
    //

    PVPD_IDENTIFICATION_PAGE DeviceIdentifierPage;
    ULONG DeviceIdentifierPageLength;

    //
    // If we reduce the MaxQueueDepth, track how long we remain in the degraded
    // state.  If we reach a configurable number of ticks we restore ourselves
    // to full power.
    //

    ULONG TicksInReducedMaxQueueDepthState;

};

//
// Miniport specific device extension wrapper
//

struct _HW_DEVICE_EXTENSION {
    PADAPTER_EXTENSION FdoExtension;
    UCHAR HwDeviceExtension[0];
};

typedef struct _INTERRUPT_CONTEXT {
    PADAPTER_EXTENSION DeviceExtension;
    PINTERRUPT_DATA SavedInterruptData;
}INTERRUPT_CONTEXT, *PINTERRUPT_CONTEXT;

typedef struct _RESET_CONTEXT {
    PADAPTER_EXTENSION DeviceExtension;
    UCHAR PathId;
}RESET_CONTEXT, *PRESET_CONTEXT;

//
// Used in LUN rescan determination.
//

typedef struct _UNICODE_LUN_LIST {
    UCHAR TargetId;
    struct _UNICODE_LUN_LIST *Next;
    UNICODE_STRING UnicodeInquiryData;
} UNICODE_LUN_LIST, *PUNICODE_LUN_LIST;

typedef struct _POWER_CHANGE_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    POWER_STATE_TYPE Type;
    POWER_STATE State;
    PIRP OriginalIrp;
    PSCSI_REQUEST_BLOCK Srb;
} POWER_CHANGE_CONTEXT, *PPOWER_CHANGE_CONTEXT;

//
// Driver extension
//

struct _SP_INIT_CHAIN_ENTRY {
    HW_INITIALIZATION_DATA InitData;
    PSP_INIT_CHAIN_ENTRY NextEntry;
};

typedef struct _SCSIPORT_INTERFACE_TYPE_DATA {
    INTERFACE_TYPE InterfaceType;
    ULONG Flags;
} SCSIPORT_INTERFACE_TYPE_DATA, *PSCSIPORT_INTERFACE_TYPE_DATA;

typedef struct _SCSIPORT_DRIVER_EXTENSION {

    //
    // Pointer back to the driver object
    //

    PDRIVER_OBJECT DriverObject;

    //
    // Unicode string containing the registry path information
    // for this driver
    //

    UNICODE_STRING RegistryPath;

    //
    // the chain of HwInitializationData structures that were passed in during
    // the miniport's initialization
    //

    PSP_INIT_CHAIN_ENTRY InitChain;

    //
    // A count of the number of adapter which are using scsiport.  This is
    // used for generating unique Id's
    //

    ULONG AdapterCount;

    //
    // The bus type for this driver.
    //

    STORAGE_BUS_TYPE BusType;

    //
    // Flag indicating whether this miniport is set to do device detection.
    // This flag will be initialized out of the registry when the driver
    // extension is setup.
    //

    BOOLEAN LegacyAdapterDetection;

    //
    // The list of pnp interface values we read out of the registry for this
    // device.  The number of entries here can vary.
    //

    ULONG PnpInterfaceCount;

    //
    // The number of interfaces which are safe for pnp.
    //

    ULONG SafeInterfaceCount;

    //
    // A pointer to a reserve error log entry for the driver.  This entry will
    // be used to log an allocation failure if the logging routine cannot
    // allocate the necessary memory for an error log entry.
    //

    PVOID ReserveAllocFailureLogEntry;

    //
    // Indicates whether the driver is being verified.
    //

    ULONG Verifying;

    //
    // When verifying, we occasionally set pointers so they point to a page
    // of invalid memory so the system will bugcheck if a miniport attempts
    // to access the memory.  The following 3 variables are used to maintain
    // this invalid page.
    //

    PVOID UnusedPage;
    PMDL UnusedPageMdl;
    PVOID InvalidPage;

    SCSIPORT_INTERFACE_TYPE_DATA PnpInterface[0];

    //
    // The remaining pnp interface flags trail the defined structure
    //

} SCSIPORT_DRIVER_EXTENSION, *PSCSIPORT_DRIVER_EXTENSION;


//
// Port driver extension flags.
// These flags are protected by the adapter spinlock.
//

//
// This flag indicates that a request has been passed to the miniport and the
// miniport has not indicated it is ready for another request.  It is set by
// SpStartIoSynchronized. It is cleared by ScsiPortCompletionDpc when the
// miniport asks for another request.  Note the port driver will defer giving
// the miniport driver a new request if the current request disabled disconnects.
//

#define PD_DEVICE_IS_BUSY            0X00001

//
// Indicates there is a pending request for which resources
// could not be allocated.  This flag is set by SpAllocateRequestStructures
// which is called from ScsiPortStartIo.  It is cleared by
// SpProcessCompletedRequest when a request completes which then calls
// ScsiPortStartIo to try the request again.
//

#define PD_PENDING_DEVICE_REQUEST    0X00800

//
// This flag indicates that there are currently no requests executing with
// disconnects disabled.  This flag is normally on.  It is cleared by
// SpStartIoSynchronized when a request with disconnect disabled is started
// and is set when that request completes.  SpProcessCompletedRequest will
// start the next request for the miniport if PD_DEVICE_IS_BUSY is clear.
//

#define PD_DISCONNECT_RUNNING        0X01000

//
// Indicates the miniport wants the system interrupts disabled.  Set by
// ScsiPortNofitication and cleared by ScsiPortCompletionDpc.  This flag is
// NOT stored in the interrupt data structure.  The parameters are stored in
// the device extension.
//

#define PD_DISABLE_CALL_REQUEST      0X02000

//
// Indicates that the miniport is being reinitialized.  This is set and
// cleared by SpReinitializeAdapter is is tested by some of the ScsiPort APIs.
//

#define PD_MINIPORT_REINITIALIZING          0x40000
#define PD_UNCACHED_EXTENSION_RETURNED      0x80000

//
// Interrupt Data Flags
// These flags are protected by the interrupt spinlock.
//

//
// Indicates that ScsiPortCompletionDpc needs to be run.  This is set when
// A miniport makes a request which must be done at DPC and is cleared when
// when the request information is gotten by SpGetInterruptState.
//

#define PD_NOTIFICATION_REQUIRED     0X00004

//
// Indicates the miniport is ready for another request.  Set by
// ScsiPortNotification and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure.
//

#define PD_READY_FOR_NEXT_REQUEST    0X00008

//
// Indicates the miniport wants the adapter channel flushed.  Set by
// ScsiPortFlushDma and cleared by SpGetInterruptState.  This flag is
// stored in the data interrupt structure.  The flush adapter parameters
// are saved in the device object.
//

#define PD_FLUSH_ADAPTER_BUFFERS     0X00010

//
// Indicates the miniport wants the adapter channel programmed.  Set by
// ScsiPortIoMapTransfer and cleared by SpGetInterruptState or
// ScsiPortFlushDma.  This flag is stored in the interrupt data structure.
// The I/O map transfer parameters are saved in the interrupt data structure.
//

#define PD_MAP_TRANSFER              0X00020

//
// Indicates the miniport wants to log an error.  Set by
// ScsiPortLogError and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure.  The error log parameters
// are saved in the interrupt data structure.  Note at most one error per DPC
// can be logged.
//

#define PD_LOG_ERROR                 0X00040

//
// Indicates that no request should be sent to the miniport after
// a bus reset. Set when the miniport reports a reset or the port driver
// resets the bus. It is cleared by SpTimeoutSynchronized.  The
// PortTimeoutCounter is used to time the length of the reset hold.  This flag
// is stored in the interrupt data structure.
//

#define PD_RESET_HOLD                0X00080

//
// Indicates a request was stopped due to a reset hold.  The held request is
// stored in the current request of the device object.  This flag is set by
// SpStartIoSynchronized and cleared by SpTimeoutSynchronized which also
// starts the held request when the reset hold has ended.  This flag is stored
// in the interrupt data structure.
//

#define PD_HELD_REQUEST              0X00100

//
// Indicates the miniport has reported a bus reset.  Set by
// ScsiPortNotification and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure.
//

#define PD_RESET_REPORTED            0X00200

//
// Indicates that system interrupts have been enabled and that the miniport
// has disabled its adapter from interruptint.  The miniport's interrupt
// routine is not called while this flag is set.  This flag is set by
// ScsiPortNotification when a CallEnableInterrupts request is made and
// cleared by SpEnableInterruptSynchronized when the miniport requests that
// system interrupts be disabled.  This flag is stored in the interrupt data
// structure.
//

#define PD_DISABLE_INTERRUPTS        0X04000

//
// Indicates the miniport wants the system interrupt enabled.  Set by
// ScsiPortNotification and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure.  The call enable interrupts
// parameters are saved in the device extension.
//

#define PD_ENABLE_CALL_REQUEST       0X08000

//
// Indicates the miniport is wants a timer request.  Set by
// ScsiPortNotification and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure. The timer request parameters are
// stored in the interrupt data structure.
//

#define PD_TIMER_CALL_REQUEST        0X10000

//
// Indicates the miniport has a WMI request.  Set by ScsiPortNotification
// and cleared by SpGetInterruptState.  This flag is stored in the interrupt
// data structure.    The WMI request parameters are stored in the interrupt
// data structure.
//

#define PD_WMI_REQUEST               0X20000

//
// Indicates that the miniport has detected some sort of change on the bus -
// usually device arrival or removal - and wishes the port driver to rescan
// the bus.
//

#define PD_BUS_CHANGE_DETECTED       0x40000

//
// Indicates that the adapter has disappeared.  If this flag is set then no
// calls should be made into the miniport.
//

#define PD_ADAPTER_REMOVED           0x80000

//
// Indicates that interrupts from the miniport do not appear to be getting
// delivered to scsiport.  This flag is set by SpTimeoutSynchronized and
// will cause the DPC routine to log an error to this effect.
//

#define PD_INTERRUPT_FAILURE         0x100000

#if defined(FORWARD_PROGRESS)
//
// Indicates that the adapter's reserved pages are currently in use.  The 
// reserved pages is a special VA range set aside by MM in order for devices
// to make forward progress in low memory conditions.
//

#define PD_RESERVED_PAGES_IN_USE     0x200000

//
// Indicates that the adapter's reserved MDL is currently in use.
//
#define PD_RESERVED_MDL_IN_USE       0x400000
#endif

//
// Indicates that the adapter is in the process of shutting down.  Certain
// operations must not be started when this is the case.
//
#define PD_SHUTDOWN_IN_PROGRESS      0x800000

//
// The following flags should not be cleared from the interrupt data structure
// by SpGetInterruptState.
//

#define PD_INTERRUPT_FLAG_MASK (PD_RESET_HOLD | PD_HELD_REQUEST | PD_DISABLE_INTERRUPTS | PD_ADAPTER_REMOVED)

//
// Adapter extension flags for DPC routine.
//

//
// Indicates that the completion DPC is either already running or has been
// queued to service completed requests.  This flag is checked when the
// completion DPC needs to be run - the DPC should only be started if this
// flag is already clear.  It will be cleared when the DPC has completed
// processing any work items.
//

#define PD_DPC_RUNNING              0x20000

//
// Logical unit extension flags.
//

//
// Indicates the logical unit queue is frozen.  Set by
// SpProcessCompletedRequest when an error occurs and is cleared by the class
// driver.
//

#define LU_QUEUE_FROZEN              0X0001

//
// Indicates that the miniport has an active request for this logical unit.
// Set by SpStartIoSynchronized when the request is started and cleared by
// GetNextLuRequest.  This flag is used to track when it is ok to start another
// request from the logical unit queue for this device.
//

#define LU_LOGICAL_UNIT_IS_ACTIVE    0X0002

//
// Indicates that a request for this logical unit has failed and a REQUEST
// SENSE command needs to be done. This flag prevents other requests from
// being started until an untagged, by-pass queue command is started.  This
// flag is cleared in SpStartIoSynchronized.  It is set by
// SpGetInterruptState.
//

#define LU_NEED_REQUEST_SENSE  0X0004

//
// Indicates that a request for this logical unit has completed with a status
// of BUSY or QUEUE FULL.  This flag is set by SpProcessCompletedRequest and
// the busy request is saved in the logical unit structure.  This flag is
// cleared by ScsiPortTickHandler which also restarts the request.  Busy
// request may also be requeued to the logical unit queue if an error occurs
// on the device (This will only occur with command queueing.).  Not busy
// requests are nasty because they are restarted asynchronously by
// ScsiPortTickHandler rather than GetNextLuRequest. This makes error recovery
// more complex.
//

#define LU_LOGICAL_UNIT_IS_BUSY      0X0008

//
// This flag indicates a queue full has been returned by the device.  It is
// similar to PD_LOGICAL_UNIT_IS_BUSY but is set in SpGetInterruptState when
// a QUEUE FULL status is returned.  This flag is used to prevent other
// requests from being started for the logical unit before
// SpProcessCompletedRequest has a chance to set the busy flag.
//

#define LU_QUEUE_IS_FULL             0X0010

//
// Indicates that there is a request for this logical unit which cannot be
// executed for now.  This flag is set by SpAllocateRequestStructures.  It is
// cleared by GetNextLuRequest when it detects that the pending request
// can now be executed. The pending request is stored in the logical unit
// structure.  A new single non-queued reqeust cannot be executed on a logical
// that is currently executing queued requests.  Non-queued requests must wait
// unit for all queued requests to complete.  A non-queued requests is one
// which is not tagged and does not have SRB_FLAGS_NO_QUEUE_FREEZE set.
// Normally only read and write commands can be queued.
//

#define LU_PENDING_LU_REQUEST        0x0020

//
// Indicates that the logical unit queue has been paused due to an error.  Set
// by SpProcessCompletedRequest when an error occurs and is cleared by the
// class driver either by unfreezing or flushing the queue.  This flag is used
// with the following one to determine why the logical unit queue is paused.
//

#define LU_QUEUE_LOCKED             0x0040

//
// Indicates that this LUN has been "paused".  This flag is set and cleared by
// the power management code while changing the power state.  It causes
// GetNextLuRequest to return without starting another request and is used
// by SpSrbIsBypassRequest to determine that a bypass request should get
// shoved to the front of the line.
//

#define LU_QUEUE_PAUSED             0x0080

//
// Indicates that the LUN is operating in a degraded state.  The maximum queue
// depth has been reduced because the LUN has returned QUEUE FULL status.  We
// track this because in the event that the QUEUE FULL was transient, we want
// to restore the queue depth to it's original maximum.

#define LU_PERF_MAXQDEPTH_REDUCED   0x0100

//
// SRB_DATA flags.
//

//
// These three flags indicate the size of scatter gather list necessary to
// service the request and are used to determine how the scatter gather list
// should be freed.  Small requests require <= SP_SMALL_PHYSICAL_BREAK_VALUE
// breaks and the scatter gather list is preallocated in the SRB_DATA structure.
// Large requests are >= SP_LARGE_PHYSICAL_BREAK_VALUE and have scatter gather
// lists allocated from non-paged pool.  Medium requests are between small
// and large - they use scatter gather lists from a lookaside list which contain
// one less entry than a large list would.
//

#ifndef USE_DMA_MACROS

#define SRB_DATA_SMALL_SG_LIST      0x00000001
#define SRB_DATA_MEDIUM_SG_LIST     0x00000002
#define SRB_DATA_LARGE_SG_LIST      0x00000004

#endif

//
// Indicates that the srb_data block was for a bypass request
//

#define SRB_DATA_BYPASS_REQUEST     0x10000000

#if defined(FORWARD_PROGRESS)
//
// Indicates that the request is using reserved pages that enable
// forward progress in low-memory condition.
//

#define SRB_DATA_RESERVED_PAGES     0x20000000

//
// Indicates that the request is using a reserved MDL that enables
// forward progress in low-memory conditions.
//
#define SRB_DATA_RESERVED_MDL       0x40000000
#endif

//
// Port Timeout Counter values.
//

#define PD_TIMER_STOPPED             -1
#define PD_TIMER_RESET_HOLD_TIME     4

//
// Possible registry flags for pnp interface key
//

//
// The absence of any information about a particular interface in the
// PnpInterface key in the registry indicates that pnp is not safe for this
// particular card.
//

#define SP_PNP_NOT_SAFE             0x00000000

//
// Indicates that pnp is a safe operation for this device.  If this flag is
// set then the miniport will not be allowed to do detection and will always
// be handed resources provided by the pnp system.  This flag may or may not
// be set in the registry - the fact that a value for a particular interface
// exists is enough to indicate that pnp is safe and this flag will always
// be set.
//

#define SP_PNP_IS_SAFE              0x00000001

//
// Indicates that we should take advantage of a chance to enumerate a particular
// bus type using the miniport.  This flag is set for all non-enumerable legacy
// buses (ISA, EISA, etc...) and is cleared for the non-legacy ones and for the
// PnpBus type.
//

#define SP_PNP_NON_ENUMERABLE       0x00000002

//
// Indicates that we need to include some sort of location information in the
// config data to discern this adapter from any others.
//

#define SP_PNP_NEEDS_LOCATION       0x00000004

//
// Indicates that this type of adapter must have an interrupt for us to try
// and start it.  If PNP doesn't provide an interrupt then scsiport will
// log an error and fail the start operation.  If this flag is set then
// SP_PNP_IS_SAFE must also be set.
//

#define SP_PNP_INTERRUPT_REQUIRED   0x00000008

//
// Indicates that legacy detection should not be done.
//

#define SP_PNP_NO_LEGACY_DETECTION  0x00000010

//
// Internal scsiport srb status codes.
// these must be between 0x38 and 0x3f (inclusive) and should never get
// returned to a class driver.
//
// These values are used after the srb has been put on the adapter's
// startio queue and thus cannot be completed without running it through the
// completion DPC.
//

#ifndef KDBG_EXT
//
// Function declarations
//

NTSTATUS
ScsiPortGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortFdoCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortFdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortPdoScsi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortScsi1PdoScsi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiPortStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
ScsiPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ScsiPortFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortPdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortPdoCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiPortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
IssueRequestSense(
    IN PADAPTER_EXTENSION deviceExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    );

BOOLEAN
SpStartIoSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
SpResetBusSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
SpTimeoutSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
SpEnableInterruptSynchronized (
    PVOID ServiceContext
    );

VOID
IssueAbortRequest(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

BOOLEAN
SpGetInterruptState(
    IN PVOID ServiceContext
    );

#if DBG

#define GetLogicalUnitExtension(fdo, path, target, lun, lock, getlock) \
    GetLogicalUnitExtensionEx(fdo, path, target, lun, lock, getlock, __file__, __LINE__)

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtensionEx(
    PADAPTER_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    PVOID LockTag,
    BOOLEAN AcquireBinLock,
    PCSTR File,
    ULONG Line
    );

#else

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtension(
    PADAPTER_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    PVOID LockTag,
    BOOLEAN AcquireBinLock
    );

#endif

IO_ALLOCATION_ACTION
ScsiPortAllocationRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

VOID
LogErrorEntry(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PERROR_LOG_ENTRY LogEntry
    );

VOID
FASTCALL
GetNextLuRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
GetNextLuRequestWithoutLock(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpLogTimeoutError(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP Irp,
    IN ULONG UniqueId
    );

VOID
SpProcessCompletedRequest(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    OUT PBOOLEAN CallStartIo
    );

PSRB_DATA
SpGetSrbData(
    IN PADAPTER_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    UCHAR QueueTag,
    BOOLEAN AcquireBinLock
    );

VOID
SpCompleteSrb(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    IN UCHAR SrbStatus
    );

BOOLEAN
SpAllocateSrbExtension(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT BOOLEAN *StartNextRequest,
    OUT BOOLEAN *Tagged
    );

NTSTATUS
SpSendMiniPortIoctl(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

NTSTATUS
SpGetInquiryData(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
SpSendPassThrough(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
SpClaimLogicalUnit(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension,
    IN PIRP Irp,
    IN BOOLEAN StartDevice
    );

VOID
SpMiniPortTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
SpSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

NTSTATUS
SpGetCommonBuffer(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN ULONG NonCachedExtensionSize
    );

VOID
SpDestroyAdapter(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Surprise
    );

VOID
SpReleaseAdapterResources(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Surprise
    );

NTSTATUS
SpInitializeConfiguration(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PHW_INITIALIZATION_DATA HwInitData,
    IN PCONFIGURATION_CONTEXT Context
    );

VOID
SpParseDevice(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN HANDLE Key,
    IN PCONFIGURATION_CONTEXT Context,
    IN PUCHAR Buffer
    );

NTSTATUS
SpConfigurationCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

PCM_RESOURCE_LIST
SpBuildResourceList(
    PADAPTER_EXTENSION DeviceExtension,
    PPORT_CONFIGURATION_INFORMATION MiniportConfigInfo
    );

BOOLEAN
GetPciConfiguration(
    IN PDRIVER_OBJECT          DriverObject,
    IN OUT PDEVICE_OBJECT      DeviceObject,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID                   RegistryPath,
    IN ULONG                   BusNumber,
    IN OUT PPCI_SLOT_NUMBER    SlotNumber
    );

NTSTATUS
ScsiPortAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
ScsiPortUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ScsiPortFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortStartAdapter(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ScsiPortStopAdapter(
    IN PDEVICE_OBJECT Adapter,
    IN PIRP StopRequest
    );

NTSTATUS
ScsiPortStartLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
ScsiPortInitLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
ScsiPortStopLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
SpEnumerateAdapterSynchronous(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Force
    );

VOID
SpEnumerateAdapterAsynchronous(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST EnumerationRequest,
    IN BOOLEAN Force
    );

VOID
SpEnumerationWorker(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpExtractDeviceRelations(
    IN PADAPTER_EXTENSION Adapter,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

VOID
ScsiPortInitializeDispatchTables(
    VOID
    );

NTSTATUS
ScsiPortStringArrayToMultiString(
    IN PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING MultiString,
    PCSTR StringArray[]
    );

NTSTATUS
ScsiPortGetDeviceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
ScsiPortGetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
ScsiPortGetCompatibleIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
ScsiPortGetHardwareIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
ScsiPortStartAdapterCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpReportNewAdapter(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ScsiPortQueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    );

NTSTATUS
ScsiPortInitLegacyAdapter(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    );

NTSTATUS
SpCreateAdapter(
    IN PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *Fdo
    );

VOID
SpInitializeAdapterExtension(
    IN PADAPTER_EXTENSION FdoExtension,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN OUT PHW_DEVICE_EXTENSION HwDeviceExtension OPTIONAL
    );

PHW_INITIALIZATION_DATA
SpFindInitData(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    );

VOID
SpBuildConfiguration(
    IN PADAPTER_EXTENSION    AdapterExtension,
    IN PHW_INITIALIZATION_DATA         HwInitializationData,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInformation
    );

NTSTATUS
SpCallHwFindAdapter(
    IN PDEVICE_OBJECT Fdo,
    IN PHW_INITIALIZATION_DATA HwInitData,
    IN PVOID HwContext OPTIONAL,
    IN OUT PCONFIGURATION_CONTEXT ConfigurationContext,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN CallAgain
    );

NTSTATUS
SpCallHwInitialize(
    IN PDEVICE_OBJECT Fdo
    );

HANDLE
SpOpenParametersKey(
    IN PUNICODE_STRING RegistryPath
    );

HANDLE
SpOpenDeviceKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber
    );

ULONG
SpQueryPnpInterfaceFlags(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    );

NTSTATUS
SpGetRegistryValue(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE Handle,
    IN PWSTR KeyString,
    OUT PKEY_VALUE_FULL_INFORMATION *KeyInformation
    );

NTSTATUS
SpInitDeviceMap(
    VOID
    );

NTSTATUS
SpBuildDeviceMapEntry(
    IN PCOMMON_EXTENSION CommonExtension
    );

VOID
SpDeleteDeviceMapEntry(
    IN PCOMMON_EXTENSION CommonExtension
    );

NTSTATUS
SpUpdateLogicalUnitDeviceMapEntry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpLogResetError(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb,
    IN ULONG UniqueId
    );

VOID
SpRemoveLogicalUnitFromBin (
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    );

VOID
SpAddLogicalUnitToBin (
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    );

PSCSIPORT_DEVICE_TYPE
SpGetDeviceTypeInfo(
    IN UCHAR DeviceType
    );

BOOLEAN
SpRemoveLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN UCHAR RemoveType
    );

VOID
SpDeleteLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

PLOGICAL_UNIT_EXTENSION
SpFindSafeLogicalUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR PathId,
    IN PVOID LockTag
    );

NTSTATUS
ScsiPortSystemControlIrp(
    IN     PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP           Irp);

NTSTATUS
SpWmiIrpNormalRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters);

NTSTATUS
SpWmiIrpRegisterRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PWMI_PARAMETERS WmiParameters);

NTSTATUS
SpWmiHandleOnMiniPortBehalf(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters);

NTSTATUS
SpWmiPassToMiniPort(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters);

VOID
SpWmiInitializeSpRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject);

VOID
SpWmiGetSpRegInfo(
    IN  PDEVICE_OBJECT DeviceObject,
    OUT PWMIREGINFO  * SpRegInfoBuf,
    OUT ULONG        * SpRegInfoBufSize);

VOID
SpWmiDestroySpRegInfo(
    IN  PDEVICE_OBJECT DeviceObject);

NTSTATUS
SpWmiInitializeFreeRequestList(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          NumberOfItems
    );

VOID
SpWmiPushExistingFreeRequestItem(
    IN PADAPTER_EXTENSION Adapter,
    IN PWMI_MINIPORT_REQUEST_ITEM WmiRequestItem
    );

NTSTATUS
SpWmiPushFreeRequestItem(
    IN PADAPTER_EXTENSION           Adapter
    );

PWMI_MINIPORT_REQUEST_ITEM
SpWmiPopFreeRequestItem(
    IN PADAPTER_EXTENSION           Adapter
    );

BOOLEAN
SpWmiRemoveFreeMiniPortRequestItems(
    IN PADAPTER_EXTENSION   fdoExtension
    );

#if DBG
ULONG
FASTCALL
FASTCALL
SpAcquireRemoveLockEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag,
    IN PCSTR File,
    IN ULONG Line
    );
#else
ULONG
INLINE
SpAcquireRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    InterlockedIncrement(&commonExtension->RemoveLock);
    return (commonExtension->IsRemoved);
}
#endif

VOID
FASTCALL
SpReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    );

VOID
FASTCALL
FASTCALL
SpCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OPTIONAL PSRB_DATA SrbData,
    IN CCHAR PriorityBoost
    );

NTSTATUS
ScsiPortDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpDefaultPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCM_RESOURCE_LIST
RtlDuplicateCmResourceList(
    IN PDRIVER_OBJECT DriverObject,
    POOL_TYPE PoolType,
    PCM_RESOURCE_LIST ResourceList,
    ULONG Tag
    );

ULONG
RtlSizeOfCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList
    );

BOOLEAN
SpTranslateResources(
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST AllocatedResources,
    OUT PCM_RESOURCE_LIST *TranslatedResources
    );

BOOLEAN
SpFindAddressTranslation(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS RangeStart,
    IN ULONG RangeLength,
    IN BOOLEAN InIoSpace,
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Translation
    );

NTSTATUS
SpAllocateAdapterResources(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
SpLockUnlockQueue(
    IN PDEVICE_OBJECT LogicalUnit,
    IN BOOLEAN LockQueue,
    IN BOOLEAN BypassLockedQueue
    );

VOID
ScsiPortRemoveAdapter(
    IN PDEVICE_OBJECT Adapter,
    IN BOOLEAN Surprise
    );

VOID
SpTerminateAdapter(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpQueryDeviceText(
    IN PDEVICE_OBJECT LogicalUnit,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    );

NTSTATUS
SpCheckSpecialDeviceFlags(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PINQUIRYDATA InquiryData
    );

PSRB_DATA
FASTCALL
SpAllocateSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN OPTIONAL PIRP Request
    );

PSRB_DATA
FASTCALL
SpAllocateBypassSrbData(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpCheckSrbLists(
    IN PADAPTER_EXTENSION Adapter,
    IN PUCHAR FailureString
    );

VOID
ScsiPortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpAllocateTagBitMap(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpRequestValidPowerState(
    IN PADAPTER_EXTENSION Adapter,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
SpRequestValidAdapterPowerStateSynchronous(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpEnableDisableAdapter(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Enable
    );

NTSTATUS
SpEnableDisableLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Enable,
    IN PSP_ENABLE_DISABLE_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context
    );

VOID
ScsiPortProcessAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

INTERFACE_TYPE
SpGetPdoInterfaceType(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
SpReadNumericInstanceValue(
    IN PDEVICE_OBJECT Pdo,
    IN PWSTR ValueName,
    OUT PULONG Value
    );

NTSTATUS
SpWriteNumericInstanceValue(
    IN PDEVICE_OBJECT Pdo,
    IN PWSTR ValueName,
    IN ULONG Value
    );

VOID
SpGetSupportedAdapterControlFunctions(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpReleaseMappedAddresses(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpGetSupportedAdapterControlFunctions(
    PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpIsAdapterControlTypeSupported(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType
    );

SCSI_ADAPTER_CONTROL_STATUS
SpCallAdapterControl(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

PVOID
SpAllocateSrbDataBackend(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG AdapterIndex
    );

VOID
SpFreeSrbDataBackend(
    IN PSRB_DATA SrbData
    );

ULONG
SpAllocateQueueTag(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpReleaseQueueTag(
    IN PADAPTER_EXTENSION Adapter,
    IN ULONG QueueTag
    );

NTSTATUS
SpInitializeGuidInterfaceMapping(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SpSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
SpSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpGetBusTypeGuid(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpDetermine64BitSupport(
    VOID
    );

VOID
SpAdjustDisabledBit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Enable
    );

NTSTATUS
SpReadNumericValue(
    IN OPTIONAL HANDLE Root,
    IN OPTIONAL PUNICODE_STRING KeyName,
    IN PUNICODE_STRING ValueName,
    OUT PULONG Value
    );

VOID
SpWaitForRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID LockTag
    );

VOID
SpStartLockRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIRP Irp OPTIONAL
    );

BOOLEAN
SpAdapterConfiguredForSenseDataEvents(
    IN PDEVICE_OBJECT DeviceObject,
    OUT GUID *SenseDataClass
    );
        
NTSTATUS
SpInitAdapterWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject
    );

PMAPPED_ADDRESS
SpAllocateAddressMapping(
    PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpPreallocateAddressMapping(
    PADAPTER_EXTENSION Adapter,
    IN UCHAR NumberOfBlocks
    );

VOID
SpPurgeFreeMappedAddressList(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpFreeMappedAddress(
    IN PADAPTER_EXTENSION Adapter,
    IN PVOID MappedAddress
    );

PMAPPED_ADDRESS
SpFindMappedAddress(
    IN PADAPTER_EXTENSION Adapter,
    IN LARGE_INTEGER IoAddress,
    IN ULONG NumberOfBytes,
    IN ULONG SystemIoBusNumber
    );

//
// SCSIPORT specified verifier error codes.
// 
#define SCSIPORT_VERIFIER_BAD_INIT_PARAMS          0x1000
#define SCSIPORT_VERIFIER_STALL_TOO_LONG           0x1001
#define SCSIPORT_VERIFIER_MINIPORT_ROUTINE_TIMEOUT 0x1002
#define SCSIPORT_VERIFIER_REQUEST_COMPLETED_TWICE  0x1003
#define SCSIPORT_VERIFIER_BAD_SRBSTATUS            0x1004
#define SCSIPORT_VERIFIER_UNTAGGED_REQUEST_ACTIVE  0x1005
#define SCSIPORT_VERIFIER_BAD_VA                   0x1006
#define SCSIPORT_VERIFIER_RQSTS_NOT_COMPLETE       0x1007

#define SP_VRFY_NONE                               (ULONG)-1
#define SP_VRFY_COMMON_BUFFERS                     0x00000001

typedef struct _SP_VA_MAPPING_INFO {
      PVOID OriginalSrbExtVa;
      ULONG SrbExtLen;
      PMDL SrbExtMdl;
      PVOID RemappedSrbExtVa;
      PVOID OriginalSenseVa;
      ULONG SenseLen;
      PMDL SenseMdl;
      PVOID RemappedSenseVa;
} SP_VA_MAPPING_INFO, *PSP_VA_MAPPING_INFO;

#define GET_VA_MAPPING_INFO(adapter, block)\
    (PSP_VA_MAPPING_INFO)((PUCHAR)(block) + ((adapter)->CommonBufferSize - PAGE_SIZE))

BOOLEAN
SpVerifierInitialization(
    VOID
    );

VOID
SpVerifySrbStatus(
    PVOID HwDeviceExtension,
    PSCSI_REQUEST_BLOCK srb
    );

ULONG
SpHwFindAdapterVrfy (
    IN PVOID DeviceExtension,
    IN PVOID HwContext,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

BOOLEAN
SpHwInitializeVrfy (
    IN PVOID DeviceExtension
    );

BOOLEAN
SpHwStartIoVrfy (
    IN PVOID DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
SpHwInterruptVrfy (
    IN PVOID DeviceExtension
    );

BOOLEAN
SpHwResetBusVrfy (
    IN PVOID DeviceExtension,
    IN ULONG PathId
    );

VOID
SpHwDmaStartedVrfy (
    IN PVOID DeviceExtension
    );

BOOLEAN
SpHwRequestInterruptVrfy (
    IN PVOID DeviceExtension
    );

BOOLEAN
SpHwTimerRequestVrfy (
    IN PVOID DeviceExtension
    );

SCSI_ADAPTER_CONTROL_STATUS
SpHwAdapterControlVrfy (
    IN PVOID DeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

NTSTATUS
SpGetCommonBufferVrfy(
    PADAPTER_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    );

VOID
SpFreeCommonBufferVrfy(
    PADAPTER_EXTENSION Adapter
    );

PVOID
SpGetOriginalSrbExtVa(
    PADAPTER_EXTENSION Adapter,
    PVOID Va
    );

VOID
SpInsertSrbExtension(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    );

PVOID
SpPrepareSrbExtensionForUse(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    );

PCCHAR
SpPrepareSenseBufferForUse(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    );

PVOID
SpGetInaccessiblePage(
    PADAPTER_EXTENSION Adapter
    );

VOID
SpEnsureAllRequestsAreComplete(
    PADAPTER_EXTENSION Adapter
    );

VOID
SpDoVerifierCleanup(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpDoVerifierInit(
    IN PADAPTER_EXTENSION Adapter,
    IN PHW_INITIALIZATION_DATA HwInitializationData
    );

PMDL
INLINE
SpGetRemappedSrbExt(
    PADAPTER_EXTENSION Adapter,
    PVOID Block
    )
{
    PSP_VA_MAPPING_INFO MappingInfo = GET_VA_MAPPING_INFO(Adapter, Block);
    return MappingInfo->SrbExtMdl;
}

PMDL
INLINE
SpGetRemappedSenseBuffer(
    PADAPTER_EXTENSION Adapter,
    PVOID Block
    )
{
    PSP_VA_MAPPING_INFO MappingInfo = GET_VA_MAPPING_INFO(Adapter, Block);
    return MappingInfo->SenseMdl;
}

BOOLEAN
INLINE
SpVerifierActive(
    IN PADAPTER_EXTENSION Adapter
    )
{
    return (Adapter->VerifierExtension != NULL) ? TRUE : FALSE;
}

BOOLEAN
INLINE
SpVerifyingCommonBuffer(
    IN PADAPTER_EXTENSION Adapter
    )
{
    return (Adapter->VerifierExtension == NULL) ? FALSE :
       (Adapter->VerifierExtension->VrfyLevel & SP_VRFY_COMMON_BUFFERS) ? TRUE :
       FALSE;
}

//
// Definitions and declarations used for logging allocation failures.  When
// enabled, all allocation failures are logged to the system event log
// as warnings.
//

PVOID
SpAllocateErrorLogEntry(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
FASTCALL
SpLogAllocationFailureFn(
    IN PDRIVER_OBJECT DriverObject,
    IN POOL_TYPE PoolType,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN ULONG FileId,
    IN ULONG LineNumber
    );

PVOID
SpAllocatePoolEx(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    );

PMDL
SpAllocateMdlEx(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    );

PIRP
SpAllocateIrpEx(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    );

#define SCSIPORT_TAG_ALLOCMDL  TAG('LDMs')
#define SCSIPORT_TAG_ALLOCIRP  TAG('PRIs')
#define SCSIPORT_TAG_LOOKASIDE TAG('LALs')

#define SpAllocatePool(type, size, tag, drvObj) \
    SpAllocatePoolEx((type), (size), (tag), (drvObj), __FILE_ID__, __LINE__)

#define SpAllocateMdl(va, len, secbuf, cq, irp, drvobj) \
    SpAllocateMdlEx((va), (len), (secbuf), (cq), (irp), (drvobj), __FILE_ID__, __LINE__)

#define SpAllocateIrp(ss, cq, drvobj) \
    SpAllocateIrpEx((ss), (cq), (drvobj), __FILE_ID__, __LINE__)

//
// This structure makes it easy to allocate a contiguous chunk of memory
// for an event log entry with room for the insertion strings.
//
typedef struct _SCSIPORT_ALLOCFAILURE_DATA {
    ULONG Size;
    ULONG FileId;
    ULONG LineNumber;
} SCSIPORT_ALLOCFAILURE_DATA;

//
// Inline functions
//

ULONG
INLINE
SpGetCommonBufferSize(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN ULONG NonCachedExtensionSize,
    OUT OPTIONAL PULONG BlockSize
    )
{
    ULONG length;
    ULONG blockSize;

    //
    // To ensure that we never transfer normal request data to the SrbExtension
    // (ie. the case of Srb->SenseInfoBuffer == VirtualAddress in
    // ScsiPortGetPhysicalAddress) on some platforms where an inconsistency in
    // MM can result in the same Virtual address supplied for 2 different
    // physical addresses, bump the SrbExtensionSize if it's zero.
    //

    if (DeviceExtension->SrbExtensionSize == 0) {
        DeviceExtension->SrbExtensionSize = 16;
    }

    //
    // Calculate the block size for the list elements based on the Srb
    // Extension.
    //

    blockSize = DeviceExtension->SrbExtensionSize;

    //
    // If auto request sense is supported then add in space for the request
    // sense data.
    //

    if (DeviceExtension->AutoRequestSense) {        
        blockSize += sizeof(SENSE_DATA) + 
                     DeviceExtension->AdditionalSenseBytes;
    }

    //
    // Round blocksize up to the size of a PVOID.
    //

    blockSize = (blockSize + sizeof(LONGLONG) - 1) & ~(sizeof(LONGLONG) - 1);

    //
    // The length of the common buffer should be equal to the size of the
    // noncached extension and a minimum number of srb extension
    //

    length = NonCachedExtensionSize + 
             (blockSize * DeviceExtension->NumberOfRequests);

    //
    // Round the length up to a page size, since HalAllocateCommonBuffer
    // allocates in pages anyway.
    //

    length = (ULONG)ROUND_TO_PAGES(length);

    //
    // If the user is interested in the block size, copy it into the provided
    // buffer.
    //

    if (BlockSize != NULL) {
        *BlockSize = blockSize;
    }

    return length;
}

NTSTATUS
INLINE
SpDispatchRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);
    PCOMMON_EXTENSION lowerCommonExtension =
        commonExtension->LowerDeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    ASSERT_PDO(LogicalUnit->CommonExtension.DeviceObject);
    ASSERT_SRB_DATA(srb->OriginalRequest);

    if((LogicalUnit->CommonExtension.IdleTimer != NULL) &&
       (SpSrbRequiresPower(srb)) &&
       !(srb->SrbFlags & SRB_FLAGS_BYPASS_LOCKED_QUEUE) &&
       !(srb->SrbFlags & SRB_FLAGS_NO_KEEP_AWAKE)) {
       PoSetDeviceBusy(LogicalUnit->CommonExtension.IdleTimer);
    }

    ASSERT(irpStack->MajorFunction == IRP_MJ_SCSI);
    return (lowerCommonExtension->MajorFunction[IRP_MJ_SCSI])(
                commonExtension->LowerDeviceObject,
                Irp);
}


BOOLEAN
INLINE
SpSrbIsBypassRequest(
    PSCSI_REQUEST_BLOCK Srb,
    ULONG LuFlags
    )
/*++

Routine Description:

    This routine determines whether a request is a "bypass" request - one which
    should skip the lun queueing and be injected straight into the startio
    queue.

    Bypass requests do not start the next LU request when they complete.  This
    ensures that no new i/o is run until the condition being bypassed is
    cleared.

    Note: LOCK & UNLOCK requests are not bypass requests unless the queue
          is already locked.  This ensures that the first LOCK request will
          get run after previously queued requests, but that additional LOCK
          requests will not get stuck in the lun queue.

          Likewise any UNLOCK request sent when the queue is locked will be
          run immediately.  However since SpStartIoSynchronized checks to
          see if the request is a bypass request AFTER ScsiPortStartIo has
          cleared the QUEUE_LOCKED flag this will force the completion dpc
          to call GetNextLuRequest which will take the next operation out of
          the lun queue.  This is how i/o is restarted after a lock sequence
          has been completed.

Arguments:

    Srb - the srb in question

    LuFlags - the flags for the lun.

Return Value:

    TRUE if the request should bypass the lun queue, be injected into the
         StartIo queue and if GetNextLuRequest should not be called after this
         request has completed.

    FALSE otherwise

--*/

{
    ULONG flags = Srb->SrbFlags & (SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                                   SRB_FLAGS_BYPASS_LOCKED_QUEUE);

    ASSERT(TEST_FLAG(LuFlags, LU_QUEUE_FROZEN | LU_QUEUE_LOCKED) !=
           (LU_QUEUE_FROZEN | LU_QUEUE_LOCKED));

    if(flags == 0) {
        return FALSE;
    }

    if(flags & SRB_FLAGS_BYPASS_LOCKED_QUEUE) {

        DebugPrint((2, "SpSrbIsBypassRequest: Srb %#08lx is marked to bypass "
                       "locked queue\n", Srb));

        if(TEST_FLAG(LuFlags, LU_QUEUE_LOCKED | LU_QUEUE_PAUSED)) {

            DebugPrint((1, "SpSrbIsBypassRequest: Queue is locked - %#08lx is "
                           "a bypass srb\n", Srb));
            return TRUE;
        } else {
            DebugPrint((3, "SpSrbIsBypassRequest: Queue is not locked - not a "
                           "bypass request\n"));
            return FALSE;
        }
    }

    return TRUE;
}

VOID
INLINE
SpRequestCompletionDpc(
    IN PDEVICE_OBJECT Adapter
    )

/*++

Routine Description:

    This routine will request that the Completion DPC be queued if there isn't
    already one queued or in progress.  It will set the DpcFlags
    PD_DPC_NOTIFICATION_REQUIRED and PD_DPC_RUNNING.  If the DPC_RUNNING flag
    was not already set then it will request a DPC from the system as well.

Arguments:

    Adapter - the Adapter to request the DPC for

Return Value:

    none

--*/

{
    PADAPTER_EXTENSION adapterExtension = Adapter->DeviceExtension;
    ULONG oldDpcFlags;

    //
    // Set the DPC flags to indicate that there is work to be processed
    // (otherwise we wouldn't queue the DPC) and that the DPC is queued.
    //

    oldDpcFlags = InterlockedExchange(
                    &(adapterExtension->DpcFlags),
                    (PD_NOTIFICATION_REQUIRED | PD_DPC_RUNNING));

    //
    // If the DPC was already queued or running then don't bother requesting
    // a new one - the current one will pickup the work itself.
    //

    if(TEST_FLAG(oldDpcFlags, PD_DPC_RUNNING) == FALSE) {
        IoRequestDpc(Adapter, NULL, NULL);
    }

    return;
}


NTSTATUS
INLINE
SpTranslateScsiStatus(
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    This routine translates an srb status into an ntstatus.

Arguments:

    Srb - Supplies a pointer to the failing Srb.

Return Value:

    An nt status approprate for the error.

--*/

{
    switch (SRB_STATUS(Srb->SrbStatus)) {
    case SRB_STATUS_INVALID_LUN:
    case SRB_STATUS_INVALID_TARGET_ID:
    case SRB_STATUS_NO_DEVICE:
    case SRB_STATUS_NO_HBA:
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    case SRB_STATUS_COMMAND_TIMEOUT:
    case SRB_STATUS_TIMEOUT:
        return(STATUS_IO_TIMEOUT);
    case SRB_STATUS_SELECTION_TIMEOUT:
        return(STATUS_DEVICE_NOT_CONNECTED);
    case SRB_STATUS_BAD_FUNCTION:
    case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
        return(STATUS_INVALID_DEVICE_REQUEST);
    case SRB_STATUS_DATA_OVERRUN:
        return(STATUS_BUFFER_OVERFLOW);
    default:
        return(STATUS_IO_DEVICE_ERROR);
    }

    return(STATUS_IO_DEVICE_ERROR);
}

PVOID
INLINE
SpGetSrbExtensionBuffer(
    IN PADAPTER_EXTENSION Adapter
    )

/*++

Routine Description:

    This routine returns a pointer to the adapter's SrbExtensionBuffer.

Arguments:

    Adapter - Supplies a pointer to the adapter's ADAPTER_EXTNENSION.

Return Value:

    A pointer to the adapter's SrbExtensionBuffer.

--*/

{
    return (SpVerifyingCommonBuffer(Adapter)) ?
       Adapter->VerifierExtension->CommonBufferVAs :
       Adapter->SrbExtensionBuffer;
}

PMDL
SpBuildMdlForMappedTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDMA_ADAPTER AdapterObject,
    IN PMDL OriginalMdl,
    IN PVOID StartVa,
    IN ULONG ByteCount,
    IN PSRB_SCATTER_GATHER ScatterGatherList,
    IN ULONG ScatterGatherEntries
    );

#if defined(FORWARD_PROGRESS)
VOID
SpPrepareMdlForMappedTransfer(
    IN PMDL mdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDMA_ADAPTER AdapterObject,
    IN PMDL OriginalMdl,
    IN PVOID StartVa,
    IN ULONG ByteCount,
    IN PSRB_SCATTER_GATHER ScatterGatherList,
    IN ULONG ScatterGatherEntries
    );

VOID
INLINE
SpFreeSrbExtension(
    IN PADAPTER_EXTENSION Adapter, 
    IN PVOID SrbExtension
    )
{
    if (SpVerifyingCommonBuffer(Adapter)) {
        
        SpInsertSrbExtension(Adapter, SrbExtension);
        
    } else {
        
        *((PVOID *) SrbExtension) = Adapter->SrbExtensionListHeader;
        Adapter->SrbExtensionListHeader = SrbExtension;
        
    }    
}
#ifndef USE_DMA_MACROS
VOID
SpFreeSGList(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );
#endif
#endif // FORWARD_PROGRESS

#endif

#endif // _PORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\power.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    power.c

Abstract:

    This module contains the routines for port driver power support

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

PUCHAR PowerMinorStrings[] = {
    "IRP_MN_WAIT_WAKE",
    "IRP_MN_POWER_SEQUENCE",
    "IRP_MN_SET_POWER",
    "IRP_MN_QUERY_POWER"
};

VOID
SpProcessAdapterSystemState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpProcessAdapterDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpQueryTargetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    );

NTSTATUS
SpQueryAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    );

NTSTATUS
SpSetTargetDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceState
    );

VOID
SpSetTargetDeviceStateLockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    );

VOID
SpSetTargetDeviceStateUnlockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    );

NTSTATUS
SpSetTargetSystemState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN SYSTEM_POWER_STATE SystemState
    );

VOID
SpSetTargetSystemStateLockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    );

VOID
SpSetTargetSystemStateUnlockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    );

VOID
SpSetTargetDeviceStateForSystemStateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
SpSetAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    );

VOID
SpRequestAdapterPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
SpPowerAdapterForTargetCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
SpSetLowerPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
SpSetTargetDesiredPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
SpRequestValidPowerStateCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIO_STATUS_BLOCK IoStatus
    );

typedef struct {
    NTSTATUS Status;
    KEVENT Event;
} SP_SIGNAL_POWER_COMPLETION_CONTEXT, *PSP_SIGNAL_POWER_COMPLETION_CONTEXT;

VOID
SpSignalPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PSP_SIGNAL_POWER_COMPLETION_CONTEXT Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#pragma alloc_text(PAGE, SpRequestValidAdapterPowerStateSynchronous)


NTSTATUS
ScsiPortDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for the target device objects.

    N.B. This routine is NOT pageable as it may be called at dispatch level.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    BOOLEAN isPdo = commonExtension->IsPdo;
    NTSTATUS status;

    //
    // Get the current status of the request.
    //

    status = Irp->IoStatus.Status;

    DebugPrint((4, "ScsiPortDispatchPower: irp %p is %s for %s %p\n",
                Irp,
                PowerMinorStrings[irpStack->MinorFunction],
                isPdo ? "pdo" : "fdo",
                DeviceObject));

    switch (irpStack->MinorFunction) {

       case IRP_MN_SET_POWER: {

           POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
           POWER_STATE state = irpStack->Parameters.Power.State;

           DebugPrint((4, "ScsiPortDispatchPower: SET_POWER type %d state %d\n",
                       type, state));

#if DBG
           if (type == SystemPowerState) {
               ASSERT(state.SystemState >= PowerSystemUnspecified);
               ASSERT(state.SystemState < PowerSystemMaximum);
           } else {                
               ASSERT(state.DeviceState >= PowerDeviceUnspecified);
               ASSERT(state.DeviceState < PowerDeviceMaximum);
           }
#endif

           //
           // If this is a power-down request then call PoSetPowerState now
           // while we're not actually holding any resources or locks.
           //

           if ((state.SystemState != PowerSystemWorking) ||
               (state.DeviceState != PowerDeviceD0)) {

               PoSetPowerState(DeviceObject, type, state);

            }

           //
           // Special case system shutdown request.
           //

           if ((type == SystemPowerState) &&
               (state.SystemState > PowerSystemHibernate)) { 

               if (isPdo) {

                   //
                   // Do not pwer-downdown PDOs on shutdown.  There is no 
                   // reliable way to ensure that disks will spin up on restart.
                   //

                   status = STATUS_SUCCESS;
                   break;

               } else {

                   PADAPTER_EXTENSION adapter;

                   //
                   // If the adapter is not configured to receive power-down
                   // requests at shutdown, just pass the request down.
                   // 
                   
                   adapter = (PADAPTER_EXTENSION)commonExtension;
                   if (adapter->NeedsShutdown == FALSE) {

                       PoStartNextPowerIrp(Irp);
                       IoCopyCurrentIrpStackLocationToNext(Irp);
                       return PoCallDriver(commonExtension->LowerDeviceObject, Irp);
                   }
               }
           }

           if (isPdo) {

               if (type == DevicePowerState) {
                   status = SpSetTargetDeviceState(DeviceObject,
                                                   Irp,
                                                   state.DeviceState);
               } else {
                   status = SpSetTargetSystemState(DeviceObject,
                                                   Irp,
                                                   state.SystemState);
               }
           } else {
               
               PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
               
               //
               // If we have disabled power then ignore any non-working power irps.
               //
               
               if ((adapter->DisablePower) &&
                   ((state.DeviceState != PowerDeviceD0) ||
                    (state.SystemState != PowerSystemWorking))) {

                   status = STATUS_SUCCESS;
                   break;
               } else {
                   status = SpSetAdapterPower(DeviceObject, Irp, type, state);
               }
            }

            if(status == STATUS_PENDING) {
                return status;
            }

            break;
       }

       case IRP_MN_QUERY_POWER: {
           POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
           POWER_STATE state = irpStack->Parameters.Power.State;

           DebugPrint((4, "ScsiPortDispatchPower: QUERY_POWER type %d "
                       "state %d\n",
                       type, state));

           if ((type == SystemPowerState) &&
               (state.SystemState > PowerSystemHibernate)) {

               //
               // Ignore shutdown irps.
               //
               
               DebugPrint((4, "ScsiPortDispatch power - ignoring shutdown "
                           "query irp for level %d\n",
                           state.SystemState));
               status = STATUS_SUCCESS;
               break;
           }

           if (isPdo) {
               if ((type == SystemPowerState) &&
                   (state.SystemState > PowerSystemHibernate)) {

                   //
                   // Ignore shutdown irps.
                   //
                   
                   DebugPrint((4, "ScsiPortDispatch power - ignoring shutdown "
                               "query irp for level %d\n",
                               state.SystemState));
                   status = STATUS_SUCCESS;
               } else {
                   status = SpQueryTargetPower(DeviceObject,
                                               Irp,
                                               type,
                                               state);
               }
           } else {

               PADAPTER_EXTENSION adapter = (PADAPTER_EXTENSION)commonExtension;

               //
               // If we don't support power for this adapter then fail all
               // queries.
               //

               if (adapter->DisablePower) {
                   status = STATUS_NOT_SUPPORTED;
                   break;
               }

               status = SpQueryAdapterPower(DeviceObject, Irp, type, state);

               if (NT_SUCCESS(status)) {
                   
                   //
                   // See what the lower driver wants to do.
                   //
                   
                   PoStartNextPowerIrp(Irp);
                   IoCopyCurrentIrpStackLocationToNext(Irp);
                   return PoCallDriver(commonExtension->LowerDeviceObject, Irp);
               }
           }

           break;
       }

       case IRP_MN_WAIT_WAKE: {

           if (isPdo) {

               //
               // We don't support WAIT WAKE, so just fail the request.
               //

               status = STATUS_INVALID_DEVICE_REQUEST;
               PoStartNextPowerIrp(Irp);
               Irp->IoStatus.Status = status;
               IoCompleteRequest(Irp, IO_NO_INCREMENT);

           } else {

               //
               // Pass the request down.
               //

               PoStartNextPowerIrp(Irp);
               IoSkipCurrentIrpStackLocation(Irp);
               status = PoCallDriver(commonExtension->LowerDeviceObject, Irp);

           }

           return status;
       }

       default: {
           //
           // We pass down FDO requests we don't handle.
           //
           
           if (!isPdo) {
               PoStartNextPowerIrp(Irp);
               IoSkipCurrentIrpStackLocation(Irp);
               return PoCallDriver(commonExtension->LowerDeviceObject, Irp);
           }

           break;
        }
    }

    //
    // Complete the request.
    //

    PoStartNextPowerIrp(Irp);
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
SpSetAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    )
/*++

Routine Description:

    Wrapper routine to dump adapter power requests into the device i/o queue.
    Power requests are processed by the StartIo routine which calls
    SpProcessAdapterPower to do the actual work.

Arguments:

    DeviceObject - the device object being power managed.

    Irp - the power management irp.

    Type - the type of set_power irp (device or system)

    State - the state the adapter is being put into.

Return Value:

    STATUS_PENDING

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    NTSTATUS status;

    ASSERT_FDO(DeviceObject);

    DebugPrint((2, "SpSetAdapterPower - starting packet\n"));

    if(SpIsAdapterControlTypeSupported(adapter, ScsiStopAdapter)) {

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, 0L, FALSE);
        return STATUS_PENDING;

    } else if((commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) &&
              (commonExtension->PreviousPnpState != IRP_MN_START_DEVICE)) {

        //
        // Fine, we're in a low power state.  If we get a start or a remove
        // then there's an implicit power transition there so we don't really
        // need to set our current power state.
        //

        IoMarkIrpPending(Irp);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        PoCallDriver(commonExtension->LowerDeviceObject, Irp);
        return STATUS_PENDING;

    } else {

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        return Irp->IoStatus.Status;
    }
}


VOID
SpPowerAdapterForTargetCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine is called for a D0 request to a target device after it's
    adapter has been powered back on.  The routine will call back into
    SpSetTargetDeviceState to restart the power request or complete the
    target D request if the adapter power up was not successful.

Arguments:

    DeviceObject - the adapter which was powered up.

    MinorFunction - IRP_MN_SET_POWER

    PowerState - PowerDeviceD0

    OriginalIrp - The original target D0 irp.  This is the irp which will
                  be reprocessed.

    IoStatus - the status of the adapter power up request.

Return Value:

    none.

--*/

{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(OriginalIrp);
    POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
    POWER_STATE state = irpStack->Parameters.Power.State;

    NTSTATUS status = IoStatus->Status;

    DebugPrint((1, "SpPowerAdapterForTargetCompletion: DevObj %#p, Irp "
                   "%#p, Status %#08lx\n",
                DeviceObject, OriginalIrp, IoStatus));

    ASSERT_FDO(DeviceObject);
    ASSERT_PDO(irpStack->DeviceObject);

    ASSERT(type == DevicePowerState);
    ASSERT(state.DeviceState == PowerDeviceD0);

    ASSERT(NT_SUCCESS(status));

    if(NT_SUCCESS(status)) {

        ASSERT(adapter->CommonExtension.CurrentDeviceState == PowerDeviceD0);

        status = SpSetTargetDeviceState(irpStack->DeviceObject,
                                        OriginalIrp,
                                        PowerDeviceD0);
    }

    if(status != STATUS_PENDING) {
        PoStartNextPowerIrp(OriginalIrp);
        OriginalIrp->IoStatus.Status = status;
        IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);
    }
    return;
}


NTSTATUS
SpQueryAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    if((adapter->HwAdapterControl != NULL) && (adapter->IsPnp))  {

        status = STATUS_SUCCESS;

    } else if((commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) &&
              (commonExtension->PreviousPnpState != IRP_MN_START_DEVICE)) {

        //
        // If the adapter's not been started yet then we can blindly go to
        // a lower power state - START irps imply a transition into the D0 state
        //

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NOT_SUPPORTED;
    }

    return status;
}


NTSTATUS
SpQueryTargetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
SpRequestValidPowerState(
    IN PADAPTER_EXTENSION Adapter,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);
    PSRB_DATA srbData = Srb->OriginalRequest;

    BOOLEAN needsPower = SpSrbRequiresPower(Srb);

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Make sure we're at a power level which can process this request.  If
    // we aren't then make this a pending request, lock the queues and
    // ask the power system to bring us up to a more energetic level.
    //

    if((Srb->Function == SRB_FUNCTION_UNLOCK_QUEUE) ||
       (Srb->Function == SRB_FUNCTION_LOCK_QUEUE)) {

        //
        // Lock and unlock commands don't require power and will work
        // regardless of the current power state.
        //

        return status;
    }

    //
    // Even if this is a bypass request, the class driver may not request
    // actual miniport operations on the unpowered side of a power sequence.
    // This means that this is either:
    //      * a request to an idle device - powering up the device will power
    //        up the adapter if necessary.
    //      * a request to power down a device - adapter cannot have powered
    //        off until this is done.
    //      * a part of a power up sequence - the only real SCSI commands come
    //        after the power up irp has been processed and that irp will
    //        already have turned the adapter on.
    // This boils down to - we don't need to do anything special here to
    // power up the adapter.  The device power sequences will take care of
    // it automatically.
    //

    //
    // If the device or system isn't working AND this is not a request to
    // unlock the queue then let it go through.  The class driver is going
    // to unlock the queue after sending us a power request so we need to
    // be able to handle one.
    //

    if((commonExtension->CurrentDeviceState != PowerDeviceD0) ||
       ((commonExtension->CurrentSystemState != PowerSystemWorking) &&
        (!TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)))) {

        //
        // This request cannot be executed now.  Mark it as pending
        // in the logical unit structure and return.
        // GetNextLogicalUnit will restart the commnad after all of the
        // active commands have completed.
        //

        ASSERT(!TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE));

        ASSERT(!(LogicalUnit->LuFlags & LU_PENDING_LU_REQUEST));

        DebugPrint((4, "ScsiPortStartIo: logical unit (%d,%d,%d) [%#p] is "
                       "in power state (%d,%d) - must power up for irp "
                       "%#p\n",
                    Srb->PathId,
                    Srb->TargetId,
                    Srb->Lun,
                    commonExtension->DeviceObject,
                    commonExtension->CurrentDeviceState,
                    commonExtension->CurrentSystemState,
                    srbData->CurrentIrp));

        ASSERT(LogicalUnit->PendingRequest == NULL);
        LogicalUnit->PendingRequest = Srb->OriginalRequest;

        //
        // Indicate that the logical unit is still active so that the
        // request will get processed when the request list is empty.
        //

        SET_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST |
                                       LU_LOGICAL_UNIT_IS_ACTIVE);

        if(commonExtension->CurrentSystemState != PowerSystemWorking) {

            DebugPrint((1, "SpRequestValidPowerState: can't power up target "
                           "since it's in system state %d\n",
                        commonExtension->CurrentSystemState));

            //
            // Set the desired D state in the device extension.  This is
            // necessary when we're in a low system state as well as useful for
            // debugging when we're in low D states.
            //

            commonExtension->DesiredDeviceState = PowerDeviceD0;

            //
            // If we aren't in a valid system state then just release the
            // spinlock and return.  The next time we receive a system
            // state irp we'll issue the appropriate D state irp as well.
            //

            return STATUS_PENDING;

        } else if(commonExtension->DesiredDeviceState == PowerDeviceD0) {

            //
            // Scsiport is already asking to power up this lun.  Once that's
            // happened this request will be restarted.  For now just leave
            // it as the pending request.
            //

            return STATUS_PENDING;
        }

        //
        // Tell Po that we're not idle in case this was stuck in the queue
        // for some reason.
        //

        if(commonExtension->IdleTimer != NULL) {
            PoSetDeviceBusy(commonExtension->IdleTimer);
        }

        //
        // Get PO to send a power request to this device stack to put it
        // back into the D0 state.
        //

        {
            POWER_STATE powerState;

            powerState.DeviceState = PowerDeviceD0;

            status = PoRequestPowerIrp(
                        commonExtension->DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        NULL,
                        NULL,
                        NULL);
        }

        //
        // CODEWORK - if we can't power up the device here we'll need to
        // hang around in the tick handler for a while and try to do
        // it from there.
        //

        ASSERT(NT_SUCCESS(status));

        return STATUS_PENDING;
    }

    ASSERT(Adapter->CommonExtension.CurrentDeviceState == PowerDeviceD0);
    ASSERT(Adapter->CommonExtension.CurrentSystemState == PowerSystemWorking);

    return status;
}


NTSTATUS
SpSetLowerPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
    POWER_STATE state = irpStack->Parameters.Power.State;

    DebugPrint((2, "SpSetLowerPowerCompletion: DevObj %#p Irp %#p "
                   "%sState %d\n",
                DeviceObject, Irp,
                ((type == SystemPowerState) ? "System" : "Device"),
                state.DeviceState - 1));

    if(NT_SUCCESS(Irp->IoStatus.Status)) {

        if(type == SystemPowerState) {

            DebugPrint((2, "SpSetLowerPowerCompletion: Lower device succeeded "
                           "the system state transition.  Reprocessing power "
                           "irp\n"));
            SpProcessAdapterSystemState(DeviceObject, Irp);
        } else {
            DebugPrint((2, "SpSetLowerPowerCompletion: Lower device power up "
                           "was successful.  Reprocessing power irp\n"));

            SpProcessAdapterDeviceState(DeviceObject, Irp);
        }
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else {
        DebugPrint((1, "SpSetLowerPowerCompletion: Lower device power operation"
                       "failed - completing power irp with status %#08lx\n",
                    Irp->IoStatus.Status));
        PoStartNextPowerIrp(Irp);
        SpStartNextPacket(DeviceObject, FALSE);
        return STATUS_SUCCESS;
    }
}


VOID
SpProcessAdapterSystemState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles a system power IRP for the adapter.

Arguments:

    DeviceObject - the device object for the adapter.

    Irp - the power irp.

Return Value:

    none

--*/
{
    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

    SYSTEM_POWER_STATE originalSystemState;

    NTSTATUS status = STATUS_SUCCESS;

    ASSERT_FDO(DeviceObject);
    ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

    DebugPrint((2, "SpProcessAdapterSystemState: DevObj %#p Irp %#p "
                   "SystemState %d\n",
                   DeviceObject, Irp, state));

    originalSystemState = commonExtension->CurrentSystemState;

    try {

        POWER_STATE newDeviceState;

        if(((commonExtension->CurrentSystemState != PowerSystemWorking) &&
            (state != PowerSystemWorking)) ||
           (commonExtension->CurrentSystemState == state)) {

            DebugPrint((2, "SpProcessAdapterSystemState: no work required for "
                           "transition from system state %d to %d\n",
                        commonExtension->CurrentSystemState,
                        state));
            commonExtension->CurrentSystemState = state;
            leave;
        }

        //
        // Set the new system state.  We'll back it out if any errors occur.
        //

        commonExtension->CurrentSystemState = state;

        if(state != PowerSystemWorking) {

            //
            // Going into a non-working state - power down the device.
            //

            DebugPrint((1, "SpProcessAdapterSystemState: need to power "
                           "down adapter for non-working system state "
                           "%d\n", state));

            newDeviceState.DeviceState = PowerDeviceD3;

            //
            // This system irp cannot be completed until we've successfully
            // powered the adapter off (or on).
            //

            status = PoRequestPowerIrp(DeviceObject,
                                       IRP_MN_SET_POWER,
                                       newDeviceState,
                                       SpRequestAdapterPowerCompletion,
                                       Irp,
                                       NULL);

            DebugPrint((2, "SpProcessAdapterSystemState: PoRequestPowerIrp "
                           "returned %#08lx\n", status));

        } else {

            //
            // Transitioning the device into a system working state.  Just
            // do the enable.  When a child device is put into S0 and has
            // work to process it will request a D0 of the child which will
            // in turn request a D0 of the parent (ie. the adapter).  We can
            // defer adapter power on until that occurs.
            //

            // Going into a working device state.  When the targets are
            // powered on and we have work to do they will request an
            // adapter power up for us.
            //

            DebugPrint((1, "SpProcessAdapterSystemState: going to working "
                           "state - no need to take adapter out of power "
                           "state %d\n",
                        commonExtension->CurrentDeviceState));

            ASSERT(state == PowerSystemWorking);

            status = SpEnableDisableAdapter(adapterExtension, TRUE);

            ASSERT(status != STATUS_PENDING);

            DebugPrint((1, "SpProcessAdapterSystemState: SpEnableDisableAd. "
                           "returned %#08lx\n", status));

        }

    } finally {

        SpStartNextPacket(DeviceObject, FALSE);

        if(status != STATUS_PENDING) {

            if(!NT_SUCCESS(status)) {

                //
                // Something went wrong above.  Restore the original system
                // state.
                //

                commonExtension->CurrentSystemState = originalSystemState;
            }

            Irp->IoStatus.Status = status;
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

    }
    return;
}


VOID
SpProcessAdapterDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles a device power IRP for the adapter.

Arguments:

    DeviceObject - the device object for the adapter.

    Irp - the power irp.

Return Value:

    none

--*/
{
    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    DEVICE_POWER_STATE state = irpStack->Parameters.Power.State.DeviceState;

    NTSTATUS status = STATUS_SUCCESS;

    ASSERT_FDO(DeviceObject);
    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    DebugPrint((1, "SpProcessAdapterDevicePower: DevObj %#p Irp %#p "
                   "State %d\n",
                   DeviceObject, Irp, state));

    //
    // First check to see if we actually need to touch the queue.
    // If both the current and new state are working or non-working then
    // we don't have a thing to do.
    //

    if(((commonExtension->CurrentDeviceState != PowerDeviceD0) &&
        (state != PowerDeviceD0)) ||
       (commonExtension->CurrentDeviceState == state)) {

        DebugPrint((2, "SpProcessAdapterDeviceState: no work required "
                       "for transition from device state %d to %d\n",
                    commonExtension->CurrentDeviceState,
                    state));

    } else {

        BOOLEAN enable = (state == PowerDeviceD0);

        status = SpEnableDisableAdapter(adapterExtension, enable);

        ASSERT(status != STATUS_PENDING);

        DebugPrint((2, "SpProcessAdapterDeviceState: SpEnableDisableAd. "
                       "returned %#08lx\n", status));

    }

    ASSERT(status != STATUS_PENDING);

    if(NT_SUCCESS(status)) {
        commonExtension->CurrentDeviceState = state;
    }

    //
    // If this is not a D0 irp then throw it down to the lower driver,
    // otherwise complete it.
    //

    SpStartNextPacket(DeviceObject, FALSE);
    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);

    if(irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoCallDriver(commonExtension->LowerDeviceObject, Irp);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    //
    // If we successfully powered up the adapter, initiate a rescan so our child
    // device state is accurate.
    // 

    if (NT_SUCCESS(status) && (state == PowerDeviceD0)) {

        DebugPrint((1, "SpProcessAdapterDeviceState: powered up.. rescan %p\n",
                       adapterExtension->LowerPdo));

        IoInvalidateDeviceRelations(
            adapterExtension->LowerPdo,
            BusRelations);
    }

    return;
}


VOID
ScsiPortProcessAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT_FDO(DeviceObject);

    //
    // Determine if the irp should be sent to the lower driver first.
    // If so send it down without calling SpStartNextPacket so we'll
    // still have synchronization in the completion routine.
    //
    // The completion routine calls ScsiPortProcessAdapterPower for this
    // irp.
    //

    if(irpStack->Parameters.Power.Type == SystemPowerState) {

        //
        // Process system state irps before we send them down.
        //

        SpProcessAdapterSystemState(DeviceObject, Irp);

    } else if(irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0) {

        NTSTATUS status;

        //
        // System power IRP or a power-up request.  These should be
        // processed by the lower driver before being processed by
        // scsiport.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                               SpSetLowerPowerCompletion,
                               NULL,
                               TRUE,
                               TRUE,
                               TRUE);

        status = PoCallDriver(
                     adapter->CommonExtension.LowerDeviceObject,
                     Irp);
    } else {
        SpProcessAdapterDeviceState(DeviceObject, Irp);
    }

    return;
}


VOID
SpRequestAdapterPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(SystemIrp);
    SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

    BOOLEAN enable = FALSE;

    NTSTATUS status = IoStatus->Status;

    ASSERT_FDO(DeviceObject);
    ASSERT(IoGetCurrentIrpStackLocation(SystemIrp)->Parameters.Power.Type ==
           SystemPowerState);

    DebugPrint((2, "SpRequestAdapterPowerCompletion: Adapter %#p, "
                   "Irp %#p, State %d, Status %#08lx\n",
                adapter,
                SystemIrp,
                PowerState.DeviceState,
                IoStatus->Status));

    SystemIrp->IoStatus.Status = IoStatus->Status;

    if(NT_SUCCESS(status)) {

        enable = (state == PowerSystemWorking);

        status = SpEnableDisableAdapter(adapter, enable);

        DebugPrint((1, "SpRequestAdapterPowerCompletion: %s adapter call "
                       "returned %#08lx\n",
                    enable ? "Enable" : "Disable",
                    status));

        ASSERT(status != STATUS_PENDING);

        if((NT_SUCCESS(status)) && enable) {

            POWER_STATE setState;

            setState.SystemState = PowerSystemWorking;

            PoSetPowerState(DeviceObject,
                            SystemPowerState,
                            setState);

        }
    }

    IoCopyCurrentIrpStackLocationToNext(SystemIrp);

    PoStartNextPowerIrp(SystemIrp);
    PoCallDriver(adapter->CommonExtension.LowerDeviceObject, SystemIrp);

    return;
}

VOID
SpSetTargetDesiredPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    ASSERT_PDO(DeviceObject);
    ASSERT(MinorFunction == IRP_MN_SET_POWER);
    ASSERT(NT_SUCCESS(IoStatus->Status));
    ASSERT(PowerState.DeviceState == PowerDeviceD0);
    ASSERT(commonExtension->CurrentDeviceState == PowerDeviceD0);
    ASSERT(commonExtension->DesiredDeviceState == PowerState.DeviceState);
    ASSERT(OriginalIrp == NULL);

    DebugPrint((4, "SpSetTargetDesiredPowerCompletion: power irp completed "
                   "with status %#08lx\n", IoStatus->Status));

    commonExtension->DesiredDeviceState = PowerDeviceUnspecified;

    return;
}


VOID
SpSetTargetDeviceStateLockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    )
/*++

Routine Description:

    This routine is called after locking the queue for handling of a device
    state.  The proper device state is set and an unlock request is sent
    to the queue.  The OriginalIrp (whatever it may have been) will be
    completed after the unlock has been completed.

Arguments:

    DeviceObject - the device object

    Status - the status of the enable/disable operation

    OriginalIrp - the original power irp.

Return Value:

    none

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(OriginalIrp);

    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    DebugPrint((4, "SpSetTargetDeviceStateLockedCompletion: DO %#p Irp %#p "
                   "Status %#08lx\n",
                DeviceObject, OriginalIrp, Status));

    if(NT_SUCCESS(Status)) {

        DEVICE_POWER_STATE newState =
            irpStack->Parameters.Power.State.DeviceState;

        DebugPrint((4, "SpSetTargetDeviceStateLockedCompletion: old device state "
                       "was %d - new device state is %d\n",
                    commonExtension->CurrentDeviceState,
                    irpStack->Parameters.Power.State.DeviceState));

        SpAdjustDisabledBit(logicalUnit,
                            (BOOLEAN) ((newState == PowerDeviceD0) ? TRUE :
                                                                     FALSE));
        commonExtension->CurrentDeviceState = newState;

        SpEnableDisableLogicalUnit(
            logicalUnit,
            TRUE,
            SpSetTargetDeviceStateUnlockedCompletion,
            OriginalIrp);

        return;
    }

    OriginalIrp->IoStatus.Status = Status;
    PoStartNextPowerIrp(OriginalIrp);
    IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);
    return;
}


VOID
SpSetTargetDeviceStateUnlockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    )
/*++

Routine Description:

    This routine is called after unlocking the queue following the setting
    of the new device state.  It simply completes the original power request.

Arguments:

    DeviceObject - the device object

    Status - the status of the enable/disable operation

    OriginalIrp - the original power irp.

Return Value:

    none

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(OriginalIrp);

    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    DebugPrint((4, "SpSetTargetDeviceStateUnlockedCompletion: DO %#p Irp %#p "
                   "Status %#08lx\n",
                DeviceObject, OriginalIrp, Status));

    if(NT_SUCCESS(Status) &&
       (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        //
        // Power up completed - fire notifications.
        //

        PoSetPowerState(DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State);
    }

    OriginalIrp->IoStatus.Status = Status;
    PoStartNextPowerIrp(OriginalIrp);
    IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);
    return;
}


NTSTATUS
SpSetTargetDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceState
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PADAPTER_EXTENSION adapter = logicalUnit->AdapterExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    BOOLEAN isHibernation;

    NTSTATUS status = STATUS_SUCCESS;

    ASSERT_PDO(DeviceObject);
    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    DebugPrint((4, "SpSetTargetDeviceState: device %#p irp %#p\n",
                DeviceObject, Irp));

    //
    // First check to see if we actually need to touch the queue.
    // If both the current and new state are working or non-working then
    // we don't have a thing to do.
    //

    if(((commonExtension->CurrentDeviceState != PowerDeviceD0) &&
        (DeviceState != PowerDeviceD0)) ||
       (commonExtension->CurrentDeviceState == DeviceState)) {

        DebugPrint((4, "SpSetTargetDeviceState: Transition from D%d to D%d "
                       "requires no extra work\n",
                    commonExtension->CurrentDeviceState,
                    DeviceState));

        commonExtension->CurrentDeviceState = DeviceState;

        return STATUS_SUCCESS;
    }

    //
    // We can't power up the target device if the adapter isn't already
    // powered up.
    //

    if((DeviceState == PowerDeviceD0) &&
       (adapter->CommonExtension.CurrentDeviceState != PowerDeviceD0)) {

        POWER_STATE newAdapterState;

        DebugPrint((1, "SpSetTargetPower: Unable to power up target "
                       "before adapter - requesting adapter %#p "
                       "powerup\n",
                    adapter));

        irpStack->DeviceObject = DeviceObject;

        newAdapterState.DeviceState = PowerDeviceD0;

        return PoRequestPowerIrp(adapter->DeviceObject,
                                 IRP_MN_SET_POWER,
                                 newAdapterState,
                                 SpPowerAdapterForTargetCompletion,
                                 Irp,
                                 NULL);
    }

    //
    // Device power operations use queue locks to ensure
    // synchronization with i/o requests.  However they never leave
    // the logical unit queue permenantly locked - otherwise we'd be
    // unable to power-up the device when i/o came in.  Lock the queue
    // so we can set the power state.
    //

    IoMarkIrpPending(Irp);

    SpEnableDisableLogicalUnit(
        logicalUnit,
        FALSE,
        SpSetTargetDeviceStateLockedCompletion,
        Irp);

    return STATUS_PENDING;
}



NTSTATUS
SpSetTargetSystemState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN SYSTEM_POWER_STATE SystemState
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    POWER_STATE newDeviceState;

    NTSTATUS status = STATUS_SUCCESS;

    ASSERT_PDO(DeviceObject);
    ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

    DebugPrint((2, "SpSetTargetSystemState: device %#p irp %#p\n",
                DeviceObject, Irp));

    //
    // First check to see if we actually need to touch the queue.
    // If both the current and new state are working or non-working then
    // we don't have a thing to do.
    //

    if(((commonExtension->CurrentSystemState != PowerSystemWorking) &&
        (SystemState != PowerSystemWorking)) ||
       (commonExtension->CurrentSystemState == SystemState)) {

        DebugPrint((2, "SpSetTargetPower: Transition from S%d to S%d "
                       "requires no extra work\n",
                    commonExtension->CurrentSystemState,
                    SystemState));

        commonExtension->CurrentSystemState = SystemState;

        return STATUS_SUCCESS;
    }

    //
    // Disable the logical unit so we can set it's power state safely.
    //

    IoMarkIrpPending(Irp);

    SpEnableDisableLogicalUnit(
        logicalUnit,
        FALSE,
        SpSetTargetSystemStateLockedCompletion,
        Irp);

    return STATUS_PENDING;
}


VOID
SpSetTargetSystemStateLockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP PowerIrp
    )
/*++

Routine Description:

    This routine is called after the logical unit has been locked and is
    responsible for setting the new system state of the logical unit.  If
    the logical unit currently has a desired power state (other than
    unspecified) this routine will request that the device be put into that
    power state after the logical unit is re-enabled.

    Once the work is done this routine will request that the logical unit
    be re-enabled.  After that the power irp will be completed.

Arguments:

    DeviceObject - the device object which has been disabled

    Status       - the status of the disable request

    PowerIrp     - the power irp we are processing

Return Value:

    none

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(PowerIrp);

    POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
    SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

    POWER_STATE powerState;

    ASSERT_PDO(DeviceObject);
    ASSERT(type == SystemPowerState);
    ASSERT(PowerIrp != NULL);

    DebugPrint((2, "SpSetTargetSystemStateLockedCompletion: DevObj %#p, "
                   "Status %#08lx PowerIrp %#p\n",
                DeviceObject, Status, PowerIrp));

    //
    // If the enable/disable failed then the power operation is obviously
    // unsuccessful.  Fail the power irp.
    //

    if(!NT_SUCCESS(Status)) {

        ASSERT(FALSE);

        PowerIrp->IoStatus.Status = Status;
        PoStartNextPowerIrp(PowerIrp);
        IoCompleteRequest(PowerIrp, IO_NO_INCREMENT);
        return;
    }

    SpAdjustDisabledBit(
        logicalUnit,
        (BOOLEAN) ((state == PowerSystemWorking) ? TRUE : FALSE));

    commonExtension->CurrentSystemState = state;

    DebugPrint((2, "SpSetTargetSystemStateLockedCompletion: new system state %d "
                   "set - desired device state is %d\n",
                state,
                commonExtension->DesiredDeviceState));

    //
    // Re-enable the logical unit.  We'll put it into the correct D state
    // after it's been turned back on.
    //

    SpEnableDisableLogicalUnit(logicalUnit,
                               TRUE,
                               SpSetTargetSystemStateUnlockedCompletion,
                               PowerIrp);

    return;
}


VOID
SpSetTargetSystemStateUnlockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP PowerIrp
    )
/*++

Routine Description:

    This routine is called after the system state of the logical unit has been
    set and it has been re-enabled.  If the device has a desired power state
    or if it needs to be turned off (or on) for hibernation the power irp
    will be sent from here.

Arguments:

    DeviceObject - the logical unit which has been unlocked

    Status - the status of the unlock request

    PowerIrp - the original power irp.

Return Value:

    none

--*/
{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(PowerIrp);

    POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
    SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

    POWER_STATE powerState;

    ASSERT_PDO(DeviceObject);
    ASSERT(type == SystemPowerState);
    ASSERT(PowerIrp != NULL);

    DebugPrint((2, "SpSetTargetSystemStateUnlockedCompletion: DevObj %#p, "
                   "Status %#08lx PowerIrp %#p\n",
                DeviceObject, Status, PowerIrp));

    if(!NT_SUCCESS(Status)) {

        //
        // Oh dear - this device couldn't be re-enabled.  The logical unit is
        // useless until this can be done.
        //

        //
        // CODEWORK - figure out a way to deal with this case.
        //

        ASSERT(FALSE);
        PowerIrp->IoStatus.Status = Status;
        PoStartNextPowerIrp(PowerIrp);
        IoCompleteRequest(PowerIrp, IO_NO_INCREMENT);
        return;
    }

    if(state == PowerSystemWorking) {

        //
        // We're waking up the system.  Check to see if the device needs
        // to be powered immediately as well.
        //

        //
        // Power up - fire notifications.
        //

        powerState.SystemState = state;
        PoSetPowerState(DeviceObject,
                        SystemPowerState,
                        powerState);

        if(commonExtension->DesiredDeviceState != PowerDeviceUnspecified) {

            //
            // Request a power up of the target device now.  We'll complete
            // the system irp immediately without waiting for the device irp
            // to finish.
            //

            powerState.DeviceState = commonExtension->DesiredDeviceState;

            DebugPrint((1, "SpSetTargetSystemStateUnlockedCompletion: Target has "
                           "desired device state of %d - issuing irp to "
                           "request transition\n",
                        powerState.DeviceState));

            Status = PoRequestPowerIrp(DeviceObject,
                                       IRP_MN_SET_POWER,
                                       powerState,
                                       SpSetTargetDesiredPowerCompletion,
                                       NULL,
                                       NULL);

            ASSERT(Status == STATUS_PENDING);

        }

        if(Status != STATUS_PENDING) {
            PowerIrp->IoStatus.Status = Status;
        } else {
            PowerIrp->IoStatus.Status = STATUS_SUCCESS;
        }

        PoStartNextPowerIrp(PowerIrp);
        IoCompleteRequest(PowerIrp, IO_NO_INCREMENT);

    } else {

        //
        // We're going to put the device into a D state based on the current
        // S state.
        //

        DebugPrint((2, "SpSetTargetSystemStateUnlockedCompletion: power down "
                       "target for non-working system state "
                       "transition\n"));

        powerState.DeviceState = PowerDeviceD3;

        //
        // Request the appropriate D irp.  We'll block the S irp until the
        // D transition has been completed.
        //

        Status = PoRequestPowerIrp(
                    DeviceObject,
                    IRP_MN_SET_POWER,
                    powerState,
                    SpSetTargetDeviceStateForSystemStateCompletion,
                    PowerIrp,
                    NULL);

        if(!NT_SUCCESS(Status)) {

            //
            // STATUS_PENDING is still successful.
            //

            PowerIrp->IoStatus.Status = Status;
            PoStartNextPowerIrp(PowerIrp);
            IoCompleteRequest(PowerIrp, IO_NO_INCREMENT);
        }
    }
    return;
}


VOID
SpSetTargetDeviceStateForSystemStateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation(OriginalIrp);

    ASSERT_PDO(DeviceObject);

    ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);
    ASSERT(irpStack->Parameters.Power.State.SystemState != PowerSystemWorking);

    DebugPrint((2, "SpSetTargetDeviceStateForSystemCompletion: DevObj %#p, "
                   "Irp %#p, Status %#08lx\n",
                DeviceObject, OriginalIrp, IoStatus));

    OriginalIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(OriginalIrp);
    IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);

    return;
}


VOID
SpRequestValidPowerStateCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIO_STATUS_BLOCK IoStatus
    )
{

    //
    // re-enable the logical unit.  Don't bother with a completion routine
    // because there's nothing to do.
    //

    ASSERT(NT_SUCCESS(IoStatus->Status));
    SpEnableDisableLogicalUnit(LogicalUnit, TRUE, NULL, NULL);
    return;
}


NTSTATUS
SpRequestValidAdapterPowerStateSynchronous(
    IN PADAPTER_EXTENSION Adapter
    )
{
    PCOMMON_EXTENSION commonExtension = &(Adapter->CommonExtension);
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Interlock with other calls to this routine - there's no reason to have
    // several D0 irps in flight at any given time.
    //

    ExAcquireFastMutex(&(Adapter->PowerMutex));

    try {
        //
        // Check to see if we're already in a working state.  If so we can just
        // continue.
        //

        if((commonExtension->CurrentSystemState == PowerSystemWorking) &&
           (commonExtension->CurrentDeviceState == PowerDeviceD0)) {
            leave;
        }

        //
        // First check the system state.  If the device is in a non-working system
        // state then we'll need to block waiting for the system to wake up.
        //

        if(commonExtension->CurrentSystemState != PowerSystemWorking) {

            //
            // If we're not in a system working state then fail the attempt 
            // to set a new device state.  The caller should retry when the 
            // system is powered on.  Ideally we won't be getting requests 
            // which cause us to try and power up while the system is 
            // suspended.
            //

            status = STATUS_UNSUCCESSFUL;
            leave;
        }

        //
        // Request a power change request.
        //

        {
            POWER_STATE newAdapterState;
            SP_SIGNAL_POWER_COMPLETION_CONTEXT context;

            DebugPrint((1, "SpRequestValidAdapterPowerState: Requesting D0 power "
                           "irp for adapter %p\n", Adapter));

            newAdapterState.DeviceState = PowerDeviceD0;

            KeInitializeEvent(&(context.Event), SynchronizationEvent, FALSE);

            status = PoRequestPowerIrp(Adapter->DeviceObject,
                                       IRP_MN_SET_POWER,
                                       newAdapterState,
                                       SpSignalPowerCompletion,
                                       &context,
                                       NULL);

            if(status == STATUS_PENDING) {
                KeWaitForSingleObject(&(context.Event),
                                      KernelMode,
                                      Executive,
                                      FALSE,
                                      NULL);
            }

            status = context.Status;
            leave;
        }
    } finally {
        ExReleaseFastMutex(&(Adapter->PowerMutex));
    }

    return status;
}


VOID
SpSignalPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PSP_SIGNAL_POWER_COMPLETION_CONTEXT Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    Context->Status = IoStatus->Status;
    KeSetEvent(&(Context->Event), IO_NO_INCREMENT, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\pnp.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    pnp.c

Abstract:

    This is the NT SCSI port driver.  This file contains the self-contained plug
    and play code.

Authors:

    Peter Wieland

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"
#include <wdmguid.h>

#define __FILE_ID__ 'pnp '

#if DBG
static const char *__file__ = __FILE__;
#endif

#define NUM_DEVICE_TYPE_INFO_ENTRIES 18

extern SCSIPORT_DEVICE_TYPE DeviceTypeInfo[];

ULONG SpAdapterStopRemoveSupported = TRUE;

NTSTATUS
SpQueryCapabilities(
    IN PADAPTER_EXTENSION Adapter
    );

PWCHAR
ScsiPortAddGenericControllerId(
    IN PDRIVER_OBJECT DriverObject,
    IN PWCHAR IdList
    );

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    );

NTSTATUS
ScsiPortInitPnpAdapter(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
SpStartLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpGetSlotNumber(
    IN PDEVICE_OBJECT Fdo,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN PCM_RESOURCE_LIST ResourceList
    );

BOOLEAN
SpGetInterrupt(
    IN PCM_RESOURCE_LIST FullResourceList,
    OUT ULONG *Irql,
    OUT ULONG *Vector,
    OUT KAFFINITY *Affinity
    );

VOID
SpQueryDeviceRelationsCompletion(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Status
    );

//
// Routines start
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortAddDevice)
#pragma alloc_text(PAGE, ScsiPortUnload)
#pragma alloc_text(PAGE, ScsiPortFdoPnp)
#pragma alloc_text(PAGE, ScsiPortStartAdapter)
#pragma alloc_text(PAGE, ScsiPortGetDeviceId)
#pragma alloc_text(PAGE, ScsiPortGetInstanceId)
#pragma alloc_text(PAGE, ScsiPortGetHardwareIds)
#pragma alloc_text(PAGE, ScsiPortGetCompatibleIds)
#pragma alloc_text(PAGE, CopyField)
#pragma alloc_text(PAGE, SpFindInitData)
#pragma alloc_text(PAGE, SpStartLowerDevice)
#pragma alloc_text(PAGE, SpGetSlotNumber)
#pragma alloc_text(PAGE, SpGetDeviceTypeInfo)
#pragma alloc_text(PAGE, ScsiPortAddGenericControllerId)
#pragma alloc_text(PAGE, SpQueryCapabilities)
#pragma alloc_text(PAGE, SpGetInterrupt)
#pragma alloc_text(PAGE, SpQueryDeviceRelationsCompletion)

#pragma alloc_text(PAGELOCK, ScsiPortInitPnpAdapter)
#endif

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

SCSIPORT_DEVICE_TYPE DeviceTypeInfo[NUM_DEVICE_TYPE_INFO_ENTRIES] = {
    {"Disk",        "GenDisk",          L"DiskPeripheral",                  TRUE},
    {"Sequential",  "",                 L"TapePeripheral",                  TRUE},
    {"Printer",     "GenPrinter",       L"PrinterPeripheral",               FALSE},
    {"Processor",   "",                 L"OtherPeripheral",                 FALSE},
    {"Worm",        "GenWorm",          L"WormPeripheral",                  TRUE},
    {"CdRom",       "GenCdRom",         L"CdRomPeripheral",                 TRUE},
    {"Scanner",     "GenScanner",       L"ScannerPeripheral",               FALSE},
    {"Optical",     "GenOptical",       L"OpticalDiskPeripheral",           TRUE},
    {"Changer",     "ScsiChanger",      L"MediumChangerPeripheral",         TRUE},
    {"Net",         "ScsiNet",          L"CommunicationsPeripheral",        FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"Array",       "ScsiArray",        L"ArrayPeripheral",                 FALSE},
    {"Enclosure",   "ScsiEnclosure",    L"EnclosurePeripheral",             FALSE},
    {"RBC",         "ScsiRBC",          L"RBCPeripheral",                   TRUE},
    {"CardReader",  "ScsiCardReader",   L"CardReaderPeripheral",            FALSE},
    {"Bridge",      "ScsiBridge",       L"BridgePeripheral",                FALSE},
    {"Other",       "ScsiOther",        L"OtherPeripheral",                 FALSE}
};

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif


NTSTATUS
ScsiPortAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine handles add-device requests for the scsi port driver

Arguments:

    DriverObject - a pointer to the driver object for this device

    PhysicalDeviceObject - a pointer to the PDO we are being added to

Return Value:

    STATUS_SUCCESS

--*/

{
    PSCSIPORT_DRIVER_EXTENSION driverExtension;
    PDEVICE_OBJECT newFdo;

    NTSTATUS status;

    PAGED_CODE();

    status = SpCreateAdapter(DriverObject, &newFdo);

    if(newFdo != NULL) {

        PADAPTER_EXTENSION adapter;
        PCOMMON_EXTENSION commonExtension;

        PDEVICE_OBJECT newStack;

        adapter = newFdo->DeviceExtension;
        commonExtension = &(adapter->CommonExtension);

        adapter->IsMiniportDetected = FALSE;
        adapter->IsPnp = TRUE;

        driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                     ScsiPortInitialize);

        switch(driverExtension->BusType) {
#if 0
            case BusTypeFibre: {
                adapter->DisablePower = TRUE;
                adapter->DisableStop = TRUE;
                break;
            }
#endif

            default: {
                adapter->DisablePower = FALSE;
                adapter->DisableStop = FALSE;
                break;
            }
        }

        newStack = IoAttachDeviceToDeviceStack(newFdo, PhysicalDeviceObject);

        adapter->CommonExtension.LowerDeviceObject = newStack;
        adapter->LowerPdo = PhysicalDeviceObject;

        if(newStack == NULL) {

            status =  STATUS_UNSUCCESSFUL;

        } else {

            status =  STATUS_SUCCESS;
        }
    }

    return status;
}


VOID
ScsiPortUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine will shut down all device objects for this miniport and
    clean up all allocated resources

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PVOID Packet;
    PSCSIPORT_DRIVER_EXTENSION DriverExtension;
    PVOID CurrentValue;
    PVOID InvalidPage;

    PAGED_CODE();

    //
    // See if there is a driver extension for this driver.  It is possible
    // that one has not been created yet, so this may fail, in which case
    // we give up and return.
    //

    DriverExtension = IoGetDriverObjectExtension(
                          DriverObject,
                          ScsiPortInitialize
                          );

    if (DriverExtension == NULL) {
        return;
    }

    //
    // Get the reserve event in the driver extension.  The reserve event
    // may not have already been used, so it's possible that it is NULL.  If
    // this is the case, we give up and return.
    //

    Packet = DriverExtension->ReserveAllocFailureLogEntry;

    if (Packet != NULL) {

        //
        // We have to ensure that we are the only instance to use this
        // event.  To do so, we attempt to NULL the event in the driver
        // extension.  If somebody else beats us to it, they own the
        // event and we have to give up.
        //

        CurrentValue = InterlockedCompareExchangePointer(
                           &(DriverExtension->ReserveAllocFailureLogEntry),
                           NULL,
                           Packet);

        if (Packet == CurrentValue) {            
            IoFreeErrorLogEntry(Packet);
        }
    }

    //
    // Free the invalid page we created to catch misbehaving miniports.
    //

    InvalidPage = DriverExtension->InvalidPage;

    if (InvalidPage != NULL) {

        CurrentValue = InterlockedCompareExchangePointer(
                           &(DriverExtension->InvalidPage),
                           NULL,
                           InvalidPage);

        if (InvalidPage == CurrentValue) {
            MmProtectMdlSystemAddress(DriverExtension->UnusedPageMdl, PAGE_READWRITE);
            MmUnlockPages(DriverExtension->UnusedPageMdl);
            IoFreeMdl(DriverExtension->UnusedPageMdl);
            ExFreePool(DriverExtension->UnusedPage);
        }
    }

#ifdef ALLOC_PRAGMA
    if (VerifierApiCodeSectionHandle != NULL) {
        PVOID Handle = VerifierApiCodeSectionHandle;
        CurrentValue = InterlockedCompareExchangePointer(
                           &VerifierApiCodeSectionHandle,
                           NULL,
                           Handle);
        if (CurrentValue == Handle) {            
            MmUnlockPagableImageSection(Handle);
        }        
    }
#endif
    
    return;
}


NTSTATUS
ScsiPortFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;

    ULONG isRemoved;

    BOOLEAN sendDown = TRUE;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    switch(irpStack->MinorFunction) {

        case IRP_MN_QUERY_PNP_DEVICE_STATE: {

            //
            // If the device is in the paging path then mark it as
            // not-disableable.
            //

            PPNP_DEVICE_STATE deviceState;
            deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);

            DebugPrint((1, "QUERY_DEVICE_STATE for FDO %#x\n",
                        DeviceObject));

            *deviceState = adapter->DeviceState;

            if(commonExtension->PagingPathCount != 0) {
                SET_FLAG((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
                DebugPrint((1, "QUERY_DEVICE_STATE: %#x - not disableable\n",
                            DeviceObject));
            }

            SpReleaseRemoveLock(DeviceObject, Irp);

            Irp->IoStatus.Status = STATUS_SUCCESS;

            IoCopyCurrentIrpStackLocationToNext(Irp);
            return IoCallDriver(commonExtension->LowerDeviceObject, Irp);
        }

        case IRP_MN_START_DEVICE: {

            PSCSIPORT_DRIVER_EXTENSION driverExtension =
                IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                           ScsiPortInitialize);

            PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
            PCM_RESOURCE_LIST allocatedResources =
                irpStack->Parameters.StartDevice.AllocatedResources;
            PCM_RESOURCE_LIST translatedResources =
                irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
            ULONG interfaceFlags;

            sendDown = FALSE;

            //
            // Make sure this device was created by an add rather than the
            // one that was found by port or miniport.
            //

            if(adapter->IsPnp == FALSE) {

                DebugPrint((1, "ScsiPortFdoPnp - asked to start non-pnp "
                               "adapter\n"));
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            if(commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) {

                DebugPrint((1, "ScsiPortFdoPnp - already started - nothing "
                               "to do\n"));
                status = STATUS_SUCCESS;
                break;
            }

            //
            // Now make sure that pnp handed us some resources.  It may not
            // if this is a phantom of a PCI device which we reported on a
            // previous boot.  In that case pnp thinks we'll allocate the
            // resources ourselves.
            //

            if(allocatedResources == NULL) {

                //
                // This happens with reported devices when PCI mvoes them from
                // boot to boot.
                //

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                break;
            }

            ASSERT(allocatedResources);
            ASSERT(allocatedResources->Count);

            //
            // Make sure that adapters with this interface type can be
            // initialized as pnp drivers.
            //

            interfaceFlags = SpQueryPnpInterfaceFlags(
                                driverExtension,
                                allocatedResources->List[0].InterfaceType);

            if(interfaceFlags == SP_PNP_NOT_SAFE) {

                //
                // Nope - not safe.  We cannot start this device so return
                // failure.
                //

                DebugPrint((1, "ScsiPortFdoPnp - Miniport cannot be run in "
                               "pnp mode for interface type %#08lx\n",
                            allocatedResources->List[0].InterfaceType));

                //
                // Mark the device as not being pnp - that way we won't get
                // removed.
                //

                adapter->IsPnp = FALSE;

                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Check to see if this interface requires slot/function numbers.
            // If not then zero out the virtual slot number.
            //

            if(!TEST_FLAG(interfaceFlags, SP_PNP_NEEDS_LOCATION)) {
                adapter->VirtualSlotNumber.u.AsULONG = 0;
            }


            //
            // Determine if we should have found this device during
            // our detection scan.  We do this by checking to see if the pdo
            // has a pnp bus type.  If not and the detection flag is set then
            // assume duplicate detection has failed and don't start this
            // device.
            //

            {
                status = SpGetBusTypeGuid(adapter);

                if((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                   ((driverExtension->LegacyAdapterDetection == TRUE) &&
                    (interfaceFlags & SP_PNP_NON_ENUMERABLE))) {

                    DbgPrint("ScsiPortFdoPnp: device has no pnp bus type but "
                             "was not found as a duplicate during "
                             "detection\n");

                    status = STATUS_UNSUCCESSFUL;

                    //
                    // make sure this one doesn't get removed though - if it's
                    // removed then the resources may be disabled for the
                    // ghost.
                    //

                    adapter->IsPnp = FALSE;

                    break;
                }
            }

            //
            // Finally, if this is a PCI adapter make sure we were given
            // an interrupt.  The current assumption is that there aren't
            // any polled-mode PCI SCSI adapters in the market.
            //

            if(TEST_FLAG(interfaceFlags, SP_PNP_INTERRUPT_REQUIRED)) {

                ULONG irql, vector;
                KAFFINITY affinity;

                if(SpGetInterrupt(allocatedResources,
                                  &irql,
                                  &vector,
                                  &affinity) == FALSE) {

                    PIO_ERROR_LOG_PACKET error =
                        IoAllocateErrorLogEntry(DeviceObject,
                                                sizeof(IO_ERROR_LOG_PACKET));

                    status = STATUS_DEVICE_CONFIGURATION_ERROR;

                    if(error != NULL) {
                        error->MajorFunctionCode = IRP_MJ_PNP;
                        error->UniqueErrorValue = 0x418;
                        error->ErrorCode = IO_ERR_INCORRECT_IRQL;
                        IoWriteErrorLogEntry(error);
                    }
                    break;
                }
            }

            status = SpStartLowerDevice(DeviceObject, Irp);

            if(NT_SUCCESS(status)) {

                //
                // If we haven't allocated a HwDeviceExtension for this thing
                // yet then we'll need to set it up
                //

                if(commonExtension->IsInitialized == FALSE) {

                    DebugPrint((1, "ScsiPortFdoPnp - find and init adapter %#p\n",
                                   DeviceObject));

                    if(allocatedResources == NULL) {
                        status = STATUS_INVALID_PARAMETER;
                    } else {

                        adapter->AllocatedResources =
                            RtlDuplicateCmResourceList(
                                DeviceObject->DriverObject,
                                NonPagedPool,
                                allocatedResources,
                                SCSIPORT_TAG_RESOURCE_LIST);

                        adapter->TranslatedResources =
                            RtlDuplicateCmResourceList(
                                DeviceObject->DriverObject,
                                NonPagedPool,
                                translatedResources,
                                SCSIPORT_TAG_RESOURCE_LIST);

                        commonExtension->IsInitialized = TRUE;

                        status = ScsiPortInitPnpAdapter(DeviceObject);
                    }

                    if(!NT_SUCCESS(status)) {

                        DebugPrint((1, "ScsiPortInitializeAdapter failed "
                                       "%#08lx\n", status));
                        break;
                    }

                }

                //
                // Start up the adapter.
                //

                status = ScsiPortStartAdapter(DeviceObject);

                if(NT_SUCCESS(status)) {
                    commonExtension->PreviousPnpState = 0xff;
                    commonExtension->CurrentPnpState = IRP_MN_START_DEVICE;
                }

            }

            break;
        }

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {

            PIO_RESOURCE_REQUIREMENTS_LIST requirements;
            //
            // Grab the bus and slot numbers out of the resource requirements
            // list.
            //

            requirements = irpStack->Parameters.FilterResourceRequirements.
                                                IoResourceRequirementList;

            if(requirements != NULL) {
                adapter->RealBusNumber = requirements->BusNumber;
                adapter->RealSlotNumber = requirements->SlotNumber;
            }

            sendDown = TRUE;

            IoCopyCurrentIrpStackLocationToNext(Irp);
            SpReleaseRemoveLock(DeviceObject, Irp);
            return IoCallDriver(commonExtension->LowerDeviceObject, Irp);
            break;
        }

        case IRP_MN_CANCEL_STOP_DEVICE: {

            sendDown = TRUE;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            if(commonExtension->CurrentPnpState == IRP_MN_QUERY_STOP_DEVICE) {
                commonExtension->CurrentPnpState =
                    commonExtension->PreviousPnpState;
                commonExtension->PreviousPnpState = 0xff;
            }
            break;
        }

        case IRP_MN_CANCEL_REMOVE_DEVICE: {

            sendDown = TRUE;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            if(commonExtension->CurrentPnpState == IRP_MN_QUERY_REMOVE_DEVICE) {
                commonExtension->CurrentPnpState =
                    commonExtension->PreviousPnpState;
                commonExtension->PreviousPnpState = 0xff;
            }
            break;
        }

        case IRP_MN_QUERY_STOP_DEVICE: {

            if(adapter->DisableStop) {
                status = STATUS_NOT_SUPPORTED;
                sendDown = FALSE;
                break;
            }

            //
            // Fall through.
            //
        }

        case IRP_MN_QUERY_REMOVE_DEVICE: {

            //
            // No problem with this request on our part.  Just send it down
            // to the next driver.
            //

            if(SpAdapterStopRemoveSupported) {
                if((adapter->IsPnp) &&
                   SpIsAdapterControlTypeSupported(adapter,
                                                   ScsiStopAdapter)) {
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    sendDown = TRUE;
                } else {
                    status = STATUS_UNSUCCESSFUL;
                    sendDown = FALSE;
                }

                if(NT_SUCCESS(status)) {
                    commonExtension->PreviousPnpState =
                        commonExtension->CurrentPnpState;
                    commonExtension->CurrentPnpState = irpStack->MinorFunction;
                }
            } else {
                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                status = STATUS_UNSUCCESSFUL;
                sendDown = FALSE;
            }

            break;
        }

        case IRP_MN_SURPRISE_REMOVAL: {

            PDEVICE_OBJECT lowerDevice = commonExtension->LowerDeviceObject;

            //
            // Terminate the device.  This shuts down the miniport as quickly
            // as possible and aborts all i/o requests.
            //

            //
            // First mark the device as REMOVE_PENDING - this should keep
            // us from starting up any new i/o requests.
            //

            commonExtension->IsRemoved = REMOVE_PENDING;

            if(commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) {
                SpTerminateAdapter(adapter);
            }

            // Release the remove lock and wait for any in-flight requests
            // to complete.
            //
            
            SpReleaseRemoveLock(DeviceObject, Irp);
            SpWaitForRemoveLock(DeviceObject, DeviceObject);

            ScsiPortRemoveAdapter(DeviceObject, TRUE);

            //
            // Save the new state of this device.
            //

            commonExtension->PreviousPnpState = commonExtension->CurrentPnpState;
            commonExtension->CurrentPnpState = IRP_MN_SURPRISE_REMOVAL;

            IoCopyCurrentIrpStackLocationToNext(Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

            return status;

            break;
        }

        case IRP_MN_REMOVE_DEVICE: {

            PDEVICE_OBJECT lowerDevice = commonExtension->LowerDeviceObject;
            KEVENT event;

            //
            // Asked to remove the adapter.  We'll ask the port driver to
            // stop it's adapter and release it's resources.  We can
            // detach and delete our device object as the lower driver
            // completes the remove request.
            //

            ASSERT(isRemoved != REMOVE_COMPLETE);

            //
            // If the device has been started then make sure we've got the
            // necessary code to disable it.  If it isn't currently started
            // then either it's got the code we need or it's never been
            // started - in either case we can just tear it down.
            //

            if((adapter->IsPnp == FALSE) ||
               ((commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) &&
                (!SpIsAdapterControlTypeSupported(adapter,
                                                  ScsiStopAdapter)))) {

                //
                // the miniport needs to be stopped but we cannot do it.
                // Fail the request.
                //

                status = STATUS_UNSUCCESSFUL;
                sendDown = FALSE;
                break;
            }

            //
            // Clear the interface if it exists.
            //

            if(adapter->InterfaceName.Buffer != NULL) {
                IoSetDeviceInterfaceState(
                    &(adapter->InterfaceName),
                    FALSE);
                RtlFreeUnicodeString(&(adapter->InterfaceName));
                RtlInitUnicodeString(&(adapter->InterfaceName), NULL);
            }

            SpReleaseRemoveLock(DeviceObject, Irp);
            ScsiPortRemoveAdapter(DeviceObject, FALSE);

            //
            // The adapter's been removed.  Set the new state now.
            //

            commonExtension->CurrentPnpState = IRP_MN_REMOVE_DEVICE;
            commonExtension->PreviousPnpState = 0xff;

            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            IoCopyCurrentIrpStackLocationToNext(Irp);

            IoSetCompletionRoutine(Irp,
                                   SpSignalCompletion,
                                   &event,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            IoDetachDevice(commonExtension->LowerDeviceObject);
            IoDeleteDevice(DeviceObject);

            return status;

            break;
        }

        case IRP_MN_STOP_DEVICE: {

            sendDown = TRUE;

            ASSERT(adapter->IsPnp);
            ASSERT(adapter->HwAdapterControl != NULL);

            status = ScsiPortStopAdapter(DeviceObject, Irp);

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0L;

            if(!NT_SUCCESS(status)) {
                sendDown = FALSE;
            } else {
                commonExtension->PreviousPnpState = commonExtension->CurrentPnpState;
                commonExtension->CurrentPnpState = IRP_MN_STOP_DEVICE;
            }

            break;
        }

        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            DEVICE_RELATION_TYPE type =
                irpStack->Parameters.QueryDeviceRelations.Type;

            DebugPrint((1, "ScsiPortFdoPnp - got "
                           "IRP_MJ_QUERY_DEVICE_RELATIONS\n"));
            DebugPrint((1, "\ttype is %d\n", type));

            if (type == BusRelations) {

                PSP_ENUMERATION_REQUEST request;

                request = InterlockedCompareExchangePointer(
                              &adapter->PnpEnumRequestPtr,
                              NULL,
                              &(adapter->PnpEnumerationRequest));

                if (request != NULL) {

                    RtlZeroMemory(request, sizeof(SP_ENUMERATION_REQUEST));

                    request->CompletionRoutine = SpQueryDeviceRelationsCompletion;
                    request->Context = Irp;
                    request->CompletionStatus = &(Irp->IoStatus.Status);

                    IoMarkIrpPending(Irp);

                    SpEnumerateAdapterAsynchronous(adapter, request, FALSE);
                    return STATUS_PENDING;

                } else {

                    ASSERT(FALSE && "Unexpected!! Concurrent QDR requests");
                    Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                    Irp->IoStatus.Information = 0L;
                    sendDown = FALSE;

                }

            }

            break;
        }

        case IRP_MN_DEVICE_USAGE_NOTIFICATION: {

            //
            // Send the irp down to the device below us.
            // Since there's a remove lock outstanding on the PDO we can release
            // the lock on the FDO before sending this down.
            //

            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCopyCurrentIrpStackLocationToNext(Irp);
            SpReleaseRemoveLock(commonExtension->DeviceObject, Irp);
            return IoCallDriver(commonExtension->LowerDeviceObject, Irp);
            break;
        }

        case IRP_MN_QUERY_ID: {

            PWCHAR newIdList;

            //
            // We add the id GEN_SCSIADAPTER to the compatible ID's for any
            // adapters controlled by scsiport.
            //

            DebugPrint((2, "ScsiPortFdoPnp: got IRP_MN_QUERY_ID\n"));

            if(irpStack->Parameters.QueryId.IdType != BusQueryCompatibleIDs) {
                sendDown = TRUE;
                break;
            }

            status = SpSendIrpSynchronous(commonExtension->LowerDeviceObject,
                                          Irp);

            newIdList = ScsiPortAddGenericControllerId(
                            DeviceObject->DriverObject,
                            (PWCHAR) (Irp->IoStatus.Information));

            if(newIdList == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                status = STATUS_SUCCESS;
                if(Irp->IoStatus.Information != 0L) {
                    ExFreePool((PVOID) Irp->IoStatus.Information);
                }
                Irp->IoStatus.Information = (ULONG_PTR) newIdList;
            }

            sendDown = FALSE;
            break;
        }

        default: {

            PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);

            DebugPrint((1, "ScsiPortFdoPnp: Unimplemented PNP/POWER minor "
                           "code %d\n", irpStack->MinorFunction));

            break;
        }
    }

    SpReleaseRemoveLock(DeviceObject, Irp);

    if(sendDown) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

    } else {

        Irp->IoStatus.Status = status;
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
    }

    return status;
}

NTSTATUS
ScsiPortStartAdapter(
    IN PDEVICE_OBJECT Adapter
    )

/*++

Routine Descripion:

    This routine will start an adapter.

    It is illegal to start the device if it has already been started.

Arguments:

    Adapter - a pointer to the functional device object (adapter) being started

Return Value:

    STATUS_SUCCESS if the device was properly started and enumeration was
                   attempted - or if the device had previously been started.

    error value indicating the cause of the failure otherwise

--*/

{
    PSCSIPORT_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Adapter->DriverObject,
                                                     ScsiPortInitialize);

    PADAPTER_EXTENSION adapterExtension = Adapter->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = Adapter->DeviceExtension;

    UCHAR pathId;

    PAGED_CODE();

    ASSERT(driverExtension != NULL);
    ASSERT_FDO(Adapter);

    ASSERT(commonExtension->CurrentPnpState != IRP_MN_START_DEVICE);
    ASSERT(commonExtension->IsInitialized);

    ASSERT(((Adapter->Flags & DO_DEVICE_INITIALIZING) == 0));

    DebugPrint((1, "ScsiPortStartAdapter - starting adapter %#p\n", Adapter));

    //
    // Start timer. Request timeout counters
    // in the logical units have already been
    // initialized.
    //

    adapterExtension->TickCount = 0;
    IoStartTimer(Adapter);

    //
    // Initialize WMI support.
    //
    
    if (adapterExtension->CommonExtension.WmiInitialized == FALSE) {

        //
        // Build the SCSIPORT WMI registration information buffer for this FDO.
        //

        SpWmiInitializeSpRegInfo(Adapter);

        //
        // Register this device object only if the miniport supports WMI and/or
        // SCSIPORT will support certain WMI GUIDs on behalf of the miniport.
        //
        
        if (adapterExtension->CommonExtension.WmiScsiPortRegInfoBuf != NULL) {
           
           //
           // Register this functional device object as a WMI data provider,
           // instructing WMI that it is ready to receive WMI IRPs.
           //
            
            DebugPrint((1, "ScsiPortStartAdapter: REGISTER FDO:%p\n", Adapter));
            IoWMIRegistrationControl(Adapter, WMIREG_ACTION_REGISTER);
            adapterExtension->CommonExtension.WmiInitialized = TRUE;
        }

        //
        // Allocate several WMI_MINIPORT_REQUEST_ITEM blocks to satisfy a
        // potential onslaught of WMIEvent notifications by the miniport.
        //
        
        if (adapterExtension->CommonExtension.WmiMiniPortSupport) {
            
            //
            // Currently, we only allocate two per new adapter (FDO).
            //
            
            SpWmiInitializeFreeRequestList(Adapter, 2);
        }
    }

    //
    // Create a well known name for this device object by making a symbolic
    // link to the PDO.  Even if this fails, the start should still succeed.
    //

    if(adapterExtension->PortNumber == -1) {

        NTSTATUS status;

        UNICODE_STRING unicodePdoName;

        ULONG number;

        UNICODE_STRING interfaceName;

        RtlInitUnicodeString(&unicodePdoName, adapterExtension->DeviceName);

        //
        // Start at zero and keep going through all the possible numbers
        // until we find a hole.  This is an unfortunate requirement for
        // legacy support since most old class drivers will give up if
        // they find a hole in the scsiport numbers.
        //

        number = 0;

        do {

            WCHAR wideLinkName[64];
            UNICODE_STRING unicodeLinkName;

            //
            // Create the well known name string first.
            //

            swprintf(wideLinkName, L"\\Device\\ScsiPort%d", number);

            RtlInitUnicodeString(&unicodeLinkName, wideLinkName);

            status = IoCreateSymbolicLink(&unicodeLinkName, &unicodePdoName);

            if(NT_SUCCESS(status)) {

                //
                // Found a spot - mark this one as named so we don't go
                // through this trouble again and save the port number
                //

                adapterExtension->PortNumber = number;

                //
                // Create the dos port driver name.  If there's a collision
                // then just forget it.
                //

                swprintf(wideLinkName, L"\\DosDevices\\Scsi%d:", number);
                RtlInitUnicodeString(&unicodeLinkName, wideLinkName);
                IoCreateSymbolicLink(&unicodeLinkName, &unicodePdoName);
            } else {
                number++;
            }
        } while (status == STATUS_OBJECT_NAME_COLLISION);

        //
        // Increment the count of scsiport device
        //

        IoGetConfigurationInformation()->ScsiPortCount++;

        //
        // Create a device map entry for this adapter.
        //

        SpBuildDeviceMapEntry(commonExtension);

        //
        // Register our device interface.
        //

        status = IoRegisterDeviceInterface(adapterExtension->LowerPdo,
                                           &StoragePortClassGuid,
                                           NULL,
                                           &interfaceName);

        if(NT_SUCCESS(status)) {

            adapterExtension->InterfaceName = interfaceName;

            status = IoSetDeviceInterfaceState(&interfaceName, TRUE);

            if(!NT_SUCCESS(status)) {
                RtlFreeUnicodeString(&interfaceName);
                RtlInitUnicodeString(&(adapterExtension->InterfaceName), NULL);
            }
        }
    }

    //
    // Set the force next bus scan bit.
    //
    adapterExtension->ForceNextBusScan = TRUE;

    return STATUS_SUCCESS;
}


NTSTATUS
ScsiPortGetDeviceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a device id string for
    the specified Pdo.  This string is generated from the bus type (scsi) and
    the type of the device.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION physicalExtension = Pdo->DeviceExtension;
    PINQUIRYDATA inquiryData = &(physicalExtension->InquiryData);

    UCHAR buffer[256];
    PUCHAR rawIdString = buffer;
    ANSI_STRING ansiIdString;

    ULONG whichString;

    PAGED_CODE();

    ASSERT(UnicodeString != NULL);

    RtlZeroMemory(buffer, sizeof(buffer));

    sprintf(rawIdString,
            "SCSI\\%s",
            SpGetDeviceTypeInfo(inquiryData->DeviceType)->DeviceTypeString);

    rawIdString += strlen(rawIdString);

    ASSERT(*rawIdString == '\0');

    for(whichString = 0; whichString < 3; whichString++) {

        PUCHAR headerString;
        PUCHAR sourceString;
        ULONG sourceStringLength;

        ULONG i;

        switch(whichString) {

            //
            // Vendor Id
            //
            case 0: {
                sourceString = inquiryData->VendorId;
                sourceStringLength = sizeof(inquiryData->VendorId);
                headerString = "Ven";
                break;
            }

            //
            // Product Id
            //
            case 1: {
                sourceString = inquiryData->ProductId;
                sourceStringLength = sizeof(inquiryData->ProductId);
                headerString = "Prod";
                break;
            }

            //
            // Product Revision Level
            //
            case 2: {
                sourceString = inquiryData->ProductRevisionLevel;
                sourceStringLength = sizeof(inquiryData->ProductRevisionLevel);
                headerString = "Rev";
                break;
            }
        }

        //
        // Start at the end of the source string and back up until we find a
        // non-space, non-null character.
        //

        for(; sourceStringLength > 0; sourceStringLength--) {

            if((sourceString[sourceStringLength - 1] != ' ') &&
               (sourceString[sourceStringLength - 1] != '\0')) {
                break;
            }
        }

        //
        // Throw the header string into the block
        //

        sprintf(rawIdString, "&%s_", headerString);
        rawIdString += strlen(headerString) + 2;

        //
        // Spew the string into the device id
        //

        for(i = 0; i < sourceStringLength; i++) {
            *rawIdString = (sourceString[i] != ' ') ? (sourceString[i]) :
                                                      ('_');
            rawIdString++;
        }
        ASSERT(*rawIdString == '\0');
    }

    RtlInitAnsiString(&ansiIdString, buffer);

    DebugPrint((1, "DeviceId for logical unit %#p is %Z\n",
                Pdo, &ansiIdString));

    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
}


NTSTATUS
ScsiPortGetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in an instance id string for
    the specified Pdo.  This string will be generated either from the device
    type + serial number of the device (if it has a serial number) or from
    the address of the device.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION physicalExtension = Pdo->DeviceExtension;

    PDRIVER_OBJECT driverObject = Pdo->DriverObject;
    PSCSIPORT_DEVICE_TYPE deviceTypeInfo;

    UCHAR idStringBuffer[64];
    ANSI_STRING ansiIdString;

    PAGED_CODE();

    ASSERT(UnicodeString != NULL);

    //
    // can't use serial number even if it exists since a device which is 
    // multiply connected to the same bus (dual-ported device) will have 
    // the same serial number at each connection and would confuse the PNP.
    //

    sprintf(idStringBuffer,
            "%x%x%x",
            physicalExtension->PathId,
            physicalExtension->TargetId,
            physicalExtension->Lun
            );

    RtlInitAnsiString(&ansiIdString, idStringBuffer);

    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
}


NTSTATUS
ScsiPortGetCompatibleIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a compatible id multi
    string for the specified Pdo.  This string is generated using the bus and
    device types for the device

Arguments:

    InquiryData - the inquiry data to generate compatible ids from.

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    UCHAR s[sizeof("SCSI\\DEVICE_TYPE_GOES_HERE")];
    PSTR stringBuffer[] = {
        s,
        "SCSI\\RAW",
        NULL};

    //
    // Fill in the scsi specific string
    //

    sprintf(stringBuffer[0],
            "SCSI\\%s",
            SpGetDeviceTypeInfo(InquiryData->DeviceType)->DeviceTypeString);

    //
    // Set up the first id string
    //

    return ScsiPortStringArrayToMultiString(
        DriverObject, 
        UnicodeString, 
        stringBuffer);
}


NTSTATUS
ScsiPortGetHardwareIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a hardware id multi
    string for the specified Pdo.  This string is generated using the device
    type and the inquiry data.

Arguments:

    InquiryData - the inquiry data to be converted into id strings.

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

#define NUMBER_HARDWARE_STRINGS 6

{
    PSCSIPORT_DEVICE_TYPE devTypeInfo =
        SpGetDeviceTypeInfo(InquiryData->DeviceType);

    ULONG i;

    PSTR strings[NUMBER_HARDWARE_STRINGS + 1];
    UCHAR scratch[64];

    NTSTATUS status;

    PAGED_CODE();

    //
    // Zero out the string buffer
    //

    RtlZeroMemory(strings, sizeof(strings));

    try {

        for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

            RtlZeroMemory(scratch, sizeof(scratch));

            //
            // Build each of the hardware id's
            //

            switch(i) {

                //
                // Bus + Dev Type + Vendor + Product + Revision
                //

                case 0: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductRevisionLevel,
                              4,
                              '_');
                    break;
                }

                //
                // bus + device + vendor + product
                //

                case 1: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    break;
                }

                //
                // bus + device + vendor
                //

                case 2: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    break;
                }

                //
                // bus \ vendor + product + revision[0]
                //

                case 3: {
                    sprintf(scratch, "SCSI\\");

                    //
                    // Fall through to the next set.
                    //
                }

                //
                // vendor + product + revision[0] (win9x)
                //

                case 4: {

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductRevisionLevel,
                              1,
                              '_');

                    break;
                }

                case 5: {

                    sprintf(scratch, "%s", devTypeInfo->GenericTypeString);
                    break;
                }

                default: {
                    ASSERT(FALSE);
                    break;
                }
            }

            if(strlen(scratch) != 0) {
                strings[i] =
                    SpAllocatePool(PagedPool,
                                   strlen(scratch) + sizeof(UCHAR),
                                   SCSIPORT_TAG_PNP_ID,
                                   DriverObject);

                if(strings[i] == NULL) {
                    status =  STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }

                strcpy(strings[i], scratch);

            } else {

                break;
            }
        }

        status = ScsiPortStringArrayToMultiString(DriverObject,
                                                  UnicodeString,
                                                  strings);
        leave;

    } finally {

        for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

            if(strings[i]) {
                ExFreePool(strings[i]);
            }
        }
    }

    return status;
}

#undef NUMBER_HARDWARE_STRINGS

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    )

/*++

Routine Description:

    This routine will copy Count string bytes from Source to Destination.  If
    it finds a nul byte in the Source it will translate that and any subsequent
    bytes into Change.  It will also replace spaces with the specified character.

Arguments:

    Destination - the location to copy bytes

    Source - the location to copy bytes from

    Count - the number of bytes to be copied

Return Value:

    none

--*/

{
    ULONG i = 0;
    BOOLEAN pastEnd = FALSE;

    PAGED_CODE();

    for(i = 0; i < Count; i++) {

        if(!pastEnd) {

            if(Source[i] == 0) {

                pastEnd = TRUE;

                Destination[i] = Change;

            } else if(Source[i] == ' ') {

                Destination[i] = Change;

            } else {

                Destination[i] = Source[i];

            }
        } else {
            Destination[i] = Change;
        }
    }
    return;
}


NTSTATUS
ScsiPortInitPnpAdapter(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will find and (if found) initialize a specific adapter.  The
    adapter is specified by the ResourceList passed in.

    This routine will initialize a port configuration structure using the
    information provided in the resource list and call the miniport's find
    adapter routine to locate the adapter.  If that completes successfully, the
    miniport's initialize routine will be called.  This will connect the
    interrupts and initialize the timers and DPCs as well as allocating
    common buffers and request data structures.

Arguments:

    Fdo - the device object for the adapter being initialized

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapter = Fdo->DeviceExtension;

    PSCSIPORT_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Fdo->DriverObject,
                                                     ScsiPortInitialize);

    INTERFACE_TYPE interfaceType;
    ULONG resultLength;

    PHW_INITIALIZATION_DATA hwInitializationData = NULL;

    CONFIGURATION_CONTEXT configurationContext;

    PPORT_CONFIGURATION_INFORMATION configInfo = NULL;

    BOOLEAN callAgain;

    OBJECT_ATTRIBUTES objectAttributes;

    ULONG uniqueId;

    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG hwDeviceExtensionSize;

    PUNICODE_STRING registryPath = &(driverExtension->RegistryPath);

    NTSTATUS status;

    PAGED_CODE();

    //
    // Find the init data for this interface type
    //

    interfaceType = SpGetPdoInterfaceType(adapter->LowerPdo);

    hwInitializationData = SpFindInitData(driverExtension, interfaceType);

    if(hwInitializationData == NULL) {

        //
        // Hmmm.  The miniport never reported this adapter type.  We can't
        // start the device since we don't know what the correct entry points
        // are.  Pretend it doesn't exist
        //

        return STATUS_NO_SUCH_DEVICE;
    }

    hwDeviceExtensionSize = hwInitializationData->DeviceExtensionSize +
                            sizeof(HW_DEVICE_EXTENSION);

    RtlZeroMemory(&configurationContext, sizeof(configurationContext));

    if(hwInitializationData->NumberOfAccessRanges != 0) {

        configurationContext.AccessRanges =
            SpAllocatePool(PagedPool,
                           (hwInitializationData->NumberOfAccessRanges *
                            sizeof(ACCESS_RANGE)),
                           SCSIPORT_TAG_ACCESS_RANGE,
                           Fdo->DriverObject);

        if(configurationContext.AccessRanges == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    try {

        ULONG portConfigSize;

        //
        // Allocate the HwDeviceExtension first - it's easier to deallocate :)
        //

        hwDeviceExtension = SpAllocatePool(NonPagedPool,
                                           hwDeviceExtensionSize,
                                           SCSIPORT_TAG_DEV_EXT,
                                           Fdo->DriverObject);


        if(hwDeviceExtension == NULL) {
            DebugPrint((1, "ScsiPortInitialize: Could not allocate "
                           "HwDeviceExtension\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            uniqueId = __LINE__;
            leave;
        }

        RtlZeroMemory(hwDeviceExtension, hwDeviceExtensionSize);

        //
        // Setup device extension pointers
        //

        SpInitializeAdapterExtension(adapter,
                                     hwInitializationData,
                                     hwDeviceExtension);

        //
        // initialize the miniport config info buffer
        //

        status = SpInitializeConfiguration(
                    adapter,
                    registryPath,
                    hwInitializationData,
                    &configurationContext);

        if(!NT_SUCCESS(status)) {

            uniqueId = __LINE__;
            leave;
        }

        //
        // Allocate a config-info structure and access ranges for the
        // miniport drivers to use
        //

        portConfigSize = sizeof(PORT_CONFIGURATION_INFORMATION);
        portConfigSize += hwInitializationData->NumberOfAccessRanges *
                          sizeof(ACCESS_RANGE);
        portConfigSize += 7;
        portConfigSize &= ~7;

        configInfo = SpAllocatePool(NonPagedPool,
                                    portConfigSize,
                                    SCSIPORT_TAG_PORT_CONFIG,
                                    Fdo->DriverObject);

        if(configInfo == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            uniqueId = __LINE__;
            leave;
        }

        adapter->PortConfig = configInfo;

        //
        // Copy the current structure to the writable copy
        //

        RtlCopyMemory(configInfo,
                      &configurationContext.PortConfig,
                      sizeof(PORT_CONFIGURATION_INFORMATION));

        //
        // Copy the SrbExtensionSize from device extension to ConfigInfo.
        // A check will be made later to determine if the miniport updated
        // this value
        //

        configInfo->SrbExtensionSize = adapter->SrbExtensionSize;
        configInfo->SpecificLuExtensionSize = adapter->HwLogicalUnitExtensionSize;

        //
        // initialize the access range array
        //

        if(hwInitializationData->NumberOfAccessRanges != 0) {

            configInfo->AccessRanges = (PVOID) (configInfo + 1);

            //
            // Quadword align this
            //

            (ULONG_PTR) (configInfo->AccessRanges) += 7;
            (ULONG_PTR) (configInfo->AccessRanges) &= ~7;

            RtlCopyMemory(configInfo->AccessRanges,
                          configurationContext.AccessRanges,
                          (hwInitializationData->NumberOfAccessRanges *
                           sizeof(ACCESS_RANGE)));
        }

        //
        // Set the adapter interface type.
        //

        configInfo->AdapterInterfaceType = interfaceType;

        //
        // Since we've been handed resources we need to build a config info
        // structure before we can call the find adapter routine
        //

        SpBuildConfiguration(adapter,
                             hwInitializationData,
                             configInfo);

        SpGetSlotNumber(Fdo, configInfo, adapter->AllocatedResources);

        //
        // Get the miniport configuration inofmraiton
        //

        status = SpCallHwFindAdapter(Fdo,
                                     hwInitializationData,
                                     NULL,
                                     &configurationContext,
                                     configInfo,
                                     &callAgain);

        if(status == STATUS_DEVICE_DOES_NOT_EXIST) {

            adapter->PortConfig = NULL;
            ExFreePool(configInfo);

        } else if(NT_SUCCESS(status)) {

            status = SpAllocateAdapterResources(Fdo);

            if(NT_SUCCESS(status)) {

                PCOMMON_EXTENSION commonExtension = Fdo->DeviceExtension;
                BOOLEAN stopped;

                //
                // If the device's previous state is IRP_MN_STOP_DEVICE then
                // it should have a disable count of 1.  Clear the disabled
                // state.
                //

                stopped =
                    ((commonExtension->CurrentPnpState == IRP_MN_STOP_DEVICE) ?
                     TRUE :
                     FALSE);

                if(stopped) {

                    ASSERT(adapter->CommonExtension.PreviousPnpState == IRP_MN_START_DEVICE);
                    ASSERT(adapter->DisableCount == 1);

                    adapter->DisableCount = 0;
                    CLEAR_FLAG(adapter->InterruptData.InterruptFlags,
                               PD_DISABLE_INTERRUPTS);
                }

                status = SpCallHwInitialize(Fdo);

                if(stopped) {

                    KIRQL oldIrql;
                    PVOID sectionHandle;

                    //
                    // Restart i/o processing.
                    //

                    sectionHandle =
                        MmLockPagableCodeSection(ScsiPortInitPnpAdapter);

                    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
                    IoStartNextPacket(Fdo, FALSE);
                    KeLowerIrql(oldIrql);
                    MmUnlockPagableImageSection(sectionHandle);
                }
            }

        }

    } finally {

        if(!NT_SUCCESS(status)) {

            PIO_ERROR_LOG_PACKET errorLogEntry;

            //
            // An error occured - log it.
            //

            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                                IoAllocateErrorLogEntry(
                                    Fdo,
                                    sizeof(IO_ERROR_LOG_PACKET));

            if(errorLogEntry != NULL) {
                errorLogEntry->ErrorCode = IO_ERR_DRIVER_ERROR;
                errorLogEntry->UniqueErrorValue = uniqueId;
                errorLogEntry->FinalStatus = status;
                errorLogEntry->DumpDataSize = 0;
                IoWriteErrorLogEntry(errorLogEntry);
            }

            //
            // Clean up the last device object which is not used.
            //

            SpDestroyAdapter(adapter, FALSE);

            if (configurationContext.AccessRanges != NULL) {
                ExFreePool(configurationContext.AccessRanges);
            }

            if (configurationContext.Parameter != NULL) {
                ExFreePool(configurationContext.Parameter);
            }

        } else {

            //
            // Determine which adapter control functions this miniport will
            // support for the adapter.
            //

            SpGetSupportedAdapterControlFunctions(adapter);
        }
    }

    return status;
}


PHW_INITIALIZATION_DATA
SpFindInitData(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    )

/*++

Routine Description:

    This routine will search the list of chained init structures looking for
    the first one that matches the interface type in the resource list.

Arguments:

    DriverExtension - The driver extension to be searched

    ResourceList - this resource list describes the (interface) type of the
                   adapter we are looking for

Return Value:

    a pointer to the HW_INITIALIZATION_DATA structure for this interface type

    NULL if none was found

--*/

{
    PSP_INIT_CHAIN_ENTRY chainEntry = DriverExtension->InitChain;

    PAGED_CODE();

    while(chainEntry != NULL) {

        if(chainEntry->InitData.AdapterInterfaceType == InterfaceType) {
            return &(chainEntry->InitData);
        }
        chainEntry = chainEntry->NextEntry;
    }

    return NULL;
}


NTSTATUS
SpStartLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine will forward the start request to the next lower device and
    block until it's completion.

Arguments:

    DeviceObject - the device to which the start request was issued.

    Irp - the start request

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PKEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    event = SpAllocatePool(NonPagedPool,
                           sizeof(KEVENT),
                           SCSIPORT_TAG_EVENT,
                           DeviceObject->DriverObject);

    if(event == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           SpSignalCompletion,
                           event,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

    if(status == STATUS_PENDING) {

        KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

        status = Irp->IoStatus.Status;
    }

    if(NT_SUCCESS(status)) {

        PIO_STACK_LOCATION irpStack;

        //
        // Now go and retrieve any interfaces we need from the lower device.
        //

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        irpStack = IoGetNextIrpStackLocation(Irp);

        irpStack->Parameters.QueryInterface.InterfaceType =
            (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
        irpStack->Parameters.QueryInterface.Size =
            sizeof(BUS_INTERFACE_STANDARD);
        irpStack->Parameters.QueryInterface.Version = 1;
        irpStack->Parameters.QueryInterface.Interface =
            (PINTERFACE) &(adapter->LowerBusInterfaceStandard);

        irpStack->MajorFunction = IRP_MJ_PNP;
        irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

        KeResetEvent(event);

        IoSetCompletionRoutine(Irp,
                               SpSignalCompletion,
                               event,
                               TRUE,
                               TRUE,
                               TRUE);

        IoCallDriver(commonExtension->LowerDeviceObject, Irp);

        KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

        if(NT_SUCCESS(Irp->IoStatus.Status)) {
            adapter->LowerBusInterfaceStandardRetrieved = TRUE;
        } else {
            DebugPrint((1, "LowerBusInterfaceStandard request returned "
                           "%#08lx\n", Irp->IoStatus.Status));
            adapter->LowerBusInterfaceStandardRetrieved = FALSE;
        }

        Irp->IoStatus.Status = status;
    }

    ExFreePool(event);

    return status;
}


VOID
SpGetSlotNumber(
    IN PDEVICE_OBJECT Fdo,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine will open the registry key for the associated Pdo and try
    to retrieve the bus, slot and function numbers that will be stored there
    if this was a device we detected or one that the user has configured by
    hand.  These values will be stored in the ConfigInfo structure for the
    adapter.

    If this information does not exist then the values will be filled with
    zeros and the IsVirtualSlot flag will be set in the Fdo for use by other
    routines.

Arguments:

    Fdo - a pointer to the functional device object for this adapter

    ConfigInfo - the ConfigInfo structure to be changed

Return Value:

    None

--*/

{
    PADAPTER_EXTENSION adapter = Fdo->DeviceExtension;

    HANDLE instanceHandle = NULL;
    HANDLE parametersHandle = NULL;

    NTSTATUS status;

    PAGED_CODE();

    adapter->IsInVirtualSlot = FALSE;

    try {
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING unicodeKeyName;


        status = IoOpenDeviceRegistryKey(adapter->LowerPdo,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_READ,
                                         &instanceHandle);

        if(!NT_SUCCESS(status)) {
            leave;
        }

        RtlInitUnicodeString(&unicodeKeyName, L"Scsiport");
        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeKeyName,
            OBJ_CASE_INSENSITIVE,
            instanceHandle,
            NULL);

        status = ZwOpenKey(&parametersHandle,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {

            leave;

        } else {

            RTL_QUERY_REGISTRY_TABLE queryTable[3];
            ULONG busNumber;
            ULONG slotNumber;
            ULONG negativeOne = 0xffffffff;

            RtlZeroMemory(queryTable, sizeof(queryTable));

            queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
            queryTable[0].Name = L"SlotNumber";
            queryTable[0].EntryContext = &slotNumber;
            queryTable[0].DefaultType = REG_DWORD;
            queryTable[0].DefaultData = &negativeOne;
            queryTable[0].DefaultLength = sizeof(ULONG);

            queryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
            queryTable[1].Name = L"BusNumber";
            queryTable[1].EntryContext = &busNumber;
            queryTable[1].DefaultType = REG_DWORD;
            queryTable[1].DefaultData = &negativeOne;
            queryTable[1].DefaultLength = sizeof(ULONG);

            status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                            (PWSTR) parametersHandle,
                                            queryTable,
                                            NULL,
                                            NULL);

            if(!NT_SUCCESS(status)) {
                leave;
            }

            if((busNumber == negativeOne) || (slotNumber == negativeOne)) {

                ConfigInfo->SystemIoBusNumber = ResourceList->List[0].BusNumber;
                ConfigInfo->SlotNumber = 0;
                adapter->IsInVirtualSlot = TRUE;

            } else {

                ConfigInfo->SystemIoBusNumber = busNumber;
                ConfigInfo->SlotNumber = slotNumber;
                adapter->IsInVirtualSlot = FALSE;
            }

        }

   } finally {

       //
       // If an error occurred then we'll need to try virtualizing this
       // adapter
       //

       if(!NT_SUCCESS(status)) {

           //
           // Send ourself a query capabilities IRP so that we can retrieve
           // slot and function numbers from PCI.
           //

           status = SpQueryCapabilities(adapter);

           if(NT_SUCCESS(status)) {
               ConfigInfo->SystemIoBusNumber = ResourceList->List[0].BusNumber;
               ConfigInfo->SlotNumber = adapter->VirtualSlotNumber.u.AsULONG;
               adapter->IsInVirtualSlot = TRUE;
           }
       }

       if(instanceHandle != NULL) {
           ZwClose(instanceHandle);
       }

       if(parametersHandle != NULL) {
           ZwClose(parametersHandle);
       }
   }

   return;
}

PSCSIPORT_DEVICE_TYPE
SpGetDeviceTypeInfo(
    IN UCHAR DeviceType
    )
{
    PAGED_CODE();

    if(DeviceType >= NUM_DEVICE_TYPE_INFO_ENTRIES) {
        return &(DeviceTypeInfo[NUM_DEVICE_TYPE_INFO_ENTRIES - 1]);
    } else {
        return &(DeviceTypeInfo[DeviceType]);
    }
};


PWCHAR
ScsiPortAddGenericControllerId(
    IN PDRIVER_OBJECT DriverObject,
    IN PWCHAR IdList
    )

/*++

Routine Description:

    This routine will attempt to add the id GEN_SCSIADAPTER to the provided
    list of compatible id's.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    ULONG stringLength = 0;

    ULONG i = 0;

    PWCHAR addedString = L"GEN_SCSIADAPTER";
    PWCHAR newList;
    PWCHAR p;

    PAGED_CODE();

    //
    // If strings were provided then count them to determine a length for the
    // new id list.
    //

    if(IdList != NULL) {

        i = 0;

        while((IdList[i] != UNICODE_NULL) || (IdList[i+1] != UNICODE_NULL)) {
            i++;
        }

        //
        // Compensate for the fact that we stopped counting just before the
        // first byte of the double-null.
        //

        i += 2;

        stringLength = i;
    }

    stringLength += wcslen(L"GEN_SCSIADAPTER");

    //
    // We'll need to add in yet another NULL to terminate the current ending
    // string.
    //

    stringLength += 2;

    //
    // Allocate a new string list to replace the existing one with.
    //

    newList = SpAllocatePool(PagedPool,
                             (stringLength * sizeof(WCHAR)),
                             SCSIPORT_TAG_PNP_ID,
                             DriverObject);

    if(newList == NULL) {
        return NULL;
    }

    RtlFillMemory(newList, (stringLength * sizeof(WCHAR)), '@');

    //
    // If we were provided with a string then copy it into the buffer we just
    // allocated.
    //

    if(ARGUMENT_PRESENT(IdList)) {

        i = 0;
        while((IdList[i] != UNICODE_NULL) || (IdList[i+1] != UNICODE_NULL)) {
            newList[i] = IdList[i];
            i++;
        }

        //
        // Terminate the string we just wrote.
        //

        newList[i] = UNICODE_NULL;

        p = &(newList[i+1]);
    } else {
        p = newList;
    }

    //
    // Copy the new id string into the buffer.
    //

    for(i = 0; addedString[i] != UNICODE_NULL; i++) {
        *p = addedString[i];
        p++;
    }

    //
    // Write two unicode nulls to the string to terminate it.
    //

    *p = UNICODE_NULL;
    p++;
    *p = UNICODE_NULL;

    //
    // Set up the first id string
    //

    return newList;
}


NTSTATUS
SpQueryCapabilities(
    IN PADAPTER_EXTENSION Adapter
    )
{
    DEVICE_CAPABILITIES capabilities;

    PIRP irp;
    PIO_STACK_LOCATION irpStack;

    KEVENT event;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the capabilities structure.
    //

    RtlZeroMemory(&capabilities, sizeof(DEVICE_CAPABILITIES));
    capabilities.Size = sizeof(DEVICE_CAPABILITIES);
    capabilities.Version = 1;
    capabilities.Address = capabilities.UINumber = (ULONG)-1;

    //
    // Initialize the event we're going to wait on.
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Allocate a new irp.
    //

    irp = SpAllocateIrp((CCHAR) (Adapter->DeviceObject->StackSize + 1), 
                        FALSE, 
                        Adapter->DeviceObject->DriverObject);

    if(irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_PNP;
    irpStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpStack->Parameters.DeviceCapabilities.Capabilities = &capabilities;

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IoSetCompletionRoutine(irp,
                           SpSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Send the irp to ourself ... just in case we ever start modifying
    // the contents of the capabilities in our PNP dispatch routine.
    //

    IoCallDriver(Adapter->DeviceObject, irp);

    KeWaitForSingleObject(&event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    status = irp->IoStatus.Status;

    if(NT_SUCCESS(status)) {
        USHORT device;
        USHORT function;

        device = (USHORT) (capabilities.Address >> 0x10);
        function = (USHORT) (capabilities.Address & 0x0000ffff);

        Adapter->VirtualSlotNumber.u.bits.DeviceNumber = device;
        Adapter->VirtualSlotNumber.u.bits.FunctionNumber = function;
    } else {
        Adapter->VirtualSlotNumber.u.AsULONG = 0;
    }

    IoFreeIrp(irp);

    return status;
}


BOOLEAN
SpGetInterrupt(
    IN PCM_RESOURCE_LIST FullResourceList,
    OUT ULONG *Irql,
    OUT ULONG *Vector,
    OUT KAFFINITY *Affinity
    )

/*++

Routine Description:

    Given a full resource list returns the interrupt.

Arguments:

    FullResourceList - the resource list.
    Irql - returns the irql for the interrupt.
    Vector - returns the vector for the interrupt.
    Affinity - returns the affinity for the interrupt.

Return Value:

    TRUE if an interrupt is found.
    FALSE if none was found (in which case the output parameters are not valid.

--*/

{
    ULONG             rangeNumber;
    ULONG             index;

    PCM_FULL_RESOURCE_DESCRIPTOR resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialData;

    PAGED_CODE();

    rangeNumber = 0;

    resourceList = FullResourceList->List;

    for (index = 0; index < resourceList->PartialResourceList.Count; index++) {
        partialData = &resourceList->PartialResourceList.PartialDescriptors[index];

        if(partialData->Type == CmResourceTypeInterrupt) {
            *Irql = partialData->u.Interrupt.Level;
            *Vector = partialData->u.Interrupt.Vector;
            *Affinity = partialData->u.Interrupt.Affinity;

            return TRUE;
        }
    }
    return FALSE;
}



VOID
SpQueryDeviceRelationsCompletion(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Unused
    )
{
    PIRP irp = (PIRP) Request->Context;
    PDEVICE_RELATIONS deviceRelations;

    PDEVICE_OBJECT lowerDevice = Adapter->CommonExtension.LowerDeviceObject;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT_FDO(Adapter->DeviceObject);

    //
    // Pnp is done in a system thread - we shouldn't get a user-mode APC to this
    // thread.
    //

    ASSERT(Unused != STATUS_USER_APC);

    //
    // Return the list of devices on the bus
    //

    status = SpExtractDeviceRelations(Adapter, BusRelations, &deviceRelations);

    if(NT_SUCCESS(status)) {
        ULONG i;

        DebugPrint((2, "SpQueryDeviceRelationsCompletion: Found %d devices "
                       "on adapter %#p\n",
                       deviceRelations->Count,
                       Adapter));

        for(i = 0; i < deviceRelations->Count; i++) {
            DebugPrint((2, "/t#%2d: device %#p\n",
                           i,
                           deviceRelations->Objects[i]));
        }
    }

    //
    // Put the pointer to the enumeration request object back.
    //

    Request = InterlockedCompareExchangePointer(
                  &Adapter->PnpEnumRequestPtr,
                  &(Adapter->PnpEnumerationRequest),
                  NULL);
    ASSERT(Request == NULL);


    //
    // Store the status and the return information in the IRP.
    //

    irp->IoStatus.Status = status;

    if(NT_SUCCESS(status)) {
        irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
    } else {
        irp->IoStatus.Information = (ULONG_PTR) NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\remove.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    pdo.c

Abstract:

    This module contains the dispatch routines for scsiport's physical device
    objects

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

VOID
SpAdapterCleanup(
    IN PADAPTER_EXTENSION DeviceExtension
    );

VOID
SpReapChildren(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpTerminateAdapterSynchronized (
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpRemoveAdapterSynchronized(
    IN PADAPTER_EXTENSION Adapter
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpDeleteLogicalUnit)
#pragma alloc_text(PAGE, SpRemoveLogicalUnit)
#pragma alloc_text(PAGE, SpWaitForRemoveLock)
#pragma alloc_text(PAGE, SpAdapterCleanup)
#pragma alloc_text(PAGE, SpReapChildren)

#pragma alloc_text(PAGELOCK, ScsiPortRemoveAdapter)
#endif


BOOLEAN
SpRemoveLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN UCHAR RemoveType
    )

{
    PADAPTER_EXTENSION adapterExtension = LogicalUnit->AdapterExtension;

    ULONG isRemoved;
    ULONG oldDebugLevel;

    PAGED_CODE();

    if(LogicalUnit->CommonExtension.IsRemoved != REMOVE_COMPLETE) {

        if(RemoveType == IRP_MN_REMOVE_DEVICE) {

            SpWaitForRemoveLock(LogicalUnit->DeviceObject, SP_BASE_REMOVE_LOCK );

            //
            // If the device was claimed we should release it now.
            //

            if(LogicalUnit->IsClaimed) {
                LogicalUnit->IsClaimed = FALSE;
                LogicalUnit->IsLegacyClaim = FALSE;
            }

        }

        DebugPrint((1, "SpRemoveLogicalUnit - %sremoving device %#p\n",
                    (RemoveType == IRP_MN_SURPRISE_REMOVAL) ? "surprise " : "",
                    LogicalUnit));

        //
        // If the lun isn't marked as missing yet or is marked as missing but
        // PNP hasn't been informed yet then we cannot delete it.  Set it back
        // to the NO_REMOVE state so that we'll be able to attempt a rescan.
        //
        // Likewise if the lun is invisible then just swallow the remove
        // operation now that we've cleared any existing claims.
        //

        if(RemoveType == IRP_MN_REMOVE_DEVICE) {

            //
            // If the device is not missing or is missing but is still
            // enumerated then don't finish destroying it.
            //

            if((LogicalUnit->IsMissing == TRUE) &&
               (LogicalUnit->IsEnumerated == FALSE)) {

                // do nothing here - fall through and destroy the device.

            } else {

                DebugPrint((1, "SpRemoveLogicalUnit - device is not missing "
                               "and will not be destroyed\n"));

                SpAcquireRemoveLock(LogicalUnit->DeviceObject, SP_BASE_REMOVE_LOCK);

                LogicalUnit->CommonExtension.IsRemoved = NO_REMOVE;

                return FALSE;
            }

        } else if((LogicalUnit->IsVisible == FALSE) &&
                  (LogicalUnit->IsMissing == FALSE)) {

            //
            // The surprise remove came because the device is no longer
            // visible.  We don't want to destroy it.
            //

            return FALSE;
        }

        //
        // Mark the device as uninitialized so that we'll go back and
        // recreate all the necessary stuff if it gets restarted.
        //

        LogicalUnit->CommonExtension.IsInitialized = FALSE;

        //
        // Delete the device map entry for this one (if any).
        //

        SpDeleteDeviceMapEntry(&(LogicalUnit->CommonExtension));

        if(RemoveType == IRP_MN_REMOVE_DEVICE) {

            ASSERT(LogicalUnit->RequestTimeoutCounter == -1);
            ASSERT(LogicalUnit->ReadyLogicalUnit == NULL);
            ASSERT(LogicalUnit->PendingRequest == NULL);
            ASSERT(LogicalUnit->BusyRequest == NULL);
            ASSERT(LogicalUnit->QueueCount == 0);

            LogicalUnit->CommonExtension.IsRemoved = REMOVE_COMPLETE;

            //
            // Yank this out of the logical unit list.
            //

            SpRemoveLogicalUnitFromBin(LogicalUnit->AdapterExtension,
                                       LogicalUnit);

            LogicalUnit->PathId = 0xff;
            LogicalUnit->TargetId = 0xff;
            LogicalUnit->Lun = 0xff;

            //
            // If this device wasn't temporary then delete it.
            //

            if(LogicalUnit->IsTemporary == FALSE) {
                SpDeleteLogicalUnit(LogicalUnit);
            }
        }
    }

    return TRUE;
}


VOID
SpDeleteLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will release any resources held for the logical unit, mark the
    device extension as deleted, and call the io system to actually delete
    the object.  The device object will be deleted once it's reference count
    drops to zero.

Arguments:

    LogicalUnit - the device object for the logical unit to be deleted.

Return Value:

    none

--*/

{
    PAGED_CODE();

    ASSERT(LogicalUnit->ReadyLogicalUnit == NULL);
    ASSERT(LogicalUnit->PendingRequest == NULL);
    ASSERT(LogicalUnit->BusyRequest == NULL);
    ASSERT(LogicalUnit->QueueCount == 0);

    ASSERT(LogicalUnit->PathId == 0xff);
    ASSERT(LogicalUnit->TargetId == 0xff);
    ASSERT(LogicalUnit->Lun == 0xff);

    //
    // Unregister with WMI.
    //

    if(LogicalUnit->CommonExtension.WmiInitialized == TRUE) {

        //
        // Destroy all our WMI resources and unregister with WMI.
        //

        IoWMIRegistrationControl(LogicalUnit->DeviceObject,
                                 WMIREG_ACTION_DEREGISTER);

        // 
        // We should be asking the WmiFreeRequestList of remove some
        // free cells.

        LogicalUnit->CommonExtension.WmiInitialized = FALSE;
        SpWmiDestroySpRegInfo(LogicalUnit->DeviceObject);
    }

#if DBG
    // ASSERT(LogicalUnit->CommonExtension.RemoveTrackingList == NULL);
    ExDeleteNPagedLookasideList(
        &(LogicalUnit->CommonExtension.RemoveTrackingLookasideList));
#endif

    //
    // If the request sense irp still exists, delete it.
    //

    if(LogicalUnit->RequestSenseIrp != NULL) {
        IoFreeIrp(LogicalUnit->RequestSenseIrp);
        LogicalUnit->RequestSenseIrp = NULL;
    }

    if(LogicalUnit->HwLogicalUnitExtension != NULL) {
        ExFreePool(LogicalUnit->HwLogicalUnitExtension);
        LogicalUnit->HwLogicalUnitExtension = NULL;
    }

    if(LogicalUnit->SerialNumber.Buffer != NULL) {
        ExFreePool(LogicalUnit->SerialNumber.Buffer);
        RtlInitAnsiString(&(LogicalUnit->SerialNumber), NULL);
    }

    if(LogicalUnit->DeviceIdentifierPage != NULL) {
        ExFreePool(LogicalUnit->DeviceIdentifierPage);
        LogicalUnit->DeviceIdentifierPage = NULL;
    }

    //
    // If this lun is temporary then clear the RescanLun field in the adapter.
    //

    if(LogicalUnit->IsTemporary) {
        ASSERT(LogicalUnit->AdapterExtension->RescanLun = LogicalUnit);
        LogicalUnit->AdapterExtension->RescanLun = NULL;
    } else {
        ASSERT(LogicalUnit->AdapterExtension->RescanLun != LogicalUnit);
    }

    IoDeleteDevice(LogicalUnit->DeviceObject);

    return;
}


VOID
ScsiPortRemoveAdapter(
    IN PDEVICE_OBJECT AdapterObject,
    IN BOOLEAN Surprise
    )
{
    PADAPTER_EXTENSION adapter = AdapterObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = AdapterObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_FDO(AdapterObject);
    ASSERT(adapter->IsPnp);

    //
    // Set the flag PD_ADAPTER_REMOVED to keep scsiport from calling into the
    // miniport after we've started this teardown.
    //

    if(Surprise == FALSE) {
        PVOID sectionHandle;
        KIRQL oldIrql;

        //
        // Wait until all outstanding requests have been completed.  If the
        // adapter was surprise removed, we don't need to wait on the remove
        // lock again, since we already waited for it in the surprise remove
        // path.
        //

        if (commonExtension->CurrentPnpState != IRP_MN_SURPRISE_REMOVAL) {
            SpWaitForRemoveLock(AdapterObject, AdapterObject);
        }

        //
        // If the device is started we should uninitialize the miniport and
        // release it's resources.  Fortunately this is exactly what stop does.
        //

        if((commonExtension->CurrentPnpState != IRP_MN_SURPRISE_REMOVAL) &&
           ((commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) ||
            (commonExtension->PreviousPnpState == IRP_MN_START_DEVICE))) {

            //
            // Okay.  If this adapter can't support remove then we're dead
            //

            ASSERT(SpIsAdapterControlTypeSupported(adapter, ScsiStopAdapter) == TRUE);

            //
            // Stop the miniport now that it's safe.
            //

            SpEnableDisableAdapter(adapter, FALSE);

            //
            // Mark the adapter as removed.
            //

    #ifdef ALLOC_PRAGMA
            sectionHandle = MmLockPagableCodeSection(ScsiPortRemoveAdapter);
            InterlockedIncrement(&SpPAGELOCKLockCount);
    #endif
            KeAcquireSpinLock(&(adapter->SpinLock), &oldIrql);
            adapter->SynchronizeExecution(adapter->InterruptObject,
                                          SpRemoveAdapterSynchronized,
                                          adapter);

            KeReleaseSpinLock(&(adapter->SpinLock), oldIrql);

    #ifdef ALLOC_PRAGMA
            InterlockedDecrement(&SpPAGELOCKLockCount);
            MmUnlockPagableImageSection(sectionHandle);
    #endif

        }
        SpReapChildren(adapter);
    }

    if(commonExtension->WmiInitialized == TRUE) {

        //
        // Destroy all our WMI resources and unregister with WMI.
        //

        IoWMIRegistrationControl(AdapterObject, WMIREG_ACTION_DEREGISTER);
        SpWmiRemoveFreeMiniPortRequestItems(adapter);
        commonExtension->WmiInitialized = FALSE;
        commonExtension->WmiMiniPortInitialized = FALSE;
    }

    //
    // If we were surprise removed then this has already been done once.
    // In that case don't try to run the cleanup code a second time even though
    // it's safe to do so.
    //

    SpDeleteDeviceMapEntry(commonExtension);
    SpDestroyAdapter(adapter, Surprise);

    return;
}


VOID
SpWaitForRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID LockTag
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Mark the thing as removing
    //

    commonExtension->IsRemoved = REMOVE_PENDING;

    //
    // Release our outstanding lock.
    //

    SpReleaseRemoveLock(DeviceObject, LockTag);

    DebugPrint((4, "SpWaitForRemoveLock - Reference count is now %d\n",
                commonExtension->RemoveLock));

    KeWaitForSingleObject(&(commonExtension->RemoveEvent),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    DebugPrint((4, "SpWaitForRemoveLock - removing device %#p\n",
                DeviceObject));

    return;
}


VOID
SpDestroyAdapter(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Surprise
    )
{
    SpReleaseAdapterResources(Adapter, Surprise);
    SpAdapterCleanup(Adapter);
    return;
}


VOID
SpAdapterCleanup(
    IN PADAPTER_EXTENSION Adapter
    )

/*++

Routine Description:

    This routine cleans up the names associated with the specified adapter
    and the i/o system counts.

Arguments:

    Adapter - Supplies a pointer to the device extension to be deleted.

Return Value:

    None.

--*/

{
    PCOMMON_EXTENSION commonExtension = &(Adapter->CommonExtension);

    PAGED_CODE();

    //
    // If we assigned a port number to this adapter then attempt to delete the
    // symbolic links we created to it.
    //

    if(Adapter->PortNumber != -1) {

        PWCHAR wideNameStrings[] = {L"\\Device\\ScsiPort%d",
                                    L"\\DosDevices\\Scsi%d:"};
        ULONG i;

        for(i = 0; i < (sizeof(wideNameStrings) / sizeof(PWCHAR)); i++) {
            WCHAR wideLinkName[64];
            UNICODE_STRING unicodeLinkName;

            swprintf(wideLinkName, wideNameStrings[i], Adapter->PortNumber);
            RtlInitUnicodeString(&unicodeLinkName, wideLinkName);
            IoDeleteSymbolicLink(&unicodeLinkName);
        }

        Adapter->PortNumber = -1;

        //
        // Decrement the scsiport count.
        //

        IoGetConfigurationInformation()->ScsiPortCount--;
    }

    return;
}


VOID
SpReleaseAdapterResources(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Surprise
    )

/*++

Routine Description:

    This function deletes all of the storage associated with a device
    extension, disconnects from the timers and interrupts and then deletes the
    object.   This function can be called at any time during the initialization.

Arguments:

    Adapter - Supplies a pointer to the device extesnion to be deleted.

Return Value:

    None.

--*/

{

    PCOMMON_EXTENSION commonExtension = &(Adapter->CommonExtension);
    ULONG j;
    PVOID tempPointer;

    PAGED_CODE();

#if DBG

    if(!Surprise) {

        //
        // Free the Remove tracking lookaside list.
        //

        ExDeleteNPagedLookasideList(&(commonExtension->RemoveTrackingLookasideList));
    }
#endif

    //
    // Stop the time and disconnect the interrupt if they have been
    // initialized.  The interrupt object is connected after
    // timer has been initialized, and the interrupt object is connected, but
    // before the timer is started.
    //

    if(Adapter->DeviceObject->Timer != NULL) {
        IoStopTimer(Adapter->DeviceObject);
        KeCancelTimer(&(Adapter->MiniPortTimer));
    }

    if(Adapter->SynchronizeExecution != SpSynchronizeExecution) {

        if (Adapter->InterruptObject) {
            IoDisconnectInterrupt(Adapter->InterruptObject);
        }

        if (Adapter->InterruptObject2) {
            IoDisconnectInterrupt(Adapter->InterruptObject2);
            Adapter->InterruptObject2 = NULL;
        }

        //
        // SpSynchronizeExecution expects to get a pointer to the
        // adapter extension as the "interrupt" parameter.
        //

        Adapter->InterruptObject = (PVOID) Adapter;
        Adapter->SynchronizeExecution = SpSynchronizeExecution;
    }

    //
    // Delete the miniport's device extension
    //

    if (Adapter->HwDeviceExtension != NULL) {

        PHW_DEVICE_EXTENSION devExt =
            CONTAINING_RECORD(Adapter->HwDeviceExtension,
                              HW_DEVICE_EXTENSION,
                              HwDeviceExtension);

        ExFreePool(devExt);
        Adapter->HwDeviceExtension = NULL;
    }

    //
    // Free the configuration information structure.
    //

    if (Adapter->PortConfig) {
        ExFreePool(Adapter->PortConfig);
        Adapter->PortConfig = NULL;
    }

    //
    // Deallocate SCSIPORT WMI REGINFO information, if any.
    //

    SpWmiDestroySpRegInfo(Adapter->DeviceObject);

    //
    // Free the common buffer.
    //

    if (SpVerifyingCommonBuffer(Adapter)) {

        SpFreeCommonBufferVrfy(Adapter);

    } else {

        if (Adapter->SrbExtensionBuffer != NULL &&
            Adapter->CommonBufferSize != 0) {

            if (Adapter->DmaAdapterObject == NULL) {

                //
                // Since there is no adapter just free the non-paged pool.
                //

                ExFreePool(Adapter->SrbExtensionBuffer);

            } else {

                if(Adapter->UncachedExtensionIsCommonBuffer == FALSE) {
                    MmFreeContiguousMemorySpecifyCache(Adapter->SrbExtensionBuffer,
                                                       Adapter->CommonBufferSize,
                                                       MmCached);
                } else {

                    FreeCommonBuffer(
                        Adapter->DmaAdapterObject,
                        Adapter->CommonBufferSize,
                        Adapter->PhysicalCommonBuffer,
                        Adapter->SrbExtensionBuffer,
                        FALSE);
                }

            }
            Adapter->SrbExtensionBuffer = NULL;
        }
    }

    //
    // Get rid of our dma adapter.
    //

    if(Adapter->DmaAdapterObject != NULL) {
        PutDmaAdapter(Adapter->DmaAdapterObject);
        Adapter->DmaAdapterObject = NULL;
    }

    //
    // Free the SRB data array.
    //

    if (Adapter->SrbDataListInitialized) {

        if(Adapter->EmergencySrbData != NULL) {

            ExFreeToNPagedLookasideList(
                &Adapter->SrbDataLookasideList,
                Adapter->EmergencySrbData);
            Adapter->EmergencySrbData = NULL;
        }

        ExDeleteNPagedLookasideList(&Adapter->SrbDataLookasideList);

        Adapter->SrbDataListInitialized = FALSE;
    }

    if (Adapter->InquiryBuffer != NULL) {
        ExFreePool(Adapter->InquiryBuffer);
        Adapter->InquiryBuffer = NULL;
    }

    if (Adapter->InquirySenseBuffer != NULL) {
        ExFreePool(Adapter->InquirySenseBuffer);
        Adapter->InquirySenseBuffer = NULL;
    }

    if (Adapter->InquiryIrp != NULL) {
        IoFreeIrp(Adapter->InquiryIrp);
        Adapter->InquiryIrp = NULL;
    }

    if (Adapter->InquiryMdl != NULL) {
        IoFreeMdl(Adapter->InquiryMdl);
        Adapter->InquiryMdl = NULL;
    }

#ifndef USE_DMA_MACROS
    //
    // Free the Scatter Gather lookaside list.
    //

    if (Adapter->MediumScatterGatherListInitialized) {

        ExDeleteNPagedLookasideList(
            &Adapter->MediumScatterGatherLookasideList);

        Adapter->MediumScatterGatherListInitialized = FALSE;
    }
#endif

    //
    // Unmap any mapped areas.
    //

    SpReleaseMappedAddresses(Adapter);

    //
    // If we've got any resource lists allocated still we should free them
    // now.
    //

    if(Adapter->AllocatedResources != NULL) {
        ExFreePool(Adapter->AllocatedResources);
        Adapter->AllocatedResources = NULL;
    }

    if(Adapter->TranslatedResources != NULL) {
        ExFreePool(Adapter->TranslatedResources);
        Adapter->TranslatedResources = NULL;
    }

    //
    // Cleanup verifier resources.
    //

    if (SpVerifierActive(Adapter)) {
        SpDoVerifierCleanup(Adapter);
    }

#if defined(FORWARD_PROGRESS)
    //
    // Cleanup the adapter's reserved pages.
    //

    if (Adapter->ReservedPages != NULL) {
        MmFreeMappingAddress(Adapter->ReservedPages,
                             SCSIPORT_TAG_MAPPING_LIST);
        Adapter->ReservedPages = NULL;        
    }

    if (Adapter->ReservedMdl != NULL) {   
        IoFreeMdl(Adapter->ReservedMdl);
        Adapter->ReservedMdl = NULL;
    }
#endif

    Adapter->CommonExtension.IsInitialized = FALSE;

    return;
}


VOID
SpReapChildren(
    IN PADAPTER_EXTENSION Adapter
    )
{
    ULONG j;

    PAGED_CODE();

    //
    // Run through the logical unit bins and remove any child devices which
    // remain.
    //

    for(j = 0; j < NUMBER_LOGICAL_UNIT_BINS; j++) {

        while(Adapter->LogicalUnitList[j].List != NULL) {

            PLOGICAL_UNIT_EXTENSION lun =
                Adapter->LogicalUnitList[j].List;

            lun->IsMissing = TRUE;
            lun->IsEnumerated = FALSE;

            SpRemoveLogicalUnit(lun, IRP_MN_REMOVE_DEVICE);
        }
    }
    return;
}


VOID
SpTerminateAdapter(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will terminate the miniport's control of the adapter.  It
    does not cleanly shutdown the miniport and should only be called when
    scsiport is notified that the adapter has been surprise removed.

    This works by synchronizing with the miniport and setting flags to
    disable any new calls into the miniport.  Once this has been done it can
    run through and complete any i/o requests which may still be inside
    the miniport.

Arguments:

    Adapter - the adapter to terminate.

Return Value:

    none

--*/

{
    KIRQL oldIrql;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    KeAcquireSpinLockAtDpcLevel(&(Adapter->SpinLock));

    if(Adapter->CommonExtension.PreviousPnpState == IRP_MN_START_DEVICE) {

        //
        // TA synchronized will stop all calls into the miniport and complete
        // all active requests.
        //

        Adapter->SynchronizeExecution(Adapter->InterruptObject,
                                      SpTerminateAdapterSynchronized,
                                      Adapter);

        Adapter->CommonExtension.PreviousPnpState = 0xff;

        KeReleaseSpinLockFromDpcLevel(&(Adapter->SpinLock));

        //
        // Stop the miniport timer
        //

        KeCancelTimer(&(Adapter->MiniPortTimer));

        //
        // We keep the device object timer running so that any held, busy or
        // otherwise deferred requests will have a chance to get flushed out.
        // We can give the whole process a boost by setting the adapter timeout
        // counter to 1 (it will go to zero in the tick handler) and running
        // the tick handler by hand here.
        //

        // IoStopTimer(Adapter->DeviceObject);
        Adapter->PortTimeoutCounter = 1;

        ScsiPortTickHandler(Adapter->DeviceObject, NULL);

    } else {
        KeReleaseSpinLockFromDpcLevel(&(Adapter->SpinLock));
    }

    KeLowerIrql(oldIrql);

    return;
}


BOOLEAN
SpTerminateAdapterSynchronized(
    IN PADAPTER_EXTENSION Adapter
    )
{
    //
    // Disable the interrupt from coming in.
    //

    SET_FLAG(Adapter->InterruptData.InterruptFlags, PD_ADAPTER_REMOVED);
    CLEAR_FLAG(Adapter->InterruptData.InterruptFlags, PD_RESET_HOLD);

    ScsiPortCompleteRequest(Adapter->HwDeviceExtension,
                            0xff,
                            0xff,
                            0xff,
                            SRB_STATUS_NO_HBA);

    //
    // Run the completion DPC.
    //

    if(TEST_FLAG(Adapter->InterruptData.InterruptFlags,
                 PD_NOTIFICATION_REQUIRED)) {
        SpRequestCompletionDpc(Adapter->DeviceObject);
    }

    return TRUE;
}

BOOLEAN
SpRemoveAdapterSynchronized(
    PADAPTER_EXTENSION Adapter
    )
{
    //
    // Disable the interrupt from coming in.
    //

    SET_FLAG(Adapter->InterruptData.InterruptFlags, PD_ADAPTER_REMOVED);
    CLEAR_FLAG(Adapter->InterruptData.InterruptFlags, PD_RESET_HOLD);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\utils.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    port.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a dll for the kernel.

Revision History:

--*/

#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

#define __FILE_ID__ 'util'

typedef struct SP_GUID_INTERFACE_MAPPING {
    GUID Guid;
    INTERFACE_TYPE InterfaceType;
} SP_GUID_INTERFACE_MAPPING, *PSP_GUID_INTERFACE_MAPPING;

PSP_GUID_INTERFACE_MAPPING SpGuidInterfaceMappingList = NULL;

VOID
SpProcessSpecialControllerList(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    IN HANDLE ListKey,
    OUT PSP_SPECIAL_CONTROLLER_FLAGS Flags
    );

VOID
SpProcessSpecialControllerFlags(
    IN HANDLE FlagsKey,
    OUT PSP_SPECIAL_CONTROLLER_FLAGS Flags
    );


NTSTATUS
ScsiPortBuildMultiString(
    IN PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING MultiString,
    ...
    );

NTSTATUS
SpMultiStringToStringArray(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING MultiString,
    OUT PWSTR *StringArray[],
    BOOLEAN Forward
    );

VOID
FASTCALL
SpFreeSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );

VOID
FASTCALL
SpFreeBypassSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortBuildMultiString)
#pragma alloc_text(PAGE, ScsiPortStringArrayToMultiString)
#pragma alloc_text(PAGE, SpMultiStringToStringArray)
#pragma alloc_text(PAGE, RtlDuplicateCmResourceList)
#pragma alloc_text(PAGE, RtlSizeOfCmResourceList)
#pragma alloc_text(PAGE, SpTranslateResources)
#pragma alloc_text(PAGE, SpCheckSpecialDeviceFlags)
#pragma alloc_text(PAGE, SpProcessSpecialControllerList)
#pragma alloc_text(PAGE, SpProcessSpecialControllerFlags)
#pragma alloc_text(PAGE, SpAllocateTagBitMap)
#pragma alloc_text(PAGE, SpGetPdoInterfaceType)
#pragma alloc_text(PAGE, SpReadNumericInstanceValue)
#pragma alloc_text(PAGE, SpWriteNumericInstanceValue)
#pragma alloc_text(PAGE, SpReleaseMappedAddresses)
#pragma alloc_text(PAGE, SpInitializeGuidInterfaceMapping)
#pragma alloc_text(PAGE, SpSendIrpSynchronous)
#pragma alloc_text(PAGE, SpGetBusTypeGuid)
#pragma alloc_text(PAGE, SpDetermine64BitSupport)
#pragma alloc_text(PAGE, SpReadNumericValue)
#pragma alloc_text(PAGE, SpAllocateAddressMapping)
#pragma alloc_text(PAGE, SpPreallocateAddressMapping)
#pragma alloc_text(PAGE, SpPurgeFreeMappedAddressList)
#pragma alloc_text(PAGE, SpFreeMappedAddress)
#endif


NTSTATUS
SpInitializeGuidInterfaceMapping(
    IN PDRIVER_OBJECT DriverObject
    )
{
    ULONG size;

    PAGED_CODE();

    ASSERT(SpGuidInterfaceMappingList == NULL);

    size = sizeof(SP_GUID_INTERFACE_MAPPING) * 5;

    SpGuidInterfaceMappingList = SpAllocatePool(PagedPool,
                                                size,
                                                SCSIPORT_TAG_INTERFACE_MAPPING,
                                                DriverObject);

    if(SpGuidInterfaceMappingList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(SpGuidInterfaceMappingList, size);

    SpGuidInterfaceMappingList[0].Guid = GUID_BUS_TYPE_PCMCIA;
    SpGuidInterfaceMappingList[0].InterfaceType = Isa;

    SpGuidInterfaceMappingList[1].Guid = GUID_BUS_TYPE_PCI;
    SpGuidInterfaceMappingList[1].InterfaceType = PCIBus;

    SpGuidInterfaceMappingList[2].Guid = GUID_BUS_TYPE_ISAPNP;
    SpGuidInterfaceMappingList[2].InterfaceType = Isa;

    SpGuidInterfaceMappingList[3].Guid = GUID_BUS_TYPE_EISA;
    SpGuidInterfaceMappingList[3].InterfaceType = Eisa;

    SpGuidInterfaceMappingList[4].InterfaceType = InterfaceTypeUndefined;

    return STATUS_SUCCESS;
}


NTSTATUS
ScsiPortBuildMultiString(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING MultiString,
    ...
    )

/*++

Routine Description:

    This routine will take a null terminated list of ascii strings and combine
    them together into a unicode multi-string block.

    This routine allocates memory for the string buffer - is the caller's
    responsibility to free it.

Arguments:

    MultiString - a UNICODE_STRING structure into which the multi string will
                  be built.

    ... - a NULL terminated list of narrow strings which will be combined
          together.  This list may not be empty.

Return Value:

    status

--*/

{
    PCSTR rawEntry;
    ANSI_STRING ansiEntry;

    UNICODE_STRING unicodeEntry;
    PWSTR unicodeLocation;

    ULONG multiLength = 0;

    NTSTATUS status;

    va_list ap;

    va_start(ap, MultiString);

    PAGED_CODE();

    //
    // Make sure we aren't going to leak any memory
    //

    ASSERT(MultiString->Buffer == NULL);

    rawEntry = va_arg(ap, PCSTR);

    while(rawEntry != NULL) {

        RtlInitAnsiString(&ansiEntry, rawEntry);

        multiLength += RtlAnsiStringToUnicodeSize(&ansiEntry);

        rawEntry = va_arg(ap, PCSTR);

    }

    ASSERT(multiLength != 0);

    multiLength += sizeof(WCHAR);

    MultiString->Buffer = SpAllocatePool(PagedPool,
                                         multiLength,
                                         SCSIPORT_TAG_PNP_ID,
                                         DriverObject);

    if(MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    unicodeEntry.Buffer = MultiString->Buffer;
    unicodeEntry.MaximumLength = (USHORT) multiLength;

    va_start(ap, MultiString);

    rawEntry = va_arg(ap, PCSTR);

    while(rawEntry != NULL) {


        RtlInitAnsiString(&ansiEntry, rawEntry);

        status = RtlAnsiStringToUnicodeString(
                    &unicodeEntry,
                    &ansiEntry,
                    FALSE);

        //
        // Since we're not allocating any memory the only failure possible
        // is if this function is bad
        //

        ASSERT(NT_SUCCESS(status));

        //
        // Push the buffer location up and reduce the maximum count
        //

        unicodeEntry.Buffer += unicodeEntry.Length + sizeof(WCHAR);
        unicodeEntry.MaximumLength -= unicodeEntry.Length + sizeof(WCHAR);

        rawEntry = va_arg(ap, PCSTR);

    };

    ASSERT(unicodeEntry.MaximumLength == sizeof(WCHAR));

    //
    // Stick the final NUL on the end of the multisz
    //

    RtlZeroMemory(unicodeEntry.Buffer, unicodeEntry.MaximumLength);

    return STATUS_SUCCESS;

}

NTSTATUS
ScsiPortStringArrayToMultiString(
    IN PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING MultiString,
    PCSTR StringArray[]
    )

/*++

Routine Description:

    This routine will take a null terminated array of ascii strings and merge
    them together into a unicode multi-string block.

    This routine allocates memory for the string buffer - is the caller's
    responsibility to free it.

Arguments:

    MultiString - a UNICODE_STRING structure into which the multi string will
                  be built.

    StringArray - a NULL terminated list of narrow strings which will be combined
                  together.  This list may not be empty.

Return Value:

    status

--*/

{
    ANSI_STRING ansiEntry;

    UNICODE_STRING unicodeEntry;
    PWSTR unicodeLocation;

    UCHAR i;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Make sure we aren't going to leak any memory
    //

    ASSERT(MultiString->Buffer == NULL);

    RtlInitUnicodeString(MultiString, NULL);

    for(i = 0; StringArray[i] != NULL; i++) {

        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        MultiString->Length += (USHORT) RtlAnsiStringToUnicodeSize(&ansiEntry);
    }

    ASSERT(MultiString->Length != 0);

    MultiString->MaximumLength = MultiString->Length + sizeof(UNICODE_NULL);

    MultiString->Buffer = SpAllocatePool(PagedPool,
                                         MultiString->MaximumLength,
                                         SCSIPORT_TAG_PNP_ID,
                                         DriverObject);

    if(MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlZeroMemory(MultiString->Buffer, MultiString->MaximumLength);

    unicodeEntry = *MultiString;

    for(i = 0; StringArray[i] != NULL; i++) {

        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        status = RtlAnsiStringToUnicodeString(
                    &unicodeEntry,
                    &ansiEntry,
                    FALSE);

        //
        // Since we're not allocating any memory the only failure possible
        // is if this function is bad
        //

        ASSERT(NT_SUCCESS(status));

        //
        // Push the buffer location up and reduce the maximum count
        //

        ((PSTR) unicodeEntry.Buffer) += unicodeEntry.Length + sizeof(WCHAR);
        unicodeEntry.MaximumLength -= unicodeEntry.Length + sizeof(WCHAR);

    };

    //
    // Stick the final NUL on the end of the multisz
    //

//    RtlZeroMemory(unicodeEntry.Buffer, unicodeEntry.MaximumLength);

    return STATUS_SUCCESS;
}


NTSTATUS
SpMultiStringToStringArray(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING MultiString,
    OUT PWSTR *StringArray[],
    BOOLEAN Forward
    )

{
    ULONG stringCount = 0;
    ULONG stringNumber;
    ULONG i;
    PWSTR *stringArray;

    PAGED_CODE();

    //
    // Pass one: count the number of string elements.
    //

    for(i = 0; i < (MultiString->MaximumLength / sizeof(WCHAR)); i++) {
        if(MultiString->Buffer[i] == UNICODE_NULL) {
            stringCount++;
        }
    }

    //
    // Allocate the memory for a NULL-terminated string array.
    //

    stringArray = SpAllocatePool(PagedPool,
                                 (stringCount + 1) * sizeof(PWSTR),
                                 SCSIPORT_TAG_PNP_ID,
                                 DriverObject);

    if(stringArray == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(stringArray, (stringCount + 1) * sizeof(PWSTR));

    //
    // Pass two : Put the string pointers in place.
    //

    i = 0;

    for(stringNumber = 0; stringNumber < stringCount; stringNumber++) {

        ULONG arrayNumber;

        if(Forward) {
            arrayNumber = stringNumber;
        } else {
            arrayNumber = stringCount - stringNumber - 1;
        }

        //
        // Put a pointer to the head of the string into the array.
        //

        stringArray[arrayNumber] = &MultiString->Buffer[i];

        //
        // Scan for the end of the string.
        //

        while((i < (MultiString->MaximumLength / sizeof(WCHAR))) &&
              (MultiString->Buffer[i] != UNICODE_NULL)) {
            i++;
        }

        //
        // Jump past the NULL.
        //

        i++;
    }

    *StringArray = stringArray;
    return STATUS_SUCCESS;
}

PCM_RESOURCE_LIST
RtlDuplicateCmResourceList(
    IN PDRIVER_OBJECT DriverObject,
    POOL_TYPE PoolType,
    PCM_RESOURCE_LIST ResourceList,
    ULONG Tag
    )

/*++

Routine Description:

    This routine will attempt to allocate memory to copy the supplied
    resource list.  If sufficient memory cannot be allocated then the routine
    will return NULL.

Arguments:

    PoolType - the type of pool to allocate the duplicate from

    ResourceList - the resource list to be copied

    Tag - a value to tag the memory allocation with.  If 0 then untagged
          memory will be allocated.

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/

{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    PVOID buffer;

    PAGED_CODE();

    size = RtlSizeOfCmResourceList(ResourceList);

    buffer = SpAllocatePool(PoolType, 
                            size, 
                            Tag,
                            DriverObject);

    if (buffer != NULL) {
        RtlCopyMemory(buffer,
                      ResourceList,
                      size);
    }

    return buffer;
}

ULONG
RtlSizeOfCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine returns the size of a CM_RESOURCE_LIST.

Arguments:

    ResourceList - the resource list to be copied

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/

{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < ResourceList->Count; i++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor = &(ResourceList->List[i]);
        ULONG j;

        //
        // First descriptor is included in the size of the resource list.
        //

        if(i != 0) {
            size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        }

        for(j = 0; j < fullDescriptor->PartialResourceList.Count; j++) {

            //
            // First descriptor is included in the size of the partial list.
            //

            if(j != 0) {
                size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
            }
        }
    }

    return size;
}

#if !defined(NO_LEGACY_DRIVERS)

BOOLEAN
SpTranslateResources(
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST AllocatedResources,
    OUT PCM_RESOURCE_LIST *TranslatedResources
    )

/*++

Routine Description:

    This routine will call into the Hal to translate any recognizable resources
    in the AllocatedResources list.  This routine allocates the space for the
    translated list - the caller is responsible for freeing this buffer.

    If any errors occur the TranslatedResources will be NULL and the routine
    will return FALSE.

Arguments:

    AllocatedResources - The list of resources to be translated.

    TranslatedResources - A location to store the translated resources.  There
                          will be a one to one mapping between translated and
                          untranslated.  Any non-standard resource types will
                          be blindly copied.

Return Value:

    TRUE if all resources were translated properly.

    FALSE otherwise.

--*/

{
    PCM_RESOURCE_LIST list;

    ULONG listNumber;

    PAGED_CODE();

    (*TranslatedResources) = NULL;

    list = RtlDuplicateCmResourceList(DriverObject,
                                      NonPagedPool,
                                      AllocatedResources,
                                      SCSIPORT_TAG_RESOURCE_LIST);

    if(list == NULL) {
        return FALSE;
    }

    for(listNumber = 0; listNumber < list->Count; listNumber++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor;
        ULONG resourceNumber;

        fullDescriptor = &(list->List[listNumber]);

        for(resourceNumber = 0;
            resourceNumber < fullDescriptor->PartialResourceList.Count;
            resourceNumber++) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
            CM_PARTIAL_RESOURCE_DESCRIPTOR tmp;

            partialDescriptor =
                &(fullDescriptor->PartialResourceList.PartialDescriptors[resourceNumber]);

            switch(partialDescriptor->Type) {

                case CmResourceTypePort:
                case CmResourceTypeMemory: {

                    ULONG addressSpace;

                    if(partialDescriptor->Type == CmResourceTypePort) {
                        addressSpace = 1;
                    } else {
                        addressSpace = 0;
                    }

                    tmp = *partialDescriptor;

                    if(HalTranslateBusAddress(
                            fullDescriptor->InterfaceType,
                            fullDescriptor->BusNumber,
                            partialDescriptor->u.Generic.Start,
                            &addressSpace,
                            &(tmp.u.Generic.Start))) {

                        tmp.Type = (addressSpace == 0) ? CmResourceTypeMemory :
                                                         CmResourceTypePort;

                    } else {

                        ExFreePool(list);
                        return FALSE;
                    }

                    break;
                }

                case CmResourceTypeInterrupt: {

                    tmp = *partialDescriptor;

                    tmp.u.Interrupt.Vector =
                        HalGetInterruptVector(
                            fullDescriptor->InterfaceType,
                            fullDescriptor->BusNumber,
                            partialDescriptor->u.Interrupt.Level,
                            partialDescriptor->u.Interrupt.Vector,
                            &((UCHAR) tmp.u.Interrupt.Level),
                            &(tmp.u.Interrupt.Affinity));

                    if(tmp.u.Interrupt.Affinity == 0) {

                        //
                        // Translation failed.
                        //

                        ExFreePool(list);
                        return FALSE;
                    }

                    break;
                }

            };

            *partialDescriptor = tmp;
        }
    }

    *TranslatedResources = list;
    return TRUE;
}
#endif // NO_LEGACY_DRIVERS


BOOLEAN
SpFindAddressTranslation(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS RangeStart,
    IN ULONG RangeLength,
    IN BOOLEAN InIoSpace,
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Translation
    )

/*++

Routine Description:

    This routine will search the resource lists in the AdapterExtension to
    translate the given memory or i/o range using the resources provided by
    pnp or the Hal.

Arguments:

    AdapterExtesnion - the device extension for the adapter making the request

    RangeStart - the starting address of the memory range

    RangeLength - the number of bytes in the memory range

    InIoSpace - whether the untranslated range is in io or memory space.

Return Value:

    a pointer to a partial resource descriptor describing the proper range to
    be used or NULL if no matching range of sufficient length can be found.

--*/

{
    PCM_RESOURCE_LIST list;

    ULONG listNumber;

    list = AdapterExtension->AllocatedResources;

    ASSERT(!AdapterExtension->IsMiniportDetected);
    ASSERT(AdapterExtension->AllocatedResources);
    ASSERT(AdapterExtension->TranslatedResources);

    for(listNumber = 0; listNumber < list->Count; listNumber++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor;
        ULONG resourceNumber;

        fullDescriptor = &(list->List[listNumber]);

        if((fullDescriptor->InterfaceType != BusType) ||
           (fullDescriptor->BusNumber != BusNumber)) {
            continue;
        }

        for(resourceNumber = 0;
            resourceNumber < fullDescriptor->PartialResourceList.Count;
            resourceNumber++) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

            UCHAR desiredType =
                InIoSpace ? CmResourceTypePort : CmResourceTypeMemory;

            partialDescriptor =
                &(fullDescriptor->PartialResourceList.PartialDescriptors[resourceNumber]);

            if(partialDescriptor->Type == desiredType) {

                ULONGLONG requestedStart = (ULONGLONG) RangeStart.QuadPart;
                ULONGLONG requestedEnd =
                    ((ULONGLONG) RangeStart.QuadPart) + RangeLength;

                ULONGLONG testStart =
                    (ULONGLONG) partialDescriptor->u.Generic.Start.QuadPart;
                ULONGLONG testEnd =
                    testStart + partialDescriptor->u.Generic.Length;

                ULONGLONG requestedOffset = requestedStart - testStart;

                ULONG rangeOffset;

                //
                // Make sure the base address is within the current range.
                //

                if((requestedStart < testStart) ||
                   (requestedStart >= testEnd)) {
                    continue;
                }

                //
                // Make sure the end of the requested range is within this
                // descriptor.
                //

                if(requestedEnd > testEnd) {
                    continue;
                }

                //
                // We seem to have found a match.  Copy the equivalent resource
                // in the translated resource list.
                //

                *Translation =
                    AdapterExtension->TranslatedResources->List[listNumber].
                        PartialResourceList.PartialDescriptors[resourceNumber];

                //
                // Return an offset into the translated range equivalent to the
                // offset in the untranslated range.
                //

                requestedStart = Translation->u.Generic.Start.QuadPart;
                requestedStart += requestedOffset;

                Translation->u.Generic.Start.QuadPart = requestedStart;

                return TRUE;

            };

        }
    }

    return FALSE;
}


NTSTATUS
SpLockUnlockQueue(
    IN PDEVICE_OBJECT LogicalUnit,
    IN BOOLEAN LockQueue,
    IN BOOLEAN BypassLockedQueue
    )

/*++

Routine Description:

    This routine will lock or unlock the logical unit queue.

    This routine is synchronous.

Arguments:

    LogicalUnit - the logical unit to be locked or unlocked

    LockQueue - whether the queue should be locked or unlocked

    BypassLockedQueue - whether the operation should bypass other locks or
                        whether it should sit in the queue.  Must be true for
                        unlock requests.

Return Value:

    STATUS_SUCCESS if the operation was successful

    error status otherwise.

--*/

{
    PLOGICAL_UNIT_EXTENSION luExtension = LogicalUnit->DeviceExtension;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PKEVENT event = NULL;

    NTSTATUS status;

    ASSERTMSG("Must bypass locked queue when unlocking: ",
              (LockQueue || BypassLockedQueue));

    DebugPrint((1, "SpLockUnlockQueue: %sing queue for logical unit extension "
                   "%#p\n",
                LockQueue ? "Lock" : "Unlock",
                luExtension));

    //
    // Build an IRP to send to the logical unit.  We need one stack
    // location for our completion routine and one for the irp to be
    // processed with.  This irp should never be dispatched to the
    //

    irp = SpAllocateIrp((CCHAR) (LogicalUnit->StackSize + 1),
                        FALSE,
                        LogicalUnit->DriverObject);

    if(irp == NULL) {
        DebugPrint((1, "SpLockUnlockQueue: Couldn't allocate IRP\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        srb = SpAllocatePool(NonPagedPool,
                             sizeof(SCSI_REQUEST_BLOCK),
                             SCSIPORT_TAG_ENABLE,
                             LogicalUnit->DriverObject);

        if(srb == NULL) {

            DebugPrint((1, "SpLockUnlockQueue: Couldn't allocate SRB\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        event = SpAllocatePool(NonPagedPool,
                               sizeof(KEVENT),
                               SCSIPORT_TAG_EVENT,
                               LogicalUnit->DriverObject);

        if(event == NULL) {

            DebugPrint((1, "SpLockUnlockQueue: Couldn't allocate Context\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        KeInitializeEvent(event, NotificationEvent, FALSE);

        srb->Length = sizeof(SCSI_REQUEST_BLOCK);

        srb->Function = LockQueue ? SRB_FUNCTION_LOCK_QUEUE :
                                    SRB_FUNCTION_UNLOCK_QUEUE;

        srb->OriginalRequest = irp;
        srb->DataBuffer = NULL;

        srb->QueueTag = SP_UNTAGGED;

        if(BypassLockedQueue) {
            srb->SrbFlags |= SRB_FLAGS_BYPASS_LOCKED_QUEUE;
        }

        IoSetCompletionRoutine(irp,
                               SpSignalCompletion,
                               event,
                               TRUE,
                               TRUE,
                               TRUE);

        irpStack = IoGetNextIrpStackLocation(irp);

        irpStack->Parameters.Scsi.Srb = srb;
        irpStack->MajorFunction = IRP_MJ_SCSI;

        status = IoCallDriver(LogicalUnit, irp);

        if(status == STATUS_PENDING) {

            KeWaitForSingleObject(event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = irp->IoStatus.Status;
        }

    } finally {

        if(irp != NULL) {
            IoFreeIrp(irp);
        }

        if(srb != NULL) {
            ExFreePool(srb);
        }

        if(event != NULL) {
            ExFreePool(event);
        }

    }

    return status;
}


NTSTATUS
SpCheckSpecialDeviceFlags(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PINQUIRYDATA InquiryData
    )

/*++

Routine Description:

    This routine will check the registry to determine what sort of special
    handling a target device requires.  If there is a device-node then the
    routine will check under the device parameters for this particular logical
    unit.

    If there is no device node for the logical unit the hardware id will be
    looked up (first) under the devnode for the adapter or (if not found) the
    bad controller list stored under the scsiport Control key.

    The flags tested for include (this list should be updated as more are
    added):

        * OneLun    - used to keep from enumerating past LUN 0 on a particular
                      device.
        * SparseLun - used to indicate the device may have holes in the LUN
                      numbers.
        * NonStandardVPD - used to indicate that a target does not support VPD 0x00
                           but does support VPD 0x80 and 0x83.
        * BinarySN  - used to indicate that the target supplied a binary
                      serial number and that we need to convert it to ascii.



    These values are REG_DWORD's.  REG_NULL can be used to return a value
    to it's default.

Arguments:

    LogicalUnit - the logical unit

    InquiryData - the inquiry data retreived for the lun

Return Value:

    status

--*/

{
    HANDLE baseKey = NULL;
    HANDLE listKey = NULL;
    HANDLE entryKey = NULL;

    UNICODE_STRING keyName;
    OBJECT_ATTRIBUTES objectAttributes;

    SP_SPECIAL_CONTROLLER_FLAGS flags = {
        0,                                   // SparseLun
        0,                                   // OneLun
        0,                                   // LargeLuns   
        0,                                   // SetLunInCdb
        0,                                   // NonStandardVPD
        0                                    // BinarySN
    };

    NTSTATUS status;

    PAGED_CODE();

    DebugPrint((1, "SpCheckSpecialDeviceFlags - checking flags for %#p\n",
                LogicalUnit));

    //
    // Check the bad controller list in the scsiport control key
    //

    try {

        DebugPrint((2, "SpCheckSpecialDeviceFlags - trying control list\n"));

        RtlInitUnicodeString(&keyName,
                             SCSIPORT_CONTROL_KEY SCSIPORT_SPECIAL_TARGET_KEY);

        InitializeObjectAttributes(&objectAttributes,
                                   &keyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        status = ZwOpenKey(&listKey,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "key %wZ\n",
                        status,
                        &keyName));
            leave;
        }

        SpProcessSpecialControllerList(
            LogicalUnit->DeviceObject->DriverObject,
            InquiryData, 
            listKey, 
            &flags);

    } finally {

        if(listKey != NULL) {
            ZwClose(listKey);
            listKey = NULL;
        }
    }

    //
    // Next check the special list in the adapter's devnode.
    //

    try {

        PDEVICE_OBJECT adapterPdo = LogicalUnit->AdapterExtension->LowerPdo;

        DebugPrint((2, "SpCheckSpecialDeviceFlags - trying adapter list\n"));

        status = IoOpenDeviceRegistryKey(adapterPdo,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_READ,
                                         &baseKey);

        if(!NT_SUCCESS(status)) {

            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "adapter devnode key\n", status));
            leave;
        }

        RtlInitUnicodeString(&keyName,
                             L"ScsiPort\\" SCSIPORT_SPECIAL_TARGET_KEY);

        InitializeObjectAttributes(&objectAttributes,
                                   &keyName,
                                   OBJ_CASE_INSENSITIVE,
                                   baseKey,
                                   NULL);

        status = ZwOpenKey(&listKey,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "adapter devnode key %wZ\n", status, &keyName));
            leave;
        }

        SpProcessSpecialControllerList(
            LogicalUnit->DeviceObject->DriverObject,
            InquiryData, 
            listKey, 
            &flags);

    } finally {

        if(baseKey != NULL) {
            ZwClose(baseKey);
            baseKey = NULL;

            if(listKey != NULL) {
                ZwClose(listKey);
                listKey = NULL;
            }
        }
    }

    //
    // Finally check the devnode (if any) for the logical unit.  This one is
    // special - the hardware id already matchs so the key just contains the
    // values to be used, not a database of values.
    //

    try {

        status = IoOpenDeviceRegistryKey(LogicalUnit->CommonExtension.DeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_READ,
                                         &baseKey);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "device devnode key\n", status));
            leave;
        }

        RtlInitUnicodeString(&keyName,
                             L"ScsiPort\\" SCSIPORT_SPECIAL_TARGET_KEY);

        InitializeObjectAttributes(&objectAttributes,
                                   &keyName,
                                   OBJ_CASE_INSENSITIVE,
                                   baseKey,
                                   NULL);

        status = ZwOpenKey(&listKey,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "device devnode key %wZ\n", status, &keyName));
            leave;
        }

        SpProcessSpecialControllerFlags(listKey, &flags);

    } finally {
        if(baseKey != NULL) {
            ZwClose(baseKey);
            baseKey = NULL;

            if(listKey != NULL) {
                ZwClose(listKey);
                listKey = NULL;
            }
        }
    }

    LogicalUnit->SpecialFlags = flags;

    return STATUS_SUCCESS;
}

VOID
SpProcessSpecialControllerList(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    IN HANDLE ListKey,
    OUT PSP_SPECIAL_CONTROLLER_FLAGS Flags
    )

/*++

Routine Description:

    This routine will match the specified logical unit to a set of special
    controller flags stored in the registry key ListKey.  These flags will
    be written into the Flags structure, overwriting any flags which already
    exist.

    If no logical unit is provided then the ListKey handle is assumed to point
    at the appropriate list entry and the values stored there will be copied
    into the Flags structure.

Arguments:

    InquiryData - The inquiry data for the logical unit.  This is used to
                  match strings in the special target list.

    ListKey - a handle to the special controller list to locate the logical
              unit in, or a handle to a list of flags if the LogicalUnit value
              is not present.

    Flags - a location to store the flags.

Return Value:

    None

--*/

{
    UNICODE_STRING hardwareIds;
    PWSTR *hardwareIdList;

    ULONG idNumber;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(&hardwareIds, NULL);

    status = ScsiPortGetHardwareIds(DriverObject, InquiryData, &hardwareIds);

    if(!NT_SUCCESS(status)) {
        DebugPrint((2, "SpProcessSpecialControllerList: Error %#08lx getting "
                       "hardware id's\n", status));
        return;
    }

    status = SpMultiStringToStringArray(DriverObject,
                                        &hardwareIds,
                                        &hardwareIdList,
                                        FALSE);

    if(!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(&hardwareIds);
        return;
    }

    for(idNumber = 0; hardwareIdList[idNumber] != NULL; idNumber++) {

        PWSTR hardwareId = hardwareIdList[idNumber];
        ULONG j;
        UNICODE_STRING keyName;
        OBJECT_ATTRIBUTES objectAttributes;
        HANDLE flagsKey;

        DebugPrint((2, "SpProcessSpecialControllerList: processing id %ws\n",
                    hardwareId));

        //
        // Remove the leading slash from the name.
        //

        for(j = 0; hardwareId[j] != UNICODE_NULL; j++) {
            if(hardwareId[j] == L'\\') {
                hardwareId = &(hardwareId[j+1]);
                break;
            }
        }

        //
        // Process the hardware id that we just found the end of.
        //

        RtlInitUnicodeString(&keyName, hardwareId);

        DebugPrint((2, "SpProcessSpecialControllerList: Finding match for "
                       "%wZ - id %d\n", &keyName, idNumber));

        InitializeObjectAttributes(&objectAttributes,
                                   &keyName,
                                   OBJ_CASE_INSENSITIVE,
                                   ListKey,
                                   NULL);

        status = ZwOpenKey(&flagsKey,
                           KEY_READ,
                           &objectAttributes);

        if(NT_SUCCESS(status)) {
            SpProcessSpecialControllerFlags(flagsKey, Flags);
            ZwClose(flagsKey);
        } else {
            DebugPrint((2, "SpProcessSpecialControllerList: Error %#08lx "
                           "opening key\n", status));
        }

    }

    ExFreePool(hardwareIdList);
    RtlFreeUnicodeString(&hardwareIds);

    return;
}


VOID
SpProcessSpecialControllerFlags(
    IN HANDLE FlagsKey,
    OUT PSP_SPECIAL_CONTROLLER_FLAGS Flags
    )
{
    RTL_QUERY_REGISTRY_TABLE queryTable[7];
    NTSTATUS status;

    PAGED_CODE();

    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"SparseLUN";
    queryTable[0].EntryContext = &(Flags->SparseLun);

    queryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[1].Name = L"OneLUN";
    queryTable[1].EntryContext = &(Flags->OneLun);

    queryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[2].Name = L"LargeLuns";
    queryTable[2].EntryContext = &(Flags->LargeLuns);

    queryTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[3].Name = L"SetLunInCdb";
    queryTable[3].EntryContext = &(Flags->SetLunInCdb);

    queryTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[4].Name = L"NonStandardVPD";
    queryTable[4].EntryContext = &(Flags->NonStandardVPD);

    queryTable[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[5].Name = L"BinarySN";
    queryTable[5].EntryContext = &(Flags->BinarySN);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    FlagsKey,
                                    queryTable,
                                    NULL,
                                    NULL);

    if(!NT_SUCCESS(status)) {
        DebugPrint((2, "SpProcssSpecialControllerFlags: Error %#08lx reading "
                       "values\n", status));
    } else {
        DebugPrint((2, "SpProcessSpecialControllerFlags: %s%s%s%s%s\n",
                    ((Flags->SparseLun ||
                      Flags->OneLun ||
                      Flags->LargeLuns ||
                      Flags->SetLunInCdb ||
                      Flags->NonStandardVPD ||
                      Flags->BinarySN) ? "" : "none"),
                    (Flags->SparseLun ? "SparseLun " : ""),
                    (Flags->OneLun ? "OneLun " : ""),
                    (Flags->LargeLuns ? "LargeLuns " : ""),
                    (Flags->SetLunInCdb ? "SetLunInCdb" : ""),
                    (Flags->NonStandardVPD ? "NonStandardVPD" : ""),
                    (Flags->BinarySN ? "BinarySN" : "")));
    }

    return;
}


PSRB_DATA
FASTCALL
SpAllocateSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN OPTIONAL PIRP Request
    )

{
    PSRB_DATA srbData;

    srbData = ExAllocateFromNPagedLookasideList(
                &Adapter->SrbDataLookasideList);

#if TEST_LISTS
    if(srbData != NULL) {
        InterlockedIncrement64(&Adapter->SrbDataAllocationCount);
    }
#endif

    if((srbData == NULL) && (Request != NULL)) {

        KIRQL oldIrql;
        PSRB_DATA emergencySrbData;

        //
        // Use the emergency srb data if it's not already in use.
        //

        KeAcquireSpinLock(&Adapter->EmergencySrbDataSpinLock,
                          &oldIrql);

        emergencySrbData =
            (PSRB_DATA) InterlockedExchangePointer(
                            (PVOID) &(Adapter->EmergencySrbData),
                            NULL);

        if(emergencySrbData == NULL) {

            //
            // It's in use - queue the request until an srb data block
            // goes free.
            //

            InsertTailList(
                &Adapter->SrbDataBlockedRequests,
                &Request->Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
        } else {

            //
            // There is an SRB_DATA block available after all.
            //

            srbData = emergencySrbData;

#if TEST_LISTS
            InterlockedIncrement64(&Adapter->SrbDataEmergencyFreeCount);
#endif

        }

        KeReleaseSpinLock(&Adapter->EmergencySrbDataSpinLock,
                          oldIrql);
    }

    return srbData;
}


VOID
FASTCALL
SpFreeSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    )

{
    PSRB_DATA emergencySrbData = NULL;
    BOOLEAN startedRequest = FALSE;
    LONG depth;


    ASSERT_SRB_DATA(SrbData);
    ASSERT(SrbData->CurrentIrp == NULL);
    ASSERT(SrbData->CurrentSrb == NULL);
    ASSERT(SrbData->CompletedRequests == NULL);

    //
    // Determine if there are any other instances of this routine running.  If
    // there are, don't start a blocked request.
    //

    depth = InterlockedIncrement(&Adapter->SrbDataFreeRunning);

    //
    // Clear out some of the flags so we don't get confused when we reuse this
    // request.
    //

    SrbData->Flags = 0;

    //
    // See if we need to store away a new emergency SRB_DATA block
    //

    emergencySrbData = InterlockedCompareExchangePointer(
                           &(Adapter->EmergencySrbData),
                           SrbData,
                           NULL);

    //
    // If we stored this SRB_DATA block as the new emergency block AND if this
    // routine is not recursively nested, check if there are any blocked
    // requests waiting to be started.
    //

    if(emergencySrbData == NULL && depth == 1) {

        KIRQL oldIrql;

CheckForBlockedRequest:

        //
        // We did - now grab the spinlock and see if we can use it to issue
        // a new request.
        //

        KeAcquireSpinLock(&(Adapter->EmergencySrbDataSpinLock), &oldIrql);

        //
        // First check to see if we have a request to process.
        //

        if(IsListEmpty(&(Adapter->SrbDataBlockedRequests)) == TRUE) {

            KeReleaseSpinLock(&(Adapter->EmergencySrbDataSpinLock), oldIrql);
            InterlockedDecrement(&Adapter->SrbDataFreeRunning);
            return;
        }

        //
        // make sure the emergency request is still there (doesn't really
        // matter if it's the one we were called with or another one - just
        // make sure one is available).
        //

        emergencySrbData = (PSRB_DATA)
                            InterlockedExchangePointer(
                                (PVOID) &(Adapter->EmergencySrbData),
                                NULL);

        if(emergencySrbData == NULL) {

            //
            // Our work here is done.
            //

            KeReleaseSpinLock(&(Adapter->EmergencySrbDataSpinLock), oldIrql);
            InterlockedDecrement(&Adapter->SrbDataFreeRunning);
            return;

        } else {
            PLIST_ENTRY entry;
            PIRP request;
            PIO_STACK_LOCATION currentIrpStack;
            PSCSI_REQUEST_BLOCK srb;

            entry = RemoveHeadList(&(Adapter->SrbDataBlockedRequests));

            ASSERT(entry != NULL);

            request =
                CONTAINING_RECORD(
                    entry,
                    IRP,
                    Tail.Overlay.DeviceQueueEntry);

            KeReleaseSpinLock(&(Adapter->EmergencySrbDataSpinLock), oldIrql);

            currentIrpStack = IoGetCurrentIrpStackLocation(request);
            srb = currentIrpStack->Parameters.Scsi.Srb;

            ASSERT_PDO(currentIrpStack->DeviceObject);

            emergencySrbData->CurrentIrp = request;
            emergencySrbData->CurrentSrb = srb;
            emergencySrbData->LogicalUnit =
                currentIrpStack->DeviceObject->DeviceExtension;
            
            srb->OriginalRequest = emergencySrbData;

            startedRequest = TRUE;
            SpDispatchRequest(emergencySrbData->LogicalUnit,
                              request);

#if TEST_LISTS
            InterlockedIncrement64(&Adapter->SrbDataResurrectionCount);
#endif
        }

        //
        // If we started a blocked request, go back and see if another one
        // needs to be started.
        //
        
        if (startedRequest == TRUE) {
            startedRequest = FALSE;
            goto CheckForBlockedRequest;
        }

    } else if (emergencySrbData != NULL) {

        //
        // We did not store this SRB_DATA block as the emergency block, so
        // we need to free it back to the lookaside list.
        //

        ExFreeToNPagedLookasideList(
            &Adapter->SrbDataLookasideList,
            SrbData);
    }

    InterlockedDecrement(&Adapter->SrbDataFreeRunning);   
    return;
}

PVOID
SpAllocateSrbDataBackend(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG AdapterIndex
    )

{
    KIRQL oldIrql;
    PADAPTER_EXTENSION Adapter;
    PSRB_DATA srbData;
    ULONG tag;

    KeAcquireSpinLock(&ScsiGlobalAdapterListSpinLock, &oldIrql);

    Adapter = ScsiGlobalAdapterList[AdapterIndex]->DeviceExtension;

    KeReleaseSpinLock(&ScsiGlobalAdapterListSpinLock, oldIrql);

    ASSERT_FDO(Adapter->DeviceObject);

    tag = SpAllocateQueueTag(Adapter);

    if(tag == -1) {
        return NULL;
    }

    srbData = SpAllocatePool(PoolType,
                             NumberOfBytes,
                             SCSIPORT_TAG_SRB_DATA,
                             Adapter->DeviceObject->DriverObject);

    if(srbData == NULL) {
        SpReleaseQueueTag(Adapter, tag);
        return NULL;
    }

    RtlZeroMemory(srbData, sizeof(SRB_DATA));
    srbData->Adapter = Adapter;
    srbData->QueueTag = tag;
    srbData->Type = SRB_DATA_TYPE;
    srbData->Size = sizeof(SRB_DATA);
    srbData->Flags = 0;
    srbData->FreeRoutine = SpFreeSrbData;

    return srbData;
}

VOID
SpFreeSrbDataBackend(
    IN PSRB_DATA SrbData
    )
{
    ASSERT_SRB_DATA(SrbData);
    ASSERT_FDO(SrbData->Adapter->DeviceObject);
    ASSERT(SrbData->QueueTag != 0);

    SpReleaseQueueTag(SrbData->Adapter, SrbData->QueueTag);
    SrbData->Type = 0;
    ExFreePool(SrbData);
    return;
}


NTSTATUS
SpAllocateTagBitMap(
    IN PADAPTER_EXTENSION Adapter
    )

{
    ULONG size;         // number of bits
    PRTL_BITMAP bitMap;

    PAGED_CODE();

    //
    // Initialize the queue tag bitMap.
    //

    if(Adapter->MaxQueueTag == 0) {
#if SMALL_QUEUE_TAG_BITMAP
        if(Adapter->NumberOfRequests <= 240) {
            Adapter->MaxQueueTag = (UCHAR) (Adapter->NumberOfRequests) + 10;
        } else {
            Adapter->MaxQueueTag = 254;
        }
#else
        Adapter->MaxQueueTag = 254;
#endif
    } else if (Adapter->MaxQueueTag < Adapter->NumberOfRequests) {
        DbgPrint("SpAllocateTagBitmap: MaxQueueTag %d < NumberOfRequests %d\n"
                 "This will negate the advantage of having increased the "
                 "number of requests.\n",
                 Adapter->MaxQueueTag,
                 Adapter->NumberOfRequests);
    }

    DebugPrint((1, "SpAllocateAdapterResources: %d bits in queue tag "
                   "bitMap\n",
                Adapter->MaxQueueTag));

    size = (Adapter->MaxQueueTag + 1);
    size /= 8;
    size += 1;
    size *= sizeof(UCHAR);
    size += sizeof(RTL_BITMAP);

    bitMap = SpAllocatePool(NonPagedPool,
                            size,
                            SCSIPORT_TAG_QUEUE_BITMAP,
                            Adapter->DeviceObject->DriverObject);

    if(bitMap == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(bitMap,
                        (PULONG) (bitMap + 1),
                        Adapter->MaxQueueTag);

    RtlClearAllBits(bitMap);

    //
    // Queue tag 0 is invalid and should never be returned by the allocator.
    //

    RtlSetBits(bitMap, 0, 1);

    Adapter->QueueTagBitMap = bitMap;
    Adapter->QueueTagHint = 1;

    //
    // Create a spinlock to protect our queue tag bitmap.  There's no reason
    // for this to contend with the regular port spinlock.
    //

    KeInitializeSpinLock(&(Adapter->QueueTagSpinLock));

    return STATUS_SUCCESS;
}

ULONG
SpAllocateQueueTag(
    IN PADAPTER_EXTENSION Adapter
    )
{
    KIRQL oldIrql;
    ULONG tagValue;

    ASSERT_FDO(Adapter->DeviceObject);

    KeAcquireSpinLock(&(Adapter->QueueTagSpinLock), &oldIrql);

    //
    // Find an available queue tag.
    //

    tagValue = RtlFindClearBitsAndSet(Adapter->QueueTagBitMap,
                                      1,
                                      Adapter->QueueTagHint);

    KeReleaseSpinLock(&(Adapter->QueueTagSpinLock), oldIrql);

    ASSERT(Adapter->QueueTagHint < Adapter->MaxQueueTag);
    ASSERT(tagValue != 0);

    if(tagValue != -1) {

        ASSERT(tagValue <= Adapter->MaxQueueTag);

        //
        // This we can do unsynchronized.  if we nuke the hint accidentally it
        // will just increase the cost of the next lookup which should
        // hopefully occur rarely.
        //

        Adapter->QueueTagHint = (tagValue + 1) % Adapter->MaxQueueTag;
    }

    return tagValue;
}

VOID
SpReleaseQueueTag(
    IN PADAPTER_EXTENSION Adapter,
    IN ULONG QueueTag
    )
{
    KIRQL oldIrql;

    KeAcquireSpinLock(&(Adapter->QueueTagSpinLock), &oldIrql);
    RtlClearBits(Adapter->QueueTagBitMap,
                 QueueTag,
                 1);
    KeReleaseSpinLock(&(Adapter->QueueTagSpinLock), oldIrql);
    return;
}


INTERFACE_TYPE
SpGetPdoInterfaceType(
    IN PDEVICE_OBJECT Pdo
    )
{
    ULONG value;

    GUID busTypeGuid;
    INTERFACE_TYPE interfaceType = InterfaceTypeUndefined;
    ULONG result;

    NTSTATUS status;

    PAGED_CODE();

    status = SpReadNumericInstanceValue(Pdo,
                                        L"LegacyInterfaceType",
                                        &value);

    if(NT_SUCCESS(status)) {
        interfaceType = value;
        return interfaceType;
    }

    //
    // Attempt to get and interpret the bus type GUID.
    //

    status = IoGetDeviceProperty(Pdo,
                                 DevicePropertyBusTypeGuid,
                                 sizeof(GUID),
                                 &busTypeGuid,
                                 &result);

    if(NT_SUCCESS(status)) {

        ULONG i;

        for(i = 0;
            (SpGuidInterfaceMappingList[i].InterfaceType !=
             InterfaceTypeUndefined);
            i++) {

            if(RtlEqualMemory(&(SpGuidInterfaceMappingList[i].Guid),
                              &busTypeGuid,
                              sizeof(GUID))) {

                //
                // We have a legacy interface type for this guid already.
                //

                interfaceType = SpGuidInterfaceMappingList[i].InterfaceType;
                break;
            }
        }
    }

    if(interfaceType != InterfaceTypeUndefined) {
        return interfaceType;
    }

    status = IoGetDeviceProperty(Pdo,
                                 DevicePropertyLegacyBusType,
                                 sizeof(INTERFACE_TYPE),
                                 &interfaceType,
                                 &result);

    if(NT_SUCCESS(status)) {
        ASSERT(result == sizeof(INTERFACE_TYPE));

        //
        // Munge the interface type for the case of PCMCIA cards to allow SCSI
        // pccards (i.e. sparrow) to be recognized. Much better would be a way
        // to get the interface type correct before we enter this routine.
        //

        if (interfaceType == PCMCIABus) {
            interfaceType = Isa;
        }

    }

    if(interfaceType != InterfaceTypeUndefined) {

        return interfaceType;

    } else {

        //
        // No idea what the interface type is - guess isa.
        //

        DebugPrint((1, "SpGetPdoInterfaceType: Status %#08lx getting legacy "
                       "bus type - assuming device is ISA\n", status));
        return Isa;
    }
}


NTSTATUS
SpReadNumericInstanceValue(
    IN PDEVICE_OBJECT Pdo,
    IN PWSTR ValueName,
    OUT PULONG Value
    )
{
    ULONG value;

    HANDLE baseKey = NULL;
    HANDLE scsiportKey = NULL;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT(Value != NULL);
    ASSERT(ValueName != NULL);
    ASSERT(Pdo != NULL);

    status = IoOpenDeviceRegistryKey(Pdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ,
                                     &baseKey);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    try {
        UNICODE_STRING unicodeKeyName;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString(&unicodeKeyName, L"Scsiport");
        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   baseKey,
                                   NULL);

        status = ZwOpenKey(&scsiportKey,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            leave;
        } else {
            UNICODE_STRING unicodeValueName;

            UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];

            PKEY_VALUE_PARTIAL_INFORMATION keyValue =
                (PKEY_VALUE_PARTIAL_INFORMATION) buffer;

            ULONG result;

            RtlInitUnicodeString(&unicodeValueName, ValueName);

            status = ZwQueryValueKey(scsiportKey,
                                     &unicodeValueName,
                                     KeyValuePartialInformation,
                                     keyValue,
                                     sizeof(buffer),
                                     &result);

            if(!NT_SUCCESS(status)) {
                leave;
            }

            if(keyValue->Type != REG_DWORD) {
                status = STATUS_OBJECT_TYPE_MISMATCH;
                leave;
            }

            if(result < sizeof(ULONG)) {
                status = STATUS_OBJECT_TYPE_MISMATCH;
                leave;
            }

            value = ((PULONG) (keyValue->Data))[0];
        }

    } finally {
        if(baseKey != NULL) {ZwClose(baseKey);}
        if(scsiportKey != NULL) {ZwClose(scsiportKey);}
    }

    *Value = value;
    return status;
}


NTSTATUS
SpWriteNumericInstanceValue(
    IN PDEVICE_OBJECT Pdo,
    IN PWSTR ValueName,
    IN ULONG Value
    )
{
    ULONG value;

    HANDLE baseKey = NULL;
    HANDLE scsiportKey = NULL;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName != NULL);
    ASSERT(Pdo != NULL);

    status = IoOpenDeviceRegistryKey(Pdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ | KEY_WRITE,
                                     &baseKey);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    try {
        UNICODE_STRING unicodeKeyName;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString(&unicodeKeyName, L"Scsiport");
        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   baseKey,
                                   NULL);

        status = ZwCreateKey(&scsiportKey,
                             KEY_READ | KEY_WRITE,
                             &objectAttributes,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             NULL
                             );

        if(!NT_SUCCESS(status)) {
            leave;
        } else {
            UNICODE_STRING unicodeValueName;

            ULONG result;

            RtlInitUnicodeString(&unicodeValueName, ValueName);

            status = ZwSetValueKey(scsiportKey,
                                   &unicodeValueName,
                                   0,
                                   REG_DWORD,
                                   &Value,
                                   sizeof(ULONG));

        }

    } finally {
        if(baseKey != NULL) {ZwClose(baseKey);}
        if(scsiportKey != NULL) {ZwClose(scsiportKey);}
    }

    return status;
}


PMAPPED_ADDRESS
SpAllocateAddressMapping(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will attempt to allocate a free address mapping block and 
    place it on the adapter's MappedAddressList.  If there is an available 
    block in the free list then it will be used.  Otherwise it will attempt 
    to allocate a block from non-paged pool.

Arguments:

    Adapter - the adapter we are allocating the mapping for.

    Preallocate - indicates that the caller is trying to preallocate buffers.
                  
    
Return Value:

    a pointer to the new mapping (which has been inserted into the address 
    mapping list) or NULL if none could be allocated.
    
--*/            
{
    PMAPPED_ADDRESS mapping;

    PAGED_CODE();

    //
    // First check the free address mapping list.  If there's one there 
    // unlink it and return.
    //

    if(Adapter->FreeMappedAddressList != NULL) {
        mapping = Adapter->FreeMappedAddressList;
        Adapter->FreeMappedAddressList = mapping->NextMappedAddress;
    } else {
        mapping = SpAllocatePool(NonPagedPool,
                                 sizeof(MAPPED_ADDRESS),
                                 SCSIPORT_TAG_MAPPING_LIST,
                                 Adapter->DeviceObject->DriverObject);
    }

    if(mapping == NULL) {
        DebugPrint((0, "SpAllocateAddressMapping: Unable to allocate "
                       "mapping\n"));

        return NULL;
    }

    RtlZeroMemory(mapping, sizeof(MAPPED_ADDRESS));

    mapping->NextMappedAddress = Adapter->MappedAddressList;
    Adapter->MappedAddressList = mapping;

    return mapping;
}

BOOLEAN
SpPreallocateAddressMapping(
    PADAPTER_EXTENSION Adapter,
    IN UCHAR NumberOfBlocks
    )
/*++

Routine Description:

    This routine will allocate a number of address mapping structures and 
    place them on the free mapped address list.

Arguments:

    Adapter - the adapter we are allocating the mapping for.

    NumberOfBlocks - the number of blocks to allocate
                  
    
Return Value:

    TRUE if the requested number of blocks was successfully allocated, 

    FALSE if there was not sufficient memory to allocate them all.  The caller 
          is still responsible for freeing them in this case.
    
--*/            
{
    PMAPPED_ADDRESS mapping;
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < NumberOfBlocks; i++) {
        mapping = SpAllocatePool(NonPagedPool,
                                 sizeof(MAPPED_ADDRESS),
                                 SCSIPORT_TAG_MAPPING_LIST,
                                 Adapter->DeviceObject->DriverObject);

        if(mapping == NULL) {

            return FALSE;
        }

        RtlZeroMemory(mapping, sizeof(MAPPED_ADDRESS));

        mapping->NextMappedAddress = Adapter->FreeMappedAddressList;
        Adapter->FreeMappedAddressList = mapping;
    }

    return TRUE;
}

VOID
SpPurgeFreeMappedAddressList(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:
    
    This routine frees all of the mapped address blocks on the 
    FreeMappedAddressList.
   
Arguments:

    Adapter - the adapter who's FreeMappedAddressList is to be dumped.
    
Return Value:

    none

--*/    
{
    PMAPPED_ADDRESS mapping;

    PAGED_CODE();

    while(Adapter->FreeMappedAddressList != NULL) {
        mapping = Adapter->FreeMappedAddressList;
        Adapter->FreeMappedAddressList = mapping->NextMappedAddress;

        ExFreePool(mapping);
    }
    return;
}


BOOLEAN
SpFreeMappedAddress(
    IN PADAPTER_EXTENSION Adapter,
    IN PVOID MappedAddress
    )
/*++

Routine Description:

    This routine will unmap the specified mapping and then return the mapping
    block to the free list.  If no mapped address was specified then this 
    will simply free the first mapping on the MappedAddressList.

Arguments:

    Adapter - the adapter which has the mapping
    
    MappedAddress - the base address of the mapping we're attempting to free.
                    ignored if FreeSpecificBlock is false.
                    
Return Value:

    TRUE if a matching list element was found.
    FALSE otherwise.
    
--*/
{
    PMAPPED_ADDRESS *mapping;

    PAGED_CODE();

    for(mapping = &(Adapter->MappedAddressList);
        *mapping != NULL;
        mapping = &((*mapping)->NextMappedAddress)) {

        if((*mapping)->MappedAddress == MappedAddress) {
    
            PMAPPED_ADDRESS tmp = *mapping;

            //
            // Unmap address.
            //
    
            MmUnmapIoSpace(tmp->MappedAddress, tmp->NumberOfBytes);

            //
            // Unlink this entry from the mapped address list.  Stick it on 
            // the free mapped address list.  Then return.
            //

            *mapping = tmp->NextMappedAddress;

            tmp->NextMappedAddress = Adapter->FreeMappedAddressList;
            Adapter->FreeMappedAddressList = tmp;

            return TRUE;
        }
    }

    return FALSE;
}

PMAPPED_ADDRESS
SpFindMappedAddress(
    IN PADAPTER_EXTENSION Adapter,
    IN LARGE_INTEGER IoAddress,
    IN ULONG NumberOfBytes,
    IN ULONG SystemIoBusNumber
    )
{
    PMAPPED_ADDRESS mapping;

    for(mapping = Adapter->MappedAddressList;
        mapping != NULL;
        mapping = mapping->NextMappedAddress) {

        if((mapping->IoAddress.QuadPart == IoAddress.QuadPart) && 
           (mapping->NumberOfBytes == NumberOfBytes) && 
           (mapping->BusNumber == SystemIoBusNumber)) {
            return mapping;
        }
    }
    return NULL;
}


VOID
SpReleaseMappedAddresses(
    IN PADAPTER_EXTENSION Adapter
    )
{
    ULONG i;

    PAGED_CODE();

    //
    // Iterate through the mapped address list and punt every entry onto the 
    // free list.
    //

    while(Adapter->MappedAddressList != NULL) {
        SpFreeMappedAddress(Adapter, Adapter->MappedAddressList->MappedAddress);
    }

    //
    // Now dump the free list.
    //

    SpPurgeFreeMappedAddressList(Adapter);

    return;
}


NTSTATUS
SpSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SpSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KEVENT event;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           SpSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    IoCallDriver(DeviceObject, Irp);

    KeWaitForSingleObject(&event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    return Irp->IoStatus.Status;
}


NTSTATUS
SpGetBusTypeGuid(
    IN PADAPTER_EXTENSION Adapter
    )
{
    ULONG result;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Grab the bus interface GUID and save it away in the adapter extension.
    //

    status = IoGetDeviceProperty(Adapter->LowerPdo,
                                 DevicePropertyBusTypeGuid,
                                 sizeof(GUID),
                                 &(Adapter->BusTypeGuid),
                                 &result);

    if(!NT_SUCCESS(status)) {
        RtlZeroMemory(&(Adapter->BusTypeGuid), sizeof(GUID));
    }

    return status;
}


BOOLEAN
SpDetermine64BitSupport(
    VOID
    )
/*++

Routine Description:

    This routine determines if 64-bit physical addressing is supported by
    the system to be saved in the global Sp64BitPhysicalAddressing.  Eventually
    this routine can be removed and the scsiport global will just point to the
    one exported by MM.  However the global isn't hooked up for PAE36 at the
    moment so we need to do some x86 specific tricks.

Arguments:

    none

Return Value:

    Does the system support 64-bit (or something over 32-bit) addresses?

--*/

{
    PAGED_CODE();

    if((*Mm64BitPhysicalAddress) == TRUE) {
        DbgPrintEx(DPFLTR_SCSIPORT_ID,
                   DPFLTR_INFO_LEVEL,
                   "SpDetermine64BitSupport: Mm64BitPhysicalAddress is TRUE\n");

        return TRUE;
    }

    return FALSE;
}

VOID
SpAdjustDisabledBit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Enable
    )
{
    ULONG newCount;
    KIRQL oldIrql;

    KeAcquireSpinLock(&(LogicalUnit->AdapterExtension->SpinLock), &oldIrql);
    if(Enable) {
        if(LogicalUnit->QueuePauseCount != 0) {
            LogicalUnit->QueuePauseCount -= 1;
        }

        if(LogicalUnit->QueuePauseCount == 0) {
            CLEAR_FLAG(LogicalUnit->LuFlags, LU_QUEUE_PAUSED);
        }
    } else {
        LogicalUnit->QueuePauseCount += 1;
        SET_FLAG(LogicalUnit->LuFlags, LU_QUEUE_PAUSED);
    }
    KeReleaseSpinLock(&(LogicalUnit->AdapterExtension->SpinLock), oldIrql);
    return;
}

NTSTATUS
SpReadNumericValue(
    IN OPTIONAL HANDLE Root,
    IN OPTIONAL PUNICODE_STRING KeyName,
    IN PUNICODE_STRING ValueName,
    OUT PULONG Value
    )
/*++

Routine Description:

    This routine will read a REG_DWORD value from the specified registry
    location.  The caller can specify the key by providing a handle to a root
    registry key and the name of a subkey.

    The caller must supply either Root or KeyName.  Both may be supplied.

Arguments:

    Root - the key the value resides in (if KeyName is NULL), a parent
           key of the one the value resides in, or NULL if KeyName specifies
           the entire registry path.

    KeyName - the name of the subkey (either from the root of the registry or
              from the key specified in Root.

    ValueName - the name of the value to be read

    Value - returns the value in the key.  this will be zero if an error occurs

Return Value:

    STATUS_SUCCESS if successful.
    STATUS_UNSUCCESSFUL if the specified value is not a REG_DWORD value.
    other status values explaining the cause of the failure.

--*/

{
    ULONG value = 0;

    HANDLE key = Root;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(Value != NULL);
    ASSERT(ValueName != NULL);

    ASSERT((KeyName != NULL) || (Root != NULL));

    if(ARGUMENT_PRESENT(KeyName)) {
        OBJECT_ATTRIBUTES objectAttributes;

        InitializeObjectAttributes(&(objectAttributes),
                                   KeyName,
                                   OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                   Root,
                                   NULL);

        status = ZwOpenKey(&(key), KEY_QUERY_VALUE, &objectAttributes);
    }

    if(NT_SUCCESS(status)) {
        UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
        PKEY_VALUE_PARTIAL_INFORMATION data;
        ULONG result;

        RtlZeroMemory(buffer, sizeof(buffer));
        data = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;

        status = ZwQueryValueKey(key,
                                 ValueName,
                                 KeyValuePartialInformation,
                                 data,
                                 sizeof(buffer),
                                 &result);

        if(NT_SUCCESS(status)) {
            if (data->Type != REG_DWORD) {
                status = STATUS_UNSUCCESSFUL;
            } else {
                value = ((PULONG) data->Data)[0];
            }
        }
    }

    *Value = value;

    if(key != Root) {
        ZwClose(key);
    }

    return status;
}


PMDL
SpBuildMdlForMappedTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDMA_ADAPTER AdapterObject,
    IN PMDL OriginalMdl,
    IN PVOID StartVa,
    IN ULONG ByteCount,
    IN PSRB_SCATTER_GATHER ScatterGatherList,
    IN ULONG ScatterGatherEntries
    )
{
    ULONG size;
    PMDL mdl;

    ULONG pageCount;

    PPFN_NUMBER pages;
    ULONG sgPage;
    ULONG mdlPage;
    ULONG sgSpan;

    mdl = SpAllocateMdl(StartVa,
                        ByteCount,
                        FALSE,
                        FALSE,
                        NULL,
                        DeviceObject->DriverObject);

    if (mdl == NULL) {
        return NULL;
    }

    pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(StartVa, ByteCount);

    //
    // Indicate that the memory has already been locked down.
    //

    //
    // Indicate that the memory is "I/O space" so that MM doesn't won't 
    // reference the (nonexistent) PFNs for this buffer.  We have to do this 
    // for the time being because MM isn't aware of the pages the HAL is using 
    // for bounce buffers.
    //

    SET_FLAG(mdl->MdlFlags, MDL_PAGES_LOCKED | MDL_IO_SPACE);

    //
    // Run through our scatter gather list and build the page list based
    // on that.
    //

    pages = (PPFN_NUMBER) (mdl + 1);

    for(sgPage = 0, mdlPage = 0; sgPage < ScatterGatherEntries; sgPage++) {

        PVOID pa;
        ULONG sgLength;

        ASSERT(ScatterGatherList[sgPage].Length != 0);

        pa = (PVOID) ScatterGatherList[sgPage].Address.QuadPart;

        sgLength =
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(pa, 
                                           ScatterGatherList[sgPage].Length);

        for(sgSpan = 0; sgSpan < sgLength; sgSpan++, mdlPage++) {
            ULONGLONG pa;
            pa = ScatterGatherList[sgPage].Address.QuadPart;
            pa += sgSpan * PAGE_SIZE;
            pa >>= PAGE_SHIFT;
            pages[mdlPage] = (PFN_NUMBER) (pa);
        }
    }
    pages = (PPFN_NUMBER) (mdl + 1);
    pages = (PPFN_NUMBER) (OriginalMdl + 1);

    ASSERT(mdlPage == pageCount);

    return mdl;
}

#if defined(FORWARD_PROGRESS)
VOID
SpPrepareMdlForMappedTransfer(
    IN PMDL mdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDMA_ADAPTER AdapterObject,
    IN PMDL OriginalMdl,
    IN PVOID StartVa,
    IN ULONG ByteCount,
    IN PSRB_SCATTER_GATHER ScatterGatherList,
    IN ULONG ScatterGatherEntries
    )
{
    ULONG size;

    ULONG pageCount;

    PPFN_NUMBER pages;
    ULONG sgPage;
    ULONG mdlPage;
    ULONG sgSpan;

    pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(StartVa, ByteCount);

    //
    // Indicate that the memory has already been locked down.
    //

    //
    // Indicate that the memory is "I/O space" so that MM doesn't won't 
    // reference the (nonexistent) PFNs for this buffer.  We have to do this 
    // for the time being because MM isn't aware of the pages the HAL is using 
    // for bounce buffers.
    //

    SET_FLAG(mdl->MdlFlags, MDL_PAGES_LOCKED | MDL_IO_SPACE);

    //
    // Run through our scatter gather list and build the page list based
    // on that.
    //

    pages = (PPFN_NUMBER) (mdl + 1);

    for(sgPage = 0, mdlPage = 0; sgPage < ScatterGatherEntries; sgPage++) {

        PVOID pa;
        ULONG sgLength;

        ASSERT(ScatterGatherList[sgPage].Length != 0);

        pa = (PVOID) ScatterGatherList[sgPage].Address.QuadPart;

        sgLength =
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(pa, 
                                           ScatterGatherList[sgPage].Length);

        for(sgSpan = 0; sgSpan < sgLength; sgSpan++, mdlPage++) {
            ULONGLONG pa;
            pa = ScatterGatherList[sgPage].Address.QuadPart;
            pa += sgSpan * PAGE_SIZE;
            pa >>= PAGE_SHIFT;
            pages[mdlPage] = (PFN_NUMBER) (pa);
        }
    }
    pages = (PPFN_NUMBER) (mdl + 1);
    pages = (PPFN_NUMBER) (OriginalMdl + 1);

    ASSERT(mdlPage == pageCount);
}
#endif

PSRB_DATA
FASTCALL
SpAllocateBypassSrbData(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    PSINGLE_LIST_ENTRY entry;
    PSRB_DATA srbData;

    entry = ExInterlockedPopEntrySList(&(LogicalUnit->BypassSrbDataList),
                                       &(LogicalUnit->BypassSrbDataSpinLock));

    if(entry == NULL) {
        KeBugCheckEx(PORT_DRIVER_INTERNAL,
                     5,
                     NUMBER_BYPASS_SRB_DATA_BLOCKS,
                     (ULONG_PTR) LogicalUnit->BypassSrbDataBlocks,
                     0);
    }

    srbData = CONTAINING_RECORD(entry, SRB_DATA, Reserved);

    srbData->Adapter = LogicalUnit->AdapterExtension;
    srbData->QueueTag = SP_UNTAGGED;
    srbData->Type = SRB_DATA_TYPE;
    srbData->Size = sizeof(SRB_DATA);
    srbData->Flags = SRB_DATA_BYPASS_REQUEST;
    srbData->FreeRoutine = SpFreeBypassSrbData;

    return srbData;
}

VOID
FASTCALL
SpFreeBypassSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    )

{
    PLOGICAL_UNIT_EXTENSION lu = SrbData->LogicalUnit;

    ASSERT_SRB_DATA(SrbData);
    ASSERT(SrbData->CurrentIrp == NULL);
    ASSERT(SrbData->CurrentSrb == NULL);
    ASSERT(SrbData->CompletedRequests == NULL);
    ASSERT(TEST_FLAG(SrbData->Flags, SRB_DATA_BYPASS_REQUEST));

    RtlZeroMemory(SrbData, sizeof(SRB_DATA));

    ExInterlockedPushEntrySList(&(lu->BypassSrbDataList),
                                &(SrbData->Reserved),
                                &(lu->BypassSrbDataSpinLock));
    return;
}

PVOID
SpAllocateErrorLogEntry(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PVOID Packet;

    ASSERT(DriverObject);
    Packet = IoAllocateErrorLogEntry(
                 DriverObject,
                 sizeof(IO_ERROR_LOG_PACKET) + sizeof(SCSIPORT_ALLOCFAILURE_DATA));

    return Packet;
}

VOID
FASTCALL
SpLogAllocationFailureFn(
    IN PDRIVER_OBJECT DriverObject,
    IN POOL_TYPE PoolType,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN ULONG FileId,
    IN ULONG LineNumber
    )

/*++

Routine Description:

    This routine writes a message to the event log indicating that an
    allocation failure has occurred.

Arguments:

    DriverObject - pointer to the driver object for which the allocation
                   failure event is being logged.

    PoolType     - identifies the pool the failed allocation attempt was from.

    Size         - indicates the number of bytes that the failed allocation 
                   attempt tried to obtain.

    Tag          - identifies the pool tag associated with the failed 
                   allocation.
    
    AllocId      - uniquely identifies this allocation w/in scsiport.

Return Value:

    VOID

--*/

{
    NTSTATUS status;
    PIO_ERROR_LOG_PACKET Packet;
    PIO_ERROR_LOG_PACKET CurrentValue;
    SCSIPORT_ALLOCFAILURE_DATA *Data;
//    PSCSIPORT_ALLOCFAILURE_ENTRY Entry;
//    PSCSIPORT_ALLOCFAILURE_ENTRY CurrentValue;
    PSCSIPORT_DRIVER_EXTENSION DriverExtension;

    DebugPrint((2, "SpLogAllocationFailureFn: DriverObject:%p\nId:%08X|%08X\n", 
                DriverObject,
                FileId, LineNumber));

    //
    // Try to allocate a new error log event.
    //

    Packet = (PIO_ERROR_LOG_PACKET) 
       SpAllocateErrorLogEntry(DriverObject);

    //
    // If we could not allocate a log event, we check the driver extension to
    // see if it has a reserve event we can use.  If we cannot get the driver
    // extension or if it does not contain a reserve event, we return
    // without logging the allocation failure.
    //

    if (Packet == NULL) {

        //
        // See if there is a driver extension for this driver.  It is possible
        // that one has not been created yet, so this may fail, in which case
        // we give up and return.
        //

        DriverExtension = IoGetDriverObjectExtension(
                              DriverObject,
                              ScsiPortInitialize
                              );

        if (DriverExtension == NULL) {
            DebugPrint((1, "SpLogAllocationFailureFn: no driver extension\n"));
            return;
        }

        //
        // Get the reserve event in the driver extension.  The reserve event
        // may have already been used, so it's possible that it is NULL.  If
        // this is the case, we give up and return.
        //

        Packet = (PIO_ERROR_LOG_PACKET)
                DriverExtension->ReserveAllocFailureLogEntry;

        if (Packet == NULL) {
            DebugPrint((1, "SpLogAllocationFailureFn: no reserve packet\n"));
            return;
        }

        //
        // We have to ensure that we are the only instance to use this
        // event.  To do so, we attempt to NULL the event in the driver
        // extension.  If somebody else beats us to it, they own the
        // event and we have to give up.
        //

        CurrentValue = InterlockedCompareExchangePointer(
                            DriverExtension->ReserveAllocFailureLogEntry,
                            NULL,
                            Packet
                            );

        if (Packet != CurrentValue) {
            DebugPrint((1, "SpLogAllocationFailureFn: someone already owns packet\n"));
            return;
        }
    }

    //
    // Initialize the error log packet.
    //

    Packet->ErrorCode = IO_WARNING_ALLOCATION_FAILED;
    Packet->SequenceNumber = 0;
    Packet->MajorFunctionCode = 0;
    Packet->RetryCount = 0;
    Packet->UniqueErrorValue = 0x10;
    Packet->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
    Packet->DumpDataSize = sizeof(ULONG) * 4;
    Packet->NumberOfStrings = 0;
    Packet->DumpData[0] = Tag;

    Data = (SCSIPORT_ALLOCFAILURE_DATA*) &Packet->DumpData[1];

    Data->Size = (ULONG) Size;
    Data->FileId = FileId;
    Data->LineNumber = LineNumber;

    //
    // Queue the error log entry.
    //

    IoWriteErrorLogEntry(Packet);
}

PVOID
SpAllocatePoolEx(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    )
{
    PVOID Block;

    Block = ExAllocatePoolWithTag(PoolType,
                                  NumberOfBytes,
                                  Tag);
    if (Block == NULL) {

        SpLogAllocationFailureFn(DriverObject, 
                                 PoolType,
                                 NumberOfBytes,
                                 Tag,
                                 FileId,
                                 LineNumber);
    }

    return Block;
}

PMDL
SpAllocateMdlEx(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    )
{
    PMDL mdl = IoAllocateMdl(VirtualAddress,
                             Length,
                             SecondaryBuffer,
                             ChargeQuota,
                             Irp);
    if (mdl == NULL) {
        SpLogAllocationFailureFn(DriverObject,
                                 NonPagedPool,
                                 0,
                                 SCSIPORT_TAG_ALLOCMDL,
                                 FileId,
                                 LineNumber);
    }
    return mdl;
}

PIRP
SpAllocateIrpEx(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    )
{
    PIRP irp = IoAllocateIrp(StackSize, ChargeQuota);
    if (irp == NULL) {
        SpLogAllocationFailureFn(DriverObject,
                                 NonPagedPool,
                                 0,
                                 SCSIPORT_TAG_ALLOCIRP,
                                 FileId,
                                 LineNumber);
    }
    return irp;
}

#ifndef USE_DMA_MACROS
VOID
SpFreeSGList(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    )
{
    ASSERT(TEST_FLAG(SrbData->Flags,
                     (SRB_DATA_MEDIUM_SG_LIST |
		      SRB_DATA_SMALL_SG_LIST |
		      SRB_DATA_LARGE_SG_LIST)));

    if (TEST_FLAG(SrbData->Flags, SRB_DATA_MEDIUM_SG_LIST)) {

        //
        // Release the scatter gather list back to the lookaside list.
        //

        ExFreeToNPagedLookasideList(
        	&(Adapter->MediumScatterGatherLookasideList),
                (PVOID) SrbData->ScatterGatherList);

    } else if(TEST_FLAG(SrbData->Flags, SRB_DATA_LARGE_SG_LIST)) {

        //
	// We allocated the SG list from pool, so free it.
	//

        ExFreePool(SrbData->ScatterGatherList);

    } else {

        //
	// We used the preallocated SG list embedded in the SRB_DATA object,
	// so we don't have to free anything.
	//
	
        NOTHING
    }

    //
    // Clear the SG-related flags on the SRB_DATA object.
    //
    
    CLEAR_FLAG(SrbData->Flags, (SRB_DATA_LARGE_SG_LIST |
                                SRB_DATA_MEDIUM_SG_LIST |
                                SRB_DATA_SMALL_SG_LIST));

    //
    // NULL the SRB_DATA's SG list pointer.
    //

    SrbData->ScatterGatherList = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiprnt\pnp.c ===
/*++


Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    pnp.c

Abstract:

    pnp code for the pnp print class

Author:

    George Chrysanthakopoulos May-1998

Environment:

    Kernel mode

Revision History :

    dankn, 22-Jul-99 : Added ability to block & resubmit failed writes for
                       1394 printers to behave more like other print stacks
                       (i.e. USB) and therefore keep USBMON.DLL (the Win2k
                       port monitor) happy.  USBMON does not deal well
                       with failed writes.
--*/

#include "printpnp.h"
#include "1394.h"
#include "ntddsbp2.h"
#include "stdarg.h"
#include "stdio.h"
#include "string.h"


VOID
PrinterUnload(
    IN PDRIVER_OBJECT DriverObject
    );


NTSTATUS
GetPortNumber(
    HANDLE hFdoKey,
    PUNICODE_STRING uni,
    PULONG ulReturnNumber
    );



VOID
PrinterFindDeviceIdKeys
(
    PUCHAR   *lppMFG,
    PUCHAR   *lppMDL,
    PUCHAR   *lppCLS,
    PUCHAR   *lppDES,
    PUCHAR   *lppAID,
    PUCHAR   *lppCID,
    PUCHAR   lpDeviceID
);

VOID
GetCheckSum(
    PUCHAR Block,
    USHORT Len,
    PUSHORT CheckSum
    );

PUCHAR
StringChr(PCHAR string, CHAR c);


VOID
StringSubst
(
    PUCHAR lpS,
    UCHAR chTargetChar,
    UCHAR chReplacementChar,
    USHORT cbS
);

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );



#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, PrinterUnload)
#pragma alloc_text(PAGE, PrinterAddDevice)
#pragma alloc_text(PAGE, PrinterStartDevice)
#pragma alloc_text(PAGE, PrinterStartPdo)
#pragma alloc_text(PAGE, PrinterCreatePdo)
#pragma alloc_text(PAGE, PrinterQueryId)
#pragma alloc_text(PAGE, PrinterGetId)
#pragma alloc_text(PAGE, GetCheckSum)
#pragma alloc_text(PAGE, PrinterEnumerateDevice)
#pragma alloc_text(PAGE, PrinterRemoveDevice)
#pragma alloc_text(PAGE, CreatePrinterDeviceObject)
#pragma alloc_text(PAGE, PrinterInitFdo)
#pragma alloc_text(PAGE, GetPortNumber)
#pragma alloc_text(PAGE, PrinterRegisterPort)
#pragma alloc_text(PAGE, PrinterQueryPnpCapabilities)
#pragma alloc_text(PAGE, PrinterFindDeviceIdKeys)
#pragma alloc_text(PAGE, StringChr)
#pragma alloc_text(PAGE, StringSubst)

#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the printer class driver. The driver
    opens the port driver by name and then receives configuration
    information used to attach to the Printer devices.

Arguments:

    DriverObject

Return Value:

    NT Status

--*/

{

    CLASS_INIT_DATA InitializationData;

    PAGED_CODE();

    DEBUGPRINT1(("\n\nSCSI/SBP2 Printer Class Driver\n"));

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);
    InitializationData.FdoData.DeviceExtensionSize = sizeof(FUNCTIONAL_DEVICE_EXTENSION) + sizeof(PRINTER_DATA);
    InitializationData.FdoData.DeviceType = FILE_DEVICE_PRINTER;
    InitializationData.FdoData.DeviceCharacteristics = 0;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassInitDevice = PrinterInitFdo;
    InitializationData.FdoData.ClassStartDevice = PrinterStartDevice;

    InitializationData.FdoData.ClassReadWriteVerification = PrinterReadWrite;
    InitializationData.FdoData.ClassDeviceControl = PrinterDeviceControl;
    InitializationData.FdoData.ClassRemoveDevice = PrinterRemoveDevice;
    InitializationData.FdoData.ClassStopDevice = PrinterStopDevice;


    InitializationData.FdoData.ClassShutdownFlush = NULL;
    InitializationData.FdoData.ClassCreateClose = PrinterOpenClose;

    InitializationData.PdoData.DeviceExtensionSize = sizeof(PHYSICAL_DEVICE_EXTENSION);
    InitializationData.PdoData.DeviceType = FILE_DEVICE_PRINTER;
    InitializationData.PdoData.DeviceCharacteristics = 0;

    InitializationData.PdoData.ClassStartDevice = PrinterStartPdo;
    InitializationData.PdoData.ClassInitDevice = PrinterInitPdo;
    InitializationData.PdoData.ClassRemoveDevice = PrinterRemoveDevice;
    InitializationData.PdoData.ClassStopDevice = PrinterStopDevice;

    InitializationData.PdoData.ClassPowerDevice = NULL;

    InitializationData.PdoData.ClassError = NULL;
    InitializationData.PdoData.ClassReadWriteVerification = PrinterReadWrite;
    InitializationData.PdoData.ClassCreateClose = NULL;

    InitializationData.PdoData.ClassDeviceControl = PrinterDeviceControl;

    InitializationData.PdoData.ClassQueryPnpCapabilities = PrinterQueryPnpCapabilities;

    InitializationData.ClassEnumerateDevice = PrinterEnumerateDevice;

    InitializationData.ClassQueryId = PrinterQueryId;

    InitializationData.ClassAddDevice = PrinterAddDevice;
    InitializationData.ClassUnload = PrinterUnload;

    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);

} // end DriverEntry()


VOID
PrinterUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Does nothing really...

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    return;
}



NTSTATUS
PrinterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - Printer class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    ULONG printerCount = 0;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the address of the count of the number of cdroms already initialized.
    //

    do {

        status = CreatePrinterDeviceObject(
                    DriverObject,
                    PhysicalDeviceObject,
                    &printerCount);

        printerCount++;

    } while (status == STATUS_OBJECT_NAME_COLLISION);

    DEBUGPRINT1(("SCSIPRNT: AddDevice, exit with status %x\n",status));
    return status;
}


NTSTATUS
CreatePrinterDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PULONG         DeviceCount
    )

/*++

Routine Description:

    This routine creates an object for the device.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PortDeviceObject - to connect to the port driver.
    DeviceCount - Number of previously installed devices of this type.

Return Value:

    NTSTATUS

--*/
{
    UCHAR ntNameBuffer[64];
    STRING ntNameString;
    NTSTATUS status;
    PCLASS_DRIVER_EXTENSION driverExtension = ClassGetDriverExtension(DriverObject);

    PDEVICE_OBJECT lowerDevice = NULL;
    PDEVICE_OBJECT deviceObject = NULL;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    PCOMMON_DEVICE_EXTENSION commonExtension = NULL;

    CCHAR           dosNameBuffer[64];
    CCHAR           deviceNameBuffer[64];
    STRING          deviceNameString;
    STRING          dosString;
    UNICODE_STRING  unicodeString;
    PCLASS_DEV_INFO devInfo;
    PPRINTER_DATA   printerData;
    ULONG           lptNumber;

    PAGED_CODE();

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObject: Failed to claim device %x\n",status));
        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // initialize our driver extension..
    //

    devInfo = &(driverExtension->InitData.FdoData);
    devInfo->DeviceType = FILE_DEVICE_PRINTER;
    devInfo->DeviceCharacteristics = 0;

    //
    // Create device object for this device.
    //

    sprintf(ntNameBuffer, "\\Device\\Printer%d", *DeviceCount);

    status = ClassCreateDeviceObject(DriverObject,
                                     ntNameBuffer,
                                     PhysicalDeviceObject,
                                     TRUE,
                                     &deviceObject);

    if (!NT_SUCCESS(status)) {
        DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObjects: Can not create device %s, status %x\n",
                    ntNameBuffer,status));

        goto CreateDeviceObjectExit;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;
    commonExtension = deviceObject->DeviceExtension;

    printerData = (PPRINTER_DATA)(commonExtension->DriverData);

    RtlZeroMemory(printerData,sizeof(PRINTER_DATA));
    printerData->DeviceIdString = NULL;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system printer number
    //

    fdoExtension->DeviceNumber = *DeviceCount;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;

    fdoExtension->DeviceDescriptor = NULL;

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Finally, attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObjects: Failed attach\n"));
        status = STATUS_UNSUCCESSFUL;
        goto CreateDeviceObjectExit;
    }

    //
    // Recreate the deviceName
    //

    sprintf(deviceNameBuffer,
            "\\Device\\Printer%d",
            fdoExtension->DeviceNumber);

    RtlInitString(&deviceNameString,
                  deviceNameBuffer);

    status = RtlAnsiStringToUnicodeString(&unicodeString,
                                          &deviceNameString,
                                          TRUE);
    ASSERT(NT_SUCCESS(status));

    //
    // offset the lptnumber to avoid parallel port numbers.
    // note that there is an increment at the beginning of the do
    // loop below as well.
    //

    lptNumber = fdoExtension->DeviceNumber+1;

    do {

        lptNumber++;
        sprintf(dosNameBuffer,
                "\\DosDevices\\LPT%d",
                lptNumber);

        RtlInitString(&dosString, dosNameBuffer);

        status = RtlAnsiStringToUnicodeString(&printerData->UnicodeLinkName,
                                              &dosString,
                                              TRUE);

        if(!NT_SUCCESS(status)) {

           printerData->UnicodeLinkName.Buffer = NULL;
           break;

        }

        if ((printerData->UnicodeLinkName.Buffer != NULL) && (unicodeString.Buffer != NULL)) {

            status = IoAssignArcName(&printerData->UnicodeLinkName, &unicodeString);

        } else {

            status = STATUS_UNSUCCESSFUL;

        }

        if (!NT_SUCCESS(status)) {
            RtlFreeUnicodeString(&printerData->UnicodeLinkName);
            DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObjects: Failed creating Arc Name, status %x\n",status));
        }

    } while (status == STATUS_OBJECT_NAME_COLLISION);

    if (unicodeString.Buffer != NULL ) {
        RtlFreeUnicodeString(&unicodeString);
    }

    if (!NT_SUCCESS(status)) {
        goto CreateDeviceObjectExit;
    }

    printerData->LptNumber = lptNumber;

    ObDereferenceObject(lowerDevice);

    //
    // The device is initialized properly - mark it as such.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;

CreateDeviceObjectExit:

    ClassClaimDevice(lowerDevice, TRUE);
    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObjects: Exiting with status %x\n",status));
    return status;

} // end CreateDeviceObject()


NTSTATUS
PrinterInitFdo(
    IN PDEVICE_OBJECT Fdo
    )
{

    return STATUS_SUCCESS;
}



NTSTATUS
PrinterStartDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the cd-rom initialization.  This includes
    allocating sense info buffers and srb s-lists, reading drive capacity
    and setting up Media Change Notification (autorun).

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCLASS_DRIVER_EXTENSION driverExtension = ClassGetDriverExtension(Fdo->DriverObject);
    UNICODE_STRING dosUnicodeString;

    STORAGE_PROPERTY_ID propertyId;

    PVOID senseData = NULL;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT event;

    PPRINTER_DATA printerData = NULL;
    GUID * printerGuid;
    HANDLE hInterfaceKey;

    UCHAR rawString[256];
    PUCHAR vendorId, productId;

    ULONG timeOut;
    NTSTATUS status;
    PSBP2_REQUEST sbp2Request = NULL;

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                      SENSE_BUFFER_SIZE,
                                      PRINTER_TAG);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    //
    // Build the lookaside list for srb'. Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension), PRINTER_SRB_LIST_SIZE);

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    //
    // printers are not partitionable so starting offset is 0.
    //

    fdoExtension->CommonExtension.StartingOffset.LowPart = 0;
    fdoExtension->CommonExtension.StartingOffset.HighPart = 0;

    //
    // Set timeout value in seconds.
    //

    timeOut = ClassQueryTimeOutRegistryValue(Fdo);
    if (timeOut) {
        fdoExtension->TimeOutValue = timeOut;
    } else {
        fdoExtension->TimeOutValue = PRINTER_TIMEOUT;
    }

    printerData = (PPRINTER_DATA)(fdoExtension->CommonExtension.DriverData);

    KeInitializeSpinLock(&printerData->SplitRequestSpinLock);

    //
    // Call port driver to get adapter capabilities.
    //

    propertyId = StorageAdapterProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->AdapterDescriptor));

    if(!NT_SUCCESS(status)) {
        DEBUGPRINT1(( "PrinterStartDevice: unable to retrieve adapter descriptor "
                       "[%#08lx]\n", status));

        ExFreePool(senseData);
        return status;
    }

    //
    // Call port driver to get device capabilities.
    //

    propertyId = StorageDeviceProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->DeviceDescriptor));

    if(!NT_SUCCESS(status)) {
        DEBUGPRINT1(( "PrinterStartAddDevice: unable to retrieve device descriptor "
                       "[%#08lx]\n", status));

        ExFreePool(senseData);
        return status;
    }

    if (printerData->DeviceIdString == NULL) {

        printerData->DeviceIdString = ExAllocatePool(PagedPool,256);

        if (!printerData->DeviceIdString) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {

            //
            // to retrieve the model/vendor id from the port driver below, send a queryId
            // to our PDO
            //

            sbp2Request = ExAllocatePool(NonPagedPool,sizeof(SBP2_REQUEST));
            if (sbp2Request == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            irp = IoAllocateIrp((CCHAR)(Fdo->StackSize), FALSE);

            if (irp == NULL) {
                DEBUGPRINT1(("PrinterQueryId: Can't allocate irp\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlZeroMemory(sbp2Request,sizeof(SBP2_REQUEST));

            //
            // set the sbp2 api call
            //

            sbp2Request->RequestNumber = SBP2_REQUEST_RETRIEVE_TEXT_LEAFS;
            sbp2Request->u.RetrieveTextLeaf.fulFlags |= SBP2REQ_RETRIEVE_TEXT_LEAF_INDIRECT;
            sbp2Request->u.RetrieveTextLeaf.Key = 0x14; // LUN key, followed 0x81 key w/ 1284 ID

            //
            // Construct the IRP stack for the lower level driver.
            //

            irpStack = IoGetNextIrpStackLocation(irp);
            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SBP2_REQUEST;
            irpStack->Parameters.Others.Argument1  = sbp2Request;

            KeInitializeEvent(&event,
                              NotificationEvent,
                              FALSE);

            IoSetCompletionRoutine(irp,
                                   PrinterCompletionRoutine,
                                   &event,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            status = IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            if(!NT_SUCCESS(status) || !NT_SUCCESS(irp->IoStatus.Status) ||
                (sbp2Request->u.RetrieveTextLeaf.Buffer == NULL)) {

                status = irp->IoStatus.Status;
                DEBUGPRINT1(("PrinterStartDevice: 1284 retrieve failed status %xx\n",status));
                sprintf(printerData->DeviceIdString,"1394 Printer");

            } else {

                //
                // A pointer to the 1284 id TEXTUAL_LEAF is now stored in the
                // sbp2Request->u.RetrieveTextLeaf.Buffer field.
                //
                // We want to make sure it's NULL terminated before we parse
                // it, so we'll move contents of TL_Data (the actual string)
                // back to the front of the buffer (overwriting all existing
                // TL_Xxx fields), then zero the following 4 bytes.
                //
                // Note that sbp2Req->u.RetrTextLeaf.ulLength is the size in
                // bytes of the entire leaf & data, minus the TL_CRC and
                // TL_Length fields.
                //

                RtlMoveMemory(
                    sbp2Request->u.RetrieveTextLeaf.Buffer,
                    ((PUCHAR) sbp2Request->u.RetrieveTextLeaf.Buffer +
                        FIELD_OFFSET(TEXTUAL_LEAF,TL_Data)),
                    sbp2Request->u.RetrieveTextLeaf.ulLength -
                        2 * sizeof (ULONG)  // TL_Spec_Id & TL_Lang_Id fields
                    );

                *((PULONG) ((PUCHAR) sbp2Request->u.RetrieveTextLeaf.Buffer +
                    sbp2Request->u.RetrieveTextLeaf.ulLength -
                    2 * sizeof (ULONG))) = 0;

                status  = PrinterGetId(sbp2Request->u.RetrieveTextLeaf.Buffer,BusQueryDeviceID,rawString,NULL);

                if (!NT_SUCCESS(status)) {

                    sprintf(printerData->DeviceIdString,"1394 Printer");
                    status = STATUS_SUCCESS;

                } else {

                    RtlCopyMemory(printerData->DeviceIdString,rawString,256);

                }

                ExFreePool(sbp2Request->u.RetrieveTextLeaf.Buffer);

            }

            IoFreeIrp(irp);
            ExFreePool(sbp2Request);

            //
            // register with the pnp GUID so the pnp printer port enumerator loads and finds us...
            //

            printerGuid=(GUID *)&PNPPRINT_GUID;
            status=IoRegisterDeviceInterface(fdoExtension->LowerPdo,printerGuid,NULL,&printerData->UnicodeDeviceString);

            if (NT_SUCCESS(status)) {
                status=IoSetDeviceInterfaceState(&printerData->UnicodeDeviceString,TRUE);

                if (!NT_SUCCESS(status)) {
                    DEBUGPRINT1(("PrinterStartDevice: Failed setting interfaceState %x\n",status));
                    return status;
                }

            } else {
                printerData->UnicodeDeviceString.Buffer = NULL;
            }

            //
            // retrieve available port number and write it in our registry key..
            // the key is closed in GetPortNumber
            //

            status = IoOpenDeviceInterfaceRegistryKey(&printerData->UnicodeDeviceString,KEY_ALL_ACCESS,&hInterfaceKey);

            if (NT_SUCCESS(status)) {
                status = GetPortNumber(hInterfaceKey, &printerData->UnicodeDeviceString, &printerData->PortNumber);
            } else {
                DEBUGPRINT1(("PrinterStartDevice Failed opening registry key%x\n",status));
            }

        } else {

            vendorId = (PUCHAR) fdoExtension->DeviceDescriptor + fdoExtension->DeviceDescriptor->VendorIdOffset;
            productId = (PUCHAR) fdoExtension->DeviceDescriptor + fdoExtension->DeviceDescriptor->ProductIdOffset;

            printerData->PortNumber = fdoExtension->DeviceNumber;
            sprintf(printerData->DeviceIdString,"Printer&Ven_%s&Prod_%s",
                    vendorId,
                    productId);


        }

    }

    //
    // If this is a 1394 printer then we want to enable blocking
    // writes by default (to keep USBMON.DLL happy)
    //

    if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {

        printerData->WriteCompletionRoutine = PrinterWriteComplete;

        KeInitializeTimer (&printerData->Timer);

        KeInitializeDpc(
            &printerData->TimerDpc,
            PrinterWriteTimeoutDpc,
            fdoExtension
            );

    } else {

        printerData->WriteCompletionRoutine = ClassIoComplete;
    }

    ClassUpdateInformationInRegistry(Fdo, "LPT", printerData->LptNumber, NULL, 0);
    return status;

} // end PrinterStartDevice()


NTSTATUS
GetPortNumber(
    HANDLE hFdoKey,
    PUNICODE_STRING fdoUnicodeString,
    PULONG ulReturnNumber
    )

{
    UCHAR buf[sizeof (KEY_VALUE_PARTIAL_INFORMATION) + sizeof (ULONG)];

    PWSTR pDeviceList;
    PWSTR pWalkDevice;
    HANDLE hInterfaceKey;

    UCHAR baseNameString[32];
    ANSI_STRING ansiBaseNameString;

    UNICODE_STRING uncValueName,uncLinkName,uncBaseNameValueName;
    UNICODE_STRING uncBaseName, uncRecyclableValueName;
    UNICODE_STRING uncPortDescription, uncPortDescriptionValueName;

    ULONG dwPortNum;
    ULONG ulSizeUsed;
    ULONG i;

    ULONG ulPortNumber=0;
    UCHAR portArray[MAX_NUM_PRINTERS] ;


    NTSTATUS status=STATUS_SUCCESS;
    NTSTATUS qStatus;

    PKEY_VALUE_PARTIAL_INFORMATION valueStruct;
    GUID *printerGuid = (GUID *) &PNPPRINT_GUID;


    for (i=0;i<MAX_NUM_PRINTERS;i++) {
        portArray[i] = 0;
    }

    RtlInitUnicodeString(&uncValueName,PORT_NUM_VALUE_NAME);

    RtlInitUnicodeString(&uncBaseName,BASE_1394_PORT_NAME);
    RtlInitUnicodeString(&uncBaseNameValueName,BASE_PORT_NAME_VALUE_NAME);
    RtlInitUnicodeString(&uncRecyclableValueName,RECYCLABLE_VALUE_NAME);
    RtlInitUnicodeString(&uncPortDescription,BASE_PORT_DESCRIPTION);
    RtlInitUnicodeString(&uncPortDescriptionValueName,BASE_PORT_DESCRIPTION_VALUE_NAME);

    ulSizeUsed = sizeof (buf); //this is a byte to much.  Oh well
    valueStruct = (PKEY_VALUE_PARTIAL_INFORMATION) buf;

    //
    // first check if our own key, has already a port value..
    //

    status=ZwQueryValueKey(hFdoKey,&uncValueName,KeyValuePartialInformation,(PVOID)valueStruct,ulSizeUsed,&ulSizeUsed);

    if (NT_SUCCESS(status)) {

        DEBUGPRINT1(("\'PRINTER:GetPortNumber: Found existing port in our Own key\n"));
        ulPortNumber=*((ULONG *)&(valueStruct->Data));
        ZwClose(hFdoKey);

    } else {

        ZwClose (hFdoKey);

        //
        // search the registry for all ports present. If you find a hole, take it
        // if no holes are found, take the next available slot
        //

        status=IoGetDeviceInterfaces(printerGuid,NULL,DEVICE_INTERFACE_INCLUDE_NONACTIVE,&pDeviceList);

        if (!NT_SUCCESS(status)) {
            DEBUGPRINT1(("\'PRINTER:GetPortNumber: Failed to retrive interfaces\n"));
            return status;
        }

        pWalkDevice=pDeviceList;

        while((*pWalkDevice!=0) && (NT_SUCCESS(status))) {

            RtlInitUnicodeString(&uncLinkName,pWalkDevice);

            if (!RtlCompareUnicodeString(fdoUnicodeString,&uncLinkName,FALSE)) {

                //
                // this key is the same as ours, skip it
                //

                pWalkDevice=pWalkDevice+wcslen(pWalkDevice)+1;
                continue;

            }

            status=IoOpenDeviceInterfaceRegistryKey(&uncLinkName,KEY_ALL_ACCESS,&hInterfaceKey);

            if (NT_SUCCESS(status)) {

                qStatus = ZwQueryValueKey(hInterfaceKey,&uncValueName,KeyValuePartialInformation,valueStruct,ulSizeUsed,&ulSizeUsed);

                if (NT_SUCCESS(qStatus)) {

                    dwPortNum = *((ULONG *)&(valueStruct->Data));

                    qStatus = ZwQueryValueKey(hInterfaceKey,&uncRecyclableValueName,KeyValuePartialInformation,valueStruct,ulSizeUsed,&ulSizeUsed);
                    if (!NT_SUCCESS(qStatus)) {

                        //
                        // port cant be recycled, mark as used so we dont try to grab it..
                        //

                        portArray[dwPortNum-1] = 1;

                    } else {

                        //
                        // port was marked recycled so we can reuse it..
                        //

                        DEBUGPRINT1(("\'GetPortNumber, Recyclable value found for port number %d\n",dwPortNum));

                    }

                }

            }

            pWalkDevice=pWalkDevice+wcslen(pWalkDevice)+1;
            ZwClose(hInterfaceKey);
        }

        ExFreePool(pDeviceList);

        //
        // now find the first hole, and use that port number as our port...
        //

        for (i=0;i<MAX_NUM_PRINTERS;i++) {
            if (portArray[i]) {

                ulPortNumber++;

            } else {

                ulPortNumber++;
                break;
            }
        }

        status = IoOpenDeviceInterfaceRegistryKey(fdoUnicodeString,KEY_ALL_ACCESS,&hFdoKey);
        if (NT_SUCCESS(status)) {

            //
            // write the new port we just found under our FDO reg key..
            //

            status=ZwSetValueKey(hFdoKey,&uncValueName,0,REG_DWORD,&ulPortNumber,sizeof(ulPortNumber));
            DEBUGPRINT1(("\'GetPortNumber, setting port number %d in fdo key status %x\n",ulPortNumber,status));

            //
            // also write our base port name
            //

            if (NT_SUCCESS(status)) {

                status=ZwSetValueKey(hFdoKey,
                                     &uncBaseNameValueName,
                                     0,REG_SZ,
                                     uncBaseName.Buffer,
                                     uncBaseName.Length);

                DEBUGPRINT1(("\'GetPortNumber, setting port name in fdo key status %x\n",status));

            }

            //
            // write out our port description
            //

            if (NT_SUCCESS(status)) {

                status=ZwSetValueKey(hFdoKey,
                                     &uncPortDescriptionValueName,
                                     0,REG_SZ,
                                     uncPortDescription.Buffer,
                                     uncPortDescription.Length);

                DEBUGPRINT1(("\'GetPortNumber, setting port description in fdo key status %x\n",status));

            }


            ZwClose(hFdoKey);

        }

    }

    DEBUGPRINT1(("\'GetPortNumber, grabbing port %d\n",ulPortNumber));
    *ulReturnNumber = ulPortNumber;

    return status;

}



NTSTATUS
PrinterInitPdo(
    IN PDEVICE_OBJECT Fdo
    )
{

    return STATUS_SUCCESS;
}



NTSTATUS
PrinterStartPdo(
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine will create the well known names for a PDO and register
    it's device interfaces.

--*/

{
    return STATUS_SUCCESS;
}



NTSTATUS
PrinterEnumerateDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called by the class driver to update the PDO list off
    of this FDO.

    Since we always only have one static PDO, this is pretty simple..

Arguments:

    Fdo - a pointer to the FDO being re-enumerated

Return Value:

    status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PPHYSICAL_DEVICE_EXTENSION pdoExtension = NULL;

    PDEVICE_OBJECT pdo = NULL;

    ULONG numberListElements = 0;

    NTSTATUS status;

    ASSERT(commonExtension->IsFdo);

    PAGED_CODE();

    if (fdoExtension->AdapterDescriptor == NULL) {

        //
        // device removed..
        //

        return STATUS_UNSUCCESSFUL;
    }

    if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {

        if(fdoExtension->CommonExtension.ChildList == NULL) {

            DebugPrint((1, "PrinterEnumerateDevice: Creating PDO\n"));

            status = PrinterCreatePdo(Fdo, &pdo);

        } else {
            status = STATUS_SUCCESS;
        }

    } else {

        status = STATUS_NOT_SUPPORTED;

    }

    return status;

} // end printerEnumerateDevice()


NTSTATUS
PrinterCreatePdo(
    IN PDEVICE_OBJECT Fdo,
    OUT PDEVICE_OBJECT *Pdo
    )

/*++

Routine Description:

    This routine will create and initialize a new device object
    (PDO) and insert it into the FDO partition list.
    Note that the PDO is actually never used. We create so the printer class
    installer will run after the LPTENUM ids for this PDO were matched to the
    printer inf..

Arguments:

    Fdo - a pointer to the functional device object this PDO will be a child
          of

    Pdo - a location to store the pdo pointer upon successful completion

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;

    PDEVICE_OBJECT pdo = NULL;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension = NULL;
    PPRINTER_DATA printerData = fdoExtension->CommonExtension.DriverData;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugPrint((2, "PrinterCreatePdo: Create device object %s\n",
                   printerData->DeviceName));

    status = ClassCreateDeviceObject(Fdo->DriverObject,
                                     printerData->DeviceName,
                                     Fdo,
                                     FALSE,
                                     &pdo);

    if (!NT_SUCCESS(status)) {

        DebugPrint((1, "printerEnumerateDevice: Can't create device object for %s\n", printerData->DeviceName));

        return status;
    }

    //
    // Set up device extension fields.
    //

    pdoExtension = pdo->DeviceExtension;
    commonExtension = pdo->DeviceExtension;

    //
    // Set up device object fields.
    //

    pdo->Flags |= DO_DIRECT_IO;

    pdo->StackSize = (CCHAR)
        commonExtension->LowerDeviceObject->StackSize + 1;

    pdoExtension->IsMissing = FALSE;

    commonExtension->DeviceObject = pdo;
    commonExtension->PartitionZeroExtension = fdoExtension;

    pdo->Flags &= ~DO_DEVICE_INITIALIZING;

    *Pdo = pdo;

    return status;
}

NTSTATUS
PrinterStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    DEBUGPRINT2((
        "SCSIPRNT: PrinterStopDevice: DevObj=x%p, Type=%d\n",
        DeviceObject,
        (ULONG) Type
        ));

    return STATUS_SUCCESS;
}


NTSTATUS
PrinterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    driver and shutting down it's timer routine.  This routine is called
    when all outstanding requests have been completed and the device has
    disappeared - no requests may be issued to the lower drivers.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension =
        DeviceObject->DeviceExtension;

    PPRINTER_DATA printerData = deviceExtension->CommonExtension.DriverData;


    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }

    if (commonExtension->IsFdo) {

        if (printerData->DeviceIdString) {
            ExFreePool(printerData->DeviceIdString);
            printerData->DeviceIdString = NULL;
        }

        if (deviceExtension->DeviceDescriptor) {
            ExFreePool(deviceExtension->DeviceDescriptor);
            deviceExtension->DeviceDescriptor = NULL;
        }

        if (deviceExtension->AdapterDescriptor) {
            ExFreePool(deviceExtension->AdapterDescriptor);
            deviceExtension->AdapterDescriptor = NULL;
        }

        if (deviceExtension->SenseData) {
            ExFreePool(deviceExtension->SenseData);
            deviceExtension->SenseData = NULL;
        }

        if (printerData->UnicodeLinkName.Buffer != NULL ) {

            IoDeassignArcName(&printerData->UnicodeLinkName);
            RtlFreeUnicodeString(&printerData->UnicodeLinkName);
            printerData->UnicodeLinkName.Buffer = NULL;
        }

        if (printerData->UnicodeDeviceString.Buffer != NULL ) {
            IoSetDeviceInterfaceState(&printerData->UnicodeDeviceString,FALSE);
            RtlFreeUnicodeString(&printerData->UnicodeDeviceString);
            printerData->UnicodeDeviceString.Buffer = NULL;
        }

        ClassDeleteSrbLookasideList(commonExtension);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PrinterQueryId(
    IN PDEVICE_OBJECT Pdo,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING UnicodeIdString
    )

{
    ANSI_STRING ansiIdString;
    UCHAR rawString[256];
    UCHAR finalString[256];

    NTSTATUS status;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Pdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;


    PPRINTER_DATA printerData;


    PAGED_CODE();
    ASSERT_PDO(Pdo);

    fdoExtension = commonExtension->PartitionZeroExtension;

    RtlZeroMemory(rawString,256);
    RtlZeroMemory(finalString,256);

    //
    // FDOs printer data
    //

    printerData = fdoExtension->CommonExtension.DriverData;

    if(IdType == BusQueryDeviceID) {

        if (fdoExtension->AdapterDescriptor->BusType != BusType1394) {

            sprintf(finalString,"SCSI\\%s",printerData->DeviceIdString);

        } else {

            //
            // we want to fake our ids it so we use the legacy printing inf.
            //

            sprintf(finalString,"LPTENUM\\%s",printerData->DeviceIdString);

        }

        RtlCopyMemory(printerData->DeviceName,finalString,256);

        DEBUGPRINT1(("\'PrinterQueryId, DeviceId =%s\n",printerData->DeviceName));
        RtlInitAnsiString(&ansiIdString,finalString);

        return RtlAnsiStringToUnicodeString(UnicodeIdString, &ansiIdString, TRUE);
    }

    if(IdType == BusQueryInstanceID) {

        if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {
            sprintf(finalString,"1394_%03u",printerData->PortNumber);
        } else {
            sprintf(finalString,"SCSI%03u", printerData->PortNumber);
        }

        RtlInitAnsiString(&ansiIdString, finalString);

        return RtlAnsiStringToUnicodeString(UnicodeIdString, &ansiIdString, TRUE);
    }

    if((IdType == BusQueryHardwareIDs) || (IdType == BusQueryCompatibleIDs)) {

        sprintf(rawString,"%s",printerData->DeviceIdString);
        sprintf(finalString,"%s",printerData->DeviceIdString);

        if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {

            status  = PrinterGetId(printerData->DeviceIdString,IdType,rawString,NULL);

            if (IdType == BusQueryHardwareIDs) {

                PrinterRegisterPort(Pdo->DeviceExtension);

            }

            if (NT_SUCCESS(status)) {

                RtlZeroMemory(finalString,256);
                sprintf(finalString,"%s",rawString);

            }
        }

        DEBUGPRINT1(("\'PrinterQueryId, Combatible/Hw Id =%s\n",finalString));

        RtlInitAnsiString(&ansiIdString, finalString);

        UnicodeIdString->MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(&ansiIdString) + sizeof(UNICODE_NULL);

        UnicodeIdString->Buffer = ExAllocatePoolWithTag(PagedPool,
                                                        UnicodeIdString->MaximumLength,
                                                        PRINTER_TAG);

        if(UnicodeIdString->Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(UnicodeIdString->Buffer, UnicodeIdString->MaximumLength);

        return RtlAnsiStringToUnicodeString(UnicodeIdString,
                                            &ansiIdString,
                                            FALSE);


    }

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
PrinterCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
PrinterQueryPnpCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Capabilities);

    if(commonExtension->IsFdo) {
        return STATUS_NOT_IMPLEMENTED;
    } else {

        Capabilities->RawDeviceOK = 1;
        Capabilities->SurpriseRemovalOK = 1;

    }

    return STATUS_SUCCESS;
}


VOID
PrinterRegisterPort(
    IN PPHYSICAL_DEVICE_EXTENSION DeviceExtension
    )
{

    HANDLE          KeyHandle;
    UCHAR           RawString[256];
    ANSI_STRING     AnsiIdString;
    NTSTATUS        status;
    UNICODE_STRING  UnicodeTemp;
    UNICODE_STRING  UnicodeRegValueName;
    PCOMMON_DEVICE_EXTENSION commonExtension = &DeviceExtension->CommonExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =
        commonExtension->PartitionZeroExtension;

    PDEVICE_OBJECT deviceObject = DeviceExtension->DeviceObject;

    PPRINTER_DATA printerData = fdoExtension->CommonExtension.DriverData;

    //
    // register with the printer guid and create a Port value in the registry
    // for talking to this printer (legacy junk, because the spooler expects it..)
    //

    status = IoOpenDeviceRegistryKey (deviceObject,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      KEY_ALL_ACCESS,
                                      &KeyHandle );

    if (NT_SUCCESS(status)) {

        //
        // Create a new value under our instance, for the port number
        //

        sprintf(RawString,"PortName");
        RtlInitAnsiString(&AnsiIdString,RawString);
        RtlAnsiStringToUnicodeString(&UnicodeRegValueName,&AnsiIdString,TRUE);

        if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {
            sprintf(RawString,"1394_%03u",printerData->PortNumber);
        } else {
            sprintf(RawString,"SCSI%03u",printerData->PortNumber);
        }

        RtlInitAnsiString(&AnsiIdString,RawString);
        RtlAnsiStringToUnicodeString(&UnicodeTemp,&AnsiIdString,TRUE);

        status = ZwSetValueKey(KeyHandle,
                      &UnicodeRegValueName,
                      0,
                      REG_SZ,
                      UnicodeTemp.Buffer,
                      UnicodeTemp.Length*sizeof(UCHAR));

        ZwClose(KeyHandle);

        RtlFreeUnicodeString(&UnicodeRegValueName);
        RtlFreeUnicodeString(&UnicodeTemp);

    }

}


NTSTATUS
PrinterGetId
(
    IN PUCHAR DeviceIdString,
    IN ULONG Type,
    OUT PUCHAR resultString,
    OUT PUCHAR descriptionString
)
/*
    Description:

        Creates Id's from the device id retrieved from the printer

    Parameters:

        DeviceId - String with raw device id
        Type - What of id we want as a result
        Id - requested id

    Return Value:
        NTSTATUS

*/
{
    NTSTATUS status;
    USHORT          checkSum=0;                     // A 16 bit check sum
    UCHAR           nodeName[16] = "LPTENUM\\";
    // The following are used to generate sub-strings from the Device ID string
    // to get the DevNode name, and to update the registry
    PUCHAR          MFG = NULL;                   // Manufature name
    PUCHAR          MDL = NULL;                   // Model name
    PUCHAR          CLS = NULL;                   // Class name
    PUCHAR          AID = NULL;                   // Hardare ID
    PUCHAR          CID = NULL;                   // Compatible IDs
    PUCHAR          DES = NULL;                   // Device Description

    status = STATUS_SUCCESS;

    switch(Type) {

    case BusQueryDeviceID:

        // Extract the usefull fields from the DeviceID string.  We want
        // MANUFACTURE (MFG):
        // MODEL (MDL):
        // AUTOMATIC ID (AID):
        // COMPATIBLE ID (CID):
        // DESCRIPTION (DES):
        // CLASS (CLS):

        PrinterFindDeviceIdKeys(&MFG, &MDL, &CLS, &DES, &AID, &CID, DeviceIdString);

        // Check to make sure we got MFG and MDL as absolute minimum fields.  If not
        // we cannot continue.
        if (!MFG || !MDL)
        {
            status = STATUS_NOT_FOUND;
            goto GetId_Cleanup;
        }
        //
        // Concatenate the provided MFG and MDL P1284 fields
        // Checksum the entire MFG+MDL string
        //
        sprintf(resultString, "%s%s\0",MFG,MDL);

        if (descriptionString) {
            sprintf(descriptionString, "%s %s\0",MFG,MDL);
        }

        break;

    case BusQueryHardwareIDs:

        GetCheckSum(DeviceIdString, (USHORT)strlen(DeviceIdString), &checkSum);
        sprintf(resultString,"%s%.20s%4X",nodeName,DeviceIdString,checkSum);
        break;

    case BusQueryCompatibleIDs:

        //
        // return only 1 id
        //
        GetCheckSum(DeviceIdString, (USHORT)strlen(DeviceIdString), &checkSum);
        sprintf(resultString,"%.20s%4X",DeviceIdString,checkSum);

        break;
    }

    if (Type!=BusQueryDeviceID) {

        //
        // Convert and spaces in the Hardware ID to underscores
        //
        StringSubst ((PUCHAR) resultString, ' ', '_', (USHORT)strlen(resultString));
    }

GetId_Cleanup:

    return(status);
}

VOID
PrinterFindDeviceIdKeys
(
    PUCHAR   *lppMFG,
    PUCHAR   *lppMDL,
    PUCHAR   *lppCLS,
    PUCHAR   *lppDES,
    PUCHAR   *lppAID,
    PUCHAR   *lppCID,
    PUCHAR   lpDeviceID
)
/*

    Description:
        This function will parse a P1284 Device ID string looking for keys
        of interest to the LPT enumerator. Got it from win95 lptenum

    Parameters:
        lppMFG      Pointer to MFG string pointer
        lppMDL      Pointer to MDL string pointer
        lppMDL      Pointer to CLS string pointer
        lppDES      Pointer to DES string pointer
        lppCIC      Pointer to CID string pointer
        lppAID      Pointer to AID string pointer
        lpDeviceID  Pointer to the Device ID string

    Return Value:
        no return VALUE.
        If found the lpp parameters are set to the approprate portions
        of the DeviceID string, and they are NULL terminated.
        The actual DeviceID string is used, and the lpp Parameters just
        reference sections, with appropriate null thrown in.

*/

{
    PUCHAR   lpKey = lpDeviceID;     // Pointer to the Key to look at
    PUCHAR   lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.

    lpValue = StringChr(lpKey, '&');
    if (lpValue) {
        ++lpValue;
        lpKey = lpValue;
    }

    while (lpKey != NULL)
    {
        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?

        if (!(lpValue = StringChr(lpKey, ':')) )
        {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON

        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //

        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //

        switch (*lpKey)
        {
            case 'M':
                // Look for MANUFACTURE (MFG) or MODEL (MDL)
                if ((RtlCompareMemory(lpKey, "MANUFACTURER", wKeyLength)>5) ||
                    (RtlCompareMemory(lpKey, "MFG", wKeyLength)==3) )
                {
                    *lppMFG = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=NULL)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else if ((RtlCompareMemory(lpKey, "MODEL", wKeyLength)==5) ||
                         (RtlCompareMemory(lpKey, "MDL", wKeyLength)==3) )
                {
                    *lppMDL = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'C':
                // Look for CLASS (CLS)
                if ((RtlCompareMemory(lpKey, "CLASS", wKeyLength)==5) ||
                    (RtlCompareMemory(lpKey, "CLS", wKeyLength)==3) )
                {
                    *lppCLS = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else if ((RtlCompareMemory(lpKey, "COMPATIBLEID", wKeyLength)>5) ||
                         (RtlCompareMemory(lpKey, "CID", wKeyLength)==3) )
                {
                    *lppCID = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue,';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'D':
                // Look for DESCRIPTION (DES)
                if (RtlCompareMemory(lpKey, "DESCRIPTION", wKeyLength) ||
                    RtlCompareMemory(lpKey, "DES", wKeyLength) )
                {
                    *lppDES = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'A':
                // Look for AUTOMATIC ID (AID)
                if (RtlCompareMemory(lpKey, "AUTOMATICID", wKeyLength) ||
                    RtlCompareMemory(lpKey, "AID", wKeyLength) )
                {
                    *lppAID = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            default:
                // The key is uninteresting.  Go to the next Key
                if ((lpKey = StringChr(lpValue, ';'))!=0)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
                break;
        }
    }
}


VOID
GetCheckSum(
    PUCHAR Block,
    USHORT Len,
    PUSHORT CheckSum
    )
{
    USHORT i;
    UCHAR lrc;
    USHORT crc = 0;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    //
    // Calculate CRC using tables.
    //

    UCHAR tmp;
    for ( i=0; i<Len;  i++) {
         tmp = Block[i] ^ (UCHAR)crc;
         crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
    }

    *CheckSum = crc;

}

PUCHAR
StringChr(PCHAR string, CHAR c)
{
    ULONG   i=0;

    if (!string)
        return(NULL);

    while (*string) {
        if (*string==c)
            return(string);
        string++;
        i++;
    }

    return(NULL);

}



VOID
StringSubst
(
    PUCHAR lpS,
    UCHAR chTargetChar,
    UCHAR chReplacementChar,
    USHORT cbS
)
{
    USHORT  iCnt = 0;

    while ((lpS != '\0') && (iCnt++ < cbS))
        if (*lpS == chTargetChar)
            *lpS++ = chReplacementChar;
        else
            ++lpS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiwmi\wmilib.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    wmilib.c

Abstract:

    WMI library utility functions for SCSI miniports

    CONSIDER adding the following functionality to the library:
        * Dynamic instance names
        * Different instance names for different guids

Author:

    AlanWar

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "miniport.h"
#include "scsi.h"
#include "wmistr.h"
#include "scsiwmi.h"

typedef enum
{
    ScsiProcessed,    // Srb was processed and possibly completed
    ScsiNotCompleted, // Srb was process and NOT completed
    ScsiNotWmi,       // Srb is not a WMI irp
    ScsiForward       // Srb is wmi irp, but targeted at another device object
} SYSCTL_SCSI_DISPOSITION, *PSYSCTL_SCSI_DISPOSITION;


BOOLEAN
ScsiWmipFindGuid(
    IN PSCSIWMIGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    );

BOOLEAN
ScsiWmipFindGuid(
    IN PSCSIWMIGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid

    *InstanceCount returns the count of instances for the guid

Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, GuidList[i].Guid))
        {
            *GuidIndex = i;
            *InstanceCount = GuidList[i].InstanceCount;
            return(TRUE);
        }
    }

    return(FALSE);
}


UCHAR ScsiWmipPostProcess(
    IN UCHAR MinorFunction,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG BufferUsed,
    IN UCHAR Status,
    OUT PULONG ReturnSize
    )
{    
    ULONG retSize;
    ULONG bufferNeeded;

    switch(MinorFunction)
    {
        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;
            ULONG instanceCount;
            POFFSETINSTANCEDATAANDLENGTH offsetInstanceDataAndLength;
            ULONG i;
            PULONG instanceLengthArray;
            ULONG dataBlockOffset;

            wnode = (PWNODE_ALL_DATA)Buffer;

            dataBlockOffset = wnode->DataBlockOffset;
            instanceCount = wnode->InstanceCount;
            bufferNeeded = dataBlockOffset + BufferUsed;

            if ((Status == SRB_STATUS_SUCCESS) &&
                (bufferNeeded > BufferSize))
            {
                Status = SRB_STATUS_DATA_OVERRUN;
            }
        
            if (Status != SRB_STATUS_SUCCESS)
            {
                if (Status == SRB_STATUS_DATA_OVERRUN)
                {
                    wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                    wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                    wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                    wnodeTooSmall->SizeNeeded = bufferNeeded;

                    retSize = sizeof(WNODE_TOO_SMALL);
                    Status = SRB_STATUS_SUCCESS;
                } else {
                    retSize = 0;
                }
                break;
            }

            instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
            offsetInstanceDataAndLength = (POFFSETINSTANCEDATAANDLENGTH)instanceLengthArray;

            wnode->WnodeHeader.BufferSize = bufferNeeded;
            retSize = bufferNeeded;

            for (i = instanceCount; i != 0; i--)
            {
                offsetInstanceDataAndLength[i-1].LengthInstanceData = instanceLengthArray[i-1];
            }

            for (i = 0; i < instanceCount; i++)
            {
                offsetInstanceDataAndLength[i].OffsetInstanceData = dataBlockOffset;
                dataBlockOffset = (dataBlockOffset + offsetInstanceDataAndLength[i].LengthInstanceData + 7) & ~7;
            }

            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_SINGLE_INSTANCE)Buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (Status == SRB_STATUS_SUCCESS)
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;

                ASSERT(wnode->SizeDataBlock == BufferUsed);

            } else if (Status == SRB_STATUS_DATA_OVERRUN) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = SRB_STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_METHOD_ITEM)Buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (Status == SRB_STATUS_SUCCESS)
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                wnode->SizeDataBlock = BufferUsed;

            } else if (Status == SRB_STATUS_DATA_OVERRUN) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = SRB_STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        default:
        {
            //
            // All other requests don't return any data
            retSize = 0;
            break;
        }
    }
    *ReturnSize = retSize;
    return(Status);
}
    

VOID
ScsiPortWmiPostProcess(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN UCHAR Status,
    IN ULONG BufferUsed
    )
{    
    ASSERT(RequestContext != NULL);
    RequestContext->ReturnStatus = ScsiWmipPostProcess(
                                        RequestContext->MinorFunction,
                                        RequestContext->Buffer,
                                        RequestContext->BufferSize,
                                        BufferUsed,
                                        Status,
                                        &RequestContext->ReturnSize);
}
       

UCHAR 
ScsiWmipProcessRequest(
    IN PSCSI_WMILIB_CONTEXT WmiLibInfo,
    IN UCHAR MinorFunction,
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN PUCHAR Buffer,
    OUT PULONG ReturnSize,
    OUT PSYSCTL_SCSI_DISPOSITION IrpDisposition
    )
{
    UCHAR status;
    ULONG retSize;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    ASSERT(MinorFunction <= IRP_MN_EXECUTE_METHOD);

    *IrpDisposition = ScsiProcessed;

    if (MinorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        ASSERT(WmiLibInfo->GuidList != NULL);
        if (ScsiWmipFindGuid(WmiLibInfo->GuidList,
                            WmiLibInfo->GuidCount,
                            (LPGUID)DataPath,
                            &guidIndex,
                            &instanceCount))
        {
            status = SRB_STATUS_SUCCESS;
        } else {
            status = SRB_STATUS_ERROR;
        }

        if ((status == SRB_STATUS_SUCCESS) &&
            ((MinorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
             (MinorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE) ||
             (MinorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
             (MinorFunction == IRP_MN_EXECUTE_METHOD)))
        {
            instanceIndex = ((PWNODE_SINGLE_INSTANCE)Buffer)->InstanceIndex;

            if ( (((PWNODE_HEADER)Buffer)->Flags) &
                                          WNODE_FLAG_STATIC_INSTANCE_NAMES)
            {
                if ( instanceIndex >= instanceCount )
                {
                    status = SRB_STATUS_ERROR;
                }
            } else {
                status = SRB_STATUS_ERROR;
            }
        }

        //
        // If we couldn't find the guid or the instance name index is out
        // of range then return an error.
        if (status != SRB_STATUS_SUCCESS)
        {
            *ReturnSize = 0;
            *IrpDisposition = ScsiNotCompleted;
            return(status);
        }
    }

    switch(MinorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PSCSIWMIGUIDREGINFO guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PWCHAR mofResourceName;
            PWCHAR stringPtr;
            ULONG mofResourceOffset;
            USHORT mofResourceSize;
            ULONG bufferNeeded;
            ULONG i;
            USHORT nameSize;
            ULONG nameOffset, nameFlags;
			USHORT mofResourceNameLen;
			
            //
            // Make sure that the required parts of the WMILIB_INFO structure
            // are filled in.
            ASSERT(WmiLibInfo->QueryWmiRegInfo != NULL);
            ASSERT(WmiLibInfo->QueryWmiDataBlock != NULL);

            status = WmiLibInfo->QueryWmiRegInfo(
                                                    Context,
                                                    RequestContext,
                                                    &mofResourceName);

            if (status == SRB_STATUS_SUCCESS)
            {
                ASSERT(WmiLibInfo->GuidList != NULL);

                guidList = WmiLibInfo->GuidList;
                guidCount = WmiLibInfo->GuidCount;

                nameOffset = sizeof(WMIREGINFO) +
                                      guidCount * sizeof(WMIREGGUIDW);
                                  
                nameFlags = WMIREG_FLAG_INSTANCE_BASENAME;
                nameSize = sizeof(L"ScsiMiniPort");

                mofResourceOffset = nameOffset + nameSize + sizeof(USHORT);
                if (mofResourceName == NULL)
                {
                    mofResourceSize = 0;
                } else {
                    mofResourceNameLen = 0;
                    while (mofResourceName[mofResourceNameLen] != 0)
					{
						mofResourceNameLen++;
					}
                    mofResourceSize = mofResourceNameLen * sizeof(WCHAR);
                }

                bufferNeeded = mofResourceOffset + mofResourceSize + sizeof(USHORT);

                if (bufferNeeded <= BufferSize)
                {
                    retSize = bufferNeeded;

                    wmiRegInfo = (PWMIREGINFO)Buffer;
                    wmiRegInfo->BufferSize = bufferNeeded;
                    wmiRegInfo->NextWmiRegInfo = 0;
                    wmiRegInfo->MofResourceName = mofResourceOffset;
                    wmiRegInfo->RegistryPath = 0;
                    wmiRegInfo->GuidCount = guidCount;

                    for (i = 0; i < guidCount; i++)
                    {
                        wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                        wmiRegGuid->Guid = *guidList[i].Guid;
                        wmiRegGuid->Flags = guidList[i].Flags | nameFlags;
                        wmiRegGuid->InstanceInfo = nameOffset;
                        wmiRegGuid->InstanceCount = guidList[i].InstanceCount;
                    }

                    stringPtr = (PWCHAR)((PUCHAR)Buffer + nameOffset);
                    *stringPtr++ = nameSize;
                    ScsiPortMoveMemory(stringPtr,
                                  L"ScsiMiniPort",
                                  nameSize);

                    stringPtr = (PWCHAR)((PUCHAR)Buffer + mofResourceOffset);
                    *stringPtr++ = mofResourceSize;
                    ScsiPortMoveMemory(stringPtr,
                                  mofResourceName,
                                  mofResourceSize);

                } else {
                    *((PULONG)Buffer) = bufferNeeded;
                    retSize = sizeof(ULONG);
                }
            } else {
                //  QueryWmiRegInfo failed
                retSize = 0;
            }

            *ReturnSize = retSize;
            *IrpDisposition = ScsiNotCompleted;
            return(status);
        }

        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            ULONG bufferAvail;
            PULONG instanceLengthArray;
            PUCHAR dataBuffer;
            ULONG instanceLengthArraySize;
            ULONG dataBlockOffset;

            wnode = (PWNODE_ALL_DATA)Buffer;

            if (BufferSize < sizeof(WNODE_ALL_DATA))
            {
                //
                // The buffer should never be smaller than the size of
                // WNODE_ALL_DATA, however if it is then return with an
                // error requesting the minimum sized buffer.
                ASSERT(FALSE);

                status = SRB_STATUS_ERROR;
                *IrpDisposition = ScsiNotCompleted;
                
                break;
            }

            wnode->InstanceCount = instanceCount;

            wnode->WnodeHeader.Flags &= ~WNODE_FLAG_FIXED_INSTANCE_SIZE;

            instanceLengthArraySize = instanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH);

            dataBlockOffset = (FIELD_OFFSET(WNODE_ALL_DATA, OffsetInstanceDataAndLength) + instanceLengthArraySize + 7) & ~7;

            wnode->DataBlockOffset = dataBlockOffset;
            if (dataBlockOffset <= BufferSize)
            {
                instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
                dataBuffer = Buffer + dataBlockOffset;
                bufferAvail = BufferSize - dataBlockOffset;
            } else {
                //
                // There is not enough room in the WNODE to complete
                // the query
                instanceLengthArray = NULL;
                dataBuffer = NULL;
                bufferAvail = 0;
            }

            status = WmiLibInfo->QueryWmiDataBlock(
                                             Context,
                                             RequestContext,
                                             guidIndex,
                                             0,
                                             instanceCount,
                                             instanceLengthArray,
                                             bufferAvail,
                                             dataBuffer);
                                         
            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            ULONG dataBlockOffset;

            wnode = (PWNODE_SINGLE_INSTANCE)Buffer;

            dataBlockOffset = wnode->DataBlockOffset;

            status = WmiLibInfo->QueryWmiDataBlock(
                                          Context,
                                          RequestContext,
                                          guidIndex,
                                          instanceIndex,
                                          1,
                                          &wnode->SizeDataBlock,
                                          BufferSize - dataBlockOffset,
                                          (PUCHAR)wnode + dataBlockOffset);

            break;
        }

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;

            if (WmiLibInfo->SetWmiDataBlock != NULL)
            {
                wnode = (PWNODE_SINGLE_INSTANCE)Buffer;

                status = WmiLibInfo->SetWmiDataBlock(
                                     Context,
                                     RequestContext,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->SizeDataBlock,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);
                                 
            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = SRB_STATUS_ERROR;
                *IrpDisposition = ScsiNotCompleted;
            }
            
            break;
        }

        case IRP_MN_CHANGE_SINGLE_ITEM:
        {
            PWNODE_SINGLE_ITEM wnode;

            if (WmiLibInfo->SetWmiDataItem != NULL)
            {
                wnode = (PWNODE_SINGLE_ITEM)Buffer;

                status = WmiLibInfo->SetWmiDataItem(
                                     Context,
                                     RequestContext,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->ItemId,
                                     wnode->SizeDataItem,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);

            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = SRB_STATUS_ERROR;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;

            if (WmiLibInfo->ExecuteWmiMethod != NULL)
            {
                wnode = (PWNODE_METHOD_ITEM)Buffer;

                status = WmiLibInfo->ExecuteWmiMethod(
                                         Context,
                                         RequestContext,
                                         guidIndex,
                                         instanceIndex,
                                         wnode->MethodId,
                                         wnode->SizeDataBlock,
                                         BufferSize - wnode->DataBlockOffset,
                                         Buffer + wnode->DataBlockOffset);
            } else {
                //
                // If method callback is not filled in then it must be error
                status = SRB_STATUS_ERROR;
                *IrpDisposition = ScsiNotCompleted;
            }

            break;
        }

        case IRP_MN_ENABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           Context,
                                                           RequestContext,
                                                           guidIndex,
                                                           ScsiWmiEventControl,
                                                           TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = SRB_STATUS_SUCCESS;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        case IRP_MN_DISABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           Context,
                                                           RequestContext,
                                                           guidIndex,
                                                           ScsiWmiEventControl,
                                                           FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = SRB_STATUS_SUCCESS;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         Context,
                                                         RequestContext,
                                                         guidIndex,
                                                         ScsiWmiDataBlockControl,
                                                         TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = SRB_STATUS_SUCCESS;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        case IRP_MN_DISABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         Context,
                                                         RequestContext,
                                                         guidIndex,
                                                         ScsiWmiDataBlockControl,
                                                         FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = SRB_STATUS_SUCCESS;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        default:
        {
            ASSERT(FALSE);
            status = SRB_STATUS_ERROR;
            *IrpDisposition = ScsiNotCompleted;
            break;
        }

    }

    return(status);
}

BOOLEAN
ScsiPortWmiDispatchFunction(
    IN PSCSI_WMILIB_CONTEXT WmiLibInfo,
    IN UCHAR MinorFunction,
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN PVOID Buffer
    )
/*++

Routine Description:

    Dispatch helper routine for WMI srb requests. Based on the Minor
    function passed the WMI request is processed and this routine 
    invokes the appropriate callback in the WMILIB structure.

Arguments:

    WmiLibInfo has the SCSI WMILIB information control block associated
        with the adapter or logical unit

    DeviceContext is miniport defined context value passed on to the callbacks
        invoked by this api.

    RequestContext is a pointer to a context structure that maintains 
        information about this WMI srb. This request context must remain 
        valid throughout the entire processing of the srb, at least until 
        ScsiPortWmiPostProcess returns with the final srb return status and 
        buffer size. If the srb can pend then memory for this buffer should 
        be allocated from the SRB extension. If not then the memory can be 
        allocated from a stack frame that does not go out of scope, perhaps 
        that of the caller to this api.

    DataPath is value passed in wmi request
    
    BufferSize is value passed in wmi request
        
    Buffer is value passed in wmi request

Return Value:

    TRUE if request is pending else FALSE

--*/
{
    UCHAR status;
    SYSCTL_SCSI_DISPOSITION irpDisposition;
    ULONG retSize;

    ASSERT(RequestContext != NULL);
    
    //
    // First ensure that the irp is a WMI irp
    if (MinorFunction > IRP_MN_EXECUTE_METHOD)
    {
        //
        // This is not a WMI irp, setup error return
        status = SRB_STATUS_ERROR;
        RequestContext->ReturnSize = 0;
        RequestContext->ReturnStatus = status;
    } else {
        //
        // Let SCSIWMI library have a crack at the SRB
        RequestContext->MinorFunction = MinorFunction;
        RequestContext->Buffer = Buffer;
        RequestContext->BufferSize = BufferSize;
        RequestContext->ReturnSize = 0;
        
        status = ScsiWmipProcessRequest(WmiLibInfo,
                                    MinorFunction,
                                    Context,
                                    RequestContext,
                                    DataPath,
                                    BufferSize,
                                    Buffer,
                                    &retSize,
                                    &irpDisposition);
                            
        
        if (irpDisposition == ScsiNotCompleted)
        {
            //
            // Some error occured while processing the SRB, for example
            // guid not found. Setup the returned error
            RequestContext->ReturnStatus = status;
            if (status != SRB_STATUS_SUCCESS)
            {
                retSize = 0;
            }
            RequestContext->ReturnSize = retSize;
        }        
    }
    return(status == SRB_STATUS_PENDING);
}

VOID
ScsiPortWmiFireLogicalUnitEvent(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    )
/*++

Routine Description:

    This routine will fire a WMI event using the data buffer passed. This
    routine may be called at or below DPC level

Arguments:

    HwDeviceExtension is the adapter device extension
        
    PathId identifies the SCSI bus if a logical unit is firing the event 
        or is 0xff if the adapter is firing the event.
        
    TargetId identifies the target controller or device on the bus
        
    Lun identifies the logical unit number of the target device

    Guid is pointer to the GUID that represents the event
        
    InstanceIndex is the index of the instance of the event
        
    EventDataSize is the number of bytes of data that is being fired with
       with the event. This size specifies the size of the event data only 
       and does NOT include the 0x40 bytes of preceeding padding.
           
    EventData is the data that is fired with the events. There must be exactly
        0x40 bytes of padding preceeding the event data.

Return Value:

--*/
{
    PWNODE_SINGLE_INSTANCE event;
    UCHAR status;

    ASSERT(EventData != NULL);

    event = (PWNODE_SINGLE_INSTANCE)EventData;

    event->WnodeHeader.Guid = *Guid;
    event->WnodeHeader.Flags =  WNODE_FLAG_SINGLE_INSTANCE |
                                    WNODE_FLAG_EVENT_ITEM |
                                    WNODE_FLAG_STATIC_INSTANCE_NAMES;
    event->WnodeHeader.Linkage = 0;
			    
    event->InstanceIndex = InstanceIndex;
    event->SizeDataBlock = EventDataSize;
    event->DataBlockOffset = 0x40;
    event->WnodeHeader.BufferSize = event->DataBlockOffset + 
                                    event->SizeDataBlock;
    
    if (PathId != 0xff)
    {
        ScsiPortNotification(WMIEvent,
	                     HwDeviceExtension,
	                     event,
                         PathId,
         			     TargetId,
        	     	     Lun);
    } else {
        ScsiPortNotification(WMIEvent,
	                     HwDeviceExtension,
	                     event,
                         PathId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiprnt\print.c ===
/*++

Copyright (C) 1992-9  Microsoft Corporation

Module Name:

    print.c

Abstract:

    The printer class driver tranlates IRPs to SRBs with embedded CDBs
    and sends them to its devices through the port driver.

Author:

    Mike Glass (mglass)

Environment:

    kernel mode only

Notes:

Revision History:

    georgioc - Made into a pnp class driver independent of the underlying storage bus
               using the new storage/classpnp

    dankn, 22-Jul-99 : Added ability to block & resubmit failed writes for
                       1394 printers to behave more like other print stacks
                       (i.e. USB) and therefore keep USBMON.DLL (the Win2k
                       port monitor) happy.  USBMON does not deal well
                       with failed writes.

--*/

#include "printpnp.h"
#include "ntddser.h"



NTSTATUS
PrinterOpenClose(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to establish a connection to the printer
    class driver. It does no more than return STATUS_SUCCESS.

Arguments:

    DeviceObject - Device object for a printer.
    Irp - Open or Close request packet

Return Value:

    NT Status - STATUS_SUCCESS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // forward irp.
    //

    ClassReleaseRemoveLock (Fdo, Irp);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    return IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, Irp);

} // end PrinterOpenClose()


NTSTATUS
BuildPrintRequest(
        PDEVICE_OBJECT Fdo,
        PIRP Irp
        )

/*++

Routine Description:

    Build SRB and CDB requests to scsi printer.

Arguments:

    DeviceObject - Device object representing this printer device.
    Irp - System IO request packet.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = Fdo->DeviceExtension;
    PIO_COMPLETION_ROUTINE completionRoutine;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    ULONG transferLength;

    //
    // Allocate Srb from nonpaged pool.
    // This call must succeed.
    //

    srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->SrbFlags = 0;

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up IRP Address.
    //

    srb->OriginalRequest = Irp;

    //
    // Set up target id and logical unit number.
    //

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    srb->DataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);

    //
    // Save byte count of transfer in SRB Extension.
    //

    srb->DataTransferLength = currentIrpStack->Parameters.Write.Length;

    //
    // Transfer length should never be greater than MAX_PRINT_XFER
    //

    ASSERT(srb->DataTransferLength <= MAX_PRINT_XFER);

    //
    // Initialize the queue actions field.
    //

    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;

    //
    // Queue sort key is not used.
    //

    srb->QueueSortKey = 0;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    srb->SenseInfoBuffer = deviceExtension->SenseData;

    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Set timeout value in seconds.
    //

    srb->TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Zero statuses.
    //

    srb->SrbStatus = srb->ScsiStatus = 0;

    srb->NextSrb = 0;

    //
    // Get number of bytes to transfer.
    //

    transferLength = currentIrpStack->Parameters.Write.Length;

    //
    // Get pointer to CDB in SRB.
    //

    cdb = (PCDB) srb->Cdb;

    //
    // Init 10-byte READ CDB's for reads (per scanner device READ spec
    // in SCSI-2), and 6-byte PRINT CDB's for writes
    //

    if (currentIrpStack->MajorFunction == IRP_MJ_READ) {

        srb->CdbLength = 10;
        srb->SrbFlags  = SRB_FLAGS_DATA_IN;

        RtlZeroMemory (cdb, 10);

        cdb->CDB10.OperationCode = SCSIOP_READ;

        //
        // Move little endian values into CDB in big endian format.
        //

        cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE) &transferLength)->Byte0;
        cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE) &transferLength)->Byte1;
        cdb->CDB10.Reserved2         = ((PFOUR_BYTE) &transferLength)->Byte2;

        //
        // For read's we always use the ClassIoComplete completion routine
        //

        completionRoutine = ClassIoComplete;

    } else {

        srb->CdbLength = 6;
        srb->SrbFlags  = SRB_FLAGS_DATA_OUT;

        cdb->PRINT.OperationCode = SCSIOP_PRINT;
        cdb->PRINT.Reserved = 0;
        cdb->PRINT.LogicalUnitNumber = 0;

        //
        // Move little endian values into CDB in big endian format.
        //

        cdb->PRINT.TransferLength[2] = ((PFOUR_BYTE) &transferLength)->Byte0;
        cdb->PRINT.TransferLength[1] = ((PFOUR_BYTE) &transferLength)->Byte1;
        cdb->PRINT.TransferLength[0] = ((PFOUR_BYTE) &transferLength)->Byte2;

        cdb->PRINT.Control = 0;

        //
        // Set the appropriate write/print completion routine
        //

        completionRoutine = ((PPRINTER_DATA) deviceExtension->
            CommonExtension.DriverData)->WriteCompletionRoutine;
    }

    //
    // Or in the default flags from the device object.
    //

    srb->SrbFlags |= deviceExtension->SrbFlags;

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = srb;

    //
    // Save retry count in current IRP stack.
    //

    currentIrpStack->Parameters.Others.Argument4 = (PVOID)MAXIMUM_RETRIES;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine(Irp, completionRoutine, srb, TRUE, TRUE, TRUE);

    return STATUS_SUCCESS;

} // end BuildPrintRequest()


NTSTATUS
PrinterReadWrite(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the entry called by the I/O system for print requests.
    It builds the SRB and sends it to the port driver.

Arguments:

    DeviceObject - the system object for the device.
    Irp - IRP involved.

Return Value:

    NT Status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = Fdo->DeviceExtension;

    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG transferByteCount = currentIrpStack->Parameters.Write.Length;
    ULONG maximumTransferLength;
    ULONG transferPages;
    NTSTATUS Status;

    DEBUGPRINT3(("PrinterReadWrite: Enter routine\n"));


    if (deviceExtension->AdapterDescriptor == NULL) {

        //
        // device removed..
        //

        DEBUGPRINT3(("PrinterReadWrite: Device removed(!!)\n"));

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Information = 0;

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    maximumTransferLength = deviceExtension->AdapterDescriptor->MaximumTransferLength;


    //
    // Calculate number of pages in this transfer.
    //

    transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                        MmGetMdlVirtualAddress(Irp->MdlAddress),
                        currentIrpStack->Parameters.Write.Length);

    //
    // Check if hardware maximum transfer length is larger than SCSI
    // print command can handle.  If so, lower the maximum allowed to
    // the SCSI print maximum.
    //

    if (maximumTransferLength > MAX_PRINT_XFER)
        maximumTransferLength = MAX_PRINT_XFER;

    //
    // Check if request length is greater than the maximum number of
    // bytes that the hardware can transfer.
    //

    if (currentIrpStack->Parameters.Write.Length > maximumTransferLength ||
        transferPages > deviceExtension->AdapterDescriptor->MaximumPhysicalPages) {

         transferPages =
            deviceExtension->AdapterDescriptor->MaximumPhysicalPages - 1;

         if (maximumTransferLength > transferPages << PAGE_SHIFT ) {
             maximumTransferLength = transferPages << PAGE_SHIFT;
         }

        //
        // Check that maximum transfer size is not zero.
        //

        if (maximumTransferLength == 0) {
            maximumTransferLength = PAGE_SIZE;
        }

        //
        // Mark IRP with status pending.
        //

        IoMarkIrpPending(Irp);

        //
        // Request greater than port driver maximum.
        // Break up into smaller routines.
        //

        SplitRequest(Fdo,
                     Irp,
                     maximumTransferLength);

        return STATUS_PENDING;
    }

    //
    // Build SRB and CDB for this IRP.
    //

    Status = BuildPrintRequest(Fdo, Irp);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Return the results of the call to the port driver.
    //

    return IoCallDriver(deviceExtension->CommonExtension.LowerDeviceObject, Irp);

} // end ScsiPrinterWrite()


NTSTATUS
PrinterDeviceControl(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the NT device control handler for Printers.

Arguments:

    DeviceObject - for this Printer

    Irp - IO Request packet

Return Value:

    NTSTATUS

--*/

{
    PVOID                        buffer = Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                     status;
    PIO_STACK_LOCATION           irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = Fdo->DeviceExtension;



    DEBUGPRINT2 (("PrinterDeviceControl: enter, Fdo=x%p, Ioctl=", Fdo));

    //
    // Zero CDB in SRB on stack.
    //

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_SERIAL_SET_TIMEOUTS: {

            PSERIAL_TIMEOUTS newTimeouts = ((PSERIAL_TIMEOUTS) buffer);


            DEBUGPRINT2 (("SET_TIMEOUTS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {

                status = STATUS_BUFFER_TOO_SMALL;

            } else if (newTimeouts->WriteTotalTimeoutConstant < 2000) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                deviceExtension->TimeOutValue =
                    newTimeouts->WriteTotalTimeoutConstant / 1000;
                status = STATUS_SUCCESS;
            }

            break;
        }

        case IOCTL_SERIAL_GET_TIMEOUTS:

            DEBUGPRINT2(("GET_TIMEOUTS\n"));

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {

                status = STATUS_BUFFER_TOO_SMALL;

            } else {

                RtlZeroMemory (buffer, sizeof (SERIAL_TIMEOUTS));

                Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

                ((PSERIAL_TIMEOUTS) buffer)->WriteTotalTimeoutConstant =
                    deviceExtension->TimeOutValue * 1000;

                status = STATUS_SUCCESS;
            }

            break;

        case IOCTL_USBPRINT_GET_LPT_STATUS:

            //
            // We support this ioctl for USBMON.DLL's sake. Other print
            // stacks will block failed writes, and eventually USBMON
            // will send them this ioctl to see if the printer is out
            // of paper, which will be indicated by the state of the
            // 0x20 bit in the returned UCHAR value.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(UCHAR)) {

                status = STATUS_BUFFER_TOO_SMALL;

            } else if (deviceExtension->AdapterDescriptor->BusType !=
                       BusType1394) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                PPRINTER_DATA   printerData;


                printerData = (PPRINTER_DATA)
                    deviceExtension->CommonExtension.DriverData;

                Irp->IoStatus.Information = sizeof (UCHAR);

                *((UCHAR *) buffer) = (printerData->LastWriteStatus ==
                    STATUS_NO_MEDIA_IN_DEVICE ? 0x20 : 0);

                DEBUGPRINT2((
                    "GET_LPT_STATUS (=x%x)\n",
                    (ULONG) *((UCHAR *) buffer)
                    ));

                status = STATUS_SUCCESS;
            }

            break;

        case IOCTL_SCSIPRNT_1394_BLOCKING_WRITE:

            //
            // This ioctl en/disables the blocking write functionality
            // (for failed writes) on 1394 devices.  By default we
            // block writes which fail on 1394 devices (until the write
            // finally succeeds or is cancelled), but a smart port
            // monitor could send this ioctl down to disable blocking
            // so it would get write error notifications asap.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(UCHAR)) {

                status = STATUS_BUFFER_TOO_SMALL;

            } else if (deviceExtension->AdapterDescriptor->BusType !=
                       BusType1394) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                PPRINTER_DATA   printerData;


                printerData = (PPRINTER_DATA)
                    deviceExtension->CommonExtension.DriverData;

                printerData->WriteCompletionRoutine = (*((UCHAR *) buffer) ?
                    PrinterWriteComplete : ClassIoComplete);

                status = STATUS_SUCCESS;
            }

            break;

        default:

            //
            // Pass the request to the common device control routine.
            //

            DEBUGPRINT2((
                "x%x\n",
                irpStack->Parameters.DeviceIoControl.IoControlCode
                ));

            return(ClassDeviceControl(Fdo, Irp));

            break;

    } // end switch()

    //
    // Update IRP with completion status.
    //

    Irp->IoStatus.Status = status;

    //
    // Complete the request.
    //

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);

    //
    // Release the remove lock (which ClassDeviceControl does)
    //

    ClassReleaseRemoveLock(Fdo, Irp);

    DEBUGPRINT2(( "PrinterDeviceControl: Status is %lx\n", status));
    return status;

} // end ScsiPrinterDeviceControl()



VOID
SplitRequest(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    )

/*++

Routine Description:

    Break request into smaller requests.  Each new request will be the
    maximum transfer size that the port driver can handle or if it
    is the final request, it may be the residual size.

    The number of IRPs required to process this request is written in the
    current stack of the original IRP. Then as each new IRP completes
    the count in the original IRP is decremented. When the count goes to
    zero, the original IRP is completed.

Arguments:

    DeviceObject - Pointer to the class device object to be addressed.

    Irp - Pointer to Irp the orginal request.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = Fdo->DeviceExtension;

    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    ULONG transferByteCount = currentIrpStack->Parameters.Read.Length;
    LARGE_INTEGER startingOffset = currentIrpStack->Parameters.Read.ByteOffset;
    PVOID dataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);
    ULONG dataLength = MaximumBytes;
    ULONG irpCount = (transferByteCount + MaximumBytes - 1) / MaximumBytes;
    PSCSI_REQUEST_BLOCK srb;
    ULONG i;
    NTSTATUS Status;

    DEBUGPRINT2(( "SplitRequest: Requires %d IRPs\n", irpCount));
    DEBUGPRINT2(( "SplitRequest: Original IRP %p\n", Irp));

    //
    // If all partial transfers complete successfully then the status and
    // bytes transferred are already set up. Failing a partial-transfer IRP
    // will set status to error and bytes transferred to 0 during
    // IoCompletion. Setting bytes transferred to 0 if an IRP fails allows
    // asynchronous partial transfers. This is an optimization for the
    // successful case.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = transferByteCount;

    //
    // Save number of IRPs to complete count on current stack
    // of original IRP.
    //

    nextIrpStack->Parameters.Others.Argument1 = ULongToPtr( irpCount );

    for (i = 0; i < irpCount; i++) {

        PIRP newIrp;
        PIO_STACK_LOCATION newIrpStack;

        //
        // Allocate new IRP.
        //

        newIrp = IoAllocateIrp(Fdo->StackSize, FALSE);

        if (newIrp == NULL) {

            DEBUGPRINT1(("SplitRequest: Can't allocate Irp\n"));

            //
            // If an Irp can't be allocated then the orginal request cannot
            // be executed.  If this is the first request then just fail the
            // orginal request; otherwise just return.  When the pending
            // requests complete, they will complete the original request.
            // In either case set the IRP status to failure.
            //

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;

            if (i == 0) {

                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }

            return;
        }

        DEBUGPRINT2(( "SplitRequest: New IRP %p\n", newIrp));

        //
        // Write MDL address to new IRP. In the port driver the SRB data
        // buffer field is used as an offset into the MDL, so the same MDL
        // can be used for each partial transfer. This saves having to build
        // a new MDL for each partial transfer.
        //

        newIrp->MdlAddress = Irp->MdlAddress;

        //
        // At this point there is no current stack. IoSetNextIrpStackLocation
        // will make the first stack location the current stack so that the
        // SRB address can be written there.
        //

        IoSetNextIrpStackLocation(newIrp);
        newIrpStack = IoGetCurrentIrpStackLocation(newIrp);

        newIrpStack->MajorFunction = currentIrpStack->MajorFunction;
        newIrpStack->Parameters.Read.Length = dataLength;
        newIrpStack->Parameters.Read.ByteOffset = startingOffset;
        newIrpStack->DeviceObject = Fdo;

        //
        // Build SRB and CDB.
        //

        Status = BuildPrintRequest(Fdo, newIrp);
        if (!NT_SUCCESS (Status)) {
            IoFreeIrp (newIrp);

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;

            if (i == 0) {

                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }

            return;
        }

        //
        // Adjust SRB for this partial transfer.
        //

        newIrpStack = IoGetNextIrpStackLocation(newIrp);

        srb = newIrpStack->Parameters.Others.Argument1;
        srb->DataBuffer = dataBuffer;

        //
        // Write original IRP address to new IRP.
        //

        newIrp->AssociatedIrp.MasterIrp = Irp;

        //
        // Set the completion routine to ScsiClassIoCompleteAssociated.
        //

        IoSetCompletionRoutine(newIrp,
                               ClassIoCompleteAssociated,
                               srb,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Call port driver with new request.
        //

        IoCallDriver(deviceExtension->CommonExtension.LowerDeviceObject, newIrp);

        //
        // Set up for next request.
        //

        dataBuffer = (PCHAR)dataBuffer + MaximumBytes;

        transferByteCount -= MaximumBytes;

        if (transferByteCount > MaximumBytes) {

            dataLength = MaximumBytes;

        } else {

            dataLength = transferByteCount;
        }

        //
        // Adjust disk byte offset.
        //

        startingOffset.QuadPart = startingOffset.QuadPart + MaximumBytes;
    }

    return;

} // end SplitRequest()



NTSTATUS
PrinterWriteComplete(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp,
    IN PVOID            Context
    )

/*++

Routine Description:

    Ideally we should be should be able to use ClassIoComplete for
    all write completion notifications, but alas...

    (Code borrowed from classpnp!ClassIoComplete)

    This is the special, 1394 bus-specific write completion routine
    required to keep USBMON.DLL happy in the case of failed write
    requests.  The other stacks that USBMON talks to all pend
    unsuccessful writes forever, rather than simply completing them
    with an error.  When a write blocks for a long time USBMON will
    issue a sideband ioctl, namely IOCTL_USBPRINT_GET_LPT_STATUS,
    to determine if the printer is out of paper or not.  Eventually
    USBMON may cancel a blocked write.  However, it simply doesn't
    expect writes to just fail, so we have to fake out the behavior
    of the other stacks to keep it happy.  We'll retry blocked
    writes every so often, & mark the irp as cancellable in between
    retries.

    At least USBMON will only send down one 10k (or so) write at a
    time, so we don't have to worry about queue-ing >1 write at a
    time for a device, nor do we have to deal with handling failed
    sub-requests of a split write.

Arguments:

    Fdo - Supplies the device object which represents the logical unit.

    Irp - Supplies the Irp which has completed.

    Context - Supplies a pointer to the SRB.

Return Value:

    NT status

--*/

{
    ULONG               retryInterval;
    KIRQL               oldIrql;
    BOOLEAN             retry;
    PPRINTER_DATA       printerData;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation (Irp);
    PSCSI_REQUEST_BLOCK srb = Context;

    PCOMMON_DEVICE_EXTENSION    extension = Fdo->DeviceExtension;


    ASSERT(extension->IsFdo);

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DEBUGPRINT3 (("PrinterWriteCompl: Fdo=x%p, Irp=x%p, ", Fdo, Irp));

        if (((PFUNCTIONAL_DEVICE_EXTENSION) extension)->AdapterDescriptor ==
                NULL) {

            //
            // Device removed..
            //

            DEBUGPRINT3(("device removed(\n"));

            Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
            Irp->IoStatus.Information = 0;

            ClassReleaseRemoveLock (Fdo, Irp);

            return STATUS_DEVICE_DOES_NOT_EXIST;
        }

        if (Irp->Cancel) {

            //
            // Someone tried to cancel the irp after it was passed
            // down the stack (where, as of win2k, there is no cancel
            // support), so bail out now
            //

            DEBUGPRINT3 (("irp cancelled\n"));

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            ClassReleaseRemoveLock (Fdo, Irp);

            return STATUS_CANCELLED;
        }

        printerData = (PPRINTER_DATA) extension->DriverData;


        //
        // Note that ClassInterpretSenseInfo will return (retry=)
        // FALSE if it determines there's no media in device
        //

        retry = ClassInterpretSenseInfo(
                    Fdo,
                    srb,
                    irpStack->MajorFunction,
                    0,
                    MAXIMUM_RETRIES - ((ULONG)(ULONG_PTR)
                        irpStack->Parameters.Others.Argument4),
                    &printerData->LastWriteStatus,
                    &retryInterval
                    );

        if (retry &&
            ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4)--) {

            DEBUGPRINT3 (("retry write\n"));

            PrinterRetryRequest (Fdo, Irp, srb);

        } else {

            if (printerData->LastWriteStatus == STATUS_NO_MEDIA_IN_DEVICE) {

                //
                // At the current time Epson is returning
                // SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED for both
                // the out-of-paper & offline cases.  The EndOfMedia
                // bit wil be set if the printer is truly out of paper,
                // but if it's not then we want to change the
                // LastWriteStatus so that we won't set the out-of-paper
                // bit in the IOCTL_USBPRINT_GET_LPT_STATUS handler.
                //

                PSENSE_DATA senseBuffer = srb->SenseInfoBuffer;


                if (senseBuffer->AdditionalSenseCodeQualifier ==
                        SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED  &&

                    !senseBuffer->EndOfMedia) {

                    printerData->LastWriteStatus = STATUS_IO_DEVICE_ERROR;
                }
            }

            printerData->DueTime.HighPart = -1;
            printerData->DueTime.LowPart =
                BLOCKED_WRITE_TIMEOUT * (-10 * 1000 * 1000);

            KeAcquireSpinLock (&printerData->SplitRequestSpinLock, &oldIrql);

            ASSERT (printerData->WriteIrp == NULL);

            if (printerData->WriteIrp == NULL  ||
                printerData->WriteIrp == Irp) {

                printerData->WriteIrp = Irp;

            } else {

                //
                // We assume that if we're in blocking write mode then
                // the client is USBMON who will only submit 1 write
                // at a time (other clients should use
                // IOCTL_SCSIPRNT_1394_BLOCKING_WRITE to disable blocking
                // writes if they don't want this behavior).
                //
                // Since we don't handle >1 blocked write at a time we'll
                // just complete this 2nd write, so we don't lose track of
                // (and fail to complete) any irps.
                //

                KeReleaseSpinLock (&printerData->SplitRequestSpinLock, oldIrql);

                return ClassIoComplete (Fdo, Irp, Context);
            }

            KeReleaseSpinLock (&printerData->SplitRequestSpinLock, oldIrql);

            IoSetCancelRoutine (Irp, PrinterCancel);

            KeSetTimer(
                &printerData->Timer,
                printerData->DueTime,
                &printerData->TimerDpc
                );

            DEBUGPRINT3 ((
                "Sts=x%x, pend write\n",
                printerData->LastWriteStatus
                ));
        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    return ClassIoComplete (Fdo, Irp, Context);

} // end PrinterWriteComplete()



VOID
PrinterRetryRequest(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp,
    PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    (Code borrowed from classpnp!ClassIoComplete, since we need to
    set a different completion routine)

    This routine reinitalizes the necessary fields, and sends the request
    to the lower driver.

Arguments:

    DeviceObject - Supplies the device object associated with this request.

    Irp - Supplies the request to be retried.

    Srb - Supplies a Pointer to the SCSI request block to be retied.

Return Value:

    None

--*/

{
    ULONG transferByteCount;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PCOMMON_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;


    //
    // Determine the transfer count of the request.  If this is a read or a
    // write then the transfer count is in the Irp stack.  Otherwise assume
    // the MDL contains the correct length.  If there is no MDL then the
    // transfer length must be zero.
    //

    if (currentIrpStack->MajorFunction == IRP_MJ_READ ||
        currentIrpStack->MajorFunction == IRP_MJ_WRITE) {

        transferByteCount = currentIrpStack->Parameters.Read.Length;

    } else if (Irp->MdlAddress != NULL) {

        //
        // Note this assumes that only read and write requests are spilt and
        // other request do not need to be.  If the data buffer address in
        // the MDL and the SRB don't match then transfer length is most
        // likely incorrect.
        //

        ASSERT(Srb->DataBuffer == MmGetMdlVirtualAddress(Irp->MdlAddress));
        transferByteCount = Irp->MdlAddress->ByteCount;

    } else {

        transferByteCount = 0;
    }

    //
    // Reset byte count of transfer in SRB Extension.
    //

    Srb->DataTransferLength = transferByteCount;

    //
    // Zero SRB statuses.
    //

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    //
    // Set the no disconnect flag, disable synchronous data transfers and
    // disable tagged queuing. This fixes some errors.
    //

    Srb->SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT |
                     SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    Srb->SrbFlags &= ~SRB_FLAGS_QUEUE_ACTION_ENABLE;
    Srb->QueueTag = SP_UNTAGGED;

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = Srb;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine (Irp, PrinterWriteComplete, Srb, TRUE, TRUE, TRUE);

    //
    // Pass the request to the port driver.
    //

    IoCallDriver (extension->LowerDeviceObject, Irp);

    return;
} // end PrinterRetryRequest()



VOID
PrinterWriteTimeoutDpc(
    IN PKDPC                    Dpc,
    IN PCOMMON_DEVICE_EXTENSION Extension,
    IN PVOID                    SystemArgument1,
    IN PVOID                    SystemArgument2
    )

/*++

Routine Description:

    Gets called when the blocking-write timer expires.  Allocates &
    queues a low-priority work item (to resubmit the write) if
    there's an outstanding write, & if the allocation fails justs
    resets the time to try again later. (We're running at raised
    irql here, when it's not necesarily safe to re-submit the write,
    hence the work item which gets processed later at passive level.)

Arguments:

    Dpc -

    Extension -

    SystemArgument1 -

    SystemArgument2 -

Return Value:

    None

--*/

{
    PIO_WORKITEM    workItem;
    PPRINTER_DATA   printerData = (PPRINTER_DATA) Extension->DriverData;


    DEBUGPRINT3((
        "PrinterWriteTimeoutDpc: enter, Fdo=x%p, Irp=x%p\n",
        Extension->DeviceObject,
        printerData->WriteIrp
        ));

    if (printerData->WriteIrp) {

        workItem = IoAllocateWorkItem (Extension->DeviceObject);

        if (workItem) {

            IoQueueWorkItem(
                workItem,
                PrinterResubmitWrite,
                DelayedWorkQueue,       // not time critical
                workItem
                );

        } else {

            printerData->DueTime.HighPart = -1;
            printerData->DueTime.LowPart =
                BLOCKED_WRITE_TIMEOUT * (-10 * 1000 * 1000);

            KeSetTimer(
                &printerData->Timer,
                printerData->DueTime,
                &printerData->TimerDpc
                );
        }
    }

} // end PrinterWriteTimeoutDpc



VOID
PrinterResubmitWrite(
    PDEVICE_OBJECT  DeviceObject,
    PVOID           Context
    )

/*++

Routine Description:

    Work item handler routine, gets called at passive level in an
    arbitrary thread context. Simply resubmits an outstanding write,
    if any.

Arguments:

    DeviceObject -

    Context - pointer to the IO_WORKITEM

Return Value:

    None

--*/

{
    PIRP            irp;
    KIRQL           oldIrql;
    PPRINTER_DATA   printerData;


    DEBUGPRINT3 (("PrinterResubmitWrite: enter, Fdo=x%p, ", DeviceObject));

    IoFreeWorkItem ((PIO_WORKITEM) Context);

    printerData = (PPRINTER_DATA)
        ((PCOMMON_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->DriverData;



    //
    // See if there's still an outstanding write irp, & if so NULL-ify
    // the cancel routine since we'll be passing the irp down the stack
    //

    KeAcquireSpinLock (&printerData->SplitRequestSpinLock, &oldIrql);

    irp = printerData->WriteIrp;

    if (irp) {

        if (IoSetCancelRoutine (irp, NULL) == NULL) {

            DEBUGPRINT3 (("write cancelled\n"));

            irp = NULL;

        } else {

            printerData->WriteIrp = NULL;
        }

    } else {

        DEBUGPRINT3 (("no pending write\n"));
    }

    KeReleaseSpinLock (&printerData->SplitRequestSpinLock, oldIrql);


    //
    // Rebsubmit an outstanding write irp
    //

    if (irp) {

        PFUNCTIONAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;


        if (extension->AdapterDescriptor) {

            DEBUGPRINT3 (("Irp=x%p\n", irp));

            PrinterReadWrite (DeviceObject, irp);

        } else {

            DEBUGPRINT3((" RMV!, fail Irp=x%p\n", irp));

            IoMarkIrpPending (irp);

            irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
            irp->IoStatus.Information = 0;

            IoCompleteRequest (irp, IO_NO_INCREMENT);

            ClassReleaseRemoveLock (DeviceObject, irp);
        }
    }

} // end PrinterWriteTimeoutDpc



VOID
PrinterCancel(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )

/*++

Routine Description:

    Cancels a blocked write irp

Arguments:

    DeviceObject -

    Irp - irp to cancel

Return Value:

    None

--*/

{
    KIRQL           	oldIrql;
    PPRINTER_DATA   	printerData;
    PIO_STACK_LOCATION 	currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;


    DEBUGPRINT2((
        "\nPrinterCancel: enter, DevObj=x%p, Irp=x%p\n\n",
        DeviceObject,
        Irp
        ));

    printerData = (PPRINTER_DATA)
        ((PCOMMON_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->DriverData;

    IoReleaseCancelSpinLock (Irp->CancelIrql);

    KeCancelTimer (&printerData->Timer);

    KeAcquireSpinLock (&printerData->SplitRequestSpinLock, &oldIrql);

    ASSERT (Irp == printerData->WriteIrp);

    printerData->WriteIrp = NULL;

    KeReleaseSpinLock (&printerData->SplitRequestSpinLock, oldIrql);

    // see if this is a SCSI Irp we sent down

    if(currentIrpStack->MajorFunction == IRP_MJ_SCSI)
    {
        // the associated SRB never got freed, so do it before we complete this request

        srb = currentIrpStack->Parameters.Scsi.Srb;

        if (srb)
        {
            currentIrpStack->Parameters.Scsi.Srb = NULL;
            ExFreePool(srb);
        }
    }

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

} // end PrinterCancel
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiprnt\printpnp.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    prntpnp.c

Abstract:

    printer class driver defines and functions decl.

Author:

    George Chrysanthakopoulos (georgioc)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ntddk.h"
#include "scsi.h"
#include "classpnp.h"

#ifndef _PRINTPNP_
#define _PRINTPNP_

#if DBG

ULONG PrintDebugLevel;

#define DEBUGPRINT1(_x_)        {if (PrintDebugLevel >= 1) \
                                KdPrint (_x_);}

#define DEBUGPRINT2(_x_)        {if (PrintDebugLevel >= 2) \
                                KdPrint (_x_);}

#define DEBUGPRINT3(_x_)        {if (PrintDebugLevel >= 3) \
                                KdPrint (_x_);}
#define DEBUGPRINT4(_x_)        {if (PrintDebugLevel >= 4) \
                                KdPrint (_x_);}

#else

#define DEBUGPRINT1(_x_)
#define DEBUGPRINT2(_x_)
#define DEBUGPRINT3(_x_)
#define DEBUGPRINT4(_x_)

#endif

NTSTATUS
PrinterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
PrinterEnumerateDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
PrinterQueryId(
    IN PDEVICE_OBJECT Pdo,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING UnicodeIdString
    );

NTSTATUS
PrinterCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
PrinterGetId
(
    IN PUCHAR DeviceIdString,
    IN ULONG Type,
    OUT PUCHAR resultString,
    OUT PUCHAR descriptionString
);

NTSTATUS
PrinterStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
PrinterInitPdo(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
PrinterInitFdo(
    IN PDEVICE_OBJECT Fdo
    );



VOID
PrinterRegisterPort(
    IN PPHYSICAL_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
PrinterStartPdo(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
PrinterQueryPnpCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    );


NTSTATUS
CreatePrinterDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PULONG         DeviceCount
    );

NTSTATUS
PrinterDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PrinterStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
PrinterCreatePdo(
    IN PDEVICE_OBJECT Fdo,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
PrinterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
PrinterSystemControl(
    PDEVICE_OBJECT Fdo,
    PIRP Irp
    );

NTSTATUS
PrinterPowerControl(
    PDEVICE_OBJECT Fdo,
    PIRP Irp
    );

NTSTATUS
PrinterOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PrinterReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PrinterIssueCommand(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR Scsiop
    );

VOID
SplitRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    );

NTSTATUS
PrinterWriteComplete(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp,
    IN PVOID            Context
    );

VOID
PrinterRetryRequest(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp,
    PSCSI_REQUEST_BLOCK Srb
    );

VOID
PrinterWriteTimeoutDpc(
    IN PKDPC                    Dpc,
    IN PCOMMON_DEVICE_EXTENSION Extension,
    IN PVOID                    SystemArgument1,
    IN PVOID                    SystemArgument2
    );

VOID
PrinterResubmitWrite(
    PDEVICE_OBJECT  DeviceObject,
    PVOID           Context
    );

VOID
PrinterCancel(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );


#define DEVICE_EXTENSION_SIZE       sizeof(FUNCTIONAL_DEVICE_EXTENSION) + sizeof(PRINTER_DATA)
#define PRINTER_TIMEOUT             100
#define PRINTER_SRB_LIST_SIZE       4
#define PRINTER_TAG                 'tnrp'
#define BLOCKED_WRITE_TIMEOUT       3       // seconds

#define PORT_NUM_VALUE_NAME L"Port Number"
#define BASE_PORT_NAME_VALUE_NAME L"Base Name"
#define BASE_PORT_DESCRIPTION L"IEEE 1394 Printer Port"
#define BASE_PORT_DESCRIPTION_VALUE_NAME L"Port Description"
#define RECYCLABLE_VALUE_NAME L"Recyclable"


#define BASE_1394_PORT_NAME L"1394_"
#define BASE_SCSI_PORT_NAME L"SCSI"

#define MAX_PRINT_XFER 0x00ffffff
#define MAX_NUM_PRINTERS 20

typedef struct _PRINTER_DATA {

    ULONG          DeviceFlags;
    KSPIN_LOCK     SplitRequestSpinLock;
    UNICODE_STRING UnicodeLinkName;
    UNICODE_STRING UnicodeDeviceString;
    UCHAR          DeviceName[256];
    PUCHAR         DeviceIdString;
    ULONG          PortNumber;
    ULONG          LptNumber;

    //
    // See comments in PrinterWriteComplete() for a description
    // of the following fields
    //

    PIO_COMPLETION_ROUTINE  WriteCompletionRoutine;
    KTIMER                  Timer;
    LARGE_INTEGER           DueTime;
    KDPC                    TimerDpc;
    PIRP                    WriteIrp;
    NTSTATUS                LastWriteStatus;

} PRINTER_DATA, *PPRINTER_DATA;

static const GUID PNPPRINT_GUID = 
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };


//
// Support for the following ioctl allows SCSIPRNT to behave like the
// USB, etc printing stacks, to keep USBMON.DLL happy
//
// From ntos\dd\usbprint\ioctl.h & windows\spooler\monitors\dynamon\ioctl.h
//

#define USBPRINT_IOCTL_INDEX 0x0000

#define IOCTL_USBPRINT_GET_LPT_STATUS CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                               USBPRINT_IOCTL_INDEX+12, \
                                               METHOD_BUFFERED,         \
                                               FILE_ANY_ACCESS)

//
// The following ioctl allows a smart client / port monitor to en/disable
// the blocking write behavior on 1394 printers
//

#define SCSIPRNT_IOCTL_INDEX 0x123

#define IOCTL_SCSIPRNT_1394_BLOCKING_WRITE  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                     SCSIPRNT_IOCTL_INDEX, \
                                                     METHOD_BUFFERED,      \
                                                     FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\verify.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000

Module Name:

    verify.c

Abstract:

    This module implements a driver verifier extension for the SCSI port 
    driver.  Scsiport adds some of its exports to the list of apis that get 
    thunked by the system driver verifier, thus enabling scsiport-specific 
    verification of miniport drivers.

Authors:

    John Strange (JohnStra)

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

#define __FILE_ID__ 'vfry'

SCSIPORT_API
ULONG
ScsiPortInitializeVrfy(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    );

SCSIPORT_API
VOID
ScsiPortCompleteRequestVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    );

SCSIPORT_API
PSCSI_REQUEST_BLOCK
ScsiPortGetSrbVrfy(
    IN PVOID DeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    );

SCSIPORT_API
PVOID
ScsiPortGetDeviceBaseVrfy(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    );

SCSIPORT_API
VOID
ScsiPortNotificationVrfy(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    );

SCSIPORT_API
VOID
ScsiPortFlushDmaVrfy(
    IN PVOID DeviceExtension
    );

SCSIPORT_API
VOID
ScsiPortFreeDeviceBaseVrfy(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    );

SCSIPORT_API
ULONG
ScsiPortGetBusDataVrfy(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

SCSIPORT_API
PVOID
ScsiPortGetLogicalUnitVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

SCSIPORT_API
SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddressVrfy(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    );

SCSIPORT_API
PVOID
ScsiPortGetUncachedExtensionVrfy(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    );

SCSIPORT_API
PVOID
ScsiPortGetVirtualAddressVrfy(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    );

SCSIPORT_API
VOID
ScsiPortIoMapTransferVrfy(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    );

SCSIPORT_API
VOID
ScsiPortMoveMemoryVrfy(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    );

SCSIPORT_API
ULONG
ScsiPortSetBusDataByOffsetVrfy(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

SCSIPORT_API
BOOLEAN
ScsiPortValidateRangeVrfy(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    );

SCSIPORT_API
VOID
ScsiPortStallExecutionVrfy(
    IN ULONG Delay
    );

PVOID
SpAllocateContiguousChunk(
    IN PDRIVER_OBJECT DriverObject,
    IN PDMA_ADAPTER DmaAdapterObject,
    IN BOOLEAN Dma64BitAddresses,
    IN ULONG Length,
    IN ULONG Align,
    OUT PHYSICAL_ADDRESS *PhysicalCommonBuffer,
    OUT BOOLEAN *CommonBuffer
    );

PVOID
SpRemapBlock(
    IN PVOID BlockVa,
    IN ULONG BlockSize,
    OUT PMDL* Mdl
    );

BOOLEAN
SpCheckForActiveRequests(
    IN PADAPTER_EXTENSION
    );

ULONG
SpGetAdapterVerifyLevel(
    IN PADAPTER_EXTENSION Adapter
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpVerifierInitialization)
#pragma alloc_text(PAGE, ScsiPortInitializeVrfy)
#pragma alloc_text(PAGE, SpGetAdapterVerifyLevel)
#pragma alloc_text(PAGE, SpDoVerifierInit)

#pragma alloc_text(PAGEVRFY1, ScsiPortGetSrbVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortCompleteRequestVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetDeviceBaseVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortNotificationVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortFlushDmaVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortFreeDeviceBaseVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetBusDataVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetLogicalUnitVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetPhysicalAddressVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetUncachedExtensionVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetVirtualAddressVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortMoveMemoryVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortSetBusDataByOffsetVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortValidateRangeVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortStallExecutionVrfy)

#pragma alloc_text(PAGEVRFY, SpHwFindAdapterVrfy)
#pragma alloc_text(PAGEVRFY, SpHwInitializeVrfy)
#pragma alloc_text(PAGEVRFY, SpHwStartIoVrfy)
#pragma alloc_text(PAGEVRFY, SpHwInterruptVrfy)
#pragma alloc_text(PAGEVRFY, SpHwResetBusVrfy)
#pragma alloc_text(PAGEVRFY, SpHwDmaStartedVrfy)
#pragma alloc_text(PAGEVRFY, SpHwRequestInterruptVrfy)
#pragma alloc_text(PAGEVRFY, SpHwTimerRequestVrfy)
#pragma alloc_text(PAGEVRFY, SpHwAdapterControlVrfy)
#pragma alloc_text(PAGEVRFY, SpVerifySrbStatus)
#pragma alloc_text(PAGEVRFY, SpAllocateContiguousChunk)
#pragma alloc_text(PAGEVRFY, SpGetCommonBufferVrfy)
#pragma alloc_text(PAGEVRFY, SpFreeCommonBufferVrfy)
#pragma alloc_text(PAGEVRFY, SpGetOriginalSrbExtVa)
#pragma alloc_text(PAGEVRFY, SpInsertSrbExtension)
#pragma alloc_text(PAGEVRFY, SpPrepareSrbExtensionForUse)
#pragma alloc_text(PAGEVRFY, SpPrepareSenseBufferForUse)
#pragma alloc_text(PAGEVRFY, SpRemapBlock)
#pragma alloc_text(PAGEVRFY, SpGetInaccessiblePage)
#pragma alloc_text(PAGEVRFY, SpEnsureAllRequestsAreComplete)
#pragma alloc_text(PAGEVRFY, SpCheckForActiveRequests)
#endif

//
// Some defines and a macro for conditionally verifying based on the 
// verification level.
//
#define SP_DONT_CHK_HW_INITIALIZE_DURATION     0x80000000
#define SP_DONT_CHK_ACTIVE_UNTAGGED_REQUEST    0x40000000
#define SP_DONT_CHK_REQUESTS_ON_RESET          0x20000000
#define SP_DONT_CHK_HW_ADAPTERCONTROL_DURATION 0x10000000

#define VRFY_DO_CHECK(adapter, chk)\
(((adapter)->VerifierExtension != NULL) &&\
(((adapter)->VerifierExtension->VrfyLevel & (chk)) == 0))


//
// Indicates whether scsiport's verifier functionality has been initialized.
//
ULONG ScsiPortVerifierInitialized = 0;

//
// Handle to pageable verifier code sections.  We manually lock the verify
// code into memory iff we need it.
//
PVOID VerifierCodeSectionHandle = NULL;
PVOID VerifierApiCodeSectionHandle = NULL;

//
// Time increment of the interval timer in 100 ns units.  We use this to
// calculate the time miniport routines execute so we can catch those that
// run longer than they should.
//
ULONG TimeIncrement;

//
// Global variable used to control verification aggressiveness.  This value
// is used in conjuction with a per-adapter registry value, to control what
// type of verification we do on a particular miniport.
//
ULONG SpVrfyLevel = 0;

//
// Global variable used to control how aggressively we seek out stall
// offenders.  Default is a tenth of a second.
//
ULONG SpVrfyMaximumStall = 100000;

//
// When verifier needs a unique address, this is what it uses.
//
ULONG SpMarker = 0x59465256;

//
// This table represents the functions verify will thunk for us.
//
#define SPVERIFIERFUNC(pfn) ((PDRIVER_VERIFIER_THUNK_ROUTINE)(pfn))

const DRIVER_VERIFIER_THUNK_PAIRS ScsiPortVerifierFunctionTable[] =
{
    {SPVERIFIERFUNC(ScsiPortInitialize), SPVERIFIERFUNC(ScsiPortInitializeVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetSrb), SPVERIFIERFUNC(ScsiPortGetSrbVrfy)},
    {SPVERIFIERFUNC(ScsiPortCompleteRequest), SPVERIFIERFUNC(ScsiPortCompleteRequestVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetDeviceBase), SPVERIFIERFUNC(ScsiPortGetDeviceBaseVrfy)},
    {SPVERIFIERFUNC(ScsiPortNotification), SPVERIFIERFUNC(ScsiPortNotificationVrfy)},
    {SPVERIFIERFUNC(ScsiPortFlushDma), SPVERIFIERFUNC(ScsiPortFlushDmaVrfy)},
    {SPVERIFIERFUNC(ScsiPortFreeDeviceBase), SPVERIFIERFUNC(ScsiPortFreeDeviceBaseVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetBusData), SPVERIFIERFUNC(ScsiPortGetBusDataVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetLogicalUnit), SPVERIFIERFUNC(ScsiPortGetLogicalUnitVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetPhysicalAddress), SPVERIFIERFUNC(ScsiPortGetPhysicalAddressVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetUncachedExtension), SPVERIFIERFUNC(ScsiPortGetUncachedExtensionVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetVirtualAddress), SPVERIFIERFUNC(ScsiPortGetVirtualAddressVrfy)},
    {SPVERIFIERFUNC(ScsiPortIoMapTransfer), SPVERIFIERFUNC(ScsiPortIoMapTransferVrfy)},
    {SPVERIFIERFUNC(ScsiPortMoveMemory), SPVERIFIERFUNC(ScsiPortMoveMemoryVrfy)},
    {SPVERIFIERFUNC(ScsiPortSetBusDataByOffset), SPVERIFIERFUNC(ScsiPortSetBusDataByOffsetVrfy)},
    {SPVERIFIERFUNC(ScsiPortValidateRange), SPVERIFIERFUNC(ScsiPortValidateRangeVrfy)},
    {SPVERIFIERFUNC(ScsiPortStallExecution), SPVERIFIERFUNC(ScsiPortStallExecutionVrfy)},
};


BOOLEAN
SpVerifierInitialization(
    VOID
    )

/*++

Routine Description:

    This routine initializes scsiport's verifier functionality.

    Adds several of scsiport's exported functions to the list of routines
    thunked by the system verifier.

Arguments:

    VOID

Return Value:

    TRUE if verifier is successfully initialized.

--*/

{
    ULONG Flags;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Query the system for verifier information.  This is to ensure that 
    // verifier is present and operational on the system.  If this fails, we 
    // give up and return FALSE.
    //

    Status = MmIsVerifierEnabled (&Flags);

    if (NT_SUCCESS(Status)) {

        //
        // Add scsiport APIs to the set that will be thunked by the system
        // for verification.
        //

        Status = MmAddVerifierThunks ((VOID *) ScsiPortVerifierFunctionTable,
                                      sizeof(ScsiPortVerifierFunctionTable));
        if (NT_SUCCESS(Status)) {

            //
            // Set the system query time increment.  Our verifier code uses
            // this to calculate the time miniport routines take to execute.
            //

            TimeIncrement = KeQueryTimeIncrement();

            return TRUE;
        }
    }

    return FALSE;
}

ULONG
ScsiPortInitializeVrfy(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    )
{
    ULONG Result;
    PDRIVER_OBJECT DriverObject = Argument1;
    PSCSIPORT_DRIVER_EXTENSION DriverExtension;

    PAGED_CODE();

    //
    // Lock the thunked API routines down.
    //

#ifdef ALLOC_PRAGMA
    if (VerifierApiCodeSectionHandle == NULL) {
        VerifierApiCodeSectionHandle = MmLockPagableCodeSection(ScsiPortGetSrbVrfy);
    }
#endif

    if (Argument1 == NULL || Argument2 == NULL) {

        //
        // Argument1 and Argument2 must be non-NULL.
        //

        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      SCSIPORT_VERIFIER_BAD_INIT_PARAMS,
                      (ULONG_PTR)Argument1,
                      (ULONG_PTR)Argument2,
                      0);
    }

    //
    // Forward the call on to ScsiPortInitialize.
    //

    Result = ScsiPortInitialize (Argument1, 
                                 Argument2, 
                                 HwInitializationData, 
                                 HwContext);

    //
    // If initialization was successful, try to initialize verifier settings.
    //

    if (NT_SUCCESS(Result)) {

        DriverExtension = IoGetDriverObjectExtension (DriverObject,
                                                      ScsiPortInitialize);
        if (DriverExtension != NULL) {

            //
            // Indicate that the driver is being verified by scsiport.
            //

            InterlockedExchange(&DriverExtension->Verifying, 1);
        }        
    }

    return Result;
}

PSCSI_REQUEST_BLOCK
ScsiPortGetSrbVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )
{
    return ScsiPortGetSrb(HwDeviceExtension,
                          PathId,
                          TargetId,
                          Lun,
                          QueueTag);
}

VOID
ScsiPortCompleteRequestVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )
{
    ScsiPortCompleteRequest(HwDeviceExtension,
                            PathId,
                            TargetId,
                            Lun,
                            SrbStatus);
}

PVOID
ScsiPortGetDeviceBaseVrfy(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    SCSI_PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )
{
    return ScsiPortGetDeviceBase(HwDeviceExtension,
                                 BusType,
                                 SystemIoBusNumber,
                                 IoAddress,
                                 NumberOfBytes,
                                 InIoSpace);
}

VOID
ScsiPortNotificationVrfy(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )
{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK Srb;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    PHW_INTERRUPT HwRequestInterrupt;
    PHW_INTERRUPT HwTimerRequest;
    ULONG MiniportTimerValue;
    PWNODE_EVENT_ITEM WnodeEventItem;
    PSRB_DATA srbData;
    va_list ap;

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case NextRequest:

            ScsiPortNotification(NotificationType, HwDeviceExtension);
            va_end(ap);
            return;

        case RequestComplete:

            Srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            //
            // Check that the status makes sense.
            //

            SpVerifySrbStatus(HwDeviceExtension, Srb);

            //
            // Check that this request has not already been completed.
            //

            if ((Srb->SrbFlags & SRB_FLAGS_IS_ACTIVE) == 0) {
                KeBugCheckEx(
                    SCSI_VERIFIER_DETECTED_VIOLATION,
                    SCSIPORT_VERIFIER_REQUEST_COMPLETED_TWICE,
                    (ULONG_PTR)HwDeviceExtension,
                    (ULONG_PTR)Srb, 
                    0);                     
            }

            //
            // Restore the DataBuffer in the SRB if we plugged in our
            // pointer to unmapped memory.  We did this if the adapter
            // does not specify MappedBuffers because the miniport is
            // not supposed to touch the buffer in that case.
            //

            srbData = (PSRB_DATA)Srb->OriginalRequest;
            ASSERT_SRB_DATA(srbData);

            if (srbData->UnmappedDataBuffer != &SpMarker) {
                ASSERT(srbData->UnmappedDataBuffer != NULL);
                Srb->DataBuffer = srbData->UnmappedDataBuffer;
            }
            srbData->UnmappedDataBuffer = NULL;

            //
            // Forward on to the real ScsiPortNotification routine.
            //

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 Srb);

            va_end(ap);
            return;

        case ResetDetected:

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension);
            va_end(ap);
            return;

        case NextLuRequest:

            //
            // The miniport driver is ready for the next request and
            // can accept a request for this logical unit.
            //

            PathId = va_arg(ap, UCHAR);
            TargetId = va_arg(ap, UCHAR);
            Lun = va_arg(ap, UCHAR);

            logicalUnit = deviceExtension->CachedLogicalUnit;

            if ((logicalUnit == NULL)
                || (logicalUnit->TargetId != TargetId)
                || (logicalUnit->PathId != PathId)
                || (logicalUnit->Lun != Lun)) {

                logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                                      PathId,
                                                      TargetId,
                                                      Lun,
                                                      FALSE,
                                                      FALSE);
            }

            //
            // Bugcheck if there is an untagged request active for this 
            // logical unit.
            //

            if (VRFY_DO_CHECK(deviceExtension, SP_DONT_CHK_ACTIVE_UNTAGGED_REQUEST) &&
                logicalUnit != NULL &&
                logicalUnit->CurrentUntaggedRequest != NULL &&
                logicalUnit->CurrentUntaggedRequest->CurrentSrb != NULL &&
                logicalUnit->CurrentUntaggedRequest->CurrentSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                
                KeBugCheckEx (
                    SCSI_VERIFIER_DETECTED_VIOLATION,
                    SCSIPORT_VERIFIER_UNTAGGED_REQUEST_ACTIVE,
                    (ULONG_PTR)HwDeviceExtension,
                    (ULONG_PTR)logicalUnit, 
                    0);
            }

            //
            // Forward on to the real ScsiPortNotification.
            //

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 PathId,
                                 TargetId,
                                 Lun);
            va_end(ap);
            return;

        case CallDisableInterrupts:

            HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);
            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 HwRequestInterrupt);
            va_end(ap);
            return;

        case CallEnableInterrupts:

            HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);
            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 HwRequestInterrupt);
            va_end(ap);
            return;

        case RequestTimerCall:

            HwTimerRequest = va_arg(ap, PHW_INTERRUPT);
            MiniportTimerValue = va_arg(ap, ULONG);
            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 HwTimerRequest,
                                 MiniportTimerValue);
            va_end(ap);
            return;

        case WMIEvent:

            WnodeEventItem = va_arg(ap, PWNODE_EVENT_ITEM);
            PathId = va_arg(ap, UCHAR);

            if (PathId != 0xFF) {
                TargetId = va_arg(ap, UCHAR);
                Lun = va_arg(ap, UCHAR);
                ScsiPortNotification(NotificationType,
                                     HwDeviceExtension,
                                     WnodeEventItem,
                                     PathId,
                                     TargetId,
                                     Lun);
            } else {
                ScsiPortNotification(NotificationType,
                                     HwDeviceExtension,
                                     WnodeEventItem,
                                     PathId);
            }
            va_end(ap);
            return;

        case WMIReregister:

            PathId = va_arg(ap, UCHAR);

            if (PathId != 0xFF) {
                TargetId = va_arg(ap, UCHAR);
                Lun = va_arg(ap, UCHAR);
                ScsiPortNotification(NotificationType,
                                     HwDeviceExtension,
                                     PathId,
                                     TargetId,
                                     Lun);
            } else {
                ScsiPortNotification(NotificationType,
                                     HwDeviceExtension,
                                     PathId);
            }
            va_end(ap);
            return;

        case BusChangeDetected:

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension);
            va_end(ap);
            return;

        default:

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension);
            va_end(ap);
            return;
    }
}

VOID
ScsiPortFlushDmaVrfy(
    IN PVOID DeviceExtension
    )
{
    ScsiPortFlushDma(DeviceExtension);
    return;
}

VOID
ScsiPortFreeDeviceBaseVrfy(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
{
    ScsiPortFreeDeviceBase(HwDeviceExtension, MappedAddress);
    return;
}

ULONG
ScsiPortGetBusDataVrfy(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    ULONG BusData;
    BusData = ScsiPortGetBusData(DeviceExtension,
                                 BusDataType,
                                 SystemIoBusNumber,
                                 SlotNumber,
                                 Buffer,
                                 Length);
    return BusData;
}

PVOID
ScsiPortGetLogicalUnitVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    PVOID LogicalUnit;
    LogicalUnit = ScsiPortGetLogicalUnit(HwDeviceExtension,
                                         PathId,
                                         TargetId,
                                         Lun);
    return LogicalUnit;
}

SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddressVrfy(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    )
{
    PADAPTER_EXTENSION  deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PHYSICAL_ADDRESS    address;
    PSP_VA_MAPPING_INFO MappingInfo;
    ULONG               byteOffset;
    ULONG               length;

    if ((deviceExtension->VerifierExtension != NULL) &&
        (deviceExtension->VerifierExtension->VrfyLevel & SP_VRFY_COMMON_BUFFERS) &&
        (Srb == NULL || Srb->SenseInfoBuffer == VirtualAddress)) {

        ULONG i;
        PVOID* BlkAddr;
        PUCHAR Beginning, End;
        PHYSICAL_ADDRESS *AddressBlock;

        //
        // Initialize a pointer to our array of common memory block 
        // descriptors.  We use this to locate the block that contains
        // the VA.
        //

        BlkAddr = deviceExtension->VerifierExtension->CommonBufferVAs;
        
        //
        // Look for the block that contains the VA.
        //

        for (i = 0; i < deviceExtension->NumberOfRequests; i++) {

            //
            // First, check if the VA is in the SRB extension.
            //

            MappingInfo = GET_VA_MAPPING_INFO(deviceExtension, BlkAddr[i]);
            if (MappingInfo->RemappedSrbExtVa != NULL) {
                Beginning = MappingInfo->RemappedSrbExtVa;
            } else {
                Beginning = BlkAddr[i];
            }
            End = (PUCHAR)ROUND_TO_PAGES((PUCHAR)Beginning + deviceExtension->SrbExtensionSize);
            
            if ((PUCHAR)VirtualAddress >= Beginning && 
                (PUCHAR)VirtualAddress < End) {
                byteOffset = (ULONG)((PUCHAR)VirtualAddress - Beginning);
                break;
            }

            //
            // Next, check if the VA is in the Sense Data Buffer.
            //

            if (deviceExtension->AutoRequestSense == TRUE) {        

                if (MappingInfo->RemappedSenseVa != NULL) {
                    Beginning = MappingInfo->RemappedSenseVa;
                } else {
                    Beginning = (PUCHAR)BlkAddr[i] + ROUND_TO_PAGES(deviceExtension->SrbExtensionSize);
                }
                End = Beginning + PAGE_SIZE;

                if ((PUCHAR)VirtualAddress >= Beginning && 
                    (PUCHAR)VirtualAddress < End) {                    
                    byteOffset = (ULONG)((PUCHAR)VirtualAddress - Beginning) +
                       (ULONG)ROUND_TO_PAGES(deviceExtension->SrbExtensionSize);
                    break;
                }
            }
        }
        
        //
        // If we haven't found the VA yet, it must be in the non-cached 
        // extension.
        //
        
        if (i == deviceExtension->NumberOfRequests) {
         
            if (deviceExtension->VerifierExtension->NonCachedBufferSize != 0) {

                Beginning = BlkAddr[i];
                End = (PUCHAR) ROUND_TO_PAGES(
                    (PUCHAR)Beginning + 
                    deviceExtension->VerifierExtension->NonCachedBufferSize);
            
                if ((PUCHAR)VirtualAddress < Beginning && 
                    (PUCHAR)VirtualAddress >= End) {

                    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                                  SCSIPORT_VERIFIER_BAD_VA,
                                  (ULONG_PTR)HwDeviceExtension,
                                  (ULONG_PTR)VirtualAddress,
                                  0);                        
                }

                byteOffset = (ULONG)((PUCHAR)VirtualAddress - Beginning);

            } else {

                KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                              SCSIPORT_VERIFIER_BAD_VA,
                              (ULONG_PTR)HwDeviceExtension,
                              (ULONG_PTR)VirtualAddress,
                              0);
            }
        }
                
        //
        // Get the physical address.
        //
        
        AddressBlock = deviceExtension->VerifierExtension->CommonBufferPAs;
        address.QuadPart = AddressBlock[i].QuadPart + byteOffset;
        
        //
        // Calculate the length of the block.
        //
        
        length = (ULONG)((End - (PUCHAR)VirtualAddress) + 1);

        return address;
    }

    //
    // Forward on to the real routine.
    //

    address = ScsiPortGetPhysicalAddress(HwDeviceExtension,
                                         Srb,
                                         VirtualAddress,
                                         Length);
    return address;
}

PVOID
ScsiPortGetUncachedExtensionVrfy(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
{
    PVOID Extension;
    Extension = ScsiPortGetUncachedExtension(HwDeviceExtension,
                                             ConfigInfo,
                                             NumberOfBytes);
    return Extension;
}


PVOID
ScsiPortGetVirtualAddressVrfy(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    )
{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PVOID* BlkAddr;
    PSP_VA_MAPPING_INFO MappingInfo;
    ULONG smallphysicalBase;
    ULONG smallAddress;
    PVOID address;
    ULONG offset;
    ULONG Size;
    ULONG i;

    //
    // If the adapter is not configured to allocate multiple common buffer 
    // blocks during verification, just call the scsiport routine.
    //

    if ((deviceExtension->VerifierExtension == NULL) ||
        (deviceExtension->VerifierExtension->VrfyLevel & SP_VRFY_COMMON_BUFFERS) == 0) {
        return ScsiPortGetVirtualAddress(HwDeviceExtension, PhysicalAddress);
    }

    BlkAddr = deviceExtension->VerifierExtension->CommonBufferVAs;

    //
    // Convert the 64-bit physical address to a ULONG.
    //

    smallAddress = ScsiPortConvertPhysicalAddressToUlong(PhysicalAddress);

    //
    // Check first if the supplied physical address is in an SRB extension or
    // in a sense buffer.
    //

    for (i = 0; i < deviceExtension->NumberOfRequests; i++) {

        smallphysicalBase = 
           ScsiPortConvertPhysicalAddressToUlong(
               deviceExtension->VerifierExtension->CommonBufferPAs[i]);

        if ((smallAddress < smallphysicalBase) ||
            (smallAddress >= smallphysicalBase + 
             (deviceExtension->CommonBufferSize -
              PAGE_SIZE))) {
            continue;
        }
        
        //
        // Calculate the address of the buffer.
        //

        offset = smallAddress - smallphysicalBase;
        address = offset + (PUCHAR)BlkAddr[i];

        MappingInfo = GET_VA_MAPPING_INFO(deviceExtension, BlkAddr[i]);

        goto GotAddress;
    }

    //
    // Check if the supplied physical address is in the non-cached extension.
    //

    if (deviceExtension->VerifierExtension->NonCachedBufferSize == 0) {

        ASSERT(FALSE);
        return(NULL);

    } else {

        smallphysicalBase = 
           ScsiPortConvertPhysicalAddressToUlong(
               deviceExtension->VerifierExtension->CommonBufferPAs[i]);  

        if ((smallAddress < smallphysicalBase) ||
            (smallAddress >= smallphysicalBase + 
            deviceExtension->VerifierExtension->NonCachedBufferSize)) {

            //
            // This is a bogus physical address return back NULL.
            //

            ASSERT(FALSE);
            return(NULL);
        }

        offset = smallAddress - smallphysicalBase;
        address = offset + (PUCHAR)BlkAddr[i];

        Size = (ULONG)ROUND_TO_PAGES(deviceExtension->VerifierExtension->NonCachedBufferSize);
        MappingInfo = (PSP_VA_MAPPING_INFO)((PUCHAR)BlkAddr[i] + (Size - PAGE_SIZE));

    }

GotAddress:
    //
    // Find out if we've remapped this address.  If we have, give the
    // caller the second mapping.
    //

    if (address < MappingInfo->OriginalSenseVa && 
        MappingInfo->RemappedSrbExtVa != NULL) {
        return(offset + (PUCHAR)MappingInfo->RemappedSrbExtVa);
    }
    else if (MappingInfo->RemappedSenseVa != NULL) {
        return(offset + (PUCHAR)MappingInfo->RemappedSenseVa);
    }

    return(address);
}

VOID
ScsiPortIoMapTransferVrfy(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    )
{
    ScsiPortIoMapTransfer(HwDeviceExtension,
                          Srb,
                          LogicalAddress,
                          Length);
    return;
}

VOID
ScsiPortMoveMemoryVrfy(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )
{
    ScsiPortMoveMemory(WriteBuffer,
                       ReadBuffer,
                       Length);
    return;
}

ULONG
ScsiPortSetBusDataByOffsetVrfy(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    ULONG Result;
    Result = ScsiPortSetBusDataByOffset(DeviceExtension,
                                        BusDataType,
                                        SystemIoBusNumber,
                                        SlotNumber,
                                        Buffer,
                                        Offset,
                                        Length);
    return Result;
}

BOOLEAN
ScsiPortValidateRangeVrfy(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )
{
    BOOLEAN Result;
    Result = ScsiPortValidateRange(HwDeviceExtension,
                                   BusType,
                                   SystemIoBusNumber,
                                   IoAddress,
                                   NumberOfBytes,
                                   InIoSpace);
    return Result;
}

VOID
ScsiPortStallExecutionVrfy(
    IN ULONG Delay
    )
{
    //
    // Miniports must specify a delay not more than one millisecond.
    //

    if (Delay > SpVrfyMaximumStall) {
        KeBugCheckEx(SCSI_VERIFIER_DETECTED_VIOLATION,
                     SCSIPORT_VERIFIER_STALL_TOO_LONG,
                     (ULONG_PTR)Delay,
                     0,
                     0);
    }

    KeStallExecutionProcessor(Delay);
}

//
// Timeout periods in ticks.  To calculate, we divide the time limit in 100 ns
// units by the TimeIncrement, which is the value returned by 
// KeQueryTimeIncrement.  Since KeQueryTickCount rounds up to the next
// tick, we'll add one tick to the defined limits.
//
#define SP_FIVE_SECOND_LIMIT  ((50000000L / TimeIncrement) + 1)
#define SP_TWO_SECOND_LIMIT   ((20000000L / TimeIncrement) + 1)
#define SP_HALF_SECOND_LIMIT  ((5000000L / TimeIncrement) + 1)

/*++

Macro Description:

    This macro checks the number of ticks elapsed during the execution of a
    miniport routine against a maximum number allowed ticks.  If the routine
    ran longer than the max allowable ticks, we bugcheck.

Arguments:

    Ticks     - number of ticks routine took to execute.

    MaxTicks  - number of ticks the routine is allowed to execute.

    Routine   - address of the routine we are checking.

    Extension - address of the miniport's HwDeviceExtension

Notes:

    The format for the bugcheck is:
        Parameter 1: 0x1002
        Parameter 2: address of routine that ran too long
        Parameter 3: address of miniport's HwDeviceExtension
        Parameter 4: duration of routine in microseconds

--*/
#define SpCheckMiniportRoutineDuration(Ticks, MaxTicks, Routine, Extension) \
{                                                                           \
    if ((Ticks) > (MaxTicks)) {                                             \
        KeBugCheckEx (                                                      \
            SCSI_VERIFIER_DETECTED_VIOLATION,                               \
            SCSIPORT_VERIFIER_MINIPORT_ROUTINE_TIMEOUT,                     \
            (ULONG_PTR)(Routine),                                           \
            (ULONG_PTR)(Extension),                                         \
            (ULONG_PTR)(((Ticks) * TimeIncrement) / 10));                   \
    }                                                                       \
}

ULONG
SpHwFindAdapterVrfy (
    IN PVOID HwDeviceExtension,
    IN PVOID HwContext,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    ULONG Result;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    Result =  AdapterExtension->VerifierExtension->RealHwFindAdapter(
                                                       HwDeviceExtension,
                                                       HwContext,
                                                       BusInformation,
                                                       ArgumentString,
                                                       ConfigInfo,
                                                       Again);
    return Result;
}

BOOLEAN
SpHwInitializeVrfy (
    IN PVOID HwDeviceExtension
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwInitialize(HwDeviceExtension);
    KeQueryTickCount(&Duration);
    Duration.QuadPart -= Start.QuadPart;

    if (VRFY_DO_CHECK(AdapterExtension, SP_DONT_CHK_HW_INITIALIZE_DURATION)) {
        SpCheckMiniportRoutineDuration(
            Duration.LowPart,
            SP_FIVE_SECOND_LIMIT,
            AdapterExtension->VerifierExtension->RealHwInitialize,
            HwDeviceExtension);
    }

    return Result;
}

BOOLEAN
SpHwStartIoVrfy (
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PSRB_DATA srbData;

    //
    // If MapBuffers is not set, the miniport is not supposed to touch
    // the DataBuffer field in the SRB.  To verify this, we'll set
    // DataBuffer to point to memory that will fault if the miniport tries
    // to touch it.
    //

    ASSERT(Srb != NULL);
    srbData = (PSRB_DATA)Srb->OriginalRequest;
    ASSERT_SRB_DATA(srbData);

    if (AdapterExtension->MapBuffers == FALSE 
        && !IS_MAPPED_SRB(Srb)
        && Srb->DataBuffer != NULL
        && AdapterExtension->VerifierExtension->InvalidPage != NULL) {

        if (Srb->DataBuffer != AdapterExtension->VerifierExtension->InvalidPage) {
            srbData->UnmappedDataBuffer = Srb->DataBuffer;
            Srb->DataBuffer = AdapterExtension->VerifierExtension->InvalidPage;
        } else {
            ASSERT(srbData->UnmappedDataBuffer != &SpMarker);
            ASSERT(srbData->UnmappedDataBuffer != NULL);
        }

    } else {

        srbData->UnmappedDataBuffer = &SpMarker;

    }

    //
    // Call the miniport's StartIo function and calculate the call's duration.
    //

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwStartIo(
                                                      HwDeviceExtension,
                                                      Srb);
    KeQueryTickCount(&Duration);
    Duration.QuadPart -= Start.QuadPart;

    //
    // Bugcheck if the call took more than .5 seconds.
    //

    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwStartIo,
        HwDeviceExtension);

    //
    // If the HwStartIo returns failure, undo any fixups we performed on the SRB.
    //

    if (Result == FALSE 
        && srbData->UnmappedDataBuffer != &SpMarker) {

        ASSERT(srbData->UnmappedDataBuffer != NULL);
        Srb->DataBuffer = srbData->UnmappedDataBuffer;
        srbData->UnmappedDataBuffer = NULL; 

    }

    return Result;
}


BOOLEAN
SpHwInterruptVrfy (
    IN PVOID HwDeviceExtension
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwInterrupt (
                                                      HwDeviceExtension);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwInterrupt,
        HwDeviceExtension);

    return Result;
}

BOOLEAN
SpHwResetBusVrfy (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwResetBus(
                                                      HwDeviceExtension,
                                                      PathId);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwResetBus,
        HwDeviceExtension);

    return Result;
}

VOID
SpHwDmaStartedVrfy (
    IN PVOID HwDeviceExtension
    )
{
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    AdapterExtension->VerifierExtension->RealHwDmaStarted(
                                             HwDeviceExtension);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwDmaStarted,
        HwDeviceExtension);
}

BOOLEAN
SpHwRequestInterruptVrfy (
    IN PVOID HwDeviceExtension
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwRequestInterrupt(
                                                      HwDeviceExtension);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwRequestInterrupt,
        HwDeviceExtension);

    return Result;
}

BOOLEAN
SpHwTimerRequestVrfy (
    IN PVOID HwDeviceExtension
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwTimerRequest(
                                                      HwDeviceExtension);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwTimerRequest,
        HwDeviceExtension);

    return Result;
}

SCSI_ADAPTER_CONTROL_STATUS
SpHwAdapterControlVrfy (
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    SCSI_ADAPTER_CONTROL_STATUS Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount (&Start);
    Result = AdapterExtension->VerifierExtension->RealHwAdapterControl(
                                                      HwDeviceExtension,
                                                      ControlType,
                                                      Parameters);
    KeQueryTickCount(&Duration);
    Duration.QuadPart -= Start.QuadPart;

    if (VRFY_DO_CHECK(AdapterExtension, SP_DONT_CHK_HW_ADAPTERCONTROL_DURATION)) {
        SpCheckMiniportRoutineDuration(
            Duration.LowPart,
            SP_HALF_SECOND_LIMIT,
            AdapterExtension->VerifierExtension->RealHwAdapterControl,
            HwDeviceExtension);
    }

    return Result;
}

VOID
SpVerifySrbStatus(
    PVOID HwDeviceExtension,
    PSCSI_REQUEST_BLOCK srb
    )

/*++

Routine Description:

    Verify that the SRB's status as set by the miniport driver is valid.

Arguments:

    HwDeviceExtension - The port driver's device extension follows the 
                        miniport's device extension and contains a pointer to
                        the logical device extension list.

    srb               - Points to the SRB.

Return Value:

    VOID

--*/

{
    UCHAR SrbStatus;

    //
    // Turn off internal bits used by scsiport.
    //

    SrbStatus = srb->SrbStatus & ~(SRB_STATUS_QUEUE_FROZEN | 
                                   SRB_STATUS_AUTOSENSE_VALID);

    //
    // Miniports may never set the status to SRB_STATUS_PENDING.
    //

    if (SrbStatus == SRB_STATUS_PENDING) {
        goto BadStatus;
    }

    //
    // If the function is SRB_FUNCTION_EXECUTE_SCSI, then the command must be
    // either completed successfully, or ScsiStatus must be set to
    // SCSISTAT_GOOD.
    //

    if (!(SrbStatus != SRB_STATUS_SUCCESS ||
          srb->ScsiStatus == SCSISTAT_GOOD ||
          srb->Function != SRB_FUNCTION_EXECUTE_SCSI)) {
        goto BadStatus;
    }

    //
    // Make sure the status is within the valid range.
    //

    if ((SrbStatus) == 0x0C ||
        (SrbStatus > 0x16 && srb->SrbStatus < 0x20) ||
        (SrbStatus > 0x23)) {
        goto BadStatus;
    }

    //
    // The SRB Status is ok.
    //

    return;

BadStatus:
    //
    // Bugcheck if the status is bad.
    //

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  SCSIPORT_VERIFIER_BAD_SRBSTATUS,
                  (ULONG_PTR)srb,
                  (ULONG_PTR)HwDeviceExtension,
                  0);
}

PVOID
SpRemapBlock(
    IN PVOID BlockVa,
    IN ULONG BlockSize,
    OUT PMDL* Mdl
    )
/*++

Routine Description:

    This function attempts to remap the supplied VA range.  If the block is
    remapped, it will be made invalid for reading and writing.

Arguments:

    BlockVa   - Supplies the address of the block of memory to remap.

    BlockSize - Supplies the size of the block of memory to remap.

    Mdl       - Supplies the address into which the function will store
                a pointer to the MDL for the remapped range.  If the MDL
                cannot be allocated or if the range cannot be remapped,
                this will be NULL upon return.

Return Value:

    If the range is successfully remapped, the address of the beginning of
    the remapped range is returned.  Else, NULL is returned.

--*/
{
    PVOID MappedRange;
    NTSTATUS Status;
    PMDL LocalMdl;

    //
    // Try to allocate a new MDL for the range we're trying to remap.
    //

    LocalMdl = IoAllocateMdl(BlockVa, BlockSize, FALSE, FALSE, NULL);
    if (LocalMdl == NULL) {
        *Mdl = NULL;
        return NULL;
    }

    //
    // Try to lock the pages.  This initializes the MDL properly.
    //

    __try {
        MmProbeAndLockPages(LocalMdl, KernelMode, IoModifyAccess);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        IoFreeMdl(LocalMdl);
        *Mdl = NULL;
        return NULL;
    }

    //
    // Try to remap the range represented by the new MDL.
    //

    MappedRange = MmMapLockedPagesSpecifyCache(LocalMdl,
                                               KernelMode,
                                               MmCached,
                                               NULL,
                                               FALSE,
                                               NormalPagePriority);
    if (MappedRange == NULL) {
        IoFreeMdl(LocalMdl);
        *Mdl = NULL;
        return NULL;
    }

    //
    // If we've gotten this far, we have successfully remapped the range.
    // Now we want to invalidate the entire range so any accesses to it
    // will be trapped by the system.
    //

    Status = MmProtectMdlSystemAddress(LocalMdl, PAGE_NOACCESS);
#if DBG==1
    if (!NT_SUCCESS(Status)) {
        DebugPrint((0, "SpRemapBlock: failed to remap block:%p mdl:%p (%x)\n", 
                    BlockVa, LocalMdl, Status));
    }
#endif

    //
    // Copy the MDL we allocated into the supplied address and return the
    // address of the beginning of the remapped range.
    //

    *Mdl = LocalMdl;
    return MappedRange;
}

VOID
SpRemapCommonBufferForMiniport(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine attempts to remap all of the common buffer blocks allocated
    for a particular adapter.

Arguments:

    DeviceExtension - Supplies a pointer to the adapter device extension.

--*/
{
    PVOID* BlkAddr = Adapter->VerifierExtension->CommonBufferVAs;
    PSP_VA_MAPPING_INFO MappingInfo;
    PVOID RemappedVa;
    ULONG Size;
    PMDL Mdl;
    ULONG i;

    //
    // Iterate through all of the common buffer blocks, and attempt to remap
    // the SRB extension and the sense buffer within each block.
    //

    for (i = 0; i < Adapter->VerifierExtension->CommonBufferBlocks; i++) {

        //
        // Get a pointer to the mapping info we keep at the end of the block.
        //

        MappingInfo = GET_VA_MAPPING_INFO(Adapter, BlkAddr[i]);
      
        //
        // Initialize the original VA info for the SRB extension.
        //

        MappingInfo->OriginalSrbExtVa = BlkAddr[i];
        MappingInfo->SrbExtLen = (ULONG)ROUND_TO_PAGES(Adapter->SrbExtensionSize);

        //
        // Initialize the original VA info for the sense buffer.
        //

        MappingInfo->OriginalSenseVa = (PUCHAR)BlkAddr[i] + MappingInfo->SrbExtLen;
        MappingInfo->SenseLen = PAGE_SIZE;

        //
        // Try to remap the SRB extension.  If successful, initialize the
        // remapped VA info for the SRB extension.
        //

        RemappedVa = SpRemapBlock(MappingInfo->OriginalSrbExtVa, 
                                  MappingInfo->SrbExtLen, 
                                  &Mdl);
        if (RemappedVa != NULL) {
            MappingInfo->RemappedSrbExtVa = RemappedVa;
            MappingInfo->SrbExtMdl = Mdl;
        }

#if 0
        //
        // Try to remap the sense buffer.  If successful, initialize the
        // remapped VA info for the sense buffer.
        //
        // For now, I think we can live without this.  I don't know of any
        // issues where overruns etc. occur in a sense buffer.
        //

        RemappedVa = SpRemapBlock(MappingInfo->OriginalSenseVa, 
                                  MappingInfo->SenseLen, 
                                  &Mdl);
        if (RemappedVa != NULL) {
            MappingInfo->RemappedSenseVa = RemappedVa;
            MappingInfo->SenseMdl = Mdl;
        }
#endif
    }

    if (Adapter->VerifierExtension->NonCachedBufferSize != 0) {
        //
        // Init uncached extension mapping info.
        //

        Size = (ULONG)ROUND_TO_PAGES(Adapter->VerifierExtension->NonCachedBufferSize);
        MappingInfo = (PSP_VA_MAPPING_INFO)((PUCHAR)BlkAddr[i] + (Size - PAGE_SIZE));
        MappingInfo->OriginalSrbExtVa = BlkAddr[i];
        MappingInfo->SrbExtLen = Adapter->VerifierExtension->NonCachedBufferSize;
        MappingInfo->OriginalSenseVa = (PUCHAR)BlkAddr[i] + Adapter->VerifierExtension->NonCachedBufferSize;
    }
}

PVOID
SpAllocateContiguousChunk(
    IN PDRIVER_OBJECT     DriverObject,
    IN PDMA_ADAPTER       DmaAdapterObject,
    IN BOOLEAN            Dma64BitAddresses,
    IN ULONG              Length,
    IN ULONG              Align,
    OUT PHYSICAL_ADDRESS *PhysicalCommonBuffer,
    OUT BOOLEAN          *CommonBuffer
    )

/*++

Routine Description:

    This routine allocates a chunk of memory which can be used for common
    buffer io.  Where the memory is allocated from depends on several 
    parameters.  If no adapter object is specified, the memory is simply
    allocated from non-paged pool.  Else, the memory is allocated such
    that it can be used in DMA operations.

Arguments:

    DriverObject           - Supplies a pointer to the driver object.

    DmaAdapterObject       - Supplies a pointer to the adapter's DMA adapter
                             object.

    Dma64BitAddresses      - Specifies whether the adapter supports 64-bit.

    Length                 - Specifies the number of bytes to allocate.

    Align                  - Alignment requirement for uncached extension.

    PhysicalCommonBuffer   - Specifies a pointer into which the physical
                             address of the allocated memory is to be copied
                             if the memory is allocated for DMA operations.

    CommonBuffer           - Supplies a pointer to a boolean that we set if the
                             memory is allocated using AllocateCommonBuffer.

Return Value:

    Returns the VA of the allocated memory if the allocation succeeds.  Else,
    returns NULL.

--*/

{
    PVOID Buffer;

    if (DmaAdapterObject == NULL) {

        //
        // Since there is no adapter object just allocate from non-paged pool.
        //

        Buffer = SpAllocatePool(
                     NonPagedPool,
                     Length,
                     SCSIPORT_TAG_COMMON_BUFFER,
                     DriverObject);
    } else {

        ASSERT(PhysicalCommonBuffer != NULL);

        //
        // If the controller can do 64-bit addresses then we need to
        // specifically force the uncached extension area below the 4GB mark.
        //

        if (((Sp64BitPhysicalAddresses) && (Dma64BitAddresses == TRUE)) ||
            Align != 0) {

            PHYSICAL_ADDRESS low;
            PHYSICAL_ADDRESS high;
            PHYSICAL_ADDRESS boundary;

            if (Align != 0) {
                boundary.QuadPart = Length;
            } else {
                boundary.QuadPart = 0;
            }

            low.QuadPart = 0;
            high.HighPart = 0;
            high.LowPart = 0xffffffff;

            //
            // We'll get page aligned memory out of this which is probably 
            // better than the requirements of the adapter.
            //

            Buffer = MmAllocateContiguousMemorySpecifyCache(
                         Length,
                         low,
                         high,
                         boundary,
                         MmCached);

            if (Buffer != NULL) {
                *PhysicalCommonBuffer = MmGetPhysicalAddress(Buffer);
            }

            if (CommonBuffer != NULL) {
                *CommonBuffer = FALSE;
            }

        } else {
            Buffer = AllocateCommonBuffer(
                         DmaAdapterObject,
                         Length,
                         PhysicalCommonBuffer,
                         FALSE);

            if (CommonBuffer != NULL) {
                *CommonBuffer = TRUE;
            }
        }
    }

    return Buffer;
}

NTSTATUS
SpGetCommonBufferVrfy(
    PADAPTER_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    )
/*++

Routine Description:

    This function allocates multiple common buffer blocks instead of one
    big one.  The verifier does this so it can remap VA ranges within
    each block in order to control their protection attributes.  This
    enables us to invalidate key VA ranges and catch miniports that attempt
    to access these ranges when they should not.

    If the remapping succeeds, the SCSI port driver hands out the remapped
    VA ranges to miniports instead of the original ranges.  If the remapping
    fails, it just hands out the original ranges.

Arguments:

    DeviceExtension        - Supplies a pointer to the device extension.

    NonCachedExtensionSize - Supplies the size of the noncached device
                             extension for the miniport driver.

Return Value:

    Returns the status of the allocate operation.

--*/
{
    NTSTATUS Status;
    PVOID buffer;
    ULONG length;
    ULONG blockSize;
    PVOID *srbExtension;
    PVOID buffer2;
    PMDL  mdl;
    ULONG TotalSize;
    ULONG i;
    PVOID* BlkAddr;
    PHYSICAL_ADDRESS *PhysicalCommonBuffer;
    PCCHAR InvalidRegion;
    BOOLEAN commonBuffer;    

    PAGED_CODE();

    DebugPrint((1, "SpGetCommonBufferVrfy: DeviceExtension:%p NonCachedExtensionSize:%d\n",
                DeviceExtension, NonCachedExtensionSize));

    //
    // Now fixup the size if the adapter has special alignment requirements so
    // the buffer we allocate may be aligned as required.
    //

    if (DeviceExtension->UncachedExtAlignment != 0) {
	NonCachedExtensionSize = 
           ROUND_UP_COUNT(NonCachedExtensionSize, 
                          DeviceExtension->UncachedExtAlignment);
    }

    //
    // We maintain a couple of arrays in order to find our common
    // buffer blocks at various times.  Calculate the amount of space we
    // need for these arrays.  This amount depends on the number of
    // simultaneous requests the adapter supports.  We add one to the
    // number of requests in order to accommodate the non-cached extension.
    //

    ASSERT(DeviceExtension->VerifierExtension->CommonBufferVAs == NULL);

    i = DeviceExtension->NumberOfRequests + 1;
    length = sizeof(PVOID) * i;

    if (DeviceExtension->DmaAdapterObject != NULL) {
        ASSERT(DeviceExtension->VerifierExtension->CommonBufferPAs == NULL);
        length += (sizeof(PHYSICAL_ADDRESS) * i);
    }

    //
    // Allocate a block of memory for these arrays.  If this allocation fails,
    // we return failure.
    //

    BlkAddr = SpAllocatePool(NonPagedPool,
                            length,
                            SCSIPORT_TAG_COMMON_BUFFER,
                            DeviceExtension->DeviceObject->DriverObject);

    if (BlkAddr == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Save the number of common buffer blocks.
    //

    DeviceExtension->VerifierExtension->CommonBufferBlocks =
       DeviceExtension->NumberOfRequests;

    //
    // Zero the entire block so when we're freeing resources we can tell if we
    // have valid buffers to free.
    //

    RtlZeroMemory(BlkAddr, length);

    //
    // Save a pointer to the array of addresses in the adapter extension and,
    // if there is an adapter object, initialize a pointer to the beginning of
    // the physical address array and save a pointer to the array in the
    // adapter extension.
    //

    DeviceExtension->VerifierExtension->CommonBufferVAs = (PVOID *)BlkAddr;
    if (DeviceExtension->DmaAdapterObject != NULL) {
        PhysicalCommonBuffer = (PHYSICAL_ADDRESS*) &BlkAddr[i];
        DeviceExtension->VerifierExtension->CommonBufferPAs = PhysicalCommonBuffer;
    }

    //
    // To ensure that we never transfer normal request data to the SrbExtension
    // (ie. the case of Srb->SenseInfoBuffer == VirtualAddress in
    // ScsiPortGetPhysicalAddress) on some platforms where an inconsistency in
    // MM can result in the same Virtual address supplied for 2 different
    // physical addresses, bump the SrbExtensionSize if it's zero.
    //

    if (DeviceExtension->SrbExtensionSize == 0) {
        DeviceExtension->SrbExtensionSize = 16;
    }

    //
    // Calculate the block size for an SRB extension/sense buffer block. If
    // AutoRequestSense is FALSE, allocate 1 page anyway as a placeholder.
    //

    blockSize = (ULONG)ROUND_TO_PAGES(DeviceExtension->SrbExtensionSize);
    if (DeviceExtension->AutoRequestSense == TRUE) {        
        blockSize += sizeof(SENSE_DATA) + DeviceExtension->AdditionalSenseBytes;
        blockSize = (ULONG)ROUND_TO_PAGES(blockSize);                   
    } else {
        blockSize += PAGE_SIZE;
    }

    //
    // Add a page for holding bookkeeping information.
    //

    blockSize += PAGE_SIZE;

    //
    // Allocate each block individually and link them all together into a
    // list.  If we fail to allocate any of the blocks, we clean everything up 
    // and return failure.
    //

    DeviceExtension->CommonBufferSize = blockSize;
    srbExtension = NULL;

    for (i = 0; i < DeviceExtension->NumberOfRequests; i++) {

        //
        // Allocate a contiguous chunk of memory for the block.
        //

        buffer = SpAllocateContiguousChunk(
            DeviceExtension->DeviceObject->DriverObject,
            DeviceExtension->DmaAdapterObject,
            DeviceExtension->Dma64BitAddresses,
            blockSize,
            0,
            (DeviceExtension->DmaAdapterObject) ? &PhysicalCommonBuffer[i] : NULL,
            &commonBuffer);
                                           
        if (buffer == NULL) {

            //
            // Free everything we've allocated so far and return failure.  This
            // will also free the arrays we allocated at the beginning of this
            // function.
            //
            
            DeviceExtension->VerifierExtension->IsCommonBuffer = commonBuffer;
            SpFreeCommonBufferVrfy(DeviceExtension);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Zero the entire block and save a pointer to it in our array.
        //

        RtlZeroMemory(buffer, blockSize);
        BlkAddr[i] = buffer;

        //
        // Link the new block onto the front of the chain.
        //

        *((PVOID *) buffer) = srbExtension;
        srbExtension = (PVOID *) buffer;
    }

    //
    // Indicate whether the buffer was allocated as common buffer.
    //

    DeviceExtension->VerifierExtension->IsCommonBuffer = commonBuffer;
   
    //
    // Allocate the non-cached extension.  Note that we align the uncached
    // buffer on the next page boundary and allocate enough for a scratch page.
    // If the allocation fails, free everything we've allocated so far and
    // return failure.
    //

    if (NonCachedExtensionSize != 0) {

        DeviceExtension->VerifierExtension->NonCachedBufferSize = NonCachedExtensionSize;
        length = (ULONG)(ROUND_TO_PAGES(NonCachedExtensionSize));

        BlkAddr[i] =
           SpAllocateContiguousChunk(
               DeviceExtension->DeviceObject->DriverObject,
               DeviceExtension->DmaAdapterObject,
               DeviceExtension->Dma64BitAddresses,
               length,
               DeviceExtension->UncachedExtAlignment,
               (DeviceExtension->DmaAdapterObject) ? &PhysicalCommonBuffer[i] : NULL,
               &DeviceExtension->UncachedExtensionIsCommonBuffer);
        
        if (BlkAddr[i] == NULL) {

            //
            // Free everything we've allocated so far and return failure.  This
            // will also free the arrays we allocated at the beginning of this
            // function.
            //
            
            SpFreeCommonBufferVrfy(DeviceExtension);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Zero the entire block.
        //

        RtlZeroMemory(BlkAddr[i], length);

        //
        // Save a pointer to the beginning of the non-cached extension data.  
        // Note that the data is positioned such that it ends on a page 
        // boundary so if the miniport overwrites the buffer, the system will
        // fault.
        //

        DeviceExtension->NonCachedExtension = 
           (PCCHAR)BlkAddr[i] + 
           (ROUND_TO_PAGES(NonCachedExtensionSize) - NonCachedExtensionSize);

    } else {

        DeviceExtension->NonCachedExtension = NULL;
        DeviceExtension->VerifierExtension->NonCachedBufferSize = 0;

    }

    //
    // If the miniport asked for an SRB Extension, point the SRB Extension List
    // at the beginning of the list of blocks we allocated and chained together 
    // above.
    //

    if (DeviceExtension->AllocateSrbExtension == TRUE) {
        DeviceExtension->SrbExtensionListHeader = srbExtension;
    } else {
        ASSERT(DeviceExtension->SrbExtensionListHeader == NULL);
    }

    //
    // Create a second VA mapping of the common buffer area so we can make the
    // range of addresses invalid when the miniport is not supposed to touch it.
    // This will allow us to catch mis-behaving miniports.
    // 

    SpRemapCommonBufferForMiniport(DeviceExtension);

    DebugPrint((1, "SpGetCommonBufferVrfy: returning STATUS_SUCCESS\n"));
    return(STATUS_SUCCESS);
}

VOID
SpFreeCommonBufferVrfy(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine frees all of the common buffer space we've allocated for the
    miniport on the supplied adapter.  If only partially allocated, the routine 
    correctly cleans up the parts that are present.  On exit, all the memory has 
    been freed and the associated pointers have been NULLed.

Arguments:

    DeviceExtension - Supplies a pointer to the adapter device extension.

Return Value:

    VOID

--*/
{
    ULONG i;
    PVOID* BlkAddr;
    NTSTATUS Status;
    PSP_VA_MAPPING_INFO MappingInfo;

    ASSERT(Adapter->SrbExtensionBuffer == NULL);

    if (Adapter->VerifierExtension != NULL &&
        Adapter->VerifierExtension->CommonBufferVAs != NULL) {
        //
        // Initialize a pointer to the array of pointers we use to track and
        // manage the common buffer blocks.
        //

        BlkAddr = Adapter->VerifierExtension->CommonBufferVAs;

        //
        // Cycle through the array of common memory descriptors, freeing each
        // one.  What we are freeing here is the SRB Extension/Sense Data
        // buffers.  Stop when we've deleted all the blocks.
        //

        for (i = 0; i < Adapter->VerifierExtension->CommonBufferBlocks && BlkAddr[i]; i++) {

            //
            // If there is a second VA range for the common block, free the 
            // MDL(s).
            // 

            MappingInfo = GET_VA_MAPPING_INFO(Adapter, BlkAddr[i]);
            
            if (MappingInfo->SrbExtMdl != NULL) {
                MmProtectMdlSystemAddress(MappingInfo->SrbExtMdl, PAGE_READWRITE);
                MmUnlockPages(MappingInfo->SrbExtMdl);
                IoFreeMdl(MappingInfo->SrbExtMdl);
            }

            if (MappingInfo->SenseMdl != NULL) {
                MmProtectMdlSystemAddress(MappingInfo->SrbExtMdl, PAGE_READWRITE);
                MmUnlockPages(MappingInfo->SenseMdl);
                IoFreeMdl(MappingInfo->SenseMdl);
            }

            //
            // Free the memory.  The method we use depends on how the memory
            // was allocated.
            //

            if (Adapter->DmaAdapterObject == NULL) {
                ExFreePool(BlkAddr[i]);            
            } else {
                if (Adapter->VerifierExtension->IsCommonBuffer == FALSE) {
                    MmFreeContiguousMemorySpecifyCache(
                        BlkAddr[i],
                        Adapter->CommonBufferSize,
                        MmCached);
                } else {
                    FreeCommonBuffer(
                        Adapter->DmaAdapterObject,
                        Adapter->CommonBufferSize,
                        Adapter->VerifierExtension->CommonBufferPAs[i],
                        BlkAddr[i],
                        FALSE);
                }
            }
        }

        //
        // Free the uncached extension if we allocated one.
        //

        if (Adapter->NonCachedExtension != NULL) {
            
            ULONG Length;

            //
            // Calculate the total length of the non-cached extension block we
            // allocated.  This is the non-cached buffer size asked for by the
            // miniport rounded up to the next page boundary plus one full page.
            //

            Length = (ULONG)(ROUND_TO_PAGES(Adapter->VerifierExtension->NonCachedBufferSize));
            
            //
            // Free the memory.  The method we use depends on how the memory
            // was allocated.
            //
            
            if (Adapter->DmaAdapterObject == NULL) {        
                ExFreePool(BlkAddr[i]);
            } else {
                if (Adapter->UncachedExtensionIsCommonBuffer == FALSE) {
                    MmFreeContiguousMemorySpecifyCache(
                        BlkAddr[i],
                        Length,
                        MmCached);
                } else {
                    FreeCommonBuffer(
                        Adapter->DmaAdapterObject,
                        Length,
                        Adapter->VerifierExtension->CommonBufferPAs[i],
                        BlkAddr[i],
                        FALSE);
                }
            }

            Adapter->NonCachedExtension = NULL;
        }

        //
        // Free the arrays we allocated to manage the common buffer area.
        //
        
        ExFreePool(Adapter->VerifierExtension->CommonBufferVAs);
        Adapter->VerifierExtension->CommonBufferVAs = NULL;
        Adapter->VerifierExtension->CommonBufferPAs = NULL;
        Adapter->VerifierExtension->CommonBufferBlocks = 0;
        Adapter->SrbExtensionListHeader = NULL;
    }
}

PVOID
SpGetOriginalSrbExtVa(
    PADAPTER_EXTENSION Adapter,
    PVOID Va
    )
/*++

Routine Description:

    This function returns the original mapped virtual address of a common
    block if the supplied VA is for one of the common buffer blocks we've
    allocated.

Arguments:

    Adapter - the adapter device extension

    Va - virtual address of a common buffer block

Return Value:

    If the supplied VA is the address of one of the common buffer blocks,
    returns the original VA of the block.  Else, returns NULL.

--*/
{
    PVOID* BlkAddr = Adapter->VerifierExtension->CommonBufferVAs;
    PSP_VA_MAPPING_INFO MappingInfo;
    ULONG i;
    
    for (i = 0; i < Adapter->VerifierExtension->CommonBufferBlocks; i++) {
        MappingInfo = GET_VA_MAPPING_INFO(Adapter, *BlkAddr++);
        if (Va == MappingInfo->RemappedSrbExtVa || 
            Va == MappingInfo->OriginalSrbExtVa)
            return MappingInfo->OriginalSrbExtVa;
    }

    return NULL;
}

VOID
SpInsertSrbExtension(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    )
/*++

Routine Description:

    This routine inserts the supplied SRB extension back into the SRB extension
    list.  The VA of the supplied extension lies within one of our common buffer
    blocks and it may be a remapped VA.  If it is a remapped address, this
    routine invalidates the page(s) comprising the extension after it links the
    extension back into the list.

Arguments:

    Adapter      - Pointer to an adapter device extension.

    SrbExtension - Pointer to the beginning of an SRB extension within one of
                   our common buffer blocks.  May or may not be within a
                   remapped range.

--*/
{
    //
    // Round the srb extension pointer down to the beginning of the page
    // and link the block back into the list.  Note that we're careful
    // to point the list header at the original VA of the block.
    //

    SrbExtension = (PVOID)((ULONG_PTR)SrbExtension & ~(PAGE_SIZE - 1));
    *((PVOID *) SrbExtension) = Adapter->SrbExtensionListHeader;    
    Adapter->SrbExtensionListHeader = SpGetOriginalSrbExtVa(
                                          Adapter, 
                                          SrbExtension);
    
    //
    // If the original VA differs from the one supplied, the supplied
    // one is one of our remapped VAs.  In this case, we want to invalidate
    // the range so the system will bugcheck if anyone tries to access it.
    //
                    
    if (Adapter->SrbExtensionListHeader != SrbExtension) {
        PMDL Mdl = SpGetRemappedSrbExt(Adapter, Adapter->SrbExtensionListHeader);
        ASSERT(Mdl != NULL);
        MmProtectMdlSystemAddress(Mdl, PAGE_NOACCESS);

        //
        // Just because we remapped the SRB extension does not mean we
        // necessarily remapped the sense buffer.
        //

        Mdl = SpGetRemappedSenseBuffer(Adapter, Adapter->SrbExtensionListHeader);
        if (Mdl != NULL) {
            MmProtectMdlSystemAddress(Mdl, PAGE_NOACCESS);
        }
    }
}

PVOID
SpPrepareSrbExtensionForUse(
    IN PADAPTER_EXTENSION Adapter,
    IN OUT PCCHAR SrbExtension
    )
/*++

Routine Description:

    This function accepts a pointer to the beginning of one of the individual 
    common-buffer blocks allocated by the verifier for SRB extensions, sense 
    buffers, and non-cached extensions.  It calculates the beginning of the 
    SRB extension within the block and, if the block has been remapped, makes 
    the page(s) of the SRB extension read/write valid.

Arguments:

    Adapter      - Pointer to an adapter device extension.

    SrbExtension - Pointer to the beginning of a common-buffer block.

Return Value:

    If the common buffer block containing the SRB extension has been remapped, 
    returns the address of the beginning of the remapped srb extension, valid 
    for reading and writing.  

    If the block has not been remapped, returns NULL.

    Regardless of whether the block is remapped or not, the supplied pointer
    is fixed up to point to the beginning of the SRB extension within the
    original VA range.

--*/
{
    PCCHAR RemappedSrbExt = NULL;
    NTSTATUS Status;
    PMDL Mdl;
    ULONG srbExtensionSize = ROUND_UP_COUNT(Adapter->SrbExtensionSize, 8);

    //
    // If we've remapped the SRB extension, get the second mapping and make it
    // valid.  If we get the second mapping, but cannot make it valid, we just
    // use the original mapping.
    //

    Mdl = SpGetRemappedSrbExt(Adapter, SrbExtension);
    if (Mdl != NULL) {
        Status = MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);
        if (NT_SUCCESS(Status)) {
            RemappedSrbExt = MmGetSystemAddressForMdlSafe(Mdl, NormalPagePriority);

            //
            // Adjust the remapped srb extension pointer so the end of the 
            // buffer falls on a page boundary.
            //

            RemappedSrbExt += ((Adapter->CommonBufferSize - (PAGE_SIZE * 2)) - srbExtensionSize);
        }
    }
    
    //
    // Adjust the original srb extension pointer so it also ends on a page boundary.
    //

    SrbExtension += ((Adapter->CommonBufferSize - (PAGE_SIZE * 2)) - srbExtensionSize);

    return RemappedSrbExt;
}

PCCHAR
SpPrepareSenseBufferForUse(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    )
/*++

Routine Description:

    This function accepts a pointer to the beginning of an SRB extension
    within one of the individual common-buffer blocks allocated by the 
    verifier for SRB extensions, sense buffers, and non-cached extensions.
    It calculates the beginning of the sense buffer within the block and,
    if the block has been remapped, makes the page read/write valid.

    It is assumed that a sense buffer will never be larger than one page.

Arguments:

    Adapter      - Pointer to an adapter device extension.

    SrbExtension - Pointer to the beginning of the SRB extension within a 
                   common-buffer block.

Return Value:

    Returns the address of the beginning of a sense buffer valid for
    reading and writing.

--*/
{
    PVOID BeginningOfBlock;
    ULONG SenseDataSize;
    PCCHAR Base;
    NTSTATUS Status;
    PMDL Mdl;
    ULONG srbExtensionSize = (ULONG)ROUND_TO_PAGES(Adapter->SrbExtensionSize);

    //
    // Initialize the size of the sense buffer and the base of the sense buffer
    // within the originally allocated block.  The base of the sense buffer
    // immediately follows the srb extension and resides on a page boundary
    // within a common buffer block.
    //

    SenseDataSize = sizeof(SENSE_DATA) + Adapter->AdditionalSenseBytes;
    SenseDataSize = ROUND_UP_COUNT(SenseDataSize, 8);
    Base = SrbExtension + srbExtensionSize;

    //
    // Initialize a pointer to the beginning of the common block the sense 
    // buffer resides in.  This is needed in order to determine if the
    // sense buffer has been remapped.
    //

    BeginningOfBlock = (PVOID)((ULONG_PTR)SrbExtension & ~(PAGE_SIZE - 1));

    //
    // If we've remapped the sense buffer, make the range valid and reset base
    // to point to the beginning of the range.
    //

    Mdl = SpGetRemappedSenseBuffer(Adapter, BeginningOfBlock);
    if (Mdl != NULL) {
        Status = MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);
        if (NT_SUCCESS(Status)) {
            Base = MmGetSystemAddressForMdlSafe(Mdl, NormalPagePriority);
            ASSERT(Base != NULL);
        }
    }
    
    //
    // Return a pointer into the block such that the sense buffer ends aligned
    // on a page boundary.
    //

    return (Base + PAGE_SIZE - SenseDataSize);
}

PVOID
SpGetInaccessiblePage(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This function returns a pointer to a page of memory that is not valid
    for reading or writing.  This page is a shared resource, used by all
    adapters that are actively verifying.  The page is hung off of the driver
    extension.  The page is faulted in as needed, so if we haven't initialized
    it yet, we try to do so here in an interlocked fashion.

Arguments:

    Adapter - Pointer to an adapter device extension.

Return Value:

    Either returns a pointer to an invalid page of VAs or NULL if the page
    could not be allocated.

--*/
{
    PSCSIPORT_DRIVER_EXTENSION DriverExtension;
    PVOID UnusedPage;
    PVOID InvalidPage;
    PMDL UnusedPageMdl;
    PVOID CurrentValue;

    //
    // Retrieve the driver extension.  We must have it to proceed.
    //

    DriverExtension = IoGetDriverObjectExtension(
                          Adapter->DeviceObject->DriverObject,
                          ScsiPortInitialize);
    if (DriverExtension == NULL) {
        return NULL;
    }

    //
    // If the invalid page is not yet initialized, go ahead and try to 
    // initialize it now.
    //

    if (DriverExtension->InvalidPage == NULL) {

        //
        // Allocate a page of memory.
        //

        UnusedPage = SpAllocatePool(NonPagedPool,
                                    PAGE_SIZE,
                                    SCSIPORT_TAG_VERIFIER,
                                    Adapter->DeviceObject->DriverObject);

        if (UnusedPage != NULL) {
            
            //
            // Zero the page and remap it.  The remapped range will be inaccessible.
            // If the remapping fails, just free the page; we just won't have an
            // inaccessible page to work with.
            //
            
            RtlZeroMemory(UnusedPage, PAGE_SIZE);
            InvalidPage = SpRemapBlock(UnusedPage,
                                       PAGE_SIZE,
                                       &UnusedPageMdl);

            if (InvalidPage != NULL) {

                //
                // If nobody else has beaten us to it, init the pointer to the
                // invalid page in the driver extension.  If somebody has already
                // done it, just free the page we created.  This page is freed
                // when scsiport is unloaded.
                //

                CurrentValue = InterlockedCompareExchangePointer(
                                   &DriverExtension->InvalidPage,
                                   InvalidPage,
                                   NULL);
                if (CurrentValue == NULL) {

                    DriverExtension->UnusedPage = UnusedPage;
                    DriverExtension->UnusedPageMdl = UnusedPageMdl;
    
                } else {

                    MmProtectMdlSystemAddress(UnusedPageMdl, PAGE_READWRITE);
                    UnusedPageMdl->MdlFlags &= ~MDL_MAPPED_TO_SYSTEM_VA;
                    IoFreeMdl(UnusedPageMdl);
                    ExFreePool(UnusedPage);

                }

            } else {

                //
                // Couldn't make the page inaccessible, just free it.
                //

                ExFreePool(UnusedPage);
            }
        }
    }

    return DriverExtension->InvalidPage;
}

BOOLEAN
SpCheckForActiveRequests(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This function walks through all of the logical units connected to the
    supplied adapter looking for any outstanding requests.  If it finds
    any, it returns TRUE immediately.

Arguments:

    Adapter - Pointer to an adapter device extension.

Return Value:

    TRUE  - If an outstanding requests is found on one of the logical units
            connected to the adapter.

    FALSE - If no outstanding requests on the adapter.

--*/
{
    PLOGICAL_UNIT_EXTENSION LogicalUnit;
    PLOGICAL_UNIT_BIN Bin;
    ULONG BinNumber;

    //
    // Iterate through each LU bin.  For each bin, if there are any LUs, iterate
    // through each of those looking for an oustanding request.  If we find one
    // terminate the search and return TRUE.
    //

    for (BinNumber = 0; BinNumber < NUMBER_LOGICAL_UNIT_BINS; BinNumber++) {

        Bin = &Adapter->LogicalUnitList[BinNumber];

        LogicalUnit = Bin->List;
        while (LogicalUnit != NULL) {

            if (LogicalUnit->AbortSrb != NULL &&
                LogicalUnit->AbortSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                    return TRUE;
            } else if (LogicalUnit->CurrentUntaggedRequest != NULL &&
                       LogicalUnit->CurrentUntaggedRequest->CurrentSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                return TRUE;
            } else if (LogicalUnit->RequestList.Flink != &LogicalUnit->RequestList) {
                PSRB_DATA srbData;
                PVOID nextEntry = LogicalUnit->RequestList.Flink;
                while (nextEntry != &LogicalUnit->RequestList) {
                    srbData = CONTAINING_RECORD(nextEntry, SRB_DATA, RequestList);
                    if (srbData->CurrentSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                        return TRUE;
                    }
                    nextEntry = srbData->RequestList.Flink;
                }    
            }

            LogicalUnit = LogicalUnit->NextLogicalUnit;
        }
    }

    return FALSE;
}

VOID
SpEnsureAllRequestsAreComplete(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine bugchecks the system if there are any outstanding requests
    on the supplied adapter.  If the SP_DONT_CHK_REQUESTS_ON_RESET bit is
    set on the adapter's verification level, don't do the check.

Arguments:

    Adapter - Points to an adapter device extension.

--*/
{
    //
    // If there are any outstanding requests on any of the LUs connected to the
    // adapter, bugcheck the system.  Note that we only do this check if it
    // has not been turned off.
    //

    if (VRFY_DO_CHECK(Adapter, SP_DONT_CHK_REQUESTS_ON_RESET)) {
        BOOLEAN ActiveRequests = SpCheckForActiveRequests(Adapter);
        if (ActiveRequests == TRUE) {
            KeBugCheckEx(SCSI_VERIFIER_DETECTED_VIOLATION,
                         SCSIPORT_VERIFIER_RQSTS_NOT_COMPLETE,
                         (ULONG_PTR)Adapter,
                         (ULONG_PTR)Adapter->HwDeviceExtension,
                         0);
        }            
    }
}

VOID
SpDoVerifierInit(
    IN PADAPTER_EXTENSION Adapter,
    IN PHW_INITIALIZATION_DATA HwInitializationData
    )
/*++

Routine Description:

    This routine allocates and initializes a verifier extension for the 
    supplied adapter.  A per-adapter verification level is read from the
    registry before allocating the extension.  A verfication level of -1
    means "don't verify this adapter".  If we do allocate the extension,
    we also lock the verifier code section into memory.

Arguments:

    Adapter              - The adapter device extension.

    HwInitializationData - A pointer to the HW_INITIALIZATION_DATA for
                           the adapter.

--*/
{        
    ULONG VerifyLevel;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Read adapter's verification level from the registry.  If the adapter is
    // configured for no verification, just return.
    //

    VerifyLevel = SpGetAdapterVerifyLevel(Adapter);
    if (VerifyLevel == SP_VRFY_NONE) {
        return;
    }

    //
    // Go ahead and try to allocate the extension.
    //

    Adapter->VerifierExtension = 
       SpAllocatePool(NonPagedPool,
                      sizeof(VERIFIER_EXTENSION),
                      SCSIPORT_TAG_VERIFIER,
                      Adapter->DeviceObject->DriverObject);
    
    if (Adapter->VerifierExtension != NULL) {
        
        //
        // Zero the extension.
        //

        RtlZeroMemory(Adapter->VerifierExtension, sizeof(VERIFIER_EXTENSION));
        
        //
        // Lock the pageable verifier code section into memory.
        //

#ifdef ALLOC_PRAGMA
        if (VerifierCodeSectionHandle == NULL) {
            VerifierCodeSectionHandle = MmLockPagableCodeSection(SpHwFindAdapterVrfy);
        } else {
            MmLockPagableSectionByHandle(VerifierCodeSectionHandle);
        }
#endif

        //
        // Set the verification level for this adapter.  This value is the sum
        // of the global verifier level and the per-adapter value we read above.
        //
            
        Adapter->VerifierExtension->VrfyLevel = (VerifyLevel | SpVrfyLevel);
            
        //
        // Initialize function pointers in the verifier extension to
        // to point to the real miniport routines.
        //
            
        Adapter->VerifierExtension->RealHwFindAdapter = HwInitializationData->HwFindAdapter;
        Adapter->VerifierExtension->RealHwInitialize = HwInitializationData->HwInitialize;
        Adapter->VerifierExtension->RealHwStartIo = HwInitializationData->HwStartIo;
        Adapter->VerifierExtension->RealHwInterrupt = HwInitializationData->HwInterrupt;
        Adapter->VerifierExtension->RealHwResetBus = HwInitializationData->HwResetBus;
        Adapter->VerifierExtension->RealHwDmaStarted = HwInitializationData->HwDmaStarted;
        Adapter->VerifierExtension->RealHwAdapterControl = HwInitializationData->HwAdapterControl;
            
        //
        // Redirect the miniport routines to verifier routines.
        //
            
        Adapter->HwFindAdapter = SpHwFindAdapterVrfy;
        Adapter->HwInitialize = SpHwInitializeVrfy;
        Adapter->HwStartIo = SpHwStartIoVrfy;
        Adapter->HwInterrupt = SpHwInterruptVrfy;
        Adapter->HwResetBus = SpHwResetBusVrfy;
        Adapter->HwDmaStarted = SpHwDmaStartedVrfy;
        Adapter->HwAdapterControl = SpHwAdapterControlVrfy;

        //
        // Get a pointer to an invalid page of memory so we can catch
        // miniports trying to touch memory when they shouldn't be.
        //

        Adapter->VerifierExtension->InvalidPage = SpGetInaccessiblePage(Adapter);
    }
}

VOID
SpDoVerifierCleanup(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine frees the supplied adapter's verifier extension and releases
    its reference on the verifier code section.

    This routine gets called as part of the adapter resource cleanup.  When
    called, all the actual resources allocated for the verifier have already
    been cleaned up.

Arguments:

    Adapter - the adapter device extension

--*/
{
    //
    // We should never arrive here if the scsiport verifier is not active.
    // And when we get here we should have freed all the resources hanging
    // off the extension.
    //

    ASSERT(Adapter->VerifierExtension != NULL);
    ASSERT(Adapter->VerifierExtension->CommonBufferVAs == NULL);
    ASSERT(Adapter->VerifierExtension->CommonBufferPAs == NULL);
    ASSERT(Adapter->VerifierExtension->CommonBufferBlocks == 0);

    //
    // Free and NULL the verifier extension for this adapter.
    //

    ExFreePool(Adapter->VerifierExtension);
    Adapter->VerifierExtension = NULL;

    //
    // Release our reference on the verifier code section.
    //

#ifdef ALLOC_PRAGMA
    ASSERT(VerifierCodeSectionHandle != NULL);
    MmUnlockPagableImageSection(VerifierCodeSectionHandle);
#endif
}

ULONG
SpGetAdapterVerifyLevel(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This function returns the verification level for the supplied adapter.    

Arguments:

    Adapter - Pointer to an adapter device extension.

Return Value:

    The supplied adapter's verification level.

--*/
{
    PSCSIPORT_DRIVER_EXTENSION DrvExt;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE ParametersKey;
    HANDLE ServiceKey;
    ULONG VerifyLevel = 0;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // We need the driver extension to get the adapter's registry path.  We use
    // this to look up the adapter settings in the registry.  If we cannot get
    // the driver extension, we have to abort.
    //

    DrvExt = IoGetDriverObjectExtension(
        Adapter->DeviceObject->DriverObject,
        ScsiPortInitialize);
    if (DrvExt == NULL) {
        return 0;
    }

    //
    // Try to open the adapter's registry key.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DrvExt->RegistryPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = ZwOpenKey(&ServiceKey, KEY_READ, &ObjectAttributes);
    if (NT_SUCCESS(Status)) {

        //
        // Try to open the adapter's parameters key.
        //

        RtlInitUnicodeString(&UnicodeString, L"Parameters");
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            ServiceKey,
            NULL);

        Status = ZwOpenKey(&ParametersKey, KEY_READ, &ObjectAttributes);
        if (NT_SUCCESS(Status)) {

            //
            // Try to read the verification level value under the adapter's
            // parameters key.
            //

            RtlInitUnicodeString(&UnicodeString, L"VerifyLevel");
            SpReadNumericValue(
                ParametersKey,
                NULL,
                &UnicodeString,
                &VerifyLevel);

            ZwClose(ParametersKey);
        }
        
        ZwClose(ServiceKey);
    }

    return VerifyLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\sfloppy\floppy.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    floppy.c

Abstract:

    SCSI floppy class driver

Author:

    Jeff Havens (jhavens)

Environment:

    kernel mode only

Notes:

Revision History:
02/28/96    georgioc    Merged this code with code developed by compaq in
                        parallel with microsoft, for 120MB floppy support.

01/17/96    georgioc    Made code PNP aware (uses the new \storage\classpnp/scsiport)

--*/

#include "stddef.h"
#include "ntddk.h"
#include "scsi.h"
#include "classpnp.h"

#include "initguid.h"
#include "ntddstor.h"

#define MODE_DATA_SIZE      192
#define SCSI_FLOPPY_TIMEOUT  20
#define SFLOPPY_SRB_LIST_SIZE 4
//
// Define all possible drive/media combinations, given drives listed above
// and media types in ntdddisk.h.
//
// These values are used to index the DriveMediaConstants table.
//

#define NUMBER_OF_DRIVE_TYPES              7
#define DRIVE_TYPE_120M                    4    //120MB Floptical
#define DRIVE_TYPE_NONE                    NUMBER_OF_DRIVE_TYPES

//
// This array describes all media types we support. 
// It should be arranged in the increasing order of density
// 
// For a given drive, we list all the mediatypes that will
// work with that drive. For instance, a 120MB drive will
// take 720KB media, 1.44MB media, and 120MB media.
//
// Note that, DriveMediaConstants given below is grouped
// as drive and media combination
//
typedef enum _DRIVE_MEDIA_TYPE {
    Drive360Media160,                      // 5.25"  360k  drive;  160k   media
    Drive360Media180,                      // 5.25"  360k  drive;  180k   media
    Drive360Media320,                      // 5.25"  360k  drive;  320k   media
    Drive360Media32X,                      // 5.25"  360k  drive;  320k 1k secs
    Drive360Media360,                      // 5.25"  360k  drive;  360k   media
    Drive720Media720,                      // 3.5"   720k  drive;  720k   media
    Drive120Media160,                      // 5.25" 1.2Mb  drive;  160k   media
    Drive120Media180,                      // 5.25" 1.2Mb  drive;  180k   media
    Drive120Media320,                      // 5.25" 1.2Mb  drive;  320k   media
    Drive120Media32X,                      // 5.25" 1.2Mb  drive;  320k 1k secs
    Drive120Media360,                      // 5.25" 1.2Mb  drive;  360k   media
    Drive120Media120,                      // 5.25" 1.2Mb  drive; 1.2Mb   media
    Drive144Media720,                      // 3.5"  1.44Mb drive;  720k   media
    Drive144Media144,                      // 3.5"  1.44Mb drive; 1.44Mb  media
    Drive288Media720,                      // 3.5"  2.88Mb drive;  720k   media
    Drive288Media144,                      // 3.5"  2.88Mb drive; 1.44Mb  media
    Drive288Media288,                      // 3.5"  2.88Mb drive; 2.88Mb  media
    Drive2080Media720,                     // 3.5"  20.8Mb drive;  720k   media
    Drive2080Media144,                     // 3.5"  20.8Mb drive; 1.44Mb  media
    Drive2080Media2080,                    // 3.5"  20.8Mb drive; 20.8Mb  media
    Drive32MMedia32M,                      // 3.5"  32Mb drive; 32MB    media
    Drive120MMedia720,                     // 3.5"  120Mb drive; 720k  media
    Drive120MMedia144,                     // 3.5"  120Mb drive; 1.44Mb  media
    Drive120MMedia120M,                    // 3.5"  120Mb drive; 120Mb  media
    Drive240MMedia144M,                    // 3.5"  240Mb drive; 1.44Mb  media
    Drive240MMedia120M,                    // 3.5"  240Mb drive; 120Mb  media
    Drive240MMedia240M                     // 3.5"  240Mb drive; 240Mb  media
} DRIVE_MEDIA_TYPE;

//
// When we want to determine the media type in a drive, we will first
// guess that the media with highest possible density is in the drive,
// and keep trying lower densities until we can successfully read from
// the drive.
//
// These values are used to select a DRIVE_MEDIA_TYPE value.
//
// The following table defines ranges that apply to the DRIVE_MEDIA_TYPE
// enumerated values when trying media types for a particular drive type.
// Note that for this to work, the DRIVE_MEDIA_TYPE values must be sorted
// by ascending densities within drive types.  Also, for maximum track
// size to be determined properly, the drive types must be in ascending
// order.
//

typedef struct _DRIVE_MEDIA_LIMITS {
    DRIVE_MEDIA_TYPE HighestDriveMediaType;
    DRIVE_MEDIA_TYPE LowestDriveMediaType;
} DRIVE_MEDIA_LIMITS, *PDRIVE_MEDIA_LIMITS;

#if 0
DRIVE_MEDIA_LIMITS DriveMediaLimits[NUMBER_OF_DRIVE_TYPES] = {

    { Drive360Media360, Drive360Media160 }, // DRIVE_TYPE_0360
    { Drive120Media120, Drive120Media160 }, // DRIVE_TYPE_1200
    { Drive720Media720, Drive720Media720 }, // DRIVE_TYPE_0720
    { Drive144Media144, Drive144Media720 }, // DRIVE_TYPE_1440
    { Drive288Media288, Drive288Media720 }, // DRIVE_TYPE_2880
    { Drive2080Media2080, Drive2080Media720 }
};
#else
DRIVE_MEDIA_LIMITS DriveMediaLimits[NUMBER_OF_DRIVE_TYPES] = {

    { Drive720Media720, Drive720Media720 }, // DRIVE_TYPE_0720
    { Drive144Media144,  Drive144Media720}, // DRIVE_TYPE_1440
    { Drive288Media288,  Drive288Media720}, // DRIVE_TYPE_2880
    { Drive2080Media2080, Drive2080Media720 },
    { Drive32MMedia32M, Drive32MMedia32M }, // DRIVE_TYPE_32M
    { Drive120MMedia120M, Drive120MMedia720 }, // DRIVE_TYPE_120M
    { Drive240MMedia240M, Drive240MMedia144M } // DRIVE_TYPE_240M
};

#endif
//
// For each drive/media combination, define important constants.
//

typedef struct _DRIVE_MEDIA_CONSTANTS {
    MEDIA_TYPE MediaType;
    USHORT     BytesPerSector;
    UCHAR      SectorsPerTrack;
    USHORT     MaximumTrack;
    UCHAR      NumberOfHeads;
} DRIVE_MEDIA_CONSTANTS, *PDRIVE_MEDIA_CONSTANTS;

//
// Magic value to add to the SectorLengthCode to use it as a shift value
// to determine the sector size.
//

#define SECTORLENGTHCODE_TO_BYTESHIFT      7

//
// The following values were gleaned from many different sources, which
// often disagreed with each other.  Where numbers were in conflict, I
// chose the more conservative or most-often-selected value.
//

DRIVE_MEDIA_CONSTANTS DriveMediaConstants[] =
    {

    { F5_160_512,   0x200, 0x08, 0x27, 0x1 },
    { F5_180_512,   0x200, 0x09, 0x27, 0x1 },
    { F5_320_1024,  0x400, 0x04, 0x27, 0x2 },
    { F5_320_512,   0x200, 0x08, 0x27, 0x2 },
    { F5_360_512,   0x200, 0x09, 0x27, 0x2 },

    { F3_720_512,   0x200, 0x09, 0x4f, 0x2 },

    { F5_160_512,   0x200, 0x08, 0x27, 0x1 },
    { F5_180_512,   0x200, 0x09, 0x27, 0x1 },
    { F5_320_1024,  0x400, 0x04, 0x27, 0x2 },
    { F5_320_512,   0x200, 0x08, 0x27, 0x2 },
    { F5_360_512,   0x200, 0x09, 0x27, 0x2 },
    { F5_1Pt2_512,  0x200, 0x0f, 0x4f, 0x2 },

    { F3_720_512,   0x200, 0x09, 0x4f, 0x2 },
    { F3_1Pt44_512, 0x200, 0x12, 0x4f, 0x2 },

    { F3_720_512,   0x200, 0x09, 0x4f, 0x2 },
    { F3_1Pt44_512, 0x200, 0x12, 0x4f, 0x2 },
    { F3_2Pt88_512, 0x200, 0x24, 0x4f, 0x2 },

    { F3_720_512,   0x200, 0x09, 0x4f, 0x2 },
    { F3_1Pt44_512, 0x200, 0x12, 0x4f, 0x2 },
    { F3_20Pt8_512, 0x200, 0x1b, 0xfa, 0x6 },

    { F3_32M_512,   0x200, 0x20, 0x3ff,0x2},

    { F3_720_512,   0x200, 0x09, 0x4f, 0x2 },
    { F3_1Pt44_512, 0x200, 0x12, 0x4f, 0x2 },
    { F3_120M_512,  0x200, 0x20, 0x3c2,0x8 },

    { F3_1Pt44_512, 0x200, 0x12, 0x4f, 0x2 },
    { F3_120M_512,  0x200, 0x20, 0x3c2,0x8 },
    { F3_240M_512,  0x200, 0x38, 0x105,0x20}
};


#define NUMBER_OF_DRIVE_MEDIA_COMBINATIONS sizeof(DriveMediaConstants)/sizeof(DRIVE_MEDIA_CONSTANTS)

//
// floppy device data
//

typedef struct _DISK_DATA {
    ULONG DriveType;
    BOOLEAN IsDMF;
    // BOOLEAN EnableDMF;
    UNICODE_STRING FloppyInterfaceString;
} DISK_DATA, *PDISK_DATA;

//
// The FloppyCapacities and FloppyGeometries arrays are used by the
// USBFlopGetMediaTypes() and USBFlopFormatTracks() routines.

// The FloppyCapacities and FloppyGeometries arrays must be kept in 1:1 sync,
// i.e. each FloppyGeometries[i] must correspond to each FloppyCapacities[i].

// Also, the arrays must be kept in sorted ascending order so that they
// are returned in sorted ascending order by IOCTL_DISK_GET_MEDIA_TYPES.
//

typedef struct _FORMATTED_CAPACITY
{
    ULONG       NumberOfBlocks;

    ULONG       BlockLength;

    BOOLEAN     CanFormat;      // return for IOCTL_DISK_GET_MEDIA_TYPES ?

} FORMATTED_CAPACITY, *PFORMATTED_CAPACITY;


FORMATTED_CAPACITY FloppyCapacities[] =
{
    // Blocks  BlockLen CanFormat H   T  B/S S/T
    {0x000500, 0x0200,  TRUE}, // 2  80  512   8   640 KB  F5_640_512
    {0x0005A0, 0x0200,  TRUE}, // 2  80  512   9   720 KB  F3_720_512
    {0x000960, 0x0200,  TRUE}, // 2  80  512  15  1.20 MB  F3_1Pt2_512   (Toshiba)
    {0x0004D0, 0x0400,  TRUE}, // 2  77 1024   8  1.23 MB  F3_1Pt23_1024 (NEC)
    {0x000B40, 0x0200,  TRUE}, // 2  80  512  18  1.44 MB  F3_1Pt44_512
    {0x000D20, 0x0200, FALSE}, // 2  80  512  21  1.70 MB  DMF
    {0x03C300, 0x0200,  TRUE}, // 8 963  512  32   120 MB  F3_120M_512
    {0x0600A4, 0x0200,  TRUE}, // 13 890  512  34   200 MB  F3_200Mb_512 (HiFD)
    {0x072A00, 0x0200,  TRUE}, // 32 262  512  56   240 MB  F3_240M_512 
    {0x010000, 0x0200,  FALSE} // 2  1024 512  32   32 MB    F3_32M_512
};

DISK_GEOMETRY FloppyGeometries[] =
{
    // Cyl      MediaType       Trk/Cyl Sec/Trk Bytes/Sec
    {{80,0},    F5_640_512,     2,      8,      512},
    {{80,0},    F3_720_512,     2,      9,      512},
    {{80,0},    F3_1Pt2_512,    2,      15,     512},
    {{77,0},    F3_1Pt23_1024,  2,      8,      1024},
    {{80,0},    F3_1Pt44_512,   2,      18,     512},
    {{80,0},    F3_1Pt44_512,   2,      21,     512},   // DMF -> F3_1Pt44_512
    {{963,0},   F3_120M_512,    8,      32,     512},
    {{890,0},   F3_200Mb_512,   13,     34,     512},
    {{262,0},   F3_240M_512,    32,     56,     512},
    {{1024,0},  F3_32M_512,     2,      32,     512}
};

#define FLOPPY_CAPACITIES (sizeof(FloppyCapacities)/sizeof(FloppyCapacities[0]))

C_ASSERT((sizeof(FloppyGeometries)/sizeof(FloppyGeometries[0])) == FLOPPY_CAPACITIES);

//
// The following structures are used by USBFlopFormatTracks()
//

#pragma pack (push, 1)

typedef struct _CDB12FORMAT
{
    UCHAR   OperationCode;
    UCHAR   DefectListFormat : 3;
    UCHAR   CmpList : 1;
    UCHAR   FmtData : 1;
    UCHAR   LogicalUnitNumber : 3;
    UCHAR   TrackNumber;
    UCHAR   InterleaveMsb;
    UCHAR   InterleaveLsb;
    UCHAR   Reserved1[2];
    UCHAR   ParameterListLengthMsb;
    UCHAR   ParameterListLengthLsb;
    UCHAR   Reserved2[3];
} CDB12FORMAT, *PCDB12FORMAT;


typedef struct _DEFECT_LIST_HEADER
{
    UCHAR   Reserved1;
    UCHAR   Side : 1;
    UCHAR   Immediate : 1;
    UCHAR   Reserved2 : 2;
    UCHAR   SingleTrack : 1;
    UCHAR   DisableCert : 1;
    UCHAR   Reserved3 : 1;
    UCHAR   FormatOptionsValid : 1;
    UCHAR   DefectListLengthMsb;
    UCHAR   DefectListLengthLsb;
} DEFECT_LIST_HEADER, *PDEFECT_LIST_HEADER;

typedef struct _FORMAT_UNIT_PARAMETER_LIST
{
    DEFECT_LIST_HEADER DefectListHeader;
    FORMATTED_CAPACITY_DESCRIPTOR FormatDescriptor;
} FORMAT_UNIT_PARAMETER_LIST, *PFORMAT_UNIT_PARAMETER_LIST;

#pragma pack (pop)



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
ScsiFlopUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ScsiFlopAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
ScsiFlopInitDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ScsiFlopStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ScsiFlopRemoveDevice(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR Type
    );

NTSTATUS
ScsiFlopStopDevice(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR Type
    );

BOOLEAN
FindScsiFlops(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    IN PCLASS_INIT_DATA InitializationData,
    IN PDEVICE_OBJECT PortDeviceObject,
    IN ULONG PortNumber
    );



NTSTATUS
ScsiFlopReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiFlopDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
IsFloppyDevice(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CreateFlopDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PortDeviceObject,
    IN ULONG DeviceCount
    );

NTSTATUS
DetermineMediaType(
    PDEVICE_OBJECT DeviceObject
    );

ULONG
DetermineDriveType(
    PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FlCheckFormatParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFORMAT_PARAMETERS FormatParameters
    );

NTSTATUS
FormatMedia(
    PDEVICE_OBJECT DeviceObject,
    MEDIA_TYPE MediaType
    );

NTSTATUS
FlopticalFormatMedia(
    PDEVICE_OBJECT DeviceObject,
    PFORMAT_PARAMETERS Format
    );

VOID
ScsiFlopProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

LONG
SFlopStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    );

NTSTATUS
USBFlopGetMediaTypes(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
USBFlopFormatTracks(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ScsiFlopUnload)
#pragma alloc_text(PAGE, ScsiFlopAddDevice)
#pragma alloc_text(PAGE, CreateFlopDeviceObject)
#pragma alloc_text(PAGE, ScsiFlopStartDevice)
#pragma alloc_text(PAGE, IsFloppyDevice)
#pragma alloc_text(PAGE, SFlopStringCmp)
#pragma alloc_text(PAGE, DetermineMediaType)
#pragma alloc_text(PAGE, DetermineDriveType)
#pragma alloc_text(PAGE, FlCheckFormatParameters)
#pragma alloc_text(PAGE, FormatMedia)
#pragma alloc_text(PAGE, FlopticalFormatMedia)
#pragma alloc_text(PAGE, USBFlopGetMediaTypes)
#pragma alloc_text(PAGE, USBFlopFormatTracks)

#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the system initialization routine for installable drivers.
    It calls the SCSI class driver initialization routine.

Arguments:

    DriverObject - Pointer to driver object created by system.

Return Value:

    NTSTATUS

--*/

{
    CLASS_INIT_DATA InitializationData;

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);
    InitializationData.FdoData.DeviceExtensionSize =
        sizeof(FUNCTIONAL_DEVICE_EXTENSION) + sizeof(DISK_DATA);

    InitializationData.FdoData.DeviceType = FILE_DEVICE_DISK;
    InitializationData.FdoData.DeviceCharacteristics = FILE_REMOVABLE_MEDIA | FILE_FLOPPY_DISKETTE;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassInitDevice = ScsiFlopInitDevice;
    InitializationData.FdoData.ClassStartDevice = ScsiFlopStartDevice;
    InitializationData.FdoData.ClassStopDevice = ScsiFlopStopDevice;
    InitializationData.FdoData.ClassRemoveDevice = ScsiFlopRemoveDevice;

    InitializationData.FdoData.ClassReadWriteVerification = ScsiFlopReadWriteVerification;
    InitializationData.FdoData.ClassDeviceControl = ScsiFlopDeviceControl;

    InitializationData.FdoData.ClassShutdownFlush = NULL;
    InitializationData.FdoData.ClassCreateClose = NULL;
    InitializationData.FdoData.ClassError = ScsiFlopProcessError;
    InitializationData.ClassStartIo = NULL;

    InitializationData.ClassAddDevice = ScsiFlopAddDevice;
    InitializationData.ClassUnload = ScsiFlopUnload;
    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);


} // end DriverEntry()

VOID
ScsiFlopUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    return;
}


NTSTATUS
ScsiFlopAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - Scsiscan class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/
{

    PCONFIGURATION_INFORMATION configurationInformation;

    NTSTATUS status;
    ULONG floppyCount = IoGetConfigurationInformation()->FloppyCount;

    //
    // Get the number of disks already initialized.
    //

    status = CreateFlopDeviceObject(DriverObject, Pdo, floppyCount);

    if (NT_SUCCESS(status)) {

        //
        // Increment system floppy device count.
        //

        IoGetConfigurationInformation()->FloppyCount++;
    }

    return status;
}



NTSTATUS
CreateFlopDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG DeviceCount
    )

/*++

Routine Description:

    This routine creates an object for the device and then calls the
    SCSI port driver for media capacity and sector size.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PortDeviceObject - to connect to SCSI port driver.
    DeviceCount - Number of previously installed Floppys.
    AdapterDescriptor - Pointer to structure returned by SCSI port
                        driver describing adapter capabilites (and limitations).
    DeviceDescriptor - Pointer to configuration information for this device.

Return Value:

--*/
{
    NTSTATUS        status;
    PDEVICE_OBJECT  deviceObject;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;

    PDISK_DATA  diskData;
    PVOID       senseData;

    BOOLEAN freeDevice = TRUE;


    DebugPrint((3,"CreateFlopDeviceObject: Enter routine\n"));

    //
    // Try to claim the device.
    //

    status = ClassClaimDevice(Pdo,FALSE);

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    DeviceCount--;

    do {
        UCHAR           name[256];

        //
        // Create device object for this device.
        //

        DeviceCount++;

        sprintf(name, "\\Device\\Floppy%d", DeviceCount);

        status = ClassCreateDeviceObject(DriverObject,
                                         name,
                                         Pdo,
                                         TRUE,
                                         &deviceObject);

    } while ((status == STATUS_OBJECT_NAME_COLLISION) ||
             (status == STATUS_OBJECT_NAME_EXISTS));

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"CreateFlopDeviceObjects: Can not create device\n"));
        goto CreateFlopDeviceObjectExit;
    }

    //
    // Indicate that IRPs should include MDLs.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Reset the drive type.
    //

    diskData = (PDISK_DATA) fdoExtension->CommonExtension.DriverData;
    diskData->DriveType = DRIVE_TYPE_NONE;
    diskData->IsDMF = FALSE;
    // diskData->EnableDMF = TRUE;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system floppy number
    //

    fdoExtension->DeviceNumber = DeviceCount;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (Pdo->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = Pdo->AlignmentRequirement;
    }

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Finally, attach to the PDO
    //

    fdoExtension->LowerPdo = Pdo;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, Pdo);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        status = STATUS_UNSUCCESSFUL;
        goto CreateFlopDeviceObjectExit;
    }

    deviceObject->StackSize++;

    //
    // The device is initialized properly - mark it as such.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;

CreateFlopDeviceObjectExit:

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    return status;

} // end CreateFlopDeviceObject()


NTSTATUS
ScsiFlopInitDevice(
    IN PDEVICE_OBJECT Fdo
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PDISK_DATA diskData = commonExtension->DriverData;

    PVOID senseData = NULL;
    ULONG timeOut;
    BOOLEAN srbListInitialized = FALSE;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePool(NonPagedPoolCacheAligned, SENSE_BUFFER_SIZE);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    //
    // Build the lookaside list for srb's for this device.
    //

    ClassInitializeSrbLookasideList((PCOMMON_DEVICE_EXTENSION)fdoExtension,
                                    SFLOPPY_SRB_LIST_SIZE);

    srbListInitialized = TRUE;

    //
    // Register for media change notification
    //
    ClassInitializeMediaChangeDetection(fdoExtension,
                                        "SFloppy");

    //
    // Set timeout value in seconds.
    //

    timeOut = ClassQueryTimeOutRegistryValue(Fdo);
    if (timeOut) {
        fdoExtension->TimeOutValue = timeOut;
    } else {
        fdoExtension->TimeOutValue = SCSI_FLOPPY_TIMEOUT;
    }

    //
    // Floppies are not partitionable so starting offset is 0.
    //

    fdoExtension->CommonExtension.StartingOffset.QuadPart = (LONGLONG)0;

#if 0
    if (!IsFloppyDevice(Fdo) ||
        !(Fdo->Characteristics & FILE_REMOVABLE_MEDIA) ||
        (fdoExtension->DeviceDescriptor->DeviceType != DIRECT_ACCESS_DEVICE)) {

        ExFreePool(senseData);
        status = STATUS_NO_SUCH_DEVICE;
        return status;
    }
#endif

    RtlZeroMemory(&(fdoExtension->DiskGeometry),
                  sizeof(DISK_GEOMETRY));

    //
    // Determine the media type if possible. Set the current media type to
    // Unknown so that determine media type will check the media.
    //

    fdoExtension->DiskGeometry.MediaType = Unknown;

#if 0
    {
        PUCHAR vendorId;
        UCHAR vendorString[6] = {'I','N','S','I','T','E'};

        vendorId = (PUCHAR)fdoExtension->DeviceDescriptor +
                           fdoExtension->DeviceDescriptor->VendorIdOffset;
        if (!SFlopStringCmp(vendorId,vendorString,6)) {
            diskData->EnableDMF = FALSE;
        }
    }
#endif

    //
    // Register interfaces for this device.
    //

    {
        PDISK_DATA diskData = (PDISK_DATA) commonExtension->DriverData;
        UNICODE_STRING interfaceName;

        RtlInitUnicodeString(&interfaceName, NULL);

        status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                           (LPGUID) &FloppyClassGuid,
                                           NULL,
                                           &interfaceName);

        if(NT_SUCCESS(status)) {
            diskData->FloppyInterfaceString = interfaceName;
        } else {
            RtlInitUnicodeString(&(diskData->FloppyInterfaceString), NULL);
            DebugPrint((1, "ScsiFlopStartDevice: Unable to register device "
                           "interface for fdo %#p [%#08lx]\n",
                        Fdo, status));
        }
    }

    return (STATUS_SUCCESS);
}

NTSTATUS
ScsiFlopStartDevice(
    IN PDEVICE_OBJECT Fdo
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;

    PIRP        irp;
    IO_STATUS_BLOCK ioStatus;

    SCSI_ADDRESS    scsiAddress;

    WCHAR   ntNameBuffer[256];
    UNICODE_STRING  ntUnicodeString;

    WCHAR   arcNameBuffer[256];
    UNICODE_STRING  arcUnicodeString;

    KEVENT event;

    NTSTATUS status = STATUS_SUCCESS;

    KeInitializeEvent(&event,SynchronizationEvent,FALSE);

    DetermineMediaType(Fdo); // ignore unsuccessful here

    //
    // Create a symbolic link from the disk name to the corresponding
    // ARC name, to be used if we're booting off the disk.  This will
    // fail if it's not system initialization time; that's fine.  The
    // ARC name looks something like \ArcName\scsi(0)Flop(0)fdisk(0).
    // In order to get the address, we need to send a IOCTL_SCSI_GET_ADDRESS...
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_GET_ADDRESS,
                                        Fdo,
                                        NULL,
                                        0,
                                        &scsiAddress,
                                        sizeof(scsiAddress),
                                        FALSE,
                                        &event,
                                        &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    swprintf(arcNameBuffer,
             L"\\ArcName\\scsi(%d)disk(%d)fdisk(%d)",
             scsiAddress.PortNumber,
             scsiAddress.TargetId,
             scsiAddress.Lun);

    RtlInitUnicodeString(&arcUnicodeString, arcNameBuffer);

    //
    // Create device object for this device.
    //

    swprintf(ntNameBuffer,L"\\Device\\Floppy%d",fdoExtension->DeviceNumber);

    //
    // Create local copy of unicode string
    //
    RtlInitUnicodeString(&ntUnicodeString,ntNameBuffer);

    IoAssignArcName(&arcUnicodeString, &ntUnicodeString);

    //
    // Create the multi() arc name -- Create the "fake"
    // name of multi(0)disk(0)fdisk(#) to handle the case where the
    // SCSI floppy is the only floppy in the system.  If this fails
    // it doesn't matter because the previous scsi() based ArcName
    // will work.  This name is necessary for installation.
    //

    swprintf(arcNameBuffer, L"\\ArcName\\multi(%d)disk(%d)fdisk(%d)",
             0,
             0,
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&arcUnicodeString, arcNameBuffer);

    IoAssignArcName(&arcUnicodeString, &ntUnicodeString);

    //
    // Set our interface state.
    //

    {
        PDISK_DATA diskData = commonExtension->DriverData;

        if(diskData->FloppyInterfaceString.Buffer != NULL) {

            status = IoSetDeviceInterfaceState(
                        &(diskData->FloppyInterfaceString),
                        TRUE);

#if DBG
            if(!NT_SUCCESS(status)) {
                DebugPrint((1, "ScsiFlopStartDevice: Unable to set device "
                               "interface state to TRUE for fdo %#p "
                               "[%#08lx]\n",
                            Fdo, status));
            }
#endif
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ScsiFlopReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

Return Value:

    NT Status

--*/

{
    return STATUS_SUCCESS;
} // end ScsiFlopReadWriteVerification()


NTSTATUS
ScsiFlopDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

Arguments:

Return Value:

    Status is returned.

--*/

{
    KIRQL currentIrql;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    NTSTATUS status;
    PDISK_GEOMETRY outputBuffer;
    ULONG outputBufferLength;
    ULONG i;
    DRIVE_MEDIA_TYPE lowestDriveMediaType;
    DRIVE_MEDIA_TYPE highestDriveMediaType;
    PFORMAT_PARAMETERS formatParameters;
    PMODE_PARAMETER_HEADER modeData;
    ULONG length;

    srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        if (IoIsErrorUserInduced(STATUS_INSUFFICIENT_RESOURCES)) {

            IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
        }

        KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, 0);
        KeLowerIrql(currentIrql);

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Write zeros to Srb.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {


    case IOCTL_DISK_VERIFY: {

       PVERIFY_INFORMATION verifyInfo = Irp->AssociatedIrp.SystemBuffer;
       LARGE_INTEGER byteOffset;
       ULONG         sectorOffset;
       USHORT        sectorCount;

       //
       // Validate buffer length.
       //

       if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
           sizeof(VERIFY_INFORMATION)) {

           status = STATUS_INFO_LENGTH_MISMATCH;
           break;
       }

       //
       // Verify sectors
       //

       srb->CdbLength = 10;

       cdb->CDB10.OperationCode = SCSIOP_VERIFY;

       //
       // Add disk offset to starting sector.
       //

       byteOffset.QuadPart = fdoExtension->CommonExtension.StartingOffset.QuadPart +
                       verifyInfo->StartingOffset.QuadPart;

       //
       // Convert byte offset to sector offset.
       //

       sectorOffset = (ULONG)(byteOffset.QuadPart >> fdoExtension->SectorShift);

       //
       // Convert ULONG byte count to USHORT sector count.
       //

       sectorCount = (USHORT)(verifyInfo->Length >> fdoExtension->SectorShift);

       //
       // Move little endian values into CDB in big endian format.
       //

       cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&sectorOffset)->Byte3;
       cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&sectorOffset)->Byte2;
       cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&sectorOffset)->Byte1;
       cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&sectorOffset)->Byte0;

       cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&sectorCount)->Byte1;
       cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&sectorCount)->Byte0;

       //
       // The verify command is used by the NT FORMAT utility and
       // requests are sent down for 5% of the volume size. The
       // request timeout value is calculated based on the number of
       // sectors verified.
       //

       srb->TimeOutValue = ((sectorCount + 0x7F) >> 7) *
                             fdoExtension->TimeOutValue;

       status = ClassSendSrbAsynchronous(DeviceObject,
                                         srb,
                                         Irp,
                                         NULL,
                                         0,
                                         FALSE);
       return(status);

    }

    case IOCTL_DISK_GET_PARTITION_INFO: {

        if (fdoExtension->AdapterDescriptor->BusType == BusTypeUsb) {

            status = USBFlopGetMediaTypes(DeviceObject, NULL);

            // Don't need to propagate any error if one occurs
            //
            status = STATUS_SUCCESS;

        } else {

            status = DetermineMediaType(DeviceObject);
        }

        if (!NT_SUCCESS(status)) {
            // so will propogate error
            NOTHING;
        } else if (fdoExtension->DiskGeometry.MediaType == F3_120M_512) {
            //so that the format code will not try to partition it.
            status = STATUS_INVALID_DEVICE_REQUEST;
        } else {
           //
           // Free the Srb, since it is not needed.
           //

           ExFreePool(srb);

           //
           // Pass the request to the common device control routine.
           //

           return(ClassDeviceControl(DeviceObject, Irp));
        }
        break;
    }

    case IOCTL_DISK_GET_DRIVE_GEOMETRY: {

        DebugPrint((3,"ScsiDeviceIoControl: Get drive geometry\n"));

        if (fdoExtension->AdapterDescriptor->BusType == BusTypeUsb)
        {
            status = USBFlopGetMediaTypes(DeviceObject,
                                          Irp);
            break;
        }

        //
        // If there's not enough room to write the
        // data, then fail the request.
        //

        if ( irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof( DISK_GEOMETRY ) ) {

            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = DetermineMediaType(DeviceObject);

        if (!NT_SUCCESS(status)) {

            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = status;

        } else {

            //
            // Copy drive geometry information from device extension.
            //

            RtlMoveMemory(Irp->AssociatedIrp.SystemBuffer,
                          &(fdoExtension->DiskGeometry),
                          sizeof(DISK_GEOMETRY));

            Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
            status = STATUS_SUCCESS;

        }

        break;
    }

    case IOCTL_DISK_GET_MEDIA_TYPES: {

        if (fdoExtension->AdapterDescriptor->BusType == BusTypeUsb)
        {
            status = USBFlopGetMediaTypes(DeviceObject,
                                          Irp);
            break;
        }

        i = DetermineDriveType(DeviceObject);

        if (i == DRIVE_TYPE_NONE) {
            status = STATUS_UNRECOGNIZED_MEDIA;
            break;
        }

        lowestDriveMediaType = DriveMediaLimits[i].LowestDriveMediaType;
        highestDriveMediaType = DriveMediaLimits[i].HighestDriveMediaType;

        outputBufferLength =
        irpStack->Parameters.DeviceIoControl.OutputBufferLength;

        //
        // Make sure that the input buffer has enough room to return
        // at least one descriptions of a supported media type.
        //

        if ( outputBufferLength < ( sizeof( DISK_GEOMETRY ) ) ) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Assume success, although we might modify it to a buffer
        // overflow warning below (if the buffer isn't big enough
        // to hold ALL of the media descriptions).
        //

        status = STATUS_SUCCESS;

        if (outputBufferLength < ( sizeof( DISK_GEOMETRY ) *
            ( highestDriveMediaType - lowestDriveMediaType + 1 ) ) ) {

            //
            // The buffer is too small for all of the descriptions;
            // calculate what CAN fit in the buffer.
            //

            status = STATUS_BUFFER_OVERFLOW;

            highestDriveMediaType = (DRIVE_MEDIA_TYPE)( ( lowestDriveMediaType - 1 ) +
                ( outputBufferLength /
                sizeof( DISK_GEOMETRY ) ) );
        }

        outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;

        for (i = (UCHAR)lowestDriveMediaType;i <= (UCHAR)highestDriveMediaType;i++ ) {

             outputBuffer->MediaType = DriveMediaConstants[i].MediaType;
             outputBuffer->Cylinders.LowPart =
                 DriveMediaConstants[i].MaximumTrack + 1;
             outputBuffer->Cylinders.HighPart = 0;
             outputBuffer->TracksPerCylinder =
                 DriveMediaConstants[i].NumberOfHeads;
             outputBuffer->SectorsPerTrack =
                 DriveMediaConstants[i].SectorsPerTrack;
             outputBuffer->BytesPerSector =
                 DriveMediaConstants[i].BytesPerSector;
             outputBuffer++;

             Irp->IoStatus.Information += sizeof( DISK_GEOMETRY );
        }

        break;
    }

    case IOCTL_DISK_FORMAT_TRACKS: {

        if (fdoExtension->AdapterDescriptor->BusType == BusTypeUsb)
        {
            status = USBFlopFormatTracks(DeviceObject,
                                         Irp);
            break;
        }

        //
        // Make sure that we got all the necessary format parameters.
        //

        if ( irpStack->Parameters.DeviceIoControl.InputBufferLength <sizeof( FORMAT_PARAMETERS ) ) {

            status = STATUS_INVALID_PARAMETER;
            break;
        }

        formatParameters = (PFORMAT_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;

        //
        // Make sure the parameters we got are reasonable.
        //

        if ( !FlCheckFormatParameters(DeviceObject, formatParameters)) {

            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // If this request is for a 20.8 MB floppy then call a special
        // floppy format routine.
        //

        if (formatParameters->MediaType == F3_20Pt8_512) {
            status = FlopticalFormatMedia(DeviceObject,
                                          formatParameters
                                          );

            break;
        }

        //
        // All the work is done in the pass.  If this is not the first pass,
        // then complete the request and return;
        //

        if (formatParameters->StartCylinderNumber != 0 || formatParameters->StartHeadNumber != 0) {

            status = STATUS_SUCCESS;
            break;
        }

        status = FormatMedia( DeviceObject, formatParameters->MediaType);
        break;
    }

    case IOCTL_DISK_IS_WRITABLE: {

        //
        // Determine if the device is writable.
        //

        modeData = ExAllocatePool(NonPagedPoolCacheAligned, MODE_DATA_SIZE);

        if (modeData == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(modeData, MODE_DATA_SIZE);

        length = ClassModeSense(DeviceObject,
                    (PUCHAR) modeData,
                    MODE_DATA_SIZE,
                    MODE_SENSE_RETURN_ALL);

        if (length < sizeof(MODE_PARAMETER_HEADER)) {

            //
            // Retry the request in case of a check condition.
            //

            length = ClassModeSense(DeviceObject,
                        (PUCHAR) modeData,
                        MODE_DATA_SIZE,
                        MODE_SENSE_RETURN_ALL);

            if (length < sizeof(MODE_PARAMETER_HEADER)) {
                status = STATUS_IO_DEVICE_ERROR;
                ExFreePool(modeData);
                break;
            }
        }

        if (modeData->DeviceSpecificParameter & MODE_DSP_WRITE_PROTECT) {
            status = STATUS_MEDIA_WRITE_PROTECTED;
        } else {
            status = STATUS_SUCCESS;
        }

        DebugPrint((2,"IOCTL_DISK_IS_WRITABLE returns %08X\n", status));

        ExFreePool(modeData);
        break;
    }

    default: {

        DebugPrint((3,"ScsiIoDeviceControl: Unsupported device IOCTL\n"));

        //
        // Free the Srb, since it is not needed.
        //

        ExFreePool(srb);

        //
        // Pass the request to the common device control routine.
        //

        return(ClassDeviceControl(DeviceObject, Irp));

        break;
    }

    } // end switch( ...

    //
    // Check if SL_OVERRIDE_VERIFY_VOLUME flag is set in the IRP.
    // If so, do not return STATUS_VERIFY_REQUIRED
    //
    if ((status == STATUS_VERIFY_REQUIRED) &&
        (TEST_FLAG(irpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME))) {

        status = STATUS_IO_DEVICE_ERROR;

    }

    Irp->IoStatus.Status = status;

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
    }

    KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);
    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject, Irp, 0);
    KeLowerIrql(currentIrql);

    ExFreePool(srb);

    return status;

} // end ScsiFlopDeviceControl()

#if 0

BOOLEAN
IsFloppyDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    The routine performs the necessary funcitons to deterime if the device is
    really a floppy rather than a harddisk.  This is done by a mode sense
    command.  First a check is made to see if the medimum type is set.  Second
    a check is made for the flexible parameters mode page.

Arguments:

    DeviceObject - Supplies the device object to be tested.

Return Value:

    Return TRUE if the indicated device is a floppy.

--*/
{

    PVOID modeData;
    PUCHAR pageData;
    ULONG length;

    modeData = ExAllocatePool(NonPagedPoolCacheAligned, MODE_DATA_SIZE);

    if (modeData == NULL) {
        return(FALSE);
    }

    RtlZeroMemory(modeData, MODE_DATA_SIZE);

    length = ClassModeSense(DeviceObject, modeData, MODE_DATA_SIZE, MODE_SENSE_RETURN_ALL);

    if (length < sizeof(MODE_PARAMETER_HEADER)) {

        //
        // Retry the request in case of a check condition.
        //

        length = ClassModeSense(DeviceObject,
                    modeData,
                    MODE_DATA_SIZE,
                    MODE_SENSE_RETURN_ALL);

        if (length < sizeof(MODE_PARAMETER_HEADER)) {

            ExFreePool(modeData);
            return(FALSE);

        }
    }

#if 0
    //
    // Some drives incorrectly report this.  In particular the SONY RMO-S350
    // when in disk mode.
    //

    if (((PMODE_PARAMETER_HEADER) modeData)->MediumType >= MODE_FD_SINGLE_SIDE
        && ((PMODE_PARAMETER_HEADER) modeData)->MediumType <= MODE_FD_MAXIMUM_TYPE) {

        DebugPrint((1, "ScsiFlop: MediumType value %2x, This is a floppy.\n", ((PMODE_PARAMETER_HEADER) modeData)->MediumType));
        ExFreePool(modeData);
        return(TRUE);
    }

#endif

    //
    // If the length is greater than length indiated by the mode data reset
    // the data to the mode data.
    //
    if (length > (ULONG)((PMODE_PARAMETER_HEADER) modeData)->ModeDataLength + 1) {
        length = (ULONG)((PMODE_PARAMETER_HEADER) modeData)->ModeDataLength + 1;

    }

    //
    // Look for the flexible disk mode page.
    //

    pageData = ClassFindModePage( modeData, length, MODE_PAGE_FLEXIBILE, TRUE);

    if (pageData != NULL) {

        DebugPrint((1, "ScsiFlop: Flexible disk page found, This is a floppy.\n"));

        //
        // As a special case for the floptical driver do a magic mode sense to
        // enable the drive.
        //

        ClassModeSense(DeviceObject, modeData, 0x2a, 0x2e);

        ExFreePool(modeData);
        return(TRUE);

    }

    ExFreePool(modeData);
    return(FALSE);

}
#endif


NTSTATUS
DetermineMediaType(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine determines the floppy media type based on the size of the
    device.  The geometry information is set for the device object.

Arguments:

    DeviceObject - Supplies the device object to be tested.

Return Value:

    None

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PDISK_GEOMETRY geometry;
    LONG index;
    NTSTATUS status;

    geometry = &(fdoExtension->DiskGeometry);

    //
    // Issue ReadCapacity to update device extension
    // with information for current media.
    //

    status = ClassReadDriveCapacity(DeviceObject);

    if (!NT_SUCCESS(status)) {

       //
       // Set the media type to unknow and zero the geometry information.
       //

       geometry->MediaType = Unknown;

       return status;

    }

    //
    // Look at the capcity of disk to determine its type.
    //

    for (index = NUMBER_OF_DRIVE_MEDIA_COMBINATIONS - 1; index >= 0; index--) {

        //
        // Walk the table backward untill the drive capacity holds all of the
        // data and the bytes per setor are equal
        //

         if ((ULONG) (DriveMediaConstants[index].NumberOfHeads *
             (DriveMediaConstants[index].MaximumTrack + 1) *
             DriveMediaConstants[index].SectorsPerTrack *
             DriveMediaConstants[index].BytesPerSector) <=
             fdoExtension->CommonExtension.PartitionLength.LowPart &&
             DriveMediaConstants[index].BytesPerSector ==
             geometry->BytesPerSector) {

             geometry->MediaType = DriveMediaConstants[index].MediaType;
             geometry->TracksPerCylinder = DriveMediaConstants[index].NumberOfHeads;
             geometry->SectorsPerTrack = DriveMediaConstants[index].SectorsPerTrack;
             geometry->Cylinders.LowPart = DriveMediaConstants[index].MaximumTrack+1;
             break;
         }
    }

    if (index == -1) {

        //
        // Set the media type to unknow and zero the geometry information.
        //

        geometry->MediaType = Unknown;


    } else {
        //
        // DMF check breaks the insight SCSI floppy, so its disabled for that case
        //
        PDISK_DATA diskData = (PDISK_DATA) fdoExtension->CommonExtension.DriverData;

        // if (diskData->EnableDMF == TRUE) {

            //
            //check to see if DMF
            //

            PSCSI_REQUEST_BLOCK srb;
            PVOID               readData;

            //
            // Allocate a Srb for the read command.
            //

            readData = ExAllocatePool(NonPagedPool, geometry->BytesPerSector);
            if (readData == NULL) {
                return STATUS_NO_MEMORY;
            }

            srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

            if (srb == NULL) {

                ExFreePool(readData);
                return STATUS_NO_MEMORY;
            }

            RtlZeroMemory(readData, geometry->BytesPerSector);
            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

            srb->CdbLength = 10;
            srb->Cdb[0] = SCSIOP_READ;
            srb->Cdb[5] = 0;
            srb->Cdb[8] = (UCHAR) 1;

            //
            // Set timeout value.
            //

            srb->TimeOutValue = fdoExtension->TimeOutValue;

            //
            // Send the mode select data.
            //

            status = ClassSendSrbSynchronous(DeviceObject,
                      srb,
                      readData,
                      geometry->BytesPerSector,
                      FALSE
                      );

            if (NT_SUCCESS(status)) {
                char *pchar = (char *)readData;

                pchar += 3; //skip 3 bytes jump code

                // If the MSDMF3. signature is there then mark it as DMF diskette
                if (RtlCompareMemory(pchar, "MSDMF3.", 7) == 7) {
                    diskData->IsDMF = TRUE;
                }

            }
            ExFreePool(readData);
            ExFreePool(srb);
        // }// else
    }
    return status;
}

ULONG
DetermineDriveType(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    The routine determines the device type so that the supported medias can be
    determined.  It does a mode sense for the default parameters.  This code
    assumes that the returned values are for the maximum device size.

Arguments:

    DeviceObject - Supplies the device object to be tested.

Return Value:

    None

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PVOID modeData;
    PDISK_DATA diskData = (PDISK_DATA) fdoExtension->CommonExtension.DriverData;
    PMODE_FLEXIBLE_DISK_PAGE pageData;
    ULONG length;
    LONG index;
    UCHAR numberOfHeads;
    UCHAR sectorsPerTrack;
    USHORT maximumTrack;
    BOOLEAN applyFix = FALSE;

    if (diskData->DriveType != DRIVE_TYPE_NONE) {
        return(diskData->DriveType);
    }

    modeData = ExAllocatePool(NonPagedPoolCacheAligned, MODE_DATA_SIZE);

    if (modeData == NULL) {
        return(DRIVE_TYPE_NONE);
    }

    RtlZeroMemory(modeData, MODE_DATA_SIZE);

    length = ClassModeSense(DeviceObject,
                            modeData,
                            MODE_DATA_SIZE,
                            MODE_PAGE_FLEXIBILE);

    if (length < sizeof(MODE_PARAMETER_HEADER)) {

        RtlZeroMemory(modeData, MODE_DATA_SIZE);

        //
        // Retry the request one more time
        // in case of a check condition.
        //
        length = ClassModeSense(DeviceObject,
                                modeData,
                                MODE_DATA_SIZE,
                                MODE_PAGE_FLEXIBILE);

        if (length < sizeof(MODE_PARAMETER_HEADER)) {
            ExFreePool(modeData);
            return(DRIVE_TYPE_NONE);
        }
    }

    //
    // Look for the flexible disk mode page.
    //

    pageData = ClassFindModePage( modeData,
                                  length,
                                  MODE_PAGE_FLEXIBILE,
                                  TRUE);

    //
    // Make sure the page is returned and is large enough.
    //

    if ((pageData != NULL) &&
        (pageData->PageLength + 2 >=
         offsetof(MODE_FLEXIBLE_DISK_PAGE, StartWritePrecom))) {

       //
       // Pull out the heads, cylinders, and sectors.
       //

       numberOfHeads = pageData->NumberOfHeads;
       maximumTrack = pageData->NumberOfCylinders[1];
       maximumTrack |= pageData->NumberOfCylinders[0] << 8;
       sectorsPerTrack = pageData->SectorsPerTrack;


       //
       // Convert from number of cylinders to maximum track.
       //

       maximumTrack--;

       //
       // Search for the maximum supported media. Based on the number of heads,
       // sectors per track and number of cylinders
       //
       for (index = 0; index < NUMBER_OF_DRIVE_MEDIA_COMBINATIONS; index++) {

            //
            // Walk the table forward until the drive capacity holds all of the
            // data and the bytes per setor are equal
            //

            if (DriveMediaConstants[index].NumberOfHeads == numberOfHeads &&
                DriveMediaConstants[index].MaximumTrack == maximumTrack &&
                DriveMediaConstants[index].SectorsPerTrack ==sectorsPerTrack) {

                ExFreePool(modeData);

                //
                // index is now a drive media combination.  Compare this to
                // the maximum drive media type in the drive media table.
                //

                for (length = 0; length < NUMBER_OF_DRIVE_TYPES; length++) {

                    if (DriveMediaLimits[length].HighestDriveMediaType == index) {
                        return(length);
                    }
                }
                return(DRIVE_TYPE_NONE);
           }
       }

       // If the maximum track is greater than 8 bits then divide the
       // number of tracks by 3 and multiply the number of heads by 3.
       // This is a special case for the 20.8 MB floppy.
       //

       if (!applyFix && maximumTrack >= 0x0100) {
           applyFix = TRUE;
           maximumTrack++;
           maximumTrack /= 3;
           maximumTrack--;
           numberOfHeads *= 3;
       } else {
           ExFreePool(modeData);
           return(DRIVE_TYPE_NONE);
       }

    }

    ExFreePool(modeData);
    return(DRIVE_TYPE_NONE);
}


BOOLEAN
FlCheckFormatParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFORMAT_PARAMETERS FormatParameters
    )

/*++

Routine Description:

    This routine checks the supplied format parameters to make sure that
    they'll work on the drive to be formatted.

Arguments:

    DeviceObject - Pointer to the device object to be formated.

    FormatParameters - a pointer to the caller's parameters for the FORMAT.

Return Value:

    TRUE if parameters are OK.
    FALSE if the parameters are bad.

--*/

{
    PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
    DRIVE_MEDIA_TYPE driveMediaType;
    ULONG index;

    //
    // Get the device type.
    //

    index = DetermineDriveType(DeviceObject);

    if (index == DRIVE_TYPE_NONE) {

        //
        // If the determine device type failed then just use the media type
        // and try the parameters.
        //

        driveMediaType = Drive360Media160;

        while (( DriveMediaConstants[driveMediaType].MediaType !=
               FormatParameters->MediaType ) &&
               ( driveMediaType < Drive288Media288) ) {

               driveMediaType++;
        }

    } else {

        //
        // Figure out which entry in the DriveMediaConstants table to use.
        //

        driveMediaType =
            DriveMediaLimits[index].HighestDriveMediaType;

        while ( ( DriveMediaConstants[driveMediaType].MediaType !=
            FormatParameters->MediaType ) &&
            ( driveMediaType > DriveMediaLimits[index].
            LowestDriveMediaType ) ) {

            driveMediaType--;
        }

    }


    if ( DriveMediaConstants[driveMediaType].MediaType !=
        FormatParameters->MediaType ) {
        return FALSE;

    } else {

        driveMediaConstants = &DriveMediaConstants[driveMediaType];

        if ( ( FormatParameters->StartHeadNumber >
            (ULONG)( driveMediaConstants->NumberOfHeads - 1 ) ) ||
            ( FormatParameters->EndHeadNumber >
            (ULONG)( driveMediaConstants->NumberOfHeads - 1 ) ) ||
            ( FormatParameters->StartCylinderNumber >
            driveMediaConstants->MaximumTrack ) ||
            ( FormatParameters->EndCylinderNumber >
            driveMediaConstants->MaximumTrack ) ||
            ( FormatParameters->EndCylinderNumber <
            FormatParameters->StartCylinderNumber ) ) {

            return FALSE;

        } else {

            return TRUE;
        }
    }
}

NTSTATUS
FormatMedia(
    PDEVICE_OBJECT DeviceObject,
    MEDIA_TYPE MediaType
    )
/*++

Routine Description:

    This routine formats the floppy disk.  The entire floppy is formated in
    one shot.

Arguments:

    DeviceObject - Supplies the device object to be tested.

    Irp - Supplies a pointer to the requesting Irp.

    MediaType - Supplies the media type format the device for.

Return Value:

    Returns a status for the operation.

--*/
{
    PVOID modeData;
    PSCSI_REQUEST_BLOCK srb;
    PMODE_FLEXIBLE_DISK_PAGE pageData;
    DRIVE_MEDIA_TYPE driveMediaType;
    PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
    ULONG length;
    NTSTATUS status;

    modeData = ExAllocatePool(NonPagedPoolCacheAligned, MODE_DATA_SIZE);

    if (modeData == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(modeData, MODE_DATA_SIZE);

    length = ClassModeSense(DeviceObject,
                            modeData,
                            MODE_DATA_SIZE,
                            MODE_PAGE_FLEXIBILE);

    if (length < sizeof(MODE_PARAMETER_HEADER)) {
        ExFreePool(modeData);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // Look for the flexible disk mode page.
    //

    pageData = ClassFindModePage( modeData, length, MODE_PAGE_FLEXIBILE, TRUE);

    //
    // Make sure the page is returned and is large enough.
    //

    if ((pageData == NULL) ||
        (pageData->PageLength + 2 <
         offsetof(MODE_FLEXIBLE_DISK_PAGE, StartWritePrecom))) {

        ExFreePool(modeData);
        return(STATUS_INVALID_DEVICE_REQUEST);

    }

    //
    // Look for a drive media type which matches the requested media type.
    //
    //
    //start from Drive120MMedia120M instead of Drive2080Media2080
    //
    for (driveMediaType = Drive120MMedia120M;
    DriveMediaConstants[driveMediaType].MediaType != MediaType;
    driveMediaType--) {
         if (driveMediaType == Drive360Media160) {

             ExFreePool(modeData);
             return(STATUS_INVALID_PARAMETER);

         }
    }

    driveMediaConstants = &DriveMediaConstants[driveMediaType];

    if ((pageData->NumberOfHeads != driveMediaConstants->NumberOfHeads) ||
        (pageData->SectorsPerTrack != driveMediaConstants->SectorsPerTrack) ||
        ((pageData->NumberOfCylinders[0] != (UCHAR)(driveMediaConstants->MaximumTrack+1) >> 8) &&
         (pageData->NumberOfCylinders[1] != (UCHAR)driveMediaConstants->MaximumTrack+1)) ||
        (pageData->BytesPerSector[0] != driveMediaConstants->BytesPerSector >> 8 )) {

        //
        // Update the flexible parameters page with the new parameters.
        //

        pageData->NumberOfHeads = driveMediaConstants->NumberOfHeads;
        pageData->SectorsPerTrack = driveMediaConstants->SectorsPerTrack;
        pageData->NumberOfCylinders[0] = (UCHAR)(driveMediaConstants->MaximumTrack+1) >> 8;
        pageData->NumberOfCylinders[1] = (UCHAR)driveMediaConstants->MaximumTrack+1;
        pageData->BytesPerSector[0] = driveMediaConstants->BytesPerSector >> 8;

        //
        // Clear the mode parameter header.
        //

        RtlZeroMemory(modeData, sizeof(MODE_PARAMETER_HEADER));

        //
        // Set the length equal to the length returned for the flexible page.
        //

        length = pageData->PageLength + 2;

        //
        // Copy the page after the mode parameter header.
        //

        RtlMoveMemory((PCHAR) modeData + sizeof(MODE_PARAMETER_HEADER),
                pageData,
                length
                );
            length += sizeof(MODE_PARAMETER_HEADER);


        //
        // Allocate a Srb for the format command.
        //

        srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

        if (srb == NULL) {

            ExFreePool(modeData);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        srb->CdbLength = 6;
        srb->Cdb[0] = SCSIOP_MODE_SELECT;
        srb->Cdb[4] = (UCHAR) length;

        //
        // Set the PF bit.
        //

        srb->Cdb[1] |= 0x10;

        //
        // Set timeout value.
        //

        srb->TimeOutValue = 2;

        //
        // Send the mode select data.
        //

        status = ClassSendSrbSynchronous(DeviceObject,
                  srb,
                  modeData,
                  length,
                  TRUE
                  );

        //
        // The mode data not needed any more so free it.
        //

        ExFreePool(modeData);

        if (!NT_SUCCESS(status)) {
            ExFreePool(srb);
            return(status);
        }

    } else {

        //
        // The mode data not needed any more so free it.
        //

        ExFreePool(modeData);

        //
        // Allocate a Srb for the format command.
        //

        srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

        if (srb == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    srb->CdbLength = 6;

    srb->Cdb[0] = SCSIOP_FORMAT_UNIT;

    //
    // Set timeout value.
    //

    srb->TimeOutValue = 10 * 60;

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE
                                     );
    ExFreePool(srb);

    return(status);

}

VOID
ScsiFlopProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )
/*++

Routine Description:

   This routine checks the type of error.  If the error indicate the floppy
   controller needs to be reinitialize a command is made to do it.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - Status with which the IRP will be completed.

    Retry - Indication of whether the request will be retried.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = (PDISK_DATA) fdoExtension->CommonExtension.DriverData;
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    LARGE_INTEGER largeInt;
    PCOMPLETION_CONTEXT context;
    PCDB cdb;
    ULONG_PTR alignment;
    ULONG majorFunction;

    UNREFERENCED_PARAMETER(Status);
    UNREFERENCED_PARAMETER(Retry);

    largeInt.QuadPart = 1;

    //
    // Check the status.  The initialization command only needs to be sent
    // if UNIT ATTENTION or LUN NOT READY is returned.
    //

    if (!(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)) {

        //
        // The drive does not require reinitialization.
        //

        return;
    }

    //
    // Reset the drive type.
    //

    diskData->DriveType = DRIVE_TYPE_NONE;
    diskData->IsDMF = FALSE;

    fdoExtension->DiskGeometry.MediaType = Unknown;

    if (fdoExtension->AdapterDescriptor->BusType == BusTypeUsb) {

        // FLPYDISK.SYS never returns a non-zero value for the ChangeCount
        // on an IOCTL_DISK_CHECK_VERIFY.  Some things seem to work better
        // if we do the same.  In particular, FatVerifyVolume() can exit between
        // the IOCTL_DISK_CHECK_VERIFY and the IOCTL_DISK_GET_DRIVE_GEOMETRY
        // if a non-zero ChangeCount is returned, and this appears to cause
        // issues formatting unformatted media in some situations.
        //
        // This is something that should probably be revisited at some point.
        //
        fdoExtension->MediaChangeCount = 0;

        if (((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_UNIT_ATTENTION) &&
            (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_MEDIUM_CHANGED)) {

            struct _START_STOP *cdb;

            DebugPrint((2,"Sending SCSIOP_START_STOP_UNIT\n"));

            context = ExAllocatePool(NonPagedPool,
                                     sizeof(COMPLETION_CONTEXT));

            if (context == NULL) {

                return;
            }

            srb = &context->Srb;

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

            srb->SrbFlags = SRB_FLAGS_DISABLE_AUTOSENSE;

            srb->CdbLength = 6;

            cdb = (struct _START_STOP *)srb->Cdb;

            cdb->OperationCode = SCSIOP_START_STOP_UNIT;
            cdb->Start = 1;

            // A Start Stop Unit request has no transfer buffer.
            // Set the request to IRP_MJ_FLUSH_BUFFERS when calling
            // IoBuildAsynchronousFsdRequest() so that it ignores
            // the buffer pointer and buffer length parameters.
            //
            majorFunction = IRP_MJ_FLUSH_BUFFERS;

        } else if ((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_MEDIUM_ERROR) {

            // Return ERROR_UNRECOGNIZED_MEDIA instead of
            // STATUS_DEVICE_DATA_ERROR to make shell happy.
            //
            *Status = STATUS_UNRECOGNIZED_MEDIA;
            return;

        } else {

            return;
        }

    } else if (((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_NOT_READY) &&
             senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_INIT_COMMAND_REQUIRED ||
             (senseBuffer->SenseKey & 0xf) == SCSI_SENSE_UNIT_ATTENTION) {

        DebugPrint((1, "ScsiFlopProcessError: Reinitializing the floppy.\n"));

        //
        // Send the special mode sense command to enable writes on the
        // floptical drive.
        //

        alignment = DeviceObject->AlignmentRequirement ?
            DeviceObject->AlignmentRequirement : 1;

        context = ExAllocatePool(
            NonPagedPool,
            sizeof(COMPLETION_CONTEXT) + 0x2a + (ULONG)alignment
            );

        if (context == NULL) {

            //
            // If there is not enough memory to fulfill this request,
            // simply return. A subsequent retry will fail and another
            // chance to start the unit.
            //

            return;
        }

        srb = &context->Srb;
        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Set the transfer length.
        //

        srb->DataTransferLength = 0x2a;
        srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_AUTOSENSE | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

        //
        // The data buffer must be aligned.
        //

        srb->DataBuffer = (PVOID) (((ULONG_PTR) (context + 1) + (alignment - 1)) &
            ~(alignment - 1));


        //
        // Build the start unit CDB.
        //

        srb->CdbLength = 6;
        cdb = (PCDB)srb->Cdb;
        cdb->MODE_SENSE.LogicalUnitNumber = srb->Lun;
        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = 0x2e;
        cdb->MODE_SENSE.AllocationLength = 0x2a;

        majorFunction = IRP_MJ_READ;

    } else {

        return;
    }

    context->DeviceObject = DeviceObject;

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    //
    // Build the asynchronous request
    // to be sent to the port driver.
    //

    irp = IoBuildAsynchronousFsdRequest(majorFunction,
                       DeviceObject,
                       srb->DataBuffer,
                       srb->DataTransferLength,
                       &largeInt,
                       NULL);

    if(irp == NULL) {
        ExFreePool(context);
        return;
    }


    IoSetCompletionRoutine(irp,
           (PIO_COMPLETION_ROUTINE)ClassAsynchronousCompletion,
           context,
           TRUE,
           TRUE,
           TRUE);

    ClassAcquireRemoveLock(DeviceObject, irp);

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    srb->OriginalRequest = irp;

    //
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Others.Argument1 = (PVOID)srb;

    //
    // Can't release the remove lock yet - let ClassAsynchronousCompletion
    // take care of that for us.
    //

    (VOID)IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    return;
}

NTSTATUS
FlopticalFormatMedia(
    PDEVICE_OBJECT DeviceObject,
    PFORMAT_PARAMETERS Format
    )
/*++

Routine Description:

    This routine is used to do perform a format tracks for the 20.8 MB
    floppy.  Because the device does not support format tracks and the full
    format takes a long time a write of zeros is done instead.

Arguments:

    DeviceObject - Supplies the device object to be tested.

    Format - Supplies the format parameters.

Return Value:

    Returns a status for the operation.

--*/
{
    IO_STATUS_BLOCK ioStatus;
    PIRP irp;
    KEVENT event;
    LARGE_INTEGER offset;
    ULONG length;
    PVOID buffer;
    PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
    NTSTATUS status;

    driveMediaConstants = &DriveMediaConstants[Drive2080Media2080];

    //
    // Calculate the length of the buffer.
    //

    length = ((Format->EndCylinderNumber - Format->StartCylinderNumber) *
        driveMediaConstants->NumberOfHeads +
        Format->EndHeadNumber - Format->StartHeadNumber + 1) *
        driveMediaConstants->SectorsPerTrack *
        driveMediaConstants->BytesPerSector;

    buffer = ExAllocatePool(NonPagedPoolCacheAligned, length);

    if (buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(buffer, length);

    offset.QuadPart =
    (Format->StartCylinderNumber * driveMediaConstants->NumberOfHeads +
    Format->StartHeadNumber) * driveMediaConstants->SectorsPerTrack *
    driveMediaConstants->BytesPerSector;

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build the synchronous request with data transfer.
    //

    irp = IoBuildSynchronousFsdRequest(
       IRP_MJ_WRITE,
       DeviceObject,
       buffer,
       length,
       &offset,
       &event,
       &ioStatus);


    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {

        //
        // Wait for the request to complete if necessary.
        //

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    //
    // If the call  driver suceeded then set the status to the status block.
    //

    if (NT_SUCCESS(status)) {
        status = ioStatus.Status;
    }

    ExFreePool(buffer);

    return(status);

}

#if 0

LONG
SFlopStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    )
{
    UCHAR  first ,last;

    if (Count) {
        do {

            //
            // Get next char.
            //

            first = *FirstStr++;
            last = *SecondStr++;

            if (first != last) {

                //
                // If no match, try lower-casing.
                //

                if (first>='A' && first<='Z') {
                    first = first - 'A' + 'a';
                }
                if (last>='A' && last<='Z') {
                    last = last - 'A' + 'a';
                }
                if (first != last) {

                    //
                    // No match
                    //

                    return first - last;
                }
            }
        }while (--Count && first);
    }

    return 0;
}
#endif


NTSTATUS
ScsiFlopRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    sfloppy driver.  This routine is called
    when all outstanding requests have been completed and the driver has
    disappeared - no requests may be issued to the lower drivers.

Arguments:

    DeviceObject - the device object being removed

    Type - the type of remove operation (QUERY, REMOVE or CANCEL)

Return Value:

    for a query - success if the device can be removed or a failure code
                  indiciating why not.

    for a remove or cancel - STATUS_SUCCESS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension =
        DeviceObject->DeviceExtension;
    PDISK_DATA diskData = deviceExtension->CommonExtension.DriverData;

    PAGED_CODE();

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }

    if(deviceExtension->DeviceDescriptor) {
        ExFreePool(deviceExtension->DeviceDescriptor);
        deviceExtension->DeviceDescriptor = NULL;
    }

    if(deviceExtension->AdapterDescriptor) {
        ExFreePool(deviceExtension->AdapterDescriptor);
        deviceExtension->AdapterDescriptor = NULL;
    }

    if(deviceExtension->SenseData) {
        ExFreePool(deviceExtension->SenseData);
        deviceExtension->SenseData = NULL;
    }

    ClassDeleteSrbLookasideList(&deviceExtension->CommonExtension);

    if(diskData->FloppyInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(
            &(diskData->FloppyInterfaceString),
            FALSE);
        RtlFreeUnicodeString(&(diskData->FloppyInterfaceString));
        RtlInitUnicodeString(&(diskData->FloppyInterfaceString), NULL);
    }

    if(Type == IRP_MN_REMOVE_DEVICE) {
        IoGetConfigurationInformation()->FloppyCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ScsiFlopStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
USBFlopGetMediaTypes(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
/*++

Routine Description:

    This routines determines the current or default geometry of the drive
    for IOCTL_DISK_GET_DRIVE_GEOMETRY, or all currently supported geometries
    of the drive (which is determined by its currently inserted media) for
    IOCTL_DISK_GET_MEDIA_TYPES.

    The returned geometries are determined by issuing a Read Format Capacities
    request and then matching the returned {Number of Blocks, Block Length}
    pairs in a table of known floppy geometries.

Arguments:

    DeviceObject - Supplies the device object.

    Irp - A IOCTL_DISK_GET_DRIVE_GEOMETRY or a IOCTL_DISK_GET_MEDIA_TYPES Irp.
          If NULL, the device geometry is updated with the current device
          geometry.

Return Value:

    Status is returned.

--*/
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension;
    PIO_STACK_LOCATION              irpStack;
    ULONG                           ioControlCode;
    PDISK_GEOMETRY                  outputBuffer;
    PDISK_GEOMETRY                  outputBufferEnd;
    ULONG                           outputBufferLength;
    PSCSI_REQUEST_BLOCK             srb;
    PVOID                           dataBuffer;
    ULONG                           dataTransferLength;
    struct _READ_FORMATTED_CAPACITIES *cdb;
    PFORMATTED_CAPACITY_LIST        capList;
    NTSTATUS                        status;

    fdoExtension = DeviceObject->DeviceExtension;

    if (Irp != NULL) {

        // Get the Irp parameters
        //
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

        Irp->IoStatus.Information = 0;

        outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;

        outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

        if (outputBufferLength < sizeof(DISK_GEOMETRY))
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        // Pointer arithmetic to allow multiple DISK_GEOMETRY's to be returned.
        // Rounds BufferEnd down to integral multiple of DISK_GEOMETRY structs.
        //
        outputBufferEnd = outputBuffer +
                          outputBufferLength / sizeof(DISK_GEOMETRY);

    } else {

        // No Irp to return the result in, just update the current geometry
        // in the device extension.
        //
        ioControlCode = IOCTL_DISK_GET_DRIVE_GEOMETRY;

        outputBuffer        = NULL;

        outputBufferEnd     = NULL;

        outputBufferLength  = 0;
    }

    if (ioControlCode == IOCTL_DISK_GET_DRIVE_GEOMETRY) {

        fdoExtension->DiskGeometry.MediaType = Unknown;

        status = ClassReadDriveCapacity(DeviceObject);

        if (!NT_SUCCESS(status))
        {
            // If the media is not recongized, we want to return the default
            // geometry so that the media can be formatted.  Unrecognized media
            // causes SCSI_SENSE_MEDIUM_ERROR, which gets reported as
            // STATUS_DEVICE_DATA_ERROR.  Ignore these errors, but return other
            // errors, such as STATUS_NO_MEDIA_IN_DEVICE.
            //
            if (status != STATUS_UNRECOGNIZED_MEDIA)
            {
                DebugPrint((2,"IOCTL_DISK_GET_DRIVE_GEOMETRY returns %08X\n", status));

                return status;
            }
        }
    }

    // Allocate an SRB for the SCSIOP_READ_FORMATTED_CAPACITY request
    //
    srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate a transfer buffer for the SCSIOP_READ_FORMATTED_CAPACITY request
    // The length of the returned descriptor array is limited to a byte field
    // in the capacity list header.
    //
    dataTransferLength = sizeof(FORMATTED_CAPACITY_LIST) +
                         31 * sizeof(FORMATTED_CAPACITY_DESCRIPTOR);

    ASSERT(dataTransferLength < 0x100);

    dataBuffer = ExAllocatePool(NonPagedPool, dataTransferLength);

    if (dataBuffer == NULL)
    {
        ExFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the SRB and CDB
    //
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    RtlZeroMemory(dataBuffer, dataTransferLength);

    srb->CdbLength = sizeof(struct _READ_FORMATTED_CAPACITIES);

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb = (struct _READ_FORMATTED_CAPACITIES *)srb->Cdb;

    cdb->OperationCode = SCSIOP_READ_FORMATTED_CAPACITY;
    cdb->AllocationLength[1] = (UCHAR)dataTransferLength;

    // Send down the SCSIOP_READ_FORMATTED_CAPACITY request
    //
    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     dataBuffer,
                                     dataTransferLength,
                                     FALSE);

    capList = (PFORMATTED_CAPACITY_LIST)dataBuffer;

    // If we don't get as much data as requested, it is not an error.
    //
    if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)
    {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status) &&
        srb->DataTransferLength >= sizeof(FORMATTED_CAPACITY_LIST) &&
        capList->CapacityListLength &&
        capList->CapacityListLength % sizeof(FORMATTED_CAPACITY_DESCRIPTOR) == 0)
    {
        ULONG   NumberOfBlocks;
        ULONG   BlockLength;
        ULONG   count;
        ULONG   i, j;
        LONG    currentGeometry;
        BOOLEAN capacityMatches[FLOPPY_CAPACITIES];

        // Subtract the size of the Capacity List Header to get
        // just the size of the Capacity List Descriptor array.
        //
        srb->DataTransferLength -= sizeof(FORMATTED_CAPACITY_LIST);

        // Only look at the Capacity List Descriptors that were actually
        // returned.
        //
        if (srb->DataTransferLength < capList->CapacityListLength)
        {
            count = srb->DataTransferLength /
                    sizeof(FORMATTED_CAPACITY_DESCRIPTOR);
        }
        else
        {
            count = capList->CapacityListLength /
                    sizeof(FORMATTED_CAPACITY_DESCRIPTOR);
        }

        // Updated only if a match is found for the first Capacity List
        // Descriptor returned by the device.
        //
        currentGeometry = -1;

        // Initialize the array of capacities that hit a match.
        //
        RtlZeroMemory(capacityMatches, sizeof(capacityMatches));

        // Iterate over each Capacity List Descriptor returned from the device
        // and record matching capacities in the capacity match array.
        //
        for (i = 0; i < count; i++)
        {
            NumberOfBlocks = (capList->Descriptors[i].NumberOfBlocks[0] << 24) +
                             (capList->Descriptors[i].NumberOfBlocks[1] << 16) +
                             (capList->Descriptors[i].NumberOfBlocks[2] <<  8) +
                             (capList->Descriptors[i].NumberOfBlocks[3]);

            BlockLength = (capList->Descriptors[i].BlockLength[0] << 16) +
                          (capList->Descriptors[i].BlockLength[1] <<  8) +
                          (capList->Descriptors[i].BlockLength[2]);

            // Given the {NumberOfBlocks, BlockLength} from this Capacity List
            // Descriptor, find a matching entry in FloppyCapacities[].
            //
            for (j = 0; j < FLOPPY_CAPACITIES; j++)
            {
                if (NumberOfBlocks == FloppyCapacities[j].NumberOfBlocks &&
                    BlockLength    == FloppyCapacities[j].BlockLength)
                {
                    // A matching capacity was found, record it.
                    //
                    capacityMatches[j] = TRUE;

                    // A match was found for the first Capacity List
                    // Descriptor returned by the device.
                    //
                    if (i == 0)
                    {
                        currentGeometry = j;
                    }
                }
            }
        }

        // Default status is STATUS_UNRECOGNIZED_MEDIA, unless we return
        // either STATUS_SUCCESS or STATUS_BUFFER_OVERFLOW.
        //
        status = STATUS_UNRECOGNIZED_MEDIA;

        if (ioControlCode == IOCTL_DISK_GET_DRIVE_GEOMETRY) {

            if (currentGeometry != -1)
            {
                // Update the current device geometry
                //
                fdoExtension->DiskGeometry = FloppyGeometries[currentGeometry];

                //
                // Calculate sector to byte shift.
                //

                WHICH_BIT(fdoExtension->DiskGeometry.BytesPerSector,
                          fdoExtension->SectorShift);

                fdoExtension->CommonExtension.PartitionLength.QuadPart =
                    (LONGLONG)FloppyCapacities[currentGeometry].NumberOfBlocks *
                    FloppyCapacities[currentGeometry].BlockLength;

                DebugPrint((2,"geometry  is: %3d %2d %d %2d %4d  %2d  %08X\n",
                            fdoExtension->DiskGeometry.Cylinders.LowPart,
                            fdoExtension->DiskGeometry.MediaType,
                            fdoExtension->DiskGeometry.TracksPerCylinder,
                            fdoExtension->DiskGeometry.SectorsPerTrack,
                            fdoExtension->DiskGeometry.BytesPerSector,
                            fdoExtension->SectorShift,
                            fdoExtension->CommonExtension.PartitionLength.LowPart));

                // Return the current device geometry
                //
                if (Irp != NULL)
                {
                    *outputBuffer = FloppyGeometries[currentGeometry];

                    Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
                }

                status = STATUS_SUCCESS;
            }

        } else {

            // Iterate over the capacities and return the geometry
            // corresponding to each matching Capacity List Descriptor
            // returned from the device.
            //
            // The resulting list should be in sorted ascending order,
            // assuming that the FloppyGeometries[] array is in sorted
            // ascending order.
            //
            for (i = 0; i < FLOPPY_CAPACITIES; i++)
            {
                if (capacityMatches[i] && FloppyCapacities[i].CanFormat)
                {
                    if (outputBuffer < outputBufferEnd)
                    {
                        *outputBuffer++ = FloppyGeometries[i];

                        Irp->IoStatus.Information += sizeof(DISK_GEOMETRY);

                        DebugPrint((2,"geometry    : %3d %2d %d %2d %4d\n",
                                    FloppyGeometries[i].Cylinders.LowPart,
                                    FloppyGeometries[i].MediaType,
                                    FloppyGeometries[i].TracksPerCylinder,
                                    FloppyGeometries[i].SectorsPerTrack,
                                    FloppyGeometries[i].BytesPerSector));

                        status = STATUS_SUCCESS;
                    }
                    else
                    {
                        // We ran out of output buffer room before we ran out
                        // geometries to return.
                        //
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
        }
    }
    else if (NT_SUCCESS(status))
    {
        // The SCSIOP_READ_FORMATTED_CAPACITY request was successful, but
        // returned data does not appear valid.
        //
        status = STATUS_UNSUCCESSFUL;
    }

    ExFreePool(dataBuffer);
    ExFreePool(srb);

    return status;
}


NTSTATUS
USBFlopFormatTracks(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
/*++

Routine Description:

    This routines formats the specified tracks.  If multiple tracks are
    specified, each is formatted with a separate Format Unit request.

Arguments:

    DeviceObject - Supplies the device object.

    Irp - A IOCTL_DISK_FORMAT_TRACKS Irp.

Return Value:

    Status is returned.

--*/
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension;
    PIO_STACK_LOCATION              irpStack;
    PFORMAT_PARAMETERS              formatParameters;
    PDISK_GEOMETRY                  geometry;
    PFORMATTED_CAPACITY             capacity;
    PSCSI_REQUEST_BLOCK             srb;
    PFORMAT_UNIT_PARAMETER_LIST     parameterList;
    PCDB12FORMAT                    cdb;
    ULONG                           i;
    ULONG                           cylinder, head;
    NTSTATUS                        status;

    fdoExtension = DeviceObject->DeviceExtension;

    // Get the Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FORMAT_PARAMETERS))
    {
        return STATUS_INVALID_PARAMETER;
    }

    formatParameters = (PFORMAT_PARAMETERS)Irp->AssociatedIrp.SystemBuffer;

    // Find the geometry / capacity entries corresponding to the format
    // parameters MediaType
    //
    geometry = NULL;
    capacity = NULL;

    for (i=0; i<FLOPPY_CAPACITIES; i++)
    {
        if (FloppyGeometries[i].MediaType == formatParameters->MediaType)
        {
            geometry = &FloppyGeometries[i];
            capacity = &FloppyCapacities[i];

            break;
        }
    }

    if (geometry == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Check if the format parameters are valid
    //
    if ((formatParameters->StartCylinderNumber >
         geometry->Cylinders.LowPart - 1)       ||

        (formatParameters->EndCylinderNumber >
         geometry->Cylinders.LowPart - 1)       ||

        (formatParameters->StartHeadNumber >
         geometry->TracksPerCylinder - 1)       ||

        (formatParameters->EndHeadNumber >
         geometry->TracksPerCylinder - 1)       ||

        (formatParameters->StartCylinderNumber >
         formatParameters->EndCylinderNumber)   ||

        (formatParameters->StartHeadNumber >
         formatParameters->EndHeadNumber))
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Don't low level format LS-120 media, Imation says it's best to not
    // do this.
    //
    if ((formatParameters->MediaType == F3_120M_512) ||
        (formatParameters->MediaType == F3_240M_512))
    {
        return STATUS_SUCCESS;
    }

    // Allocate an SRB for the SCSIOP_FORMAT_UNIT request
    //
    srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate a transfer buffer for the SCSIOP_FORMAT_UNIT parameter list
    //
    parameterList = ExAllocatePool(NonPagedPool,
                                   sizeof(FORMAT_UNIT_PARAMETER_LIST));

    if (parameterList == NULL)
    {
        ExFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the parameter list
    //
    RtlZeroMemory(parameterList, sizeof(FORMAT_UNIT_PARAMETER_LIST));

    parameterList->DefectListHeader.SingleTrack = 1;
    parameterList->DefectListHeader.DisableCert = 1;  // TEAC requires this set
    parameterList->DefectListHeader.FormatOptionsValid = 1;
    parameterList->DefectListHeader.DefectListLengthLsb = 8;

    parameterList->FormatDescriptor.NumberOfBlocks[0] =
        (UCHAR)((capacity->NumberOfBlocks >> 24) & 0xFF);

    parameterList->FormatDescriptor.NumberOfBlocks[1] =
        (UCHAR)((capacity->NumberOfBlocks >> 16) & 0xFF);

    parameterList->FormatDescriptor.NumberOfBlocks[2] =
        (UCHAR)((capacity->NumberOfBlocks >> 8) & 0xFF);

    parameterList->FormatDescriptor.NumberOfBlocks[3] =
        (UCHAR)(capacity->NumberOfBlocks & 0xFF);

    parameterList->FormatDescriptor.BlockLength[0] =
        (UCHAR)((capacity->BlockLength >> 16) & 0xFF);

    parameterList->FormatDescriptor.BlockLength[1] =
        (UCHAR)((capacity->BlockLength >> 8) & 0xFF);

    parameterList->FormatDescriptor.BlockLength[2] =
        (UCHAR)(capacity->BlockLength & 0xFF);


    for (cylinder =  formatParameters->StartCylinderNumber;
         cylinder <= formatParameters->EndCylinderNumber;
         cylinder++)
    {
        for (head =  formatParameters->StartHeadNumber;
             head <= formatParameters->EndHeadNumber;
             head++)
        {
            // Initialize the SRB and CDB
            //
            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

            srb->CdbLength = sizeof(CDB12FORMAT);

            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb = (PCDB12FORMAT)srb->Cdb;

            cdb->OperationCode = SCSIOP_FORMAT_UNIT;
            cdb->DefectListFormat = 7;
            cdb->FmtData = 1;
            cdb->TrackNumber = (UCHAR)cylinder;
            cdb->ParameterListLengthLsb = sizeof(FORMAT_UNIT_PARAMETER_LIST);

            parameterList->DefectListHeader.Side = (UCHAR)head;

            // Send down the SCSIOP_READ_FORMATTED_CAPACITY request
            //
            status = ClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             parameterList,
                                             sizeof(FORMAT_UNIT_PARAMETER_LIST),
                                             TRUE);

            if (!NT_SUCCESS(status))
            {
                break;
            }
        }
        if (!NT_SUCCESS(status))
        {
            break;
        }
    }

    if (NT_SUCCESS(status) && formatParameters->StartCylinderNumber == 0)
    {
        // Update the device geometry
        //

        DebugPrint((2,"geometry was: %3d %2d %d %2d %4d  %2d  %08X\n",
                    fdoExtension->DiskGeometry.Cylinders.LowPart,
                    fdoExtension->DiskGeometry.MediaType,
                    fdoExtension->DiskGeometry.TracksPerCylinder,
                    fdoExtension->DiskGeometry.SectorsPerTrack,
                    fdoExtension->DiskGeometry.BytesPerSector,
                    fdoExtension->SectorShift,
                    fdoExtension->CommonExtension.PartitionLength.LowPart));

        fdoExtension->DiskGeometry = *geometry;

        //
        // Calculate sector to byte shift.
        //

        WHICH_BIT(fdoExtension->DiskGeometry.BytesPerSector,
                  fdoExtension->SectorShift);

        fdoExtension->CommonExtension.PartitionLength.QuadPart =
            (LONGLONG)capacity->NumberOfBlocks *
            capacity->BlockLength;

        DebugPrint((2,"geometry  is: %3d %2d %d %2d %4d  %2d  %08X\n",
                    fdoExtension->DiskGeometry.Cylinders.LowPart,
                    fdoExtension->DiskGeometry.MediaType,
                    fdoExtension->DiskGeometry.TracksPerCylinder,
                    fdoExtension->DiskGeometry.SectorsPerTrack,
                    fdoExtension->DiskGeometry.BytesPerSector,
                    fdoExtension->SectorShift,
                    fdoExtension->CommonExtension.PartitionLength.LowPart));
    }

    // Free everything we allocated
    //
    ExFreePool(parameterList);
    ExFreePool(srb);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\scsiport\wmi.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    wmi.c

Abstract:

    This module contains the WMI support code for SCSIPORT's functional and
    physical device objects.

Authors:

    Dan Markarian

Environment:

    Kernel mode only.

Notes:

    None.

Revision History:

    19-Mar-1997, Original Writing, Dan Markarian

--*/

#include "port.h"

#define __FILE_ID__ 'wmi '

#if DBG
static const char *__file__ = __FILE__;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortSystemControlIrp)
#pragma alloc_text(PAGE, SpWmiIrpNormalRequest)
#pragma alloc_text(PAGE, SpWmiIrpRegisterRequest)

#pragma alloc_text(PAGE, SpWmiHandleOnMiniPortBehalf)
#pragma alloc_text(PAGE, SpWmiPassToMiniPort)

#pragma alloc_text(PAGE, SpWmiDestroySpRegInfo)
#pragma alloc_text(PAGE, SpWmiGetSpRegInfo)
#pragma alloc_text(PAGE, SpWmiInitializeSpRegInfo)

#pragma alloc_text(PAGE, SpWmiInitializeFreeRequestList)

#pragma alloc_text(PAGE, SpAdapterConfiguredForSenseDataEvents)
#pragma alloc_text(PAGE, SpInitAdapterWmiRegInfo)
#endif



NTSTATUS
ScsiPortSystemControlIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )

/*++

Routine Description:

   Process an IRP_MJ_SYSTEM_CONTROL request packet.

Arguments:

   DeviceObject - Pointer to the functional or physical device object.

   Irp          - Pointer to the request packet.

Return Value:

   NTSTATUS result code.

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION       irpSp;
    NTSTATUS                 status          = STATUS_SUCCESS;
    WMI_PARAMETERS           wmiParameters;

    ULONG isRemoved;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    if (isRemoved) {
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        SpReleaseRemoveLock(DeviceObject, Irp);
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Obtain a pointer to the current IRP stack location.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL);

    //
    // Determine if this WMI request was destined to us.  If not, pass the IRP
    // down.
    //

    if ( (PDEVICE_OBJECT)irpSp->Parameters.WMI.ProviderId == DeviceObject) {
        BOOLEAN forwardDown = FALSE;

        DebugPrint((3, "ScsiPortSystemControlIrp: MinorFunction %x\n", 
                    irpSp->MinorFunction));
    
        //
        // Copy the WMI parameters into our local WMISRB structure.
        //
        wmiParameters.ProviderId = irpSp->Parameters.WMI.ProviderId;
        wmiParameters.DataPath   = irpSp->Parameters.WMI.DataPath;
        wmiParameters.Buffer     = irpSp->Parameters.WMI.Buffer;
        wmiParameters.BufferSize = irpSp->Parameters.WMI.BufferSize;
    
        //
        // Determine what the WMI request wants of us.
        //
        switch (irpSp->MinorFunction) {
            case IRP_MN_QUERY_ALL_DATA:
                //
                // Query for all instances of a data block.
                //
            case IRP_MN_QUERY_SINGLE_INSTANCE:
                //
                // Query for a single instance of a data block.
                //
            case IRP_MN_CHANGE_SINGLE_INSTANCE:
                //
                // Change all data items in a data block for a single instance.
                //
            case IRP_MN_CHANGE_SINGLE_ITEM:
                //
                // Change a single data item in a data block for a single instance.
                //
            case IRP_MN_ENABLE_EVENTS:
                //
                // Enable events.
                //
            case IRP_MN_DISABLE_EVENTS:
                //
                // Disable events.
                //
            case IRP_MN_ENABLE_COLLECTION:
                //
                // Enable data collection for the given GUID.
                //
            case IRP_MN_DISABLE_COLLECTION:
                //
                // Disable data collection for the given GUID.
                //
                status = SpWmiIrpNormalRequest(DeviceObject,
                                               irpSp->MinorFunction,
                                               &wmiParameters);
                break;
    
            case IRP_MN_EXECUTE_METHOD:
                //
                // Execute method
                //
                status = SpWmiIrpNormalRequest(DeviceObject,
                                               irpSp->MinorFunction,
                                               &wmiParameters);
                break;
    
            case IRP_MN_REGINFO:
                //
                // Query for registration and registration update information.
                //
                status = SpWmiIrpRegisterRequest(DeviceObject, &wmiParameters);
                break;
    
            default:
                //
                // Unsupported WMI request.  According to some rule in the WMI 
                // spec we're supposed to send unsupported WMI requests down 
                // the stack even if we're marked as the provider.
                //
                forwardDown = TRUE;
                break;
        }

        if(forwardDown == FALSE) {
            //
            // Complete this WMI IRP request.
            //
            Irp->IoStatus.Status     = status;
            Irp->IoStatus.Information= (NT_SUCCESS(status) ? 
                                        wmiParameters.BufferSize : 0);
            SpReleaseRemoveLock(DeviceObject, Irp);
            SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

            return status;
        }
    }

    //
    // Request should be forwarded down the stack.  If we're a pdo that means 
    // we should complete it as is.
    //

    SpReleaseRemoveLock(DeviceObject, Irp);

    if(commonExtension->IsPdo) {
        //
        // Get the current status out of the irp.
        // 

        status = Irp->IoStatus.Status;

        //
        // Complete the irp.
        //

        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
    } else {
        //
        // Copy parameters from our stack location to the next stack location.
        //
    
        IoCopyCurrentIrpStackLocationToNext(Irp);
    
        //
        // Pass the IRP on to the next driver.
        //

        status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
    }

    return status;
}


NTSTATUS
SpWmiIrpNormalRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    )

/*++

Routine Description:

    Process an IRP_MJ_SYSTEM_CONTROL request packet (for all requests except registration
    IRP_MN_REGINFO requests).

Arguments:

    DeviceObject  - Pointer to the functional or physical device object.

    WmiMinorCode  - WMI action to perform.

    WmiParameters - Pointer to the WMI request parameters.

Return Value:

    NTSTATUS result code to complete the WMI IRP with.

Notes:

    If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
    BufferSize field will reflect the actual size of the WMI return buffer.

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    NTSTATUS                 status          = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Determine if SCSIPORT will repond to this WMI request on behalf of
    // the miniport driver.
    //
    status = SpWmiHandleOnMiniPortBehalf(DeviceObject,
                                         WmiMinorCode,
                                         WmiParameters);

    //
    // If not, pass the request onto the miniport driver, provided the
    // miniport driver does support WMI.
    //
    if (status == STATUS_WMI_GUID_NOT_FOUND && 
        commonExtension->WmiMiniPortSupport) {

        //
        // Send off the WMI request to the miniport.
        //
        status = SpWmiPassToMiniPort(DeviceObject,
                                     WmiMinorCode,
                                     WmiParameters);

        if (NT_SUCCESS(status)) {

            //
            // Fill in fields miniport cannot fill in for itself.
            //
            if ( WmiMinorCode == IRP_MN_QUERY_ALL_DATA ||
                 WmiMinorCode == IRP_MN_QUERY_SINGLE_INSTANCE ) {
                PWNODE_HEADER wnodeHeader = WmiParameters->Buffer;

                ASSERT( WmiParameters->BufferSize >= sizeof(WNODE_HEADER) );

                KeQuerySystemTime(&wnodeHeader->TimeStamp);
            }
        } else {

            //
            // Translate SRB status into a meaningful NTSTATUS status.
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    return status;
}


NTSTATUS
SpWmiIrpRegisterRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PWMI_PARAMETERS WmiParameters
    )

/*++

Routine Description:

   Process an IRP_MJ_SYSTEM_CONTROL registration request.

Arguments:

   DeviceObject  - Pointer to the functional or physical device object.

   WmiParameters - Pointer to the WMI request parameters.

Return Value:

   NTSTATUS result code to complete the WMI IRP with.

Notes:

   If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
   BufferSize field will reflect the actual size of the WMI return buffer.

--*/

{
    PCOMMON_EXTENSION   commonExtension = DeviceObject->DeviceExtension;
    PSCSIPORT_DRIVER_EXTENSION driverExtension = NULL;

    ULONG                      countedRegistryPathSize = 0;
    ULONG                      retSz;
    PWMIREGINFO                spWmiRegInfoBuf;
    ULONG                      spWmiRegInfoBufSize;
    NTSTATUS                   status = STATUS_SUCCESS;
    BOOLEAN                    wmiUpdateRequest;
    ULONG                      i;
    PDEVICE_OBJECT             pDO;

    WMI_PARAMETERS  paranoidBackup = *WmiParameters;

    PAGED_CODE();

    //
    // Validate our assumptions for this function's code.
    //
    ASSERT(WmiParameters->BufferSize >= sizeof(ULONG));

    //
    // Validate the registration mode.
    //
    switch ( (ULONG)(ULONG_PTR)WmiParameters->DataPath ) {
        case WMIUPDATE:
            //
            // No SCSIPORT registration information will be piggybacked
            // on behalf of the miniport for a WMIUPDATE request.
            //
            wmiUpdateRequest = TRUE;
            break;

        case WMIREGISTER:
            wmiUpdateRequest = FALSE;
            break;

        default:
            //
            // Unsupported registration mode.
            //
            ASSERT(FALSE);
            return STATUS_INVALID_PARAMETER;
    }

    //
    // Obtain the driver extension for this miniport (FDO/PDO).
    //
    driverExtension = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                                 ScsiPortInitialize);

    ASSERT(driverExtension != NULL);
    //
    // Make Prefix Happy -- we'll quit if
    // driverExtension is NULL
    //
    if (driverExtension == NULL) {
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // Obtain a pointer to the SCSIPORT WMI registration information
    // buffer, which is registered on behalf of the miniport driver.
    //
    SpWmiGetSpRegInfo(DeviceObject, &spWmiRegInfoBuf,
                      &spWmiRegInfoBufSize);

    //
    // Pass the WMI registration request to the miniport.  This is not
    // necessary if we know the miniport driver does not support WMI.
    //
    if (commonExtension->WmiMiniPortSupport == TRUE &&
        commonExtension->WmiMiniPortInitialized == TRUE) {
        
        //
        // Note that we shrink the buffer size by the size necessary
        // to hold SCSIPORT's own registration information, which we
        // register on behalf of the miniport.   This information is
        // piggybacked into the WMI return buffer after the call  to
        // the miniport.  We ensure that the BufferSize passed to the
        // miniport is no smaller than "sizeof(ULONG)" so that it can
        // tell us the required buffer size should the buffer be too
        // small [by filling in this ULONG].
        //
        // Note that we must also make enough room for a copy of the
        // miniport registry path in the buffer, since the WMIREGINFO
        // structures from the miniport DO NOT set their registry
        // path fields.
        //
        ASSERT(WmiParameters->BufferSize >= sizeof(ULONG));

        //
        // Calculate size of required miniport registry path.
        //
        countedRegistryPathSize = driverExtension->RegistryPath.Length
                                  + sizeof(USHORT);

        //
        // Shrink buffer by the appropriate size. Note that the extra
        // 7 bytes (possibly extraneous) is subtracted to ensure that
        // the piggybacked data added later on is 8-byte aligned (if
        // any).
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {
            WmiParameters->BufferSize =
                (WmiParameters->BufferSize > spWmiRegInfoBufSize + countedRegistryPathSize + 7 + sizeof(ULONG)) ?
                WmiParameters->BufferSize - spWmiRegInfoBufSize - countedRegistryPathSize - 7 :
            sizeof(ULONG);
        } else { // no data to piggyback
            WmiParameters->BufferSize =
                (WmiParameters->BufferSize > countedRegistryPathSize + sizeof(ULONG)) ?
                WmiParameters->BufferSize - countedRegistryPathSize :
            sizeof(ULONG);
        }

        //
        // Call the minidriver.
        //
        status = SpWmiPassToMiniPort(DeviceObject,
                                     IRP_MN_REGINFO,
                                     WmiParameters);

        ASSERT(WmiParameters->ProviderId == paranoidBackup.ProviderId);
        ASSERT(WmiParameters->DataPath == paranoidBackup.DataPath);
        ASSERT(WmiParameters->Buffer == paranoidBackup.Buffer);
        ASSERT(WmiParameters->BufferSize <= paranoidBackup.BufferSize);

        //
        // Assign WmiParameters->BufferSize to retSz temporarily.
        //
        // Note that on return from the above call, the wmiParameters'
        // BufferSize field has been _modified_ to reflect the current
        // size of the return buffer.
        //
        retSz = WmiParameters->BufferSize;

    } else if (WmiParameters->BufferSize < spWmiRegInfoBufSize &&
               !wmiUpdateRequest) {

        //
        // Insufficient space to hold SCSIPORT WMI registration information
        // alone.  Inform WMI appropriately of the required buffer size.
        //
        *((ULONG*)WmiParameters->Buffer) = spWmiRegInfoBufSize;
        WmiParameters->BufferSize = sizeof(ULONG);

        return STATUS_SUCCESS;

    } else { // no miniport support for WMI, sufficient space for scsiport info

        //
        // Fake having the miniport return zero WMIREGINFO structures.
        //
        retSz = 0;
    }

    //
    // Piggyback SCSIPORT's registration information into the WMI
    // registration buffer.
    //

    if ((status == STATUS_BUFFER_TOO_SMALL) ||
        (NT_SUCCESS(status) && (retSz == sizeof(ULONG)))) {
        
        //
        // Miniport could not fit registration information into the
        // pre-shrunk buffer.
        //
        // Buffer currently contains a ULONG specifying required buffer
        // size of miniport registration info, but does not include the
        // SCSIPORT registration info's size.  Add it in.
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {

            *((ULONG*)WmiParameters->Buffer) += spWmiRegInfoBufSize;

            //
            // Add an extra 7 bytes (possibly extraneous) which is used to
            // ensure that the piggybacked data structure 8-byte aligned.
            //
            *((ULONG*)WmiParameters->Buffer) += 7;
        }

        //
        // Add in size of the miniport registry path.
        //
        *((ULONG*)WmiParameters->Buffer) += countedRegistryPathSize;

        //
        // Return STATUS_SUCCESS, even though this is a BUFFER TOO
        // SMALL failure, while ensuring retSz = sizeof(ULONG), as
        // the WMI protocol calls us to do.
        //
        retSz  = sizeof(ULONG);
        status = STATUS_SUCCESS;

    } else if ( NT_SUCCESS(status) ) {
        
        //
        // Zero or more WMIREGINFOs exist in buffer from miniport.
        //

        //
        // Piggyback the miniport registry path transparently, if at least one
        // WMIREGINFO was returned by the minport.
        //
        if (retSz) {

            ULONG offsetToRegPath  = retSz;
            PWMIREGINFO wmiRegInfo = WmiParameters->Buffer;

            //
            // Build a counted wide-character string, containing the
            // registry path, into the WMI buffer.
            //
            *( (PUSHORT)( (PUCHAR)WmiParameters->Buffer + retSz ) ) =
                driverExtension->RegistryPath.Length,
            RtlCopyMemory( (PUCHAR)WmiParameters->Buffer + retSz + sizeof(USHORT),
                           driverExtension->RegistryPath.Buffer,
                           driverExtension->RegistryPath.Length);

            //
            // Traverse the WMIREGINFO structures returned by the mini-
            // driver and set the missing RegistryPath fields to point
            // to our registry path location. We also jam in the PDO for
            // the device stack so that the device instance name is used for
            // the wmi instance names.
            //
            pDO = commonExtension->IsPdo ? DeviceObject :
                            ((PADAPTER_EXTENSION)commonExtension)->LowerPdo;

            while (1) {
                wmiRegInfo->RegistryPath = offsetToRegPath;

                for (i = 0; i < wmiRegInfo->GuidCount; i++)
                {
                    wmiRegInfo->WmiRegGuid[i].InstanceInfo = (ULONG_PTR)pDO;
                    wmiRegInfo->WmiRegGuid[i].Flags &= ~(WMIREG_FLAG_INSTANCE_BASENAME |
                                                      WMIREG_FLAG_INSTANCE_LIST);
                    wmiRegInfo->WmiRegGuid[i].Flags |= WMIREG_FLAG_INSTANCE_PDO;
                }

                if (wmiRegInfo->NextWmiRegInfo == 0) {
                    break;
                }

                offsetToRegPath -= wmiRegInfo->NextWmiRegInfo;
                wmiRegInfo = (PWMIREGINFO)( (PUCHAR)wmiRegInfo +
                                            wmiRegInfo->NextWmiRegInfo );
            }

            //
            // Adjust retSz to reflect new size of the WMI buffer.
            //
            retSz += countedRegistryPathSize;
            wmiRegInfo->BufferSize = retSz;
        } // else, no WMIREGINFOs registered whatsoever, nothing to piggyback

        //
        // Do we have any SCSIPORT WMIREGINFOs to piggyback?
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {

            //
            // Adjust retSz so that the data we piggyback is 8-byte aligned
            // (safe if retSz = 0).
            //
            retSz = (retSz + 7) & ~7;

            //
            // Piggyback SCSIPORT's registration info into the buffer.
            //
            RtlCopyMemory( (PUCHAR)WmiParameters->Buffer + retSz,
                           spWmiRegInfoBuf,
                           spWmiRegInfoBufSize);

            //
            // Was at least one WMIREGINFO returned by the minidriver?
            // Otherwise, we have nothing else to add to the WMI buffer.
            //
            if (retSz) { // at least one WMIREGINFO returned by minidriver
                PWMIREGINFO wmiRegInfo = WmiParameters->Buffer;

                //
                // Traverse to the end of the WMIREGINFO structures returned
                // by the miniport.
                //
                while (wmiRegInfo->NextWmiRegInfo) {
                    wmiRegInfo = (PWMIREGINFO)( (PUCHAR)wmiRegInfo +
                                                wmiRegInfo->NextWmiRegInfo );
                }

                //
                // Chain minidriver's WMIREGINFO structures to SCSIPORT's
                // WMIREGINFO structures.
                //
                wmiRegInfo->NextWmiRegInfo = retSz -
                                             (ULONG)((PUCHAR)wmiRegInfo - (PUCHAR)WmiParameters->Buffer);
            }

            //
            // Adjust retSz to reflect new size of the WMI buffer.
            //
            retSz += spWmiRegInfoBufSize;

        } // we had SCSIPORT REGINFO data to piggyback
    } // else, unknown error, complete IRP with this error status

    //
    // Save new buffer size to WmiParameters->BufferSize.
    //
    WmiParameters->BufferSize = retSz;
    return status;
}


NTSTATUS
SpWmiHandleOnMiniPortBehalf(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    )

/*++

Routine Description:

   Handle the WMI request on the miniport's behalf, if possible.

Arguments:

   DeviceObject  - Pointer to the functional or physical device object.

   WmiMinorCode  - WMI action to perform.

   WmiParameters - WMI parameters.

Return Value:

   If STATUS_UNSUCCESSFUL is returned, SCSIPORT did not handle this WMI
   request.  It must be passed on to the miniport driver for processing.

   Otherwise, this function returns an NTSTATUS code describing the result
   of handling the WMI request.  Complete the IRP with this status.

Notes:

   If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
   BufferSize field will reflect the actual size of the WMI return buffer.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    if (commonExtension->IsPdo) {
        //
        /// Placeholder for code to check if this is a PDO-relevant GUID which
        //  SCSIPORT must handle, and handle it if so.
        //
    } else { // FDO

        NTSTATUS status;
        GUID guid = *(GUID*)WmiParameters->DataPath;
        PADAPTER_EXTENSION Adapter = (PADAPTER_EXTENSION) commonExtension;
        SIZE_T size;

        DebugPrint((3, "SpWmiHandleOnMiniPortBehalf: WmiMinorCode:%x guid:"
                       "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\n",
                    WmiMinorCode,
                    guid.Data1,
                    guid.Data2,
                    guid.Data3,
                    guid.Data4[0],
                    guid.Data4[1],
                    guid.Data4[2],
                    guid.Data4[3],
                    guid.Data4[4],
                    guid.Data4[5],
                    guid.Data4[6],
                    guid.Data4[7]));

        //
        // Check the guid to verify that it represents a data block supported
        // by scsiport.  If it does not, we return failure and let the
        // miniports have a look at it.
        //

        size = RtlCompareMemory(&guid, 
                                &Adapter->SenseDataEventClass,
                                sizeof(GUID)); 
        if (size != sizeof(GUID)) {

            //
            // WMI spec says to fail the irp w/ STATUS_WMI_GUID_NOT_FOUND if the
            // guid does not represent a data block we understand.
            //

            DebugPrint((1, "SpWmiHandleOnMiniPortBehalf: not handling data block\n"));
            return STATUS_WMI_GUID_NOT_FOUND;
        }

        //
        // Handle the request.  At this point, we've decided that the IRP
        // is intended for this device and that this is a datablock 
        // supported by the device.  Therefore, the code below returns the 
        // appropriate result as per the wmi spec.
        //

        switch (WmiMinorCode) {
        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        case IRP_MN_REGINFO:
        case IRP_MN_EXECUTE_METHOD:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        
        case IRP_MN_ENABLE_EVENTS:
            DebugPrint((3, "SenseData event enabled\n"));
            Adapter->EnableSenseDataEvent = TRUE;
            WmiParameters->BufferSize = 0;
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_DISABLE_EVENTS:
            DebugPrint((3, "SenseData event disabled\n"));
            Adapter->EnableSenseDataEvent = FALSE;
            WmiParameters->BufferSize = 0;
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        };

        return status;

    }

    return STATUS_WMI_GUID_NOT_FOUND;
}


NTSTATUS
SpWmiPassToMiniPort(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    )
/*++

Routine Description:

   This function pass a WMI request to the miniport driver for processing.
   It creates an SRB which is processed normally by the port driver.  This
   call is synchronous.

   Callers of SpWmiPassToMiniPort must be running at IRQL PASSIVE_LEVEL.

Arguments:

   DeviceObject  - Pointer to the functional or physical device object.

   WmiMinorCode  - WMI action to perform.

   WmiParameters - WMI parameters.

Return Value:

   An NTSTATUS code describing the result of handling the WMI request.
   Complete the IRP with this status.

Notes:

   If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
   BufferSize field will reflect the actual size of the WMI return buffer.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PADAPTER_EXTENSION fdoExtension;
    SCSI_WMI_REQUEST_BLOCK   srb;
    LARGE_INTEGER            startingOffset;
    PLOGICAL_UNIT_EXTENSION  logicalUnit;

    ULONG                    commonBufferSize;
    PUCHAR                   commonBuffer;
    PHYSICAL_ADDRESS         physicalAddress;
    PVOID                    removeTag = (PVOID)((ULONG_PTR)WmiParameters+3);
    PWNODE_HEADER            wnode;

    NTSTATUS status;

    PAGED_CODE();

    startingOffset.QuadPart = (LONGLONG) 1;

    //
    // Zero out the SRB.
    //
    RtlZeroMemory(&srb, sizeof(SCSI_WMI_REQUEST_BLOCK));

    //
    // Initialize the SRB for a WMI request.
    //
    if (commonExtension->IsPdo) {                                       // [PDO]

        //
        // Set the logical unit addressing from this PDO's device extension.
        //
        logicalUnit = DeviceObject->DeviceExtension;

        SpAcquireRemoveLock(DeviceObject, removeTag);

        srb.PathId      = logicalUnit->PathId;
        srb.TargetId    = logicalUnit->TargetId;
        srb.Lun         = logicalUnit->Lun;

        fdoExtension = logicalUnit->AdapterExtension;

    } else {                                                            // [FDO]

        //
        // Set the logical unit addressing to the first logical unit.  This is
        // merely used for addressing purposes for adapter requests only.
        // NOTE: SpFindSafeLogicalUnit will acquire the remove lock
        //

        logicalUnit = SpFindSafeLogicalUnit(DeviceObject,
                                            0xff,
                                            removeTag);

        if (logicalUnit == NULL) {
            return(STATUS_DEVICE_DOES_NOT_EXIST);
        }

        fdoExtension = DeviceObject->DeviceExtension;

        srb.WMIFlags    = SRB_WMI_FLAGS_ADAPTER_REQUEST;
        srb.PathId      = logicalUnit->PathId;
        srb.TargetId    = logicalUnit->TargetId;
        srb.Lun         = logicalUnit->Lun;
    }

    //
    // HACK - allocate a chunk of common buffer for the actual request to
    // get processed in. We need to determine the size of buffer to allocate
    // this is the larger of the input or output buffers
    //

    if (WmiMinorCode == IRP_MN_EXECUTE_METHOD)
    {
        wnode = (PWNODE_HEADER)WmiParameters->Buffer;
        commonBufferSize = (WmiParameters->BufferSize > wnode->BufferSize) ?
                            WmiParameters->BufferSize :
                            wnode->BufferSize;
    } else {
        commonBufferSize = WmiParameters->BufferSize;
    }

    commonBuffer = AllocateCommonBuffer(fdoExtension->DmaAdapterObject,
                                        commonBufferSize,
                                        &physicalAddress,
                                        FALSE);

    if(commonBuffer == NULL) {
        DebugPrint((1, "SpWmiPassToMiniPort: Unable to allocate %#x bytes of "
                       "common buffer\n", commonBufferSize));

        SpReleaseRemoveLock(logicalUnit->DeviceObject, removeTag);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {
        KEVENT event;
        PIRP irp;
        PMDL mdl;
        PIO_STACK_LOCATION irpStack;

        RtlCopyMemory(commonBuffer, WmiParameters->Buffer, commonBufferSize);

        srb.DataBuffer         = commonBuffer;       // [already non-paged]
        srb.DataTransferLength = WmiParameters->BufferSize;
        srb.Function           = SRB_FUNCTION_WMI;
        srb.Length             = sizeof(SCSI_REQUEST_BLOCK);
        srb.WMISubFunction     = WmiMinorCode;
        srb.DataPath           = WmiParameters->DataPath;
        srb.SrbFlags           = SRB_FLAGS_DATA_IN | SRB_FLAGS_NO_QUEUE_FREEZE;
        srb.TimeOutValue       = 10;                                // [ten seconds]

        //
        // Note that the value in DataBuffer may be used regardless of the value
        // of the MapBuffers field.
        //

        //
        // Initialize the notification event.
        //

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        //
        // Build IRP for this request.
        // Note we do this synchronously for two reasons.  If it was done
        // asynchonously then the completion code would have to make a special
        // check to deallocate the buffer.  Second if a completion routine were
        // used then an additional IRP stack location would be needed.
        //

        irp = SpAllocateIrp(logicalUnit->DeviceObject->StackSize, FALSE, DeviceObject->DriverObject);

        if(irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        mdl = SpAllocateMdl(commonBuffer,
                            WmiParameters->BufferSize,
                            FALSE,
                            FALSE,
                            irp,
                            DeviceObject->DriverObject);

        if(mdl == NULL) {
            IoFreeIrp(irp);
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        MmBuildMdlForNonPagedPool(mdl);

        srb.OriginalRequest = irp;

        irpStack = IoGetNextIrpStackLocation(irp);

        //
        // Set major code.
        //
        irpStack->MajorFunction = IRP_MJ_SCSI;

        //
        // Set SRB pointer.
        //
        irpStack->Parameters.Scsi.Srb = (PSCSI_REQUEST_BLOCK)&srb;

        //
        // Setup a completion routine so we know when the request has completed.
        //

        IoSetCompletionRoutine(irp,
                               SpSignalCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Flush the data buffer for output.  This will insure that the data is
        // written back to memory.  Since the data-in flag is the the port driver
        // will flush the data again for input which will ensure the data is not
        // in the cache.
        //
        KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

        //
        // Call port driver to handle this request.
        //
        IoCallDriver(logicalUnit->CommonExtension.DeviceObject, irp);

        //
        // Wait for request to complete.
        //
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = irp->IoStatus.Status;

        //
        // Relay the return buffer's size to the caller on success.
        //
        if (NT_SUCCESS(status)) {
            WmiParameters->BufferSize = srb.DataTransferLength;
        }

        //
        // Copy back the correct number of bytes into the caller provided buffer.
        //

        RtlCopyMemory(WmiParameters->Buffer,
                      commonBuffer,
                      WmiParameters->BufferSize);

        //
        // Free the irp and MDL.
        //

        IoFreeMdl(mdl);
        IoFreeIrp(irp);

    } finally {

        FreeCommonBuffer(fdoExtension->DmaAdapterObject,
                         commonBufferSize,
                         physicalAddress,
                         commonBuffer,
                         FALSE);

        SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                            removeTag);
    }

    //
    // Return the IRP's status.
    //
    return status;
}


VOID
SpWmiGetSpRegInfo(
    IN  PDEVICE_OBJECT DeviceObject,
    OUT PWMIREGINFO  * SpRegInfoBuf,
    OUT ULONG        * SpRegInfoBufSize
    )
/*++

Routine Description:

   This function retrieves a pointer to the WMI registration information
   buffer for the given device object.

Arguments:

   DeviceObject     - Pointer to the functional or physical device object.

Return Values:

   SpRegInfoBuf     - Pointer to the registration information buffer, which
                      will point to the WMIREGINFO structures that SCSIPORT
                      should register on behalf of the miniport driver.

   SpRegInfoBufSize - Size of the registration information buffer in bytes.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Retrieve a pointer to the WMI registration information buffer for the
    // given device object.
    //
    if (commonExtension->WmiScsiPortRegInfoBuf     == NULL ||
        commonExtension->WmiScsiPortRegInfoBufSize == 0) {
        *SpRegInfoBuf     = NULL;
        *SpRegInfoBufSize = 0;
    } else {
        *SpRegInfoBuf     = commonExtension->WmiScsiPortRegInfoBuf;
        *SpRegInfoBufSize = commonExtension->WmiScsiPortRegInfoBufSize;
    }

    return;
}


VOID
SpWmiInitializeSpRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject
    )

/*++

Routine Description:

   This function allocates space for and builds the WMI registration
   information buffer for this device object.

   The WMI registration information consists of zero or more WMIREGINFO
   structures which are used to register and identify SCSIPORT-handled
   WMI GUIDs on behalf of the miniport driver. This information is not
   the complete set of WMI GUIDs supported by for device object,  only
   the ones supported by SCSIPORT.  It is actually piggybacked onto the
   WMIREGINFO structures provided by the miniport driver during
   registration.

   The WMI registration information is allocated and stored on a
   per-device basis because, concievably, each device may support
   differing WMI GUIDs and/or instances during its lifetime.

Arguments:

   DeviceObject   - Pointer to the functional or physical device object.

Return Value:

   None.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    ASSERT(commonExtension->WmiScsiPortRegInfoBuf     == NULL);
    ASSERT(commonExtension->WmiScsiPortRegInfoBufSize == 0);

    if (commonExtension->IsPdo) {

        //
        /// Placeholder for code to build PDO-relevant GUIDs into the
        //  registration buffer.
        //
        /// commonExtension->WmiScsiPortRegInfo     = ExAllocatePool( PagedPool, <size> );
        //  commonExtension->WmiScsiPortRegInfoSize = <size>;
        //  <code to fill in wmireginfo struct(s) into buffer>
        //
        //  * use L"SCSIPORT" as the RegistryPath
    
    } else { // FDO
        
        BOOLEAN DoesSenseEvents;
        GUID SenseDataClass;

        //
        // Determine if the supplied adapter is configured to generate sense
        // data events.  If it is, copy the guid into the adapter extension
        // and initialize the WMIREGINFO structure pointed to by the
        // adapter extension.
        //

        DoesSenseEvents = SpAdapterConfiguredForSenseDataEvents(
                              DeviceObject,
                              &SenseDataClass);
        if (DoesSenseEvents) {
            ((PADAPTER_EXTENSION)commonExtension)->SenseDataEventClass = SenseDataClass;
            SpInitAdapterWmiRegInfo(DeviceObject);
        }
    }

    return;
}


VOID
SpWmiDestroySpRegInfo(
    IN  PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

   This function de-allocates the space for the WMI registration information
   buffer for this device object, if one exists.

Arguments:

   DeviceObject - Pointer to the functional or physical device object.

Return Value:

   None.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    if (commonExtension->WmiScsiPortRegInfoBuf) {
        ExFreePool(commonExtension->WmiScsiPortRegInfoBuf);
        commonExtension->WmiScsiPortRegInfoBuf = NULL;
    }

    commonExtension->WmiScsiPortRegInfoBufSize = 0;

    return;
}


NTSTATUS
SpWmiInitializeFreeRequestList(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          NumberOfItems
    )
/*++

Routine Description:

    Call that initializes the WmiFreeMiniPortRequestList, this call MUST
    be completed prior to any manipulatio of the WmiFreeMiniPortRequestList

    The list will be initialized with at most the number of cells requested.

    If the list has already been initialized, we raise the watermark by the number
    of Items requested.

Arguments:

    DeviceObject    - Device Object that this list belongs to
    NumberOfItems   - requested number of free cells

Return Value:

    Return the SUCESS if list was initialized succesfully

    STATUS_INSUFFICIENT_REOSOURCES  - Indicates that we could not allocate
                                      enough memory for the list header

Notes:


--*/
{
    PADAPTER_EXTENSION  fdoExtension;
    ULONG               itemsInserted;
    KIRQL               oldIrql;

    PAGED_CODE();               // Routine is paged until locked down.

    //
    // Obtain a pointer to the functional device extension (for the adapter).
    //
    if ( ((PCOMMON_EXTENSION)DeviceObject->DeviceExtension)->IsPdo ) {
        fdoExtension = ((PLOGICAL_UNIT_EXTENSION)DeviceObject->DeviceExtension)
                       ->AdapterExtension;
    } else {
        fdoExtension = DeviceObject->DeviceExtension;
    }

    // If the list has been initalized increase the watermark
    if (fdoExtension->WmiFreeMiniPortRequestInitialized) {
        DebugPrint((2, "SpWmiInitializeFreeRequestList:"
                    " Increased watermark for : %p\n", fdoExtension));

        InterlockedExchangeAdd
            (&(fdoExtension->WmiFreeMiniPortRequestWatermark),
             NumberOfItems);

        while (fdoExtension->WmiFreeMiniPortRequestCount <
            fdoExtension->WmiFreeMiniPortRequestWatermark) {

            // Add free cells until the count reaches the watermark
            SpWmiPushFreeRequestItem(fdoExtension);
        }

        return (STATUS_SUCCESS);
    }

    // Only FDO's should be calling when the list has not been initialized
    ASSERT_FDO(DeviceObject);

    // Assignt he list we just initialized to the pointer in the
    // fdoExtension (and save the lock pointer also)
    KeInitializeSpinLock(&(fdoExtension->WmiFreeMiniPortRequestLock));
    ExInitializeSListHead(&(fdoExtension->WmiFreeMiniPortRequestList));

    DebugPrint((1, "SpWmiInitializeFreeRequestList:"
                " Initialized WmiFreeRequestList for: %p\n", fdoExtension));

    // Set the initialized flag
    fdoExtension->WmiFreeMiniPortRequestInitialized = TRUE;

    // Set the watermark, and the count to 0
    fdoExtension->WmiFreeMiniPortRequestWatermark = 0;
    fdoExtension->WmiFreeMiniPortRequestCount = 0;

    // Attempt to add free cells to the free list
    for (itemsInserted = 0; itemsInserted < NumberOfItems;
         itemsInserted++) {

        // Make a request to push a NULL item, so that the
        // allocation will be done by the next function
        //
        // At this point we don't care about the return value
        // because after we set the watermark, scsiport's free-cell
        // repopulation code will try to get the free list cell count
        // back to the watermark. (So if we fail to add all the requested
        // free cells, the repopulation code will attempt again for us
        // at a later time)
        SpWmiPushFreeRequestItem(fdoExtension);
    }


    // Now set the watermark to the correct value
    fdoExtension->WmiFreeMiniPortRequestWatermark = NumberOfItems;

    return(STATUS_SUCCESS);
}

VOID
SpWmiPushExistingFreeRequestItem(
    IN PADAPTER_EXTENSION Adapter,
    IN PWMI_MINIPORT_REQUEST_ITEM WmiRequestItem
    )
/*++

Routine Description:

    Inserts the entry into the interlocked list of free request items.

Arguments:

    WmiRequestItem - Pointer to the request item to insert into the free list.

Return Value:

    VOID

--*/
{
    //
    // The WMI request list must be initialized.
    //

    if (!Adapter->WmiFreeMiniPortRequestInitialized) {
        ASSERT(FALSE);
        return;
    }

    //
    // This request doesn't point to another one.
    //

    WmiRequestItem->NextRequest = NULL;

    //
    // Insert Cell into interlocked list.
    //

    ExInterlockedPushEntrySList(
        &(Adapter->WmiFreeMiniPortRequestList),
        (PSINGLE_LIST_ENTRY)WmiRequestItem,
        &(Adapter->WmiFreeMiniPortRequestLock));

    //
    // Increment the value of the free count.
    //
    
    InterlockedIncrement(&(Adapter->WmiFreeMiniPortRequestCount));
}

NTSTATUS
SpWmiPushFreeRequestItem(
    IN PADAPTER_EXTENSION           fdoExtension
    )
/*++

Routine Description:

    Inserts the Entry into the interlocked SLIST.  (Of Free items)

Arguments:

    fdoExtension        - The extension on the adapter

Return Value:

    STATUS_SUCESS                   - If succesful
    STATUS_INSUFFICIENT_RESOURCES   - If memory allocation fails
    STATUS_UNSUCCESSFUL             - Free List not initialized

Notes:

    This code cannot be marked as pageable since it will be called from
    DPC level

    Theoricatlly this call can fail, but no one should call this function
    before we've been initialized

--*/
{
    PWMI_MINIPORT_REQUEST_ITEM      Entry = NULL;

    if (!fdoExtension->WmiFreeMiniPortRequestInitialized) {
        return (STATUS_UNSUCCESSFUL);
    }

    Entry = SpAllocatePool(NonPagedPool,
                           sizeof(WMI_MINIPORT_REQUEST_ITEM),
                           SCSIPORT_TAG_WMI_EVENT,
                           fdoExtension->DeviceObject->DriverObject);

    if (!Entry) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Entry->NextRequest = NULL;

    // Insert Cell into interlocked list
    ExInterlockedPushEntrySList(
        &(fdoExtension->WmiFreeMiniPortRequestList),
        (PSINGLE_LIST_ENTRY)Entry,
        &(fdoExtension->WmiFreeMiniPortRequestLock));

    // Increment the value of the free count
    InterlockedIncrement(&(fdoExtension->WmiFreeMiniPortRequestCount));

    return(STATUS_SUCCESS);
}


PWMI_MINIPORT_REQUEST_ITEM
SpWmiPopFreeRequestItem(
    IN PADAPTER_EXTENSION           fdoExtension
    )
/*++

Routine Description:

    Pops an Entry from the interlocked SLIST.  (Of Free items)

Arguments:

    fdoExtension     - The extension on the adapter

Return Value:

    A pointer to a REQUEST_ITEM or NULL if none are available

Notes:

    This code cannot be paged, it will be called a DIRLQL

--*/
{
    PWMI_MINIPORT_REQUEST_ITEM              requestItem;

    if (!fdoExtension->WmiFreeMiniPortRequestInitialized) {
        return (NULL);
    }

    // Pop Cell from interlocked list
    requestItem = (PWMI_MINIPORT_REQUEST_ITEM)
        ExInterlockedPopEntrySList(
            &(fdoExtension->WmiFreeMiniPortRequestList),
            &(fdoExtension->WmiFreeMiniPortRequestLock));


    if (requestItem) {
        // Decrement the count of free cells
        InterlockedDecrement(&(fdoExtension->WmiFreeMiniPortRequestCount));

    }

    return (requestItem);
}



BOOLEAN
SpWmiRemoveFreeMiniPortRequestItems(
    IN PADAPTER_EXTENSION   fdoExtension
    )

/*++

Routine Description:

   This function removes WMI_MINIPORT_REQUEST_ITEM structures from the "free"
   queue of the adapter extension.

   It removed all the free cells.

Arguments:

    fdoExtension    - The device_extension

Return Value:

   TRUE always.

--*/

{
    PWMI_MINIPORT_REQUEST_ITEM   tmpRequestItem;
    PWMI_MINIPORT_REQUEST_ITEM   wmiRequestItem;

    //
    // Set the watermark to 0
    // No need to grab a lock we're just setting it
    fdoExtension->WmiFreeMiniPortRequestWatermark = 0;

    DebugPrint((1, "SpWmiRemoveFreeMiniPortRequestItems: Removing %p", fdoExtension));


    //
    // Walk the queue of items and de-allocate as many as we need to.
    //
    for (;;) {
        // Pop
        wmiRequestItem = SpWmiPopFreeRequestItem(fdoExtension);
        if (wmiRequestItem == NULL) {
            break;
        } else {
            ExFreePool(wmiRequestItem);
        }
    }

    return TRUE;
}

const GUID GUID_NULL = { 0 };

BOOLEAN
SpAdapterConfiguredForSenseDataEvents(
    IN PDEVICE_OBJECT DeviceObject,
    OUT GUID *SenseDataClass
    )

/*++

Routine Description:

   This function answers whether a specified device is configured to generate
   sense data events.  This is determined by the presense of a string value
   containing the GUID for the event class responsible for generating the
   events.

Arguments:

    DeviceObject    - Points to the device object
    
    SenseDataClass  - Points to a GUID into which the sense data class,
                      if found, is copied.  If none is found, GUID_NULL is
                      copied into the location.
                      
                      If the function's return value is FALSE, SenseDataClass
                      will be set to GUID_NULL.

Return Value:

   Answers TRUE if a GUID is registed for the device.  Otherwise, returns
   FALSE.

--*/

{
    NTSTATUS status;
    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
    HANDLE instanceHandle = NULL;    
    HANDLE handle = NULL;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    UNICODE_STRING unicodeString;
    UNICODE_STRING stringValue;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Initialize the guid pointed to by SenseDataClass to GUID_NULL.
    //

    *SenseDataClass = GUID_NULL;

    //
    // If this isn't a pnp device, don't attempt to determine
    // if it supports sense data events.  Just return FALSE.
    //

    if (!adapterExtension->IsPnp) {

        return FALSE;

    }

    //
    // Open the device registry key.
    //

    status = IoOpenDeviceRegistryKey(adapterExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_ALL_ACCESS,
                                     &instanceHandle);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Open the scsiport subkey under the device's Device Parameters key.
    //

    RtlInitUnicodeString(&unicodeString, L"Scsiport");
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        instanceHandle,
        NULL);

    status = ZwOpenKey(&handle,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Read the device's sense data class guid.  We have to initialize the 
    // maximum size of the string and init the buffer to NULL so 
    // RtlQueryRegistryValues will allocate a buffer for us.  If the specified 
    // value is not in the registry, the query will fail
    //

    stringValue.MaximumLength = 40;
    stringValue.Buffer = NULL;
    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"SenseDataEventClass";
    queryTable[0].EntryContext = &stringValue;

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                    (PWSTR) handle,
                                    queryTable,
                                    NULL,
                                    NULL);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    //
    // Convert the registry string to a GUID.
    //

    ASSERT(stringValue.Buffer);
    status = RtlGUIDFromString(&stringValue, SenseDataClass);
    ExFreePool(stringValue.Buffer);

cleanup:

    if(handle != NULL) {
        ZwClose(handle);
    }

    ASSERT(instanceHandle != NULL);
    ZwClose(instanceHandle);

    return (NT_SUCCESS(status)) ? TRUE : FALSE;
}
        
NTSTATUS
SpInitAdapterWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

   This function initializes a the WMIREGINFO structure pointed to by the
   specified device's extension.  This structure will be used later
   to register scsiport to handle WMI IRPs on behalf of the device.

Arguments:

    DeviceObject    - The device object
    
Return Value:

   STATUS_SUCCESS
   
   STATUS_INSUFFICIENT_RESOURCES

--*/

{
    ULONG TotalSize;
    PWMIREGINFO TempInfo;
    PWCHAR TempString;
    ULONG OffsetToRegPath;
    ULONG OffsetToRsrcName;
    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    //
    // The registry path name follows the WMIREGINFO struct and the
    // contiguous array of WMIREGGUIDW structs.
    //

    OffsetToRegPath = sizeof(WMIREGINFO) + sizeof(WMIREGGUIDW);

    //
    // The name of the resource follows the registry path name and
    // its size.
    //

    OffsetToRsrcName = OffsetToRegPath + 
                       sizeof(WCHAR) + 
                       sizeof(SPMOFREGISTRYPATH);

    //
    // The total size of the block of memory we need to allocate is the size
    // of the WMIREGINFO struct, plus the size of however many WMIREGGUIDW
    // structs we need, plus the size of the registry path and and resource
    // name strings.  The size is aligned on an 8 byte boundary.
    //

    TotalSize = OffsetToRsrcName + 
                sizeof(WCHAR) +
                sizeof(SPMOFRESOURCENAME);
    TotalSize = (TotalSize + 7) & ~7;

    //
    // Try to allocate the memory.
    //

    TempInfo = SpAllocatePool(NonPagedPool,
                              TotalSize,
                              SCSIPORT_TAG_WMI_EVENT,
                              DeviceObject->DriverObject);

    if (TempInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the WMIREGINFO struct.
    //

    TempInfo->BufferSize = TotalSize;
    TempInfo->NextWmiRegInfo = 0;
    TempInfo->RegistryPath = OffsetToRegPath;
    TempInfo->MofResourceName = OffsetToRsrcName;

    TempString = (PWCHAR)((ULONG_PTR)TempInfo + OffsetToRegPath);
    *TempString++ = sizeof(SPMOFREGISTRYPATH);
    RtlCopyMemory(TempString, 
                  SPMOFREGISTRYPATH, 
                  sizeof(SPMOFREGISTRYPATH));

    TempString = (PWCHAR)((ULONG_PTR)TempInfo + OffsetToRsrcName);
    *TempString++ = sizeof(SPMOFRESOURCENAME);
    RtlCopyMemory(TempString, 
                  SPMOFRESOURCENAME, 
                  sizeof(SPMOFRESOURCENAME));

    TempInfo->GuidCount = 1;

    TempInfo->WmiRegGuid[0].Guid = adapterExtension->SenseDataEventClass;
    TempInfo->WmiRegGuid[0].Flags = 
        WMIREG_FLAG_INSTANCE_PDO | WMIREG_FLAG_EVENT_ONLY_GUID;
    TempInfo->WmiRegGuid[0].InstanceCount = 1;

    //
    // This must be a physical device object.
    //

    TempInfo->WmiRegGuid[0].Pdo = (ULONG_PTR) adapterExtension->LowerPdo;

    //
    // Update the common extension members.
    //

    commonExtension->WmiScsiPortRegInfoBuf = TempInfo;
    commonExtension->WmiScsiPortRegInfoBufSize = TotalSize;

    DebugPrint((3, "SpInitAdapterWmiRegInfo: commonExtension %p "
                "WmiScsiPortRegInfoBuf %p WmiScsiPortRegInfoBufSize %x\n",
                commonExtension,
                commonExtension->WmiScsiPortRegInfoBuf,
                commonExtension->WmiScsiPortRegInfoBufSize));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\class\tape.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    scsitape.c

Abstract:

    This is the tape class driver.

Environment:

    kernel mode only

Revision History:

--*/

#include "tape.h"

//
// Define the maximum inquiry data length.
//

#define MAXIMUM_TAPE_INQUIRY_DATA   252
#define UNDEFINED_BLOCK_SIZE        ((ULONG) -1)
#define TAPE_SRB_LIST_SIZE          4

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
TapeUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
TapeAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
TapeStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
CreateTapeDeviceObject(
    IN PDRIVER_OBJECT          DriverObject,
    IN PDEVICE_OBJECT          PhysicalDeviceObject,
    IN PTAPE_INIT_DATA_EX      TapeInitData
    );

VOID
TapeError(
    IN PDEVICE_OBJECT      DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PNTSTATUS       Status,
    IN OUT PBOOLEAN        Retry
    );

NTSTATUS
TapeReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
TapeReadWrite(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

VOID
SplitTapeRequest(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    );

NTSTATUS
TapeIoCompleteAssociated(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
TapeDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeInitDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
TapeRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
TapeStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, TapeUnload)
#pragma alloc_text(PAGE, TapeClassInitialize)
#pragma alloc_text(PAGE, TapeAddDevice)
#pragma alloc_text(PAGE, CreateTapeDeviceObject)
#pragma alloc_text(PAGE, TapeStartDevice)
#pragma alloc_text(PAGE, TapeInitDevice)
#pragma alloc_text(PAGE, TapeRemoveDevice)
#pragma alloc_text(PAGE, TapeStopDevice)
#pragma alloc_text(PAGE, TapeDeviceControl)
#pragma alloc_text(PAGE, TapeReadWriteVerification)
#pragma alloc_text(PAGE, TapeReadWrite)
#pragma alloc_text(PAGE, SplitTapeRequest)
#pragma alloc_text(PAGE, ScsiTapeFreeSrbBuffer)
#pragma alloc_text(PAGE, TapeClassZeroMemory)
#pragma alloc_text(PAGE, TapeClassCompareMemory)
#pragma alloc_text(PAGE, TapeClassLiDiv)
#pragma alloc_text(PAGE, GetTimeoutDeltaFromRegistry)
#endif


NTSTATUS
DriverEntry(
  IN PDRIVER_OBJECT DriverObject,
  IN PUNICODE_STRING RegistryPath
  )

/*++

Routine Description:

    This is the entry point for this EXPORT DRIVER.  It does nothing.

--*/

{
    return STATUS_SUCCESS;
}


ULONG
TapeClassInitialize(
    IN  PVOID           Argument1,
    IN  PVOID           Argument2,
    IN  PTAPE_INIT_DATA_EX TapeInitData
    )

/*++

Routine Description:

    This routine is called by a tape mini-class driver during its
    DriverEntry routine to initialize the driver.

Arguments:

    Argument1       - Supplies the first argument to DriverEntry.

    Argument2       - Supplies the second argument to DriverEntry.

    TapeInitData    - Supplies the tape initialization data.

Return Value:

    A valid return code for a DriverEntry routine.

--*/

{
    PDRIVER_OBJECT  driverObject = Argument1;
    PUNICODE_STRING registryPath = Argument2;
    PTAPE_INIT_DATA_EX driverExtension;
    NTSTATUS        status;
    CLASS_INIT_DATA initializationData;
    TAPE_INIT_DATA_EX tmpInitData;

    PAGED_CODE();

    DebugPrint((1,"\n\nSCSI Tape Class Driver\n"));

    //
    // Zero InitData
    //

    RtlZeroMemory (&tmpInitData, sizeof(TAPE_INIT_DATA_EX));

    //
    // Save the tape init data passed in from the miniclass driver. When AddDevice gets called, it will be used.
    // First a check for 4.0 vs. later miniclass drivers.
    //

    if (TapeInitData->InitDataSize != sizeof(TAPE_INIT_DATA_EX)) {

        //
        // Earlier rev. Copy the bits around so that the EX structure is correct.
        //

        RtlCopyMemory(&tmpInitData.VerifyInquiry, TapeInitData, sizeof(TAPE_INIT_DATA));
        //
        // Mark it as an earlier rev.
        //

        tmpInitData.InitDataSize = sizeof(TAPE_INIT_DATA);
    } else {
        RtlCopyMemory(&tmpInitData, TapeInitData, sizeof(TAPE_INIT_DATA_EX));
    }

    //
    // Get the driverExtension

    status = IoAllocateDriverObjectExtension(driverObject,
                                             TapeClassInitialize,
                                             sizeof(TAPE_INIT_DATA_EX),
                                             &driverExtension);

    if (!NT_SUCCESS(status)) {

        if(status == STATUS_OBJECT_NAME_COLLISION) {

            //
            // An extension already exists for this key.  Get a pointer to it
            //

            driverExtension = IoGetDriverObjectExtension(driverObject,
                                                         TapeClassInitialize);
            if (driverExtension == NULL) {
                DebugPrint((1, "TapeClassInitialize : driverExtension NULL\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {

            //
            // As this failed, the tape init data won't be able to be stored.
            //

            DebugPrint((1, "TapeClassInitialize: Error %x allocating driver extension.\n",
                            status));

            return status;
        }
    }

    RtlCopyMemory(driverExtension, &tmpInitData, sizeof(TAPE_INIT_DATA_EX));

    RtlZeroMemory (&initializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    initializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);


    initializationData.FdoData.DeviceExtensionSize = sizeof(FUNCTIONAL_DEVICE_EXTENSION) +
                                                     sizeof(TAPE_DATA) + tmpInitData.MinitapeExtensionSize;

    initializationData.FdoData.DeviceType = FILE_DEVICE_TAPE;
    initializationData.FdoData.DeviceCharacteristics =   FILE_REMOVABLE_MEDIA |
                                                         FILE_DEVICE_SECURE_OPEN;

    //
    // Set entry points
    //

    initializationData.FdoData.ClassStartDevice = TapeStartDevice;
    initializationData.FdoData.ClassStopDevice = TapeStopDevice;
    initializationData.FdoData.ClassInitDevice = TapeInitDevice;
    initializationData.FdoData.ClassRemoveDevice = TapeRemoveDevice;
    initializationData.ClassAddDevice = TapeAddDevice;

    initializationData.FdoData.ClassError = TapeError;
    initializationData.FdoData.ClassReadWriteVerification = TapeReadWriteVerification;
    initializationData.FdoData.ClassDeviceControl = TapeDeviceControl;


    initializationData.FdoData.ClassShutdownFlush = NULL;
    initializationData.FdoData.ClassCreateClose = NULL;

    //
    // Routines for WMI support
    //
    initializationData.FdoData.ClassWmiInfo.GuidCount = 6; 
    initializationData.FdoData.ClassWmiInfo.GuidRegInfo = TapeWmiGuidList;
    initializationData.FdoData.ClassWmiInfo.ClassQueryWmiRegInfo = TapeQueryWmiRegInfo;
    initializationData.FdoData.ClassWmiInfo.ClassQueryWmiDataBlock = TapeQueryWmiDataBlock;
    initializationData.FdoData.ClassWmiInfo.ClassSetWmiDataBlock = TapeSetWmiDataBlock;
    initializationData.FdoData.ClassWmiInfo.ClassSetWmiDataItem = TapeSetWmiDataItem;
    initializationData.FdoData.ClassWmiInfo.ClassExecuteWmiMethod = TapeExecuteWmiMethod;
    initializationData.FdoData.ClassWmiInfo.ClassWmiFunctionControl = TapeWmiFunctionControl;

    initializationData.ClassUnload = TapeUnload;

    //
    // Call the class init routine last, so can cleanup if it fails
    //

    status = ClassInitialize( driverObject, registryPath, &initializationData);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1, "TapeClassInitialize: Error %x from classinit\n", status));
        TapeUnload(driverObject);
    }

    return status;
}

VOID
TapeUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    return;
}

NTSTATUS
TapeAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - Tape class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    PTAPE_INIT_DATA_EX tapeInitData;
    NTSTATUS status;
    PULONG tapeCount;

    PAGED_CODE();

    //
    // Get the saved-off tape init data.
    //

    tapeInitData = IoGetDriverObjectExtension(DriverObject, TapeClassInitialize);

    ASSERT(tapeInitData);

    //
    // Get the address of the count of the number of tape devices already initialized.
    //

    tapeCount = &IoGetConfigurationInformation()->TapeCount;

    status = CreateTapeDeviceObject(DriverObject,
                                    PhysicalDeviceObject,
                                    tapeInitData);


    if(NT_SUCCESS(status)) {

        (*tapeCount)++;
    }

    return status;
}


NTSTATUS
CreateTapeDeviceObject(
    IN PDRIVER_OBJECT          DriverObject,
    IN PDEVICE_OBJECT          PhysicalDeviceObject,
    IN PTAPE_INIT_DATA_EX      TapeInitData
    )

/*++

Routine Description:

    This routine creates an object for the device.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PhysicalDeviceObject - DeviceObject of the attached to device.
    TapeInitData - Supplies the tape initialization data.

Return Value:

    NTSTATUS

--*/

{
    UCHAR                   deviceNameBuffer[64];
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject;
    PTAPE_INIT_DATA_EX      tapeInitData;
    PDEVICE_OBJECT          lowerDevice;
    PTAPE_DATA              tapeData;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    WCHAR                   dosNameBuffer[64];
    WCHAR                   wideNameBuffer[64];
    UNICODE_STRING          dosUnicodeString;
    UNICODE_STRING          deviceUnicodeString;
    ULONG                   tapeCount;

    PAGED_CODE();

    DebugPrint((3,"CreateDeviceObject: Enter routine\n"));

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);

    //
    // Claim the device. Note that any errors after this
    // will goto the generic handler, where the device will
    // be released.
    //

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        //
        // Someone already had this device - we're in trouble
        //

        ObDereferenceObject(lowerDevice);

        return status;
    }

    //
    // Create device object for this device.
    //

    tapeCount = 0;
    do {
       sprintf(deviceNameBuffer,
               "\\Device\\Tape%d",
               tapeCount);
   
       status = ClassCreateDeviceObject(DriverObject,
                                        deviceNameBuffer,
                                        PhysicalDeviceObject,
                                        TRUE,
                                        &deviceObject);
       tapeCount++;
    } while (status == STATUS_OBJECT_NAME_COLLISION);
    
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"CreateTapeDeviceObjects: Can not create device %s\n",
                    deviceNameBuffer));

        goto CreateTapeDeviceObjectExit;
    }

    //
    // Indicate that IRPs should include MDLs.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system tape number
    //

    fdoExtension->DeviceNumber = tapeCount - 1;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;
    fdoExtension->DeviceDescriptor = NULL;

    //
    // Attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        //
        // The attach failed. Cleanup and return.
        //

        status = STATUS_UNSUCCESSFUL;
        goto CreateTapeDeviceObjectExit;
    }

    //
    // Save the tape initialization data.
    //

    RtlCopyMemory(fdoExtension->CommonExtension.DriverData, TapeInitData,sizeof(TAPE_INIT_DATA_EX));

    //
    // Initialize the splitrequest spinlock.
    //

    tapeData = (PTAPE_DATA)fdoExtension->CommonExtension.DriverData;
    KeInitializeSpinLock(&tapeData->SplitRequestSpinLock);

    //
    // Create the dos port driver name.
    //

    swprintf(dosNameBuffer,
             L"\\DosDevices\\TAPE%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);

    //
    // Recreate the deviceName
    //

    swprintf(wideNameBuffer,
             L"\\Device\\Tape%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&deviceUnicodeString,
                         wideNameBuffer);

    status = IoAssignArcName(&dosUnicodeString,
                             &deviceUnicodeString);
    if (NT_SUCCESS(status)) {
         tapeData->DosNameCreated = TRUE;
    } else {
         tapeData->DosNameCreated = FALSE;
    }

    //
    // The device is initialized properly - mark it as such.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    ObDereferenceObject(lowerDevice);

    return(STATUS_SUCCESS);

CreateTapeDeviceObjectExit:

    //
    // Release the device since an error occured.
    //

    // ClassClaimDevice(PortDeviceObject,
    //                      LunInfo,
    //                      TRUE,
    //                      NULL);

    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    return status;

} // end CreateTapeDeviceObject()


NTSTATUS
TapeStartDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called after InitDevice, and creates the symbolic link,
    and sets up information in the registry.
    The routine could be called multiple times, in the event of a StopDevice.


Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PTAPE_DATA              tapeData;
    PTAPE_INIT_DATA_EX      tapeInitData;
    PINQUIRYDATA            inquiryData;
    ULONG                   inquiryLength;
    SCSI_REQUEST_BLOCK      srb;
    PCDB                    cdb;
    NTSTATUS                status;
    PVOID                   minitapeExtension;
    PMODE_CAP_PAGE          capPage = NULL ;
    PMODE_CAPABILITIES_PAGE capabilitiesPage;
    ULONG                   pageLength;

    PAGED_CODE();

    //
    // Build and send request to get inquiry data.
    //

    inquiryData = ExAllocatePool(NonPagedPoolCacheAligned, MAXIMUM_TAPE_INQUIRY_DATA);
    if (!inquiryData) {
        //
        // The buffer cannot be allocated.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get the tape init data again.
    //

    tapeData = (PTAPE_DATA)(fdoExtension->CommonExtension.DriverData);
    tapeInitData = &tapeData->TapeInitData;

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 2;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = MAXIMUM_TAPE_INQUIRY_DATA;

    status = ClassSendSrbSynchronous(Fdo,
                                     &srb,
                                     inquiryData,
                                     MAXIMUM_TAPE_INQUIRY_DATA,
                                     FALSE);


    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        srb.SrbStatus = SRB_STATUS_SUCCESS;
    }

    if (srb.SrbStatus == SRB_STATUS_SUCCESS) {
        inquiryLength = inquiryData->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (inquiryLength > srb.DataTransferLength) {
            inquiryLength = srb.DataTransferLength;
        }

        //
        // Verify that we really want this device.
        //

        if (tapeInitData->QueryModeCapabilitiesPage ) {

            capPage = ExAllocatePool(NonPagedPoolCacheAligned,
                                     sizeof(MODE_CAP_PAGE));
        }
        if (capPage) {

            pageLength = ClassModeSense(Fdo,
                                        (PCHAR) capPage,
                                        sizeof(MODE_CAP_PAGE),
                                        MODE_PAGE_CAPABILITIES);

            if (pageLength == 0) {
                pageLength = ClassModeSense(Fdo,
                                            (PCHAR) capPage,
                                            sizeof(MODE_CAP_PAGE),
                                            MODE_PAGE_CAPABILITIES);
            }

            if (pageLength < (sizeof(MODE_CAP_PAGE) - 1)) {
                ExFreePool(capPage);
                capPage = NULL;
            }
        }

        if (capPage) {
            capabilitiesPage = &(capPage->CapabilitiesPage);
        } else {
            capabilitiesPage = NULL;
        }

        //
        // Initialize the minitape extension.
        //

        if (tapeInitData->ExtensionInit) {
            minitapeExtension = tapeData + 1;
            tapeInitData->ExtensionInit(minitapeExtension,
                                        inquiryData,
                                        capabilitiesPage);
        }

        if (capPage) {
            ExFreePool(capPage);
        }
    } else {
        inquiryLength = 0;
    }

    //
    // Add tape device number to registry
    //

    ClassUpdateInformationInRegistry(Fdo,
                                     "Tape",
                                     fdoExtension->DeviceNumber,
                                     inquiryData,
                                     inquiryLength);

    ExFreePool(inquiryData);

    status = IoSetDeviceInterfaceState(&(tapeData->TapeInterfaceString),
                                       TRUE);

    if(!NT_SUCCESS(status)) {

        DebugPrint((1,
                    "TapeStartDevice: Unable to register Tape%x interface name - %x.\n",
                    fdoExtension->DeviceNumber,
                    status));
    }

    return STATUS_SUCCESS;
}


NTSTATUS
TapeInitDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the tape miniclass initialization.  This includes
    allocating sense info buffers and srb s-lists.

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PVOID                   senseData = NULL;
    PTAPE_DATA              tapeData;
    PTAPE_INIT_DATA_EX      tapeInitData;
    NTSTATUS                status;
    PVOID                   minitapeExtension;
    STORAGE_PROPERTY_ID     propertyId;
    UNICODE_STRING          interfaceName;

    PAGED_CODE();

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePool(NonPagedPoolCacheAligned,
                               SENSE_BUFFER_SIZE);

    if (senseData == NULL) {


        //
        // The buffer cannot be allocated.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Build the lookaside list for srb's for the physical disk. Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension),
                                    TAPE_SRB_LIST_SIZE);

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    fdoExtension->DiskGeometry.BytesPerSector = UNDEFINED_BLOCK_SIZE;

    //
    // Get the tape init data again.
    //

    tapeData = (PTAPE_DATA)(fdoExtension->CommonExtension.DriverData);
    tapeInitData = &tapeData->TapeInitData;

    //
    // Set timeout value in seconds.
    //

    if (tapeInitData->DefaultTimeOutValue) {
        fdoExtension->TimeOutValue = tapeInitData->DefaultTimeOutValue;
    } else {
        fdoExtension->TimeOutValue = 180;
    }

    //
    // Used to keep track of the last time a drive clean
    // notification was sent by the driver
    //
    tapeData->LastDriveCleanRequestTime.QuadPart = 0;

    //
    // SRB Timeout delta is used to increase the timeout for certain
    // commands - typically, commands such as SET_POSITION, ERASE, etc.
    //
    tapeData->SrbTimeoutDelta = GetTimeoutDeltaFromRegistry(fdoExtension->LowerPdo);
    if ((tapeData->SrbTimeoutDelta) == 0) {
        tapeData->SrbTimeoutDelta = fdoExtension->TimeOutValue;
    }

    //
    // Call port driver to get adapter capabilities.
    //

    propertyId = StorageAdapterProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->AdapterDescriptor));

    if(!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "TapeStartDevice: Unable to get adapter descriptor. Status %x\n",
                    status));
        ExFreePool(senseData);
        return status;
    }

    //
    // Register for media change notification
    //
    ClassInitializeMediaChangeDetection(fdoExtension, 
                                        "Tape");

    //
    // Register interfaces for this device.
    //

    RtlInitUnicodeString(&tapeData->TapeInterfaceString, NULL);

    status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                       (LPGUID) &TapeClassGuid,
                                       NULL,
                                       &(tapeData->TapeInterfaceString));

    if(!NT_SUCCESS(status)) {

        DebugPrint((1,
                    "TapeInitDevice: Unable to register Tape%x interface name - %x.\n",
                    fdoExtension->DeviceNumber,
                    status));
        status = STATUS_SUCCESS;
    }

    return STATUS_SUCCESS;


} // End TapeStartDevice


NTSTATUS
TapeRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    tape driver.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PTAPE_DATA                   tapeData = (PTAPE_DATA)fdoExtension->CommonExtension.DriverData;
    WCHAR                        dosNameBuffer[64];
    UNICODE_STRING               dosUnicodeString;
    NTSTATUS                     status;

    PAGED_CODE();

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }

    //
    // Free all allocated memory.
    //

    if (fdoExtension->DeviceDescriptor) {
        ExFreePool(fdoExtension->DeviceDescriptor);
        fdoExtension->DeviceDescriptor = NULL;
    }
    if (fdoExtension->AdapterDescriptor) {
        ExFreePool(fdoExtension->AdapterDescriptor);
        fdoExtension->AdapterDescriptor = NULL;
    }
    if (fdoExtension->SenseData) {
        ExFreePool(fdoExtension->SenseData);
        fdoExtension->SenseData = NULL;
    }

    //
    // Remove the lookaside list.
    //

    ClassDeleteSrbLookasideList(&fdoExtension->CommonExtension);

    if(tapeData->TapeInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(&(tapeData->TapeInterfaceString),
                                  FALSE);

        RtlFreeUnicodeString(&(tapeData->TapeInterfaceString));

        //
        // Clear it.
        //

        RtlInitUnicodeString(&(tapeData->TapeInterfaceString), NULL);
    }

    if(tapeData->DosNameCreated) {
        //
        // Delete the symbolic link "tapeN".
        //

        swprintf(dosNameBuffer,
                 L"\\DosDevices\\TAPE%d",
                 fdoExtension->DeviceNumber);

        RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);

        IoDeleteSymbolicLink(&dosUnicodeString);

        tapeData->DosNameCreated = FALSE;
    }

    IoGetConfigurationInformation()->TapeCount--;

    return STATUS_SUCCESS;
}


NTSTATUS
TapeStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    PAGED_CODE();
    return STATUS_SUCCESS;
}


BOOLEAN
ScsiTapeNtStatusToTapeStatus(
    IN  NTSTATUS        NtStatus,
    OUT PTAPE_STATUS    TapeStatus
    )

/*++

Routine Description:

    This routine translates an NT status code to a TAPE status code.

Arguments:

    NtStatus    - Supplies the NT status code.

    TapeStatus  - Returns the tape status code.

Return Value:

    FALSE   - No tranlation was possible.

    TRUE    - Success.

--*/

{
    switch (NtStatus) {

        case STATUS_SUCCESS:
            *TapeStatus = TAPE_STATUS_SUCCESS;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
            *TapeStatus = TAPE_STATUS_INSUFFICIENT_RESOURCES;
            break;

        case STATUS_NOT_IMPLEMENTED:
            *TapeStatus = TAPE_STATUS_NOT_IMPLEMENTED;
            break;

        case STATUS_INVALID_DEVICE_REQUEST:
            *TapeStatus = TAPE_STATUS_INVALID_DEVICE_REQUEST;
            break;

        case STATUS_INVALID_PARAMETER:
            *TapeStatus = TAPE_STATUS_INVALID_PARAMETER;
            break;

        case STATUS_VERIFY_REQUIRED:
        case STATUS_MEDIA_CHANGED:
            *TapeStatus = TAPE_STATUS_MEDIA_CHANGED;
            break;

        case STATUS_BUS_RESET:
            *TapeStatus = TAPE_STATUS_BUS_RESET;
            break;

        case STATUS_SETMARK_DETECTED:
            *TapeStatus = TAPE_STATUS_SETMARK_DETECTED;
            break;

        case STATUS_FILEMARK_DETECTED:
            *TapeStatus = TAPE_STATUS_FILEMARK_DETECTED;
            break;

        case STATUS_BEGINNING_OF_MEDIA:
            *TapeStatus = TAPE_STATUS_BEGINNING_OF_MEDIA;
            break;

        case STATUS_END_OF_MEDIA:
            *TapeStatus = TAPE_STATUS_END_OF_MEDIA;
            break;

        case STATUS_BUFFER_OVERFLOW:
            *TapeStatus = TAPE_STATUS_BUFFER_OVERFLOW;
            break;

        case STATUS_NO_DATA_DETECTED:
            *TapeStatus = TAPE_STATUS_NO_DATA_DETECTED;
            break;

        case STATUS_EOM_OVERFLOW:
            *TapeStatus = TAPE_STATUS_EOM_OVERFLOW;
            break;

        case STATUS_NO_MEDIA:
        case STATUS_NO_MEDIA_IN_DEVICE:
            *TapeStatus = TAPE_STATUS_NO_MEDIA;
            break;

        case STATUS_IO_DEVICE_ERROR:
        case STATUS_NONEXISTENT_SECTOR:
            *TapeStatus = TAPE_STATUS_IO_DEVICE_ERROR;
            break;

        case STATUS_UNRECOGNIZED_MEDIA:
            *TapeStatus = TAPE_STATUS_UNRECOGNIZED_MEDIA;
            break;

        case STATUS_DEVICE_NOT_READY:
            *TapeStatus = TAPE_STATUS_DEVICE_NOT_READY;
            break;

        case STATUS_MEDIA_WRITE_PROTECTED:
            *TapeStatus = TAPE_STATUS_MEDIA_WRITE_PROTECTED;
            break;

        case STATUS_DEVICE_DATA_ERROR:
            *TapeStatus = TAPE_STATUS_DEVICE_DATA_ERROR;
            break;

        case STATUS_NO_SUCH_DEVICE:
            *TapeStatus = TAPE_STATUS_NO_SUCH_DEVICE;
            break;

        case STATUS_INVALID_BLOCK_LENGTH:
            *TapeStatus = TAPE_STATUS_INVALID_BLOCK_LENGTH;
            break;

        case STATUS_IO_TIMEOUT:
            *TapeStatus = TAPE_STATUS_IO_TIMEOUT;
            break;

        case STATUS_DEVICE_NOT_CONNECTED:
            *TapeStatus = TAPE_STATUS_DEVICE_NOT_CONNECTED;
            break;

        case STATUS_DATA_OVERRUN:
            *TapeStatus = TAPE_STATUS_DATA_OVERRUN;
            break;

        case STATUS_DEVICE_BUSY:
            *TapeStatus = TAPE_STATUS_DEVICE_BUSY;
            break;

        case STATUS_CLEANER_CARTRIDGE_INSTALLED:
            *TapeStatus = TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED;
            break;

        default:
            return FALSE;

    }

    return TRUE;
}


BOOLEAN
ScsiTapeTapeStatusToNtStatus(
    IN  TAPE_STATUS TapeStatus,
    OUT PNTSTATUS   NtStatus
    )

/*++

Routine Description:

    This routine translates a TAPE status code to an NT status code.

Arguments:

    TapeStatus  - Supplies the tape status code.

    NtStatus    - Returns the NT status code.


Return Value:

    FALSE   - No tranlation was possible.

    TRUE    - Success.

--*/

{
    switch (TapeStatus) {

        case TAPE_STATUS_SUCCESS:
            *NtStatus = STATUS_SUCCESS;
            break;

        case TAPE_STATUS_INSUFFICIENT_RESOURCES:
            *NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;

        case TAPE_STATUS_NOT_IMPLEMENTED:
            *NtStatus = STATUS_NOT_IMPLEMENTED;
            break;

        case TAPE_STATUS_INVALID_DEVICE_REQUEST:
            *NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case TAPE_STATUS_INVALID_PARAMETER:
            *NtStatus = STATUS_INVALID_PARAMETER;
            break;

        case TAPE_STATUS_MEDIA_CHANGED:
            *NtStatus = STATUS_VERIFY_REQUIRED;
            break;

        case TAPE_STATUS_BUS_RESET:
            *NtStatus = STATUS_BUS_RESET;
            break;

        case TAPE_STATUS_SETMARK_DETECTED:
            *NtStatus = STATUS_SETMARK_DETECTED;
            break;

        case TAPE_STATUS_FILEMARK_DETECTED:
            *NtStatus = STATUS_FILEMARK_DETECTED;
            break;

        case TAPE_STATUS_BEGINNING_OF_MEDIA:
            *NtStatus = STATUS_BEGINNING_OF_MEDIA;
            break;

        case TAPE_STATUS_END_OF_MEDIA:
            *NtStatus = STATUS_END_OF_MEDIA;
            break;

        case TAPE_STATUS_BUFFER_OVERFLOW:
            *NtStatus = STATUS_BUFFER_OVERFLOW;
            break;

        case TAPE_STATUS_NO_DATA_DETECTED:
            *NtStatus = STATUS_NO_DATA_DETECTED;
            break;

        case TAPE_STATUS_EOM_OVERFLOW:
            *NtStatus = STATUS_EOM_OVERFLOW;
            break;

        case TAPE_STATUS_NO_MEDIA:
            *NtStatus = STATUS_NO_MEDIA;
            break;

        case TAPE_STATUS_IO_DEVICE_ERROR:
            *NtStatus = STATUS_IO_DEVICE_ERROR;
            break;

        case TAPE_STATUS_UNRECOGNIZED_MEDIA:
            *NtStatus = STATUS_UNRECOGNIZED_MEDIA;
            break;

        case TAPE_STATUS_DEVICE_NOT_READY:
            *NtStatus = STATUS_DEVICE_NOT_READY;
            break;

        case TAPE_STATUS_MEDIA_WRITE_PROTECTED:
            *NtStatus = STATUS_MEDIA_WRITE_PROTECTED;
            break;

        case TAPE_STATUS_DEVICE_DATA_ERROR:
            *NtStatus = STATUS_DEVICE_DATA_ERROR;
            break;

        case TAPE_STATUS_NO_SUCH_DEVICE:
            *NtStatus = STATUS_NO_SUCH_DEVICE;
            break;

        case TAPE_STATUS_INVALID_BLOCK_LENGTH:
            *NtStatus = STATUS_INVALID_BLOCK_LENGTH;
            break;

        case TAPE_STATUS_IO_TIMEOUT:
            *NtStatus = STATUS_IO_TIMEOUT;
            break;

        case TAPE_STATUS_DEVICE_NOT_CONNECTED:
            *NtStatus = STATUS_DEVICE_NOT_CONNECTED;
            break;

        case TAPE_STATUS_DATA_OVERRUN:
            *NtStatus = STATUS_DATA_OVERRUN;
            break;

        case TAPE_STATUS_DEVICE_BUSY:
            *NtStatus = STATUS_DEVICE_BUSY;
            break;

        case TAPE_STATUS_REQUIRES_CLEANING:
            *NtStatus = STATUS_DEVICE_REQUIRES_CLEANING;
            break;

        case TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED:
            *NtStatus = STATUS_CLEANER_CARTRIDGE_INSTALLED;
            break;

        default:
            return FALSE;

    }

    return TRUE;
}


VOID
TapeError(
    IN      PDEVICE_OBJECT      FDO,
    IN      PSCSI_REQUEST_BLOCK Srb,
    IN OUT  PNTSTATUS           Status,
    IN OUT  PBOOLEAN            Retry
    )

/*++

Routine Description:

    When a request completes with error, the routine ScsiClassInterpretSenseInfo is
    called to determine from the sense data whether the request should be
    retried and what NT status to set in the IRP. Then this routine is called
    for tape requests to handle tape-specific errors and update the nt status
    and retry boolean.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - NT Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = FDO->DeviceExtension;
    PTAPE_DATA tapeData = (PTAPE_DATA)(fdoExtension->CommonExtension.DriverData);
    PTAPE_INIT_DATA_EX tapeInitData = &tapeData->TapeInitData;
    PVOID minitapeExtension = (tapeData + 1);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;
    LONG residualBlocks;
    LONG length;
    TAPE_STATUS tapeStatus, oldTapeStatus;
    TARGET_DEVICE_CUSTOM_NOTIFICATION  NotificationStructure[2];

    //
    // Never retry tape requests.
    //

    *Retry = FALSE;

    //
    // Check that request sense buffer is valid.
    //

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        DebugPrint((1, 
                    "Sense Code : %x, Ad Sense : %x, Ad Sense Qual : %x\n",
                    ((senseBuffer->SenseKey) & 0xf),
                    (senseBuffer->AdditionalSenseCode),
                    (senseBuffer->AdditionalSenseCodeQualifier)));

        switch (senseBuffer->SenseKey & 0xf) {

            case SCSI_SENSE_UNIT_ATTENTION:

                switch (senseBuffer->AdditionalSenseCode) {

                    case SCSI_ADSENSE_MEDIUM_CHANGED:
                        DebugPrint((1,
                                    "InterpretSenseInfo: Media changed\n"));

                        *Status = STATUS_MEDIA_CHANGED;

                        break;

                    default:
                        DebugPrint((1,
                                    "InterpretSenseInfo: Bus reset\n"));

                        *Status = STATUS_BUS_RESET;

                        break;

                }

                break;

            case SCSI_SENSE_RECOVERED_ERROR:

                //
                // Check other indicators
                //

                if (senseBuffer->FileMark) {

                    switch (senseBuffer->AdditionalSenseCodeQualifier) {

                        case SCSI_SENSEQ_SETMARK_DETECTED :

                            DebugPrint((1,
                                        "InterpretSenseInfo: Setmark detected\n"));

                            *Status = STATUS_SETMARK_DETECTED;
                            break ;

                        case SCSI_SENSEQ_FILEMARK_DETECTED :
                        default:

                            DebugPrint((1,
                                        "InterpretSenseInfo: Filemark detected\n"));

                            *Status = STATUS_FILEMARK_DETECTED;
                            break ;

                    }

                } else if ( senseBuffer->EndOfMedia ) {

                    switch( senseBuffer->AdditionalSenseCodeQualifier ) {

                        case SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED :

                            DebugPrint((1,
                                        "InterpretSenseInfo: Beginning of media detected\n"));

                            *Status = STATUS_BEGINNING_OF_MEDIA;
                            break ;

                        case SCSI_SENSEQ_END_OF_MEDIA_DETECTED :
                        default:

                            DebugPrint((1,
                                        "InterpretSenseInfo: End of media detected\n"));

                            *Status = STATUS_END_OF_MEDIA;
                            break ;

                    }
                }

                break;

            case SCSI_SENSE_NO_SENSE:

                //
                // Check other indicators
                //

                if (senseBuffer->FileMark) {

                    switch( senseBuffer->AdditionalSenseCodeQualifier ) {

                        case SCSI_SENSEQ_SETMARK_DETECTED :

                            DebugPrint((1,
                                        "InterpretSenseInfo: Setmark detected\n"));

                            *Status = STATUS_SETMARK_DETECTED;
                            break ;

                        case SCSI_SENSEQ_FILEMARK_DETECTED :
                        default:

                            DebugPrint((1,
                                        "InterpretSenseInfo: Filemark detected\n"));

                            *Status = STATUS_FILEMARK_DETECTED;
                            break ;
                    }

                } else if (senseBuffer->EndOfMedia) {

                    switch(senseBuffer->AdditionalSenseCodeQualifier) {

                        case SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED :

                            DebugPrint((1,
                                        "InterpretSenseInfo: Beginning of media detected\n"));

                            *Status = STATUS_BEGINNING_OF_MEDIA;
                            break ;

                        case SCSI_SENSEQ_END_OF_MEDIA_DETECTED :
                        default:

                            DebugPrint((1,
                                        "InterpretSenseInfo: End of media detected\n"));

                            *Status = STATUS_END_OF_MEDIA;
                            break;

                    }
                } else if (senseBuffer->IncorrectLength) {

                    //
                    // If we're in variable block mode then ignore
                    // incorrect length.
                    //

                    if (fdoExtension->DiskGeometry.BytesPerSector == 0 &&
                        Srb->Cdb[0] == SCSIOP_READ6) {

                        REVERSE_BYTES((FOUR_BYTE UNALIGNED *)&residualBlocks,
                                      (FOUR_BYTE UNALIGNED *)(senseBuffer->Information));

                        if (residualBlocks >= 0) {
                            DebugPrint((1,"InterpretSenseInfo: In variable block mode :We read less than specified\n"));
                            *Status = STATUS_SUCCESS;
                        } else {
                            DebugPrint((1,"InterpretSenseInfo: In variable block mode :Data left in block\n"));
                            *Status = STATUS_BUFFER_OVERFLOW;
                        }
                    }
                }
                break;

            case SCSI_SENSE_BLANK_CHECK:

                DebugPrint((1,
                            "InterpretSenseInfo: Media blank check\n"));

                *Status = STATUS_NO_DATA_DETECTED;


                break;

            case SCSI_SENSE_VOL_OVERFLOW:

                DebugPrint((1,
                    "InterpretSenseInfo: End of Media Overflow\n"));

                *Status = STATUS_EOM_OVERFLOW;


                break;

            case SCSI_SENSE_NOT_READY:

                switch (senseBuffer->AdditionalSenseCode) {

                case SCSI_ADSENSE_LUN_NOT_READY:

                    switch (senseBuffer->AdditionalSenseCodeQualifier) {

                    case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED:

                        *Status = STATUS_NO_MEDIA;
                        break;

                    case SCSI_SENSEQ_FORMAT_IN_PROGRESS:
                        break;

                    case SCSI_SENSEQ_INIT_COMMAND_REQUIRED:
                    default:

                        //
                        // Allow retries, if the drive isn't ready.
                        //

                        *Retry = TRUE;
                        break;

                    }

                    break;

                    case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE:

                        DebugPrint((1,
                                    "InterpretSenseInfo:"
                                    " No Media in device.\n"));
                        *Status = STATUS_NO_MEDIA;
                        break;
                }

                break;

        } // end switch

        //
        // Check if a filemark or setmark was encountered,
        // or an end-of-media or no-data condition exists.
        //

        if ((NT_WARNING(*Status) || NT_SUCCESS( *Status)) &&
            (Srb->Cdb[0] == SCSIOP_WRITE6 || Srb->Cdb[0] == SCSIOP_READ6)) {

            LONG actualLength;

            //
            // Not all bytes were transfered. Update information field with
            // number of bytes transfered from sense buffer.
            //

            if (senseBuffer->Valid) {
                REVERSE_BYTES((FOUR_BYTE UNALIGNED *)&residualBlocks,
                              (FOUR_BYTE UNALIGNED *)(senseBuffer->Information));
            } else {
                residualBlocks = 0;
            }

            length = ((PCDB) Srb->Cdb)->CDB6READWRITETAPE.TransferLenLSB;
            length |= ((PCDB) Srb->Cdb)->CDB6READWRITETAPE.TransferLen << 8;
            length |= ((PCDB) Srb->Cdb)->CDB6READWRITETAPE.TransferLenMSB << 16;

            actualLength = length;

            length -= residualBlocks;

            if (length < 0) {

                length = 0;
                *Status = STATUS_IO_DEVICE_ERROR;
            }


            if (fdoExtension->DiskGeometry.BytesPerSector) {
                actualLength *= fdoExtension->DiskGeometry.BytesPerSector;
                length *= fdoExtension->DiskGeometry.BytesPerSector;
            }

            if (length > actualLength) {
                length = actualLength;
            }

            irp->IoStatus.Information = length;

            DebugPrint((1,"ScsiTapeError:  Transfer Count: %lx\n", Srb->DataTransferLength));
            DebugPrint((1," Residual Blocks: %lx\n", residualBlocks));
            DebugPrint((1," Irp IoStatus Information = %lx\n", irp->IoStatus.Information));
        }

    } else {
        DebugPrint((1, "SRB Status : %x, SCSI Status : %x\n",
                    SRB_STATUS(Srb->SrbStatus),
                    (Srb->ScsiStatus)));
    }

    //
    // Call tape device specific error handler.
    //

    if (tapeInitData->TapeError &&
        ScsiTapeNtStatusToTapeStatus(*Status, &tapeStatus)) {

        oldTapeStatus = tapeStatus;
        tapeInitData->TapeError(minitapeExtension, Srb, &tapeStatus);
        if (tapeStatus != oldTapeStatus) {
            ScsiTapeTapeStatusToNtStatus(tapeStatus, Status);
        }
    }

    //
    // Notify the system that this tape drive requires cleaning
    //
    if ((*Status) == STATUS_DEVICE_REQUIRES_CLEANING) {
       LARGE_INTEGER currentTime;
       LARGE_INTEGER driveCleanInterval;

       KeQuerySystemTime(&currentTime);
       driveCleanInterval.QuadPart = ONE_SECOND;
       driveCleanInterval.QuadPart *= TAPE_DRIVE_CLEAN_NOTIFICATION_INTERVAL;
       if ((currentTime.QuadPart) >
           ((tapeData->LastDriveCleanRequestTime.QuadPart) +
            (driveCleanInterval.QuadPart))) {
           NotificationStructure[0].Event = GUID_IO_DRIVE_REQUIRES_CLEANING;
           NotificationStructure[0].Version = 1;
           NotificationStructure[0].Size = sizeof(TARGET_DEVICE_CUSTOM_NOTIFICATION) +
                                           sizeof(ULONG) - sizeof(UCHAR);
           NotificationStructure[0].FileObject = NULL;
           NotificationStructure[0].NameBufferOffset = -1;

           //
           // Increasing Index for this event
           //

           *((PULONG) (&(NotificationStructure[0].CustomDataBuffer[0]))) = 0;

           IoReportTargetDeviceChangeAsynchronous(fdoExtension->LowerPdo,
                                                  &NotificationStructure[0],
                                                  NULL,
                                                  NULL);
           tapeData->LastDriveCleanRequestTime.QuadPart = currentTime.QuadPart;
       }
    }

    return;

} // end ScsiTapeError()


NTSTATUS
TapeReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds up the given irp for a read or write request.

Arguments:

    DeviceObject - Supplies the device object.

    Irp - Supplies the I/O request packet.

Return Value:

    None.

--*/

{
    PCOMMON_DEVICE_EXTENSION     commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = commonExtension->PartitionZeroExtension;
    PSTORAGE_ADAPTER_DESCRIPTOR  adapterDescriptor = fdoExtension->CommonExtension.PartitionZeroExtension->AdapterDescriptor;
    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG               transferPages;
    ULONG               transferByteCount = currentIrpStack->Parameters.Read.Length;
    LARGE_INTEGER       startingOffset = currentIrpStack->Parameters.Read.ByteOffset;
    ULONG               maximumTransferLength = adapterDescriptor->MaximumTransferLength;
    ULONG               bytesPerSector = fdoExtension->DiskGeometry.BytesPerSector;

    PAGED_CODE();

    //
    // Since most tape devices don't support 10-byte read/write, the entire request must be dealt with here.
    // STATUS_PENDING will be returned to the classpnp driver, so that it does nothing.
    //

    //
    // Ensure that the request is for something valid - ie. not 0.
    //

    if (currentIrpStack->Parameters.Read.Length == 0) {

        //
        // Class code will handle this.
        //

        return STATUS_SUCCESS;
    }

    //
    // Check that blocksize has been established.
    //

    if (bytesPerSector == UNDEFINED_BLOCK_SIZE) {

        DebugPrint((1,
                    "TapeReadWriteVerification: Invalid block size - UNDEFINED\n"));

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        //
        // ClassPnp will handle completing the request.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if (bytesPerSector) {
        if (transferByteCount % bytesPerSector) {

            DebugPrint((1,
                       "TapeReadWriteVerification: Invalid block size\n"));

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            Irp->IoStatus.Information = 0;

            //
            // ClassPnp will handle completing the request.
            //

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Calculate number of pages in this transfer.
    //

    transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(Irp->MdlAddress),
                                                   currentIrpStack->Parameters.Read.Length);

    //
    // Check if request length is greater than the maximum number of
    // bytes that the hardware can transfer.
    //



    //
    // Calculate number of pages in this transfer.
    //

    if (currentIrpStack->Parameters.Read.Length > maximumTransferLength ||
        transferPages > adapterDescriptor->MaximumPhysicalPages) {

        DebugPrint((2,
                    "TapeReadWriteVerification: Request greater than maximum\n"));
        DebugPrint((2,
                    "TapeReadWriteVerification: Maximum is %lx\n",
                    maximumTransferLength));
        DebugPrint((2,
                    "TapeReadWriteVerification: Byte count is %lx\n",
                    currentIrpStack->Parameters.Read.Length));

        transferPages = adapterDescriptor->MaximumPhysicalPages - 1;

        if (maximumTransferLength > transferPages << PAGE_SHIFT ) {
            maximumTransferLength = transferPages << PAGE_SHIFT;
        }

        //
        // Check that maximum transfer size is not zero.
        //

        if (maximumTransferLength == 0) {
            maximumTransferLength = PAGE_SIZE;
        }

        //
        // Ensure that this is reasonable, according to the current block size.
        //

        if (bytesPerSector) {
            if (maximumTransferLength % bytesPerSector) {
                ULONG tmpLength;

                tmpLength = maximumTransferLength % bytesPerSector;
                maximumTransferLength = maximumTransferLength - tmpLength;
            }
        }

        //
        // Mark IRP with status pending.
        //

        IoMarkIrpPending(Irp);

        //
        // Request greater than port driver maximum.
        // Break up into smaller routines.
        //
        SplitTapeRequest(DeviceObject, Irp, maximumTransferLength);

        return STATUS_PENDING;
    }


    //
    // Build SRB and CDB for this IRP.
    //

    TapeReadWrite(DeviceObject, Irp);

    IoMarkIrpPending(Irp);

    IoCallDriver(commonExtension->LowerDeviceObject, Irp);

    return STATUS_PENDING;
}



VOID
SplitTapeRequest(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    )

/*++

Routine Description:

    Break request into smaller requests.
    Each new request will be the maximum transfer
    size that the port driver can handle or if it
    is the final request, it may be the residual
    size.

    The number of IRPs required to process this
    request is written in the current stack of
    the original IRP. Then as each new IRP completes
    the count in the original IRP is decremented.
    When the count goes to zero, the original IRP
    is completed.

Arguments:

    DeviceObject - Pointer to the device object
    Irp - Pointer to Irp

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION  nextIrpStack = IoGetNextIrpStackLocation(Irp);
    ULONG               irpCount;
    ULONG               transferByteCount = currentIrpStack->Parameters.Read.Length;
    PSCSI_REQUEST_BLOCK srb;
    LARGE_INTEGER       startingOffset = currentIrpStack->Parameters.Read.ByteOffset;
    ULONG               dataLength = MaximumBytes;
    PVOID               dataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);
    LONG                remainingIrps;
    BOOLEAN             completeOriginalIrp = FALSE;
    NTSTATUS            status;
    ULONG               i;

    PAGED_CODE();

    //
    // Caluculate number of requests to break this IRP into.
    //

    irpCount = (transferByteCount + MaximumBytes - 1) / MaximumBytes;

    DebugPrint((2,
                "SplitTapeRequest: Requires %d IRPs\n", irpCount));
    DebugPrint((2,
                "SplitTapeRequest: Original IRP %p\n", Irp));

    //
    // If all partial transfers complete successfully then
    // the status is already set up.
    // Failing partial transfer IRP will set status to
    // error and bytes transferred to 0 during IoCompletion.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    //CEP Irp->IoStatus.Information = transferByteCount;
    Irp->IoStatus.Information = 0;

    //
    // Save number of IRPs to complete count on current stack
    // of original IRP.
    //

    nextIrpStack->Parameters.Others.Argument1 = ULongToPtr( irpCount );

    for (i = 0; i < irpCount; i++) {

        PIRP newIrp;
        PIO_STACK_LOCATION newIrpStack;

        //
        // Allocate new IRP.
        //

        newIrp = IoAllocateIrp(Fdo->StackSize, FALSE);

        if (newIrp == NULL) {

            DebugPrint((1,
                       "SplitTapeRequest: Can't allocate Irp\n"));

            //
            // Decrement count of outstanding partial requests.
            //

            remainingIrps = InterlockedDecrement((PLONG)&nextIrpStack->Parameters.Others.Argument1);

            //
            // Check if any outstanding IRPs.
            //

            if (remainingIrps == 0) {
                completeOriginalIrp = TRUE;
            }

            //
            // Update original IRP with failing status.
            //

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;

            //
            // Keep going with this request as outstanding partials
            // may be in progress.
            //

            goto KeepGoing;
        }

        DebugPrint((2,
                    "SplitTapeRequest: New IRP %p\n", newIrp));

        //
        // Write MDL address to new IRP.
        // In the port driver the SRB data length
        // field is used as an offset into the MDL,
        // so the same MDL can be used for each partial
        // transfer. This saves having to build a new
        // MDL for each partial transfer.
        //

        newIrp->MdlAddress = Irp->MdlAddress;

        //
        // At this point there is no current stack.
        // IoSetNextIrpStackLocation will make the
        // first stack location the current stack
        // so that the SRB address can be written
        // there.
        //

        IoSetNextIrpStackLocation(newIrp);

        newIrpStack = IoGetCurrentIrpStackLocation(newIrp);

        newIrpStack->MajorFunction = currentIrpStack->MajorFunction;

        newIrpStack->Parameters.Read.Length = dataLength;
        newIrpStack->Parameters.Read.ByteOffset = startingOffset;

        newIrpStack->DeviceObject = Fdo;

        //
        // Build SRB and CDB.
        //

        TapeReadWrite(Fdo, newIrp);

        //
        // Adjust SRB for this partial transfer.
        //

        newIrpStack = IoGetNextIrpStackLocation(newIrp);

        srb = newIrpStack->Parameters.Others.Argument1;

        srb->DataBuffer = dataBuffer;

        //
        // Write original IRP address to new IRP.
        //

        newIrp->AssociatedIrp.MasterIrp = Irp;

        //
        // Set the completion routine to TapeIoCompleteAssociated.
        //

        IoSetCompletionRoutine(newIrp,
                               TapeIoCompleteAssociated,
                               srb,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Call port driver with new request.
        //

        status = IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, newIrp);

        if (!NT_SUCCESS(status)) {

            DebugPrint((1,
                       "SplitTapeRequest: IoCallDriver returned error\n"));

            //
            // Decrement count of outstanding partial requests.
            //

            remainingIrps = InterlockedDecrement((PLONG)&nextIrpStack->Parameters.Others.Argument1);

            //
            // Check if any outstanding IRPs.
            //

            if (remainingIrps == 0) {
                completeOriginalIrp = TRUE;
            }

            //
            // Update original IRP with failing status.
            //

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            //
            // Deallocate this partial IRP.
            //

            IoFreeIrp(newIrp);
        }

KeepGoing:

        //
        // Set up for next request.
        //

        dataBuffer = (PCHAR)dataBuffer + MaximumBytes;

        transferByteCount -= MaximumBytes;

        if (transferByteCount > MaximumBytes) {

            dataLength = MaximumBytes;

        } else {

            dataLength = transferByteCount;
        }

        //
        // Adjust disk byte offset.
        //

        startingOffset.QuadPart += MaximumBytes;
    }

    //
    // Check if original IRP should be completed.
    //

    if (completeOriginalIrp) {

        ClassReleaseRemoveLock(Fdo, Irp);
        ClassCompleteRequest(Fdo, Irp, 0);
    }

    return;

} // end SplitTapeRequest()



VOID
TapeReadWrite(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds up the given irp for a read or write request.

Arguments:

    DeviceObject - Supplies the device object.

    Irp - Supplies the I/O request packet.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PTAPE_DATA         tapeData = (PTAPE_DATA)(fdoExtension->CommonExtension.DriverData);
    PTAPE_INIT_DATA_EX tapeInitData = &tapeData->TapeInitData;
    PVOID minitapeExtension = (tapeData + 1);
    PIO_STACK_LOCATION       irpSp, nextSp;
    PSCSI_REQUEST_BLOCK      srb;
    PCDB                     cdb;
    ULONG                    transferBlocks;

    PAGED_CODE();

    //
    // Allocate an Srb.
    //

    srb = ExAllocateFromNPagedLookasideList(&(fdoExtension->CommonExtension.SrbLookasideList));

    srb->SrbFlags = 0;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->MajorFunction == IRP_MJ_READ) {
        srb->SrbFlags |= SRB_FLAGS_DATA_IN;
    } else {
        srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
    }

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbStatus = 0;
    srb->ScsiStatus = 0;
    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
    srb->SrbFlags |= fdoExtension->SrbFlags;
    srb->DataTransferLength = irpSp->Parameters.Read.Length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);
    srb->SenseInfoBuffer = fdoExtension->SenseData;
    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
    srb->NextSrb = NULL;
    srb->OriginalRequest = Irp;
    srb->SrbExtension = NULL;
    srb->QueueSortKey = 0;

    //
    // Indicate that 6-byte CDB's will be used.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;

    //
    // Fill in CDB fields.
    //

    cdb = (PCDB)srb->Cdb;

    //
    // Zero CDB in SRB.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    if (fdoExtension->DiskGeometry.BytesPerSector) {

        //
        // Since we are writing fixed block mode, normalize transfer count
        // to number of blocks.
        //

        transferBlocks = irpSp->Parameters.Read.Length / fdoExtension->DiskGeometry.BytesPerSector;

        //
        // Tell the device that we are in fixed block mode.
        //

        cdb->CDB6READWRITETAPE.VendorSpecific = 1;
    } else {

        //
        // Variable block mode transfer.
        //

        transferBlocks = irpSp->Parameters.Read.Length;
        cdb->CDB6READWRITETAPE.VendorSpecific = 0;
    }

    //
    // Set up transfer length
    //

    cdb->CDB6READWRITETAPE.TransferLenMSB = (UCHAR)((transferBlocks >> 16) & 0xff);
    cdb->CDB6READWRITETAPE.TransferLen    = (UCHAR)((transferBlocks >> 8) & 0xff);
    cdb->CDB6READWRITETAPE.TransferLenLSB = (UCHAR)(transferBlocks & 0xff);

    //
    // Set transfer direction.
    //

    if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

         DebugPrint((3,
                    "TapeReadWrite: Read Command\n"));

         cdb->CDB6READWRITETAPE.OperationCode = SCSIOP_READ6;

    } else {

         DebugPrint((3,
                     "TapeReadWrite: Write Command\n"));

         cdb->CDB6READWRITETAPE.OperationCode = SCSIOP_WRITE6;
    }

    nextSp = IoGetNextIrpStackLocation(Irp);

    nextSp->MajorFunction = IRP_MJ_SCSI;
    nextSp->Parameters.Scsi.Srb = srb;
    irpSp->Parameters.Others.Argument4 = (PVOID) MAXIMUM_RETRIES;

    IoSetCompletionRoutine(Irp,
                           ClassIoComplete,
                           srb,
                           TRUE,
                           TRUE,
                           FALSE);

    if (tapeInitData->PreProcessReadWrite) {

        //
        // If the routine exists, call it. The miniclass driver will
        // do whatever it needs to.
        //

        tapeInitData->PreProcessReadWrite(minitapeExtension,
                                          NULL,
                                          NULL,
                                          srb,
                                          0,
                                          0,
                                          NULL);
    }
}



NTSTATUS
TapeIoCompleteAssociated(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine executes when the port driver has completed a request.
    It looks at the SRB status in the completing SRB and if not success
    it checks for valid request sense buffer information. If valid, the
    info is used to update status with more precise message of type of
    error. This routine deallocates the SRB.  This routine is used for
    requests which were build by split request.  After it has processed
    the request it decrements the Irp count in the master Irp.  If the
    count goes to zero then the master Irp is completed.

Arguments:

    DeviceObject - Supplies the device object which represents the logical
        unit.

    Irp - Supplies the Irp which has completed.

    Context - Supplies a pointer to the SRB.

Return Value:

    NT status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = Context;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PTAPE_DATA tapeData = (PTAPE_DATA)(fdoExtension->CommonExtension.DriverData);
    LONG irpCount;
    PIRP originalIrp = Irp->AssociatedIrp.MasterIrp;
    NTSTATUS status;

    //
    // Check SRB status for success of completing request.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DebugPrint((2,
                    "TapeIoCompleteAssociated: IRP %p, SRB %p", Irp, srb));

        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(Fdo);
        }

        ClassInterpretSenseInfo(Fdo,
                                srb,
                                irpStack->MajorFunction,
                                irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL ?
                                                           irpStack->Parameters.DeviceIoControl.IoControlCode : 0,
                                MAXIMUM_RETRIES - ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4),
                                &status,
                                NULL);

        //
        // Return the highest error that occurs.  This way warning take precedence
        // over success and errors take precedence over warnings.
        //

        if ((ULONG) status > (ULONG) originalIrp->IoStatus.Status) {

            //
            // Ignore any requests which were flushed.
            //

            if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_REQUEST_FLUSHED) {

                originalIrp->IoStatus.Status = status;

            }

        }


    } // end if (SRB_STATUS(srb->SrbStatus) ...

    ExInterlockedAddUlong((PULONG)&originalIrp->IoStatus.Information,
                          (ULONG)Irp->IoStatus.Information,
                          &tapeData->SplitRequestSpinLock );

    //
    // Return SRB to the slist
    //

    ExFreeToNPagedLookasideList((&fdoExtension->CommonExtension.SrbLookasideList), srb);

    DebugPrint((2,
               "TapeIoCompleteAssociated: Partial xfer IRP %p\n", Irp));

    //
    // Get next stack location. This original request is unused
    // except to keep track of the completing partial IRPs so the
    // stack location is valid.
    //

    irpStack = IoGetNextIrpStackLocation(originalIrp);

    //
    //
    // If any of the asynchronous partial transfer IRPs fail with an error
    // with an error then the original IRP will return 0 bytes transfered.
    // This is an optimization for successful transfers.
    //

    if (NT_ERROR(originalIrp->IoStatus.Status)) {

        originalIrp->IoStatus.Information = 0;

        //
        // Set the hard error if necessary.
        //

        if (IoIsErrorUserInduced(originalIrp->IoStatus.Status)) {

            //
            // Store DeviceObject for filesystem.
            //

            IoSetHardErrorOrVerifyDevice(originalIrp, Fdo);

        }

    }

    //
    // Decrement and get the count of remaining IRPs.
    //

    irpCount = InterlockedDecrement((PLONG)&irpStack->Parameters.Others.Argument1);

    DebugPrint((2,
               "TapeIoCompleteAssociated: Partial IRPs left %d\n",
               irpCount));

    if (irpCount == 0) {

#if DBG
        irpStack = IoGetCurrentIrpStackLocation(originalIrp);

        if (originalIrp->IoStatus.Information != irpStack->Parameters.Read.Length) {
            DebugPrint((1,
                        "TapeIoCompleteAssociated: Short transfer.  Request length: %lx, Return length: %lx, Status: %lx\n",
                         irpStack->Parameters.Read.Length,
                         originalIrp->IoStatus.Information,
                         originalIrp->IoStatus.Status));
        }
#endif
        //
        // All partial IRPs have completed.
        //

        DebugPrint((2,
                   "TapeIoCompleteAssociated: All partial IRPs complete %p\n",
                   originalIrp));


        //
        // Release the lock and complete the original request.
        //

        ClassReleaseRemoveLock(Fdo, originalIrp);
        ClassCompleteRequest(Fdo,originalIrp, IO_DISK_INCREMENT);
    }

    //
    // Deallocate IRP and indicate the I/O system should not attempt any more
    // processing.
    //

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;

} // end TapeIoCompleteAssociated()


VOID
ScsiTapeFreeSrbBuffer(
    IN OUT  PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine frees an SRB buffer that was previously allocated with
    'TapeClassAllocateSrbBuffer'.

Arguments:

    Srb - Supplies the SCSI request block.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if (Srb->DataBuffer) {
        ExFreePool(Srb->DataBuffer);
        Srb->DataBuffer = NULL;
    }
    Srb->DataTransferLength = 0;
}

#define IOCTL_TAPE_OLD_SET_MEDIA_PARAMS CTL_CODE(IOCTL_TAPE_BASE, 0x0008, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)



NTSTATUS
TapeDeviceControl(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  )

/*++

Routine Description:

    This routine is the dispatcher for device control requests. It
    looks at the IOCTL code and calls the appropriate tape device
    routine.

Arguments:

    DeviceObject
    Irp - Request packet

Return Value:

--*/

{
    PIO_STACK_LOCATION              irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension = DeviceObject->DeviceExtension;
    PTAPE_DATA                      tapeData= (PTAPE_DATA) (fdoExtension->CommonExtension.DriverData);
    PTAPE_INIT_DATA_EX              tapeInitData = &tapeData->TapeInitData;
    PVOID                           minitapeExtension = tapeData + 1;
    NTSTATUS                        status = STATUS_SUCCESS;
    TAPE_PROCESS_COMMAND_ROUTINE    commandRoutine;
    ULONG                           i;
    PVOID                           commandExtension;
    SCSI_REQUEST_BLOCK              srb;
    BOOLEAN                         writeToDevice;
    TAPE_STATUS                     tStatus;
    TAPE_STATUS                     LastError ;
    ULONG                           retryFlags, numRetries;
    TAPE_WMI_OPERATIONS             WMIOperations;
    TAPE_DRIVE_PROBLEM_TYPE         DriveProblemType;
    PVOID                           commandParameters;
    ULONG                           ioControlCode;
    PWMI_TAPE_PROBLEM_WARNING       TapeDriveProblem = NULL;
    ULONG                           timeoutDelta = 0;
    ULONG                           dataTransferLength = 0;

    PAGED_CODE();

    DebugPrint((3,"ScsiTapeDeviceControl: Enter routine\n"));

    Irp->IoStatus.Information = 0;

    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    switch (ioControlCode) {

        case IOCTL_STORAGE_GET_MEDIA_TYPES_EX: {

            ULONG tmpSize;

            //
            // Validate version. Don't send this to a 4.0 miniclass driver.
            //

            if (tapeInitData->InitDataSize == sizeof(TAPE_INIT_DATA_EX)) {

                //
                // Validate buffer length.
                //

                tmpSize = (tapeInitData->MediaTypesSupported - 1) * sizeof(DEVICE_MEDIA_INFO);
                if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(GET_MEDIA_TYPES) + tmpSize) {
                    status = STATUS_INFO_LENGTH_MISMATCH;
                    break;
                }

                //
                // Validate that the buffer is large enough for all media types.
                //

                commandRoutine = tapeInitData->TapeGetMediaTypes;

            } else {
                status = STATUS_NOT_IMPLEMENTED;
            }
            break;

        }

        case IOCTL_TAPE_GET_DRIVE_PARAMS:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(TAPE_GET_DRIVE_PARAMETERS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->GetDriveParameters;
            Irp->IoStatus.Information = sizeof(TAPE_GET_DRIVE_PARAMETERS);
            break;

        case IOCTL_TAPE_SET_DRIVE_PARAMS:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(TAPE_SET_DRIVE_PARAMETERS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->SetDriveParameters;
            break;

        case IOCTL_TAPE_GET_MEDIA_PARAMS:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(TAPE_GET_MEDIA_PARAMETERS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->GetMediaParameters;
            Irp->IoStatus.Information = sizeof(TAPE_GET_MEDIA_PARAMETERS);
            break;

            //
            // OLD_SET_XXX is here for legacy apps (defined READ/WRITE)
            //

        case IOCTL_TAPE_OLD_SET_MEDIA_PARAMS:
        case IOCTL_TAPE_SET_MEDIA_PARAMS: {

            PTAPE_SET_MEDIA_PARAMETERS tapeSetMediaParams = Irp->AssociatedIrp.SystemBuffer;
            ULONG                      maxBytes1,maxBytes2,maxSize;
            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(TAPE_SET_MEDIA_PARAMETERS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            //
            // Ensure that Max. block size is less than the miniports
            // reported MaximumTransferLength.
            //

            maxBytes1 = PAGE_SIZE * (fdoExtension->AdapterDescriptor->MaximumPhysicalPages - 1);
            maxBytes2 = fdoExtension->AdapterDescriptor->MaximumTransferLength;
            maxSize = (maxBytes1 > maxBytes2) ? maxBytes2 : maxBytes1;

            if (tapeSetMediaParams->BlockSize > maxSize) {

                DebugPrint((1,
                            "ScsiTapeDeviceControl: Attempted to set blocksize greater than miniport capabilities\n"));
                DebugPrint((1,"BlockSize %x, Miniport Maximum %x\n",
                            tapeSetMediaParams->BlockSize,
                            maxSize));

                status = STATUS_INVALID_PARAMETER;
                break;

            }

            commandRoutine = tapeInitData->SetMediaParameters;
            break;
        }

        case IOCTL_TAPE_CREATE_PARTITION:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(TAPE_CREATE_PARTITION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->CreatePartition;
            timeoutDelta = tapeData->SrbTimeoutDelta;
            break;

        case IOCTL_TAPE_ERASE:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(TAPE_ERASE)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->Erase;
            timeoutDelta = tapeData->SrbTimeoutDelta;
            break;

        case IOCTL_TAPE_PREPARE:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(TAPE_PREPARE)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->Prepare;
            timeoutDelta = tapeData->SrbTimeoutDelta;
            break;

        case IOCTL_TAPE_WRITE_MARKS:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(TAPE_WRITE_MARKS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->WriteMarks;
            timeoutDelta = tapeData->SrbTimeoutDelta;
            break;

        case IOCTL_TAPE_GET_POSITION:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(TAPE_GET_POSITION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->GetPosition;
            Irp->IoStatus.Information = sizeof(TAPE_GET_POSITION);
            break;

        case IOCTL_TAPE_SET_POSITION:

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(TAPE_SET_POSITION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            commandRoutine = tapeInitData->SetPosition;
            timeoutDelta = tapeData->SrbTimeoutDelta;
            break;

        case IOCTL_TAPE_GET_STATUS:

            commandRoutine = tapeInitData->GetStatus;
            break;

        case IOCTL_STORAGE_PREDICT_FAILURE : {
            //
            // This IOCTL is for checking the tape drive
            // to see if the device is having any problem.
            //
            PSTORAGE_PREDICT_FAILURE checkFailure;
            
            checkFailure = (PSTORAGE_PREDICT_FAILURE)Irp->AssociatedIrp.SystemBuffer;
            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(STORAGE_PREDICT_FAILURE)) {

               status = STATUS_BUFFER_TOO_SMALL;
               break;
            }

            //
            // WMI routine to check for drive problems.
            //
            commandRoutine = tapeInitData->TapeWMIOperations;
            if (commandRoutine == NULL) {
               //
               // WMI not supported by minidriver.
               //
               status = STATUS_WMI_NOT_SUPPORTED;
               break;
            }

            TapeDriveProblem = ExAllocatePool(NonPagedPool,
                                              sizeof(WMI_TAPE_PROBLEM_WARNING));
            if (TapeDriveProblem == NULL) {
               status = STATUS_NO_MEMORY;
               break;
            }

            //
            // Call the WMI method to check for drive problem.
            //
            RtlZeroMemory(TapeDriveProblem, sizeof(WMI_TAPE_PROBLEM_WARNING));
            TapeDriveProblem->DriveProblemType = TapeDriveProblemNone;
            WMIOperations.Method = TAPE_CHECK_FOR_DRIVE_PROBLEM;
            WMIOperations.DataBufferSize = sizeof(WMI_TAPE_PROBLEM_WARNING);
            WMIOperations.DataBuffer = (PVOID)TapeDriveProblem;
            break;
        }

        default:

            //
            // Pass the request to the common device control routine.
            //

            return ClassDeviceControl(DeviceObject, Irp);

    } // end switch()


    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;

        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);
        return status;
    }

    if (tapeInitData->CommandExtensionSize) {
        commandExtension = ExAllocatePool(NonPagedPool,
                                        tapeInitData->CommandExtensionSize);
    } else {
        commandExtension = NULL;
    }
 
    if (ioControlCode == IOCTL_STORAGE_PREDICT_FAILURE) {
       commandParameters = (PVOID)&WMIOperations;
    } else {
       commandParameters = Irp->AssociatedIrp.SystemBuffer;
    }

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    LastError = TAPE_STATUS_SUCCESS ;

    for (i = 0; ; i++) {

        srb.TimeOutValue = fdoExtension->TimeOutValue;
        srb.SrbFlags = 0;

        retryFlags = 0;

        tStatus = commandRoutine(minitapeExtension, commandExtension,
                                 commandParameters, &srb, i, 
                                 LastError, &retryFlags);
        //
        // Add Srb Timeout delta to the current timeout value
        // set in the SRB. 
        //
        srb.TimeOutValue += timeoutDelta;

        LastError = TAPE_STATUS_SUCCESS ;

        numRetries = retryFlags&TAPE_RETRY_MASK;

        if (tStatus == TAPE_STATUS_CHECK_TEST_UNIT_READY) {
            PCDB cdb = (PCDB)srb.Cdb;

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(srb.Cdb, MAXIMUM_CDB_SIZE);
            srb.CdbLength = CDB6GENERIC_LENGTH;
            cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
            srb.DataTransferLength = 0 ;

            DebugPrint((3,"Test Unit Ready\n"));

        } else if (tStatus == TAPE_STATUS_CALLBACK) {
            LastError = TAPE_STATUS_CALLBACK ;
            continue;

        } else if (tStatus != TAPE_STATUS_SEND_SRB_AND_CALLBACK) {
            break;
        }

        if (srb.DataBuffer && !srb.DataTransferLength) {
            ScsiTapeFreeSrbBuffer(&srb);
        }

        if (srb.DataBuffer && (srb.SrbFlags&SRB_FLAGS_DATA_OUT)) {
            writeToDevice = TRUE;
        } else {
            writeToDevice = FALSE;
        }

        dataTransferLength = srb.DataTransferLength;
        for (;;) {

            status = ClassSendSrbSynchronous(DeviceObject, &srb,
                                             srb.DataBuffer,
                                             srb.DataTransferLength,
                                             writeToDevice);

            if (NT_SUCCESS(status) ||
                (status == STATUS_DATA_OVERRUN)) {

                if (status == STATUS_DATA_OVERRUN) {
                    if ((srb.DataTransferLength) <= dataTransferLength) {
                        DebugPrint((1, "DataUnderRun reported as overrun\n"));
                        status = STATUS_SUCCESS;
                        break;
                    }
                } else {
                    break;
                }
            }

            if ((status == STATUS_BUS_RESET) ||
                (status == STATUS_IO_TIMEOUT)) {
                //
                // Timeout value for the command probably wasn't sufficient.
                // Update timeout delta from the registry
                //
                tapeData->SrbTimeoutDelta = GetTimeoutDeltaFromRegistry(fdoExtension->LowerPdo);
                if ((tapeData->SrbTimeoutDelta) == 0) {
                    tapeData->SrbTimeoutDelta = fdoExtension->TimeOutValue;
                    timeoutDelta = tapeData->SrbTimeoutDelta;
                    srb.TimeOutValue += timeoutDelta; 
                }
            }

            if (numRetries == 0) {

                if (retryFlags&RETURN_ERRORS) {
                    ScsiTapeNtStatusToTapeStatus(status, &LastError) ;
                    break ;
                }

                if (retryFlags&IGNORE_ERRORS) {
                    break;
                }

                if (commandExtension) {
                    ExFreePool(commandExtension);
                }

                ScsiTapeFreeSrbBuffer(&srb);

                if (TapeDriveProblem) {
                   ExFreePool(TapeDriveProblem);
                }

                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = status;

                ClassReleaseRemoveLock(DeviceObject, Irp);
                ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
                return status;
            }

            numRetries--;
        }
    }

    ScsiTapeFreeSrbBuffer(&srb);

    if (commandExtension) {
        ExFreePool(commandExtension);
    }

    if (!ScsiTapeTapeStatusToNtStatus(tStatus, &status)) {
        status = STATUS_IO_DEVICE_ERROR;
    }

    if (NT_SUCCESS(status)) {

        PTAPE_GET_MEDIA_PARAMETERS tapeGetMediaParams;
        PTAPE_SET_MEDIA_PARAMETERS tapeSetMediaParams;
        PTAPE_GET_DRIVE_PARAMETERS tapeGetDriveParams;
        PGET_MEDIA_TYPES           tapeGetMediaTypes;
        ULONG                      maxBytes1,maxBytes2,maxSize;

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

            case IOCTL_STORAGE_GET_MEDIA_TYPES_EX:

                tapeGetMediaTypes = Irp->AssociatedIrp.SystemBuffer;

                //
                // Set information field based on the returned number of mediaTypes
                //

                Irp->IoStatus.Information = sizeof(GET_MEDIA_TYPES);
                Irp->IoStatus.Information += ((tapeGetMediaTypes->MediaInfoCount - 1) * sizeof(DEVICE_MEDIA_INFO));

                DebugPrint((1,"Tape: GET_MEDIA_TYPES - Information %x\n", Irp->IoStatus.Information));
                break;

            case IOCTL_TAPE_GET_MEDIA_PARAMS:
                tapeGetMediaParams = Irp->AssociatedIrp.SystemBuffer;

                //
                // Check if block size has been initialized.
                //

                if (fdoExtension->DiskGeometry.BytesPerSector ==
                    UNDEFINED_BLOCK_SIZE) {

                    //
                    // Set the block size in the device object.
                    //

                    fdoExtension->DiskGeometry.BytesPerSector =
                        tapeGetMediaParams->BlockSize;
                }
                break;

            case IOCTL_TAPE_OLD_SET_MEDIA_PARAMS:
            case IOCTL_TAPE_SET_MEDIA_PARAMS:
                tapeSetMediaParams = Irp->AssociatedIrp.SystemBuffer;

                //
                // Set the block size in the device object.
                //

                fdoExtension->DiskGeometry.BytesPerSector =
                    tapeSetMediaParams->BlockSize;

                break;

            case IOCTL_TAPE_GET_DRIVE_PARAMS:
                tapeGetDriveParams = Irp->AssociatedIrp.SystemBuffer;

                //
                // Ensure that Max. block size is less than the miniports
                // reported MaximumTransferLength.
                //


                maxBytes1 = PAGE_SIZE * (fdoExtension->AdapterDescriptor->MaximumPhysicalPages - 1);
                maxBytes2 = fdoExtension->AdapterDescriptor->MaximumTransferLength;
                maxSize = (maxBytes1 > maxBytes2) ? maxBytes2 : maxBytes1;

                if (tapeGetDriveParams->MaximumBlockSize > maxSize) {
                    tapeGetDriveParams->MaximumBlockSize = maxSize;

                    DebugPrint((1,
                                "ScsiTapeDeviceControl: Resetting max. tape block size to %x\n",
                                tapeGetDriveParams->MaximumBlockSize));
                }

                //
                // Ensure that the default block size is less than or equal
                // to maximum block size.
                //
                if ((tapeGetDriveParams->DefaultBlockSize) > 
                    (tapeGetDriveParams->MaximumBlockSize)) {
                    tapeGetDriveParams->DefaultBlockSize = 
                        tapeGetDriveParams->MaximumBlockSize;
                }

                //
                // Ensure the blocksize we return are power of 2
                //

                UPDATE_BLOCK_SIZE(tapeGetDriveParams->DefaultBlockSize);

                UPDATE_BLOCK_SIZE(tapeGetDriveParams->MaximumBlockSize);

                UPDATE_BLOCK_SIZE(tapeGetDriveParams->MinimumBlockSize);

                break;

            case IOCTL_STORAGE_PREDICT_FAILURE: {
        
               PSTORAGE_PREDICT_FAILURE checkFailure;
               WMI_TAPE_PROBLEM_WARNING TapeProblemWarning;
               GUID TapeProblemWarningGuid = WMI_TAPE_PROBLEM_WARNING_GUID;

               checkFailure = (PSTORAGE_PREDICT_FAILURE)Irp->AssociatedIrp.SystemBuffer;

               //
               // We don't want classpnp to notify WMI if the drive is having
               // problems or not. We'll handle that here. So, set 
               // PredictFailure to 0. Then, classpnp will not process 
               // it further.
               //
               checkFailure->PredictFailure = 0;

               //
               // If the drive is reporting problem, we'll notify WMI
               //
               if (TapeDriveProblem->DriveProblemType != 
                   TapeDriveProblemNone) {
                  DebugPrint((1, 
                              "IOCTL_STORAGE_PREDICT_FAILURE : Tape drive %p",
                              " is experiencing problem %d\n",
                              DeviceObject, 
                              TapeDriveProblem->DriveProblemType));
                  ClassWmiFireEvent(DeviceObject, 
                                    &TapeProblemWarningGuid,
                                    0,
                                    sizeof(WMI_TAPE_PROBLEM_WARNING),
                                    (PUCHAR)TapeDriveProblem);
                  //
                  // ISSUE 02/28/2000 - nramas : We should decide whether 
                  // or not we need to log an event in addition to 
                  // firing a WMI event.
                  //
               }

               Irp->IoStatus.Information = sizeof(STORAGE_PREDICT_FAILURE);

               //
               // Free the buffer allocated for tape problem
               // warning data
               //
               ExFreePool(TapeDriveProblem);
               break;
            }

            case IOCTL_TAPE_ERASE: {

                //
                // Notify that the media has been successfully erased
                //
                TARGET_DEVICE_CUSTOM_NOTIFICATION  NotificationStructure[2];

                NotificationStructure[0].Event = GUID_IO_TAPE_ERASE;
                NotificationStructure[0].Version = 1;
                NotificationStructure[0].Size =  sizeof(TARGET_DEVICE_CUSTOM_NOTIFICATION) +
                                                 sizeof(ULONG) - sizeof(UCHAR);
                NotificationStructure[0].FileObject = NULL;
                NotificationStructure[0].NameBufferOffset = -1;

                //
                // Increasing Index for this event
                //

                *((PULONG) (&(NotificationStructure[0].CustomDataBuffer[0]))) = 0;

                IoReportTargetDeviceChangeAsynchronous(fdoExtension->LowerPdo,
                                                       &NotificationStructure[0],
                                                       NULL,
                                                       NULL);
                break;
            }
        }
    } else {
        Irp->IoStatus.Information = 0;
        if (TapeDriveProblem) {
           ExFreePool(TapeDriveProblem);
        }
    }

    Irp->IoStatus.Status = status;

    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject,Irp, 2);

    return status;
} // end ScsiScsiTapeDeviceControl()



BOOLEAN
TapeClassAllocateSrbBuffer(
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               SrbBufferSize
    )

/*++

Routine Description:

    This routine allocates a 'DataBuffer' for the given SRB of the given
    size.

Arguments:

    Srb             - Supplies the SCSI request block.

    SrbBufferSize   - Supplies the desired 'DataBuffer' size.

Return Value:

    FALSE   - The allocation failed.

    TRUE    - The allocation succeeded.

--*/

{
    PVOID   p;

    PAGED_CODE();

    if (Srb->DataBuffer) {
        ExFreePool(Srb->DataBuffer);
    }

    p = ExAllocatePool(NonPagedPoolCacheAligned, SrbBufferSize);
    if (!p) {
        Srb->DataBuffer = NULL;
        Srb->DataTransferLength = 0;
        return FALSE;
    }

    Srb->DataBuffer = p;
    Srb->DataTransferLength = SrbBufferSize;
    RtlZeroMemory(p, SrbBufferSize);

    return TRUE;
}


VOID
TapeClassZeroMemory(
    IN OUT  PVOID   Buffer,
    IN      ULONG   BufferSize
    )

/*++

Routine Description:

    This routine zeroes the given memory.

Arguments:

    Buffer          - Supplies the buffer.

    BufferSize      - Supplies the buffer size.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    RtlZeroMemory(Buffer, BufferSize);
}


ULONG
TapeClassCompareMemory(
    IN OUT  PVOID   Source1,
    IN OUT  PVOID   Source2,
    IN      ULONG   Length
    )

/*++

Routine Description:

    This routine compares the two memory buffers and returns the number
    of bytes that are equivalent.

Arguments:

    Source1         - Supplies the first memory buffer.

    Source2         - Supplies the second memory buffer.

    Length          - Supplies the number of bytes to be compared.

Return Value:

    The number of bytes that compared as equal.

--*/

{
    PAGED_CODE();

    return (ULONG)RtlCompareMemory(Source1, Source2, Length);
}


LARGE_INTEGER
TapeClassLiDiv(
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER Divisor
    )
{
    LARGE_INTEGER li;

    PAGED_CODE();

    li.QuadPart = Dividend.QuadPart / Divisor.QuadPart;
    return li;
}


ULONG
GetTimeoutDeltaFromRegistry(
    IN PDEVICE_OBJECT LowerPdo
    )
{
    ULONG srbTimeoutDelta = 0;
    HANDLE deviceKey;
    NTSTATUS status;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    OBJECT_ATTRIBUTES objectAttributes;

    PAGED_CODE();

#define SRB_TIMEOUT_DELTA (L"SrbTimeoutDelta")

    ASSERT(LowerPdo != NULL);
    
    //
    // Open a handle to the device node
    //
    status = IoOpenDeviceRegistryKey(LowerPdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_QUERY_VALUE,
                                     &deviceKey);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1, 
                    "IoOpenDeviceRegistryKey Failed in GetTimeoutDeltaFromRegistry : %x\n",
                    status));
        return 0;
    }

    RtlZeroMemory(&queryTable[0], sizeof(queryTable));

    queryTable[0].Name = SRB_TIMEOUT_DELTA;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].EntryContext = &srbTimeoutDelta;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = NULL;
    queryTable[0].DefaultLength = 0;

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR)deviceKey,
                                    queryTable,
                                    NULL,
                                    NULL);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1, 
                    "RtlQueryRegistryValue failed for SrbTimeoutDelta : %x\n",
                    status));
        srbTimeoutDelta = 0;
    }

    ZwClose(deviceKey);

    DebugPrint((3, "SrbTimeoutDelta read from registry %x\n",
                srbTimeoutDelta));
    return srbTimeoutDelta;
}

#if DBG

#define TAPE_DEBUG_PRINT_BUFF_LEN 128
ULONG TapeClassDebug = 0;
UCHAR TapeClassBuffer[TAPE_DEBUG_PRINT_BUFF_LEN];

VOID
TapeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
/*++

Routine Description:

    Debug print for all Tape minidrivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;
    va_start(ap, DebugMessage);
    
    if ((DebugPrintLevel <= (TapeClassDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & TapeClassDebug)) {

        _vsnprintf(TapeClassBuffer, TAPE_DEBUG_PRINT_BUFF_LEN, 
                   DebugMessage, ap);
        DbgPrintEx(DPFLTR_TAPE_ID, DPFLTR_INFO_LEVEL, TapeClassBuffer);
    }

    va_end(ap);

} // end TapeDebugPrint()

#else

//
// TapeDebugPrint stub
//

VOID
TapeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\class\tapewmi.c ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    tapewmi.c

Abstract:

    This is the tape class driver - WMI support routines.

Environment:

    kernel mode only

Revision History:

--*/

#include "tape.h"

//
// List guids supported by Tape driver
//
GUIDREGINFO TapeWmiGuidList[] =
{
   {
      WMI_TAPE_DRIVE_PARAMETERS_GUID,
      1,
      0
   },

   {
      WMI_TAPE_MEDIA_PARAMETERS_GUID,
      1,
      0
   },

   {
      WMI_TAPE_PROBLEM_WARNING_GUID,
      1,
      WMIREG_FLAG_EVENT_ONLY_GUID
   },

   {
      WMI_TAPE_PROBLEM_IO_ERROR_GUID,
      1,
      WMIREG_FLAG_EXPENSIVE
   },

   {
      WMI_TAPE_PROBLEM_DEVICE_ERROR_GUID,
      1,
      WMIREG_FLAG_EXPENSIVE
   },

   {
      WMI_TAPE_SYMBOLIC_NAME_GUID,
      1,
      0
   }
};

GUID TapeDriveProblemEventGuid = WMI_TAPE_PROBLEM_WARNING_GUID;

//
// GUID index. It should match the guid list
// defined above
//
#define TapeDriveParametersGuid            0
#define TapeMediaCapacityGuid              1
#define TapeDriveProblemWarningGuid        2
#define TapeDriveProblemIoErrorGuid        3
#define TapeDriveProblemDevErrorGuid       4
#define TapeSymbolicNameGuid               5


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, TapeWMIControl)
#pragma alloc_text(PAGE, TapeQueryWmiRegInfo)
#pragma alloc_text(PAGE, TapeQueryWmiDataBlock)
#pragma alloc_text(PAGE, TapeExecuteWmiMethod)
#pragma alloc_text(PAGE, TapeWmiFunctionControl)
#pragma alloc_text(PAGE, TapeSetWmiDataBlock)
#pragma alloc_text(PAGE, TapeSetWmiDataItem)
#pragma alloc_text(PAGE, TapeEnableDisableDrivePolling)

#endif


NTSTATUS
TapeQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.


Return Value:

    status

--*/
{

    PAGED_CODE();

   //
   // Use devnode for FDOs
   //
   *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
   return STATUS_SUCCESS;
}

NTSTATUS
TapeQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
   PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
   PTAPE_INIT_DATA_EX tapeInitData;
   PVPB Vpb;
   ULONG sizeNeeded;
   ULONG wmiMethod;
   TAPE_WMI_OPERATIONS  wmiWorkItem;
   TAPE_PROCESS_COMMAND_ROUTINE commandRoutine;
   
   PAGED_CODE();

   DebugPrint((3, 
               "TapeQueryWmiDataBlock : Device %p, Irp %p, GuidIndex %d",
               "  BufferAvail %lx Buffer %lx\n",   
               DeviceObject, Irp, GuidIndex, BufferAvail, Buffer));

   Vpb = ClassGetVpb(DeviceObject);
   if ((Vpb) && ((Vpb->Flags) & VPB_MOUNTED)) {

       //
       // Tape drive is in use. Return busy status
       //
       status = ClassWmiCompleteRequest(DeviceObject,
                                        Irp,
                                        STATUS_DEVICE_BUSY,
                                        0,
                                        IO_NO_INCREMENT);

       return status;
   } 

   tapeInitData = (PTAPE_INIT_DATA_EX) (fdoExtension->CommonExtension.DriverData);
   switch (GuidIndex) {
      case TapeDriveParametersGuid: {
         TAPE_GET_DRIVE_PARAMETERS dataBuffer;
         PWMI_TAPE_DRIVE_PARAMETERS outBuffer;

         sizeNeeded = sizeof(WMI_TAPE_DRIVE_PARAMETERS);
         if (BufferAvail < sizeNeeded) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }
  
         RtlZeroMemory(&dataBuffer, sizeof(TAPE_GET_DRIVE_PARAMETERS));
         commandRoutine = tapeInitData->GetDriveParameters;
         status = TapeWMIControl(DeviceObject, commandRoutine,
                                 (PUCHAR)&dataBuffer);

         if (NT_SUCCESS(status)) {
            outBuffer = (PWMI_TAPE_DRIVE_PARAMETERS)Buffer;
            outBuffer->MaximumBlockSize = dataBuffer.MaximumBlockSize;
            outBuffer->MinimumBlockSize = dataBuffer.MinimumBlockSize;
            outBuffer->DefaultBlockSize = dataBuffer.DefaultBlockSize;
            outBuffer->MaximumPartitionCount = dataBuffer.MaximumPartitionCount;
            if ((dataBuffer.FeaturesLow) & TAPE_DRIVE_COMPRESSION) {
               outBuffer->CompressionCapable = TRUE;
            } else {
               outBuffer->CompressionCapable = FALSE;
            }
            outBuffer->CompressionEnabled = dataBuffer.Compression;
            outBuffer->HardwareErrorCorrection = dataBuffer.ECC;
            outBuffer->ReportSetmarks = dataBuffer.ReportSetmarks;
         }

         break;
      }

      case TapeMediaCapacityGuid: {
         TAPE_GET_MEDIA_PARAMETERS dataBuffer;
         PWMI_TAPE_MEDIA_PARAMETERS outBuffer;

         sizeNeeded = sizeof(WMI_TAPE_MEDIA_PARAMETERS);
         if (BufferAvail < sizeNeeded) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         } 

         RtlZeroMemory(&dataBuffer, sizeof(TAPE_GET_MEDIA_PARAMETERS));
         commandRoutine = tapeInitData->GetMediaParameters;      
         status = TapeWMIControl(DeviceObject, commandRoutine,
                                 (PUCHAR)&dataBuffer);

         if (NT_SUCCESS(status)) {
            outBuffer = (PWMI_TAPE_MEDIA_PARAMETERS)Buffer;
            outBuffer->AvailableCapacity = dataBuffer.Remaining.QuadPart;
            outBuffer->MaximumCapacity = dataBuffer.Capacity.QuadPart;
            outBuffer->BlockSize = dataBuffer.BlockSize;
            outBuffer->PartitionCount = dataBuffer.PartitionCount;
            outBuffer->MediaWriteProtected = dataBuffer.WriteProtected;
         }

         break;
      }

      case TapeSymbolicNameGuid: {

          //
          // We need buffer large enough to put the string TapeN
          // where N is an integer. We'll take 32 wide chars
          //
          sizeNeeded = sizeof(WCHAR) * 32;
          if (BufferAvail < sizeNeeded) {
              status = STATUS_BUFFER_TOO_SMALL;
              break;
          }

          RtlZeroMemory(Buffer, sizeof(WCHAR) * 32);
          swprintf((PWCHAR)(Buffer + sizeof(USHORT)),  L"Tape%d", 
                   fdoExtension->DeviceNumber);
          *((PUSHORT)Buffer) = wcslen((PWCHAR)(Buffer + sizeof(USHORT))) * sizeof(WCHAR);

          status = STATUS_SUCCESS;
          break;
      }

      case TapeDriveProblemIoErrorGuid: {
         sizeNeeded = sizeof(WMI_TAPE_PROBLEM_WARNING);
         if (BufferAvail < sizeNeeded) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         commandRoutine = tapeInitData->TapeWMIOperations;
         wmiWorkItem.Method = TAPE_QUERY_IO_ERROR_DATA;
         wmiWorkItem.DataBufferSize = BufferAvail;
         wmiWorkItem.DataBuffer = Buffer;
         status = TapeWMIControl(DeviceObject, commandRoutine,
                                 (PUCHAR)&wmiWorkItem);
         break;
      }

      case TapeDriveProblemDevErrorGuid: {
         sizeNeeded = sizeof(WMI_TAPE_PROBLEM_WARNING);
         if (BufferAvail < sizeNeeded) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         commandRoutine = tapeInitData->TapeWMIOperations;
         wmiWorkItem.Method = TAPE_QUERY_DEVICE_ERROR_DATA;
         wmiWorkItem.DataBufferSize = BufferAvail;
         wmiWorkItem.DataBuffer = Buffer;
         status = TapeWMIControl(DeviceObject, commandRoutine,
                                 (PUCHAR)&wmiWorkItem);
         break;
      }

      default:{
         sizeNeeded = 0;
         status = STATUS_WMI_GUID_NOT_FOUND;
         break;
      }
   } // switch (GuidIndex)

   DebugPrint((3, "TapeQueryWmiData : Device %p, Irp %p, ",
                  "GuidIndex %d, status %x\n",
                  DeviceObject, Irp, GuidIndex, status));

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    sizeNeeded,
                                    IO_NO_INCREMENT);

   return status;
}

NTSTATUS
TapeExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
{
   NTSTATUS status = STATUS_SUCCESS;

   PAGED_CODE();

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);

   return status;
}

NTSTATUS
TapeWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

    This function can be used to enable\disable event generation. The event
    mentioned here is Tape Drive Problem Warning event. This event is disabled
    by default. If any application is interested in being notified of drive 
    problems, it can enable this event generation.
    
Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

   PAGED_CODE();

   //
   // We handle only enable\disable tape drive problem warning events,
   // query data blocks.
   //
   if ((Function == EventGeneration) &&
       (GuidIndex == TapeDriveProblemWarningGuid)) {
      DebugPrint((3, 
                  "TapeWmiFunctionControl : DeviceObject %p, Irp %p, ",
                  "GuidIndex %d. Event Generation %s\n",
                  DeviceObject, Irp, GuidIndex, 
                  Enable ? "Enabled" : "Disabled"));
      status = TapeEnableDisableDrivePolling(fdoExtension, 
                                             Enable,
                                             TAPE_DRIVE_POLLING_PERIOD);
   } else if (Function == DataBlockCollection) {
      DebugPrint((3,
                  "TapeWmiFunctionControl : Irp %p - %s DataBlockCollection",
                  " for Device %p.\n",
                  Irp, Enable ? "Enable " : "Disable ", DeviceObject));
      status = STATUS_SUCCESS;
   } else {
      DebugPrint((3,
                  "TapeWmiFunctionControl : Unknown function %d for ",
                  "Device %p, Irp %p\n",
                  Function, DeviceObject, Irp));

      status = STATUS_INVALID_DEVICE_REQUEST;
   }

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);
   return status;
}

NTSTATUS
TapeSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*+

Routine Description :

   This routine is called to set the contents of a datablock.
   When the driver is finished setting the buffer, it must call
   ClassWmiCompleteRequest to complete the irp. The driver can
   return STATUS_PENDING if the irp cannot be completed immediately.
   
Arguments :

   Device object of the device being referred.
   
   Irp is the WMI Irp
   
   GuidIndex is the index of the guid for which the data is being set
   
   BufferSize is the size of the data block
   
   Buffer is the pointer to the data block
   
Return valus :

   NTSTATUS returned by ClassWmiCompleteRequest
   STATUS_WMI_READ_ONLY if the datablock cannot be modified.
   STATUS_WMI_GUID_NOT_FOUND if an invalid guid index is passed
-*/
{
   NTSTATUS status = STATUS_WMI_READ_ONLY;
   
   PAGED_CODE();

   DebugPrint((3, 
               "TapeWmiSetBlock : Device %p, Irp %p, GuidIndex %d\n",
               DeviceObject, Irp, GuidIndex));

   
   if (GuidIndex > TapeDriveProblemDevErrorGuid) {
       status = STATUS_WMI_GUID_NOT_FOUND;
   }

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);

   DebugPrint((3, "TapeSetWmiDataBlock : Device %p, Irp %p returns %lx\n",
            DeviceObject, Irp, status));

   return status;
}

NTSTATUS
TapeSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

   NTSTATUS returned by ClassWmiCompleteRequest
   STATUS_WMI_READ_ONLY if the datablock cannot be modified.
   STATUS_WMI_GUID_NOT_FOUND if an invalid guid index is passed

-*/
{
    NTSTATUS status = STATUS_WMI_READ_ONLY;                                                         
                                                                               
    PAGED_CODE();

    DebugPrint((3, 
                "TapeSetWmiDataItem, Device %p, Irp %p, GuiIndex %d",
                "  BufferSize %#x Buffer %p\n",                               
                DeviceObject, Irp,                                                
                GuidIndex, DataItemId, 
                BufferSize, Buffer));                      
                                                                              
    if (GuidIndex >  TapeDriveProblemDevErrorGuid) {
        status = STATUS_WMI_GUID_NOT_FOUND;                                    
    }                                                                          
                                                                               
    status = ClassWmiCompleteRequest(DeviceObject,                             
                                     Irp,                                      
                                     status,                                   
                                     0,                                        
                                     IO_NO_INCREMENT); 

    DebugPrint((3, "TapeSetWmiDataItem Device %p, Irp %p returns %lx\n", 
             DeviceObject, Irp, status));                                      
                                                                               
    return status;                                                             
}

NTSTATUS
TapeEnableDisableDrivePolling(
    IN PFUNCTIONAL_DEVICE_EXTENSION fdoExtension, 
    IN BOOLEAN Enable,
    IN ULONG PollingTimeInSeconds
    )
/*++

Routine Description:

    Enable or disable polling to check for drive problems.

Arguments:

    FdoExtension  Device extension

    Enable        TRUE if polling is to be enabled. FALSE otherwise.

    PollTimeInSeconds - if 0 then no change to current polling timer

Return Value:

    NT Status

--*/

{
   NTSTATUS status;
   FAILURE_PREDICTION_METHOD failurePredictionMethod;

   PAGED_CODE();

   //
   // Failure prediction is done through IOCTL_STORAGE_PREDICT_FAILURE
   //
   if (Enable) {
      failurePredictionMethod = FailurePredictionIoctl;
   } else {
      failurePredictionMethod = FailurePredictionNone;
   }

   status = ClassSetFailurePredictionPoll(fdoExtension,
                                          failurePredictionMethod,
                                          PollingTimeInSeconds);
   return status;
}


NTSTATUS
TapeWMIControl(
  IN PDEVICE_OBJECT DeviceObject,
  IN TAPE_PROCESS_COMMAND_ROUTINE commandRoutine,
  OUT PUCHAR Buffer
  )

/*++

Routine Description:

   This is the class routine to handle WMI requests. It handles all query
   requests. 
   
Arguments:

  DeviceObject   The device object
  commandRoutine minidriver routine to call.
  Buffer         Pointer to the buffer
  
Return Value:

  NT Status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension = DeviceObject->DeviceExtension;
    PTAPE_DATA                      tapeData= (PTAPE_DATA) (fdoExtension->CommonExtension.DriverData);
    PTAPE_INIT_DATA_EX              tapeInitData = &tapeData->TapeInitData;
    PVOID                           minitapeExtension = tapeData + 1;
    NTSTATUS                        status = STATUS_SUCCESS;
    TAPE_STATUS                     lastError;
    TAPE_STATUS                     tapeStatus;
    ULONG                           callNumber;
    PVOID                           commandExtension;
    ULONG                           retryFlags;
    ULONG                           numRetries;
    SCSI_REQUEST_BLOCK              srb;
    BOOLEAN                         writeToDevice;

    PAGED_CODE();

    //
    // Verify if the minidriver supports WMI operations
    //
    if (commandRoutine == NULL) {
       DebugPrint((1, 
                   "TapeWMIControl : DeviceObject %d does not support WMI\n"));
       return STATUS_WMI_NOT_SUPPORTED;
    }

    if (tapeInitData->CommandExtensionSize) {
        commandExtension = ExAllocatePool(NonPagedPool,
                                          tapeInitData->CommandExtensionSize);
    } else {
        commandExtension = NULL;
    }

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    lastError = TAPE_STATUS_SUCCESS ;

    for (callNumber = 0; ;callNumber++) {

        srb.TimeOutValue = fdoExtension->TimeOutValue;
        srb.SrbFlags = 0;

        retryFlags = 0;

        tapeStatus = commandRoutine(minitapeExtension,
                                    commandExtension,
                                    Buffer,
                                    &srb,
                                    callNumber,
                                    lastError,
                                    &retryFlags);

        lastError = TAPE_STATUS_SUCCESS ;

        numRetries = retryFlags & TAPE_RETRY_MASK;

        if (tapeStatus == TAPE_STATUS_CHECK_TEST_UNIT_READY) {
            PCDB cdb = (PCDB)srb.Cdb;

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(srb.Cdb, MAXIMUM_CDB_SIZE);
            srb.CdbLength = CDB6GENERIC_LENGTH;
            cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
            srb.DataTransferLength = 0 ;

            DebugPrint((3,"Test Unit Ready\n"));

        } else if (tapeStatus == TAPE_STATUS_CALLBACK) {
            lastError = TAPE_STATUS_CALLBACK ;
            continue;

        } else if (tapeStatus != TAPE_STATUS_SEND_SRB_AND_CALLBACK) {
            break;
        }

        if (srb.DataBuffer && !srb.DataTransferLength) {
            ScsiTapeFreeSrbBuffer(&srb);
        }

        if (srb.DataBuffer && (srb.SrbFlags & SRB_FLAGS_DATA_OUT)) {
            writeToDevice = TRUE;
        } else {
            writeToDevice = FALSE;
        }

        for (;;) {

            status = ClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             srb.DataBuffer,
                                             srb.DataTransferLength,
                                             writeToDevice);

            if (NT_SUCCESS(status) ||
                (status == STATUS_DATA_OVERRUN)) {

                if (status == STATUS_DATA_OVERRUN) {
                    ULONG allocLen;
                    PCDB Cdb;

                    //
                    // ISSUE: 03/31/2000: nramas
                    // We use either LOG SENSE or REQUEST SENSE CDB
                    // in minidrivers. For LogSense, AllocationLength
                    // is 2 bytes. It is 10 byte CDB.
                    //
                    // Currently, if DataOverrun occurs on request sense, 
                    // we don't handle that.
                    //
                    if ((srb.CdbLength) == CDB10GENERIC_LENGTH) {
                        Cdb = (PCDB)(srb.Cdb);
                        allocLen = Cdb->LOGSENSE.AllocationLength[0];
                        allocLen <<= 8;
                        allocLen |= Cdb->LOGSENSE.AllocationLength[1];
                        DebugPrint((3, "DataXferLen %x, AllocLen %x\n",
                                    srb.DataTransferLength,
                                    allocLen));
                        if ((srb.DataTransferLength) <= allocLen) {
                            status = STATUS_SUCCESS;
                            break;
                        } else {
                            DebugPrint((1, 
                                        "DataOverrun in TapeWMI routine. Srb %p\n",
                                        &srb));
                        }
                    }
                } else {
                    break;
                }
            }

            if (numRetries == 0) {

                if (retryFlags & RETURN_ERRORS) {
                    ScsiTapeNtStatusToTapeStatus(status, &lastError) ;
                    break ;
                }

                if (retryFlags & IGNORE_ERRORS) {
                    break;
                }

                if (commandExtension) {
                    ExFreePool(commandExtension);
                }

                ScsiTapeFreeSrbBuffer(&srb);

                return status;
            }

            numRetries--;
        }
    }

    ScsiTapeFreeSrbBuffer(&srb);

    if (commandExtension) {
        ExFreePool(commandExtension);
    }

    if (!ScsiTapeTapeStatusToNtStatus(tapeStatus, &status)) {
        status = STATUS_IO_DEVICE_ERROR;
    }

    return status;

} // end TapeWMIControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\class\newtape.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    tape.h

Abstract:

    These are the structures and defines that are used in the
    SCSI tape class drivers. The tape class driver is separated
    into two modules. An export driver called SCSITAPE.SYS which
    provides a OS dependant wrapper for the OS independant and
    a tape drive specific minitape driver.  The interface between
    these two drivers is also defined in this file.

Revision History:

--*/

#include "scsi.h"

// begin_ntminitape

#if defined DebugPrint
   #undef DebugPrint
#endif

#if DBG

#define DebugPrint(x) TapeDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

//
// Define Device Configuration Page
//

typedef struct _MODE_DEVICE_CONFIGURATION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR ActiveFormat : 5;
    UCHAR CAFBit : 1;
    UCHAR CAPBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR ActivePartition;
    UCHAR WriteBufferFullRatio;
    UCHAR ReadBufferEmptyRatio;
    UCHAR WriteDelayTime[2];
    UCHAR REW : 1;
    UCHAR RBO : 1;
    UCHAR SOCF : 2;
    UCHAR AVC : 1;
    UCHAR RSmk : 1;
    UCHAR BIS : 1;
    UCHAR DBR : 1;
    UCHAR GapSize;
    UCHAR Reserved3 : 3;
    UCHAR SEW : 1;
    UCHAR EEG : 1;
    UCHAR EODdefined : 3;
    UCHAR BufferSize[3];
    UCHAR DCAlgorithm;
    UCHAR Reserved4;

} MODE_DEVICE_CONFIGURATION_PAGE, *PMODE_DEVICE_CONFIGURATION_PAGE;

//
// Define Medium Partition Page
//

typedef struct _MODE_MEDIUM_PARTITION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR MaximumAdditionalPartitions;
    UCHAR AdditionalPartitionDefined;
    UCHAR Reserved2 : 3;
    UCHAR PSUMBit : 2;
    UCHAR IDPBit : 1;
    UCHAR SDPBit : 1;
    UCHAR FDPBit : 1;
    UCHAR MediumFormatRecognition;
    UCHAR Reserved3[2];
    UCHAR Partition0Size[2];
    UCHAR Partition1Size[2];

} MODE_MEDIUM_PARTITION_PAGE, *PMODE_MEDIUM_PARTITION_PAGE;

//
// Define Data Compression Page
//

typedef struct _MODE_DATA_COMPRESSION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2 : 6;
    UCHAR DCC : 1;
    UCHAR DCE : 1;
    UCHAR Reserved3 : 5;
    UCHAR RED : 2;
    UCHAR DDE : 1;
    UCHAR CompressionAlgorithm[4];
    UCHAR DecompressionAlgorithm[4];
    UCHAR Reserved4[4];

} MODE_DATA_COMPRESSION_PAGE, *PMODE_DATA_COMPRESSION_PAGE;

//
// Define capabilites and mechanical status page.
//

typedef struct _MODE_CAPABILITIES_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2[2];
    UCHAR RO : 1;
    UCHAR Reserved3 : 4;
    UCHAR SPREV : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5 : 3;
    UCHAR EFMT : 1;
    UCHAR Reserved6 : 1;
    UCHAR QFA : 1;
    UCHAR Reserved7 : 2;
    UCHAR LOCK : 1;
    UCHAR LOCKED : 1;
    UCHAR PREVENT : 1;
    UCHAR UNLOAD : 1;
    UCHAR Reserved8 : 2;
    UCHAR ECC : 1;
    UCHAR CMPRS : 1;
    UCHAR Reserved9 : 1;
    UCHAR BLK512 : 1;
    UCHAR BLK1024 : 1;
    UCHAR Reserved10 : 4;
    UCHAR SLOWB : 1;
    UCHAR MaximumSpeedSupported[2];
    UCHAR MaximumStoredDefectedListEntries[2];
    UCHAR ContinuousTransferLimit[2];
    UCHAR CurrentSpeedSelected[2];
    UCHAR BufferSize[2];
    UCHAR Reserved11[2];

} MODE_CAPABILITIES_PAGE, *PMODE_CAPABILITIES_PAGE;

typedef struct _MODE_CAP_PAGE {

    MODE_PARAMETER_HEADER   ParameterListHeader;
    MODE_PARAMETER_BLOCK    ParameterListBlock;
    MODE_CAPABILITIES_PAGE  CapabilitiesPage;

} MODE_CAP_PAGE, *PMODE_CAP_PAGE;



//
// Mode parameter list header and medium partition page -
// used in creating partitions
//

typedef struct _MODE_MEDIUM_PART_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE, *PMODE_MEDIUM_PART_PAGE;

typedef struct _MODE_MEDIUM_PART_PAGE_PLUS {

    MODE_PARAMETER_HEADER       ParameterListHeader;
    MODE_PARAMETER_BLOCK        ParameterListBlock;
    MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE_PLUS, *PMODE_MEDIUM_PART_PAGE_PLUS;



//
// Mode parameters for retrieving tape or media information
//

typedef struct _MODE_TAPE_MEDIA_INFORMATION {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_TAPE_MEDIA_INFORMATION, *PMODE_TAPE_MEDIA_INFORMATION;

//
// Mode parameter list header and device configuration page -
// used in retrieving device configuration information
//

typedef struct _MODE_DEVICE_CONFIG_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE, *PMODE_DEVICE_CONFIG_PAGE;

typedef struct _MODE_DEVICE_CONFIG_PAGE_PLUS {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE_PLUS, *PMODE_DEVICE_CONFIG_PAGE_PLUS ;

//
// Mode parameter list header and data compression page -
// used in retrieving data compression information
//

typedef struct _MODE_DATA_COMPRESS_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE, *PMODE_DATA_COMPRESS_PAGE;

typedef struct _MODE_DATA_COMPRESS_PAGE_PLUS {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE_PLUS, *PMODE_DATA_COMPRESS_PAGE_PLUS;



//
// Tape/Minitape definition.
//

typedef
BOOLEAN
(*TAPE_VERIFY_INQUIRY_ROUTINE)(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

typedef
VOID
(*TAPE_EXTENSION_INIT_ROUTINE)(
    IN  PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

typedef enum _TAPE_STATUS {
    TAPE_STATUS_SEND_SRB_AND_CALLBACK,
    TAPE_STATUS_CALLBACK,
    TAPE_STATUS_CHECK_TEST_UNIT_READY,

    TAPE_STATUS_SUCCESS,
    TAPE_STATUS_INSUFFICIENT_RESOURCES,
    TAPE_STATUS_NOT_IMPLEMENTED,
    TAPE_STATUS_INVALID_DEVICE_REQUEST,
    TAPE_STATUS_INVALID_PARAMETER,

    TAPE_STATUS_MEDIA_CHANGED,
    TAPE_STATUS_BUS_RESET,
    TAPE_STATUS_SETMARK_DETECTED,
    TAPE_STATUS_FILEMARK_DETECTED,
    TAPE_STATUS_BEGINNING_OF_MEDIA,
    TAPE_STATUS_END_OF_MEDIA,
    TAPE_STATUS_BUFFER_OVERFLOW,
    TAPE_STATUS_NO_DATA_DETECTED,
    TAPE_STATUS_EOM_OVERFLOW,
    TAPE_STATUS_NO_MEDIA,
    TAPE_STATUS_IO_DEVICE_ERROR,
    TAPE_STATUS_UNRECOGNIZED_MEDIA,

    TAPE_STATUS_DEVICE_NOT_READY,
    TAPE_STATUS_MEDIA_WRITE_PROTECTED,
    TAPE_STATUS_DEVICE_DATA_ERROR,
    TAPE_STATUS_NO_SUCH_DEVICE,
    TAPE_STATUS_INVALID_BLOCK_LENGTH,
    TAPE_STATUS_IO_TIMEOUT,
    TAPE_STATUS_DEVICE_NOT_CONNECTED,
    TAPE_STATUS_DATA_OVERRUN,
    TAPE_STATUS_DEVICE_BUSY,
    TAPE_STATUS_REQUIRES_CLEANING,
    TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED

} TAPE_STATUS, *PTAPE_STATUS;

typedef
VOID
(*TAPE_ERROR_ROUTINE)(
    IN      PVOID               MinitapeExtension,
    IN      PSCSI_REQUEST_BLOCK Srb,
    IN OUT  PTAPE_STATUS        TapeStatus
    );

#define TAPE_RETRY_MASK 0x0000FFFF
#define IGNORE_ERRORS   0x00010000
#define RETURN_ERRORS   0x00020000

typedef
TAPE_STATUS
(*TAPE_PROCESS_COMMAND_ROUTINE)(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         StatusOfLastCommand,
    IN OUT  PULONG              RetryFlags
    );

//
// NT 4.0 miniclass drivers will be using this.
//

typedef struct _TAPE_INIT_DATA {
    TAPE_VERIFY_INQUIRY_ROUTINE     VerifyInquiry;
    BOOLEAN                         QueryModeCapabilitiesPage ;
    ULONG                           MinitapeExtensionSize;
    TAPE_EXTENSION_INIT_ROUTINE     ExtensionInit;          /* OPTIONAL */
    ULONG                           DefaultTimeOutValue;    /* OPTIONAL */
    TAPE_ERROR_ROUTINE              TapeError;              /* OPTIONAL */
    ULONG                           CommandExtensionSize;
    TAPE_PROCESS_COMMAND_ROUTINE    CreatePartition;
    TAPE_PROCESS_COMMAND_ROUTINE    Erase;
    TAPE_PROCESS_COMMAND_ROUTINE    GetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    GetStatus;
    TAPE_PROCESS_COMMAND_ROUTINE    Prepare;
    TAPE_PROCESS_COMMAND_ROUTINE    SetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    WriteMarks;
    TAPE_PROCESS_COMMAND_ROUTINE    PreProcessReadWrite;
} TAPE_INIT_DATA, *PTAPE_INIT_DATA;

typedef struct _TAPE_INIT_DATA_EX {

    //
    // Size of this structure.
    //

    ULONG InitDataSize;

    //
    // Keep the 4.0 init data as is, so support of these
    // drivers can be as seamless as possible.
    //

    TAPE_VERIFY_INQUIRY_ROUTINE     VerifyInquiry;
    BOOLEAN                         QueryModeCapabilitiesPage ;
    ULONG                           MinitapeExtensionSize;
    TAPE_EXTENSION_INIT_ROUTINE     ExtensionInit;          /* OPTIONAL */
    ULONG                           DefaultTimeOutValue;    /* OPTIONAL */
    TAPE_ERROR_ROUTINE              TapeError;              /* OPTIONAL */
    ULONG                           CommandExtensionSize;
    TAPE_PROCESS_COMMAND_ROUTINE    CreatePartition;
    TAPE_PROCESS_COMMAND_ROUTINE    Erase;
    TAPE_PROCESS_COMMAND_ROUTINE    GetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    GetStatus;
    TAPE_PROCESS_COMMAND_ROUTINE    Prepare;
    TAPE_PROCESS_COMMAND_ROUTINE    SetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    WriteMarks;
    TAPE_PROCESS_COMMAND_ROUTINE    PreProcessReadWrite;

    //
    // New entry points / information for 5.0
    //
    // Returns supported media types for the device.
    //

    TAPE_PROCESS_COMMAND_ROUTINE    TapeGetMediaTypes;

    //
    // Indicates the number of different types the drive supports.
    //

    ULONG                           MediaTypesSupported;

    //
    // Entry point for all WMI operations that the driver/device supports.
    //

    TAPE_PROCESS_COMMAND_ROUTINE    TapeWMIOperations;
    ULONG                           Reserved[2];
} TAPE_INIT_DATA_EX, *PTAPE_INIT_DATA_EX;

SCSIPORT_API
ULONG
TapeClassInitialize(
    IN  PVOID           Argument1,
    IN  PVOID           Argument2,
    IN  PTAPE_INIT_DATA_EX TapeInitData
    );

SCSIPORT_API
BOOLEAN
TapeClassAllocateSrbBuffer(
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               SrbBufferSize
    );

SCSIPORT_API
VOID
TapeClassZeroMemory(
    IN OUT  PVOID   Buffer,
    IN      ULONG   BufferSize
    );

SCSIPORT_API
ULONG
TapeClassCompareMemory(
    IN OUT  PVOID   Source1,
    IN OUT  PVOID   Source2,
    IN      ULONG   Length
    );

SCSIPORT_API
LARGE_INTEGER
TapeClassLiDiv(
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER Divisor
    );

SCSIPORT_API
VOID
TapeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

// end_ntminitape
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\4mmdat\4mmdat.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       4mmdat.c
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1994-1998 Microsoft

Module Name:

    4mmsony.c

Abstract:

    This module contains device-specific routines for 4mm DAT drives:
    SONY SDT-2000, SONY SDT-4000, SDT-5000, and SDT-5200.

Environment:

    kernel mode only

Revision History:



--*/

#include "minitape.h"
#include "4mmdat.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

STORAGE_MEDIA_TYPE DatMedia[DAT_SUPPORTED_TYPES] = {DDS_4mm};


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = TapeError ;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = 1;
    tapeInitData.TapeWMIOperations = TapeWMIControl;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}

#if 0


TAPE_STATUS
Verify(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeVerify requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.
    CommandExtension    - Supplies the ioctl extension.
    CommandParameters   - Supplies the command parameters.
    Srb                 - Supplies the SCSI request block.
    CallNumber          - Supplies the call number.
    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)
    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.
    Otherwise                           - An error occurred.

--*/

{
    PTAPE_VERIFY  tapeVerify = CommandParameters;
    PCDB          cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeVerify: Enter routine\n"));

    if (CallNumber == 0) {
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6VERIFY.OperationCode = SCSIOP_VERIFY6;

        cdb->CDB6VERIFY.Immediate = tapeVerify->Immediate;

        //
        // Assume fixed and that the length is in blocks.
        //

        cdb->CDB6VERIFY.Fixed = 1;

        cdb->CDB6VERIFY.VerificationLength[0] = (UCHAR)((tapeVerify->NumberOfBytes >> 16) & 0xFF);
        cdb->CDB6VERIFY.VerificationLength[1] = (UCHAR)((tapeVerify->NumberOfBytes >> 8) & 0xFF);
        cdb->CDB6VERIFY.VerificationLength[2] = (UCHAR)(tapeVerify->NumberOfBytes & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeVerify: SendSrb (TapeVerify)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT (CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end Verify()

#endif


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData, 
                                   extension);
    extension->CurrentPartition = 0 ;
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_CREATE_PARTITION      tapeCreatePartition = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PMINITAPE_EXTENSION         tapeExtension = MinitapeExtension ;
    PCOMMAND_EXTENSION          tapeCmdExtension = CommandExtension ;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_MEDIUM_PART_PAGE      modeSelectBuffer;
    ULONG                       modeSelectLength;
    ULONG                       partitionMethod;
    ULONG                       partitionCount;
    ULONG                       partition;

    PMODE_PARAMETER_HEADER      ParameterListHeader;  // List Header Format
    PMODE_PARAMETER_BLOCK       ParameterListBlock;   // List Block Descriptor
    PMODE_MEDIUM_PARTITION_PAGE MediumPartPage;
    PMODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;
    ULONG                       bufferSize ;

    UNREFERENCED_PARAMETER(LastError) ;

    DebugPrint((3,"CreatePartition: Enter routine\n"));

    if (CallNumber == 0) {

        partitionCount  = tapeCreatePartition->Count;

        //
        //  Filter out invalid partition counts.
        //

        switch (tapeCreatePartition->Count) {
            case 0:
            case 1:
            case 2:
                break;

            default:
                DebugPrint((1,
                           "CreatePartition: Invalid partitionCount - %x\n",
                           tapeCreatePartition->Count));

                return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // Check if we are doing TAPE_INITIATOR_PARTITION. If so, we
        // should first rewind the tape just in case it's not already.
        //
        if ((tapeCreatePartition->Method) == 
            TAPE_INITIATOR_PARTITIONS) {
           
           DebugPrint((1,
                       "CreatePartition for TAPE_INITIATOR_PARTITION.\n"));
           //
           // Zero CDB in SRB.
           //
           cdb = (PCDB)Srb->Cdb;
           TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
   
           //
           // Prepare SCSI command (CDB)
           //
   
           Srb->CdbLength = CDB6GENERIC_LENGTH;
           Srb->TimeOutValue = 900;
   
           cdb->CDB6GENERIC.Immediate = FALSE;
   
           cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
           Srb->TimeOutValue = 360;
           Srb->DataTransferLength = 0 ;

           return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        } else {
           return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
        }

    }

    if (CallNumber == 1) {

        if (!LocalAllocatePartPage(Srb,
                                   tapeExtension,
                                   &ParameterListHeader,
                                   &ParameterListBlock,
                                   &MediumPartPage,
                                   &bufferSize ) ) {

             DebugPrint((1,"TapeCreatePartition: insufficient resources (ModeSel buffer)\n"));
             return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufferSize;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;

        switch (tapeExtension->DriveID) {

            //
            // The Sony drives must return Block descriptors.
            //

            case DEC_TLZ09:
            case SONY_SDT2000 :
            case SONY_SDT4000 :
            case SONY_SDT5000 :
            case SONY_SDT5200 :
            case SONY_SDT10000:

                cdb->MODE_SENSE.Dbd = 0;
                break;

            case ARCHIVE_PYTHON:
            case SEAGATE_DAT:

                cdb->MODE_SENSE.Dbd = 1;
                break;

            default:
                cdb->MODE_SENSE.Dbd = 1;

                //
                // Subtract off last partition size entry.
                //

                cdb->MODE_SENSE.AllocationLength -= 2;
                break;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = cdb->MODE_SENSE.AllocationLength ;

        *RetryFlags = RETURN_ERRORS ;
        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }
    if ( CallNumber == 2 ) {

        LocalGetPartPageData(Srb,
                             tapeExtension,
                             &ParameterListHeader,
                             &ParameterListBlock,
                             &MediumPartPage,
                             &bufferSize ) ;


        partitionMethod = tapeCreatePartition->Method;
        partitionCount  = tapeCreatePartition->Count;

        //
        //  Filter out invalid partition counts.
        //

        switch (partitionCount) {
            case 0:
                partitionMethod = NO_PARTITIONS;
                break;

            case 1:
            case 2:
                break;

            default:
                return TAPE_STATUS_INVALID_DEVICE_REQUEST;
                break;
        }

        //
        //  Filter out partition methods that are
        //  not implemented on the various drives.
        //

        switch (partitionMethod) {
            case TAPE_FIXED_PARTITIONS:

                DebugPrint((3,"TapeCreatePartition: fixed partitions\n"));

                switch (tapeExtension->DriveID) {
                    case WANGDAT_1300:
                    case WANGDAT_3100:
                    case WANGDAT_3200:
                    case WANGDAT_3300DX:
                    case WANGDAT_3400DX:
                        partitionCount = 1;
                        break;

                    default:
                        return TAPE_STATUS_NOT_IMPLEMENTED;
                        break;
                }
                break;

            case TAPE_SELECT_PARTITIONS:

                DebugPrint((3,"TapeCreatePartition: select partitions\n"));

                switch (tapeExtension->DriveID) {
                    case WANGDAT_1300:
                    case WANGDAT_3100:
                    case WANGDAT_3200:
                    case WANGDAT_3300DX:
                    case WANGDAT_3400DX:
                        if (--partitionCount == 0) {

                            DebugPrint((3,"TapeCreatePartition: no partitions\n"));
                            partitionMethod = NO_PARTITIONS;

                        }
                        break;

                    default:
                        return TAPE_STATUS_NOT_IMPLEMENTED;
                        break;
                }
                break;

            case TAPE_INITIATOR_PARTITIONS:

                DebugPrint((3,"TapeCreatePartition: initiator partitions\n"));

                if (--partitionCount == 0) {

                    DebugPrint((3,"TapeCreatePartition: no partitions\n"));
                    partitionMethod = NO_PARTITIONS;

                }
                break;

            case NO_PARTITIONS:

                DebugPrint((3,"TapeCreatePartition: no partitions\n"));

                partitionCount = 0;
                break;

            default:
                DebugPrint((1,"partitionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
                break;

        }


        ParameterListHeader->ModeDataLength = 0;
        ParameterListHeader->MediumType = 0;
        ParameterListHeader->DeviceSpecificParameter = 0x10;
        if (ParameterListBlock) {
            ParameterListHeader->BlockDescriptorLength = 0x08;
        } else {
            ParameterListHeader->BlockDescriptorLength = 0;
        }

        MediumPartPage->PageCode = MODE_PAGE_MEDIUM_PARTITION;
        MediumPartPage->PageLength = partitionCount? 8 : 6;
        MediumPartPage->MaximumAdditionalPartitions = 0;
        MediumPartPage->AdditionalPartitionDefined = (UCHAR)partitionCount;
        MediumPartPage->MediumFormatRecognition = 3;


        switch (partitionMethod) {
            case TAPE_FIXED_PARTITIONS:
                MediumPartPage->FDPBit = SETBITON;
                switch (tapeExtension->DriveID) {
                    case WANGDAT_1300:
                    case WANGDAT_3100:
                    case WANGDAT_3200:
                    case WANGDAT_3300DX:
                    case WANGDAT_3400DX:
                        MediumPartPage->PageLength = 10;
                        break;

                    default:
                        //  we already returned not implmented....
                        MediumPartPage->PageLength = 6;
                        break;
                }
                partition = FIXED_PARTITIONED;
                break;

            case TAPE_SELECT_PARTITIONS:
                MediumPartPage->SDPBit = SETBITON;
                switch (tapeExtension->DriveID) {
                    case WANGDAT_1300:
                    case WANGDAT_3100:
                    case WANGDAT_3200:
                    case WANGDAT_3300DX:
                    case WANGDAT_3400DX:
                        MediumPartPage->PageLength = 10;
                        break;

                    default:
                        //  we already returned not implmented....
                        MediumPartPage->PageLength = 6;
                        break;
                }
                partition = SELECT_PARTITIONED;
                break;

            case TAPE_INITIATOR_PARTITIONS:
                MediumPartPage->IDPBit = SETBITON;
                MediumPartPage->PSUMBit = 2;
                switch (tapeExtension->DriveID) {
                    case WANGDAT_1300:
                    case WANGDAT_3100:
                    case WANGDAT_3200:
                    case WANGDAT_3300DX:
                    case WANGDAT_3400DX:
                        MediumPartPage->PageLength = 10;
                        if (partitionCount) {
                            MediumPartPage->Partition1Size[0] = (UCHAR)((tapeCreatePartition->Size >> 8) & 0xFF);
                            MediumPartPage->Partition1Size[1] = (UCHAR)(tapeCreatePartition->Size & 0xFF);
                        }
                        break;

                    case DEC_TLZ09:
                    case SONY_SDT2000 :
                    case SONY_SDT4000 :
                    case SONY_SDT5000 :
                    case SONY_SDT5200 :
                    case SONY_SDT10000:
                        MediumPartPage->PageLength = 10;
                        if (partitionCount) {
                            MediumPartPage->Partition0Size[0] = 0;
                            MediumPartPage->Partition0Size[1] = 0;

                            MediumPartPage->Partition1Size[0] = (UCHAR)((tapeCreatePartition->Size >> 8) & 0xFF);
                            MediumPartPage->Partition1Size[1] = (UCHAR)(tapeCreatePartition->Size & 0xFF);
                        }

                        break;

                    default:

                        //
                        // Subtract out Parition1Size
                        //

                        bufferSize -= 2;
                        if (partitionCount) {
                            if ((tapeExtension->DriveID == ARCHIVE_PYTHON) ||
                                (tapeExtension->DriveID == SEAGATE_DAT)) {
                                bufferSize += 2;
                            }

                            MediumPartPage->Partition0Size[0] = (UCHAR)((tapeCreatePartition->Size >> 8) & 0xFF);
                            MediumPartPage->Partition0Size[1] = (UCHAR)(tapeCreatePartition->Size & 0xFF);

                        }
                        break;
                }

                partition = INITIATOR_PARTITIONED;
                break;

            case NO_PARTITIONS:
                switch (tapeExtension->DriveID) {
                    case WANGDAT_1300:
                    case WANGDAT_3100:
                    case WANGDAT_3200:
                    case WANGDAT_3300DX:
                    case WANGDAT_3400DX:
                        switch (tapeCreatePartition->Method) {
                            case TAPE_FIXED_PARTITIONS:
                                MediumPartPage->FDPBit = SETBITON;
                                break;

                            case TAPE_SELECT_PARTITIONS:
                                MediumPartPage->SDPBit = SETBITON;
                                break;

                            case TAPE_INITIATOR_PARTITIONS:
                                MediumPartPage->IDPBit = SETBITON;
                                MediumPartPage->PSUMBit = 2;
                                break;
                        }
                        MediumPartPage->PageLength = 10;
                        break;

                    case DEC_TLZ09:
                    case SONY_SDT2000 :
                    case SONY_SDT4000 :
                    case SONY_SDT5000 :
                    case SONY_SDT5200 :
                    case SONY_SDT10000:
                        MediumPartPage->PageLength = 10;
                        MediumPartPage->MaximumAdditionalPartitions = 0;
                        MediumPartPage->Partition0Size[0] = 0;
                        MediumPartPage->Partition0Size[1] = 0;
                        MediumPartPage->Partition1Size[0] = 0;
                        MediumPartPage->Partition1Size[1] = 0;

                        MediumPartPage->IDPBit = SETBITON;
                        MediumPartPage->PSUMBit = 2;
                        break;

                    default:

                        //
                        // When no partitions are defined, the structure shinks to no longer
                        // include Partition0Size[2]
                        //

                        bufferSize -= 4;
                        if ((tapeExtension->DriveID == ARCHIVE_PYTHON) ||
                            (tapeExtension->DriveID == SEAGATE_DAT)) {
                           bufferSize += 2;
                        }
                        MediumPartPage->IDPBit = SETBITON;
                        MediumPartPage->PSUMBit = 2;
                        break;
                }
                partition = NOT_PARTITIONED;
                break;

        }

        Srb->CdbLength = CDB6GENERIC_LENGTH ;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)bufferSize;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode select)\n"));

        Srb->TimeOutValue = 16500;
        Srb->DataTransferLength = bufferSize;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        //
        //  save partition value for successful completion....
        //
        tapeCmdExtension->CurrentState = partition ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }


    if ( CallNumber == 3 ) {

        partition = tapeCmdExtension->CurrentState;

        if (partition == NOT_PARTITIONED) {

            tapeExtension->CurrentPartition = partition ;
            return TAPE_STATUS_SUCCESS ;

        }

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        if (!LocalAllocateConfigPage(Srb,
                                   tapeExtension,
                                   &ParameterListHeader,
                                   &ParameterListBlock,
                                   &DeviceConfigPage,
                                   &bufferSize ) ) {


            DebugPrint((1,"TapeCreatePartition: insufficient resources (DevConfig buffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = bufferSize ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if ( CallNumber == 4 ) {

        LocalGetConfigPageData(Srb,
                             tapeExtension,
                             &ParameterListHeader,
                             &ParameterListBlock,
                             &DeviceConfigPage,
                             &bufferSize ) ;

        tapeExtension->CurrentPartition = DeviceConfigPage->ActivePartition + 1;

    }

    return TAPE_STATUS_SUCCESS;

} // end TapeCreatePartition()


TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE                 tapeErase = CommandParameters;
    PCDB                        cdb = (PCDB) Srb->Cdb;
    PMINITAPE_EXTENSION         tapeExtension = MinitapeExtension ;

    UNREFERENCED_PARAMETER(LastError) ;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if ( CallNumber == 0 ) {

        if (tapeErase->Immediate) {
            switch (tapeErase->Type) {
                case TAPE_ERASE_LONG:
                case TAPE_ERASE_SHORT:
                    DebugPrint((3,"TapeErase: immediate\n"));
                    break;

                default:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                switch (tapeExtension->DriveID) {
                    case AIWA_GD201:
                    case ARCHIVE_PYTHON:
                    case DEC_TLZ06:
                    case DEC_TLZ07:
                    case EXABYTE_4200:
                    case EXABYTE_4200C:
                    case HP_35470A:
                    case HP_35480A:
                    case HP_IBM35480A:
                    case IOMEGA_DAT4000:
                    case WANGDAT_1300:
                        DebugPrint((1,"TapeErase: long -- operation not supported\n"));
                        return TAPE_STATUS_NOT_IMPLEMENTED;

                }
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:

               switch (tapeExtension->DriveID) {
                    case HP_C1533A:
                    case HP_C1553A:
                        DebugPrint((1,"TapeErase: short -- operation not supported\n"));
                        return TAPE_STATUS_NOT_IMPLEMENTED;

                }

                DebugPrint((3,"TapeErase: short\n"));
                break;

            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        if (tapeErase->Type == TAPE_ERASE_LONG) {
            cdb->ERASE.Long = SETBITON;
        } else {
            cdb->ERASE.Long = SETBITOFF;
        }

        //
        // Set timeout value.
        //

        if (tapeErase->Type == TAPE_ERASE_LONG) {
            Srb->TimeOutValue = 16500;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapeErase()

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION tapeExtension = MinitapeExtension;
    PSENSE_DATA        senseBuffer;
    UCHAR              senseKey;
    UCHAR              adsenseq;
    UCHAR              adsense;

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       senseBuffer = Srb->SenseInfoBuffer;
       senseKey = senseBuffer->SenseKey & 0x0F;
       adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
       adsense = senseBuffer->AdditionalSenseCode;

       switch (*LastError) {
   
           case TAPE_STATUS_IO_DEVICE_ERROR :
   
               if (senseKey == SCSI_SENSE_ABORTED_COMMAND) {
   
                   *LastError = TAPE_STATUS_DEVICE_NOT_READY;
               }
   
               break ;
   
           case TAPE_STATUS_BUS_RESET:
   
               // if a manual eject during an operation occurs then this happens
   
               if ((adsense == SCSI_ADSENSE_NO_MEDIA_IN_DEVICE) &&
                   (adsenseq == 0) ) {
   
                   *LastError = TAPE_STATUS_NO_MEDIA;
   
               }
               break;
       }
   
       if ((tapeExtension->DriveID == HP_C1533A) || (tapeExtension->DriveID == HP_C1553A)) {
           if (senseKey == SCSI_SENSE_NO_SENSE) {
               if ((adsense == HP_ADSENSE_CLEANING_REQ) && (adsenseq == HP_ADSENSE_CLEANING_REQ)) {
                   *LastError = TAPE_STATUS_REQUIRES_CLEANING;
               }
           }
       }   
    }

    DebugPrint((1,"TapeError: Status 0x%.8X \n", *LastError ));

    return;

} // end TapeError()

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;

    PMODE_PARAMETER_HEADER      ParameterListHeader;  // List Header Format
    PMODE_PARAMETER_BLOCK       ParameterListBlock;   // List Block Descriptor
    PMODE_DATA_COMPRESSION_PAGE DataCompressPage;
    PMODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;
    ULONG                       bufferSize ;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        if (!LocalAllocateConfigPage(Srb,
                                   extension,
                                   &ParameterListHeader,
                                   &ParameterListBlock,
                                   &DeviceConfigPage,
                                   &bufferSize ) ) {

            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (modeParmBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = bufferSize ;

        *RetryFlags = RETURN_ERRORS ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        if ( ( LastError != TAPE_STATUS_NO_MEDIA ) &&
            ( LastError != TAPE_STATUS_SUCCESS ) ) {
             return LastError ;
        }

        LocalGetConfigPageData(Srb,
                             extension,
                             &ParameterListHeader,
                             &ParameterListBlock,
                             &DeviceConfigPage,
                             &bufferSize ) ;

        tapeGetDriveParams->ReportSetmarks =
            (DeviceConfigPage->RSmk? 1 : 0 );

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        if (!LocalAllocateCompressPage(Srb,
                                   extension,
                                   &ParameterListHeader,
                                   &ParameterListBlock,
                                   &DataCompressPage,
                                   &bufferSize ) ) {

            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufferSize ;

        Srb->DataTransferLength = bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        *RetryFlags = RETURN_ERRORS ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        if ( LastError == TAPE_STATUS_INVALID_DEVICE_REQUEST ) {
            return TAPE_STATUS_CALLBACK ;
        }

        if ( ( LastError != TAPE_STATUS_NO_MEDIA ) &&
            ( LastError != TAPE_STATUS_SUCCESS ) ) {

            DebugPrint((1,"TapeGetDriveParameters: mode sense, SendSrb unsuccessful\n"));
            return LastError ;
        }

        compressionModeSenseBuffer = Srb->DataBuffer;

        LocalGetCompressPageData(Srb,
                             extension,
                             &ParameterListHeader,
                             &ParameterListBlock,
                             &DataCompressPage,
                             &bufferSize ) ;


        if (DataCompressPage->DCC) {

            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
                 (DataCompressPage->DCE? TRUE : FALSE);

        } else {
            return TAPE_STATUS_CALLBACK ;
        }

        if ( LastError == TAPE_STATUS_NO_MEDIA ) {

            return TAPE_STATUS_CALLBACK ;
        }

        if (compressionModeSenseBuffer->DataCompressPage.DDE) {
            return TAPE_STATUS_CALLBACK ;
        }

        if (( extension->DriveID != SONY_SDT2000 ) &&
            ( extension->DriveID != SONY_SDT4000 ) &&
            ( extension->DriveID != SONY_SDT5000 ) &&
            ( extension->DriveID != SONY_SDT5200 ) && 
            ( extension->DriveID != SONY_SDT10000) &&
            ( extension->DriveID != DEC_TLZ09    )) {

            return TAPE_STATUS_CALLBACK ;
        }

        ParameterListHeader->ModeDataLength = 0;
        ParameterListHeader->MediumType = 0;
        ParameterListHeader->DeviceSpecificParameter = 0x10;

        if ( ParameterListBlock ) {
             ParameterListBlock->DensityCode = 0x7F;
        }

        DataCompressPage->DDE = SETBITON;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode select)\n"));

        Srb->DataTransferLength = bufferSize ;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        *RetryFlags = RETURN_ERRORS ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if ( CallNumber == 3 ) {

        if ( ( LastError != TAPE_STATUS_NO_MEDIA ) &&
            ( LastError != TAPE_STATUS_CALLBACK ) &&
            ( LastError != TAPE_STATUS_SUCCESS ) ) {

            DebugPrint((1,"TapeGetDriveParameters: mode sense, SendSrb unsuccessful\n"));
            return LastError ;
        }


        //
        //  this time around lets make sure the DDE bit is on
        //

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(READ_BLOCK_LIMITS_DATA))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        *RetryFlags = RETURN_ERRORS ;

        Srb->DataTransferLength = sizeof(READ_BLOCK_LIMITS_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 4) {

        blockLimits = Srb->DataBuffer;

        if ( LastError == TAPE_STATUS_SUCCESS ) {

            tapeGetDriveParams->MaximumBlockSize  = blockLimits->BlockMaximumSize[2];
            tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
            tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

            tapeGetDriveParams->MinimumBlockSize  = blockLimits->BlockMinimumSize[1];
            tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);


        } else {

            if (LastError != TAPE_STATUS_NO_MEDIA ) {

                return LastError ;
            }
        }

        tapeGetDriveParams->DefaultBlockSize = 16384;
        tapeGetDriveParams->MaximumPartitionCount = 2;

        tapeGetDriveParams->FeaturesLow |=
           TAPE_DRIVE_INITIATOR |
           TAPE_DRIVE_ERASE_SHORT |
           TAPE_DRIVE_ERASE_IMMEDIATE |
           TAPE_DRIVE_FIXED_BLOCK |
           TAPE_DRIVE_VARIABLE_BLOCK |
           TAPE_DRIVE_WRITE_PROTECT |
           TAPE_DRIVE_REPORT_SMKS |
           TAPE_DRIVE_GET_ABSOLUTE_BLK |
           TAPE_DRIVE_GET_LOGICAL_BLK |
           TAPE_DRIVE_EJECT_MEDIA;

        tapeGetDriveParams->FeaturesHigh |=
           TAPE_DRIVE_LOAD_UNLOAD |
           TAPE_DRIVE_LOCK_UNLOCK |
           TAPE_DRIVE_REWIND_IMMEDIATE |
           TAPE_DRIVE_SET_BLOCK_SIZE |
           TAPE_DRIVE_LOAD_UNLD_IMMED |
           TAPE_DRIVE_SET_REPORT_SMKS |
           TAPE_DRIVE_ABSOLUTE_BLK |
           TAPE_DRIVE_LOGICAL_BLK |
           TAPE_DRIVE_END_OF_DATA |
           TAPE_DRIVE_RELATIVE_BLKS |
           TAPE_DRIVE_FILEMARKS |
           TAPE_DRIVE_SEQUENTIAL_FMKS |
           TAPE_DRIVE_SETMARKS |
           TAPE_DRIVE_REVERSE_POSITION |
           TAPE_DRIVE_WRITE_SETMARKS |
           TAPE_DRIVE_WRITE_FILEMARKS |
           TAPE_DRIVE_WRITE_MARK_IMMED;

        switch (extension->DriveID) {

            case AIWA_GD201:
            case IOMEGA_DAT4000:
                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_TAPE_CAPACITY |
                     TAPE_DRIVE_TAPE_REMAINING;

                tapeGetDriveParams->FeaturesHigh |=
                     TAPE_DRIVE_TENSION |
                     TAPE_DRIVE_TENSION_IMMED |
                     TAPE_DRIVE_ABS_BLK_IMMED |
                     TAPE_DRIVE_LOG_BLK_IMMED |
                     TAPE_DRIVE_SEQUENTIAL_SMKS;
                break;

            case ARCHIVE_PYTHON:
            case ARCHIVE_4322:
            case ARCHIVE_4326:
            case ARCHIVE_4586:
            case DEC_TLZ06:
            case DEC_TLZ07:
                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_TAPE_CAPACITY |
                     TAPE_DRIVE_TAPE_REMAINING;
                break;

            case DEC_TLZ09:

                tapeGetDriveParams->DefaultBlockSize = 16384;

                //
                // Turn off sequential setmarks and filemarks.
                //

                tapeGetDriveParams->FeaturesHigh &=~TAPE_DRIVE_SEQUENTIAL_FMKS;
                tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_ERASE_LONG |
                                                   TAPE_DRIVE_TAPE_CAPACITY ;

                tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_TENSION |
                                                    TAPE_DRIVE_TENSION_IMMED |
                                                    TAPE_DRIVE_ABS_BLK_IMMED;
                break;

            case ARCHIVE_IBM4326:
            case ARCHIVE_IBM4586:
            case SEAGATE_DAT:
                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_ERASE_LONG  |
                     TAPE_DRIVE_TAPE_CAPACITY |
                     TAPE_DRIVE_TAPE_REMAINING;
                break;

            case EXABYTE_4200:
            case EXABYTE_4200C:
                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_TAPE_CAPACITY |
                     TAPE_DRIVE_TAPE_REMAINING;

                if ((extension->DriveID) == EXABYTE_4200C) {
                   tapeGetDriveParams->FeaturesLow |= 
                      TAPE_DRIVE_ERASE_BOP_ONLY;
                }

                tapeGetDriveParams->FeaturesHigh &=~TAPE_DRIVE_SEQUENTIAL_FMKS;
                break;

            case HP_35470A:
            case HP_35480A:
            case HP_IBM35480A:
                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_TAPE_CAPACITY |
                     TAPE_DRIVE_TAPE_REMAINING;

                tapeGetDriveParams->FeaturesHigh |=
                     TAPE_DRIVE_ABS_BLK_IMMED |
                     TAPE_DRIVE_LOG_BLK_IMMED |
                     TAPE_DRIVE_SEQUENTIAL_SMKS;
                break;

            case HP_C1533A:
            case HP_C1553A:
                //
                // Bizarre implementation doesn't write EOD.
                //

                DebugPrint((1,"GetDriveParameters: Turning off erase short %x\n",
                           tapeGetDriveParams->FeaturesLow));
                tapeGetDriveParams->FeaturesLow &= ~TAPE_DRIVE_ERASE_SHORT;
                DebugPrint((1,"GetDriveParameters: Turned off erase short %x\n",
                           tapeGetDriveParams->FeaturesLow));

                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_ERASE_LONG  |
                     TAPE_DRIVE_TAPE_CAPACITY |
                     TAPE_DRIVE_TAPE_REMAINING |
                     TAPE_DRIVE_CLEAN_REQUESTS;

                tapeGetDriveParams->FeaturesHigh |=
                     TAPE_DRIVE_ABS_BLK_IMMED |
                     TAPE_DRIVE_LOG_BLK_IMMED |
                     TAPE_DRIVE_SEQUENTIAL_SMKS;
                break;

            case WANGDAT_1300:
                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_FIXED |
                     TAPE_DRIVE_SELECT |
                     TAPE_DRIVE_TAPE_CAPACITY;

                tapeGetDriveParams->FeaturesHigh |=
                     TAPE_DRIVE_ABS_BLK_IMMED |
                     TAPE_DRIVE_LOG_BLK_IMMED |
                     TAPE_DRIVE_SEQUENTIAL_SMKS;
                break;

            case SONY_SDT2000 :
            case SONY_SDT4000 :
            case SONY_SDT5000 :
            case SONY_SDT5200 :
            case SONY_SDT10000:
                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_ERASE_LONG |
                     TAPE_DRIVE_TAPE_CAPACITY ;

                tapeGetDriveParams->FeaturesHigh |=
                     TAPE_DRIVE_TENSION |
                     TAPE_DRIVE_TENSION_IMMED |
                     TAPE_DRIVE_ABS_BLK_IMMED ;
                     //TAPE_DRIVE_LOG_BLK_IMMED |
                     //TAPE_DRIVE_SEQUENTIAL_SMKS ;

                tapeGetDriveParams->FeaturesHigh &=~TAPE_DRIVE_SEQUENTIAL_FMKS;
                break ;
            case WANGDAT_3100:
            case WANGDAT_3200:
            case WANGDAT_3300DX:
            case WANGDAT_3400DX:
                tapeGetDriveParams->FeaturesLow |=
                     TAPE_DRIVE_FIXED |
                     TAPE_DRIVE_SELECT |
                     TAPE_DRIVE_ERASE_LONG  |
                     TAPE_DRIVE_ERASE_BOP_ONLY |
                     TAPE_DRIVE_TAPE_CAPACITY;

                tapeGetDriveParams->FeaturesHigh |=
                     TAPE_DRIVE_ABS_BLK_IMMED |
                     TAPE_DRIVE_LOG_BLK_IMMED |
                     TAPE_DRIVE_SEQUENTIAL_SMKS;
                break;
        }


        tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

        DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
           tapeGetDriveParams->FeaturesLow));
        DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
           tapeGetDriveParams->FeaturesHigh));

        return TAPE_STATUS_SUCCESS ;
    }

    ASSERT(FALSE) ;
    return TAPE_STATUS_SUCCESS ;

} // end TapeGetDriveParameters()

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION          extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS   tapeGetMediaParams = CommandParameters;
    PMODE_TAPE_MEDIA_INFORMATION modeSenseBuffer;
    PLOG_SENSE_PARAMETER_FORMAT  logSenseBuffer;
    LARGE_INTEGER                partitionSize[2];
    LARGE_INTEGER                remaining[2];
    LARGE_INTEGER                capacity[2];
    ULONG                        partitionCount = 0;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    PMODE_PARAMETER_HEADER      ParameterListHeader;  // List Header Format
    PMODE_PARAMETER_BLOCK       ParameterListBlock;   // List Block Descriptor
    PMODE_DATA_COMPRESSION_PAGE DataCompressPage;
    PMODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;
    ULONG                       bufferSize ;

    UNREFERENCED_PARAMETER(LastError) ;

    TapeClassZeroMemory(partitionSize, 2*sizeof(LARGE_INTEGER));
    TapeClassZeroMemory(remaining, 2*sizeof(LARGE_INTEGER));
    TapeClassZeroMemory(capacity, 2*sizeof(LARGE_INTEGER));

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        if (!LocalAllocateConfigPage(Srb,
                                   extension,
                                   &ParameterListHeader,
                                   &ParameterListBlock,
                                   &DeviceConfigPage,
                                   &bufferSize ) ) {

            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = bufferSize ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 2) {

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        LocalGetConfigPageData(Srb,
                             extension,
                             &ParameterListHeader,
                             &ParameterListBlock,
                             &DeviceConfigPage,
                             &bufferSize ) ;

        extension->CurrentPartition = DeviceConfigPage->ActivePartition + 1;

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION))) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeSenseBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION);

        if ((extension->DriveID == HP_C1553A) || (extension->DriveID == HP_C1533A)) {

            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 2;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) ;

        *RetryFlags = RETURN_ERRORS ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3) {
        if ( ( LastError != TAPE_STATUS_DATA_OVERRUN ) &&
             ( LastError != TAPE_STATUS_SUCCESS ) ) {

            return LastError ;
        }

        modeSenseBuffer = Srb->DataBuffer;

        tapeGetMediaParams->BlockSize  = modeSenseBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += modeSenseBuffer->ParameterListBlock.BlockLength[1] << 8;
        tapeGetMediaParams->BlockSize += modeSenseBuffer->ParameterListBlock.BlockLength[0] << 16;

        partitionCount = modeSenseBuffer->MediumPartPage.AdditionalPartitionDefined;
        tapeGetMediaParams->PartitionCount = partitionCount + 1;

        extension->CurrentPartition = partitionCount? extension->CurrentPartition : NOT_PARTITIONED;

        tapeGetMediaParams->WriteProtected =
            ((modeSenseBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

        partitionSize[0].LowPart  = modeSenseBuffer->MediumPartPage.Partition0Size[1];
        partitionSize[0].LowPart += modeSenseBuffer->MediumPartPage.Partition0Size[0] << 8;
        partitionSize[0].HighPart = 0;

        partitionSize[1].LowPart  = modeSenseBuffer->MediumPartPage.Partition1Size[1];
        partitionSize[1].LowPart += modeSenseBuffer->MediumPartPage.Partition1Size[0] << 8;
        partitionSize[1].HighPart = 0;

        switch (modeSenseBuffer->MediumPartPage.PSUMBit) {
            case 1:
                partitionSize[0].QuadPart <<= 10 ;
                partitionSize[1].QuadPart <<= 10 ;
                break;

            case 2:
                partitionSize[0].QuadPart <<= 20 ;
                partitionSize[1].QuadPart <<= 20 ;
                break;
        }

        switch (extension->DriveID) {
            case AIWA_GD201:
            case ARCHIVE_PYTHON:
            case ARCHIVE_4322:
            case ARCHIVE_4326:
            case ARCHIVE_4586:
            case ARCHIVE_IBM4326:
            case ARCHIVE_IBM4586:
            case SEAGATE_DAT:
            case DEC_TLZ06:
            case DEC_TLZ07:
            case EXABYTE_4200:
            case EXABYTE_4200C:
            case HP_35470A:
            case HP_35480A:
            case HP_C1533A:
            case HP_C1553A:
            case HP_IBM35480A:
            case IOMEGA_DAT4000:

                if (!TapeClassAllocateSrbBuffer(Srb, sizeof(LOG_SENSE_PARAMETER_FORMAT))) {
                    DebugPrint((1,"TapeGetMediaParameters: insufficient resources (LogSenseBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                logSenseBuffer = Srb->DataBuffer;

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
                cdb->LOGSENSE.PageCode = LOGSENSEPAGE31;
                cdb->LOGSENSE.PCBit = 1;
                cdb->LOGSENSE.AllocationLength[0] = 0;
                cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetMediaParameters: SendSrb (log sense)\n"));

                Srb->DataTransferLength = 0x24 ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

            case WANGDAT_1300:
            case WANGDAT_3100:
            case WANGDAT_3200:
            case WANGDAT_3300DX:
            case WANGDAT_3400DX:
            case DEC_TLZ09:
            case SONY_SDT2000 :
            case SONY_SDT4000 :
            case SONY_SDT5200 :
            case SONY_SDT5000 :
            case SONY_SDT10000:
                capacity[0].QuadPart = partitionSize[0].QuadPart +
                                       partitionSize[1].QuadPart ;

                tapeGetMediaParams->Remaining = remaining[0];
                tapeGetMediaParams->Capacity  = capacity[0];

                return TAPE_STATUS_SUCCESS ;
        }
    }

    if (CallNumber == 4) {

        logSenseBuffer = Srb->DataBuffer;

        capacity[0].LowPart  = logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.MaximumCapacityPart0[3];
        capacity[0].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.MaximumCapacityPart0[2] << 8;
        capacity[0].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.MaximumCapacityPart0[1] << 16;
        capacity[0].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.MaximumCapacityPart0[0] << 24;
        capacity[0].HighPart = 0;

        remaining[0].LowPart  = logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.RemainingCapacityPart0[3];
        remaining[0].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.RemainingCapacityPart0[2] << 8;
        remaining[0].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.RemainingCapacityPart0[1] << 16;
        remaining[0].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.RemainingCapacityPart0[0] << 24;
        remaining[0].HighPart = 0;

        capacity[1].LowPart  = logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.MaximumCapacityPart1[3];
        capacity[1].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.MaximumCapacityPart1[2] << 8;
        capacity[1].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.MaximumCapacityPart1[1] << 16;
        capacity[1].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.MaximumCapacityPart1[0] << 24;
        capacity[1].HighPart = 0;

        remaining[1].LowPart  = logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.RemainingCapacityPart1[3];
        remaining[1].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.RemainingCapacityPart1[2] << 8;
        remaining[1].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.RemainingCapacityPart1[1] << 16;
        remaining[1].LowPart += logSenseBuffer->LogSensePageInfo.LogSensePage.Page31.RemainingCapacityPart1[0] << 24;
        remaining[1].HighPart = 0;

        remaining[0].QuadPart = remaining[0].QuadPart << 10 ;
        remaining[1].QuadPart = remaining[1].QuadPart << 10 ;
        remaining[0].QuadPart = remaining[0].QuadPart + remaining[1].QuadPart ;

        capacity[0].QuadPart <<= 10 ;
        capacity[1].QuadPart <<= 10 ;
        capacity[0].QuadPart += capacity[1].QuadPart ;

        tapeGetMediaParams->Remaining = remaining[0];
        tapeGetMediaParams->Capacity  = capacity[0];

        return TAPE_STATUS_SUCCESS ;
     }
     ASSERT(FALSE) ;
     return TAPE_STATUS_SUCCESS ;

} // end TapeGetMediaParameters()

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PTAPE_POSITION_DATA         positionBuffer;
    ULONG                       type;

    UNREFERENCED_PARAMETER(LastError) ;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;

    }

    if ( CallNumber == 1 ) {

         switch (tapeGetPosition->Type) {
             case TAPE_ABSOLUTE_POSITION:
                 DebugPrint((3,"TapeGetPosition: absolute\n"));
                 break;

             case TAPE_LOGICAL_POSITION:
                 DebugPrint((3,"TapeGetPosition: logical\n"));
                 break;

             default:
                 DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                 return TAPE_STATUS_NOT_IMPLEMENTED;

         }

         if (!TapeClassAllocateSrbBuffer( Srb, sizeof(TAPE_POSITION_DATA) )) {
               DebugPrint((1,"TapeGetPosition: insufficient resources (TapePositionData)\n"));
               return TAPE_STATUS_INSUFFICIENT_RESOURCES;
         }


         positionBuffer = Srb->DataBuffer ;

         //
         // Prepare SCSI command (CDB)
         //

         Srb->CdbLength = CDB10GENERIC_LENGTH;
         TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

         cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

         if (tapeGetPosition->Type == TAPE_ABSOLUTE_POSITION) {
             switch (extension->DriveID) {
                 case ARCHIVE_PYTHON:
                 case WANGDAT_1300:
                 case WANGDAT_3100:
                 case WANGDAT_3200:
                 case WANGDAT_3300DX:
                 case WANGDAT_3400DX:
                 case DEC_TLZ09:
                 case SONY_SDT2000 :
                 case SONY_SDT4000 :
                 case SONY_SDT5000 :
                 case SONY_SDT5200 :
                 case SONY_SDT10000:
                     break;

                 default:
                     cdb->READ_POSITION.BlockType = SETBITON;
                     break;
             }
         }

         //
         // Send SCSI command (CDB) to device
         //

         DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

         Srb->DataTransferLength = sizeof(TAPE_POSITION_DATA) ;

         return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 2) ;

    positionBuffer = Srb->DataBuffer ;

    if (positionBuffer->BlockPositionUnsupported) {
        DebugPrint((1,"TapeGetPosition: read position -- block position unsupported\n"));
        return TAPE_STATUS_INVALID_DEVICE_REQUEST;
    }

    if (tapeGetPosition->Type == TAPE_LOGICAL_POSITION) {
       if (extension->CurrentPartition != NOT_PARTITIONED) {
          tapeGetPosition->Partition = positionBuffer->PartitionNumber + 1;
       } else {
          tapeGetPosition->Partition = positionBuffer->PartitionNumber;
       }
    }

    tapeGetPosition->Offset.HighPart = 0;
    REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                  (PFOUR_BYTE)positionBuffer->FirstBlock);

    return TAPE_STATUS_SUCCESS ;


} // end TapeGetPosition()

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION tapeExtension = MinitapeExtension;
    PCOMMAND_EXTENSION  commandExtension = CommandExtension;
    PHP_SENSE_DATA      senseData;
    PCDB                cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {

        if ((tapeExtension->DriveID == HP_C1533A) || (tapeExtension->DriveID == HP_C1553A)) {
            *RetryFlags = RETURN_ERRORS;
            commandExtension->CurrentState = HP_C1533A;
        } else {
           commandExtension->CurrentState = 0;
        }

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((commandExtension->CurrentState == HP_C1533A) &&
        (CallNumber == 1)) {

       commandExtension->CurrentState = LastError;

       //
       // Issue a request sense to get the cleaning info bits.
       //
       
       if (!TapeClassAllocateSrbBuffer( Srb, sizeof(HP_SENSE_DATA))) {
          DebugPrint((1,
                      "GetStatus: Insufficient resources (SenseData)\n"));
          return TAPE_STATUS_SUCCESS;
       }    
       
       //
       // Prepare SCSI command (CDB)
       //
       
       TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
       
       Srb->ScsiStatus = Srb->SrbStatus = 0;
       Srb->CdbLength = CDB6GENERIC_LENGTH;
       
       cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
       cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(HP_SENSE_DATA);
       
       //
       // Send SCSI command (CDB) to device
       //
       
       Srb->DataTransferLength = sizeof(HP_SENSE_DATA);
       *RetryFlags |= RETURN_ERRORS;
       
       return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
       
    } 

    if (CallNumber == 2) {
       if ((commandExtension->CurrentState == TAPE_STATUS_SUCCESS)  ||
           (commandExtension->CurrentState == TAPE_STATUS_NO_MEDIA)) {
          
          //
          // Return needs cleaning status if necessary, but only if
          // no other errors are present (with the exception of no media as the
          // drive will spit out AME media when in this state).
          //
          
          senseData = Srb->DataBuffer;
          
          //
          // Determine if the clean bit is set.
          //
          
          if (senseData->CLN) {
             DebugPrint((1,
                         "Drive reports needs cleaning \n"));
             
             return TAPE_STATUS_REQUIRES_CLEANING;
          } else {
             return (commandExtension->CurrentState);
          }
       } else {
          
          //
          // Return the saved error status.
          //
          return commandExtension->CurrentState;
       }
    }   

    return TAPE_STATUS_SUCCESS;

} // end TapeGetStatus()

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION  extension = MinitapeExtension;
    PTAPE_PREPARE        tapePrepare = CommandParameters;
    PCDB                 cdb = (PCDB)Srb->Cdb;

    UNREFERENCED_PARAMETER(LastError) ;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: load\n"));
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: unload\n"));
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: lock\n"));
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: unlock\n"));
                break;

            case TAPE_TENSION:
                DebugPrint((3,"TapePrepare: tension\n"));

                switch (extension->DriveID) {
                    case ARCHIVE_PYTHON:
                    case ARCHIVE_IBM4326:
                    case ARCHIVE_IBM4586:
                    case SEAGATE_DAT:
                    case ARCHIVE_4322:
                    case ARCHIVE_4326:
                    case ARCHIVE_4586:
                    case DEC_TLZ06:
                    case DEC_TLZ07:
                    case EXABYTE_4200:
                    case EXABYTE_4200C:
                    case HP_35470A:
                    case HP_35480A:
                    case HP_C1533A:
                    case HP_C1553A:
                    case HP_IBM35480A:
                    case WANGDAT_1300:
                    case WANGDAT_3100:
                    case WANGDAT_3200:
                    case WANGDAT_3300DX:
                    case WANGDAT_3400DX:
                        return TAPE_STATUS_NOT_IMPLEMENTED;
                        break;
                }
                break;

            default:
                return TAPE_STATUS_NOT_IMPLEMENTED;
                break;
        }

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                case TAPE_TENSION:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_LOCK:
                case TAPE_UNLOCK:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 900;
                break;

            case TAPE_UNLOAD:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                Srb->TimeOutValue = 390;
                break;

            case TAPE_TENSION:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
                Srb->TimeOutValue = 390;
                break;

            case TAPE_LOCK:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_UNLOCK:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                Srb->TimeOutValue = 180;
                break;

        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 1) ;

    return TAPE_STATUS_SUCCESS;

} // end TapePrepare()

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;

    PMODE_PARAMETER_HEADER      ParameterListHeader;  // List Header Format
    PMODE_PARAMETER_BLOCK       ParameterListBlock;   // List Block Descriptor
    PMODE_MEDIUM_PARTITION_PAGE MediumPartPage;
    PMODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;
    PMODE_DATA_COMPRESSION_PAGE DataCompressPage;
    ULONG                       bufferSize ;

    UNREFERENCED_PARAMETER(LastError) ;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        if (!LocalAllocateConfigPage(Srb,
                                   extension,
                                   &ParameterListHeader,
                                   &ParameterListBlock,
                                   &DeviceConfigPage,
                                   &bufferSize ) ) {

            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = bufferSize ;

        *RetryFlags = RETURN_ERRORS ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 1 ) {

        if ( LastError != TAPE_STATUS_SUCCESS ) {

            return TAPE_STATUS_CALLBACK ;
        }

        LocalGetConfigPageData(Srb,
                             extension,
                             &ParameterListHeader,
                             &ParameterListBlock,
                             &DeviceConfigPage,
                             &bufferSize ) ;

        ParameterListHeader->ModeDataLength = 0;
        ParameterListHeader->MediumType = 0;
        ParameterListHeader->DeviceSpecificParameter = 0x10;
//        ParameterListHeader->BlockDescriptorLength = 0;

        if ( ParameterListBlock ) {
            ParameterListBlock->DensityCode = 0x7f ;
        }

        DeviceConfigPage->PageCode = MODE_PAGE_DEVICE_CONFIG;
        DeviceConfigPage->PageLength = 0x0E;

        if (tapeSetDriveParams->ReportSetmarks) {
            DeviceConfigPage->RSmk = SETBITON;
        } else {
            DeviceConfigPage->RSmk = SETBITOFF;
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->DataTransferLength = bufferSize ;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return  TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        if (!LocalAllocateCompressPage(Srb,
                                   extension,
                                   &ParameterListHeader,
                                   &ParameterListBlock,
                                   &DataCompressPage,
                                   &bufferSize ) ) {

            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = bufferSize ;
        *RetryFlags = RETURN_ERRORS ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 3 ) {

        if ( LastError == TAPE_STATUS_INVALID_DEVICE_REQUEST ) {
            return TAPE_STATUS_SUCCESS ;
        }

        LocalGetCompressPageData(Srb,
                             extension,
                             &ParameterListHeader,
                             &ParameterListBlock,
                             &DataCompressPage,
                             &bufferSize ) ;

        if ( !DataCompressPage->DCC) {
            return TAPE_STATUS_SUCCESS ;
        }

        ParameterListHeader->ModeDataLength = 0;
        ParameterListHeader->MediumType = 0;
        ParameterListHeader->DeviceSpecificParameter = 0x10;

        if ( ParameterListBlock ) {
            ParameterListBlock->DensityCode = 0x7F;
        } else {
            ParameterListHeader->BlockDescriptorLength = 0;
        }

        DataCompressPage->PageCode = MODE_PAGE_DATA_COMPRESS;
        DataCompressPage->PageLength = 0x0E;

        if (tapeSetDriveParams->Compression) {
            DataCompressPage->DCE = SETBITON;
            DataCompressPage->CompressionAlgorithm[0] = 0;
            DataCompressPage->CompressionAlgorithm[1] = 0;
            DataCompressPage->CompressionAlgorithm[2] = 0;
            DataCompressPage->CompressionAlgorithm[3] = 0x20;
            DataCompressPage->DecompressionAlgorithm[0] = 0;
            DataCompressPage->DecompressionAlgorithm[1] = 0;
            DataCompressPage->DecompressionAlgorithm[2] = 0;
            DataCompressPage->DecompressionAlgorithm[3] = 0;
        } else {
            DataCompressPage->DCE = SETBITOFF;
            DataCompressPage->CompressionAlgorithm[0] = 0;
            DataCompressPage->CompressionAlgorithm[1] = 0;
            DataCompressPage->CompressionAlgorithm[2] = 0;
            DataCompressPage->CompressionAlgorithm[3] = 0;
            DataCompressPage->DecompressionAlgorithm[0] = 0;
            DataCompressPage->DecompressionAlgorithm[1] = 0;
            DataCompressPage->DecompressionAlgorithm[2] = 0;
            DataCompressPage->DecompressionAlgorithm[3] = 0;
        }

        DataCompressPage->DDE = SETBITON;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)bufferSize ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->DataTransferLength = bufferSize ;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
     }

     ASSERT( CallNumber == 4 ) ;

     return TAPE_STATUS_SUCCESS ;

} // end TapeSetDriveParameters()
TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    UNREFERENCED_PARAMETER(LastError) ;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

         return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }
    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer ;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
                                MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.DensityCode = 0x7F;
        modeBuffer->ParameterListBlock.BlockLength[0] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
            (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 2 );

    return TAPE_STATUS_SUCCESS ;

} // end TapeSetMediaParameters()

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION tapeExtension = MinitapeExtension ;
    PCOMMAND_EXTENSION  tapeCmdExtension = CommandExtension ;
    PTAPE_SET_POSITION  tapeSetPosition = CommandParameters;
    PCDB                cdb = (PCDB)Srb->Cdb;
    ULONG               tapePositionVector;
    ULONG               method;
    ULONG               partition = 0;

    UNREFERENCED_PARAMETER(LastError) ;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                    DebugPrint((3,"TapeSetPosition: immediate\n"));
                    break;

                case TAPE_ABSOLUTE_BLOCK:
                    switch (tapeExtension->DriveID) {
                        case ARCHIVE_PYTHON:
                        case ARCHIVE_IBM4326:
                        case ARCHIVE_IBM4586:
                        case SEAGATE_DAT:
                        case ARCHIVE_4322:
                        case ARCHIVE_4326:
                        case ARCHIVE_4586:

                            DebugPrint((1,"TapeSetPosition: PositionMethod (absolute), immediate -- operation not supported\n"));
                            return TAPE_STATUS_NOT_IMPLEMENTED;
                            break;

                        default:
                            DebugPrint((3,"TapeSetPosition: immediate\n"));
                            break;
                    }
                    break;

                case TAPE_LOGICAL_BLOCK:
                    switch (tapeExtension->DriveID) {
                        case DEC_TLZ09:
                        case SONY_SDT2000 :
                        case SONY_SDT4000 :
                        case SONY_SDT5000 :
                        case SONY_SDT5200 :
                        case SONY_SDT10000:
                        case ARCHIVE_PYTHON:
                        case ARCHIVE_IBM4326:
                        case ARCHIVE_IBM4586:
                        case SEAGATE_DAT:
                        case ARCHIVE_4322:
                        case ARCHIVE_4326:
                        case ARCHIVE_4586:

                            DebugPrint((1,"TapeSetPosition: PositionMethod (logical), immediate -- operation not supported\n"));
                            return TAPE_STATUS_NOT_IMPLEMENTED;
                            break;

                        default:
                            DebugPrint((3,"TapeSetPosition: immediate\n"));
                            break;
                    }
                    break;

                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:
                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->TimeOutValue = 900;

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (tapeSetPosition->Method) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 360;
                break;

            case TAPE_ABSOLUTE_BLOCK:
                switch (tapeExtension->DriveID) {
                    case ARCHIVE_PYTHON:
                    case WANGDAT_1300:
                    case WANGDAT_3100:
                    case WANGDAT_3200:
                    case WANGDAT_3300DX:
                    case WANGDAT_3400DX:
                    case DEC_TLZ09:
                    case SONY_SDT2000 :
                    case SONY_SDT4000 :
                    case SONY_SDT5000 :
                    case SONY_SDT5200 :
                    case SONY_SDT10000:
                        DebugPrint((3,"TapeSetPosition: method == locate, BT- (absolute)\n"));
                        break;

                    default:
                        DebugPrint((3,"TapeSetPosition: method == locate, BT+ (absolute)\n"));
                        cdb->LOCATE.BTBit = SETBITON;
                        break;
                }
                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)((tapeSetPosition->Offset.LowPart >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);

                Srb->TimeOutValue = 480;
                break;


            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (logical)\n"));

                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)((tapeSetPosition->Offset.LowPart >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);

                if ((tapeSetPosition->Partition != 0) &&
                    (tapeExtension->CurrentPartition != NOT_PARTITIONED) &&
                    (tapeSetPosition->Partition != tapeExtension->CurrentPartition)) {

                    partition = tapeSetPosition->Partition;
                    cdb->LOCATE.Partition = (UCHAR)(partition - 1);
                    cdb->LOCATE.CPBit = SETBITON;

                } else {
                    partition = tapeExtension->CurrentPartition;
                }
                Srb->TimeOutValue = 480;
                break;

            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 480;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =    (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
                Srb->TimeOutValue = 480;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =    (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
                Srb->TimeOutValue = 480;
                break;

            case TAPE_SPACE_SEQUENTIAL_FMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 2;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =    (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
                Srb->TimeOutValue = 480;
                break;

            case TAPE_SPACE_SETMARKS:
                DebugPrint((3,"TapeSetPosition: method == space setmarks\n"));

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 4;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =    (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
                Srb->TimeOutValue = 480;
                break;

            case TAPE_SPACE_SEQUENTIAL_SMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential setmarks\n"));

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 5;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)(UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =    (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
                Srb->TimeOutValue = 480;
                break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;

        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0 ;

        tapeCmdExtension->CurrentState = partition ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 1 ) ;

    if (tapeSetPosition->Method == TAPE_LOGICAL_BLOCK) {
        tapeExtension->CurrentPartition = tapeCmdExtension->CurrentState ;
    }

    return TAPE_STATUS_SUCCESS ;

} // end TapeSetPosition()

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                case TAPE_SHORT_FILEMARKS:
                case TAPE_LONG_FILEMARKS:
                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SETMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == setmarks\n"));
                cdb->WRITE_TAPE_MARKS.WriteSetMarks = SETBITON;
                break;

            case TAPE_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == filemarks\n"));
                break;

            case TAPE_SHORT_FILEMARKS:
            case TAPE_LONG_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 900;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS;

} // end TapeWriteMarks()



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PMINITAPE_EXTENSION tapeExtension = MinitapeExtension;
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {

                DebugPrint((1,
                            "4mmDAT.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS));
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)Srb->DataTransferLength;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {

        ULONG currentMedia;
        ULONG blockSize;
        ULONG i;
        UCHAR densityCode;
        PMODE_DEVICE_CONFIG_PAGE_PLUS configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, only one type (either known or unknown) is returned.
        //

        mediaTypes->MediaInfoCount = 1;

        if ( LastError == TAPE_STATUS_SUCCESS ) {

            //
            // Determine the media type currently loaded.
            //

            densityCode = configInformation->ParameterListBlock.DensityCode;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: DensityCode %x, Current Block Size %x\n",
                        densityCode,
                        blockSize));


            switch (densityCode) {
                case 0:

                    //
                    // Cleaner, unknown, no media mounted...
                    //

                    currentMedia = 0;
                    break;

                case 0x13:
                case 0x24:
                case 0x25:
                case 0x26:
      
                    //
                    // DDS-1, 2, 3, or 4.
                    //

                    currentMedia = DDS_4mm;
                    break;

                default:

                    //
                    // Unknown
                    //

                    currentMedia = 0;
                    break;
            }

            if ((tapeExtension->DriveID == EXABYTE_4200) ||
                (tapeExtension->DriveID == EXABYTE_4200C)) {

                //
                // Never seem to set mediatype/density code.
                //

                currentMedia = DDS_4mm;

            }

        } else {
            currentMedia = 0;
        }


        //
        // fill in buffer based on spec. values
        // Only one type supported now.
        //

        for (i = 0; i < DAT_SUPPORTED_TYPES; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = DatMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (DatMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;


                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType =
                    configInformation->ParameterListHeader.MediumType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode = densityCode;
                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }

    }

    return TAPE_STATUS_SUCCESS;
}


static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData,
    IN OUT PMINITAPE_EXTENSION miniExtension
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)
    miniExtension Mini driver extension

Return Value:

    driveID

--*/

{
    //
    // Assume the drive provides no means to retrieve tape alert info.
    //  
    miniExtension->DriveAlertInfoType = TapeAlertInfoNone;

    if (TapeClassCompareMemory(InquiryData->VendorId,"AIWA    ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"GD-201",6) == 6) {
            return AIWA_GD201;
        }
        if (TapeClassCompareMemory(InquiryData->ProductId,"GD-8000",7) == 7) {
            return HP_C1553A;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"ARCHIVE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"Python",6) == 6) {
            return ARCHIVE_PYTHON;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"IBM4326",7) == 7) {
            return ARCHIVE_IBM4326;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"4322XX",6) == 6) {
            return ARCHIVE_4322;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"4326XX",6) == 6) {
            return ARCHIVE_4326;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"4586XX",6) == 6) {
            return ARCHIVE_4586;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"IBM4586",7) == 7) {
            return ARCHIVE_IBM4586;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"DEC     ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"TLZ06",5) == 5) {
            return DEC_TLZ06;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TLZ6",4) == 4) {
            return DEC_TLZ06;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TLZ07",5) == 5) {
            return DEC_TLZ07;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TLZ09",5) == 5) {
            return DEC_TLZ09;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TLZ7 ",5) == 5) {
            return DEC_TLZ07;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TLZ9 ",5) == 5) {
            return DEC_TLZ09;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TLZ10",5) == 5) {
            return DEC_TLZ09;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"EXABYTE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-4200 ",9) == 9) {
            return EXABYTE_4200;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-4200c",9) == 9) {
            return EXABYTE_4200C;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"HP      ",8) == 8) {

        //
        // All HP 4mmDat drives provide some drive alert info in
        // request sense data
        //
        miniExtension->DriveAlertInfoType = TapeAlertInfoRequestSense;
        if (TapeClassCompareMemory(InquiryData->ProductId,"HP35470A",8) == 8) {
            return HP_35470A;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"HP35480A",8) == 8) {
            return HP_35480A;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"IBM35480A",9) == 9) {
            return HP_IBM35480A;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"C1533A",6) == 6) {
            return HP_C1533A;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"C1553A",6) == 6) {
            return HP_C1553A;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"C1537A",6) == 6) {
            miniExtension->DriveAlertInfoType = TapeAlertInfoLogPage;
            return HP_C1553A;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"C1557A",6) == 6) {
            miniExtension->DriveAlertInfoType = TapeAlertInfoLogPage;
            return HP_C1553A;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"C5683A",6) == 6) {
           return HP_C1553A;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"C5713A",6) == 6) {
           return HP_C1553A;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"IBM     ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"HP35480A ",9) == 9) {
            return HP_IBM35480A;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"IOMEGA  ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"DAT4000",7) == 7) {
            return IOMEGA_DAT4000;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"WangDAT ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"Model 1300",10) == 10) {
            return WANGDAT_1300;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"Model 3100",10) == 10) {
            return WANGDAT_3100;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"Model 3200",10) == 10) {
            return WANGDAT_3200;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"Model 3300DX",12) == 12) {
            return WANGDAT_3300DX;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"Model 3400DX",12) == 12) {
            return WANGDAT_3400DX;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"WANGTEK ",8) == 8) {
        if (TapeClassCompareMemory(InquiryData->ProductId,"6130-FS",7) == 7) {
            return WANGDAT_3400DX;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"SONY    ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-2000",8) == 8) {
            return SONY_SDT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-4000",8) == 8) {
            return SONY_SDT4000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-5000",8) == 8) {
            return SONY_SDT5000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-5200",8) == 8) {
            return SONY_SDT5200;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-7000",8) == 8) {
            return SONY_SDT5000;
        }
        if (TapeClassCompareMemory(InquiryData->ProductId,"TSL-7000",8) == 8) {
            return DEC_TLZ09;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-9000",8) == 8) {
            return SONY_SDT5000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-10000", 9) == 9) {
            miniExtension->DriveAlertInfoType = TapeAlertInfoRequestSense;
            return SONY_SDT10000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-11000", 9) == 9) {
            miniExtension->DriveAlertInfoType = TapeAlertInfoRequestSense;
            return SONY_SDT10000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TSL-9000",8) == 8) {
            return SONY_SDT5000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TSL-10000",9) == 9) {
            miniExtension->DriveAlertInfoType = TapeAlertInfoRequestSense;
            return SONY_SDT10000;
        }
        if (TapeClassCompareMemory(InquiryData->ProductId,"TSL-11000",9) == 9) {
            miniExtension->DriveAlertInfoType = TapeAlertInfoRequestSense;
            return SONY_SDT10000;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"COMPAQ", 6) == 6) {
       if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-7000",8) == 8) {
           return SONY_SDT5000;
       }
       if (TapeClassCompareMemory(InquiryData->ProductId,"SDT-9000",8) == 8) {
           return SONY_SDT5000;
       }
       if ((TapeClassCompareMemory(InquiryData->ProductId,"SDT-10000", 9) == 9) ||
           (TapeClassCompareMemory(InquiryData->ProductId,"TSL-10000",9) == 9)) {
           miniExtension->DriveAlertInfoType = TapeAlertInfoRequestSense;
           return SONY_SDT10000;
       }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"SEAGATE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"DAT",3) == 3) {
            return SEAGATE_DAT;
        }

    }
    
    return 0;
}

BOOLEAN
LocalAllocatePartPage(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_MEDIUM_PARTITION_PAGE *MediumPartPage,
       OUT  PULONG                      bufferSize
    )

/*++

Routine Description:

    This routine allocates and returns the pointers to the individule
     members of the MODE_MEDIUM_PART_PAGE

Arguments:

    Srb                 - Supplies the SCSI request block.

    MinitapeExtension   - Supplies the minitape extension.

    ParameterListHeader - Return pointer to this portion of the page.

    ParameterListBlock  - Return pointer to this poriton of the page.

    MediumPartPage      - Return pointer to this portion of the page.

    bufferSize          - The size of the page.

Return Value:

    TRUE if the allocation was successful

--*/
{
    ULONG size ;

    switch ( MinitapeExtension->DriveID ) {

        case DEC_TLZ09:
        case SONY_SDT2000 :
        case SONY_SDT4000 :
        case SONY_SDT5000 :
        case SONY_SDT5200 :

            size = sizeof(MODE_MEDIUM_PART_PAGE_PLUS) ;
            break ;

        case ARCHIVE_PYTHON:
        case SEAGATE_DAT:
            size = sizeof(MODE_MEDIUM_PART_PAGE) - 2;
            break;

        default:

            size = sizeof(MODE_MEDIUM_PART_PAGE);
            break ;
    }

    if (!TapeClassAllocateSrbBuffer(Srb, size) ) {
         DebugPrint((1,"TapeCreatePartition: insufficient resources (ModeSel buffer)\n"));
         return FALSE ;

    } else {
         LocalGetPartPageData( Srb,
                               MinitapeExtension,
                               ParameterListHeader,
                               ParameterListBlock,
                               MediumPartPage,
                               bufferSize ) ;

    }
    return TRUE ;
}

VOID
LocalGetPartPageData(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_MEDIUM_PARTITION_PAGE *MediumPartPage,
       OUT  PULONG                      bufferSize
    )

/*++

Routine Description:

    This returns the pointers to the individule members of the
     MODE_MEDIUM_PART_PAGE

Arguments:

    Srb                 - Supplies the SCSI request block.

    MinitapeExtension   - Supplies the minitape extension.

    ParameterListHeader - Return pointer to this portion of the page.

    ParameterListBlock  - Return pointer to this poriton of the page.

    MediumPartPage      - Return pointer to this portion of the page.

    bufferSize          - The size of the page.

Return Value:

    none

--*/
{
    PMODE_MEDIUM_PART_PAGE      modePage = Srb->DataBuffer ;
    PMODE_MEDIUM_PART_PAGE_PLUS modePagePlus = Srb->DataBuffer ;

    switch ( MinitapeExtension->DriveID ) {

        case DEC_TLZ09:
        case SONY_SDT2000 :
        case SONY_SDT4000 :
        case SONY_SDT5000 :
        case SONY_SDT5200 :
            *ParameterListHeader = &modePagePlus->ParameterListHeader ;
            *ParameterListBlock  = &modePagePlus->ParameterListBlock ;
            *MediumPartPage      = &modePagePlus->MediumPartPage ;
            *bufferSize          = sizeof(MODE_MEDIUM_PART_PAGE_PLUS) ;
            break ;

        case ARCHIVE_PYTHON:
        case SEAGATE_DAT:
            *ParameterListHeader = &modePage->ParameterListHeader ;
            *ParameterListBlock  = NULL ;
            *MediumPartPage      = &modePage->MediumPartPage ;
            *bufferSize          = sizeof(MODE_MEDIUM_PART_PAGE) - 2;
            break ;

        default:
            *ParameterListHeader = &modePage->ParameterListHeader ;
            *ParameterListBlock  = NULL ;
            *MediumPartPage      = &modePage->MediumPartPage ;
            *bufferSize          = sizeof(MODE_MEDIUM_PART_PAGE);
            break ;
    }
    return ;
}

BOOLEAN
LocalAllocateConfigPage(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_DEVICE_CONFIGURATION_PAGE *DeviceConfigPage,
       OUT  PULONG                      bufferSize
    )

/*++

Routine Description:

    This routine allocates and returns the pointers to the individule
     members of the MODE_DEVICE_CONFIG_PAGE

Arguments:

    Srb                 - Supplies the SCSI request block.

    MinitapeExtension   - Supplies the minitape extension.

    ParameterListHeader - Return pointer to this portion of the page.

    ParameterListBlock  - Return pointer to this poriton of the page.

    DeviceConfigPage    - Return pointer to this portion of the page.

    bufferSize          - The size of the page.

Return Value:

    TRUE if the allocation was successful.

--*/
{
    ULONG size ;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    switch ( MinitapeExtension->DriveID ) {

        case DEC_TLZ09:
        case SONY_SDT2000 :
        case SONY_SDT4000 :
        case SONY_SDT5000 :
        case SONY_SDT5200 :
            size = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS) ;
            break ;

        default:
            cdb->MODE_SENSE.Dbd = SETBITON;
            size = sizeof(MODE_DEVICE_CONFIG_PAGE) ;
            break ;
    }

    if (!TapeClassAllocateSrbBuffer(Srb, size) ) {
         DebugPrint((1,"TapeCreatePartition: insufficient resources (ModeSel buffer)\n"));
         return FALSE ;

    } else {
         LocalGetConfigPageData( Srb,
                               MinitapeExtension,
                               ParameterListHeader,
                               ParameterListBlock,
                               DeviceConfigPage,
                               bufferSize ) ;

    }
    return TRUE ;
}

VOID
LocalGetConfigPageData(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_DEVICE_CONFIGURATION_PAGE *DeviceConfigPage,
       OUT  PULONG                      bufferSize
    )

/*++

Routine Description:

    This returns the pointers to the individule members of the
     MODE_DEVICE_CONFIG_PART_PAGE

Arguments:

    Srb                 - Supplies the SCSI request block.

    MinitapeExtension   - Supplies the minitape extension.

    ParameterListHeader - Return pointer to this portion of the page.

    ParameterListBlock  - Return pointer to this poriton of the page.

    DeviceConfigPage    - Return pointer to this portion of the page.

    bufferSize          - The size of the page.

Return Value:

    none

--*/
{
    PMODE_DEVICE_CONFIG_PAGE      configPage = Srb->DataBuffer ;
    PMODE_DEVICE_CONFIG_PAGE_PLUS configPagePlus = Srb->DataBuffer ;

    switch ( MinitapeExtension->DriveID ) {

        case DEC_TLZ09:
        case SONY_SDT2000 :
        case SONY_SDT4000 :
        case SONY_SDT5000 :
        case SONY_SDT5200 :
            *ParameterListHeader = &configPagePlus->ParameterListHeader ;
            *ParameterListBlock  = &configPagePlus->ParameterListBlock ;
            *DeviceConfigPage    = &configPagePlus->DeviceConfigPage ;
            *bufferSize          = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS) ;
            break ;

        default:
            *ParameterListHeader = &configPage->ParameterListHeader ;
            *ParameterListBlock  = NULL ;
            *DeviceConfigPage    = &configPage->DeviceConfigPage ;
            *bufferSize          = sizeof(MODE_DEVICE_CONFIG_PAGE) ;
            break ;
    }
    return ;
}

BOOLEAN
LocalAllocateCompressPage(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_DATA_COMPRESSION_PAGE *CompressPage,
       OUT  PULONG                      bufferSize
    )

/*++

Routine Description:

    This routine allocates and returns the pointers to the individule
     members of the MODE_DATA_COMPRESS_PAGE

Arguments:

    Srb                 - Supplies the SCSI request block.

    MinitapeExtension   - Supplies the minitape extension.

    ParameterListHeader - Return pointer to this portion of the page.

    ParameterListBlock  - Return pointer to this poriton of the page.

    CompressPage        - Return pointer to this portion of the page.

    bufferSize          - The size of the page.

Return Value:

    TRUE if the allocation was successful.

--*/
{
    ULONG size ;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    switch ( MinitapeExtension->DriveID ) {

        case DEC_TLZ09:
        case SONY_SDT2000 :
        case SONY_SDT4000 :
        case SONY_SDT5000 :
        case SONY_SDT5200 :
            size = sizeof(MODE_DATA_COMPRESS_PAGE_PLUS) ;
            break ;

        default:
            size = sizeof(MODE_DATA_COMPRESS_PAGE) ;
            cdb->MODE_SENSE.Dbd = SETBITON;
            break ;
    }

    if (!TapeClassAllocateSrbBuffer(Srb, size) ) {
         DebugPrint((1,"TapeCreatePartition: insufficient resources (ModeSel buffer)\n"));
         return FALSE ;

    } else {
         LocalGetCompressPageData( Srb,
                               MinitapeExtension,
                               ParameterListHeader,
                               ParameterListBlock,
                               CompressPage,
                               bufferSize ) ;

    }
    return TRUE ;
}

VOID
LocalGetCompressPageData(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_DATA_COMPRESSION_PAGE *CompressPage,
       OUT  PULONG                      bufferSize
    )

/*++

Routine Description:

    This returns the pointers to the individule members of the
     MODE_DEVICE_CONFIG_PART_PAGE

Arguments:

    Srb                 - Supplies the SCSI request block.

    MinitapeExtension   - Supplies the minitape extension.

    ParameterListHeader - Return pointer to this portion of the page.

    ParameterListBlock  - Return pointer to this poriton of the page.

    CompressPage        - Return pointer to this portion of the page.

    bufferSize          - The size of the page.

Return Value:

    none

--*/
{
    PMODE_DATA_COMPRESS_PAGE      compressPage = Srb->DataBuffer ;
    PMODE_DATA_COMPRESS_PAGE_PLUS compressPagePlus = Srb->DataBuffer ;

    switch ( MinitapeExtension->DriveID ) {

        case DEC_TLZ09:
        case SONY_SDT2000 :
        case SONY_SDT4000 :
        case SONY_SDT5000 :
        case SONY_SDT5200 :
            *ParameterListHeader = &compressPagePlus->ParameterListHeader ;
            *ParameterListBlock  = &compressPagePlus->ParameterListBlock ;
            *CompressPage        = &compressPagePlus->DataCompressPage ;
            *bufferSize          = sizeof(MODE_DATA_COMPRESS_PAGE_PLUS) ;
            break ;

        default:
            *ParameterListHeader = &compressPage->ParameterListHeader ;
            *ParameterListBlock  = NULL ;
            *CompressPage        = &compressPage->DataCompressPage ;
            *bufferSize          = sizeof(MODE_DATA_COMPRESS_PAGE) ;
            break ;
    }
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\class\physlogi.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    physlogi.c

Abstract:

    This module contains functions used specifically by tape drivers.
    It contains functions that do physical to pseudo-logical and pseudo-
    logical to physical tape block address/position translation.

Environment:

    kernel mode only

Revision History:

--*/

#include "ntddk.h"
#include "physlogi.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TapeClassPhysicalBlockToLogicalBlock)
#pragma alloc_text(PAGE, TapeClassLogicalBlockToPhysicalBlock)
#endif

//
// defines for various QIC physical tape format constants
//

#define  QIC_150_BOT_OFFSET  2
#define  QIC_525_PSEUDO_PHYSICAL_BLOCK_SIZE  512
#define  QIC_525_PHYSICAL_BLOCK_SIZE  1024
#define  QIC_525_DATA_BLKS_PER_FRAME  14
#define  QIC_525_ECC_BLKS_PER_FRAME  2
#define  QIC_525_BLKS_PER_FRAME  16
#define  QIC_525_BOT_OFFSET  16
#define  QIC_1350_PHYSICAL_BLOCK_SIZE  512
#define  QIC_1350_DATA_BLKS_PER_FRAME  52
#define  QIC_1350_ECC_BLKS_PER_FRAME  12
#define  QIC_1350_BLKS_PER_FRAME  64
#define  QIC_1350_BOT_OFFSET  64


ULONG
TapeClassPhysicalBlockToLogicalBlock(
    IN UCHAR DensityCode,
    IN ULONG PhysicalBlockAddress,
    IN ULONG BlockLength,
    IN BOOLEAN FromBOT
    )

/*++
Routine Description:

    This routine will translate from a QIC physical tape format
    specific physical/absolute block address to a pseudo-logical
    block address.

Arguments:

    DensityCode            // tape media density code
    PhysicalBlockAddress   // tape format specific tape block address
    BlockLength            // mode select/sense block length setting
    FromBOT                // true/false - translate from BOT

Return Value:

    ULONG

--*/

{
    ULONG logicalBlockAddress;
    ULONG frames;

    PAGED_CODE();

    logicalBlockAddress = PhysicalBlockAddress;

    switch ( DensityCode ) {
        case 0:
            logicalBlockAddress = 0xFFFFFFFF;
            break;

        case QIC_24:
            logicalBlockAddress--;
            break;

        case QIC_120:
            logicalBlockAddress--;
            break;

        case QIC_150:
            if (FromBOT) {
                if (logicalBlockAddress > QIC_150_BOT_OFFSET) {
                    logicalBlockAddress -= QIC_150_BOT_OFFSET;
                } else {
                    logicalBlockAddress = 0;
                }
            } else {
                logicalBlockAddress--;
            }
            break;

        case QIC_525:
        case QIC_1000:
        case QIC_2GB:
            if (FromBOT && (logicalBlockAddress >= QIC_525_BOT_OFFSET)) {
                logicalBlockAddress -= QIC_525_BOT_OFFSET;
            }
            if (logicalBlockAddress != 0) {
                frames = logicalBlockAddress/QIC_525_BLKS_PER_FRAME;
                logicalBlockAddress -= QIC_525_ECC_BLKS_PER_FRAME*frames;
                switch (BlockLength) {
                    case QIC_525_PHYSICAL_BLOCK_SIZE:
                        break;

                    case QIC_525_PSEUDO_PHYSICAL_BLOCK_SIZE:
                        logicalBlockAddress *= 2;
                        break;

                    default:
                        if (BlockLength > QIC_525_PHYSICAL_BLOCK_SIZE) {
                            if ((BlockLength%QIC_525_PHYSICAL_BLOCK_SIZE) == 0) {
                                logicalBlockAddress /=
                                    BlockLength/QIC_525_PHYSICAL_BLOCK_SIZE;
                            } else {
                                logicalBlockAddress /=
                                    1+(BlockLength/QIC_525_PHYSICAL_BLOCK_SIZE);
                            }
                        }
                        break;
                }
            }
            break;

        case QIC_1350:
        case QIC_2100:
            if (FromBOT && (logicalBlockAddress >= QIC_1350_BOT_OFFSET)) {
                logicalBlockAddress -= QIC_1350_BOT_OFFSET;
            }
            if (logicalBlockAddress != 0) {
                frames = logicalBlockAddress/QIC_1350_BLKS_PER_FRAME;
                logicalBlockAddress -= QIC_1350_ECC_BLKS_PER_FRAME*frames;
                if (BlockLength > QIC_1350_PHYSICAL_BLOCK_SIZE) {
                    if ((BlockLength%QIC_1350_PHYSICAL_BLOCK_SIZE) == 0) {
                        logicalBlockAddress /=
                            BlockLength/QIC_1350_PHYSICAL_BLOCK_SIZE;
                    } else {
                        logicalBlockAddress /=
                            1+(BlockLength/QIC_1350_PHYSICAL_BLOCK_SIZE);
                    }
                }
            }
            break;
    }

    return logicalBlockAddress;

} // end TapeClassPhysicalBlockToLogicalBlock()


TAPE_PHYS_POSITION
TapeClassLogicalBlockToPhysicalBlock(
    IN UCHAR DensityCode,
    IN ULONG LogicalBlockAddress,
    IN ULONG BlockLength,
    IN BOOLEAN FromBOT
    )

/*++
Routine Description:

    This routine will translate from a pseudo-logical block address
    to a QIC physical tape format specific physical/absolute block
    address and (space) block delta.

Arguments:

    DensityCode            // tape media density code
    LogicalBlockAddress    // pseudo-logical tape block address
    BlockLength            // mode select/sense block length setting
    FromBOT                // true/false - translate from BOT

Return Value:

    TAPE_PHYS_POSITION info/structure

--*/

{
    TAPE_PHYS_POSITION physPosition;
    ULONG physicalBlockAddress;
    ULONG remainder = 0;
    ULONG frames;

    PAGED_CODE();

    physicalBlockAddress = LogicalBlockAddress;

    switch ( DensityCode ) {
        case 0:
            physicalBlockAddress = 0xFFFFFFFF;
            break;

        case QIC_24:
            physicalBlockAddress++;
            break;

        case QIC_120:
            physicalBlockAddress++;
            break;

        case QIC_150:
            if (FromBOT) {
                physicalBlockAddress += QIC_150_BOT_OFFSET;
            } else {
                physicalBlockAddress++;
            }
            break;

        case QIC_525:
        case QIC_1000:
        case QIC_2GB:
            if (physicalBlockAddress != 0) {
                switch (BlockLength) {
                    case QIC_525_PHYSICAL_BLOCK_SIZE:
                        break;

                    case QIC_525_PSEUDO_PHYSICAL_BLOCK_SIZE:
                        remainder = physicalBlockAddress & 0x00000001;
                        physicalBlockAddress >>= 1;
                        break;

                    default:
                        if (BlockLength > QIC_525_PHYSICAL_BLOCK_SIZE) {
                            if ((BlockLength%QIC_525_PHYSICAL_BLOCK_SIZE) == 0) {
                                physicalBlockAddress *=
                                    BlockLength/QIC_525_PHYSICAL_BLOCK_SIZE;
                            } else {
                                physicalBlockAddress *=
                                    1+(BlockLength/QIC_525_PHYSICAL_BLOCK_SIZE);
                            }
                        }
                        break;

                }
                frames = physicalBlockAddress/QIC_525_DATA_BLKS_PER_FRAME;
                physicalBlockAddress += QIC_525_ECC_BLKS_PER_FRAME*frames;
            }
            if (FromBOT) {
                physicalBlockAddress += QIC_525_BOT_OFFSET;
            }
            break;

        case QIC_1350:
        case QIC_2100:
            if (physicalBlockAddress != 0) {
                if (BlockLength > QIC_1350_PHYSICAL_BLOCK_SIZE) {
                    if ((BlockLength%QIC_1350_PHYSICAL_BLOCK_SIZE) == 0) {
                        physicalBlockAddress *=
                            BlockLength/QIC_1350_PHYSICAL_BLOCK_SIZE;
                    } else {
                        physicalBlockAddress *=
                            1+(BlockLength/QIC_1350_PHYSICAL_BLOCK_SIZE);
                    }
                }
                frames = physicalBlockAddress/QIC_1350_DATA_BLKS_PER_FRAME;
                physicalBlockAddress += QIC_1350_ECC_BLKS_PER_FRAME*frames;
            }
            if (FromBOT) {
                physicalBlockAddress += QIC_1350_BOT_OFFSET;
            }
            break;
    }

    physPosition.SeekBlockAddress = physicalBlockAddress;
    physPosition.SpaceBlockCount = remainder;

    return physPosition;

} // end TapeClassLogicalBlockToPhysicalBlock()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\4mmdat\4mmdat.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    4mmdat.h

Abstract:

    This file contains structures and defines that are used
    specifically for the tape drivers.

Revision History:

--*/

#ifndef _4MMDAT_H
#define _4MMDAT_H

//
//  Internal (module wide) defines that symbolize
//  various 4mm DAT "partitioned" states.
//
#define NOT_PARTITIONED        0  // must be zero -- != 0 means partitioned
#define SELECT_PARTITIONED     1
#define INITIATOR_PARTITIONED  2
#define FIXED_PARTITIONED      3

//
//  Internal (module wide) define that symbolizes
//  the 4mm DAT "no partitions" partition method.
//
#define NO_PARTITIONS  0xFFFFFFFF

#define DAT_SUPPORTED_TYPES 1

#define HP_ADSENSE_CLEANING_REQ 0x82

//
// Minitape extension definition.
//
typedef struct _MINITAPE_EXTENSION {
          ULONG DriveID ;
          ULONG CurrentPartition ;
          TAPE_ALERT_INFO_TYPE DriveAlertInfoType;
} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION ;


//
//  Internal (module wide) defines that symbolize
//  the 4mm DAT drives supported by this module.
//
#define SONY_SDT2000     31
#define SONY_SDT4000     32
#define SONY_SDT5000     33
#define SONY_SDT5200     34
#define SONY_SDT10000    35
//
//  Internal (module wide) defines that symbolize
//  the 4mm DAT drives supported by this module.
//
#define AIWA_GD201       1
#define ARCHIVE_PYTHON   2
#define ARCHIVE_IBM4326  3
#define ARCHIVE_4326     4
#define ARCHIVE_4322     5
#define ARCHIVE_4586     6
#define DEC_TLZ06        7
#define DEC_TLZ07        8
#define DEC_TLZ09        9
#define EXABYTE_4200    10
#define EXABYTE_4200C   11
#define HP_35470A       12
#define HP_35480A       13
#define HP_C1533A       14
#define HP_C1553A       15
#define HP_IBM35480A    16
#define IOMEGA_DAT4000  17
#define WANGDAT_1300    18
#define WANGDAT_3100    19
#define WANGDAT_3200    20
#define WANGDAT_3300DX  21
#define WANGDAT_3400DX  22
#define ARCHIVE_IBM4586 23
#define SEAGATE_DAT     24


//
// Request structure used to determine cleaning needs on some
// of the HP units.
//

typedef struct _HP_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FRUCode;
    UCHAR SenseKeySpecific;
    UCHAR DriveErrorCode[2];
    UCHAR Reserved2[3];
    UCHAR Reserved3 : 3;
    UCHAR CLN : 1;
    UCHAR Reserved4 : 4;
} HP_SENSE_DATA, *PHP_SENSE_DATA;


//
// Request structure used to determine cleaning needs on some
// of the SONY units (such as SDT-10000.
//

typedef struct _SONY_SENSE_DATA {
   UCHAR ErrorCode:7;
   UCHAR Valid:1;
   UCHAR SegmentNumber;
   UCHAR SenseKey:4;
   UCHAR Reserved1:1;
   UCHAR IncorrectLength:1;
   UCHAR EndOfMedia:1;
   UCHAR FileMark:1;
   UCHAR Information[4];
   UCHAR AdditionalSenseLength;
   UCHAR CommandSpecificInformation[4];
   UCHAR AdditionalSenseCode;
   UCHAR AdditionalSenseCodeQualifier;
   UCHAR FRUCode;
   UCHAR SenseKeySpecific[3];
   UCHAR Reserved2;
   UCHAR ReadWriteErrorCounter[3];
   UCHAR RemainingCapacity[4];
   UCHAR MEW : 1;
   UCHAR Reserved3 : 2;
   UCHAR CLN : 1;
   UCHAR Reserved4 : 4;
   UCHAR Reserved5;
} SONY_SENSE_DATA, *PSONY_SENSE_DATA;

//
// Error counter upper limits
//
#define TAPE_READ_ERROR_LIMIT        0x8000
#define TAPE_WRITE_ERROR_LIMIT       0x8000

#define TAPE_READ_WARNING_LIMIT      0x4000
#define TAPE_WRITE_WARNING_LIMIT     0x4000

//
// Defines for type of parameter
//
#define TotalCorrectedErrors            0x0003
#define TotalTimesAlgorithmProcessed    0x0004
#define TotalGroupsProcessed            0x0005
#define TotalUncorrectedErrors          0x0006

//
// Defines for Log Sense Pages
//

#define LOGSENSEPAGE0                        0x00
#define LOGSENSEPAGE2                        0x02
#define LOGSENSEPAGE3                        0x03
#define LOGSENSEPAGE30                       0x30
#define LOGSENSEPAGE31                       0x31

//
// Defined Log Sense Page Header
//

typedef struct _LOG_SENSE_PAGE_HEADER {

   UCHAR PageCode : 6;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR Length[2];           // [0]=MSB ... [1]=LSB

} LOG_SENSE_PAGE_HEADER, *PLOG_SENSE_PAGE_HEADER;


//
// Defined Log Sense Parameter Header
//

typedef struct _LOG_SENSE_PARAMETER_HEADER {

   UCHAR ParameterCode[2];    // [0]=MSB ... [1]=LSB
   UCHAR LPBit     : 1;
   UCHAR Reserved1 : 1;
   UCHAR TMCBit    : 2;
   UCHAR ETCBit    : 1;
   UCHAR TSDBit    : 1;
   UCHAR DSBit     : 1;
   UCHAR DUBit     : 1;
   UCHAR ParameterLength;

} LOG_SENSE_PARAMETER_HEADER, *PLOG_SENSE_PARAMETER_HEADER;


//
// Defined Log Page Information - statistical values, accounts
// for maximum parameter values that is returned for each page
//

typedef struct _LOG_SENSE_PAGE_INFORMATION {

   union {

       struct {
          UCHAR Page0;
          UCHAR Page2;
          UCHAR Page3;
          UCHAR Page30;
          UCHAR Page31;
       } PageData ;

       //
       // Allocate enough number of bytes for each counter (Page2 & Page3)
       // so that it'll cover all 4mmDAT drives. The routine that
       // processes the error counters takes care of actual number
       // of bytes in each error counter
       //
       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR ErrorsCorrectedWithoutDelay[4];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR ErrorsCorrectedWithDelay[4];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR TotalErrors[4];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR TotalErrorsCorrected[4];
          LOG_SENSE_PARAMETER_HEADER Parm5;
          UCHAR TotalTimesAlgoProcessed[4];
          LOG_SENSE_PARAMETER_HEADER Parm6;
          UCHAR TotalGroupsWritten[8];
          LOG_SENSE_PARAMETER_HEADER Parm7;
          UCHAR TotalErrorsUncorrected[4];
       } Page2 ;

       struct {
           LOG_SENSE_PARAMETER_HEADER Parm1;
           UCHAR ErrorsCorrectedWithoutDelay[4];
           LOG_SENSE_PARAMETER_HEADER Parm2;
           UCHAR ErrorsCorrectedWithDelay[4];
           LOG_SENSE_PARAMETER_HEADER Parm3;
           UCHAR TotalErrors[4];
           LOG_SENSE_PARAMETER_HEADER Parm4;
           UCHAR TotalErrorsCorrected[4];
           LOG_SENSE_PARAMETER_HEADER Parm5;
           UCHAR TotalTimesAlgoProcessed[4];
           LOG_SENSE_PARAMETER_HEADER Parm6;
           UCHAR TotalGroupsWritten[8];
           LOG_SENSE_PARAMETER_HEADER Parm7;
           UCHAR TotalErrorsUncorrected[4];
       } Page3 ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR CurrentGroupsWritten[3];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR CurrentRewrittenFrames[2];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR CurrentGroupsRead[3];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR CurrentECCC3Corrections[2];
          LOG_SENSE_PARAMETER_HEADER Parm5;
          UCHAR PreviousGroupsWritten[3];
          LOG_SENSE_PARAMETER_HEADER Parm6;
          UCHAR PreviousRewrittenFrames[2];
          LOG_SENSE_PARAMETER_HEADER Parm7;
          UCHAR PreviousGroupsRead[3];
          LOG_SENSE_PARAMETER_HEADER Parm8;
          UCHAR PreviousECCC3Corrections[2];
          LOG_SENSE_PARAMETER_HEADER Parm9;
          UCHAR TotalGroupsWritten[4];
          LOG_SENSE_PARAMETER_HEADER Parm10;
          UCHAR TotalRewritteFrames[3];
          LOG_SENSE_PARAMETER_HEADER Parm11;
          UCHAR TotalGroupsRead[4];
          LOG_SENSE_PARAMETER_HEADER Parm12;
          UCHAR TotalECCC3Corrections[3];
          LOG_SENSE_PARAMETER_HEADER Parm13;
          UCHAR LoadCount[2];
       } Page30 ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR RemainingCapacityPart0[4];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR RemainingCapacityPart1[4];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR MaximumCapacityPart0[4];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR MaximumCapacityPart1[4];
       } Page31 ;

   } LogSensePage;


} LOG_SENSE_PAGE_INFORMATION, *PLOG_SENSE_PAGE_INFORMATION;



//
// Defined Log Sense Parameter Format - statistical values, accounts
// for maximum parameter values that is returned
//

typedef struct _LOG_SENSE_PARAMETER_FORMAT {

   LOG_SENSE_PAGE_HEADER       LogSenseHeader;
   LOG_SENSE_PAGE_INFORMATION  LogSensePageInfo;

} LOG_SENSE_PARAMETER_FORMAT, *PLOG_SENSE_PARAMETER_FORMAT;

//
// Tape Alert Info format
//
typedef struct _TAPE_ALERT_INFO {
    UCHAR  ParamCodeUB; // Upper byte of the param code
    UCHAR  ParamCodeLB; // Lower byte of the param code
    UCHAR  BitFields;
    UCHAR  ParamLen;
    UCHAR  Flag;
} TAPE_ALERT_INFO, *PTAPE_ALERT_INFO;

//
//  Function prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData,
                         IN OUT PMINITAPE_EXTENSION miniExtension);

//
// Command extension definition.
//

typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

BOOLEAN
LocalAllocatePartPage(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_MEDIUM_PARTITION_PAGE *MediumPartPage,
       OUT  PULONG                      bufferSize
    );

VOID
LocalGetPartPageData(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_MEDIUM_PARTITION_PAGE *MediumPartPage,
       OUT  PULONG                      bufferSize
    ) ;

BOOLEAN
LocalAllocateConfigPage(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_DEVICE_CONFIGURATION_PAGE *DeviceConfigPage,
       OUT  PULONG                      bufferSize
    ) ;

VOID
LocalGetConfigPageData(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_DEVICE_CONFIGURATION_PAGE *DeviceConfigPage,
       OUT  PULONG                      bufferSize
    ) ;

BOOLEAN
LocalAllocateCompressPage(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_DATA_COMPRESSION_PAGE *CompressPage,
       OUT  PULONG                      bufferSize
    ) ;

VOID
LocalGetCompressPageData(
    IN OUT  PSCSI_REQUEST_BLOCK         Srb,
    IN OUT  PMINITAPE_EXTENSION         MinitapeExtension,
       OUT  PMODE_PARAMETER_HEADER      *ParameterListHeader,
       OUT  PMODE_PARAMETER_BLOCK       *ParameterListBlock,
       OUT  PMODE_DATA_COMPRESSION_PAGE *CompressPage,
       OUT  PULONG                      bufferSize
    ) ;

BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

#if 0
TAPE_STATUS
Verify(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );
#endif

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

//
// Internal routines for wmi
//

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
  );

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   );

#endif // _4MMDAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\class\tape.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    tape.h

Abstract:

    SCSI tape class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/
#ifndef _TAPE_H_
#define _TAPE_H_


#include "ntddk.h"
#include "newtape.h"
#include "classpnp.h"
#include <wmidata.h>
#include <wmistr.h>

#include "initguid.h"
#include "ntddstor.h"
#include "ioevent.h"
#include <stdarg.h>
#include <string.h>

//
// WMI guid list for tape.
//
extern GUIDREGINFO TapeWmiGuidList[];


//
// NT uses a system time measured in 100 nanosecond intervals.  
// Define convenient constant for the timer routines.
//
#define ONE_SECOND          (10 * 1000 * 1000) 

//
// Time interval between two drive clean notification - 1 Hour
//
#define TAPE_DRIVE_CLEAN_NOTIFICATION_INTERVAL 60 * 60

//
// Poll the tape drive every one hour
//
#define TAPE_DRIVE_POLLING_PERIOD  60 * 60

//
// Macro to update block size. 
// If the given blocksize is not a power of 2, this macro
// sets the blocksize to the next lower power of 2
//

#define UPDATE_BLOCK_SIZE(BlockSize)                                       \
    {                                                                      \
      ULONG newBlockSize;                                                  \
      ULONG count;                                                         \
                                                                           \
      newBlockSize = BlockSize;                                            \
      if ((newBlockSize & (newBlockSize - 1)) != 0) {                      \
                                                                           \
          count = 0;                                                       \
          while (newBlockSize > 0) {                                       \
              newBlockSize >>= 1;                                          \
              count++;                                                     \
          }                                                                \
                                                                           \
          if (count > 0) {                                                 \
              BlockSize = 1 << (count - 1);                                \
          }                                                                \
      }                                                                    \
    }                                                               

//
// Tape class driver extension
//
typedef struct _TAPE_DATA {
    TAPE_INIT_DATA_EX TapeInitData;
    KSPIN_LOCK SplitRequestSpinLock;
    LARGE_INTEGER LastDriveCleanRequestTime;
    UNICODE_STRING TapeInterfaceString;
    ULONG   SrbTimeoutDelta;
    BOOLEAN DosNameCreated;
} TAPE_DATA, *PTAPE_DATA;

//
// WMI routines
//
NTSTATUS
TapeQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    );

NTSTATUS
TapeQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
TapeSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
TapeSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
TapeExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
TapeWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    );

//
// Internal routines
//

NTSTATUS
TapeWMIControl(
  IN PDEVICE_OBJECT DeviceObject,
  IN TAPE_PROCESS_COMMAND_ROUTINE commandRoutine,
  IN PUCHAR Buffer
  );

VOID
ScsiTapeFreeSrbBuffer(
    IN OUT  PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
ScsiTapeTapeStatusToNtStatus(
    IN  TAPE_STATUS TapeStatus,
    OUT PNTSTATUS   NtStatus
    );

BOOLEAN
ScsiTapeNtStatusToTapeStatus(
    IN  NTSTATUS        NtStatus,
    OUT PTAPE_STATUS    TapeStatus
    );

NTSTATUS
TapeEnableDisableDrivePolling(
    IN PFUNCTIONAL_DEVICE_EXTENSION fdoExtension, 
    IN BOOLEAN Enable,
    IN ULONG PollingTimeInSeconds
    );

ULONG
GetTimeoutDeltaFromRegistry(
    IN PDEVICE_OBJECT LowerPdo
    );

#endif // _TAPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\4mmsony\4mmsony.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       4mmsony.h
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1993  Conner Peripherals Inc.

Module Name:

    4mmsony.h

Abstract:

    This file contains structures and defines that are used
    specifically for the 4mmsony.sys tape driver.

Author:

    Mike Colandreo (Conner Software)

Revision History:


    $Log$


--*/

#include "scsi.h"
#include "class.h"

//
// Define the maximum inquiry data length.
//

#define MAXIMUM_TAPE_INQUIRY_DATA 252

//
// Tape device data
//

typedef struct _TAPE_DATA {
     ULONG               Flags;
     ULONG               CurrentPartition;
     PVOID               DeviceSpecificExtension;
     PSCSI_INQUIRY_DATA  InquiryData;
} TAPE_DATA, *PTAPE_DATA;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION) + sizeof(TAPE_DATA)


//
// Define Device Configuration Page
//

typedef struct _MODE_DEVICE_CONFIGURATION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR ActiveFormat : 5;
    UCHAR CAFBit : 1;
    UCHAR CAPBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR ActivePartition;
    UCHAR WriteBufferFullRatio;
    UCHAR ReadBufferEmptyRatio;
    UCHAR WriteDelayTime[2];
    UCHAR REW : 1;
    UCHAR RBO : 1;
    UCHAR SOCF : 2;
    UCHAR AVC : 1;
    UCHAR RSmk : 1;
    UCHAR BIS : 1;
    UCHAR DBR : 1;
    UCHAR GapSize;
    UCHAR Reserved3 : 3;
    UCHAR SEW : 1;
    UCHAR EEG : 1;
    UCHAR EODdefined : 3;
    UCHAR BufferSize[3];
    UCHAR DCAlgorithm;
    UCHAR Reserved4;

} MODE_DEVICE_CONFIGURATION_PAGE, *PMODE_DEVICE_CONFIGURATION_PAGE;

//
// Define Medium Partition Page
//

typedef struct _MODE_MEDIUM_PARTITION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR MaximumAdditionalPartitions;
    UCHAR AdditionalPartitionDefined;
    UCHAR Reserved2 : 3;
    UCHAR PSUMBit : 2;
    UCHAR IDPBit : 1;
    UCHAR SDPBit : 1;
    UCHAR FDPBit : 1;
    UCHAR MediumFormatRecognition;
    UCHAR Reserved3[2];
    UCHAR Partition0Size[2];
    UCHAR Partition1Size[2];

} MODE_MEDIUM_PARTITION_PAGE, *PMODE_MEDIUM_PARTITION_PAGE;

//
// Define Data Compression Page
//

typedef struct _MODE_DATA_COMPRESSION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2 : 6;
    UCHAR DCC : 1;
    UCHAR DCE : 1;
    UCHAR Reserved3 : 5;
    UCHAR RED : 2;
    UCHAR DDE : 1;
    UCHAR CompressionAlgorithm[4];
    UCHAR DecompressionAlgorithm[4];
    UCHAR Reserved4[4];

} MODE_DATA_COMPRESSION_PAGE, *PMODE_DATA_COMPRESSION_PAGE;

//
// Mode parameter list header and medium partition page -
// used in creating partitions
//

typedef struct _MODE_MEDIUM_PART_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE, *PMODE_MEDIUM_PART_PAGE;


//
// Mode parameters for retrieving tape or media information
//

typedef struct _MODE_TAPE_MEDIA_INFORMATION {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_TAPE_MEDIA_INFORMATION, *PMODE_TAPE_MEDIA_INFORMATION;

//
// Mode parameter list header and device configuration page -
// used in retrieving device configuration information
//

typedef struct _MODE_DEVICE_CONFIG_PAGE {

   MODE_PARAMETER_HEADER           ParameterListHeader;
   MODE_PARAMETER_BLOCK            ParameterListBlock;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE, *PMODE_DEVICE_CONFIG_PAGE;


//
// Mode parameter list header and data compression page -
// used in retrieving data compression information
//

typedef struct _MODE_DATA_COMPRESS_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE, *PMODE_DATA_COMPRESS_PAGE;

//
// Defines for Log Sense Pages
//

#define LOGSENSEPAGE0                        0x00
#define LOGSENSEPAGE2                        0x02
#define LOGSENSEPAGE3                        0x03
#define LOGSENSEPAGE30                       0x30
#define LOGSENSEPAGE31                       0x31

//
// Defined Log Sense Page Header
//

typedef struct _LOG_SENSE_PAGE_HEADER {

   UCHAR PageCode : 6;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR Length[2];           // [0]=MSB ... [1]=LSB

} LOG_SENSE_PAGE_HEADER, *PLOG_SENSE_PAGE_HEADER;


//
// Defined Log Sense Parameter Header
//

typedef struct _LOG_SENSE_PARAMETER_HEADER {

   UCHAR ParameterCode[2];    // [0]=MSB ... [1]=LSB
   UCHAR LPBit     : 1;
   UCHAR Reserved1 : 1;
   UCHAR TMCBit    : 2;
   UCHAR ETCBit    : 1;
   UCHAR TSDBit    : 1;
   UCHAR DSBit     : 1;
   UCHAR DUBit     : 1;
   UCHAR ParameterLength;

} LOG_SENSE_PARAMETER_HEADER, *PLOG_SENSE_PARAMETER_HEADER;


//
// Defined Log Page Information - statistical values, accounts
// for maximum parameter values that is returned for each page
//

typedef struct _LOG_SENSE_PAGE_INFORMATION {

   union {

       struct {
          UCHAR Page0;
          UCHAR Page2;
          UCHAR Page3;
          UCHAR Page30;
          UCHAR Page31;
       } PageData ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR TotalRewrites[2];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR TotalErrorCorrected[3];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR NotApplicable[2];    // Always 0
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR TotalBytesProcessed[4];
          LOG_SENSE_PARAMETER_HEADER Parm5;
          UCHAR TotalUnrecoverableErrors[2];
          LOG_SENSE_PARAMETER_HEADER Parm6;
          UCHAR RewritesLastReadOp[2];
       } Page2 ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR TotalRereads[2];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR TotalErrorCorrected[3];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR TotalCorrectableECCC3[2];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR TotalBytesProcessed[4];
          LOG_SENSE_PARAMETER_HEADER Parm5;
          UCHAR TotalUnrecoverableErrors[2];
          LOG_SENSE_PARAMETER_HEADER Parm6;
          UCHAR RereadsLastWriteOp[2];
       } Page3 ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR CurrentGroupsWritten[3];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR CurrentRewrittenFrames[2];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR CurrentGroupsRead[3];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR CurrentECCC3Corrections[2];
          LOG_SENSE_PARAMETER_HEADER Parm5;
          UCHAR PreviousGroupsWritten[3];
          LOG_SENSE_PARAMETER_HEADER Parm6;
          UCHAR PreviousRewrittenFrames[2];
          LOG_SENSE_PARAMETER_HEADER Parm7;
          UCHAR PreviousGroupsRead[3];
          LOG_SENSE_PARAMETER_HEADER Parm8;
          UCHAR PreviousECCC3Corrections[2];
          LOG_SENSE_PARAMETER_HEADER Parm9;
          UCHAR TotalGroupsWritten[4];
          LOG_SENSE_PARAMETER_HEADER Parm10;
          UCHAR TotalRewritteFrames[3];
          LOG_SENSE_PARAMETER_HEADER Parm11;
          UCHAR TotalGroupsRead[4];
          LOG_SENSE_PARAMETER_HEADER Parm12;
          UCHAR TotalECCC3Corrections[3];
          LOG_SENSE_PARAMETER_HEADER Parm13;
          UCHAR LoadCount[2];
       } Page30 ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR RemainingCapacityPart0[4];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR RemainingCapacityPart1[4];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR MaximumCapacityPart0[4];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR MaximumCapacityPart1[4];
       } Page31 ;

   } LogSensePage;


} LOG_SENSE_PAGE_INFORMATION, *PLOG_SENSE_PAGE_INFORMATION;



//
// Defined Log Sense Parameter Format - statistical values, accounts
// for maximum parameter values that is returned
//

typedef struct _LOG_SENSE_PARAMETER_FORMAT {

   LOG_SENSE_PAGE_HEADER       LogSenseHeader;
   LOG_SENSE_PAGE_INFORMATION  LogSensePageInfo;

} LOG_SENSE_PARAMETER_FORMAT, *PLOG_SENSE_PARAMETER_FORMAT;


NTSTATUS
TapeCreatePartition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeErase(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
TapeError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
TapeGetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapePrepare(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
TapeVerifyInquiry(
    IN PSCSI_INQUIRY_DATA LunInfo
    );

NTSTATUS
TapeWriteMarks(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\4mmsony\4mmsony.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       4mmsony.c
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1994  Arcada Software Inc. - All rights reserved

Module Name:

    4mmsony.c

Abstract:

    This module contains device-specific routines for 4mm DAT drives:
    SONY SDT-2000, SONY SDT-4000, SDT-5000, and SDT-5200.

Author:

    Mike Colandreo (Arcada Software)

Environment:

    kernel mode only

Revision History:


    $Log$


--*/

#include "ntddk.h"
#include "4mmsony.h"

//
//  Internal (module wide) defines that symbolize
//  the 4mm DAT drives supported by this module.
//
#define SONY_SDT2000     1
#define SONY_SDT4000     2
#define SONY_SDT5000     3
#define SONY_SDT5200     4

//
//  Internal (module wide) defines that symbolize
//  various 4mm DAT "partitioned" states.
//
#define NOT_PARTITIONED        0  // must be zero -- != 0 means partitioned
#define SELECT_PARTITIONED     1
#define INITIATOR_PARTITIONED  2
#define FIXED_PARTITIONED      3

//
//  Internal (module wide) define that symbolizes
//  the 4mm DAT "no partitions" partition method.
//
#define NO_PARTITIONS  0xFFFFFFFF

//
//  Function prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);


NTSTATUS
TapeCreatePartition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine creates partitions on a 4mm DAT tape or returns
    the tape to a not partitioned state (where the whole, entire
    tape is a single, and the only, "partition").

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION        deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_CREATE_PARTITION   tapePartition = Irp->AssociatedIrp.SystemBuffer;
    PTAPE_DATA               tapeData = (PTAPE_DATA)(deviceExtension + 1);
    PMODE_DEVICE_CONFIG_PAGE deviceConfigModeSenseBuffer;
    PMODE_MEDIUM_PART_PAGE   modeSelectBuffer;
    ULONG                    partitionMethod;
    ULONG                    partitionCount;
    ULONG                    partition;
    SCSI_REQUEST_BLOCK       srb;
    PCDB                     cdb = (PCDB)srb.Cdb;
    NTSTATUS                 status = STATUS_SUCCESS;


    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeCreatePartition: SendSrb (test unit ready)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeCreatePartition: test unit ready, SendSrb unsuccessful\n"));
        return status;
    }

    partitionMethod = tapePartition->Method;
    partitionCount  = tapePartition->Count;

    //
    //  Filter out invalid partition counts.
    //

    switch (partitionCount) {
        case 0:
            partitionMethod = NO_PARTITIONS;
            break;

        case 1:
        case 2:
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeCreatePartition: "));
        DebugPrint((1,"partitionCount -- invalid request\n"));
        return status;
    }

    //
    //  Filter out the partition methods that
    //  are not implemented on the Sony drives.
    //

    switch (partitionMethod) {
        case TAPE_FIXED_PARTITIONS:
            DebugPrint((3,"TapeCreatePartition: fixed partitions\n"));
            status = STATUS_NOT_IMPLEMENTED;
            break;

        case TAPE_SELECT_PARTITIONS:
            DebugPrint((3,"TapeCreatePartition: select partitions\n"));
            status = STATUS_NOT_IMPLEMENTED;
            break;

        case TAPE_INITIATOR_PARTITIONS:
            DebugPrint((3,"TapeCreatePartition: initiator partitions\n"));
            if (--partitionCount == 0) {

                DebugPrint((3,"TapeCreatePartition: no partitions\n"));
                partitionMethod = NO_PARTITIONS;

            }
            break;

        case NO_PARTITIONS:
            DebugPrint((3,"TapeCreatePartition: no partitions\n"));
            partitionCount = 0;
            break;

        default:
            status = STATUS_NOT_IMPLEMENTED;
            break;
    }

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeCreatePartition: "));
        DebugPrint((1,"partitionMethod -- operation not supported\n"));
        return status;
    }

    modeSelectBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                      sizeof(MODE_MEDIUM_PART_PAGE));

    if (!modeSelectBuffer) {
        DebugPrint((1,"TapeCreatePartition: insufficient resources (modeSelectBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeSelectBuffer, sizeof(MODE_MEDIUM_PART_PAGE));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.AllocationLength = 12;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeCreatePartition: SendSrb (mode sense)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         modeSelectBuffer,
                                         12,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeCreatePartition: mode sense, SendSrb unsuccessful\n"));
        return status;
    }

    modeSelectBuffer->ParameterListHeader.ModeDataLength = 0;
    modeSelectBuffer->ParameterListHeader.MediumType = 0;
    modeSelectBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;

    modeSelectBuffer->ParameterListBlock.DensityCode = 0x7F;

    modeSelectBuffer->MediumPartPage.PageCode = MODE_PAGE_MEDIUM_PARTITION;
    modeSelectBuffer->MediumPartPage.PageLength = 10;
    modeSelectBuffer->MediumPartPage.AdditionalPartitionDefined = (CHAR)partitionCount;
    modeSelectBuffer->MediumPartPage.PSUMBit = 2;
    modeSelectBuffer->MediumPartPage.IDPBit  = SETBITON;
    modeSelectBuffer->MediumPartPage.MediumFormatRecognition = 3;
    if (partitionCount) {
        partition = INITIATOR_PARTITIONED;
        modeSelectBuffer->MediumPartPage.Partition1Size[0] =
            (CHAR)((tapePartition->Size >> 8) & 0xFF);
        modeSelectBuffer->MediumPartPage.Partition1Size[1] =
            (CHAR)(tapePartition->Size & 0xFF);
    } else {
        partition = NOT_PARTITIONED;
    }

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.PFBit = SETBITON;
    cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_MEDIUM_PART_PAGE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 16500;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeCreatePartition: SendSrb (mode select)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         modeSelectBuffer,
                                         sizeof(MODE_MEDIUM_PART_PAGE),
                                         TRUE);

    ExFreePool(modeSelectBuffer);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeCreatePartition: mode select, SendSrb unsuccessful\n"));
        return status;
    }

    tapeData->CurrentPartition = partition;

    if (partition != NOT_PARTITIONED) {

        deviceConfigModeSenseBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                                     sizeof(MODE_DEVICE_CONFIG_PAGE));

        if (!deviceConfigModeSenseBuffer) {
            DebugPrint((1,"TapeCreatePartition: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(deviceConfigModeSenseBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE));

        //
        // Zero CDB in SRB on stack.
        //

        RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        srb.CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = deviceExtension->TimeOutValue;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode sense)\n"));

        status = ScsiClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             deviceConfigModeSenseBuffer,
                                             sizeof(MODE_DEVICE_CONFIG_PAGE),
                                             FALSE);

        ExFreePool(deviceConfigModeSenseBuffer);

        if (!NT_SUCCESS(status)) {
            DebugPrint((1,"TapeCreatePartition: mode sense, SendSrb unsuccessful\n"));
            return status;
        }

        tapeData->CurrentPartition =
            deviceConfigModeSenseBuffer->DeviceConfigPage.ActivePartition + 1;

    }

    return status;

} // end TapeCreatePartition()


NTSTATUS
TapeErase(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine "erases" tape: a "short" erase simply writes on
    tape at its current position in a manner which causes an "End
    of Data" condition to be indicated if/when a subsequent read
    is done at, into, or over that point on tape; a "long" erase
    writes an "erase" data pattern on tape at/from its current
    position and on until End of Partition (End of Tape if the
    tape is not partitioned).

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_ERASE         tapeErase = Irp->AssociatedIrp.SystemBuffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (tapeErase->Immediate) {
        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
            case TAPE_ERASE_SHORT:
                DebugPrint((3,"TapeErase: immediate\n"));
                break;

            default:
                DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                return STATUS_NOT_IMPLEMENTED;
        }
    }

    switch (tapeErase->Type) {
        case TAPE_ERASE_LONG:
            DebugPrint((3,"TapeErase: long\n"));
            break;

        case TAPE_ERASE_SHORT:
            DebugPrint((3,"TapeErase: short\n"));
            break;

        default:
            DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
            return STATUS_NOT_IMPLEMENTED;
    }

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->ERASE.OperationCode = SCSIOP_ERASE;
    cdb->ERASE.Immediate = tapeErase->Immediate;
    if (tapeErase->Type == TAPE_ERASE_LONG) {
        cdb->ERASE.Long = SETBITON;
    } else {
        cdb->ERASE.Long = SETBITOFF;
    }

    //
    // Set timeout value.
    //

    if (tapeErase->Type == TAPE_ERASE_LONG) {
        srb.TimeOutValue = 16500;
    } else {
        srb.TimeOutValue = deviceExtension->TimeOutValue;
    }

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                NULL,
                                0,
                                FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeErase: erase, SendSrb unsuccessful\n"));
    }

    return status;

} // end TapeErase()


VOID
TapeError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    When a request completes with error, the routine InterpretSenseInfo
    is called to examine the sense data, determine whether the request
    should be retried, and store an NT status in the IRP. This routine
    is thence called, if the request was a tape request, to handle tape
    specific errors: it may/can update the NT status and/or the retry
    boolean for tape specific conditions.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - NT Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PSENSE_DATA        senseBuffer = Srb->SenseInfoBuffer;
    NTSTATUS           status = *Status;
    BOOLEAN            retry = *Retry;
    UCHAR              adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
    UCHAR              adsense = senseBuffer->AdditionalSenseCode;

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X, Retry %d\n", status, retry));

    if (status == STATUS_DEVICE_NOT_READY) {
        if ((adsense == SCSI_ADSENSE_LUN_NOT_READY) &&
            (adsenseq == SCSI_SENSEQ_BECOMING_READY) ) {

            *Status = STATUS_NO_MEDIA;
            *Retry = FALSE;

        }
    }

    if (status == STATUS_IO_DEVICE_ERROR) {
        if ((senseBuffer->SenseKey & 0x0F) == SCSI_SENSE_ABORTED_COMMAND) {

            *Status = STATUS_DEVICE_NOT_READY;
            *Retry = TRUE;

        }
    }

    DebugPrint((1,"TapeError: Status 0x%.8X, Retry %d\n", *Status, *Retry));

    return;

} // end TapeError()


NTSTATUS
TapeGetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine determines and returns the "drive parameters" of the
    4mm DAT drive associated with "DeviceObject": Set Mark reporting
    enabled/disabled, default block size, maximum block size, minimum
    block size, maximum number of partitions, device features flags,
    etc. From time to time, this set of drive parameters for a given
    drive is variable. It changes as drive operating characteristics
    change: e.g., tape media type loaded, recording density and/or
    recording mode of the media type loaded, etc.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION          deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_GET_DRIVE_PARAMETERS tapeGetDriveParams = Irp->AssociatedIrp.SystemBuffer;
    PMODE_DEVICE_CONFIG_PAGE   deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE   compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA    blockLimitsBuffer;
    SCSI_REQUEST_BLOCK         srb;
    PCDB                       cdb = (PCDB)srb.Cdb;
    NTSTATUS                   status;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    RtlZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));
    Irp->IoStatus.Information = sizeof(TAPE_GET_DRIVE_PARAMETERS);

    deviceConfigModeSenseBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                                 sizeof(MODE_DEVICE_CONFIG_PAGE));

    if (!deviceConfigModeSenseBuffer) {
        DebugPrint((1,"TapeGetDriveParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceConfigModeSenseBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
    cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         deviceConfigModeSenseBuffer,
                                         sizeof(MODE_DEVICE_CONFIG_PAGE),
                                         FALSE);

    if (status == STATUS_NO_MEDIA) {

        status = STATUS_SUCCESS;

    }

    if (NT_SUCCESS(status)) {

        tapeGetDriveParams->ReportSetmarks =
            (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk? 1 : 0 );

    }

    ExFreePool(deviceConfigModeSenseBuffer);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetDriveParameters: mode sense, SendSrb unsuccessful\n"));
        return status;
    }

    compressionModeSenseBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                                sizeof(MODE_DATA_COMPRESS_PAGE));

    if (!compressionModeSenseBuffer) {
        DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(compressionModeSenseBuffer, sizeof(MODE_DATA_COMPRESS_PAGE));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
    cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         compressionModeSenseBuffer,
                                         sizeof(MODE_DATA_COMPRESS_PAGE),
                                         FALSE);

    if (status == STATUS_NO_MEDIA) {

        status = STATUS_SUCCESS;

    }

    if (NT_SUCCESS(status)) {

        if (compressionModeSenseBuffer->DataCompressPage.DCC) {

            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
                (compressionModeSenseBuffer->DataCompressPage.DCE? TRUE : FALSE);

            if (!compressionModeSenseBuffer->DataCompressPage.DDE) {

                compressionModeSenseBuffer->ParameterListHeader.ModeDataLength = 0;
                compressionModeSenseBuffer->ParameterListHeader.MediumType = 0;
                compressionModeSenseBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;

                compressionModeSenseBuffer->ParameterListBlock.DensityCode = 0x7F;

                compressionModeSenseBuffer->DataCompressPage.DDE = SETBITON;

                //
                // Zero CDB in SRB on stack.
                //

                RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                srb.CdbLength = CDB6GENERIC_LENGTH;

                cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
                cdb->MODE_SELECT.PFBit = SETBITON;
                cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

                //
                // Set timeout value.
                //

                srb.TimeOutValue = deviceExtension->TimeOutValue;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode select)\n"));

                status = ScsiClassSendSrbSynchronous(DeviceObject,
                                                     &srb,
                                                     compressionModeSenseBuffer,
                                                     sizeof(MODE_DATA_COMPRESS_PAGE),
                                                     TRUE);

                if (!NT_SUCCESS(status)) {
                    DebugPrint((1,"TapeGetDriveParameters: mode select, SendSrb unsuccessful\n"));
                    ExFreePool(compressionModeSenseBuffer);
                    return status;
                }

            }

        }

    }

    ExFreePool(compressionModeSenseBuffer);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetDriveParameters: mode sense, SendSrb unsuccessful\n"));
        return status;
    }

    blockLimitsBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                       sizeof(READ_BLOCK_LIMITS_DATA));

    if (!blockLimitsBuffer) {
        DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimitsBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(blockLimitsBuffer, sizeof(READ_BLOCK_LIMITS_DATA));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         blockLimitsBuffer,
                                         sizeof(READ_BLOCK_LIMITS_DATA),
                                         FALSE);

    if (status == STATUS_NO_MEDIA) {

        status = STATUS_SUCCESS;

    }

    if (NT_SUCCESS(status)) {

        tapeGetDriveParams->MaximumBlockSize  = blockLimitsBuffer->BlockMaximumSize[2];
        tapeGetDriveParams->MaximumBlockSize += (blockLimitsBuffer->BlockMaximumSize[1] << 8);
        tapeGetDriveParams->MaximumBlockSize += (blockLimitsBuffer->BlockMaximumSize[0] << 16);

        tapeGetDriveParams->MinimumBlockSize  = blockLimitsBuffer->BlockMinimumSize[1];
        tapeGetDriveParams->MinimumBlockSize += (blockLimitsBuffer->BlockMinimumSize[0] << 8);

    }

    ExFreePool(blockLimitsBuffer);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetDriveParameters: read block limits, SendSrb unsuccessful\n"));
        return status;
    }

    tapeGetDriveParams->DefaultBlockSize = 0x200;
    tapeGetDriveParams->MaximumPartitionCount = 2;

    tapeGetDriveParams->FeaturesLow |=
        TAPE_DRIVE_INITIATOR |
        TAPE_DRIVE_ERASE_SHORT |
        TAPE_DRIVE_ERASE_LONG |
        TAPE_DRIVE_ERASE_IMMEDIATE |
        TAPE_DRIVE_TAPE_CAPACITY |
        TAPE_DRIVE_FIXED_BLOCK |
        TAPE_DRIVE_VARIABLE_BLOCK |
        TAPE_DRIVE_WRITE_PROTECT |
        TAPE_DRIVE_REPORT_SMKS |
        TAPE_DRIVE_GET_ABSOLUTE_BLK |
        TAPE_DRIVE_GET_LOGICAL_BLK;

    tapeGetDriveParams->FeaturesHigh |=
        TAPE_DRIVE_LOAD_UNLOAD |
        TAPE_DRIVE_TENSION |
        TAPE_DRIVE_LOCK_UNLOCK |
        TAPE_DRIVE_REWIND_IMMEDIATE |
        TAPE_DRIVE_SET_BLOCK_SIZE |
        TAPE_DRIVE_LOAD_UNLD_IMMED |
        TAPE_DRIVE_TENSION_IMMED |
        TAPE_DRIVE_SET_REPORT_SMKS |
        TAPE_DRIVE_ABSOLUTE_BLK |
        TAPE_DRIVE_ABS_BLK_IMMED |
        TAPE_DRIVE_LOGICAL_BLK |
        TAPE_DRIVE_LOG_BLK_IMMED |
        TAPE_DRIVE_END_OF_DATA |
        TAPE_DRIVE_RELATIVE_BLKS |
        TAPE_DRIVE_FILEMARKS |
        TAPE_DRIVE_SEQUENTIAL_FMKS |
        TAPE_DRIVE_SETMARKS |
        TAPE_DRIVE_SEQUENTIAL_SMKS |
        TAPE_DRIVE_REVERSE_POSITION |
        TAPE_DRIVE_WRITE_SETMARKS |
        TAPE_DRIVE_WRITE_FILEMARKS |
        TAPE_DRIVE_WRITE_MARK_IMMED;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
        tapeGetDriveParams->FeaturesLow));
    DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
        tapeGetDriveParams->FeaturesHigh));

    return status;

} // end TapeGetDriveParameters()


NTSTATUS
TapeGetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine determines and returns the "media parameters" of a
    tape in the 4mm DAT drive associated with "DeviceObject": maximum
    tape capacity, remaining tape capacity, block size, number of
    partitions, write protect indicator, etc. Tape media must be
    present (loaded) in the drive for this function to return "no
    error".


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION            deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_DATA                   tapeData = (PTAPE_DATA)(deviceExtension + 1);
    PTAPE_GET_MEDIA_PARAMETERS   tapeGetMediaParams = Irp->AssociatedIrp.SystemBuffer;
    PMODE_DEVICE_CONFIG_PAGE     deviceConfigModeSenseBuffer;
    PMODE_TAPE_MEDIA_INFORMATION modeSenseBuffer;
    LARGE_INTEGER                remaining;
    LARGE_INTEGER                capacity;
    ULONG                        partitionCount;
    ULONG                        partition;
    SCSI_REQUEST_BLOCK           srb;
    PCDB                         cdb = (PCDB)srb.Cdb;
    NTSTATUS                     status;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    RtlZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));
    Irp->IoStatus.Information = sizeof(TAPE_GET_MEDIA_PARAMETERS);

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetMediaParameters: SendSrb (test unit ready)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetMediaParameters: test unit ready, SendSrb unsuccessful\n"));
        return status;
    }

    deviceConfigModeSenseBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                                 sizeof(MODE_DEVICE_CONFIG_PAGE));

    if (!deviceConfigModeSenseBuffer) {
        DebugPrint((1,"TapeGetMediaParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceConfigModeSenseBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
    cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         deviceConfigModeSenseBuffer,
                                         sizeof(MODE_DEVICE_CONFIG_PAGE),
                                         FALSE);

    if (NT_SUCCESS(status)) {

        partition = deviceConfigModeSenseBuffer->DeviceConfigPage.ActivePartition;

    }

    ExFreePool(deviceConfigModeSenseBuffer);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetMediaParameters: mode sense, SendSrb unsuccessful\n"));
        return status;
    }

    modeSenseBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                     sizeof(MODE_TAPE_MEDIA_INFORMATION));

    if (!modeSenseBuffer) {
        DebugPrint((1,"TapeGetMediaParameters: insufficient resources (modeSenseBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeSenseBuffer, sizeof(MODE_TAPE_MEDIA_INFORMATION));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
    cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         modeSenseBuffer,
                                         sizeof(MODE_TAPE_MEDIA_INFORMATION),
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetMediaParameters: mode sense, SendSrb unsuccessful\n"));
        ExFreePool(modeSenseBuffer);
        return status;
    }

    tapeGetMediaParams->BlockSize  = modeSenseBuffer->ParameterListBlock.BlockLength[2];
    tapeGetMediaParams->BlockSize += modeSenseBuffer->ParameterListBlock.BlockLength[1] << 8;
    tapeGetMediaParams->BlockSize += modeSenseBuffer->ParameterListBlock.BlockLength[0] << 16;

    partitionCount = modeSenseBuffer->MediumPartPage.AdditionalPartitionDefined;
    tapeGetMediaParams->PartitionCount = partitionCount + 1;

    tapeGetMediaParams->WriteProtected =
        ((modeSenseBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

    if (partition) {

        capacity.LowPart  =
            modeSenseBuffer->MediumPartPage.Partition1Size[1];
        capacity.LowPart +=
            modeSenseBuffer->MediumPartPage.Partition1Size[0] << 8;
        capacity.HighPart = 0;

    } else {

        capacity.LowPart  =
            modeSenseBuffer->MediumPartPage.Partition0Size[1];
        capacity.LowPart +=
            modeSenseBuffer->MediumPartPage.Partition0Size[0] << 8;
        capacity.HighPart = 0;

    }
    capacity.QuadPart *= 1048576;
    remaining.HighPart = 0;
    remaining.LowPart = 0;

    tapeGetMediaParams->Remaining = remaining;
    tapeGetMediaParams->Capacity  = capacity;

    tapeData->CurrentPartition = partitionCount? partition + 1 : NOT_PARTITIONED;

    ExFreePool(modeSenseBuffer);

    return status;

} // end TapeGetMediaParameters()


NTSTATUS
TapeGetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine returns the current position of the tape.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_GET_POSITION  tapeGetPosition = Irp->AssociatedIrp.SystemBuffer;
    PTAPE_POSITION_DATA positionBuffer;
    ULONG               type;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    type = tapeGetPosition->Type;
    RtlZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
    Irp->IoStatus.Information = sizeof(TAPE_GET_POSITION);
    tapeGetPosition->Type = type;

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetPosition: SendSrb (test unit ready)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetPosition: test unit ready, SendSrb unsuccessful\n"));
        return status;
    }

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    switch (tapeGetPosition->Type) {
        case TAPE_ABSOLUTE_POSITION:
            DebugPrint((3,"TapeGetPosition: absolute logical\n"));
            break;

        case TAPE_LOGICAL_POSITION:
            DebugPrint((3,"TapeGetPosition: logical\n"));
            break;

        default:
            DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
            return STATUS_NOT_IMPLEMENTED;

    }

    positionBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                   sizeof(TAPE_POSITION_DATA));

    if (!positionBuffer) {
        DebugPrint((1,"TapeGetPosition: insufficient resources (positionBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(positionBuffer, sizeof(TAPE_POSITION_DATA));

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB10GENERIC_LENGTH;

    cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         positionBuffer,
                                         sizeof(TAPE_POSITION_DATA),
                                         FALSE);

    if (NT_SUCCESS(status)) {

        if (positionBuffer->BlockPositionUnsupported) {
            DebugPrint((1,"TapeGetPosition: read position -- block position unsupported\n"));
            ExFreePool(positionBuffer);
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        if (tapeGetPosition->Type == TAPE_LOGICAL_POSITION) {
            tapeGetPosition->Partition = positionBuffer->PartitionNumber + 1;
        }

        tapeGetPosition->Offset.HighPart = 0;
        REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                      (PFOUR_BYTE)positionBuffer->FirstBlock);

    }

    ExFreePool(positionBuffer);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetPosition: read position, SendSrb unsuccessful\n"));
    }

    return status;

} // end TapeGetPosition()


NTSTATUS
TapeGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine returns the status of the device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeGetStatus: SendSrb (test unit ready)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeGetStatus: test unit ready, SendSrb unsuccessful\n"));
    }

    return status;

} // end TapeGetStatus()


NTSTATUS
TapePrepare(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine loads, unloads, tensions, locks, or unlocks the tape.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_PREPARE       tapePrepare = Irp->AssociatedIrp.SystemBuffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    switch (tapePrepare->Operation) {
        case TAPE_LOAD:
            DebugPrint((3,"TapePrepare: load\n"));
            break;

        case TAPE_UNLOAD:
            DebugPrint((3,"TapePrepare: unload\n"));
            break;

        case TAPE_LOCK:
            DebugPrint((3,"TapePrepare: lock\n"));
            break;

        case TAPE_UNLOCK:
            DebugPrint((3,"TapePrepare: unlock\n"));
            break;

        case TAPE_TENSION:
            DebugPrint((3,"TapePrepare: tension\n"));
            break;

        default:
            DebugPrint((1,"TapePrepare: Operation -- not supported\n"));
            return STATUS_NOT_IMPLEMENTED;
    }

    if (tapePrepare->Immediate) {
        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
            case TAPE_UNLOAD:
            case TAPE_TENSION:
                DebugPrint((3,"TapePrepare: immediate\n"));
                break;

            case TAPE_LOCK:
            case TAPE_UNLOCK:
            default:
                DebugPrint((1,"TapePrepare: Operation, immediate -- not supported\n"));
                return STATUS_NOT_IMPLEMENTED;
        }
    }

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

    switch (tapePrepare->Operation) {
        case TAPE_LOAD:
            cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
            srb.TimeOutValue = 390;
            break;

        case TAPE_UNLOAD:
            cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
            srb.TimeOutValue = 390;
            break;

        case TAPE_TENSION:
            cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
            srb.TimeOutValue = 390;
            break;

        case TAPE_LOCK:
            cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
            srb.TimeOutValue = 180;
            break;

        case TAPE_UNLOCK:
            cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            srb.TimeOutValue = 180;
            break;

    }

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapePrepare: Operation, SendSrb unsuccessful\n"));
    }

    return status;

} // end TapePrepare()


NTSTATUS
TapeReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds SRBs and CDBs for read and write requests
    to 4MM DAT drive devices.

Arguments:

    DeviceObject
    Irp

Return Value:

    Returns STATUS_PENDING.

--*/

  {
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    ULONG transferBlocks;
    LARGE_INTEGER startingOffset =
      currentIrpStack->Parameters.Read.ByteOffset;

    DebugPrint((3,"TapeReadWrite: Enter routine\n"));

    //
    // Allocate an Srb.
    //

    if (deviceExtension->SrbZone != NULL &&
        (srb = ExInterlockedAllocateFromZone(
            deviceExtension->SrbZone,
            deviceExtension->SrbZoneSpinLock)) != NULL) {

        srb->SrbFlags = SRB_FLAGS_ALLOCATED_FROM_ZONE;

    } else {

        //
        // Allocate Srb from non-paged pool.
        // This call must succeed.
        //

        srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

        srb->SrbFlags = 0;

    }

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up IRP Address.
    //

    srb->OriginalRequest = Irp;

    //
    // Set up target id and logical unit number.
    //

    srb->PathId = deviceExtension->PathId;
    srb->TargetId = deviceExtension->TargetId;
    srb->Lun = deviceExtension->Lun;


    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    srb->DataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);

    //
    // Save byte count of transfer in SRB Extension.
    //

    srb->DataTransferLength = currentIrpStack->Parameters.Read.Length;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    srb->SenseInfoBuffer = deviceExtension->SenseData;

    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Initialize the queue actions field.
    //

    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    srb->SenseInfoBuffer = deviceExtension->SenseData;

    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Set timeout value in seconds.
    //

    srb->TimeOutValue = 900;

    //
    // Zero statuses.
    //

    srb->SrbStatus = srb->ScsiStatus = 0;

    srb->NextSrb = 0;

    //
    // Indicate that 6-byte CDB's will be used.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;

    //
    // Fill in CDB fields.
    //

    cdb = (PCDB)srb->Cdb;

    //
    // Zero CDB in SRB.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    if (deviceExtension->DiskGeometry->BytesPerSector) {

        //
        // Since we are writing fixed block mode, normalize transfer count
        // to number of blocks.
        //

        transferBlocks =
            currentIrpStack->Parameters.Read.Length /
                deviceExtension->DiskGeometry->BytesPerSector;

        //
        // Tell the device that we are in fixed block mode.
        //

        cdb->CDB6READWRITETAPE.VendorSpecific = 1;
    } else {

        //
        // Variable block mode transfer.
        //

        transferBlocks = currentIrpStack->Parameters.Read.Length;
        cdb->CDB6READWRITETAPE.VendorSpecific = 0;
    }

    //
    // Set up transfer length
    //

    cdb->CDB6READWRITETAPE.TransferLenMSB = (UCHAR)((transferBlocks >> 16) & 0xff);
    cdb->CDB6READWRITETAPE.TransferLen    = (UCHAR)((transferBlocks >> 8) & 0xff);
    cdb->CDB6READWRITETAPE.TransferLenLSB = (UCHAR)(transferBlocks & 0xff);

    //
    // Set transfer direction flag and Cdb command.
    //

    if (currentIrpStack->MajorFunction == IRP_MJ_READ) {

         DebugPrint((3, "TapeRequest: Read Command\n"));

         srb->SrbFlags = SRB_FLAGS_DATA_IN;
         cdb->CDB6READWRITETAPE.OperationCode = SCSIOP_READ6;

    } else {

         DebugPrint((3, "TapeRequest: Write Command\n"));

         srb->SrbFlags = SRB_FLAGS_DATA_OUT;
         cdb->CDB6READWRITETAPE.OperationCode = SCSIOP_WRITE6;
    }

    //
    // Or in the default flags from the device object.
    //

    srb->SrbFlags |= deviceExtension->SrbFlags;

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = srb;

    //
    // Save retry count in current IRP stack.
    //

    currentIrpStack->Parameters.Others.Argument4 = (PVOID)MAXIMUM_RETRIES;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine(Irp,
                           ScsiClassIoComplete,
                           srb,
                           TRUE,
                           TRUE,
                           FALSE);

    return STATUS_PENDING;

} // end TapeReadWrite()


NTSTATUS
TapeSetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine "sets" the "drive parameters" of the 4mm DAT drive
    associated with "DeviceObject": Set Mark reporting enable/disable,
    compression enable/disable, etc.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION          deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_SET_DRIVE_PARAMETERS tapeSetDriveParams = Irp->AssociatedIrp.SystemBuffer;
    PMODE_DATA_COMPRESS_PAGE   compressionBuffer;
    PMODE_DEVICE_CONFIG_PAGE   configBuffer;
    SCSI_REQUEST_BLOCK         srb;
    PCDB                       cdb = (PCDB)srb.Cdb;
    NTSTATUS                   status;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    configBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                  sizeof(MODE_DEVICE_CONFIG_PAGE));

    if (!configBuffer) {
        DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(configBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
    cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         configBuffer,
                                         sizeof(MODE_DEVICE_CONFIG_PAGE),
                                         FALSE);

    if (!NT_SUCCESS(status)) {

        if (status == STATUS_NO_MEDIA) {

            ExFreePool(configBuffer);

        } else {

            DebugPrint((1,"TapeSetDriveParameters: mode sense, SendSrb unsuccessful\n"));
            ExFreePool(configBuffer);
            return status;

        }

    }

    if (NT_SUCCESS(status)) {

        configBuffer->ParameterListHeader.ModeDataLength = 0;
        configBuffer->ParameterListHeader.MediumType = 0;
        configBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;

        configBuffer->ParameterListBlock.DensityCode = 0x7F;

        configBuffer->DeviceConfigPage.PageCode = MODE_PAGE_DEVICE_CONFIG;
        configBuffer->DeviceConfigPage.PageLength = 0x0E;

        if (tapeSetDriveParams->ReportSetmarks) {
            configBuffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            configBuffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Zero CDB in SRB on stack.
        //

        RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        srb.CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = deviceExtension->TimeOutValue;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        status = ScsiClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             configBuffer,
                                             sizeof(MODE_DEVICE_CONFIG_PAGE),
                                             TRUE);

        ExFreePool(configBuffer);

        if (!NT_SUCCESS(status)) {
            DebugPrint((1,"TapeSetDriveParameters: mode select, SendSrb unsuccessful\n"));
            return status;
        }
    }

    compressionBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                       sizeof(MODE_DATA_COMPRESS_PAGE));

    if (!compressionBuffer) {
        DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(compressionBuffer, sizeof(MODE_DATA_COMPRESS_PAGE));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
    cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         compressionBuffer,
                                         sizeof(MODE_DATA_COMPRESS_PAGE),
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeSetDriveParameters: mode sense, SendSrb unsuccessful\n"));
        ExFreePool(compressionBuffer);
        return status;
    }

    if (NT_SUCCESS(status) && compressionBuffer->DataCompressPage.DCC) {

        compressionBuffer->ParameterListHeader.ModeDataLength = 0;
        compressionBuffer->ParameterListHeader.MediumType = 0;
        compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;

        compressionBuffer->ParameterListBlock.DensityCode = 0x7F;

        compressionBuffer->DataCompressPage.PageCode = MODE_PAGE_DATA_COMPRESS;
        compressionBuffer->DataCompressPage.PageLength = 0x0E;

        if (tapeSetDriveParams->Compression) {
            compressionBuffer->DataCompressPage.DCE = SETBITON;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[0] = 0;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[1] = 0;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[2] = 0;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[3] = 0x20;
            compressionBuffer->DataCompressPage.DecompressionAlgorithm[0] = 0;
            compressionBuffer->DataCompressPage.DecompressionAlgorithm[1] = 0;
            compressionBuffer->DataCompressPage.DecompressionAlgorithm[2] = 0;
            compressionBuffer->DataCompressPage.DecompressionAlgorithm[3] = 0;
        } else {
            compressionBuffer->DataCompressPage.DCE = SETBITOFF;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[0] = 0;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[1] = 0;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[2] = 0;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[3] = 0;
            compressionBuffer->DataCompressPage.DecompressionAlgorithm[0] = 0;
            compressionBuffer->DataCompressPage.DecompressionAlgorithm[1] = 0;
            compressionBuffer->DataCompressPage.DecompressionAlgorithm[2] = 0;
            compressionBuffer->DataCompressPage.DecompressionAlgorithm[3] = 0;
        }

        compressionBuffer->DataCompressPage.DDE = SETBITON;

        //
        // Zero CDB in SRB on stack.
        //

        RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        srb.CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = deviceExtension->TimeOutValue;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        status = ScsiClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             compressionBuffer,
                                             sizeof(MODE_DATA_COMPRESS_PAGE),
                                             TRUE);
        if (!NT_SUCCESS(status)) {
            DebugPrint((1,"TapeSetDriveParameters: mode select, SendSrb unsuccessful\n"));
        }

    }

    ExFreePool(compressionBuffer);

    return status;

} // end TapeSetDriveParameters()


NTSTATUS
TapeSetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine "sets" the "media parameters" of a tape in the 4mm
    DAT drive associated with "DeviceObject": the block size. Tape media
    must be present (loaded) in the drive for this function to return
    "no error".

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION          deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_SET_MEDIA_PARAMETERS tapeSetMediaParams = Irp->AssociatedIrp.SystemBuffer;
    PMODE_PARM_READ_WRITE_DATA modeBuffer;
    SCSI_REQUEST_BLOCK         srb;
    PCDB                       cdb = (PCDB)srb.Cdb;
    NTSTATUS                   status;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeSetMediaParameters: SendSrb (test unit ready)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeSetMediaParameters: test unit ready, SendSrb unsuccessful\n"));
        return status;
    }

    modeBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARM_READ_WRITE_DATA));

    if (!modeBuffer) {
        DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARM_READ_WRITE_DATA));

    modeBuffer->ParameterListHeader.ModeDataLength = 0;
    modeBuffer->ParameterListHeader.MediumType = 0;
    modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
    modeBuffer->ParameterListHeader.BlockDescriptorLength =
        MODE_BLOCK_DESC_LENGTH;

    modeBuffer->ParameterListBlock.DensityCode = 0x7F;
    modeBuffer->ParameterListBlock.BlockLength[0] =
        (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
    modeBuffer->ParameterListBlock.BlockLength[1] =
        (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
    modeBuffer->ParameterListBlock.BlockLength[2] =
        (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         modeBuffer,
                                         sizeof(MODE_PARM_READ_WRITE_DATA),
                                         TRUE);

    ExFreePool(modeBuffer);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeSetMediaParameters: mode select, SendSrb unsuccessful\n"));
    }

    return status;

} // end TapeSetMediaParameters()


NTSTATUS
TapeSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine sets the position of the tape.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_DATA          tapeData = (PTAPE_DATA)(deviceExtension + 1);
    PTAPE_SET_POSITION  tapeSetPosition = Irp->AssociatedIrp.SystemBuffer;
    ULONG               partition = 0;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (tapeSetPosition->Immediate) {
        switch (tapeSetPosition->Method) {
            case TAPE_REWIND:
            case TAPE_ABSOLUTE_BLOCK:
            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: immediate\n"));
                break;

            case TAPE_SPACE_END_OF_DATA:
            case TAPE_SPACE_RELATIVE_BLOCKS:
            case TAPE_SPACE_FILEMARKS:
            case TAPE_SPACE_SEQUENTIAL_FMKS:
            case TAPE_SPACE_SETMARKS:
            case TAPE_SPACE_SEQUENTIAL_SMKS:
            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                return STATUS_NOT_IMPLEMENTED;
        }
    }

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

    switch (tapeSetPosition->Method) {
        case TAPE_REWIND:
            DebugPrint((3,"TapeSetPosition: method == rewind\n"));
            cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
            srb.TimeOutValue = 360;
            break;

        case TAPE_ABSOLUTE_BLOCK:
            DebugPrint((3,"TapeSetPosition: method == locate (absolute logical)\n"));
            srb.CdbLength = CDB10GENERIC_LENGTH;
            cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
            cdb->LOCATE.LogicalBlockAddress[0] =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 24) & 0xFF);
            cdb->LOCATE.LogicalBlockAddress[1] =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->LOCATE.LogicalBlockAddress[2] =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->LOCATE.LogicalBlockAddress[3] =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            srb.TimeOutValue = 480;
            break;

        case TAPE_LOGICAL_BLOCK:
            DebugPrint((3,"TapeSetPosition: method == locate (logical)\n"));
            srb.CdbLength = CDB10GENERIC_LENGTH;
            cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
            cdb->LOCATE.LogicalBlockAddress[0] =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 24) & 0xFF);
            cdb->LOCATE.LogicalBlockAddress[1] =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->LOCATE.LogicalBlockAddress[2] =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->LOCATE.LogicalBlockAddress[3] =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            if ((tapeSetPosition->Partition != 0) &&
                (tapeData->CurrentPartition != NOT_PARTITIONED) &&
                (tapeSetPosition->Partition != tapeData->CurrentPartition)) {
                partition = tapeSetPosition->Partition;
                cdb->LOCATE.Partition = (UCHAR)(partition- 1);
                cdb->LOCATE.CPBit = SETBITON;
            } else {
                partition = tapeData->CurrentPartition;
            }
            srb.TimeOutValue = 480;
            break;

        case TAPE_SPACE_END_OF_DATA:
            DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 3;
            srb.TimeOutValue = 480;
            break;

        case TAPE_SPACE_RELATIVE_BLOCKS:
            DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 0;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            srb.TimeOutValue = 480;
            break;

        case TAPE_SPACE_FILEMARKS:
            DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 1;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            srb.TimeOutValue = 480;
            break;

        case TAPE_SPACE_SEQUENTIAL_FMKS:
            DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 2;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            srb.TimeOutValue = 480;
            break;

        case TAPE_SPACE_SETMARKS:
            DebugPrint((3,"TapeSetPosition: method == space setmarks\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 4;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            srb.TimeOutValue = 480;
            break;

        case TAPE_SPACE_SEQUENTIAL_SMKS:
            DebugPrint((3,"TapeSetPosition: method == space sequential setmarks\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Code = 5;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            srb.TimeOutValue = 480;
            break;

        default:
            DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
            return STATUS_NOT_IMPLEMENTED;

    }

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {

        if (tapeSetPosition->Method == TAPE_LOGICAL_BLOCK) {
            tapeData->CurrentPartition = partition;
        }

    } else {

        DebugPrint((1,"TapeSetPosition: method, SendSrb unsuccessful\n"));

    }

    return status;

} // end TapeSetPosition()


BOOLEAN
TapeVerifyInquiry(
    IN PSCSI_INQUIRY_DATA LunInfo
    )

/*++
Routine Description:

    This routine determines if this driver should claim this drive.

Arguments:

    LunInfo

Return Value:

    TRUE  - driver should claim this drive.
    FALSE - driver should not claim this drive.

--*/

{
    PINQUIRYDATA inquiryData;

    DebugPrint((3,"TapeVerifyInquiry: Enter routine\n"));

    inquiryData = (PVOID)LunInfo->InquiryData;

    //
    //  Determine, from the Product ID field in the
    //  inquiry data, whether or not to "claim" this drive.
    //

    return WhichIsIt(inquiryData)? TRUE : FALSE;

} // end TapeVerifyInquiry()


NTSTATUS
TapeWriteMarks(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine writes tapemarks on the tape.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_WRITE_MARKS   tapeWriteMarks = Irp->AssociatedIrp.SystemBuffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (tapeWriteMarks->Immediate) {
        switch (tapeWriteMarks->Type) {
            case TAPE_SETMARKS:
            case TAPE_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: immediate\n"));
                break;

            case TAPE_SHORT_FILEMARKS:
            case TAPE_LONG_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                return STATUS_NOT_IMPLEMENTED;
        }
    }

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
    cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

    switch (tapeWriteMarks->Type) {
        case TAPE_SETMARKS:
            DebugPrint((3,"TapeWriteMarks: TapemarkType == setmarks\n"));
            cdb->WRITE_TAPE_MARKS.WriteSetMarks = SETBITON;
            break;

        case TAPE_FILEMARKS:
            DebugPrint((3,"TapeWriteMarks: TapemarkType == filemarks\n"));
            break;

        case TAPE_SHORT_FILEMARKS:
        case TAPE_LONG_FILEMARKS:
        default:
            DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
            return STATUS_NOT_IMPLEMENTED;
    }

    cdb->WRITE_TAPE_MARKS.TransferLength[0] =
        (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
    cdb->WRITE_TAPE_MARKS.TransferLength[1] =
        (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
    cdb->WRITE_TAPE_MARKS.TransferLength[2] =
        (UCHAR)(tapeWriteMarks->Count & 0xFF);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 360;

    //
    // Send SCSI command (CDB) to device
    //

    DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"TapeWriteMarks: TapemarkType, SendSrb unsuccessful\n"));
    }

    return status;

} // end TapeWriteMarks()


static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (RtlCompareMemory(InquiryData->VendorId,"SONY    ",8) == 8) {

        if (RtlCompareMemory(InquiryData->ProductId,"SDT-2000",8) == 8) {
            return SONY_SDT2000;
        }

        if (RtlCompareMemory(InquiryData->ProductId,"SDT-4000",8) == 8) {
            return SONY_SDT4000;
        }

        if (RtlCompareMemory(InquiryData->ProductId,"SDT-5000",8) == 8) {
            return SONY_SDT5000;
        }

        if (RtlCompareMemory(InquiryData->ProductId,"SDT-5200",8) == 8) {
            return SONY_SDT5200;
        }

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\4mmdat\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for 4mm DAT drives:
    SONY SDT-2000, SONY SDT-4000, SDT-5000, and SDT-5200.

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"
#include "4mmdat.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TapeWMIControl)
#pragma alloc_text(PAGE, ProcessReadWriteErrors)
#pragma alloc_text(PAGE, QueryDeviceErrorData)
#pragma alloc_text(PAGE, QueryIoErrorData)
#pragma alloc_text(PAGE, VerifyReadWriteErrors)
#endif

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )
/*+
Routine Description:

   This is the common entry point for all WMI calls from tape class driver.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;

   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;

   switch (wmiOperations->Method) {
      case TAPE_CHECK_FOR_DRIVE_PROBLEM: {
         if ((miniExtension->DriveAlertInfoType) != TapeAlertInfoNone) {
            return QueryDeviceErrorData(MinitapeExtension, 
                                        CommandExtension,
                                        CommandParameters, 
                                        Srb, CallNumber,
                                        LastError, RetryFlags);
         } else { 
            return QueryIoErrorData(MinitapeExtension, 
                                    CommandExtension,
                                    CommandParameters, 
                                    Srb, CallNumber,
                                    LastError, RetryFlags);
         }

         break;
      }

      case TAPE_QUERY_IO_ERROR_DATA: {
         return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                 CommandParameters, Srb, CallNumber,
                                 LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_DEVICE_ERROR_DATA: {
         return QueryDeviceErrorData(MinitapeExtension, CommandExtension,
                                     CommandParameters, Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      default: {
         return TAPE_STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   } // switch (wmiOperations->Method) 
}

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns IO Error data such as read\write errors.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;

   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   IoErrorData = (PWMI_TAPE_PROBLEM_IO_ERROR)&(wmiData->TapeData);

   if (CallNumber == 0) {
      if (!TapeClassAllocateSrbBuffer(Srb, 
                                      sizeof(LOG_SENSE_PARAMETER_FORMAT))) {
         DebugPrint((1, "QueryIoErrorData : No memory for log sense info\n"));
         return TAPE_STATUS_INSUFFICIENT_RESOURCES;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(IoErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_IO_ERROR));

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB) to get Write Error counters
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE2;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 1) {
      ProcessReadWriteErrors(Srb, FALSE, IoErrorData);

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB) to get Read Error counters
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE3;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 2) {
      ProcessReadWriteErrors(Srb, TRUE, IoErrorData);
      
      wmiData->DriveProblemType = VerifyReadWriteErrors(IoErrorData);
      DebugPrint((3, "QueryIoErrorData: DriveProblemType %x\n",
                  wmiData->DriveProblemType));
   }

   return TAPE_STATUS_SUCCESS;
}

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
)
/*+
Routine Description :

   This routine processes the buffer containing read\write counters,
   and sets the appropriate fields in WMI_TAPE_PROBLEM_IO_ERROR 
   buffer.
   
Arguments :

 Srb            SCSI Request Block
 Read           TRUE if we are to process read counters. FALSE if it is 
                Write counters
 IoErrorData    Buffer in which to return counter values.
 
Return Value :

  None  
-*/
{
   USHORT paramCode;
   UCHAR  paramLen;
   UCHAR  actualParamLen;
   LONG  bytesLeft;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PLOG_SENSE_PARAMETER_HEADER logSenseParamHeader;
   PUCHAR  paramValue = NULL;
   ULONG transferLength;
   ULONG value;
   logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
   
   ASSERT(((logSenseHeader->PageCode) == LOGSENSEPAGE2) ||
          ((logSenseHeader->PageCode) == LOGSENSEPAGE3));
   bytesLeft = logSenseHeader->Length[0];
   bytesLeft <<= 8;
   bytesLeft += logSenseHeader->Length[1];

   transferLength = Srb->DataTransferLength;

   if (bytesLeft > (LONG)(transferLength -
                          sizeof(LOG_SENSE_PAGE_HEADER))) {
       bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
   }

   (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseHeader + sizeof(LOG_SENSE_PAGE_HEADER);
   DebugPrint((3, "ProcessReadWriteErrors : BytesLeft %x, TransferLength %x\n",
               bytesLeft, transferLength));
   while (bytesLeft >= sizeof(LOG_SENSE_PARAMETER_HEADER)) {
      paramCode = logSenseParamHeader->ParameterCode[0];
      paramCode <<= 8;
      paramCode |= logSenseParamHeader->ParameterCode[1];
      paramLen = logSenseParamHeader->ParameterLength;
      paramValue = (PUCHAR)logSenseParamHeader + sizeof(LOG_SENSE_PARAMETER_HEADER);

      //
      // Make sure we have at least 
      // (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen) bytes left.
      // Otherwise, we've reached the end of the buffer.
      //
      if (bytesLeft < (LONG)(sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)) {
          DebugPrint((1, 
                      "4mmDAT : Reached end of buffer. BytesLeft %x, Expected %x\n",
                      bytesLeft, 
                      (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)));
          break;
      }

      //
      // ISSUE: 04/04/2000 : nramas
      //
      // Error counters in all 4mmDAT drives have length lesser than or equal 
      // to 4 bytes. If any counter is more than 4 bytes long, we just take 
      // the lower 4 bytes. The assumption here is, if the actual error counter  
      // value is more than what a ULONG can hold, the drive is sure suspect 
      // anyway. We could possibly be missing TotalBytesProcessed counter. 
      // Since we don't use that to detect drive failure, it's okay if we 
      // don't get the right value for TotalBytesProcessed.
      //
      actualParamLen = paramLen;
      if (paramLen > 4) {
          DebugPrint((1,
                      "4mmDAT : ParamCode %x has length greater than 4. ParamLen %x\n",
                      paramCode, paramLen));
          paramValue += paramLen - 4;
          paramLen = 4;

      }

      DebugPrint((3, 
                  "ProcessReadWriteErrors : ParamCode %x, ParamLen %x\n",
                  paramCode, paramLen));

      value = 0;
      while (paramLen > 0) {
          value <<= 8;
          value += *paramValue;
          paramValue++;
          paramLen--;
      }

      switch (paramCode) {
         case TotalCorrectedErrors: {
            DebugPrint((3, "TotalCorrectedErrors %x\n", value));
            if (Read) {
               IoErrorData->ReadTotalCorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalCorrectedErrors = value;
            }
            break;
         }

         case TotalUncorrectedErrors: {
            DebugPrint((3, "TotalUncorrectedErrors %x\n", value));
            if (Read) {
               IoErrorData->ReadTotalUncorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalUncorrectedErrors = value;
            }

            break;
         }

         case TotalTimesAlgorithmProcessed: {
            DebugPrint((3, "TotalTimesAlgorithmProcessed %x\n", value));
            if (Read) {
               IoErrorData->ReadCorrectionAlgorithmProcessed = value;
            } else {
               IoErrorData->WriteCorrectionAlgorithmProcessed = value;
            }
            break;
         }

         default: {
            break;
         }
      } // switch (paramCode) 

      (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseParamHeader + 
                                    sizeof(LOG_SENSE_PARAMETER_HEADER) +
                                    actualParamLen;

      bytesLeft -= actualParamLen + sizeof(LOG_SENSE_PARAMETER_HEADER);
   } // while (bytesLeft > 0)

   if (Read) {
      IoErrorData->ReadTotalErrors = IoErrorData->ReadTotalUncorrectedErrors +
                                     IoErrorData->ReadTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: ReadErrors %x\n",
                  IoErrorData->ReadTotalErrors));
   } else {
      IoErrorData->WriteTotalErrors = IoErrorData->WriteTotalUncorrectedErrors +
                                      IoErrorData->WriteTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: WriteErrors %x\n",
                  IoErrorData->WriteTotalErrors));
   }

}

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   )
/*+

Routine Description :

   This routine looks at the read\write error counters.
   If the values are above a certain threshold, it returns
   appropriate error value.
   
Argument :

  IoErrorData  WMI_TAPE_PROBLEM_IO_ERROR struct
  
Return Value :
   
      TapeDriveReadWriteError If there are too many uncorrected 
                              read\write errors
                         
      TapeDriveReadWriteWarning If there are too many corrected
                                read\write errors 
                                
      TapeDriveProblemNone    If the read\write errors are below
                              threshold   
  
-*/
{
   if (((IoErrorData->ReadTotalUncorrectedErrors) >=
         TAPE_READ_ERROR_LIMIT)   ||       
       ((IoErrorData->WriteTotalUncorrectedErrors) >=
         TAPE_WRITE_ERROR_LIMIT)) {
      return TapeDriveReadWriteError;
   }

   if (((IoErrorData->ReadTotalCorrectedErrors) >=
         TAPE_READ_WARNING_LIMIT) ||
       ((IoErrorData->WriteTotalCorrectedErrors) >=
         TAPE_WRITE_WARNING_LIMIT)) {

      return TapeDriveReadWriteWarning;
   }

   return TapeDriveProblemNone;
}

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns device Error data such as "drive calibration"
   error, etc.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;
   PWMI_TAPE_PROBLEM_DEVICE_ERROR DeviceErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PCDB cdb = (PCDB)Srb->Cdb;
   LONG bytesLeft;
   
   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   DeviceErrorData = (PWMI_TAPE_PROBLEM_DEVICE_ERROR)wmiData->TapeData;

   if (CallNumber == 0) {
      DebugPrint((3,
                  "QueryDeviceErrorData: DriveAlertInfoType %x\n",
                  miniExtension->DriveAlertInfoType));

      if ((miniExtension->DriveAlertInfoType) == TapeAlertInfoNone) {
         DebugPrint((1, "QueryDeviceErrorData: No alert info supported\n"));
         return TAPE_STATUS_NOT_IMPLEMENTED;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(DeviceErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_DEVICE_ERROR));

      if ((miniExtension->DriveAlertInfoType) == TapeAlertInfoLogPage) {
         ULONG allocLength;

         allocLength = sizeof(LOG_SENSE_PAGE_HEADER) + 
                        (sizeof(TAPE_ALERT_INFO) * 0x40);
         DebugPrint((3, "QueryDeviceErrorData: AlertInfo allocLength %x\n",
                     allocLength));
         if (!TapeClassAllocateSrbBuffer(Srb, allocLength)) {
            DebugPrint((1, 
                        "QueryDeviceErrorData : No memory for log sense info\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
         }
   
         TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
   
         //
         // Prepare SCSI command (CDB)
         //
         Srb->CdbLength = CDB10GENERIC_LENGTH;
   
         cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
         cdb->LOGSENSE.PageCode = TapeAlertLogPage;
         cdb->LOGSENSE.PCBit = 1;
         cdb->LOGSENSE.AllocationLength[0] = (UCHAR)((allocLength & 0xFF00) >> 8);
         cdb->LOGSENSE.AllocationLength[1] = (UCHAR)(allocLength & 0xFF);

         Srb->DataTransferLength = allocLength;

         return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
      } else if ((miniExtension->DriveAlertInfoType) == 
                  TapeAlertInfoRequestSense) {

         UCHAR requestSenseSize;

         //
         // Issue a request sense to get the cleaning info bits.
         // 

         if (((miniExtension->DriveID) == HP_C1533A) || 
             ((miniExtension->DriveID) == HP_C1553A)) {
            requestSenseSize = sizeof(HP_SENSE_DATA);
         } else if ((miniExtension->DriveID) == SONY_SDT10000) {
            requestSenseSize = sizeof(SONY_SENSE_DATA);
         } else {
             DebugPrint((1,
                         "QueryDeviceErrorData: Request Sense not supported\n"));
             return TAPE_STATUS_NOT_IMPLEMENTED;
         }

         DebugPrint((3, "QueryDeviceErrorData : Request Sense size %x\n",
                     requestSenseSize));
         if (!TapeClassAllocateSrbBuffer( Srb, requestSenseSize)) {
            DebugPrint((1,
                      "QueryDeviceErrorData: Insufficient resources (SenseData)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
         }

         //
         // Prepare SCSI command (CDB)
         //

         TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

         Srb->ScsiStatus = Srb->SrbStatus = 0;
         Srb->CdbLength = CDB6GENERIC_LENGTH;

         cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
         cdb->CDB6GENERIC.CommandUniqueBytes[2] = requestSenseSize;

         //
         // Send SCSI command (CDB) to device
         //

         Srb->DataTransferLength = requestSenseSize;
         *RetryFlags |= RETURN_ERRORS;

         return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
      } else {
          DebugPrint((1,
                      "QueryDeviceError: Invalid DriveAlertInfoType %x\n",
                      miniExtension->DriveAlertInfoType));
          return TAPE_STATUS_INVALID_PARAMETER;
      }
   }

   if (CallNumber == 1) {

      if ((miniExtension->DriveAlertInfoType) == TapeAlertInfoRequestSense) {

         if (LastError != TAPE_STATUS_SUCCESS) {
             DebugPrint((1, 
                         "QueryDeviceErrorData:RequestSense returned error %x\n",
                         LastError));
             //
             // Not setting any drive problem info. Just return SUCCESS
             //
             return TAPE_STATUS_SUCCESS;
         }

         if (((miniExtension->DriveID) == HP_C1533A) || 
             ((miniExtension->DriveID) == HP_C1553A)) {

            PHP_SENSE_DATA hpSenseData;
            hpSenseData = (PHP_SENSE_DATA)Srb->DataBuffer;

            if (hpSenseData->CLN) {
               DebugPrint((3, "HPSenseData : CLN bit set\n"));
               DeviceErrorData->DriveRequiresCleaning = TRUE;
               wmiData->DriveProblemType = TapeDriveCleanDriveNow;
            }

            if (((hpSenseData->FRUCode) == 0x01) ||
                ((hpSenseData->FRUCode) == 0x02)) {
               DebugPrint((3, "HPSenseData : FRUCode value %x\n",
                           hpSenseData->FRUCode));
               DeviceErrorData->DriveHardwareError = TRUE;
               wmiData->DriveProblemType = TapeDriveHardwareError;
            }

         } else if ((miniExtension->DriveID) == SONY_SDT10000) {

            PSONY_SENSE_DATA sonySenseData;
            sonySenseData = (PSONY_SENSE_DATA)Srb->DataBuffer;

            if (sonySenseData->CLN) {
                DebugPrint((3, "SonySenseData : CLN bit set\n"));
               DeviceErrorData->DriveRequiresCleaning = TRUE;
               wmiData->DriveProblemType = TapeDriveCleanDriveNow;
            }

            if (sonySenseData->MEW) {
               DebugPrint((3, "SonySenseData : MEW bit set\n"));
               DeviceErrorData->WriteWarning = TRUE;
               DeviceErrorData->ReadWarning = TRUE;
               wmiData->DriveProblemType = TapeDriveReadWarning;
            }

            if (((sonySenseData->FRUCode) == 0x01) ||
                ((sonySenseData->FRUCode) == 0x02)) {
               DebugPrint((3, "SonySenseData : FRUCode value %x\n",
                           sonySenseData->FRUCode));
               DeviceErrorData->DriveHardwareError = TRUE;
               wmiData->DriveProblemType = TapeDriveHardwareError;
            }
         } 

         DebugPrint((3, "QueryDeviceErrorData: DriveProblemType %x\n",
                     wmiData->DriveProblemType));
      } else if ((miniExtension->DriveAlertInfoType) == 
                  TapeAlertInfoLogPage) {

         PTAPE_ALERT_INFO  tapeAlertInfo;
         ULONG transferLength;
         UCHAR paramCode;
         UCHAR flagValue;

         logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
         
         ASSERT((logSenseHeader->PageCode) == TapeAlertLogPage);
         bytesLeft = logSenseHeader->Length[0];
         bytesLeft <<= 8;
         bytesLeft += logSenseHeader->Length[1];
      
         transferLength = Srb->DataTransferLength;

         if (bytesLeft > (LONG)(transferLength -
                          sizeof(LOG_SENSE_PAGE_HEADER))) {
             bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
         }

         DebugPrint((3, "QueryDeviceErrorData : BytesLeft %x, TransferLength %x\n",
                     bytesLeft, transferLength));
         tapeAlertInfo= (PTAPE_ALERT_INFO)((PUCHAR)logSenseHeader + 
                                           sizeof(LOG_SENSE_PAGE_HEADER));
         while (bytesLeft >= sizeof(TAPE_ALERT_INFO)) {
            //
            // ParamCode is 2 bytes long. Upper Byte is 0.
            // Lower Byte goes from 0x01 to 0x40. So, we just
            // pick up the lower byte
            //
            paramCode = tapeAlertInfo->ParamCodeLB;
            flagValue = tapeAlertInfo->Flag;
            ASSERT((tapeAlertInfo->ParamLen) == 1);
            DebugPrint((3, "QDED: ParamCode %x, FlagValue %x, ParamLen %x\n",
                        paramCode, flagValue, tapeAlertInfo->ParamLen));
            switch (paramCode) {
                case READ_WARNING: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : READ_WARNING\n"));
                      DeviceErrorData->ReadWarning = TRUE;
                      wmiData->DriveProblemType = TapeDriveReadWarning;
                   }

                   break;
                }
       
                case WRITE_WARNING: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : WRITE_WARNING\n"));
                      DeviceErrorData->WriteWarning = TRUE;
                      wmiData->DriveProblemType = TapeDriveWriteWarning;
                   }
       
                   break;
                }
       
                case HARD_ERROR: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : HARD_ERROR\n"));
                      DeviceErrorData->HardError = TRUE;
                      wmiData->DriveProblemType = TapeDriveHardwareError;
                   }
                      
                   break;
                }
       
                case READ_FAILURE: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : READ_FAILURE\n"));
                      DeviceErrorData->ReadFailure = TRUE;
                      wmiData->DriveProblemType = TapeDriveReadError;
                   }
                      
                   break;
                }
       
                case WRITE_FAILURE: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : WRITE_FAILURE\n"));
                      DeviceErrorData->WriteFailure = TRUE;
                      wmiData->DriveProblemType = TapeDriveWriteError;
                   }
                   
                   break;
                }
       
                case MEDIA_LIFE: {
                   if (flagValue) {
                       DebugPrint((3, "QueryDeviceErrorData : MEDIA_LIFE\n"));
                      DeviceErrorData->MediaLife = TRUE;
                      wmiData->DriveProblemType = TapeDriveMediaLifeExpired;
                   }
                      
                   break;
                }
       
                case UNSUPPORTED_FORMAT: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : UNSUPPORTED_FORMAT\n"));
                      DeviceErrorData->UnsupportedFormat = TRUE;
                      wmiData->DriveProblemType = TapeDriveUnsupportedMedia;
                   }
                      
                   break;
                }
       
                case SNAPPED_TAPE: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : SNAPPED_TAPE\n"));
                      DeviceErrorData->TapeSnapped = TRUE;
                      wmiData->DriveProblemType = TapeDriveSnappedTape;
                   }
                      
                   break;
                }
       
                case CLEAN_NOW: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : CLEAN_NOW\n"));
                      DeviceErrorData->DriveRequiresCleaning = TRUE;
                      wmiData->DriveProblemType = TapeDriveCleanDriveNow;
                   }
                      
                   break;
                }
       
                case CLEAN_PERIODIC: {
                    if (flagValue) {
                        DebugPrint((3, "QueryDeviceErrorData : CLEAN_PERIODIC\n"));
                        DeviceErrorData->TimetoCleanDrive = TRUE;
                        wmiData->DriveProblemType = TapeDriveTimetoClean;
                    }

                    break;
                }
       
                case HARDWARE_A: case HARDWARE_B: {
                    if (flagValue) {
                        DebugPrint((3, "QueryDeviceErrorData : HARDWARE_A\\B\n"));
                        DeviceErrorData->DriveHardwareError = TRUE;
                        wmiData->DriveProblemType = TapeDriveHardwareError;
                    }

                    break;
                }
       
                case INTERFACE_ERROR: {
                   if (flagValue) {
                      DebugPrint((3, "QueryDeviceErrorData : INTERFACE_ERROR\n"));
                      DeviceErrorData->ScsiInterfaceError = TRUE;
                      wmiData->DriveProblemType = TapeDriveScsiConnectionError;
                   }
                      
                   break;
                }
       
                default:
                    break;
            } // switch (paramCode) {
       
            tapeAlertInfo++;
            bytesLeft -= sizeof(TAPE_ALERT_INFO);
         }

         DebugPrint((3, "QueryDeviceErrorData : DriveProblemType %x\n",
                     wmiData->DriveProblemType));
      }
   }

   return TAPE_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\9track\9track.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    9track.c

Abstract:

    This module contains the device-specific routines for the Overland
    Data Series 5000 9-track tape drives.

Author:

    Mike Glass

Environment:

    kernel mode only

Revision History:

--*/

#include "ntddk.h"
#include "tape.h"

//
// The Overland 9-track tape drive supports a single code page.
//

typedef struct _NINE_TRACKSENSE_DATA {
    UCHAR SenseDataLength;
    UCHAR MediaType;
    UCHAR Speed : 4;
    UCHAR BufferedMode : 3;
    UCHAR WriteProtected : 1;
    UCHAR BlockDescriptorLength;
    UCHAR DensityCode;
    UCHAR NumberOfBlocks;
    UCHAR Reserved;
    UCHAR BlockLength[3];
} NINE_TRACKSENSE_DATA, *PNINE_TRACKSENSE_DATA;


NTSTATUS
TapeCreatePartition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    9-track tape drives do not support partitions.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;

} // end TapeCreatePartition()


NTSTATUS
TapeErase(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine erases the current partition of the device by writing an
    end-of-recorded data marker beginning at the current position.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_ERASE         tapeErase = Irp->AssociatedIrp.SystemBuffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->ERASE.OperationCode = SCSIOP_ERASE;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    if (tapeErase->Type != TAPE_ERASE_SHORT) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Set immediate bit if indicated.
    //

    cdb->ERASE.Immediate = tapeErase->Immediate;

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                NULL,
                                0,
                                FALSE);

    return status;

} // end TapeErase()



VOID
TapeError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    When a request completes with error, the routine InterpretSenseInfo is
    called to determine from the sense data whether the request should be
    retried and what NT status to set in the IRP. Then this routine is called
    for tape requests to handle tape-specific errors and update the nt status
    and retry boolean.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - NT Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PSENSE_DATA        senseBuffer = Srb->SenseInfoBuffer;
    NTSTATUS           status = *Status;
    BOOLEAN            retry = *Retry;

    return;

} // end TapeError()


NTSTATUS
TapeGetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:


    This routine returns the default fixed-block size, the maximum block size,
    the minimum block size, the maximum number of partitions, and the device
    features flag.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_GET_DRIVE_PARAMETERS tapeGetDriveParams = Irp->AssociatedIrp.SystemBuffer;
    PNINE_TRACKSENSE_DATA buffer;
    PREAD_BLOCK_LIMITS_DATA blockLimits;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeGetDriveParameters: Get Tape Drive Parameters\n"));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    cdb->MODE_SENSE.AllocationLength = sizeof(NINE_TRACKSENSE_DATA);
    cdb->MODE_SENSE.PageCode = MODE_SENSE_CURRENT_VALUES;
    cdb->MODE_SENSE.Pc = 0x0B;

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
        sizeof(NINE_TRACKSENSE_DATA));

    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                buffer,
                                sizeof(NINE_TRACKSENSE_DATA),
                                FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(TAPE_GET_DRIVE_PARAMETERS);

        //
        // Indicate support of following:
        //

        tapeGetDriveParams->ECC = FALSE;
        tapeGetDriveParams->Compression = FALSE;
        tapeGetDriveParams->DataPadding = FALSE;
        tapeGetDriveParams->ReportSetmarks = FALSE;

        tapeGetDriveParams->FeaturesLow =
            TAPE_DRIVE_ERASE_SHORT |
            TAPE_DRIVE_FIXED_BLOCK |
            TAPE_DRIVE_VARIABLE_BLOCK |
            TAPE_DRIVE_WRITE_PROTECT |
            TAPE_DRIVE_GET_ABSOLUTE_BLK |
            TAPE_DRIVE_GET_LOGICAL_BLK;

        tapeGetDriveParams->FeaturesHigh =
            TAPE_DRIVE_LOAD_UNLOAD |
            TAPE_DRIVE_LOCK_UNLOCK |
            TAPE_DRIVE_SET_BLOCK_SIZE |
            TAPE_DRIVE_ABSOLUTE_BLK |
            TAPE_DRIVE_ABS_BLK_IMMED |
            TAPE_DRIVE_LOGICAL_BLK |
            TAPE_DRIVE_END_OF_DATA |
            TAPE_DRIVE_FILEMARKS |
            TAPE_DRIVE_SEQUENTIAL_FMKS |
            TAPE_DRIVE_REVERSE_POSITION |
            TAPE_DRIVE_WRITE_FILEMARKS;
    }

    ExFreePool(buffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    blockLimits = ExAllocatePool(NonPagedPoolCacheAligned,
        sizeof(READ_BLOCK_LIMITS_DATA));

    if (!blockLimits) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(blockLimits, sizeof(READ_BLOCK_LIMITS_DATA));

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                blockLimits,
                                sizeof(READ_BLOCK_LIMITS_DATA),
                                FALSE);

    if (NT_SUCCESS(status)) {
        tapeGetDriveParams->MaximumBlockSize = blockLimits->BlockMaximumSize[2];
        tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
        tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

        tapeGetDriveParams->MinimumBlockSize = blockLimits->BlockMinimumSize[1];
        tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);
    }

    ExFreePool(blockLimits);

    return status;

} // end TapeGetDriveParameters()


NTSTATUS
TapeGetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    The OVERLAND 9-track tape device can return whether media is
    write-protected.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_GET_MEDIA_PARAMETERS tapeGetMediaParams = Irp->AssociatedIrp.SystemBuffer;
    PNINE_TRACKSENSE_DATA  buffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeGetMediaParameters: Get Tape Media Parameters\n"));

    //
    // Zero SRB on stack.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    cdb->MODE_SENSE.AllocationLength = sizeof(NINE_TRACKSENSE_DATA);
    cdb->MODE_SENSE.PageCode = MODE_SENSE_CURRENT_VALUES;
    cdb->MODE_SENSE.Pc = 0x0B;

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
        sizeof(NINE_TRACKSENSE_DATA));

    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                buffer,
                                sizeof(NINE_TRACKSENSE_DATA),
                                FALSE);

    if (status == STATUS_DATA_OVERRUN) {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(TAPE_GET_MEDIA_PARAMETERS);

        tapeGetMediaParams->BlockSize = buffer->BlockLength[2];
        tapeGetMediaParams->BlockSize += buffer->BlockLength[1] << 8;
        tapeGetMediaParams->BlockSize += buffer->BlockLength[0] << 16;

        tapeGetMediaParams->WriteProtected = buffer->WriteProtected;
        tapeGetMediaParams->PartitionCount = 0;
    }

    ExFreePool(buffer);

    return status;
    return status;

} // end TapeGetMediaParameters()


NTSTATUS
TapeGetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    9-track tape drives do not support reporting current position.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;

} // end TapeGetPosition()


NTSTATUS
TapeGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine returns the status of the device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeIoControl: Get Tape Status\n"));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                NULL,
                                0,
                                FALSE);

    return status;

} // end TapeGetStatus()


NTSTATUS
TapePrepare(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine loads, unloads, locks, or unlocks the tape.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_PREPARE       tapePrepare = Irp->AssociatedIrp.SystemBuffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    switch (tapePrepare->Operation) {
        case TAPE_LOAD:
            DebugPrint((3,"TapeIoControl: Load Tape\n"));
            srb.CdbLength = CDB6GENERIC_LENGTH;
            cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
            break;

        case TAPE_UNLOAD:
            DebugPrint((3,"TapeIoControl: Unload Tape\n"));
            srb.CdbLength = CDB6GENERIC_LENGTH;
            cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
            break;

        case TAPE_LOCK:
            DebugPrint((3,"TapeIoControl: Prevent Tape Removal\n"));
            srb.CdbLength = CDB6GENERIC_LENGTH;
            cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
            break;

        case TAPE_UNLOCK:
            DebugPrint((3,"TapeIoControl: Allow Tape Removal\n"));
            srb.CdbLength = CDB6GENERIC_LENGTH;
            cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            break;

        default:
            DebugPrint((3,"TapeIoControl: Tape Operation Not Supported\n"));
            return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Set immediate bit if indicated.
    //

    cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                NULL,
                                0,
                                FALSE);

    return status;

} // end TapePrepare()

NTSTATUS
TapeReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds SRBs and CDBs for read and write requests to 4MM DAT
    devices.

Arguments:

    DeviceObject
    Irp

Return Value:

    Returns STATUS_PENDING.

--*/

  {
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    ULONG transferBlocks;
    LARGE_INTEGER startingOffset =
      currentIrpStack->Parameters.Read.ByteOffset;

    //
    // Allocate an Srb.
    //

    if (deviceExtension->SrbZone != NULL &&
        (srb = ExInterlockedAllocateFromZone(
            deviceExtension->SrbZone,
            deviceExtension->SrbZoneSpinLock)) != NULL) {

        srb->SrbFlags = SRB_FLAGS_ALLOCATED_FROM_ZONE;

    } else {

        //
        // Allocate Srb from non-paged pool.
        // This call must succeed.
        //

        srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

        srb->SrbFlags = 0;

    }

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up IRP Address.
    //

    srb->OriginalRequest = Irp;

    //
    // Set up target id and logical unit number.
    //

    srb->PathId = deviceExtension->PathId;
    srb->TargetId = deviceExtension->TargetId;
    srb->Lun = deviceExtension->Lun;


    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    srb->DataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);

    //
    // Save byte count of transfer in SRB Extension.
    //

    srb->DataTransferLength = currentIrpStack->Parameters.Read.Length;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    srb->SenseInfoBuffer = deviceExtension->SenseData;

    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Initialize the queue actions field.
    //

    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    srb->SenseInfoBuffer = deviceExtension->SenseData;

    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Set timeout value in seconds.
    //

    srb->TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Zero statuses.
    //

    srb->SrbStatus = srb->ScsiStatus = 0;

    srb->NextSrb = 0;

    //
    // Indicate that 6-byte CDB's will be used.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;

    //
    // Fill in CDB fields.
    //

    cdb = (PCDB)srb->Cdb;

    //
    // Zero CDB in SRB.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    if (deviceExtension->DiskGeometry->BytesPerSector) {

        //
        // Since we are writing fixed block mode, normalize transfer count
        // to number of blocks.
        //

        transferBlocks =
            currentIrpStack->Parameters.Read.Length /
                deviceExtension->DiskGeometry->BytesPerSector;

        //
        // Tell the device that we are in fixed block mode.
        //

        cdb->CDB6READWRITETAPE.VendorSpecific = 1;
    } else {

        //
        // Variable block mode transfer.
        //

        transferBlocks = currentIrpStack->Parameters.Read.Length;
        cdb->CDB6READWRITETAPE.VendorSpecific = 0;
    }

    //
    // Set up transfer length
    //

    cdb->CDB6READWRITETAPE.TransferLenMSB = (UCHAR)((transferBlocks >> 16) & 0xff);
    cdb->CDB6READWRITETAPE.TransferLen    = (UCHAR)((transferBlocks >> 8) & 0xff);
    cdb->CDB6READWRITETAPE.TransferLenLSB = (UCHAR)(transferBlocks & 0xff);

    //
    // Set transfer direction flag and Cdb command.
    //

    if (currentIrpStack->MajorFunction == IRP_MJ_READ) {

         DebugPrint((3, "TapeReadWrite: Read Command\n"));

         srb->SrbFlags = SRB_FLAGS_DATA_IN;
         cdb->CDB6READWRITETAPE.OperationCode = SCSIOP_READ6;

    } else {

         DebugPrint((3, "TapeReadWrite: Write Command\n"));

         srb->SrbFlags = SRB_FLAGS_DATA_OUT;
         cdb->CDB6READWRITETAPE.OperationCode = SCSIOP_WRITE6;
    }

    //
    // Or in the default flags from the device object.
    //

    srb->SrbFlags |= deviceExtension->SrbFlags;

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = srb;

    //
    // Save retry count in current IRP stack.
    //

    currentIrpStack->Parameters.Others.Argument4 = (PVOID)MAXIMUM_RETRIES;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine(Irp,
                           ScsiClassIoComplete,
                           srb,
                           TRUE,
                           TRUE,
                           FALSE);

    return STATUS_PENDING;

} // end TapeReadWrite()

NTSTATUS
TapeSetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This is an unsupported routine for the Overland 9-track tape device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;

} // end TapeSetDriveParameters()


NTSTATUS
TapeSetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine sets the fixed-length logical block size or variable-length
    block mode (if the block size is 0).

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_SET_MEDIA_PARAMETERS tapeSetMediaParams = Irp->AssociatedIrp.SystemBuffer;
    PMODE_PARM_READ_WRITE_DATA buffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    DebugPrint((3,"TapeIoControl: Set Tape Media Parameters \n"));

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);
    cdb->MODE_SELECT.Reserved1 = MODE_SELECT_PFBIT;

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
        sizeof(MODE_PARM_READ_WRITE_DATA));

    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(buffer, sizeof(MODE_PARM_READ_WRITE_DATA));

    buffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
    buffer->ParameterListHeader.BlockDescriptorLength = MODE_BLOCK_DESC_LENGTH;

    buffer->ParameterListBlock.BlockLength[0] =
        (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
    buffer->ParameterListBlock.BlockLength[1] =
        (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
    buffer->ParameterListBlock.BlockLength[2] =
        (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                buffer,
                                sizeof( MODE_PARM_READ_WRITE_DATA ),
                                TRUE);

    ExFreePool(buffer);

    return status;

} // end TapeSetMediaParameters()


NTSTATUS
TapeSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine sets the position of the tape.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_DATA          tapeData = (PTAPE_DATA)(deviceExtension + 1);
    PTAPE_SET_POSITION  tapeSetPosition = Irp->AssociatedIrp.SystemBuffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    srb.CdbLength = CDB6GENERIC_LENGTH;

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    switch (tapeSetPosition->Method) {
        case TAPE_REWIND:
            DebugPrint((3,"TapeIoControl: Rewind Tape\n"));
            cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
            break;

        case TAPE_SPACE_END_OF_DATA:
            DebugPrint((3,"TapeIoControl: Position Tape to End-of-Data\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Byte6.value = 3;
            break;

        case TAPE_SPACE_RELATIVE_BLOCKS:
            DebugPrint((3,"TapeIoControl: Position Tape by Spacing Blocks\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Byte6.value = 0;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            break;

        case TAPE_SPACE_FILEMARKS:
            DebugPrint((3,"TapeIoControl: Position Tape by Spacing Filemarks\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Byte6.value = 1;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            break;

        case TAPE_SPACE_SEQUENTIAL_FMKS:
            DebugPrint((3,"TapeIoControl: Position Tape by Spacing Sequential Filemarks\n"));
            cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
            cdb->SPACE_TAPE_MARKS.Byte6.value = 2;
            cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 16) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapeSetPosition->Offset.LowPart >> 8) & 0xFF);
            cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapeSetPosition->Offset.LowPart & 0xFF);
            break;

        default:
            DebugPrint((3,"TapeIoControl: Tape Operation Not Supported\n"));
            return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Set immediate bit if indicated.
    //

    cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                NULL,
                                0,
                                FALSE);

    return status;

} // end TapeSetPosition()


BOOLEAN
TapeVerifyInquiry(
    IN PSCSI_INQUIRY_DATA LunInfo
    )

/*++
Routine Description:

    This routine determines if the driver should claim this device.

Arguments:

    LunInfo

Return Value:

    TRUE - driver should claim this device.
    FALSE - driver should not claim this device.

--*/

{
    PINQUIRYDATA        inquiryData;

    DebugPrint((3,"TapeVerifyInquiry: Verify Tape Inquiry Data\n"));

    inquiryData = (PVOID)LunInfo->InquiryData;

    return ((RtlCompareMemory(inquiryData->VendorId,"OVERLAND",8) == 8) &&
           ((RtlCompareMemory(inquiryData->ProductId,"_5212/5214",10) == 10) ||
           (RtlCompareMemory(inquiryData->ProductId,"_5612/5614",10) == 10)));

} // end TapeVerifyInquiry()


NTSTATUS
TapeWriteMarks(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This routine writes tapemarks on the tape.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PTAPE_WRITE_MARKS   tapeWriteMarks = Irp->AssociatedIrp.SystemBuffer;
    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    srb.CdbLength = CDB6GENERIC_LENGTH;

    cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;

    cdb->WRITE_TAPE_MARKS.TransferLength[0] =
        (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);

    cdb->WRITE_TAPE_MARKS.TransferLength[1] =
        (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);

    cdb->WRITE_TAPE_MARKS.TransferLength[2] =
        (UCHAR)(tapeWriteMarks->Count & 0xFF);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = deviceExtension->TimeOutValue;

    switch (tapeWriteMarks->Type) {
        case TAPE_FILEMARKS:
            DebugPrint((3,"TapeWriteMarks: Write Filemarks to Tape\n"));
            break;

        default:
            DebugPrint((3,"TapeWriteMarks: Tape Operation Not Supported\n"));
            return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Set immediate bit if indicated.
    //

    cdb->CDB6GENERIC.Immediate = tapeWriteMarks->Immediate;

    status = ScsiClassSendSrbSynchronous(DeviceObject,
                                &srb,
                                NULL,
                                0,
                                FALSE);

    return status;

} // end TapeWriteMarks()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\dlttape\dlttape.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dlttape.c
//
//--------------------------------------------------------------------------

/*++

Copyright (c) Microsoft 1998

Module Name:

    dlttape.c

Abstract:

    This module contains device specific routines for DLT drives.

Environment:

    kernel mode only

Revision History:


--*/

#include "minitape.h"
#include "dlttape.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

STORAGE_MEDIA_TYPE DLTMedia[DLT_SUPPORTED_TYPES] = {DLT,CLEANER_CARTRIDGE};


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = TapeError ;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = DLT_SUPPORTED_TYPES;

    tapeInitData.TapeWMIOperations = TapeWMIControl;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData);
    extension->CompressionOn = FALSE ;
}


TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));

    DebugPrint((1,"TapeCreatePartition: operation not supported\n"));

    return TAPE_STATUS_NOT_IMPLEMENTED;

} // end TapeCreatePartition()


TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            switch (tapeErase->Type) {
                case TAPE_ERASE_LONG:
                    DebugPrint((3,"TapeErase: immediate\n"));
                    break;

                case TAPE_ERASE_SHORT:
                default:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = SETBITON;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 23760;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    ASSERT( CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapeErase()


VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer = Srb->SenseInfoBuffer;
    UCHAR              sensekey;
    UCHAR              adsenseq;
    UCHAR              adsense;

    DebugPrint((3,"TapeError: Enter routine\n"));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       sensekey = senseBuffer->SenseKey & 0x0F;
       adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
       adsense = senseBuffer->AdditionalSenseCode;

       if (sensekey == SCSI_SENSE_RECOVERED_ERROR) {
           if ((adsense == SCSI_ADSENSE_VENDOR_UNIQUE) && (adsenseq == DLT_ASCQ_CLEANING_REQUEST)) {
               *LastError = TAPE_STATUS_REQUIRES_CLEANING;
           }
       }

       if (sensekey == SCSI_SENSE_MEDIUM_ERROR) {
           if ((adsense == SCSI_ADSENSE_VENDOR_UNIQUE) && (adsenseq == DLT_ASCQ_CLEANING_REQUIRED)) {
               *LastError = TAPE_STATUS_REQUIRES_CLEANING;
           }
       }

       if (sensekey == SCSI_SENSE_NOT_READY) {
           if ((adsense == SCSI_ADSENSE_LUN_NOT_READY) && 
               (adsenseq == SCSI_SENSEQ_INIT_COMMAND_REQUIRED)) {
               *LastError = TAPE_STATUS_NO_MEDIA;
           }
       }
    }

    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    return;
} // end TapeError()


TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimitsBuffer;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if ( CallNumber == 1 ) {

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        tapeGetDriveParams->ReportSetmarks =
            (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk? 1 : 0 );


        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);


        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        compressionModeSenseBuffer = Srb->DataBuffer ;

        if ((LastError == TAPE_STATUS_SUCCESS) &&
           compressionModeSenseBuffer->DataCompressPage.DCC) {

            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
                (compressionModeSenseBuffer->DataCompressPage.DCE? TRUE : FALSE);

        }

        if ( LastError != TAPE_STATUS_SUCCESS ) {
            switch (extension->DriveID) {
                case CIP_T860DLT:
                case DEC_TZ85:
                case DEC_TZ87:
                    if (LastError == TAPE_STATUS_INVALID_DEVICE_REQUEST) {
                        LastError = TAPE_STATUS_SUCCESS;
                        break;
                    }
                    // else: fall through to next case!

                default:
                    DebugPrint((1,"TapeGetDriveParameters: mode sense, SendSrb unsuccessful\n"));
                    return LastError;
            }
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(READ_BLOCK_LIMITS_DATA) ) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimitsBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimitsBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        Srb->DataTransferLength = sizeof(READ_BLOCK_LIMITS_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

   ASSERT ( CallNumber == 3 ) ;

   blockLimitsBuffer = Srb->DataBuffer ;

   tapeGetDriveParams->MaximumBlockSize = blockLimitsBuffer->BlockMaximumSize[2];
   tapeGetDriveParams->MaximumBlockSize += (blockLimitsBuffer->BlockMaximumSize[1] << 8);
   tapeGetDriveParams->MaximumBlockSize += (blockLimitsBuffer->BlockMaximumSize[0] << 16);

   tapeGetDriveParams->MinimumBlockSize = blockLimitsBuffer->BlockMinimumSize[1];
   tapeGetDriveParams->MinimumBlockSize += (blockLimitsBuffer->BlockMinimumSize[0] << 8);

   tapeGetDriveParams->DefaultBlockSize = 32768;
   if ((extension->DriveID == QUANTUM_7000) ||
       (extension->DriveID == QUANTUM_8000) ||
       (extension->DriveID == COMPAQ_8000)  ||
       (extension->DriveID == BNCHMARK_DLT1)) {

       //
       // All wide adapters should be able to handle this.
       //

       tapeGetDriveParams->DefaultBlockSize = 65536;
   }

   tapeGetDriveParams->FeaturesLow |=
       TAPE_DRIVE_ERASE_LONG       |
       TAPE_DRIVE_ERASE_BOP_ONLY   |
       TAPE_DRIVE_ERASE_IMMEDIATE  |
       TAPE_DRIVE_FIXED_BLOCK      |
       TAPE_DRIVE_VARIABLE_BLOCK   |
       TAPE_DRIVE_WRITE_PROTECT    |
       TAPE_DRIVE_GET_ABSOLUTE_BLK |
       TAPE_DRIVE_GET_LOGICAL_BLK  |
       TAPE_DRIVE_TAPE_CAPACITY    |
       TAPE_DRIVE_TAPE_REMAINING   |
       TAPE_DRIVE_CLEAN_REQUESTS;

   tapeGetDriveParams->FeaturesHigh |=
       TAPE_DRIVE_LOAD_UNLOAD       |
       TAPE_DRIVE_REWIND_IMMEDIATE  |
       TAPE_DRIVE_SET_BLOCK_SIZE    |
       TAPE_DRIVE_LOAD_UNLD_IMMED   |
       TAPE_DRIVE_ABSOLUTE_BLK      |
       TAPE_DRIVE_LOGICAL_BLK       |
       TAPE_DRIVE_END_OF_DATA       |
       TAPE_DRIVE_RELATIVE_BLKS     |
       TAPE_DRIVE_FILEMARKS         |
       TAPE_DRIVE_SEQUENTIAL_FMKS   |
       TAPE_DRIVE_REVERSE_POSITION  |
       TAPE_DRIVE_WRITE_FILEMARKS   |
       TAPE_DRIVE_WRITE_MARK_IMMED;

   if ((extension->DriveID == CIP_T860DLT) ||
       (extension->DriveID == CIP_DLT2000) ||
       (extension->DriveID == QUANTUM_7000)||
       (extension->DriveID == QUANTUM_8000) ||
       (extension->DriveID == COMPAQ_8000) ||
       (extension->DriveID == BNCHMARK_DLT1)) {

       tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_LOCK_UNLOCK;
   }


   tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

   DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
       tapeGetDriveParams->FeaturesLow));
   DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
       tapeGetDriveParams->FeaturesHigh));

   return TAPE_STATUS_SUCCESS;

} // end TapeGetDriveParameters()


TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PDLT_SENSE_DATA             senseData;
    ULONG                       remaining;
    ULONG                       temp ;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {

            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer ;


        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 2) {

        UCHAR senseDataSize;

        modeBuffer = Srb->DataBuffer ;

        tapeGetMediaParams->PartitionCount = 0 ;

        tapeGetMediaParams->BlockSize = modeBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);

        tapeGetMediaParams->WriteProtected =
            ((modeBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

        senseDataSize = sizeof(DLT_SENSE_DATA);
        if ((extension->DriveID == QUANTUM_7000) ||
            (extension->DriveID == QUANTUM_8000) ||
            (extension->DriveID == COMPAQ_8000) ||
            (extension->DriveID == BNCHMARK_DLT1)){

            //
            // The 7000 & 8000 have one additional 'reserved' byte.
            //

            senseDataSize += 1;
        }

        //
        // Build a request sense to get remaining values.
        //

        if (!TapeClassAllocateSrbBuffer( Srb, senseDataSize)) {
            DebugPrint((1,
                       "GetRemaining Size: insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = senseDataSize;
        Srb->DataTransferLength = senseDataSize;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3) {
        if (LastError == TAPE_STATUS_SUCCESS) {

            //
            // As a rewind was sent, get the remaining capacity from BOP.
            //

            senseData = Srb->DataBuffer;

            DebugPrint((1,
                       "GetMediaParameters: remaining Bytes %x %x %x %x\n",
                       senseData->Remaining[0],
                       senseData->Remaining[1],
                       senseData->Remaining[2],
                       senseData->Remaining[3]));

            remaining =  (senseData->Remaining[0] << 24);
            remaining += (senseData->Remaining[1] << 16);
            remaining += (senseData->Remaining[2] << 8);
            remaining += (senseData->Remaining[3]);


            DebugPrint((1,
                       "GetMediaParameters: remaining Ulong %x\n",
                       remaining));

            tapeGetMediaParams->Capacity.LowPart = extension->Capacity;
            tapeGetMediaParams->Capacity.QuadPart <<= 12;

            DebugPrint((1,
                       "Capacity returned %x %x\n",
                       tapeGetMediaParams->Capacity.HighPart,
                       tapeGetMediaParams->Capacity.LowPart));

            tapeGetMediaParams->Remaining.LowPart = remaining;
            tapeGetMediaParams->Remaining.QuadPart <<= 12;


            DebugPrint((1,
                       "Remaining returned %x %x\n",
                       tapeGetMediaParams->Remaining.HighPart,
                       tapeGetMediaParams->Remaining.LowPart));

        }
    }


    return TAPE_STATUS_SUCCESS ;

} // end TapeGetMediaParameters()


TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PTAPE_POSITION_DATA         logicalBuffer;
    ULONG                       type;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {


        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;

    }
    if ( CallNumber == 1 ) {

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = FALSE ;

        cdb->WRITE_TAPE_MARKS.TransferLength[0] = 0 ;
        cdb->WRITE_TAPE_MARKS.TransferLength[1] = 0 ;
        cdb->WRITE_TAPE_MARKS.TransferLength[2] = 0 ;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: flushing TapeWriteMarks: SendSrb\n"));
        Srb->DataTransferLength = 0 ;
        *RetryFlags |= IGNORE_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if ( CallNumber == 2 ) {

        switch (tapeGetPosition->Type) {

            case TAPE_ABSOLUTE_POSITION:
            case TAPE_LOGICAL_POSITION:

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(TAPE_POSITION_DATA)) ) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (logicalBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                logicalBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));
                Srb->DataTransferLength = sizeof(TAPE_POSITION_DATA) ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
                break ;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;

        }
    }
    ASSERT( CallNumber == 3 ) ;

    logicalBuffer = Srb->DataBuffer ;

    tapeGetPosition->Offset.HighPart = 0;

    REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                          (PFOUR_BYTE)logicalBuffer->FirstBlock);

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetPosition()


TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCOMMAND_EXTENSION commandExtension = CommandExtension;
    PCDB            cdb = (PCDB)Srb->Cdb;
    PDLT_SENSE_DATA senseData;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags |= RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        commandExtension->CurrentState = LastError;

        //
        // Issue a request sense to get the cleaning info bits.
        //

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(DLT_SENSE_DATA))) {
            DebugPrint((1,
                        "GetStatus: Insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(DLT_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        Srb->DataTransferLength = sizeof(DLT_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    } else if (CallNumber == 2) {
        if ((commandExtension->CurrentState == TAPE_STATUS_SUCCESS)  ||
            (commandExtension->CurrentState == TAPE_STATUS_NO_MEDIA)) {

            //
            // Return needs cleaning status if necessary, but only if
            // no other errors are present (with the exception of no media as the
            // drive will spit out AME media when in this state).
            //

            senseData = Srb->DataBuffer;

            //
            // Determine if the clean bit is set.
            //

            if (senseData->InternalStatusCode & BIT_FLAG_FORMAT) {
                if (senseData->InternalStatusCode & CLEANING_LIGHT_ON) {
                    DebugPrint((1,
                               "Drive reports needs cleaning - InternalStatusCode %x\n",
                               senseData->InternalStatusCode));

                    return TAPE_STATUS_REQUIRES_CLEANING;
                }
            }

            return (commandExtension->CurrentState);
        } else {

            //
            // Return the saved error status.
            //

            return commandExtension->CurrentState;
        }
    }

    return TAPE_STATUS_SUCCESS;
}


TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_PREPARE               tapePrepare = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PDLT_SENSE_DATA             senseData;
    ULONG                       remaining;
    ULONG                       temp ;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_LOCK:
                case TAPE_UNLOCK:
                    if ((extension->DriveID == DEC_TZ85) || (extension->DriveID == DEC_TZ87) ){
                        DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                        return TAPE_STATUS_NOT_IMPLEMENTED;
                    }
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_TENSION:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                break;

            case TAPE_LOCK:
                if ((extension->DriveID == DEC_TZ85) || (extension->DriveID == DEC_TZ87) ){
                    DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
                }

                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;

            case TAPE_UNLOCK:
                if ((extension->DriveID == DEC_TZ85) || (extension->DriveID == DEC_TZ87) ){
                    DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
                }

                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                break;

            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 1) {
        if (tapePrepare->Operation == TAPE_LOAD) {

            //
            // Issue a request sense to get the cleaning info bits.
            //

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(DLT_SENSE_DATA))) {
                DebugPrint((1,
                            "GetStatus: Insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->ScsiStatus = Srb->SrbStatus = 0;
            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(DLT_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            Srb->DataTransferLength = sizeof(DLT_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        } else {

            return TAPE_STATUS_CALLBACK ;
        }

    }

    if (LastError == TAPE_STATUS_SUCCESS) {

        senseData = Srb->DataBuffer;

        remaining =  (senseData->Remaining[0] << 24);
        remaining += (senseData->Remaining[1] << 16);
        remaining += (senseData->Remaining[2] << 8);
        remaining += (senseData->Remaining[3]);

        extension->Capacity = remaining;
    }

    return TAPE_STATUS_SUCCESS;

} // end TapePrepare()


TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;
    PMODE_DEVICE_CONFIG_PAGE    configBuffer;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {

            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        configBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 1 ) {

        configBuffer = Srb->DataBuffer ;

        configBuffer->ParameterListHeader.ModeDataLength = 0;
        configBuffer->ParameterListHeader.MediumType = 0;
        configBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        configBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        configBuffer->DeviceConfigPage.PageCode = MODE_PAGE_DEVICE_CONFIG;
        configBuffer->DeviceConfigPage.PageLength = 0x0E;

        if (tapeSetDriveParams->ReportSetmarks) {
            configBuffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            configBuffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 2 ) {

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3 ) {

        if ( LastError != TAPE_STATUS_SUCCESS ) {

            switch (extension->DriveID) {
                case CIP_T860DLT:
                case DEC_TZ85:
                case DEC_TZ87:
                    if (LastError == TAPE_STATUS_INVALID_DEVICE_REQUEST) {
                        return TAPE_STATUS_SUCCESS ;
                        break;
                    }
                    // else: fall through to next case!

                default:
                    DebugPrint((1,"TapeSetDriveParameters: mode sense, SendSrb unsuccessful\n"));
            }

            return LastError;

        }

        compressionBuffer = Srb->DataBuffer ;

        compressionBuffer->ParameterListHeader.ModeDataLength = 0;
        compressionBuffer->ParameterListHeader.MediumType = 0;
        compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        compressionBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        compressionBuffer->DataCompressPage.PageCode = MODE_PAGE_DATA_COMPRESS;
        compressionBuffer->DataCompressPage.PageLength = 0x0E;

        if (tapeSetDriveParams->Compression) {
            compressionBuffer->DataCompressPage.DCE = SETBITON;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[3]= 0x10;
        } else {
            compressionBuffer->DataCompressPage.DCE = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT(CallNumber == 4 ) ;
    return TAPE_STATUS_SUCCESS ;

} // end TapeSetDriveParameters()


TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if ((extension->DriveID == QUANTUM_7000) ||
            (extension->DriveID == QUANTUM_8000) ||
            (extension->DriveID == COMPAQ_8000) ||
            (extension->DriveID == BNCHMARK_DLT1)) {

            //
            // Ensure that the new block size isn't 'odd'.
            //

            if (tapeSetMediaParams->BlockSize & 0x01) {
                DebugPrint((1,
                           "SetMediaParameters: Attempting to set odd block size - %x\n",
                           tapeSetMediaParams->BlockSize));

                return TAPE_STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {
        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer ;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
            MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.BlockLength[0] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
            (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT(CallNumber == 2 ) ;

    return TAPE_STATUS_SUCCESS;

} // end TapeSetMediaParameters()


TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_POSITION          tapeSetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    ULONG                       tapePositionVector;
    PDLT_SENSE_DATA             senseData;
    ULONG                       remaining;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
           switch (tapeSetPosition->Method) {
        case TAPE_REWIND:
        case TAPE_LOGICAL_BLOCK:
        case TAPE_ABSOLUTE_BLOCK: {     
           DebugPrint((3,"TapeSetPosition: immediate\n"));
           break;
        }

                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS: {
           DebugPrint((3, 
                   "TapeSetPosition-Operation Immediate : %x.\n",
                   tapeSetPosition->Method));
           break;
        }

                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:
                default:
                    DebugPrint((1,
                "TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        tapePositionVector = tapeSetPosition->Offset.LowPart;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (tapeSetPosition->Method) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                break;

            case TAPE_ABSOLUTE_BLOCK:
            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (logical)\n"));
                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] =
                    (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11800;
                break;

            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 11800;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:

                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;

                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);

                Srb->TimeOutValue = 11800;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                   (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11800;
               break;

           case TAPE_SPACE_SEQUENTIAL_FMKS:
               DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));
               cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
               cdb->SPACE_TAPE_MARKS.Code = 2;
               cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                   (UCHAR)((tapePositionVector >> 16) & 0xFF);
               cdb->SPACE_TAPE_MARKS.NumMarks =
                   (UCHAR)((tapePositionVector >> 8) & 0xFF);
               cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                   (UCHAR)(tapePositionVector & 0xFF);
               Srb->TimeOutValue = 11800;
               break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
         }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 1) {

        if (tapeSetPosition->Method == TAPE_REWIND) {

            //
            // Build a request sense to get remaining values.
            //

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(DLT_SENSE_DATA)) ) {
                DebugPrint((1,
                           "GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->ScsiStatus = Srb->SrbStatus = 0;
            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(DLT_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(DLT_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        } else if (tapeSetPosition->Method == TAPE_SPACE_SEQUENTIAL_FMKS) {
       DebugPrint((3, "TAPE_SPACE_SEQUENTIAL_FMKS Success.\n"));
    }
    }

    if (CallNumber == 2) {
        if (LastError == TAPE_STATUS_SUCCESS) {

            //
            // As a rewind was sent, get the remaining capacity from BOP.
            //

            senseData = Srb->DataBuffer;

            remaining =  (senseData->Remaining[0] << 24);
            remaining += (senseData->Remaining[1] << 16);
            remaining += (senseData->Remaining[2] << 8);
            remaining += (senseData->Remaining[3]);

            extension->Capacity = remaining;
        }
    }
    return TAPE_STATUS_SUCCESS ;

} // end TapeSetPosition()


TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;
    LARGE_INTEGER      timeout ;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        switch (tapeWriteMarks->Type) {
            case TAPE_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: immediate\n"));
                break;

            case TAPE_SETMARKS:
            case TAPE_SHORT_FILEMARKS:
            case TAPE_LONG_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;

        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;


        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT (CallNumber == 1 ) ;
    /* we may need to add a delay for the tz87 */

    return TAPE_STATUS_SUCCESS ;

} // end TapeWriteMarks()


TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION commandExtension = CommandExtension;
    ULONG i;
    ULONG currentMedia  = 0;
    ULONG blockSize = 0;
    UCHAR mediaType = 0;
    UCHAR densityCode = 0;
    UCHAR deviceSpecificParameter = 0;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        commandExtension->CurrentState = 0;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    //
    // If there is a cleaner cartridge, we get TAPE_STATUS_NO_MEDIA
    // we'll  send LogSense command to find out the type of media
    //
    if ((LastError == TAPE_STATUS_BUS_RESET) || 
        (LastError == TAPE_STATUS_MEDIA_CHANGED) || 
        (LastError == TAPE_STATUS_SUCCESS) ||
        (LastError == TAPE_STATUS_DEVICE_NOT_READY)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {

                DebugPrint((1,
                            "Dlttape.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS));
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)Srb->DataTransferLength;

            commandExtension->CurrentState = SCSIOP_MODE_SENSE;
            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        }
    } else if (LastError == TAPE_STATUS_NO_MEDIA) {
        if (CallNumber == 1) {
            //
            // If we get this status, it could mean there's no media in the
            // drive or there's a cleaner cartridge. Send TapeAlert Info
            // command 
            //
            if (((extension->DriveID) == COMPAQ_8000) ||
                ((extension->DriveID) == QUANTUM_8000)) {
                commandExtension->CurrentState = SCSIOP_LOG_SENSE;
                return PrepareSrbForTapeAlertInfo(Srb);
            }
        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {


        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, two types (either known dlt/cleaner or unknown) are returned.
        //

        mediaTypes->MediaInfoCount = 2;

        //
        // Determine the media type currently loaded.
        //

        if ( LastError == TAPE_STATUS_SUCCESS ) {
            if ((commandExtension->CurrentState) ==  SCSIOP_MODE_SENSE) {

                PMODE_DEVICE_CONFIG_PAGE_PLUS configInformation = Srb->DataBuffer;
                
                mediaType = configInformation->ParameterListHeader.MediumType;

                blockSize = configInformation->ParameterListBlock.BlockLength[2];
                blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
                blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

                deviceSpecificParameter = configInformation->ParameterListHeader.DeviceSpecificParameter;

                densityCode = configInformation->ParameterListBlock.DensityCode;

                DebugPrint((1,
                            "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                            mediaType,
                            blockSize));

                switch (mediaType) {
                    case 0: {

                        currentMedia = 0;

                        //
                        // Check density code, just in case - DEC TLZ86/87
                        // Benchmark drives report 0 for medium type for brand new
                        // media, but return non-zero density code.
                        //
                        if (densityCode != 0) {

                                currentMedia = DLT;

                        } 

                        break;
                    }

                    case 0x81:

                        //
                        // Cleaning cartridge.
                        //

                        currentMedia = CLEANER_CARTRIDGE;
                        break;

                    case 0x82:
                    case 0x83:
                    case 0x84:
                    case 0x85:
                    case 0x86:

                        //
                        // DLT 1,2,3,or 4.
                        //

                        currentMedia = DLT;
                        break;

                    default:

                        //
                        // Unknown
                        //

                        currentMedia = 0;
                        break;
                } // switch (mediaType)
            } else if ((commandExtension->CurrentState) ==  SCSIOP_LOG_SENSE) {
                PTAPE_ALERT_INFO tapeAlertInfo;
                PLOG_SENSE_PAGE_HEADER logSenseHeader;
                LONG bytesLeft = 0;

                //
                // Check if "CLEANER MEDIA" flag is set
                //
                currentMedia = 0;
                bytesLeft = GetNumberOfBytesReturned(Srb);

                logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
                tapeAlertInfo= (PTAPE_ALERT_INFO)((PUCHAR)logSenseHeader +
                                  sizeof(LOG_SENSE_PAGE_HEADER));
                while (bytesLeft >= sizeof(TAPE_ALERT_INFO)) {

                    if ((tapeAlertInfo->ParamCodeLB) == CLEANING_MEDIA) {

                        if (tapeAlertInfo->Flag) {
                            currentMedia = CLEANER_CARTRIDGE;
                        }

                        break;
                    }

                    tapeAlertInfo++;
                    bytesLeft -= sizeof(TAPE_ALERT_INFO);
                }
            }
        } 


        //
        // At this point, currentMedia should either be 0, or a valid
        // mediatype supported
        //
        DebugPrint((3, "Currents Media is %d\n", currentMedia));

        //
        // fill in buffer based on spec. values
        //

        for (i = 0; i < DLT_SUPPORTED_TYPES; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = DLTMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (DLTMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    densityCode;

                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((deviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }
    }

    return TAPE_STATUS_SUCCESS;
}

static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"CIPHER  ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"T860",4) == 4) {
            return CIP_T860DLT;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"L860",4) == 4) {
            return CIP_T860DLT;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZ86",4) == 4) {
            return DEC_TZ85;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT2000",7) == 7) {
            return CIP_DLT2000;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"DEC",3) == 3) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"THZ02",5) == 5) {
            return DEC_TZ85;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZ86",4) == 4) {
            return DEC_TZ85;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZ87",4) == 4) {
            return DEC_TZ87;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZ88",4) == 4) {
            return DEC_TZ87;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"TZ89",4) == 4) {
            return QUANTUM_7000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT2000",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT2500",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT2700",7) == 7) {
            return CIP_DLT2000;
        }
        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT4000",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT4500",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT4700",7) == 7) {
            return CIP_DLT2000;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"Quantum",7) == 7) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT2000",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT2500",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT2700",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT4000",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT4500",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT4700",7) == 7) {
            return CIP_DLT2000;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"QUANTUM",7) == 7) {
        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT7000",7) == 7) {
            return QUANTUM_7000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT8000",7) == 7) {
            return QUANTUM_8000;
        }

    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"COMPAQ",6) == 6) {
        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT8000",7) == 7) {
            return COMPAQ_8000;
        }
        if (TapeClassCompareMemory(InquiryData->ProductId,"SuperDLT1",9) == 9) {
            //
            // Issue : nramas 02/05/2001
            //   Super DLT drives should be assigned a separate ID
            //
            return COMPAQ_8000;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"BNCHMARK",8) == 8) {
        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT1",4) == 4) {
            return BNCHMARK_DLT1;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"TANDBERG",8) == 8) {
        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT4000",7) == 7) {
            return CIP_DLT2000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT7000",7) == 7) {
            return QUANTUM_7000;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"DLT8000",7) == 7) {
            return QUANTUM_8000;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\archqic\archqic.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    archqic.c

Abstract:

    This module contains device specific routines for Archive QIC
    drives: Anaconda 2800, Anaconda 2750, Viper 2525, Viper 2150, and
    Conner 3200.

Author:

    Mike Colandreo (Maynard)
    Norbert Kusters

Environment:

    kernel mode only

Revision History:

    Norbert Kusters - October 1994 - added support for ATAPI Conner 3200
    Norbert Kusters - November 1994 - converted to minitape model

--*/

#include "minitape.h"


//
//  Internal (module wide) defines that symbolize
//  non-QFA mode and the two QFA mode partitions.
//
#define NO_PARTITIONS        0  // non-QFA mode
#define DIRECTORY_PARTITION  1  // QFA mode, directory partition #
#define DATA_PARTITION       2  // QFA mode, data partition #

//
//  Internal (module wide) defines that symbolize
//  the Archive QIC drives supported by this module.
//
#define VIPER_150           1  // aka the Archive 250
#define VIPER_2525          2  // aka the Archive 525
#define ANACONDA_2750       3  // aka the Anaconda 2750
#define ANACONDA_2800       3  //handled identically the same as the 2750 herein

#define QIC_SUPPORTED_TYPES 1
STORAGE_MEDIA_TYPE QicMedia[QIC_SUPPORTED_TYPES] = {QIC};

//
//  Function prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);

//
// Minitape extension definition.
//

typedef struct _MINITAPE_EXTENSION {

    ULONG   CurrentPartition;
    ULONG   DriveID;
    ULONG   Version;

} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION;

typedef struct _COMMAND_EXTENSION {

    ULONG               CurrentState;
    UCHAR               MediumType;
    UCHAR               DensityCode;
    ULONG               TapeBlockLength;
    ULONG               Method;
    TAPE_PHYS_POSITION  PhysPosition;
    ULONG               TapePositionVector;
    ULONG               TapeBlockAddress;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = VerifyInquiry;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 0;
    tapeInitData.TapeError = NULL;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = QIC_SUPPORTED_TYPES;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}

BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine examines the given inquiry data to determine whether
    or not the given device is one that may be controller by this driver.

Arguments:

    InquiryData - Supplies the SCSI inquiry data.

Return Value:

    FALSE   - This driver does not recognize the given device.

    TRUE    - This driver recognizes the given device.

--*/

{
    return WhichIsIt(InquiryData) ? TRUE : FALSE;
}

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION extension = MinitapeExtension;

    extension->CurrentPartition = 0;
    extension->DriveID = WhichIsIt(InquiryData);
    extension->Version = InquiryData->Versions & 0x07;
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;
    PTAPE_CREATE_PARTITION  tapePartition = CommandParameters;
    PCDB                    cdb = (PCDB) Srb->Cdb;
    PINQUIRYDATA            inquiryBuffer;

    DebugPrint((3,"CreatePartition: Enter routine\n"));

    if (CallNumber == 0) {

        switch (tapePartition->Method) {
            case TAPE_FIXED_PARTITIONS:
                DebugPrint((3,"CreatePartition: fixed partitions\n"));
                break;

            case TAPE_SELECT_PARTITIONS:
            case TAPE_INITIATOR_PARTITIONS:
            default:
                DebugPrint((1,"TapeCreatePartition: "));
                DebugPrint((1,"PartitionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        if (extension->DriveID != ANACONDA_2750) {
            DebugPrint((1,"CreatePartition: driveID -- operation not supported\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = 0;

        cdb->PARTITION.OperationCode = SCSIOP_PARTITION;
        cdb->PARTITION.Sel = 1;
        cdb->PARTITION.PartitionSelect =
            tapePartition->Count? DATA_PARTITION : NO_PARTITIONS;

        //
        // Send SCSI command (CDB) to device
        //

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    if (tapePartition->Count == 0) {
        extension->CurrentPartition = NO_PARTITIONS;
        DebugPrint((3,"CreatePartition: QFA disabled\n"));
    } else {
        extension->CurrentPartition = DATA_PARTITION;
        DebugPrint((3,"CreatePartition: QFA enabled\n"));
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            switch (tapeErase->Type) {
                case TAPE_ERASE_LONG:
                    DebugPrint((3,"TapeErase: immediate\n"));
                    break;

                case TAPE_ERASE_SHORT:
                default:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = 0;

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = SETBITON;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 360;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;
    PMODE_DEVICE_CONFIG_PAGE    modeDevBuffer;
    PMODE_PARM_READ_WRITE_DATA  modeParmBuffer;
    PINQUIRYDATA                inquiryBuffer;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (modeParmBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeParmBuffer = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        modeParmBuffer = Srb->DataBuffer;

        commandExtension->MediumType = modeParmBuffer->ParameterListHeader.MediumType;
        commandExtension->DensityCode = modeParmBuffer->ParameterListBlock.DensityCode;
        commandExtension->TapeBlockLength  = modeParmBuffer->ParameterListBlock.BlockLength[2];
        commandExtension->TapeBlockLength += (modeParmBuffer->ParameterListBlock.BlockLength[1] << 8);
        commandExtension->TapeBlockLength += (modeParmBuffer->ParameterListBlock.BlockLength[0] << 16);

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(READ_BLOCK_LIMITS_DATA))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimits)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        commandExtension->CurrentState = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (commandExtension->CurrentState == 0) {

        blockLimits = Srb->DataBuffer;

        tapeGetDriveParams->MaximumBlockSize = blockLimits->BlockMaximumSize[2];
        tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
        tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

        tapeGetDriveParams->MinimumBlockSize = blockLimits->BlockMinimumSize[1];
        tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);

        commandExtension->CurrentState = 1;

    }

    if (commandExtension->CurrentState == 1) {

        if (extension->Version == 2) {

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE))) {
                DebugPrint((1,"TapeGetDriveParameters: insufficient resources (modeDevBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            modeDevBuffer = Srb->DataBuffer;

            //
            // Zero CDB in SRB on stack.
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.Dbd = SETBITON;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

            commandExtension->CurrentState = 2;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        } else {
            commandExtension->CurrentState = 3;
        }
    }

    if (commandExtension->CurrentState == 2) {

        modeDevBuffer = Srb->DataBuffer;

        tapeGetDriveParams->ReportSetmarks =
            (modeDevBuffer->DeviceConfigPage.RSmk ? 1 : 0 );

        tapeGetDriveParams->FeaturesLow |=
            TAPE_DRIVE_REPORT_SMKS;

        tapeGetDriveParams->FeaturesHigh |=
            TAPE_DRIVE_SET_REPORT_SMKS |
            TAPE_DRIVE_SETMARKS |
            TAPE_DRIVE_SEQUENTIAL_SMKS |
            TAPE_DRIVE_WRITE_SETMARKS;

        commandExtension->CurrentState = 3;
    }

    ASSERT(commandExtension->CurrentState == 3);

    tapeGetDriveParams->ECC = 0;
    tapeGetDriveParams->Compression = 0;
    tapeGetDriveParams->DataPadding = 0;

    switch (commandExtension->DensityCode) {
        case QIC_XX:
            switch (commandExtension->MediumType) {
                case DCXXXX:
                    if (extension->DriveID == VIPER_2525) {
                        tapeGetDriveParams->DefaultBlockSize = 1024;
                    } else {
                        tapeGetDriveParams->DefaultBlockSize = 512;
                    }
                    break;

                case DC6320:
                case DC6525:
                case DC9100:
                    tapeGetDriveParams->DefaultBlockSize = 1024;
                    break;

                default:
                    tapeGetDriveParams->DefaultBlockSize = 512;
                    break;
            }
            break;

        case QIC_525:
        case QIC_1000:
            tapeGetDriveParams->DefaultBlockSize = 1024;
            break;

        default:
            tapeGetDriveParams->DefaultBlockSize = 512;
            break;
    }

    if (extension->DriveID == ANACONDA_2750) {
        tapeGetDriveParams->MaximumPartitionCount = 2;
        tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_FIXED;
    } else {
        tapeGetDriveParams->MaximumPartitionCount = 0;
    }

    if (extension->DriveID != VIPER_150) {

        tapeGetDriveParams->FeaturesLow |=
            TAPE_DRIVE_VARIABLE_BLOCK;

        tapeGetDriveParams->FeaturesHigh |=
            TAPE_DRIVE_SET_BLOCK_SIZE;

    }

    tapeGetDriveParams->FeaturesLow |=
        TAPE_DRIVE_ERASE_LONG |
        TAPE_DRIVE_ERASE_BOP_ONLY |
        TAPE_DRIVE_ERASE_IMMEDIATE |
        TAPE_DRIVE_FIXED_BLOCK |
        TAPE_DRIVE_WRITE_PROTECT |
        TAPE_DRIVE_GET_ABSOLUTE_BLK |
        TAPE_DRIVE_GET_LOGICAL_BLK;

    tapeGetDriveParams->FeaturesHigh |=
        TAPE_DRIVE_LOAD_UNLOAD |
        TAPE_DRIVE_TENSION |
        TAPE_DRIVE_REWIND_IMMEDIATE |
        TAPE_DRIVE_LOAD_UNLD_IMMED |
        TAPE_DRIVE_TENSION_IMMED |
        TAPE_DRIVE_ABSOLUTE_BLK |
        TAPE_DRIVE_LOCK_UNLOCK |
        TAPE_DRIVE_ABS_BLK_IMMED |
        TAPE_DRIVE_LOGICAL_BLK |
        TAPE_DRIVE_END_OF_DATA |
        TAPE_DRIVE_RELATIVE_BLKS |
        TAPE_DRIVE_FILEMARKS |
        TAPE_DRIVE_SEQUENTIAL_FMKS |
        TAPE_DRIVE_REVERSE_POSITION |
        TAPE_DRIVE_WRITE_FILEMARKS |
        TAPE_DRIVE_WRITE_MARK_IMMED;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
        tapeGetDriveParams->FeaturesLow));
    DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
        tapeGetDriveParams->FeaturesHigh));

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PUCHAR                      partitionBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        modeBuffer = Srb->DataBuffer;
        tapeGetMediaParams->BlockSize = modeBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);
        tapeGetMediaParams->WriteProtected =
            ((modeBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);


        if (extension->DriveID == ANACONDA_2750) {

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(UCHAR)*2)) {
                DebugPrint((1,"TapeGetMediaParameters: insufficient resources (partitionBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            partitionBuffer = Srb->DataBuffer;

            //
            // Zero CDB in SRB on stack.
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(UCHAR);

            cdb->PARTITION.OperationCode = SCSIOP_PARTITION;

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetMediaParameters: SendSrb (partition)\n"));

            commandExtension->CurrentState = 0;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        } else {

            tapeGetMediaParams->PartitionCount = 0 ;
            extension->CurrentPartition = NO_PARTITIONS;
            commandExtension->CurrentState = 1;
        }
    }

    if (commandExtension->CurrentState == 0) {

        partitionBuffer = Srb->DataBuffer;
        tapeGetMediaParams->PartitionCount = *partitionBuffer? 2 : 1 ;
        extension->CurrentPartition = *partitionBuffer;
        commandExtension->CurrentState = 1;
    }

    ASSERT(commandExtension->CurrentState == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PINQUIRYDATA                inquiryBuffer;
    PTAPE_POSITION_DATA         tapePosBuffer;
    PUCHAR                      partitionBuffer;
    PUCHAR                      absoluteBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        commandExtension->Method = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = commandExtension->Method;

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        if (commandExtension->Method == TAPE_LOGICAL_POSITION) {

            if (extension->DriveID == ANACONDA_2750) {

                if (!TapeClassAllocateSrbBuffer(Srb, sizeof(UCHAR)*2)) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (partitionBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                partitionBuffer = Srb->DataBuffer;

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;
                Srb->DataTransferLength = sizeof(UCHAR);

                cdb->PARTITION.OperationCode = SCSIOP_PARTITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (partition)\n"));

                commandExtension->CurrentState = 0;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

            } else {
                extension->CurrentPartition = NO_PARTITIONS;
                commandExtension->CurrentState = 1;
            }
        } else {
            commandExtension->CurrentState = 3;
        }
    }

    if (commandExtension->CurrentState == 0) {

        partitionBuffer = Srb->DataBuffer;
        extension->CurrentPartition = *partitionBuffer;
        commandExtension->CurrentState = 1;
    }

    if (commandExtension->CurrentState == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (mode sense)\n"));

        commandExtension->CurrentState = 2;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (commandExtension->CurrentState == 2) {

        modeBuffer = Srb->DataBuffer;

        commandExtension->DensityCode = modeBuffer->ParameterListBlock.DensityCode;
        commandExtension->TapeBlockLength  = modeBuffer->ParameterListBlock.BlockLength[2];
        commandExtension->TapeBlockLength += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        commandExtension->TapeBlockLength += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);

        switch (commandExtension->DensityCode) {
            case QIC_1350:
            case QIC_2100:
                break;

            default:
                DebugPrint((3,"TapeGetPosition: pseudo logical\n"));
                commandExtension->Method = TAPE_PSEUDO_LOGICAL_POSITION;
                break;
        }

        commandExtension->CurrentState = 3;
    }

    if (commandExtension->CurrentState == 3) {

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        switch (commandExtension->Method) {
            case TAPE_PSEUDO_LOGICAL_POSITION:
            case TAPE_ABSOLUTE_POSITION:

                if (!TapeClassAllocateSrbBuffer(Srb, sizeof(UCHAR)*3)) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (absoluteBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                absoluteBuffer = Srb->DataBuffer;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;

                cdb->REQUEST_BLOCK_ADDRESS.OperationCode = SCSIOP_REQUEST_BLOCK_ADDR;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (request block address)\n"));

                commandExtension->CurrentState = 5;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

            case TAPE_LOGICAL_POSITION:

                if (!TapeClassAllocateSrbBuffer(Srb, sizeof(TAPE_POSITION_DATA))) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (absoluteBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                tapePosBuffer = Srb->DataBuffer;

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

                commandExtension->CurrentState = 7;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }
    }

    if (commandExtension->CurrentState == 4) {

        tapePosBuffer = Srb->DataBuffer;

        REVERSE_BYTES((PFOUR_BYTE)&commandExtension->TapeBlockAddress,
                      (PFOUR_BYTE)tapePosBuffer->FirstBlock);

        commandExtension->CurrentState = 6;
    }

    if (commandExtension->CurrentState == 5) {

        absoluteBuffer = Srb->DataBuffer;

        commandExtension->TapeBlockAddress  = absoluteBuffer[2];
        commandExtension->TapeBlockAddress += (absoluteBuffer[1] << 8);
        commandExtension->TapeBlockAddress += (absoluteBuffer[0] << 16);

        commandExtension->CurrentState = 6;
    }

    if (commandExtension->CurrentState == 6) {

        if (commandExtension->Method == TAPE_ABSOLUTE_POSITION) {

            tapeGetPosition->Partition = 0;
            tapeGetPosition->Offset.HighPart = 0;
            tapeGetPosition->Offset.LowPart = commandExtension->TapeBlockAddress;

        } else {

            commandExtension->TapeBlockAddress =
                TapeClassPhysicalBlockToLogicalBlock(
                    commandExtension->DensityCode,
                    commandExtension->TapeBlockAddress,
                    commandExtension->TapeBlockLength,
                    (BOOLEAN)(
                        (extension->CurrentPartition
                            == DIRECTORY_PARTITION)?
                        NOT_FROM_BOT : FROM_BOT
                    )
                );

            tapeGetPosition->Offset.HighPart = 0;
            tapeGetPosition->Offset.LowPart  = commandExtension->TapeBlockAddress;
            tapeGetPosition->Partition = extension->CurrentPartition;
        }

        commandExtension->CurrentState = 8;
    }

    if (commandExtension->CurrentState == 7) {

        tapePosBuffer = Srb->DataBuffer;

        if (tapePosBuffer->BlockPositionUnsupported) {
            DebugPrint((1,"TapeGetPosition: read position -- logical block position unsupported\n"));
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        tapeGetPosition->Partition = extension->CurrentPartition;

        tapeGetPosition->Offset.HighPart = 0;
        REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                      (PFOUR_BYTE)tapePosBuffer->FirstBlock);

        commandExtension->CurrentState = 8;
    }

    ASSERT(commandExtension->CurrentState == 8);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCDB    cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_PREPARE      tapePrepare = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                case TAPE_TENSION:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_LOCK:
                case TAPE_UNLOCK:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_TENSION:
                DebugPrint((3,"TapePrepare: Operation == tension\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
                Srb->TimeOutValue = 360;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                Srb->TimeOutValue = 180;
                break;

            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PMODE_DEVICE_CONFIG_PAGE    buffer;
    PINQUIRYDATA                inquiryBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if (extension->DriveID != ANACONDA_2750 ||
            extension->Version != 2) {

            DebugPrint((1,"TapeSetDriveParameters: driveID -- operation not supported\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE))) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (buffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        buffer = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        buffer = Srb->DataBuffer;

        buffer->ParameterListHeader.ModeDataLength = 0;
        buffer->ParameterListHeader.MediumType = 0;
        buffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        buffer->ParameterListHeader.BlockDescriptorLength = 0;

        if (tapeSetDriveParams->ReportSetmarks) {
            buffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            buffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 2);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PINQUIRYDATA                inquiryBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if (extension->DriveID == VIPER_150) {
            DebugPrint((1,"TapeSetMediaParameters: driveID -- operation not supported\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        if (extension->DriveID == VIPER_2525) {

            //
            // Zero CDB in SRB on stack.
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode sense)\n"));

            commandExtension->CurrentState = 0;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        } else {
            commandExtension->CurrentState = 0;
        }
    }

    if (commandExtension->CurrentState == 0) {

        modeBuffer = Srb->DataBuffer;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
            MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.BlockLength[0] = (UCHAR)
            ((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] = (UCHAR)
            ((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] = (UCHAR)
            (tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA);
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        commandExtension->CurrentState = 1;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(commandExtension->CurrentState == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_POSITION          tapeSetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PINQUIRYDATA                inquiryBuffer;
    PUCHAR                      partitionBuffer;


    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                case TAPE_ABSOLUTE_BLOCK:
                    DebugPrint((3,"TapeSetPosition: immediate\n"));
                    break;

                case TAPE_LOGICAL_BLOCK:
                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:
                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        commandExtension->Method = tapeSetPosition->Method;
        commandExtension->TapePositionVector = tapeSetPosition->Offset.LowPart;

        if (commandExtension->Method == TAPE_LOGICAL_BLOCK) {

            if (extension->DriveID == ANACONDA_2750) {

                if (!TapeClassAllocateSrbBuffer(Srb, sizeof(UCHAR)*2)) {
                    DebugPrint((1,"TapeSetPosition: insufficient resources (partitionBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                partitionBuffer = Srb->DataBuffer;

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;

                cdb->PARTITION.OperationCode = SCSIOP_PARTITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeSetPosition: SendSrb (partition)\n"));

                Srb->DataTransferLength = sizeof(UCHAR);

                commandExtension->CurrentState = 0;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

            } else {
                commandExtension->CurrentState = 1;
            }

        } else {
            commandExtension->CurrentState = 5;
        }
    }

    if (commandExtension->CurrentState == 0) {

        partitionBuffer = Srb->DataBuffer;
        extension->CurrentPartition = *partitionBuffer;

        if ((tapeSetPosition->Partition != 0) &&
            (extension->CurrentPartition == NO_PARTITIONS)) {
            DebugPrint((1,"TapeSetPosition: Partition -- invalid parameter\n"));
            return TAPE_STATUS_INVALID_PARAMETER;
        }

        commandExtension->CurrentState = 1;
    }

    if (commandExtension->CurrentState == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeSetPosition: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (mode sense)\n"));

        commandExtension->CurrentState = 2;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (commandExtension->CurrentState == 2) {

        modeBuffer = Srb->DataBuffer;

        commandExtension->DensityCode = modeBuffer->ParameterListBlock.DensityCode;
        commandExtension->TapeBlockLength  = modeBuffer->ParameterListBlock.BlockLength[2];
        commandExtension->TapeBlockLength += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        commandExtension->TapeBlockLength += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);

        switch (commandExtension->DensityCode) {
            case QIC_1350:
            case QIC_2100:
                commandExtension->CurrentState = 5;
                break;

            default:
                DebugPrint((3,"TapeSetPosition: pseudo logical\n"));

                commandExtension->Method = TAPE_PSEUDO_LOGICAL_BLOCK;

                if ((extension->DriveID == ANACONDA_2750) &&
                   (tapeSetPosition->Partition != 0)) {

                    //
                    // Zero CDB in SRB on stack.
                    //

                    TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                    //
                    // Prepare SCSI command (CDB)
                    //

                    Srb->CdbLength = CDB6GENERIC_LENGTH;

                    cdb->PARTITION.OperationCode = SCSIOP_PARTITION;
                    cdb->PARTITION.Sel = 1;
                    cdb->PARTITION.PartitionSelect = (UCHAR) tapeSetPosition->Partition;

                    //
                    // Send SCSI command (CDB) to device
                    //

                    DebugPrint((3,"TapeSetPosition: SendSrb (partition)\n"));

                    Srb->DataTransferLength = 0;

                    commandExtension->CurrentState = 3;

                    return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

                } else {
                    commandExtension->CurrentState = 4;
                }
                break;
        }
    }

    if (commandExtension->CurrentState == 3) {

        extension->CurrentPartition = tapeSetPosition->Partition;
        commandExtension->CurrentState = 4;
    }

    if (commandExtension->CurrentState == 4) {

        commandExtension->PhysPosition =
            TapeClassLogicalBlockToPhysicalBlock(
                commandExtension->DensityCode,
                commandExtension->TapePositionVector,
                commandExtension->TapeBlockLength,
                (BOOLEAN)(
                (extension->CurrentPartition
                     == DIRECTORY_PARTITION)?
                NOT_FROM_BOT : FROM_BOT
                )
            );

        commandExtension->TapePositionVector =
            commandExtension->PhysPosition.SeekBlockAddress;

        commandExtension->CurrentState = 5;
    }

    if (commandExtension->CurrentState == 5) {

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (commandExtension->Method) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 180;
                commandExtension->CurrentState = 7;
                break;

            case TAPE_PSEUDO_LOGICAL_BLOCK:
            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == seek block (absolute)\n"));
                cdb->SEEK_BLOCK.OperationCode = SCSIOP_SEEK_BLOCK;
                cdb->SEEK_BLOCK.BlockAddress[0] = (UCHAR)
                    ((commandExtension->TapePositionVector >> 16) & 0xFF);
                cdb->SEEK_BLOCK.BlockAddress[1] = (UCHAR)
                    ((commandExtension->TapePositionVector >> 8) & 0xFF);
                cdb->SEEK_BLOCK.BlockAddress[2] = (UCHAR)
                    (commandExtension->TapePositionVector & 0xFF);
                Srb->TimeOutValue = 480;
                if ((commandExtension->PhysPosition.SpaceBlockCount != 0) &&
                    (commandExtension->Method == TAPE_PSEUDO_LOGICAL_BLOCK)) {

                    //
                    // Send SCSI command (CDB) to device
                    //

                    DebugPrint((3,"TapeSetPosition: SendSrb (seek block)\n"));

                    Srb->DataTransferLength = 0;

                    *RetryFlags = 1;
                    commandExtension->CurrentState = 6;

                    return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
                } else {
                    commandExtension->CurrentState = 7;
                }
                break;

            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (logical)\n"));
                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)
                    ((commandExtension->TapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)
                    ((commandExtension->TapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)
                    ((commandExtension->TapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)
                    (commandExtension->TapePositionVector & 0xFF);
                if ((tapeSetPosition->Partition != 0) &&
                    (tapeSetPosition->Partition != extension->CurrentPartition)) {
                    cdb->LOCATE.Partition = (UCHAR) tapeSetPosition->Partition;
                    cdb->LOCATE.CPBit = SETBITON;
                }
                Srb->TimeOutValue = 480;
                commandExtension->CurrentState = 7;
                break;

            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 480;
                commandExtension->CurrentState = 7;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)
                    ((commandExtension->TapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)
                    ((commandExtension->TapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)
                    (commandExtension->TapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                commandExtension->CurrentState = 7;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)
                    ((commandExtension->TapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)
                    ((commandExtension->TapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)
                    (commandExtension->TapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                commandExtension->CurrentState = 7;
                break;

            case TAPE_SPACE_SEQUENTIAL_FMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 2;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)
                    ((commandExtension->TapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)
                    ((commandExtension->TapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)
                    (commandExtension->TapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                commandExtension->CurrentState = 7;
                break;

            case TAPE_SPACE_SETMARKS:
                DebugPrint((3,"TapeSetPosition: method == space setmarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 4;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)
                    ((commandExtension->TapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)
                    ((commandExtension->TapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)
                    (commandExtension->TapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                commandExtension->CurrentState = 7;
                break;

            case TAPE_SPACE_SEQUENTIAL_SMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential setmarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 5;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)
                    ((commandExtension->TapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)
                    ((commandExtension->TapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)
                    (commandExtension->TapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                commandExtension->CurrentState = 7;
                break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }
    }

    if (commandExtension->CurrentState == 6) {

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        DebugPrint((3,"TapeSetPosition: method == space block(s)\n"));
        cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
        cdb->SPACE_TAPE_MARKS.Code = 0;
        cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)
             ((commandExtension->PhysPosition.SpaceBlockCount >> 16) & 0xFF);
        cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)
             ((commandExtension->PhysPosition.SpaceBlockCount >> 8) & 0xFF);
        cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)
             (commandExtension->PhysPosition.SpaceBlockCount & 0xFF);
        commandExtension->CurrentState = 7;
    }

    if (commandExtension->CurrentState == 7) {

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0;

        if (commandExtension->Method == TAPE_PSEUDO_LOGICAL_BLOCK) {
            *RetryFlags = 1;
        }

        commandExtension->CurrentState = 8;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(commandExtension->CurrentState == 8);

    if (commandExtension->Method == TAPE_LOGICAL_BLOCK &&
        tapeSetPosition->Partition != 0) {

        extension->CurrentPartition = tapeSetPosition->Partition;
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                case TAPE_SHORT_FILEMARKS:
                case TAPE_LONG_FILEMARKS:
                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SETMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == setmarks\n"));
                cdb->WRITE_TAPE_MARKS.WriteSetMarks = SETBITON;
                break;

            case TAPE_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == filemarks\n"));
                break;

            case TAPE_SHORT_FILEMARKS:
            case TAPE_LONG_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] = (UCHAR)
            ((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] = (UCHAR)
            ((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] = (UCHAR)
            (tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
                DebugPrint((1,"GetMediaTypes: insufficient resources (modeParmBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_PARM_READ_WRITE_DATA));

            //
            // Zero CDB in SRB on stack.
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA);
            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {


        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;
        PMODE_PARM_READ_WRITE_DATA configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, only one type (either known or unknown) is returned.
        //

        mediaTypes->MediaInfoCount = 1;

        if ( LastError == TAPE_STATUS_SUCCESS ) {

            //
            // Determine the media type currently loaded.
            //

            mediaType = configInformation->ParameterListHeader.MediumType;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                        mediaType,
                        blockSize));


            currentMedia = QIC;

        } else {
            currentMedia = 0;
        }

        //
        // fill in buffer based on spec. values
        // Only one type supported now.
        //

        for (i = 0; i < QIC_SUPPORTED_TYPES; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = QicMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (QicMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;

                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    configInformation->ParameterListBlock.DensityCode;
                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }
    }

    return TAPE_STATUS_SUCCESS;
}


static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++

Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"ARCHIVE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"ANCDA 2800",10) == 10) {
            return ANACONDA_2800;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"ANCDA 2750",10) == 10) {
            return ANACONDA_2750;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"VIPER 2525",10) == 10) {
            return VIPER_2525;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"VIPER 150",9) == 9) {
            return VIPER_150;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\dlttape\dlttape.h ===
/*++

Copyright (c) Microsoft 1998

Module Name:

    dlttape.c

Abstract:

    This module contains device specific routines for DLT drives.

Environment:

    kernel mode only

Revision History:


--*/
#ifndef _DLTTAPE_H
#define _DLTTAPE_H

//
//  Internal (module wide) defines that symbolize
//  the Archive QIC drives supported by this module.
//
#define CIP_T860DLT     1  // aka the Cipher T860 DLT
                           // Vendor  ID - CIPHER
                           // Product ID - T860s
                           // Revision   - 430A

#define DEC_TZ85        2  // aka the DEC TZ85
                           // Vendor  ID - DEC
                           // Product ID - THZ02  (C)DEC
                           // Revision   - 4314

#define CIP_DLT2000     3  // aka the Cipher DLT 2000
                           // Vendor  ID - CIPHER
                           // Product ID - DLT2000
                           // Revision   - 8E01

#define DEC_TZ87        4  // aka the DEC TZ87
                           // Vendor  ID - DEC
                           // Product ID - (C)DEC
                           // Revision   - 9104

#define QUANTUM_7000    5
#define QUANTUM_8000    6

#define COMPAQ_8000     7

#define BNCHMARK_DLT1   8

#define SUPER_DLT       9


#define DLT_SUPPORTED_TYPES 2

#define DLT_ASCQ_CLEANING_REQUIRED 0x01
#define DLT_ASCQ_CLEANING_REQUEST  0x02

//
// Error counter upper limits
//
#define TAPE_READ_ERROR_LIMIT        0x8000
#define TAPE_WRITE_ERROR_LIMIT       0x8000

#define TAPE_READ_WARNING_LIMIT      0x4000
#define TAPE_WRITE_WARNING_LIMIT     0x4000

//
// Defines for type of parameter
//
#define TotalCorrectedErrors            0x0003
#define TotalTimesAlgorithmProcessed    0x0004
#define TotalGroupsProcessed            0x0005
#define TotalUncorrectedErrors          0x0006

//
// Minitape extension definition.
//
typedef struct _MINITAPE_EXTENSION {
          ULONG DriveID;
          ULONG Capacity;
          BOOLEAN CompressionOn;
} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION ;

//
// Command extension definition.
//
typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

//
// Bitfield def. of InternalStatusCode
//
#define BIT_FLAG_FORMAT   0x80
#define CLEANING_LIGHT_ON 0x01

//
// DLT Sense data - including addition length
// for remaining tape capacity fields.
//
typedef struct _DLT_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR SubAssemblyCode;
    UCHAR SenseKeySpecific[3];
    UCHAR InternalStatusCode;
    UCHAR TapeMotionHrs[2];
    UCHAR PowerOnHrs[4];
    UCHAR Remaining[4];
    //UCHAR Reserved3; -- 7000 only
} DLT_SENSE_DATA, *PDLT_SENSE_DATA;


//
// Defines for Log Sense Pages
//

#define LOGSENSEPAGE0                        0x00
#define LOGSENSEPAGE2                        0x02
#define LOGSENSEPAGE3                        0x03

//
// Defined Log Sense Page Header
//

typedef struct _LOG_SENSE_PAGE_HEADER {

   UCHAR PageCode : 6;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR Length[2];           // [0]=MSB ... [1]=LSB

} LOG_SENSE_PAGE_HEADER, *PLOG_SENSE_PAGE_HEADER;


//
// Defined Log Sense Parameter Header
//

typedef struct _LOG_SENSE_PARAMETER_HEADER {

   UCHAR ParameterCode[2];    // [0]=MSB ... [1]=LSB
   UCHAR LPBit     : 1;
   UCHAR Reserved1 : 1;
   UCHAR TMCBit    : 2;
   UCHAR ETCBit    : 1;
   UCHAR TSDBit    : 1;
   UCHAR DSBit     : 1;
   UCHAR DUBit     : 1;
   UCHAR ParameterLength;

} LOG_SENSE_PARAMETER_HEADER, *PLOG_SENSE_PARAMETER_HEADER;


//
// Defined Log Page Information - statistical values, accounts
// for maximum parameter values that is returned for each page
//

typedef struct _LOG_SENSE_PAGE_INFORMATION {

   union {

       struct {
          UCHAR Page0;
          UCHAR Page2;
          UCHAR Page3;
       } PageData ;

       struct {
           LOG_SENSE_PARAMETER_HEADER Parm1;
           UCHAR ErrorsCorrectedWithDelay[4];
           LOG_SENSE_PARAMETER_HEADER Parm2;
           UCHAR ErrorsCorrectedWithLesserDelay[4]; 
           LOG_SENSE_PARAMETER_HEADER Parm3;
           UCHAR TotalNumberofErrors[4];
           LOG_SENSE_PARAMETER_HEADER Parm4;
           UCHAR TotalErrorsCorrected[4];
           LOG_SENSE_PARAMETER_HEADER Parm5;
           UCHAR TotalTimesAlgoProcessed[4];
           LOG_SENSE_PARAMETER_HEADER Parm6;
           UCHAR TotalGroupsWritten[8];
           LOG_SENSE_PARAMETER_HEADER Parm7;
           UCHAR TotalErrorsUncorrected[4];
       } Page2 ;

       struct {
           LOG_SENSE_PARAMETER_HEADER Parm1;
           UCHAR ErrorsCorrectedWithDelay[4];
           LOG_SENSE_PARAMETER_HEADER Parm2;
           UCHAR ErrorsCorrectedWithLesserDelay[4]; 
           LOG_SENSE_PARAMETER_HEADER Parm3;
           UCHAR TotalNumberofErrors[4];
           LOG_SENSE_PARAMETER_HEADER Parm4;
           UCHAR TotalErrorsCorrected[4];
           LOG_SENSE_PARAMETER_HEADER Parm5;
           UCHAR TotalTimesAlgoProcessed[4];
           LOG_SENSE_PARAMETER_HEADER Parm6;
           UCHAR TotalGroupsWritten[8];
           LOG_SENSE_PARAMETER_HEADER Parm7;
           UCHAR TotalErrorsUncorrected[4];
       } Page3 ;

   } LogSensePage;


} LOG_SENSE_PAGE_INFORMATION, *PLOG_SENSE_PAGE_INFORMATION;



//
// Defined Log Sense Parameter Format - statistical values, accounts
// for maximum parameter values that is returned
//

typedef struct _LOG_SENSE_PARAMETER_FORMAT {

   LOG_SENSE_PAGE_HEADER       LogSenseHeader;
   LOG_SENSE_PAGE_INFORMATION  LogSensePageInfo;

} LOG_SENSE_PARAMETER_FORMAT, *PLOG_SENSE_PARAMETER_FORMAT;

//
// Tape Alert Info format
//
typedef struct _TAPE_ALERT_INFO {
    UCHAR  ParamCodeUB; // Upper byte of the param code
    UCHAR  ParamCodeLB; // Lower byte of the param code
    UCHAR  BitFields;
    UCHAR  ParamLen;
    UCHAR  Flag;
} TAPE_ALERT_INFO, *PTAPE_ALERT_INFO;

//
//  Function Prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);


BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

//
// Internal routines for wmi
//

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
  );

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   );

TAPE_STATUS
PrepareSrbForTapeAlertInfo(
    PSCSI_REQUEST_BLOCK Srb
    );

LONG
GetNumberOfBytesReturned(
    PSCSI_REQUEST_BLOCK Srb
    );

#endif // _DLTTAPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\dlttape\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for dlt tape drives.

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"
#include "dlttape.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TapeWMIControl)
#pragma alloc_text(PAGE, GetNumberOfBytesReturned)
#pragma alloc_text(PAGE, PrepareSrbForTapeAlertInfo)
#pragma alloc_text(PAGE, ProcessReadWriteErrors)
#pragma alloc_text(PAGE, QueryDeviceErrorData)
#pragma alloc_text(PAGE, QueryIoErrorData)
#pragma alloc_text(PAGE, VerifyReadWriteErrors)
#endif

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )
/*+
Routine Description:

   This is the common entry point for all WMI calls from tape class driver.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;

   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;

   switch (wmiOperations->Method) {
      case TAPE_CHECK_FOR_DRIVE_PROBLEM: {
         if ((miniExtension->DriveID == COMPAQ_8000) ||
             (miniExtension->DriveID == QUANTUM_8000)){
            return QueryDeviceErrorData(MinitapeExtension, 
                                        CommandExtension,
                                        CommandParameters, 
                                        Srb, CallNumber,
                                        LastError, RetryFlags);
         } else {
            return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                    CommandParameters, Srb, CallNumber,
                                    LastError, RetryFlags);
         }
         break;
      }

      case TAPE_QUERY_IO_ERROR_DATA: {
         return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                 CommandParameters, Srb, CallNumber,
                                 LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_DEVICE_ERROR_DATA: {
         return QueryDeviceErrorData(MinitapeExtension, CommandExtension,
                                     CommandParameters, Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      default: {
         return TAPE_STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   } // switch (wmiOperations->Method) 
}

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns IO Error data such as read\write errors.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;

   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   IoErrorData = (PWMI_TAPE_PROBLEM_IO_ERROR)&(wmiData->TapeData);

   if (CallNumber == 0) {
      if (!TapeClassAllocateSrbBuffer(Srb, 
                                      sizeof(LOG_SENSE_PARAMETER_FORMAT))) {
         DebugPrint((1, "QueryIoErrorData : No memory for log sense info\n"));
         return TAPE_STATUS_INSUFFICIENT_RESOURCES;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(IoErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_IO_ERROR));
      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE2;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 1) {
      ProcessReadWriteErrors(Srb, FALSE, IoErrorData);

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE3;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 2) {
      ProcessReadWriteErrors(Srb, TRUE, IoErrorData);
      
      wmiData->DriveProblemType = VerifyReadWriteErrors(IoErrorData);
      DebugPrint((3, "QueryIoErrorData: DriveProblemType %x\n",
                  wmiData->DriveProblemType));
   }

   return TAPE_STATUS_SUCCESS;
}

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
)
/*+
Routine Description :

   This routine processes the buffer containing read\write counters,
   and sets the appropriate fields in WMI_TAPE_PROBLEM_IO_ERROR 
   buffer.
   
Arguments :

 Srb            SCSI Request Block
 Read           TRUE if we are to process read counters. FALSE if it is 
                Write counters
 IoErrorData    Buffer in which to return counter values.
 
Return Value :

  None  
-*/
{
   USHORT paramCode;
   UCHAR  paramLen;
   LONG  bytesLeft;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PLOG_SENSE_PARAMETER_HEADER logSenseParamHeader;
   PUCHAR  paramValue = NULL;
   ULONG value;
   ULONG tmpVal;
   ULONG transferLength;

   logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
   
   ASSERT(((logSenseHeader->PageCode) == LOGSENSEPAGE2) ||
          ((logSenseHeader->PageCode) == LOGSENSEPAGE3));
   bytesLeft = logSenseHeader->Length[0];
   bytesLeft <<= 8;
   bytesLeft += logSenseHeader->Length[1];
   transferLength = Srb->DataTransferLength;

   if (bytesLeft > (LONG)(transferLength -
                          sizeof(LOG_SENSE_PAGE_HEADER))) {
       bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
   }
   DebugPrint((3, "ProcessReadWriteErrors : BytesLeft %x, TransferLength %x\n",
               bytesLeft, transferLength));

   (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseHeader + sizeof(LOG_SENSE_PAGE_HEADER);
   while (bytesLeft >= sizeof(LOG_SENSE_PARAMETER_HEADER)) {
      paramCode = logSenseParamHeader->ParameterCode[0];
      paramCode <<= 8;
      paramCode |= logSenseParamHeader->ParameterCode[1];
      paramLen = logSenseParamHeader->ParameterLength;
      paramValue = (PUCHAR)logSenseParamHeader + sizeof(LOG_SENSE_PARAMETER_HEADER);

      //
      // Make sure we have at least
      // (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen) bytes left.
      // Otherwise, we've reached the end of the buffer.
      //
      if (bytesLeft < (LONG)(sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)) {
          DebugPrint((1,
                      "dlttape : Reached end of buffer. BytesLeft %x, Expected %x\n",
                      bytesLeft,
                      (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)));
          break;
      }

      DebugPrint((3,
                  "ProcessReadWriteErrors : ParamCode %x, ParamLen %x\n",
                  paramCode, paramLen));
      switch (paramCode) {
         case TotalCorrectedErrors: {   
            value = (UCHAR)*(paramValue);
            value <<= 24;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 16;
            value += tmpVal;
            tmpVal = (UCHAR)*(paramValue+2);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+3);
            DebugPrint((3, "TotalCorrectedErrors %x\n", value));
            if (Read) {
               IoErrorData->ReadTotalCorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalCorrectedErrors = value;
            }
            break;
         }

         case TotalUncorrectedErrors: {
            value = (UCHAR)*(paramValue);
            value <<= 24;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 16;
            value += tmpVal;
            tmpVal = (UCHAR)*(paramValue+2);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+3);
            DebugPrint((3, "TotalUncorrectedErrors %x\n", value));
            if (Read) {
               IoErrorData->ReadTotalUncorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalUncorrectedErrors = value;
            }

            break;
         }

         case TotalTimesAlgorithmProcessed: {

            value = (UCHAR)*(paramValue);
            value <<= 24;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 16;
            value += tmpVal;
            tmpVal = (UCHAR)*(paramValue+2);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+3);
            DebugPrint((3, "TotalTimesAlgorithmProcessed %x\n", value));
            if (Read) {
               IoErrorData->ReadCorrectionAlgorithmProcessed = value;
            } else {
               IoErrorData->WriteCorrectionAlgorithmProcessed = value;
            }
            break;
         }

         default: {
            break;
         }
      } // switch (paramCode) 

      (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseParamHeader + 
                                    sizeof(LOG_SENSE_PARAMETER_HEADER) +
                                    paramLen;

      bytesLeft -= paramLen + sizeof(LOG_SENSE_PARAMETER_HEADER);
   } // while (bytesLeft > 0)

   if (Read) {
      IoErrorData->ReadTotalErrors = IoErrorData->ReadTotalUncorrectedErrors +
                                     IoErrorData->ReadTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: ReadErrors %x\n",
                  IoErrorData->ReadTotalErrors));
   } else {
      IoErrorData->WriteTotalErrors = IoErrorData->WriteTotalUncorrectedErrors +
                                      IoErrorData->WriteTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: WriteErrors %x\n",
                  IoErrorData->WriteTotalErrors));
   }
}

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   )
/*+

Routine Description :

   This routine looks at the read\write error counters.
   If the values are above a certain threshold, it returns
   appropriate error value.
   
Argument :

  IoErrorData  WMI_TAPE_PROBLEM_IO_ERROR struct
  
Return Value :
   
      TapeDriveReadWriteError If there are too many uncorrected 
                              read\write errors
                         
      TapeDriveReadWriteWarning If there are too many corrected
                                read\write errors 
                                
      TapeDriveProblemNone    If the read\write errors are below
                              threshold   
  
-*/
{

   if (((IoErrorData->ReadTotalUncorrectedErrors) >=
         TAPE_READ_ERROR_LIMIT)   ||       
       ((IoErrorData->WriteTotalUncorrectedErrors) >=
         TAPE_WRITE_ERROR_LIMIT)) {
      return TapeDriveReadWriteError;
   }

   if (((IoErrorData->ReadTotalCorrectedErrors) >=
         TAPE_READ_WARNING_LIMIT) ||
       ((IoErrorData->WriteTotalCorrectedErrors) >=
         TAPE_WRITE_WARNING_LIMIT)) {

      return TapeDriveReadWriteWarning;
   }

   return TapeDriveProblemNone;
}

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns device Error data such as "drive calibration"
   error, etc.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;
   PWMI_TAPE_PROBLEM_DEVICE_ERROR DeviceErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;
   ULONG bytesLeft;
   
   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   DeviceErrorData = (PWMI_TAPE_PROBLEM_DEVICE_ERROR)wmiData->TapeData;

   if (CallNumber == 0) {
      ULONG allocLength;

      if ((miniExtension->DriveID != COMPAQ_8000) &&
          (miniExtension->DriveID != QUANTUM_8000)) {
         DebugPrint((1, 
                     "QueryDeviceErrorData : TapeAlertPage not supported\n"));
         return TAPE_STATUS_NOT_IMPLEMENTED;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(DeviceErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_DEVICE_ERROR));

      return PrepareSrbForTapeAlertInfo(Srb);
   }

   if (CallNumber == 1) {
       PTAPE_ALERT_INFO  tapeAlertInfo;
       PLOG_SENSE_PAGE_HEADER logSenseHeader;
       LONG  bytesLeft;
       UCHAR paramCode;
       UCHAR flagValue;

       bytesLeft = GetNumberOfBytesReturned(Srb);

       logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
       tapeAlertInfo= (PTAPE_ALERT_INFO)((PUCHAR)logSenseHeader +
                                         sizeof(LOG_SENSE_PAGE_HEADER));
       while (bytesLeft >= sizeof(TAPE_ALERT_INFO)) {
            //
            // ParamCode is 2 bytes long. Upper Byte is 0.
            // Lower Byte goes from 0x01 to 0x40. So, we just
            // pick up the lower byte
            //
            paramCode = tapeAlertInfo->ParamCodeLB;
            flagValue = tapeAlertInfo->Flag;
            ASSERT((tapeAlertInfo->ParamLen) == 1);
            DebugPrint((3, "QDED: ParamCode %x, FlagValue %x, ParamLen %x\n",
                        paramCode, flagValue, tapeAlertInfo->ParamLen));
            switch (paramCode) {
               case READ_WARNING: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : READ_WARNING\n"));
                     DeviceErrorData->ReadWarning = TRUE;
                     wmiData->DriveProblemType = TapeDriveReadWarning;
                  }
   
                  break;
               }
   
               case WRITE_WARNING: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : WRITE_WARNING\n"));
                     DeviceErrorData->WriteWarning = TRUE;
                     wmiData->DriveProblemType = TapeDriveWriteWarning;
                  }
   
                  break;
               }
   
               case HARD_ERROR: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : HARD_ERROR\n"));
                     DeviceErrorData->HardError = TRUE;
                     wmiData->DriveProblemType = TapeDriveHardwareError;
                  }
                  break;
               }
   
               case READ_FAILURE: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : READ_FAILURE\n"));
                     DeviceErrorData->ReadFailure = TRUE;
                     wmiData->DriveProblemType = TapeDriveReadError;
                  }
                  break;
               }
   
               case WRITE_FAILURE: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : WRITE_FAILURE\n"));
                     DeviceErrorData->WriteFailure = TRUE;
                     wmiData->DriveProblemType = TapeDriveWriteError;
                  }
                  break;
               }
   
               case CLEAN_NOW: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : CLEAN_NOW\n"));
                     DeviceErrorData->DriveRequiresCleaning = TRUE;
                     wmiData->DriveProblemType = TapeDriveCleanDriveNow;
                  }
                  break;
               }
   
               case HARDWARE_B: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : HARDWARE_B\n"));
                     DeviceErrorData->DriveHardwareError = TRUE;
                     wmiData->DriveProblemType = TapeDriveHardwareError;
                  }
                  break;
               }
   
               case INTERFACE_ERROR: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : INTERFACE_ERROR\n"));
                     DeviceErrorData->ScsiInterfaceError = TRUE;
                     wmiData->DriveProblemType = TapeDriveScsiConnectionError;
                  }
                  break;
               }
   
               default:
                  break;
            } // switch (paramCode) {

            tapeAlertInfo++;
            bytesLeft -= sizeof(TAPE_ALERT_INFO);   
         }
   }

   return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
PrepareSrbForTapeAlertInfo(
    PSCSI_REQUEST_BLOCK Srb
    )
/*+++

Routine Description:

        This routine sets the SCSI_REQUEST_BLOCK to retrieve
        Tape Alert information from the drive

Arguements:

        Srb - Pointer to the SCSI_REQUEST_BLOCK

Return Value:

        TAPE_STATUS_SEND_SRB_AND_CALLBACK if Srb fields were successfully set.

        TAPE_STATUS_SUCCESS if there was not enough memory for Srb Databuffer.
                            case is not treated as an error.
--*/
{
    PCDB cdb = (PCDB)Srb->Cdb;
    ULONG allocLength;

    allocLength = sizeof(LOG_SENSE_PAGE_HEADER) +
                   (sizeof(TAPE_ALERT_INFO) * 0x40);
    if (!TapeClassAllocateSrbBuffer(Srb, allocLength)) {
       DebugPrint((1, 
                   "PrepareSrbForTapeAlertInfo : No mem for logsense info\n"));
       return TAPE_STATUS_INSUFFICIENT_RESOURCES;
    }

    TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //
    Srb->CdbLength = CDB10GENERIC_LENGTH;

    cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
    cdb->LOGSENSE.PageCode = TapeAlertLogPage;
    cdb->LOGSENSE.PCBit = 1;
    cdb->LOGSENSE.AllocationLength[0] = (UCHAR)((allocLength & 0xFF00) >> 8);
    cdb->LOGSENSE.AllocationLength[1] = (UCHAR)(allocLength & 0xFF);

    Srb->DataTransferLength = allocLength;
    return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
}

LONG 
GetNumberOfBytesReturned(
    PSCSI_REQUEST_BLOCK Srb
    )
{
    PLOG_SENSE_PAGE_HEADER logSenseHeader;
    ULONG transferLength;
    LONG  bytesLeft;

    logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);

    ASSERT((logSenseHeader->PageCode) == TapeAlertLogPage);
    bytesLeft = logSenseHeader->Length[0];
    bytesLeft <<= 8;
    bytesLeft += logSenseHeader->Length[1];

    transferLength = Srb->DataTransferLength;

    if (bytesLeft > (LONG)(transferLength -
                           sizeof(LOG_SENSE_PAGE_HEADER))) {
        bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
    }

    DebugPrint((3, "GetNumberOfBytesReturned : BytesLeft %x, TransferLength %x\n",
                bytesLeft, transferLength));

    return bytesLeft;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\exabyte2\exabyte2.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    exabyte2.h

Abstract:

    This file contains structures and defines that are used
    specifically for the tape drivers.

Revision History:

--*/

#ifndef _EXABYTE2_H
#define _EXABYTE2_H


//
//  Internal (module wide) defines that symbolize
//  density codes returned by/from EXB-8500 drives
//
#define EXB_XX00  0             // undetermined tape recording density
#define EXB_8200  20   // 0x14  // EXB-8200 tape recording density
#define EXB_8500  133  // 0x85  // EXB-8500 tape recording density

//
//  Internal (module wide) defines that symbolize
//  the 8mm drives supported by this module.
//
#define EXABYTE_8500    1  // aka the Maynard 5000
#define EXABYTE_8505    2  // An Exabyte 8500 with data compresion
#define IBM_8505        3  // OEM Exabyte 8500 with data compresion
#define EXABYTE_8500C   4  // 8500 with compression

//
// Define EXABYTE vendor unique mode select/sense information.
//

#define EXABYTE_MODE_LENGTH          0x11
#define EXABYTE_CARTRIDGE            0x80
#define EXABYTE_NO_DATA_DISCONNECT   0x20
#define EXABYTE_NO_BUSY_ENABLE       0x08
#define EXABYTE_EVEN_BYTE_DISCONNECT 0x04
#define EXABYTE_PARITY_ENABLE        0x02
#define EXABYTE_NO_AUTO_LOAD         0X01

#define EXA_SUPPORTED_TYPES 1

//
//  Function prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);

//
// Minitape extension definition.
//

typedef struct _MINITAPE_EXTENSION {

    ULONG   DriveID;
    ULONG   Capacity;
    ULONG   CurrentPartition;
} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION;

//
// Command extension definition.
//

typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;


//
// Request structure used to determine cleaning needs, and remaining tape
// capacity.
//

typedef struct _EXB_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Reserved2[2];
    UCHAR RWDataErrorCounter[3];
    UCHAR UnitSense[3];
    UCHAR Reserved4;
    UCHAR Remaining[3];
    UCHAR RetryCounters[2];
    UCHAR FSC;
} EXB_SENSE_DATA, *PEXB_SENSE_DATA;

//
// Bit definitions for UnitSense

//
// UnitSense[0]
//
#define EXB_MEDIA_ERROR          0x10
#define EXB_TAPE_MOTION_ERROR    0x04

//
// UnitSense[1]
//
#define EXB_WRITE_ERROR          0x04
#define EXB_SERVO_ERROR          0x02
#define EXB_FORMATTER_ERROR      0x01

//
// UnitSense[2]
//
#define EXB_WRITE_SPLICE_ERROR   0x03
#define EXB_DRIVE_NEEDS_CLEANING 0x08
#define EXB_DRIVE_CLEANED        0x10

//
// Error counter upper limits
//
#define TAPE_READ_ERROR_LIMIT        0x8000
#define TAPE_WRITE_ERROR_LIMIT       0x8000

#define TAPE_READ_WARNING_LIMIT      0x4000
#define TAPE_WRITE_WARNING_LIMIT     0x4000

//
// Defines for type of parameter
//
#define TotalCorrectedErrors            0x0003
#define TotalTimesAlgorithmProcessed    0x0004
#define TotalGroupsProcessed            0x0005
#define TotalUncorrectedErrors          0x0006

//
// Defines for Log Sense Pages
//
#define LOGSENSEPAGE0                        0x00
#define LOGSENSEPAGE2                        0x02
#define LOGSENSEPAGE3                        0x03

//
// Defined Log Sense Page Header
//

typedef struct _LOG_SENSE_PAGE_HEADER {

   UCHAR PageCode : 6;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR Length[2];           // [0]=MSB ... [1]=LSB

} LOG_SENSE_PAGE_HEADER, *PLOG_SENSE_PAGE_HEADER;


//
// Defined Log Sense Parameter Header
//

typedef struct _LOG_SENSE_PARAMETER_HEADER {

   UCHAR ParameterCode[2];    // [0]=MSB ... [1]=LSB
   UCHAR LPBit     : 1;
   UCHAR Reserved1 : 1;
   UCHAR TMCBit    : 2;
   UCHAR ETCBit    : 1;
   UCHAR TSDBit    : 1;
   UCHAR DSBit     : 1;
   UCHAR DUBit     : 1;
   UCHAR ParameterLength;

} LOG_SENSE_PARAMETER_HEADER, *PLOG_SENSE_PARAMETER_HEADER;

//
// Defined Log Page Information - statistical values, accounts
// for maximum parameter values that is returned for each page
//

typedef struct _LOG_SENSE_PAGE_INFORMATION {

   union {

       struct {
          UCHAR Page0;
          UCHAR Page2;
          UCHAR Page3;
       } PageData ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR TotalNumberOfErrors[3];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR TotalErrorsCorrected[3];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR TotalTimesAlgoProcessed[3];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR TotalGroupsWritten[5];
          LOG_SENSE_PARAMETER_HEADER Parm5;
          UCHAR TotalErrorsUncorrected[2];
       } Page2 ;

       struct {
           LOG_SENSE_PARAMETER_HEADER Parm1;
           UCHAR TotalNumberOfErrors[3];
           LOG_SENSE_PARAMETER_HEADER Parm2;
           UCHAR TotalErrorsCorrected[3];
           LOG_SENSE_PARAMETER_HEADER Parm3;
           UCHAR TotalTimesAlgoProcessed[3];
           LOG_SENSE_PARAMETER_HEADER Parm4;
           UCHAR TotalGroupsWritten[5];
           LOG_SENSE_PARAMETER_HEADER Parm5;
           UCHAR TotalErrorsUncorrected[2];
       } Page3 ;
   } LogSensePage;

} LOG_SENSE_PAGE_INFORMATION, *PLOG_SENSE_PAGE_INFORMATION;

//
// Defined Log Sense Parameter Format - statistical values, accounts
// for maximum parameter values that is returned
//

typedef struct _LOG_SENSE_PARAMETER_FORMAT {

   LOG_SENSE_PAGE_HEADER       LogSenseHeader;
   LOG_SENSE_PAGE_INFORMATION  LogSensePageInfo;

} LOG_SENSE_PARAMETER_FORMAT, *PLOG_SENSE_PARAMETER_FORMAT;


BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );


TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

//
// Internal routines wmi
//

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
  );

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   );

#endif // _EXABYTE2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\exabyte2\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for exabyte EXB-8505 
    and EXB-8205 drives.

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"
#include "exabyte2.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TapeWMIControl)
#pragma alloc_text(PAGE, ProcessReadWriteErrors)
#pragma alloc_text(PAGE, QueryDeviceErrorData)
#pragma alloc_text(PAGE, QueryIoErrorData)
#pragma alloc_text(PAGE, VerifyReadWriteErrors)
#endif

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )
/*+
Routine Description:

   This is the common entry point for all WMI calls from tape class driver.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;

   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;

   switch (wmiOperations->Method) {
      case TAPE_CHECK_FOR_DRIVE_PROBLEM: {
         return QueryDeviceErrorData(MinitapeExtension, 
                                     CommandExtension,
                                     CommandParameters, 
                                     Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_IO_ERROR_DATA: {
         return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                 CommandParameters, Srb, CallNumber,
                                 LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_DEVICE_ERROR_DATA: {
         return QueryDeviceErrorData(MinitapeExtension, CommandExtension,
                                     CommandParameters, Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      default: {
         return TAPE_STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   } // switch (wmiOperations->Method) 
}

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns IO Error data such as read\write errors.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;

   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   IoErrorData = (PWMI_TAPE_PROBLEM_IO_ERROR)&(wmiData->TapeData);

   if (CallNumber == 0) {
      if (!TapeClassAllocateSrbBuffer(Srb, 
                                      sizeof(LOG_SENSE_PARAMETER_FORMAT))) {
         DebugPrint((1, "QueryIoErrorData : No memory for log sense info\n"));
         return TAPE_STATUS_INSUFFICIENT_RESOURCES;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(IoErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_IO_ERROR));
      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE2;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 1) {
      ProcessReadWriteErrors(Srb, FALSE, IoErrorData);

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE3;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 2) {
      ProcessReadWriteErrors(Srb, TRUE, IoErrorData);
      
      wmiData->DriveProblemType = VerifyReadWriteErrors(IoErrorData);
   }

   return TAPE_STATUS_SUCCESS;
}

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
)
/*+
Routine Description :

   This routine processes the buffer containing read\write counters,
   and sets the appropriate fields in WMI_TAPE_PROBLEM_IO_ERROR 
   buffer.
   
Arguments :

 Srb            SCSI Request Block
 Read           TRUE if we are to process read counters. FALSE if it is 
                Write counters
 IoErrorData    Buffer in which to return counter values.
 
Return Value :

  None  
-*/
{
   USHORT paramCode;
   UCHAR  paramLen;
   LONG  bytesLeft;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PLOG_SENSE_PARAMETER_HEADER logSenseParamHeader;
   PUCHAR  paramValue = NULL;
   ULONG transferLength;

   logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
   
   ASSERT(((logSenseHeader->PageCode) == LOGSENSEPAGE2) ||
          ((logSenseHeader->PageCode) == LOGSENSEPAGE3));

   bytesLeft = logSenseHeader->Length[0];
   bytesLeft <<= 8;
   bytesLeft += logSenseHeader->Length[1];

   transferLength = Srb->DataTransferLength;

   if (bytesLeft > (LONG)(transferLength -
                          sizeof(LOG_SENSE_PAGE_HEADER))) {
       bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
   }
   DebugPrint((3, "ProcessReadWriteErrors : BytesLeft %x, TransferLength %x\n",
               bytesLeft, transferLength));

   (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseHeader + sizeof(LOG_SENSE_PAGE_HEADER);
   while (bytesLeft >= sizeof(LOG_SENSE_PARAMETER_HEADER)) {
      paramCode = logSenseParamHeader->ParameterCode[0];
      paramCode <<= 8;
      paramCode |= logSenseParamHeader->ParameterCode[1];
      paramLen = logSenseParamHeader->ParameterLength;      
      paramValue = (PUCHAR)logSenseParamHeader + sizeof(LOG_SENSE_PARAMETER_HEADER);

      if (bytesLeft < (LONG)(sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)) {
          DebugPrint((1,
                      "exabyte2 : Reached end of buffer. BytesLeft %x, Expected %x\n",
                      bytesLeft,
                      (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)));
          break;
      }

      DebugPrint((3,
                  "ProcessReadWriteErrors : ParamCode %x, ParamLen %x\n",
                  paramCode, paramLen));
      switch (paramCode) {
         case TotalCorrectedErrors: {
            ULONG value;
            ULONG tmpVal;

            value = (UCHAR)*(paramValue);
            value <<= 16;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+2);
            DebugPrint((3, "TotalCorrectedErrors %x\n", value));
            if (Read) {
               IoErrorData->ReadTotalCorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalCorrectedErrors = value;
            }
            break;
         }

         case TotalUncorrectedErrors: {
            USHORT value;

            value = (UCHAR)*(paramValue);
            value <<= 8;
            value += (UCHAR)*(paramValue+1);
            DebugPrint((3, "TotalUncorrectedErrors %x\n", value));
            if (Read) {
               IoErrorData->ReadTotalUncorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalUncorrectedErrors = value;
            }

            break;
         }

         case TotalTimesAlgorithmProcessed: {
            ULONG value;
            ULONG tmpVal;
            
            value = (UCHAR)*(paramValue);
            value <<= 16;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+2);
            DebugPrint((3, "TotalTimesAlgorithmProcessed %x\n", value));
            if (Read) {
               IoErrorData->ReadCorrectionAlgorithmProcessed = value;
            } else {
               IoErrorData->WriteCorrectionAlgorithmProcessed = value;
            }
            break;
         }

         default: {
            break;
         }
      } // switch (paramCode) 

      (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseParamHeader + 
                                    sizeof(LOG_SENSE_PARAMETER_HEADER) +
                                    paramLen;

      bytesLeft -= paramLen + sizeof(LOG_SENSE_PARAMETER_HEADER);
   } // while (bytesLeft > 0)

   if (Read) {
      IoErrorData->ReadTotalErrors = IoErrorData->ReadTotalUncorrectedErrors +
                                     IoErrorData->ReadTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: ReadErrors %x\n",
                  IoErrorData->ReadTotalErrors));
   } else {
      IoErrorData->WriteTotalErrors = IoErrorData->WriteTotalUncorrectedErrors +
                                      IoErrorData->WriteTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: WriteErrors %x\n",
                  IoErrorData->WriteTotalErrors));
   }
}

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   )
/*+

Routine Description :

   This routine looks at the read\write error counters.
   If the values are above a certain threshold, it returns
   appropriate error value.
   
Argument :

  IoErrorData  WMI_TAPE_PROBLEM_IO_ERROR struct
  
Return Value :
   
      TapeDriveReadWriteError If there are too many uncorrected 
                              read\write errors
                         
      TapeDriveReadWriteWarning If there are too many corrected
                                read\write errors 
                                
      TapeDriveProblemNone    If the read\write errors are below
                              threshold   
  
-*/
{
   if (((IoErrorData->ReadTotalUncorrectedErrors) >=
         TAPE_READ_ERROR_LIMIT)   ||       
       ((IoErrorData->WriteTotalUncorrectedErrors) >=
         TAPE_WRITE_ERROR_LIMIT)) {
      return TapeDriveReadWriteError;
   }

   if (((IoErrorData->ReadTotalCorrectedErrors) >=
         TAPE_READ_WARNING_LIMIT) ||
       ((IoErrorData->WriteTotalCorrectedErrors) >=
         TAPE_WRITE_WARNING_LIMIT)) {

      return TapeDriveReadWriteWarning;
   }

   return TapeDriveProblemNone;
}

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns device Error data such as "drive calibration"
   error, etc.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;
   PWMI_TAPE_PROBLEM_DEVICE_ERROR DeviceErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;
   
   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   DeviceErrorData = (PWMI_TAPE_PROBLEM_DEVICE_ERROR)wmiData->TapeData;

   if (CallNumber == 0) {
      //
      // Issue a request sense to get some diagnostic information.
      //

      if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA))) {
          DebugPrint((1,
                      "GetStatus: Insufficient resources (SenseData)\n"));
          return TAPE_STATUS_SUCCESS;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(DeviceErrorData,
                          sizeof(WMI_TAPE_PROBLEM_DEVICE_ERROR));

      //
      // Prepare SCSI command (CDB)
      //

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      Srb->ScsiStatus = Srb->SrbStatus = 0;
      Srb->CdbLength = CDB6GENERIC_LENGTH;

      cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
      cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(EXB_SENSE_DATA);

      //
      // Send SCSI command (CDB) to device
      //

      Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
      *RetryFlags |= RETURN_ERRORS;

      return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
   }
   
   if (CallNumber == 1) {

      if (LastError == TAPE_STATUS_SUCCESS) {
         PEXB_SENSE_DATA exbSenseData;
         UCHAR firstByte, secondByte, thirdByte;
         
         exbSenseData = Srb->DataBuffer;
         firstByte = exbSenseData->UnitSense[0];
         secondByte = exbSenseData->UnitSense[1];
         thirdByte = exbSenseData->UnitSense[2];

         if (firstByte & EXB_MEDIA_ERROR) {
            wmiData->DriveProblemType = TapeDriveReadError;
            DeviceErrorData->ReadFailure = TRUE;
            DeviceErrorData->WriteFailure = TRUE;
            DebugPrint((3, "QDED: Error - Bad Media\n"));
         }

         if ((firstByte & EXB_TAPE_MOTION_ERROR) ||
             (secondByte & EXB_SERVO_ERROR)      ||
             (secondByte & EXB_FORMATTER_ERROR)  ||
             (thirdByte & EXB_WRITE_SPLICE_ERROR)) {
            wmiData->DriveProblemType = TapeDriveHardwareError;
            DeviceErrorData->DriveHardwareError = TRUE;
            DebugPrint((3, "QDED: Drive hardware error\n"));
         }

         if (secondByte & EXB_WRITE_ERROR) {
            wmiData->DriveProblemType = TapeDriveWriteError;
            DeviceErrorData->WriteFailure = TRUE;
            DebugPrint((3, "QDED: Write error. Probably bad media\n"));
         }

         if (thirdByte & EXB_DRIVE_NEEDS_CLEANING) {
            wmiData->DriveProblemType = TapeDriveCleanDriveNow;
            DeviceErrorData->DriveRequiresCleaning = TRUE;
            DebugPrint((3, "QDED: Drive requires cleaning\n"));
         }

         DebugPrint((3, "QDED: DriveProblemType %x\n",
                     wmiData->DriveProblemType));
      }
   }
   
   return TAPE_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\ltotape\ltotape.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ltotape.c
//
//--------------------------------------------------------------------------

/*++

Copyright (c) Microsoft 2000

Module Name:

    ltotape.c

Abstract:

    This module contains device specific routines for LTO drives.

Environment:

    kernel mode only

Revision History:


--*/

#include "minitape.h"
#include "ltotape.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

STORAGE_MEDIA_TYPE LTOMedia[LTO_SUPPORTED_TYPES] = {LTO_Ultrium, CLEANER_CARTRIDGE};


ULONG
DriverEntry(
           IN PVOID Argument1,
           IN PVOID Argument2
           )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 1800;
    tapeInitData.TapeError = TapeError;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = LTO_SUPPORTED_TYPES;

    tapeInitData.TapeWMIOperations = TapeWMIControl;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
             OUT PVOID                   MinitapeExtension,
             IN  PINQUIRYDATA            InquiryData,
             IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
             )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData);
    extension->CompressionOn = FALSE;
}


TAPE_STATUS
CreatePartition(
               IN OUT  PVOID               MinitapeExtension,
               IN OUT  PVOID               CommandExtension,
               IN OUT  PVOID               CommandParameters,
               IN OUT  PSCSI_REQUEST_BLOCK Srb,
               IN      ULONG               CallNumber,
               IN      TAPE_STATUS         LastError,
               IN OUT  PULONG              RetryFlags
               )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    //
    // LTO tape drives support only one partition
    //
    DebugPrint((1,
                "CreatePartition: LTO Tapedrive - Operation not supported\n"));

    return TAPE_STATUS_NOT_IMPLEMENTED;

} // end TapeCreatePartition()


TAPE_STATUS
Erase(
     IN OUT  PVOID               MinitapeExtension,
     IN OUT  PVOID               CommandExtension,
     IN OUT  PVOID               CommandParameters,
     IN OUT  PSCSI_REQUEST_BLOCK Srb,
     IN      ULONG               CallNumber,
     IN      TAPE_STATUS         LastError,
     IN OUT  PULONG              RetryFlags
     )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        switch (tapeErase->Type) {
        case TAPE_ERASE_LONG: {
                DebugPrint((3,"TapeErase: Long and %s\n",
                            (tapeErase->Immediate) ? "Immediate" : "Not-Immediate"));
                break;
            }

        case TAPE_ERASE_SHORT: {
                DebugPrint((3,"TapeErase: Short and %s\n",
                            (tapeErase->Immediate) ? "Immediate" : "Not-Immediate"));
                break;
            }

        default: {
                DebugPrint((1, "TapeErase: Unknown TapeErase type %x\n",
                            tapeErase->Type));
                return TAPE_STATUS_INVALID_PARAMETER;
            }
        } // switch (tapeErase->Type)

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = ((tapeErase->Type) == TAPE_ERASE_LONG) ? SETBITON : SETBITOFF;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 23760;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapeErase()

VOID
TapeError(
         IN OUT  PVOID               MinitapeExtension,
         IN OUT  PSCSI_REQUEST_BLOCK Srb,
         IN      TAPE_STATUS         *LastError
         )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer = Srb->SenseInfoBuffer;
    UCHAR              sensekey;
    UCHAR              adsenseq;
    UCHAR              adsense;

    DebugPrint((3,"TapeError: Enter routine\n"));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        sensekey = senseBuffer->SenseKey & 0x0F;
        adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
        adsense = senseBuffer->AdditionalSenseCode;

        switch (sensekey) {
            case SCSI_SENSE_NO_SENSE: {

                if ((adsense == LTO_ADSENSE_VENDOR_UNIQUE) && 
                    (adsenseq == LTO_ASCQ_CLEANING_REQUIRED)) {
                    *LastError = TAPE_STATUS_REQUIRES_CLEANING;
                }

                break;
            }

            case SCSI_SENSE_NOT_READY: {

                if ((adsense == SCSI_ADSENSE_INVALID_MEDIA) && 
                    (adsenseq == SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED)) {
                    *LastError = TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED;
                } else if ((adsense == SCSI_ADSENSE_LUN_NOT_READY) &&
                           (adsenseq == SCSI_SENSEQ_INIT_COMMAND_REQUIRED)) {
                            *LastError = TAPE_STATUS_NO_MEDIA;
                }

                break;
            }
        }

    } // if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)

    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    return;
} // end TapeError()


TAPE_STATUS
GetDriveParameters(
                  IN OUT  PVOID               MinitapeExtension,
                  IN OUT  PVOID               CommandExtension,
                  IN OUT  PVOID               CommandParameters,
                  IN OUT  PSCSI_REQUEST_BLOCK Srb,
                  IN      ULONG               CallNumber,
                  IN      TAPE_STATUS         LastError,
                  IN OUT  PULONG              RetryFlags
                  )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{ 
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimitsBuffer;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if ( CallNumber == 1 ) {

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        tapeGetDriveParams->ReportSetmarks =
        (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk? 1 : 0 );


        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);


        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        compressionModeSenseBuffer = Srb->DataBuffer ;

        if ((LastError == TAPE_STATUS_SUCCESS) &&
            compressionModeSenseBuffer->DataCompressPage.DCC) {

            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
            (compressionModeSenseBuffer->DataCompressPage.DCE? TRUE : FALSE);

        }

        if (LastError != TAPE_STATUS_SUCCESS ) {
            DebugPrint((1,
                        "GetDriveParameters: mode sense failed. Status %x\n",
                        LastError));
            return LastError;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(READ_BLOCK_LIMITS_DATA) ) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimitsBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimitsBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        Srb->DataTransferLength = sizeof(READ_BLOCK_LIMITS_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT ( CallNumber == 3 ) ;

    blockLimitsBuffer = Srb->DataBuffer ;

    tapeGetDriveParams->MaximumBlockSize = blockLimitsBuffer->BlockMaximumSize[2];
    tapeGetDriveParams->MaximumBlockSize += (blockLimitsBuffer->BlockMaximumSize[1] << 8);
    tapeGetDriveParams->MaximumBlockSize += (blockLimitsBuffer->BlockMaximumSize[0] << 16);

    tapeGetDriveParams->MinimumBlockSize = blockLimitsBuffer->BlockMinimumSize[1];
    tapeGetDriveParams->MinimumBlockSize += (blockLimitsBuffer->BlockMinimumSize[0] << 8);

    tapeGetDriveParams->DefaultBlockSize = 512;

    tapeGetDriveParams->MaximumPartitionCount = 0;
    tapeGetDriveParams->ECC = FALSE;
    tapeGetDriveParams->DataPadding = FALSE;

    tapeGetDriveParams->FeaturesLow |=
    TAPE_DRIVE_ERASE_SHORT      |
    TAPE_DRIVE_ERASE_LONG       |
    TAPE_DRIVE_ERASE_IMMEDIATE  |
    TAPE_DRIVE_FIXED_BLOCK      |
    TAPE_DRIVE_VARIABLE_BLOCK   |
    TAPE_DRIVE_WRITE_PROTECT    |
    TAPE_DRIVE_GET_ABSOLUTE_BLK |
    TAPE_DRIVE_GET_LOGICAL_BLK  |
    TAPE_DRIVE_TAPE_CAPACITY    |
    TAPE_DRIVE_TAPE_REMAINING   |
    TAPE_DRIVE_CLEAN_REQUESTS;

    tapeGetDriveParams->FeaturesHigh |=
    TAPE_DRIVE_LOAD_UNLOAD       |
    TAPE_DRIVE_LOCK_UNLOCK       |
    TAPE_DRIVE_TENSION           |
    TAPE_DRIVE_LOAD_UNLD_IMMED   |
    TAPE_DRIVE_TENSION_IMMED     |
    TAPE_DRIVE_REWIND_IMMEDIATE  |
    TAPE_DRIVE_SET_BLOCK_SIZE    |
    TAPE_DRIVE_ABSOLUTE_BLK      |
    TAPE_DRIVE_LOGICAL_BLK       |
    TAPE_DRIVE_END_OF_DATA       |
    TAPE_DRIVE_RELATIVE_BLKS     |
    TAPE_DRIVE_FILEMARKS         |
    TAPE_DRIVE_REVERSE_POSITION  |
    TAPE_DRIVE_WRITE_FILEMARKS   |
    TAPE_DRIVE_WRITE_MARK_IMMED;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
                tapeGetDriveParams->FeaturesLow));
    DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
                tapeGetDriveParams->FeaturesHigh));


    return TAPE_STATUS_SUCCESS;

} // end TapeGetDriveParameters()

TAPE_STATUS
GetMediaParameters(
                  IN OUT  PVOID               MinitapeExtension,
                  IN OUT  PVOID               CommandExtension,
                  IN OUT  PVOID               CommandParameters,
                  IN OUT  PSCSI_REQUEST_BLOCK Srb,
                  IN      ULONG               CallNumber,
                  IN      TAPE_STATUS         LastError,
                  IN OUT  PULONG              RetryFlags
                  )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    ULONG                       remaining;
    ULONG                       temp ;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {

            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer ;


        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 2) {

        modeBuffer = Srb->DataBuffer ;

        tapeGetMediaParams->PartitionCount = 0;

        tapeGetMediaParams->BlockSize = modeBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);

        tapeGetMediaParams->WriteProtected =
        ((modeBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

        //
        // Set the SRB to retrieve tape capacity information
        //
        return PrepareSrbForTapeCapacityInfo(Srb);
    }

    if (CallNumber == 3) {
        if (LastError == TAPE_STATUS_SUCCESS) {
            LTO_TAPE_CAPACITY ltoTapeCapacity;

            //
            // Tape capacity is given in units of Megabytes
            //
            if (ProcessTapeCapacityInfo(Srb, &ltoTapeCapacity)) {
                tapeGetMediaParams->Capacity.LowPart = ltoTapeCapacity.MaximumCapacity;
                tapeGetMediaParams->Capacity.QuadPart <<= 20;

                tapeGetMediaParams->Remaining.LowPart = ltoTapeCapacity.RemainingCapacity;
                tapeGetMediaParams->Remaining.QuadPart <<= 20;
            }

            DebugPrint((1,
                        "Maximum Capacity returned %x %x\n",
                        tapeGetMediaParams->Capacity.HighPart,
                        tapeGetMediaParams->Capacity.LowPart));

            DebugPrint((1,
                        "Remaining Capacity returned %x %x\n",
                        tapeGetMediaParams->Remaining.HighPart,
                        tapeGetMediaParams->Remaining.LowPart));
        }
    }

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetMediaParameters()


TAPE_STATUS
GetPosition(
           IN OUT  PVOID               MinitapeExtension,
           IN OUT  PVOID               CommandExtension,
           IN OUT  PVOID               CommandParameters,
           IN OUT  PSCSI_REQUEST_BLOCK Srb,
           IN      ULONG               CallNumber,
           IN      TAPE_STATUS         LastError,
           IN OUT  PULONG              RetryFlags
           )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{ 
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PTAPE_POSITION_DATA         logicalBuffer;
    ULONG                       type;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;

    }

    if ( CallNumber == 1 ) {

        //
        // Prepare SCSI command (CDB) to flush all
        // buffered data to be written to the tape
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = FALSE ;

        cdb->WRITE_TAPE_MARKS.TransferLength[0] = 0;
        cdb->WRITE_TAPE_MARKS.TransferLength[1] = 0;
        cdb->WRITE_TAPE_MARKS.TransferLength[2] = 0;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: flushing TapeWriteMarks: SendSrb\n"));
        Srb->DataTransferLength = 0 ;
        *RetryFlags |= IGNORE_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        switch (tapeGetPosition->Type) {
        
        case TAPE_ABSOLUTE_POSITION:
        case TAPE_LOGICAL_POSITION: {

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(TAPE_POSITION_DATA)) ) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (logicalBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                logicalBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));
                Srb->DataTransferLength = sizeof(TAPE_POSITION_DATA) ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
                break ;
            }

        default: {
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        } // switch (tapeGetPosition->Type)
    }

    ASSERT (CallNumber == 3);

    logicalBuffer = Srb->DataBuffer;

    tapeGetPosition->Offset.HighPart = 0;

    REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                  (PFOUR_BYTE)logicalBuffer->FirstBlock);

    return TAPE_STATUS_SUCCESS;

} // end TapeGetPosition()


TAPE_STATUS
GetStatus(
         IN OUT  PVOID               MinitapeExtension,
         IN OUT  PVOID               CommandExtension,
         IN OUT  PVOID               CommandParameters,
         IN OUT  PSCSI_REQUEST_BLOCK Srb,
         IN      ULONG               CallNumber,
         IN      TAPE_STATUS         LastError,
         IN OUT  PULONG              RetryFlags
         )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCOMMAND_EXTENSION commandExtension = CommandExtension;
    PCDB            cdb = (PCDB)Srb->Cdb;
    PLTO_SENSE_DATA senseData;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags |= RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        //
        // Issue a request sense to get the cleaning info bits.
        //

        //
        // Allocate Srb Buffer to get request sense data. If we
        // don't have enough memory, we'll just return the status
        // in LastError
        //
        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(LTO_SENSE_DATA))) {
            DebugPrint((1,
                        "GetStatus: Insufficient resources (SenseData)\n"));
            return LastError;
        }

        commandExtension->CurrentState = LastError;

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(LTO_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        Srb->DataTransferLength = sizeof(LTO_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    } else if (CallNumber == 2) {
        if ((commandExtension->CurrentState == TAPE_STATUS_SUCCESS)  ||
            (commandExtension->CurrentState == TAPE_STATUS_NO_MEDIA)) {

            //
            // Return needs cleaning status if necessary, but only if
            // no other errors are present (with the exception of no media as
            // the drive will spit out AME media when in this state).
            //

            senseData = Srb->DataBuffer;

            //
            // Check if the clean bit is set.
            //

            if (senseData->CLN) {
                DebugPrint((1, "Drive reports needs cleaning\n"));
                return TAPE_STATUS_REQUIRES_CLEANING;
            }

            return(commandExtension->CurrentState);
        } else {

            //
            // Return the saved error status.
            //

            return commandExtension->CurrentState;
        }
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Prepare(
       IN OUT  PVOID               MinitapeExtension,
       IN OUT  PVOID               CommandExtension,
       IN OUT  PVOID               CommandParameters,
       IN OUT  PSCSI_REQUEST_BLOCK Srb,
       IN      ULONG               CallNumber,
       IN      TAPE_STATUS         LastError,
       IN OUT  PULONG              RetryFlags
       )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_PREPARE               tapePrepare = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        switch (tapePrepare->Operation) {
        case TAPE_LOAD:
        case TAPE_UNLOAD: 
        case TAPE_LOCK:
        case TAPE_UNLOCK:
        case TAPE_TENSION: {
                DebugPrint((3, "TapePrepare : Type %x, %s\n",
                            (tapePrepare->Operation),
                            ((tapePrepare->Immediate) ? "Immeidate" : "Not-Immediate")));
                break;
            }

        default:   {
                DebugPrint((1, "TapePrepare : Unsupported operation %x\n",
                            tapePrepare->Operation));
                return TAPE_STATUS_INVALID_PARAMETER;
            }
        } // switch (tapePrepare->Operation)

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
        case TAPE_LOAD: {
                DebugPrint((3,"TapePrepare: Operation == Load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;

                //
                // Set "Load" bit to 1. Remaining bits to 0
                //
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;
            }

        case TAPE_UNLOAD: {
                DebugPrint((3,"TapePrepare: Operation == Unload\n"));

                //
                // "Load" bit set to 0. Just need to set the OperationCode
                // of the CDB
                //
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                break;
            }

        case TAPE_TENSION: {
                DebugPrint((3, "TapePrepare: Operation == Tension\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;

                //
                // Set "Load" and "Reten" bits to 1. Remaining bits to 0
                //
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
            }

        case TAPE_LOCK: {
                DebugPrint((3,"TapePrepare: Operation == Lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Set "Prvnt" bit to 1. Remaining bits to 0
                //
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;
            }

        case TAPE_UNLOCK: {
                DebugPrint((3,"TapePrepare: Operation == Unlock\n"));

                //
                // "Prvnt" bit set to 0. Just need to set the OperationCode
                // of the CDB
                //
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                break;
            }

        default: {
                DebugPrint((1, "TapePrepare: Unsupported operation\n"));
                return TAPE_STATUS_INVALID_PARAMETER;
            }
        }

        //
        // Send SCSI command (CDB) to device
        //
        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 1) {
        if ((tapePrepare->Operation == TAPE_LOAD) ||
            (tapePrepare->Operation == TAPE_TENSION)) {

            //
            // Load and Tension operations move the tape to the
            // Beginning of Tape (BOT). Retrieve tape capacity
            // info, and store it in our device extension
            //
            return PrepareSrbForTapeCapacityInfo(Srb);

        } else {

            return TAPE_STATUS_SUCCESS;
        }

    }

    if (CallNumber == 2) {
        if ((tapePrepare->Operation == TAPE_LOAD) ||
            (tapePrepare->Operation == TAPE_TENSION)) {
            LTO_TAPE_CAPACITY ltoTapeCapacity;

            if (LastError == TAPE_STATUS_SUCCESS) {
                if (ProcessTapeCapacityInfo(Srb, &ltoTapeCapacity)) {
                    extension->Capacity = ltoTapeCapacity.RemainingCapacity;
                }
            }
        }
    }

    return TAPE_STATUS_SUCCESS;

} // end TapePrepare()


TAPE_STATUS
SetDriveParameters(
                  IN OUT  PVOID               MinitapeExtension,
                  IN OUT  PVOID               CommandExtension,
                  IN OUT  PVOID               CommandParameters,
                  IN OUT  PSCSI_REQUEST_BLOCK Srb,
                  IN      ULONG               CallNumber,
                  IN      TAPE_STATUS         LastError,
                  IN OUT  PULONG              RetryFlags
                  )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;
    PMODE_DEVICE_CONFIG_PAGE    configBuffer;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {

            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        configBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 1 ) {

        configBuffer = Srb->DataBuffer ;

        configBuffer->ParameterListHeader.ModeDataLength = 0;
        configBuffer->ParameterListHeader.MediumType = 0;
        configBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        configBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        configBuffer->DeviceConfigPage.PageCode = MODE_PAGE_DEVICE_CONFIG;
        configBuffer->DeviceConfigPage.PageLength = 0x0E;

        if (tapeSetDriveParams->ReportSetmarks) {
            configBuffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            configBuffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 2 ) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE)) ) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3 ) {

        if ( LastError != TAPE_STATUS_SUCCESS ) {

            DebugPrint((1,
                        "TapeSetDriveParameters: mode sense failed. Status %x\n",
                        LastError));
            return LastError;

        }

        compressionBuffer = Srb->DataBuffer ;

        compressionBuffer->ParameterListHeader.ModeDataLength = 0;
        compressionBuffer->ParameterListHeader.MediumType = 0;
        compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        compressionBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        compressionBuffer->DataCompressPage.PageCode = MODE_PAGE_DATA_COMPRESS;
        compressionBuffer->DataCompressPage.PageLength = 0x0E;

        if (tapeSetDriveParams->Compression) {
            //
            // Enable data compression. Use default 
            // compression algorithm
            //
            compressionBuffer->DataCompressPage.DCE = SETBITON;
            compressionBuffer->DataCompressPage.CompressionAlgorithm[3]= 0x01;
        } else {
            //
            // Disable data compression
            //
            compressionBuffer->DataCompressPage.DCE = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT(CallNumber == 4 ) ;

    return TAPE_STATUS_SUCCESS ;
} // end TapeSetDriveParameters()



TAPE_STATUS
SetMediaParameters(
                  IN OUT  PVOID               MinitapeExtension,
                  IN OUT  PVOID               CommandExtension,
                  IN OUT  PVOID               CommandParameters,
                  IN OUT  PSCSI_REQUEST_BLOCK Srb,
                  IN      ULONG               CallNumber,
                  IN      TAPE_STATUS         LastError,
                  IN OUT  PULONG              RetryFlags
                  )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {
        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer ;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
        MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.BlockLength[0] =
        (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
        (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
        (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;

        //
        // Set PF Bit to indicate SCSI2 format mode data
        //
        cdb->MODE_SELECT.PFBit = 0x01;

        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT(CallNumber == 2 ) ;

    return TAPE_STATUS_SUCCESS;

} // end TapeSetMediaParameters()


TAPE_STATUS
SetPosition(
           IN OUT  PVOID               MinitapeExtension,
           IN OUT  PVOID               CommandExtension,
           IN OUT  PVOID               CommandParameters,
           IN OUT  PSCSI_REQUEST_BLOCK Srb,
           IN      ULONG               CallNumber,
           IN      TAPE_STATUS         LastError,
           IN OUT  PULONG              RetryFlags
           )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_POSITION          tapeSetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    ULONG                       tapePositionVector;
    ULONG                       remaining;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        DebugPrint((3,
                    "TapeSetPosition : Method %x, %s\n",
                    (tapeSetPosition->Method),
                    ((tapeSetPosition->Immediate) ? "Immediate" : "Not-Immediate")
                   ));

        tapePositionVector = tapeSetPosition->Offset.LowPart;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (tapeSetPosition->Method) {
        case TAPE_REWIND: {
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;

                Srb->TimeOutValue = 25000;
                break;
            }

        case TAPE_ABSOLUTE_BLOCK:
        case TAPE_LOGICAL_BLOCK: {
                DebugPrint((3,
                            "TapeSetPosition: method == locate (logical)\n"));
                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] =
                (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] =
                (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] =
                (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] =
                (UCHAR)(tapePositionVector & 0xFF);

                Srb->TimeOutValue = 25000;
                break;
            }

        case TAPE_SPACE_RELATIVE_BLOCKS: {
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;

                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapePositionVector & 0xFF);

                Srb->TimeOutValue = 20000;
                break;
            }

        case TAPE_SPACE_FILEMARKS: {
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 20000;
                break;
            }

        case TAPE_SPACE_END_OF_DATA: {
                DebugPrint((3,
                            "TapeSetPosition: method == space to EOD\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 20000;
                break;
            }

        default: {
                DebugPrint((1,
                            "TapeSetPosition: Method %x not supported\n",
                            (tapeSetPosition->Method)));
                return TAPE_STATUS_INVALID_PARAMETER;
            }
        } // switch (tapeSetPosition->Method)

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 1) {
        if (tapeSetPosition->Method == TAPE_REWIND) {
            //
            // Now that the tape has been successfully rewound,
            // retrieve tape capacity log.
            //
            return PrepareSrbForTapeCapacityInfo(Srb);
        }
    }

    if (CallNumber == 2) {

        LTO_TAPE_CAPACITY ltoTapeCapacity;

        if (LastError == TAPE_STATUS_SUCCESS) {
            if (ProcessTapeCapacityInfo(Srb, &ltoTapeCapacity)) {
                //
                // Tape has been reqound. Remaining capacity returned
                // is the capacity of the tape. Update that info in
                // our device extension.
                //
                extension->Capacity = ltoTapeCapacity.RemainingCapacity;
            }
        }
    }

    return TAPE_STATUS_SUCCESS;

} // end TapeSetPosition()


TAPE_STATUS
WriteMarks(
          IN OUT  PVOID               MinitapeExtension,
          IN OUT  PVOID               CommandExtension,
          IN OUT  PVOID               CommandParameters,
          IN OUT  PSCSI_REQUEST_BLOCK Srb,
          IN      ULONG               CallNumber,
          IN      TAPE_STATUS         LastError,
          IN OUT  PULONG              RetryFlags
          )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;
    LARGE_INTEGER      timeout ;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        //
        // Currently, only Write Filemarks is supported
        //
        switch (tapeWriteMarks->Type) {
        case TAPE_FILEMARKS:
            DebugPrint((3,"Write Filemarks : %s\n",
                        (tapeWriteMarks->Immediate) ? "Immediate" : "Not-Immediate"));
            break;

        case TAPE_SETMARKS:
        case TAPE_SHORT_FILEMARKS:
        case TAPE_LONG_FILEMARKS:
        default:
            DebugPrint((1,"TapeWriteMarks: Type %x, %s\n",
                        (tapeWriteMarks->Type),
                        (tapeWriteMarks->Immediate) ? "Immediate" : "Not-Immediate"));
            return TAPE_STATUS_INVALID_PARAMETER;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;

        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;


        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
        (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
        (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
        (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: Send SRB\n"));
        Srb->DataTransferLength = 0 ;

        if ( tapeWriteMarks->Count == 0 ) {
            *RetryFlags |= IGNORE_ERRORS;
        }

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT (CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapeWriteMarks()



TAPE_STATUS
GetMediaTypes(
             IN OUT  PVOID               MinitapeExtension,
             IN OUT  PVOID               CommandExtension,
             IN OUT  PVOID               CommandParameters,
             IN OUT  PSCSI_REQUEST_BLOCK Srb,
             IN      ULONG               CallNumber,
             IN      TAPE_STATUS         LastError,
             IN OUT  PULONG              RetryFlags
             )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION commandExtension = CommandExtension;
    ULONG i;
    ULONG currentMedia  = 0;
    ULONG blockSize = 0;
    UCHAR mediaType = 0;
    UCHAR densityCode = 0;
    UCHAR deviceSpecificParameter = 0;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        commandExtension->CurrentState = 0;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || 
        (LastError == TAPE_STATUS_MEDIA_CHANGED) || 
        (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, 
                                            sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {

                DebugPrint((1,
                            "Dlttape.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS));
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)(Srb->DataTransferLength);

            commandExtension->CurrentState = TAPE_STATUS_SEND_SRB_AND_CALLBACK;
            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    } else if (LastError == TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED) {
        if (CallNumber == 1) {
            commandExtension->CurrentState = TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED;
            return TAPE_STATUS_CALLBACK;
        }
    }

    if ((CallNumber == 2) || 
        ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {

        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;
        UCHAR densityCode;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, two types (either known dlt/cleaner or unknown) are returned.
        //

        mediaTypes->MediaInfoCount = LTO_SUPPORTED_TYPES;

        //
        // Determine the media type currently loaded.
        //

        if ( LastError == TAPE_STATUS_SUCCESS ) {
            if ((commandExtension->CurrentState) == TAPE_STATUS_SEND_SRB_AND_CALLBACK) {

                PMODE_DEVICE_CONFIG_PAGE_PLUS configInformation = Srb->DataBuffer;

                mediaType = configInformation->ParameterListHeader.MediumType;

                blockSize = configInformation->ParameterListBlock.BlockLength[2];
                blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
                blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

                deviceSpecificParameter = configInformation->ParameterListHeader.DeviceSpecificParameter;
                densityCode = configInformation->ParameterListBlock.DensityCode;

                DebugPrint((1,
                            "GetMediaTypes: MediaType %x, Density Code %x, Current Block Size %x\n",
                            mediaType,
                            densityCode,
                            blockSize));

                switch (densityCode) {
                    case 0x40: 
                    case 0x00: {

                        //
                        // N.B : The drive can return 0x00 for density code
                        //       to indicate Default Ultrium media.
                        //
                        currentMedia = LTO_Ultrium;
                        break;
                    }

                    default: {
                            currentMedia = 0;
                            break;
                    }
                } // switch (densityCode)
            } 
        } else if ((LastError == TAPE_STATUS_CALLBACK) &&
                   ((commandExtension->CurrentState) == TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED)) {
                currentMedia = CLEANER_CARTRIDGE;
        } else {
            currentMedia = 0;
        }

        //
        // At this point, currentMedia should either be 0, or a valid
        // mediatype supported
        //
        DebugPrint((3, "Currents Media is %d\n", currentMedia));
        
        //
        // fill in buffer based on spec. values
        //

        for (i = 0; i < LTO_SUPPORTED_TYPES; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = LTOMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (LTOMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode = densityCode;


                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                ((deviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }
    }

    return TAPE_STATUS_SUCCESS;
}


static
ULONG
WhichIsIt(
         IN PINQUIRYDATA InquiryData
         )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"V",1) == 1) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"P",1) == 1) {
        }

    }

    return 0;
}

TAPE_STATUS
INLINE
PrepareSrbForTapeCapacityInfo(
                             PSCSI_REQUEST_BLOCK Srb
                             )
/*+++

Routine Description:

        This routine sets the SCSI_REQUEST_BLOCK to retrieve
        TapeCapacity information from the drive
        
Arguements:

        Srb - Pointer to the SCSI_REQUEST_BLOCK 
        
Return Value:

        TAPE_STATUS_SEND_SRB_AND_CALLBACK if Srb fields were successfully set.
        
        TAPE_STATUS_SUCCESS if there was not enough memory for Srb Databuffer. This
                            case is not treated as an error.
--*/
{

    PCDB  cdb = (PCDB)(Srb->Cdb);

    TapeClassZeroMemory(Srb, sizeof(SCSI_REQUEST_BLOCK));
    Srb->CdbLength = CDB10GENERIC_LENGTH;

    if (!TapeClassAllocateSrbBuffer(Srb, 
                                    sizeof(LOG_SENSE_PAGE_FORMAT))) {
        //
        // Not enough memory. Can't get tape capacity info.
        // But just return TAPE_STATUS_SUCCESS
        //
        DebugPrint((1,
                    "TapePrepare: Insufficient resources (LOG_SENSE_PAGE_FORMAT)\n"));
        return TAPE_STATUS_SUCCESS;
    }

    TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
    cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
    cdb->LOGSENSE.PageCode = LTO_LOGSENSE_TAPE_CAPACITY;
    cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PAGE_FORMAT) >> 8;
    cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PAGE_FORMAT);

    Srb->DataTransferLength = sizeof(LOG_SENSE_PAGE_FORMAT);

    return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
}

BOOLEAN
ProcessTapeCapacityInfo(
                       IN PSCSI_REQUEST_BLOCK Srb,
                       OUT PLTO_TAPE_CAPACITY LTOTapeCapacity
                       )
/*+++
Routine Description:

        This routine processes the data returned by the drive in TapeCapacity
        log page, and returns the remaining capacity as an ULONG. The value
        is in Megabytes.
        
Arguements:

        Srb - Pointer to the SCSI_REQUEST_BLOCK 
        
        LTOTapeCapacity - Pointer to LTO_TAPE_CAPACITY struct
        
Return Value:

        TRUE if LTOTapeCapacity was filled with valid data
        
        FALSE if there was any error. LTOTapaCapacity might not contain
              valid data in this case.

--*/
{
    USHORT paramCode;
    UCHAR  paramLen;
    UCHAR  actualParamLen;
    LONG   bytesLeft;
    PLOG_SENSE_PAGE_HEADER logSenseHeader;
    PLOG_SENSE_PARAMETER_HEADER logSenseParamHeader;
    PUCHAR  paramValue = NULL;
    ULONG transferLength;
    ULONG tapeCapacity = 0;

    TapeClassZeroMemory(LTOTapeCapacity,
                        sizeof(LTO_TAPE_CAPACITY));

    logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);

    ASSERT(((logSenseHeader->PageCode) == LTO_LOGSENSE_TAPE_CAPACITY));
    bytesLeft = logSenseHeader->Length[0];
    bytesLeft <<= 8;
    bytesLeft += logSenseHeader->Length[1];

    transferLength = Srb->DataTransferLength;
    if (bytesLeft > (LONG)(transferLength -
                           sizeof(LOG_SENSE_PAGE_HEADER))) {
        bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
    }

    (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseHeader + 
                                  sizeof(LOG_SENSE_PAGE_HEADER);
    DebugPrint((3, 
                "ProcessTapeCapacityInfo : BytesLeft %x, TransferLength %x\n",
                bytesLeft, transferLength));
    while (bytesLeft >= sizeof(LOG_SENSE_PARAMETER_HEADER)) {
        paramCode = logSenseParamHeader->ParameterCode[0];
        paramCode <<= 8; 
        paramCode |= logSenseParamHeader->ParameterCode[1];
        paramLen = logSenseParamHeader->ParameterLength;
        paramValue = (PUCHAR)logSenseParamHeader + sizeof(LOG_SENSE_PARAMETER_HEADER);

        //
        // Make sure we have at least
        // (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen) bytes left.
        // Otherwise, we've reached the end of the buffer.
        //
        if (bytesLeft < (LONG)(sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)) {
            DebugPrint((1,
                        "ltotape : Reached end of buffer. BytesLeft %x, Expected %x\n",
                        bytesLeft,
                        (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)));
            return FALSE;
        }

        //
        // We are currently interested only in remaining capacity field
        //
        actualParamLen = paramLen;
        tapeCapacity = 0;
        while (paramLen > 0) {
            tapeCapacity <<= 8;
            tapeCapacity += *paramValue;
            paramValue++;
            paramLen--;
        }

        if (paramCode == LTO_TAPE_REMAINING_CAPACITY) {
            LTOTapeCapacity->RemainingCapacity = tapeCapacity;
        } else if (paramCode == LTO_TAPE_MAXIMUM_CAPACITY) {
            LTOTapeCapacity->MaximumCapacity = tapeCapacity;
        }

        (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseParamHeader +
                                      sizeof(LOG_SENSE_PARAMETER_HEADER) +
                                      actualParamLen;

        bytesLeft -= actualParamLen + sizeof(LOG_SENSE_PARAMETER_HEADER);
    }

    DebugPrint((3, 
                "ProcessTapeCapacityInfo : Rem Capacity %x, Max Capacity %x\n",
                LTOTapeCapacity->RemainingCapacity,
                LTOTapeCapacity->MaximumCapacity));
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\hpt4qic\hpt4qic.c ===
/*++

Copyright (C) 1996 - Microsoft Corporation

Module Name:

    hpt4qic.c

Abstract:

    This module contains device specific routines for HP T4000
    drives with SCSI-2 interfaces .

Author:

    Kurt Godwin  (HP)

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"


#if DBG
//#define HACK_SCSIDEBUG 0x3082

VOID
ThisDbgPrint(int a,void *b,...)
{
    int *args;
    int save;
    char *ScsiDebug;

    args = (int *)b;

#if HACK_SCSIDEBUG
    ScsiDebug = (char *)ScsiDebugPrint + HACK_SCSIDEBUG;

    save = *ScsiDebug;
    *ScsiDebug = a;
#endif
    DebugPrint((a, b, args[1],args[2],args[3],args[4]));
#if HACK_SCSIDEBUG
    *ScsiDebug = save;
#endif

}

#endif



//
//  Internal (module wide) defines that symbolize
//  non-QFA mode and the two QFA mode partitions.
//
#define NO_PARTITIONS        0  // non-QFA mode
#define DATA_PARTITION       1  // QFA mode, data partition #
#define DIRECTORY_PARTITION  2  // QFA mode, directory partition #

//
//  Internal (module wide) defines that symbolize
//  the Tandberg QIC drives supported by this module.
//
#define HPT4000s  (ULONG)1
#define TR4 0xb6

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

#define QIC_SUPPORTED_TYPES 2
STORAGE_MEDIA_TYPE QicMedia[QIC_SUPPORTED_TYPES] = {MiniQic, Travan};

//
// Minitape extension definition.
//
typedef struct _MINITAPE_EXTENSION {
          ULONG DriveID ;
          ULONG CurrentPartition ;
          BOOLEAN CompressionOn ;
          BOOLEAN writeMode;
} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION ;

//
// Command extension definition.
//

typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;
    UCHAR   densityCode;
    UCHAR   mediumType;
    ULONG   tapeBlockLength;
    BOOLEAN changePartition ;
    ULONG   pos_type ;
    ULONG   filemarksLeft;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

//
//  Function Prototype(s) for internal function(s)
//

ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    );


BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );

TAPE_STATUS
PreReadWrite(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );



ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = TapeError ;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.PreProcessReadWrite = PreReadWrite;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = QIC_SUPPORTED_TYPES;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData);
    extension->CurrentPartition = 0 ;
    extension->CompressionOn = FALSE ;
    extension->writeMode = FALSE;
}

TAPE_STATUS
PreReadWrite(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )
/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension. (always NULL)

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number. (always NULL)

    RetryFlags          - Supplies the retry flags. (always NULL)

Return Value:

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    if (Srb->Cdb[0] == SCSIOP_WRITE6) {
        extension->writeMode = TRUE;
    }
    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION      extension = MinitapeExtension;
    PCOMMAND_EXTENSION       tapeCmdExtension = CommandExtension ;
    PTAPE_CREATE_PARTITION   tapePartition = CommandParameters;
    PMODE_MEDIUM_PART_PAGE   buffer;
    PCDB                     cdb = (PCDB) Srb->Cdb;

    //
    //  Only support 2 partitions, QFA mode
    //  Partition 1 = Used as directory
    //  Partition 0 = used as data
    //
    //  Note that 0 & 1 are partition numbers used
    //  by the drive -- they are not tape API partition
    //  numbers.
    //

    DebugPrint((3,"TapeCreatePartition:  CallNubmer %x\n",CallNumber));

    if (CallNumber == 0) {

        switch (tapePartition->Method) {
            case TAPE_FIXED_PARTITIONS:
                DebugPrint((3,"TapeCreatePartition: fixed partitions\n"));
                break;

            case TAPE_SELECT_PARTITIONS:
            case TAPE_INITIATOR_PARTITIONS:
            default:
                DebugPrint((1,"TapeCreatePartition: "));
                DebugPrint((1,"PartitionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
         }

        //
        // Must rewind to BOT before one can enable/disable QFA mode.
        // Changing the value of the FDP bit is only valid at BOT.
        // FDP bit is used to enable/disable "additional partitions"
        // (mode sense command).
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (rewind)\n"));

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_REWIND;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 320;
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if ( CallNumber == 1 ) {

        //
        // Performing mode select command, medium partition parameters page,
        // to enable/disable QFA mode: set the FDP bit accordingly.
        //

        if (!TapeClassAllocateSrbBuffer( Srb,sizeof(MODE_MEDIUM_PART_PAGE)) ) {
            DebugPrint((1,"TapeCreatePartition: insufficient resources (buffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        buffer = Srb->DataBuffer ;

        buffer->ParameterListHeader.DeviceSpecificParameter = 0x10;

        buffer->MediumPartPage.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        buffer->MediumPartPage.PageLength = 0x06;
        buffer->MediumPartPage.MaximumAdditionalPartitions = 1;
        buffer->MediumPartPage.MediumFormatRecognition = 1;

        //
        // Setup FDP bit to enable/disable "additional partition".
        //

        if (tapePartition->Count == 0) {
            buffer->MediumPartPage.FDPBit = SETBITOFF;
        } else {
            buffer->MediumPartPage.FDPBit = SETBITON;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode  = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode select)\n"));

        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 2 ) ;

    if (tapePartition->Count == 0) {
        extension->CurrentPartition = NO_PARTITIONS;
        DebugPrint((3,"TapeCreatePartition: QFA disabled\n"));
    } else {
        extension->CurrentPartition = DATA_PARTITION;
        DebugPrint((3,"TapeCreatePartition: QFA enabled\n"));
    }

    return TAPE_STATUS_SUCCESS;

} // end TapeCreatePartition()


TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION      extension = MinitapeExtension;
    PTAPE_ERASE              tapeErase = CommandParameters;
    PCDB                     cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: CallNumber %x\n",CallNumber));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            switch (tapeErase->Type) {
                case TAPE_ERASE_LONG:
                    DebugPrint((3,"TapeErase: immediate\n"));
                    break;

                case TAPE_ERASE_SHORT:
                default:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = SETBITON;

        Srb->TimeOutValue = 320;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 1 ) ;

    if (extension->CurrentPartition) {
        extension->CurrentPartition = DATA_PARTITION;
    }

    return TAPE_STATUS_SUCCESS ;

} // end TapeErase()


VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer = Srb->SenseInfoBuffer;
    UCHAR              sensekey = senseBuffer->SenseKey & 0x0F;
    UCHAR              adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
    UCHAR              adsense = senseBuffer->AdditionalSenseCode;
#if DBG
    int i;
    char a[40];
#endif

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));
    DebugPrint((1,"TapeError: SenseKey %x AddSenseCode %x AddSenseQual%x\n", sensekey, adsense, adsenseq));

#if DBG
#define HEX(a) (((a)&0xf)>0x9?((a)&0xf)+'a'-0xa:((a)&0xf)+'0')
    for (i=0;i<Srb->CdbLength;++i) {
        a[i*3] = HEX(Srb->Cdb[i] >> 4);
        a[i*3+1] = HEX(Srb->Cdb[i]);
        a[i*3+2] = ' ';
        a[i*3+3] = '\0';
    }
#endif
    DebugPrint((1,"cdb: %s\n", a));

    //
    // If we get a filemark error,  and the block skip is 0x7fffff then
    // we are tring to do a sequential seek.
    //
    if (Srb->Cdb[0] == 0x11 && Srb->Cdb[2] == 0x7f && Srb->Cdb[3] == 0xff && Srb->Cdb[4] == 0xff &&
        *LastError == TAPE_STATUS_FILEMARK_DETECTED) {

        DebugPrint((3,"TapeError: changing error to success\n"));
        *LastError = TAPE_STATUS_SUCCESS;
    }

    return;

} // end TapeError()


TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          cmdExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;
    PMODE_PARM_READ_WRITE_DATA  blockDescripterModeSenseBuffer;

    DebugPrint((3,"TapeGetDriveParameters: CallNumber %x\n",CallNumber));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        switch (extension->DriveID) {
            case HPT4000s:
                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
                    DebugPrint((1,"TapeGetDriveParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }
                deviceConfigModeSenseBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.Dbd = SETBITON;
                cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
                cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

                Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

            default:
                return TAPE_STATUS_CALLBACK ;

        }
    }

    if ( CallNumber == 1 ) {

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

//        tapeGetDriveParams->FeaturesLow |=
//                    TAPE_DRIVE_REPORT_SMKS;

//        tapeGetDriveParams->FeaturesHigh |=
//                    TAPE_DRIVE_SETMARKS |
//                    TAPE_DRIVE_WRITE_SETMARKS;

        tapeGetDriveParams->ReportSetmarks = FALSE ;

//        if (( LastError == TAPE_STATUS_SUCCESS ) &&
//            (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk) ) {
//
//            tapeGetDriveParams->ReportSetmarks = TRUE ;
//        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {

            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockDescripterModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockDescripterModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        blockDescripterModeSenseBuffer = Srb->DataBuffer ;

        cmdExtension->mediumType = blockDescripterModeSenseBuffer->ParameterListHeader.MediumType;
        cmdExtension->densityCode= blockDescripterModeSenseBuffer->ParameterListBlock.DensityCode;

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(READ_BLOCK_LIMITS_DATA)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimitsBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
         //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        Srb->DataTransferLength = sizeof(READ_BLOCK_LIMITS_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 3 ) ;

    blockLimits = Srb->DataBuffer ;

    tapeGetDriveParams->MaximumBlockSize  =  blockLimits->BlockMaximumSize[2];
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

    tapeGetDriveParams->MinimumBlockSize  =  blockLimits->BlockMinimumSize[1];
    tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);

    tapeGetDriveParams->ECC = 0;
    tapeGetDriveParams->DataPadding = 0;
    tapeGetDriveParams->MaximumPartitionCount = 2;

    tapeGetDriveParams->DefaultBlockSize = 512;


    tapeGetDriveParams->FeaturesLow |=
        TAPE_DRIVE_FIXED |
        TAPE_DRIVE_ERASE_LONG |
        TAPE_DRIVE_ERASE_BOP_ONLY |
        TAPE_DRIVE_ERASE_IMMEDIATE |
        TAPE_DRIVE_FIXED_BLOCK |
        TAPE_DRIVE_WRITE_PROTECT |
        TAPE_DRIVE_GET_ABSOLUTE_BLK |
        TAPE_DRIVE_GET_LOGICAL_BLK |
        TAPE_DRIVE_EJECT_MEDIA;

    tapeGetDriveParams->FeaturesHigh |=
        TAPE_DRIVE_LOAD_UNLOAD |
        TAPE_DRIVE_TENSION |
        TAPE_DRIVE_LOCK_UNLOCK |
        TAPE_DRIVE_REWIND_IMMEDIATE |
        TAPE_DRIVE_LOAD_UNLD_IMMED |
        TAPE_DRIVE_TENSION_IMMED |
        TAPE_DRIVE_ABSOLUTE_BLK |
        TAPE_DRIVE_LOGICAL_BLK |
        TAPE_DRIVE_END_OF_DATA |
        TAPE_DRIVE_RELATIVE_BLKS |
        TAPE_DRIVE_FILEMARKS |
//        TAPE_DRIVE_SEQUENTIAL_FMKS |
        TAPE_DRIVE_REVERSE_POSITION |
        TAPE_DRIVE_WRITE_FILEMARKS |
        TAPE_DRIVE_WRITE_MARK_IMMED;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
        tapeGetDriveParams->FeaturesLow));
    DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
        tapeGetDriveParams->FeaturesHigh));

    return TAPE_STATUS_SUCCESS;

} // end TapeGetDriveParameters()


TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigBuffer;
    PMODE_PARM_READ_WRITE_DATA  rwparametersModeSenseBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    BOOLEAN                     qfaMode;

    DebugPrint((3,"TapeGetMediaParameters: CallNumber %x\n",CallNumber));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (mediaInfoBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense #1)\n"));

        Srb->DataTransferLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        mediaInfoBuffer = Srb->DataBuffer ;

        tapeGetMediaParams->BlockSize = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);

        tapeGetMediaParams->WriteProtected =
            ((mediaInfoBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

        if (!mediaInfoBuffer->MediumPartPage.FDPBit) {

            tapeGetMediaParams->PartitionCount = 1 ;

            extension->CurrentPartition = NO_PARTITIONS;

            return TAPE_STATUS_SUCCESS ;

        } else {

            if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
                DebugPrint((1,"TapeGetMediaParameters: insufficient resources (deviceConfigBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            deviceConfigBuffer = Srb->DataBuffer ;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.Dbd = SETBITON;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense #2)\n"));

            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }
    }
    ASSERT( CallNumber == 3) ;

    deviceConfigBuffer = Srb->DataBuffer ;

    extension->CurrentPartition =
            deviceConfigBuffer->DeviceConfigPage.ActivePartition?
            DIRECTORY_PARTITION : DATA_PARTITION;

    tapeGetMediaParams->PartitionCount = 2;

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetMediaParameters()

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          cmdExtension = CommandExtension;
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigBuffer;
    PTAPE_POSITION_DATA         readPositionBuffer;
    PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;
    ULONG                       type;
    ULONG                        tapeBlockAddress;

    DebugPrint((3,"TapeGetPosition: CallNumber %x\n",CallNumber));

    if (CallNumber == 0) {

        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;
        cmdExtension->pos_type = type ;

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if ( CallNumber == 1 ) {

        if ( cmdExtension->pos_type != TAPE_LOGICAL_POSITION ) {

            return TAPE_STATUS_CALLBACK ;
        }

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (mediaInfoBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (mode sense #1)\n"));

        Srb->DataTransferLength=sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 2) {

        if ( cmdExtension->pos_type != TAPE_LOGICAL_POSITION ) {

            return TAPE_STATUS_CALLBACK ;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        cmdExtension->mediumType  = mediaInfoBuffer->ParameterListHeader.MediumType;
        cmdExtension->densityCode = mediaInfoBuffer->ParameterListBlock.DensityCode;
        cmdExtension->tapeBlockLength  = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);

        if (!mediaInfoBuffer->MediumPartPage.FDPBit) {
            extension->CurrentPartition = NO_PARTITIONS;
            return TAPE_STATUS_CALLBACK ;
        }

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (deviceConfigBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (mode sense #2)\n"));

        Srb->DataTransferLength=sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if ( CallNumber == 3 ) {

        if ((cmdExtension->pos_type == TAPE_LOGICAL_POSITION) && 
            (LastError != TAPE_STATUS_CALLBACK)) {

            deviceConfigBuffer = Srb->DataBuffer ;

            extension->CurrentPartition =
                 deviceConfigBuffer->DeviceConfigPage.ActivePartition?
                 DIRECTORY_PARTITION : DATA_PARTITION;

        }

        switch (cmdExtension->pos_type) {
            case TAPE_ABSOLUTE_POSITION:
                DebugPrint((3,"TapeGetPosition: absolute\n"));
                break;

            case TAPE_LOGICAL_POSITION:
                DebugPrint((3,"TapeGetPosition: logical\n"));
                break;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));

           return TAPE_STATUS_NOT_IMPLEMENTED;

        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(TAPE_POSITION_DATA)) ) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (readPositionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        readPositionBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB10GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;
        cdb->READ_POSITION.BlockType = (cmdExtension->pos_type == TAPE_LOGICAL_POSITION)?
                                       SETBITOFF : SETBITON;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

        Srb->DataTransferLength = sizeof(TAPE_POSITION_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    ASSERT( CallNumber == 4 ) ;

    readPositionBuffer = Srb->DataBuffer ;

    REVERSE_BYTES((PFOUR_BYTE)&tapeBlockAddress,
                      (PFOUR_BYTE)readPositionBuffer->FirstBlock);


    tapeGetPosition->Offset.HighPart = 0;
    tapeGetPosition->Offset.LowPart  = tapeBlockAddress;

    if (cmdExtension->pos_type != TAPE_ABSOLUTE_POSITION) {
        tapeGetPosition->Partition = extension->CurrentPartition;
    }

    if (readPositionBuffer->BlockPositionUnsupported)
        return TAPE_STATUS_NOT_IMPLEMENTED;
    else
        return TAPE_STATUS_SUCCESS;

} // end TapeGetPosition()


TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCDB    cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetStatus: CallNumber %x\n",CallNumber));

    if (CallNumber == 0) {
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;

} // end TapeGetStatus()


TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_PREPARE      tapePrepare = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    DebugPrint((3,"TapePrepare: CallNumber %x\n",CallNumber));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                case TAPE_TENSION:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_LOCK:
                case TAPE_UNLOCK:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_TENSION:
                DebugPrint((3,"TapePrepare: Operation == tension\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                return TAPE_STATUS_SUCCESS;
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_UNLOCK:

                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                if (!extension->writeMode) {
                    return TAPE_STATUS_SUCCESS;
                }
                extension->writeMode = FALSE;

                DebugPrint((3,"TapePrepare: sending rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;

//                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                Srb->TimeOutValue = 320;
                break;

            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    switch (tapePrepare->Operation) {
            case TAPE_UNLOCK:
                if (CallNumber == 1) {

                    DebugPrint((3,"TapePrepare: sending seek EOD\n"));
                    // Now That we have re-wound,  repos back to EOD
                    cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                    cdb->SPACE_TAPE_MARKS.Code = 3;
                    Srb->TimeOutValue = 360;  // six minutes
                    return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
                } else {
                    ASSERT(CallNumber == 2);
                    return TAPE_STATUS_SUCCESS;
                }
                break;
        default:
            ASSERT(CallNumber == 1) ;
            return TAPE_STATUS_SUCCESS;
    }

} // end TapePrepare()


TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;

    DebugPrint((3,"TapeSetDriveParameters: CallNumber %x\n",CallNumber));

    return TAPE_STATUS_NOT_IMPLEMENTED;

} // end TapeSetDriveParameters()

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: CallNumber %x\n",CallNumber));

    return TAPE_STATUS_NOT_IMPLEMENTED;

} // end TapeSetMediaParameters()


TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION          extension = MinitapeExtension;
    PCOMMAND_EXTENSION           cmdExtension = CommandExtension ;
    PTAPE_SET_POSITION           tapeSetPosition = CommandParameters;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeSetPosition: CallNumber %x\n",CallNumber));

    if (CallNumber == 0) {

        cmdExtension->changePartition = FALSE;
        cmdExtension->filemarksLeft = 0;


        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                    DebugPrint((3,"TapeSetPosition: immediate\n"));
                    break;

                case TAPE_LOGICAL_BLOCK:
                case TAPE_ABSOLUTE_BLOCK:
                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:
                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        cmdExtension->pos_type = tapeSetPosition->Method;

        if (cmdExtension->pos_type != TAPE_LOGICAL_BLOCK) {
            return TAPE_STATUS_CALLBACK ;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_TAPE_MEDIA_INFORMATION)) ) {
            DebugPrint((1,"TapeSetPosition: insufficient resources (mediaInfoBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (mode sense #1)\n"));

        Srb->DataTransferLength = sizeof(MODE_TAPE_MEDIA_INFORMATION) - 4 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 1 ) {
        PMODE_TAPE_MEDIA_INFORMATION mediaInfoBuffer;

        if (cmdExtension->pos_type != TAPE_LOGICAL_BLOCK) {
            return TAPE_STATUS_CALLBACK ;
        }

        mediaInfoBuffer = Srb->DataBuffer ;

        cmdExtension->mediumType       = mediaInfoBuffer->ParameterListHeader.MediumType;
        cmdExtension->densityCode      = mediaInfoBuffer->ParameterListBlock.DensityCode;
        cmdExtension->tapeBlockLength  = mediaInfoBuffer->ParameterListBlock.BlockLength[2];
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[1] << 8);
        cmdExtension->tapeBlockLength += (mediaInfoBuffer->ParameterListBlock.BlockLength[0] << 16);


        if (!mediaInfoBuffer->MediumPartPage.FDPBit) {
            extension->CurrentPartition = NO_PARTITIONS;
            return TAPE_STATUS_CALLBACK ;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeSetPosition: insufficient resources (deviceConfigBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (mode sense #2)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;
        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 2 ) {

        ULONG                        tapePositionVector;
        PMODE_DEVICE_CONFIG_PAGE     deviceConfigBuffer;

        //
        // If we are doing a logical block locate,  and
        // we just got the device configuration to get
        // the current partition
        //
        if (cmdExtension->pos_type == TAPE_LOGICAL_BLOCK &&
            LastError != TAPE_STATUS_CALLBACK ) {

            deviceConfigBuffer = Srb->DataBuffer ;

            // Get the current partition
            extension->CurrentPartition =
                deviceConfigBuffer->DeviceConfigPage.ActivePartition?
                DIRECTORY_PARTITION : DATA_PARTITION;
        

            // Get the new partition
            switch (tapeSetPosition->Partition) {
               case 0:
                  // No new partition,  ignore
               break;

               case DIRECTORY_PARTITION:
               case DATA_PARTITION:
                  if (extension->CurrentPartition != NO_PARTITIONS) {
                     if (tapeSetPosition->Partition
                          != extension->CurrentPartition) {
                         cmdExtension->changePartition = TRUE;
                     }
                     break;
                  }
                  // else: fall through to next case

               default:
                  DebugPrint((1,"TapeSetPosition: Partition -- invalid parameter\n"));
                  return TAPE_STATUS_INVALID_PARAMETER;
            }
        }

        tapePositionVector = tapeSetPosition->Offset.LowPart;

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (cmdExtension->pos_type) {
            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute)\n"));
                break;

            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (logical)\n"));
                break;

        }


        switch (cmdExtension->pos_type) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 320;
                break;

            case TAPE_ABSOLUTE_BLOCK:
            case TAPE_LOGICAL_BLOCK:

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.CPBit = cmdExtension->changePartition? SETBITON : SETBITOFF;
                cdb->LOCATE.BTBit = (cmdExtension->pos_type == TAPE_LOGICAL_BLOCK)?
                                     SETBITOFF : SETBITON;
                cdb->LOCATE.LogicalBlockAddress[1] =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] =
                    (UCHAR)(tapePositionVector & 0xFF);
                if (cmdExtension->changePartition &&
                    (tapeSetPosition->Partition == DIRECTORY_PARTITION)) {
                    cdb->LOCATE.Partition = 1;
                }

                Srb->TimeOutValue = 480;

                break;

            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 360; // 6 minutes
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:

                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11100;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                //
                //  The hp t4000 drive does not support space forward
                //  filemarks,  so space a bunch of blocks instead
                //
                if (/* hpt4000  && */ (tapePositionVector & 0x800000) == 0) {
                    DebugPrint((3,"TapeSetPosition: sending first mark\n"));
                    cmdExtension->filemarksLeft = tapePositionVector-1;

                    cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                    cdb->SPACE_TAPE_MARKS.Code = 0;
                    cdb->SPACE_TAPE_MARKS.NumMarksMSB = 0x7f;
                    cdb->SPACE_TAPE_MARKS.NumMarks = 0xff;
                    cdb->SPACE_TAPE_MARKS.NumMarksLSB =  0xff;

                } else {

                    cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                    cdb->SPACE_TAPE_MARKS.Code = 1;
                    cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                        (UCHAR)((tapePositionVector >> 16) & 0xFF);
                    cdb->SPACE_TAPE_MARKS.NumMarks =
                        (UCHAR)((tapePositionVector >> 8) & 0xFF);
                    cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                        (UCHAR)(tapePositionVector & 0xFF);

                }
                Srb->TimeOutValue = 11100;
                break;

            case TAPE_SPACE_SEQUENTIAL_FMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 2;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11100;
                break;

            case TAPE_SPACE_SETMARKS:
                DebugPrint((3,"TapeSetPosition: method == space setmarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 4;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 11100;
                break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 3 ) {

        // We successfully change partitions,  so set our mirror number
        if (cmdExtension->changePartition) {
            extension->CurrentPartition = tapeSetPosition->Partition;
        }

    }

    //
    // Repeatedly send the "space a bunch-o-blocks" command until we have
    // skipped all of the filemarks
    //
    if (CallNumber >= 3 && cmdExtension->filemarksLeft--) {
        //
        // for the HP T4000 drive,  it does not support space forward filemarks
        // so a space 0x7fffff blocks was issued instead.
        //
        DebugPrint((3,"TapeSetPosition: sending next mark\n"));
        cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
        cdb->SPACE_TAPE_MARKS.Code = 0;
        cdb->SPACE_TAPE_MARKS.NumMarksMSB = 0x7f;
        cdb->SPACE_TAPE_MARKS.NumMarks = 0xff;
        cdb->SPACE_TAPE_MARKS.NumMarksLSB =  0xff;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }


    return TAPE_STATUS_SUCCESS ;

} // end TapeSetPosition()



TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: CallNumber %x\n",CallNumber));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                case TAPE_SHORT_FILEMARKS:
                case TAPE_LONG_FILEMARKS:
                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SETMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == setmarks\n"));
                cdb->WRITE_TAPE_MARKS.WriteSetMarks = SETBITON;
                break;

            case TAPE_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == filemarks\n"));
                break;

            case TAPE_SHORT_FILEMARKS:
            case TAPE_LONG_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    ASSERT( CallNumber == 1 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapeWriteMarks()



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {

                DebugPrint((1,
                            "SonyAIT.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS));
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)Srb->DataTransferLength;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {

        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;
        PMODE_DEVICE_CONFIG_PAGE_PLUS configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, two types (either mc/travan or unknown) is returned.
        //

        mediaTypes->MediaInfoCount = 2;

        if ( LastError == TAPE_STATUS_SUCCESS ) {

            //
            // Determine the media type currently loaded.
            //

            mediaType = configInformation->ParameterListHeader.MediumType;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                        mediaType,
                        blockSize));


            switch (mediaType) {
                case 0:

                    //
                    // Cleaner, unknown, no media mounted...
                    //

                    currentMedia = 0;
                    break;

                case 0x02:
                case 0x10:
                case 0x12:
                case 0x13:
                case 0x14:
                case 0x15:
                case 0x83:
                case 0x85:

                    //
                    // qic media
                    //

                    currentMedia = MiniQic;
                    break;

                case 0x03:
                case 0xA6:
                case 0xB6:

                    //
                    // travan media
                    //

                    currentMedia = Travan;
                    break;

                default:

                    //
                    // Unknown
                    //

                    currentMedia = 0;
                    break;
            }
        } else {
            currentMedia = 0;
        }

        //
        // fill in buffer based on spec. values
        // Only one type supported now.
        //

        for (i = 0; i < mediaTypes->MediaInfoCount; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = QicMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (QicMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;


                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    configInformation->ParameterListBlock.DensityCode;

                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }

    }

    return TAPE_STATUS_SUCCESS;
}


ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{

    if (TapeClassCompareMemory(InquiryData->VendorId,"HP      ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"T4000",5) == 5) {
            return HPT4000s;
        }

    }
    return (ULONG)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\exabyte1\exabyte1.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    exabyte1.c

Abstract:

    This module contains the device-specific routines for the Exabyte
    EXB-8200 tape drive and the Exabyte EXB-8200sx handled as an EXB-8200.

Environment:

    kernel mode only

--*/

#include "minitape.h"

//
//  Internal (module wide) defines that symbolize
//  the 8mm drives supported by this module.
//
#define EXABYTE_8200    1  // aka the Maynard 2200hs & 2200+
#define EXABYTE_8200SX  2  // Exabyte's own brand (OEM?) 8200SX
#define EXABYTE_8205    3  // An Exabyte 8200 with data compresion
#define OEMIBM_8200     4  // IBM version of an OEM Exabyte 8200

//
// Define EXABYTE vendor unique mode select/sense information.
//

#define OEMIBM_MODE_LENGTH           0x12
#define EXABYTE_MODE_LENGTH          0x11
#define EXABYTE_CARTRIDGE            0x80
#define EXABYTE_NO_DATA_DISCONNECT   0x20
#define EXABYTE_NO_BUSY_ENABLE       0x08
#define EXABYTE_EVEN_BYTE_DISCONNECT 0x04
#define EXABYTE_PARITY_ENABLE        0x02
#define EXABYTE_NO_AUTO_LOAD         0X01


#define EXA_SUPPORTED_TYPES 1
STORAGE_MEDIA_TYPE ExaMedia[EXA_SUPPORTED_TYPES] = {MP_8mm};

//
//  Function prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);

//
// Minitape extension definition.
//

typedef struct _MINITAPE_EXTENSION {

    ULONG DriveID;
    ULONG Capacity;

} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION;

//
// Command extension definition.
//

typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;


//
// Request structure used to determine cleaning needs, and remaining tape
// capacity.
//

typedef struct _EXB_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Reserved2[2];
    UCHAR RWDataErrorCounter[3];
    UCHAR UnitSense[3];
    UCHAR Reserved4;
    UCHAR Remaining[3];
    UCHAR RetryCounters[2];
    UCHAR FSC;
} EXB_SENSE_DATA, *PEXB_SENSE_DATA;

//
// Bit definitions for UnitSense
//

#define EXB_DRIVE_NEEDS_CLEANING 0x08
#define EXB_DRIVE_CLEANED        0x10

BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );

ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = VerifyInquiry;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = TapeError;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = EXA_SUPPORTED_TYPES;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}

BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine examines the given inquiry data to determine whether
    or not the given device is one that may be controller by this driver.

Arguments:

    InquiryData - Supplies the SCSI inquiry data.

Return Value:

    FALSE   - This driver does not recognize the given device.

    TRUE    - This driver recognizes the given device.

--*/

{
    return WhichIsIt(InquiryData) ? TRUE : FALSE;
}

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData);
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));
    DebugPrint((1,"TapeCreatePartition: operation not supported\n"));
    return TAPE_STATUS_NOT_IMPLEMENTED;
}

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }


        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = 0;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;

        cdb->ERASE.Long = SETBITON;


        //
        // Send SCSI command (CDB) to device
        //

        Srb->TimeOutValue = 18000;

        Srb->DataTransferLength = 0;

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;

} // end TapeErase()


VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    DebugPrint((3,"TapeError: Enter routine\n"));

    switch (*LastError) {
        case TAPE_STATUS_DEVICE_NOT_READY:
            *LastError = TAPE_STATUS_NO_MEDIA;
            break;

        case TAPE_STATUS_NO_DATA_DETECTED:
            break;
    }

    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));
    return;

} // end TapeError()

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(READ_BLOCK_LIMITS_DATA))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimits)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        Srb->DataTransferLength = sizeof(READ_BLOCK_LIMITS_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT( CallNumber == 1 ) ;

    blockLimits = Srb->DataBuffer;

    tapeGetDriveParams->MaximumBlockSize = blockLimits->BlockMaximumSize[2];
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

    tapeGetDriveParams->MinimumBlockSize = blockLimits->BlockMinimumSize[1];
    tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);

    tapeGetDriveParams->ECC = 0;
    tapeGetDriveParams->Compression = 0;
    tapeGetDriveParams->DataPadding = 0;
    tapeGetDriveParams->ReportSetmarks = 0;
    tapeGetDriveParams->MaximumPartitionCount = 0;
    tapeGetDriveParams->DefaultBlockSize = 1024;

    tapeGetDriveParams->FeaturesLow |=
        TAPE_DRIVE_ERASE_LONG |
        TAPE_DRIVE_FIXED_BLOCK |
        TAPE_DRIVE_VARIABLE_BLOCK |
        TAPE_DRIVE_WRITE_PROTECT |
        TAPE_DRIVE_EJECT_MEDIA;

    tapeGetDriveParams->FeaturesHigh |=
        TAPE_DRIVE_LOAD_UNLOAD |
        TAPE_DRIVE_REWIND_IMMEDIATE |
        TAPE_DRIVE_SET_BLOCK_SIZE |
//        TAPE_DRIVE_LOCK_UNLOCK |
        TAPE_DRIVE_LOAD_UNLD_IMMED |
        TAPE_DRIVE_RELATIVE_BLKS |
        TAPE_DRIVE_FILEMARKS |
        TAPE_DRIVE_REVERSE_POSITION |
        TAPE_DRIVE_WRITE_SHORT_FMKS |
        TAPE_DRIVE_WRITE_LONG_FMKS;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
        tapeGetDriveParams->FeaturesLow));
    DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
        tapeGetDriveParams->FeaturesHigh));

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetDriveParameters()


TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PEXB_SENSE_DATA             senseData;
    ULONG                       remaining;
    ULONG                       modeLength;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

         modeLength = (extension->DriveID == OEMIBM_8200)? OEMIBM_MODE_LENGTH : EXABYTE_MODE_LENGTH ;

        if (!TapeClassAllocateSrbBuffer(Srb, modeLength)) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)modeLength;
        if (extension->DriveID == OEMIBM_8200) {
            cdb->MODE_SENSE.Reserved2 = SETBITON ;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if ( CallNumber == 2 ) {
        modeBuffer = Srb->DataBuffer;

        modeLength = (extension->DriveID == OEMIBM_8200)? OEMIBM_MODE_LENGTH : EXABYTE_MODE_LENGTH ;

        tapeGetMediaParams->BlockSize  =  modeBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);

        tapeGetMediaParams->WriteProtected =
            ((modeBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListBlock.NumberOfBlocks[0] = 0 ;
        modeBuffer->ParameterListBlock.NumberOfBlocks[1] = 0 ;
        modeBuffer->ParameterListBlock.NumberOfBlocks[2] = 0 ;

        //
        // Set the even byte disconnect flag in the mode data.
        //

        if (extension->DriveID == OEMIBM_8200) {
            ((PUCHAR)(modeBuffer+1))[2] |= EXABYTE_EVEN_BYTE_DISCONNECT;
        } else {
            ((PUCHAR)(modeBuffer+1))[0] |= EXABYTE_EVEN_BYTE_DISCONNECT;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)modeLength;

        if (extension->DriveID == OEMIBM_8200) {
            cdb->MODE_SELECT.PFBit = SETBITON;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3) {

        tapeGetMediaParams->Capacity.QuadPart = 0;
        tapeGetMediaParams->Remaining.QuadPart = 0;

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
            DebugPrint((1,"GetRemaining Size: insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS ;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6INQUIRY.AllocationLength = sizeof(EXB_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

        Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 4 ) ;

    if ( LastError == TAPE_STATUS_SUCCESS ) {
        senseData = Srb->DataBuffer ;

        remaining =  (senseData->Remaining[0] << 16);
        remaining += (senseData->Remaining[1] << 8);
        remaining += (senseData->Remaining[2]);

        tapeGetMediaParams->Capacity.LowPart  = extension->Capacity ;
        tapeGetMediaParams->Remaining.LowPart = remaining ;
        tapeGetMediaParams->Capacity.QuadPart <<= 10;
        tapeGetMediaParams->Remaining.QuadPart <<= 10;
    }

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetMediaParameters()


TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PTAPE_POSITION_DATA         logicalBuffer;
    ULONG                       type;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    DebugPrint((1,"TapeGetPosition: operation not supported\n"));
    return TAPE_STATUS_NOT_IMPLEMENTED;

} // end TapeGetPosition()

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCOMMAND_EXTENSION  commandExtension = CommandExtension;
    PCDB                cdb = (PCDB)Srb->Cdb;
    PEXB_SENSE_DATA     senseData;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags |= RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        commandExtension->CurrentState = LastError;

        //
        // Issue a request sense to get the cleaning info bits.
        //

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA))) {
            DebugPrint((1,
                        "GetStatus: Insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(EXB_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    } else if (CallNumber == 2) {
        if ((commandExtension->CurrentState == TAPE_STATUS_SUCCESS)  ||
            (commandExtension->CurrentState == TAPE_STATUS_NO_MEDIA)) {

            //
            // Return needs cleaning status if necessary, but only if
            // no other errors are present.
            //

            senseData = Srb->DataBuffer;

            //
            // Determine if the clean bit is set.
            //

            if (senseData->UnitSense[2] & EXB_DRIVE_NEEDS_CLEANING) {
                DebugPrint((1,
                           "Drive reports needs cleaning - UnitSense %x\n",
                           senseData->UnitSense[2]));

                return TAPE_STATUS_REQUIRES_CLEANING;
            } else {
               return (commandExtension->CurrentState);
            }
        } else {

            //
            // Return the saved error status.
            //

            return commandExtension->CurrentState;
        }
    }

    return TAPE_STATUS_SUCCESS;
} // end TapeGetStatus()

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION extension = MinitapeExtension;
    PTAPE_PREPARE       tapePrepare = CommandParameters;
    PEXB_SENSE_DATA     senseData;
    ULONG               remaining;
    PCDB                cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_TENSION:
                case TAPE_LOCK:
                case TAPE_UNLOCK:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->TimeOutValue = 150;

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                break;

            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if ( CallNumber == 1 ) {
        if (tapePrepare->Operation == TAPE_LOAD ) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
                DebugPrint((1,"GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS ;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6INQUIRY.AllocationLength = sizeof(EXB_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        } else {

            return TAPE_STATUS_CALLBACK ;
        }
    }

    ASSERT(CallNumber == 2 );

    if ( LastError == TAPE_STATUS_SUCCESS ) {
        senseData = Srb->DataBuffer ;

        remaining =  (senseData->Remaining[0] << 16);
        remaining += (senseData->Remaining[1] << 8);
        remaining += (senseData->Remaining[2]);

        extension->Capacity = remaining;
    }

    return TAPE_STATUS_SUCCESS ;

} // end TapePrepare()

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));
    DebugPrint((1,"TapeSetDriveParameters: operation not supported\n"));
    return TAPE_STATUS_NOT_IMPLEMENTED;

} // end TapeSetDriveParameters()


TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
            MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.DensityCode = 0;
        modeBuffer->ParameterListBlock.BlockLength[0] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
            (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

         //
         // Prepare SCSI command (CDB)
         //

         Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        if (extension->DriveID == OEMIBM_8200) {
            cdb->MODE_SELECT.PFBit = SETBITON;
        }


        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT( CallNumber == 2);

    return TAPE_STATUS_SUCCESS;

} // end TapeSetMediaParameters()


TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION extension = MinitapeExtension;
    PTAPE_SET_POSITION  tapeSetPosition = CommandParameters;
    PCDB                cdb = (PCDB)Srb->Cdb;
    PEXB_SENSE_DATA             senseData;
    ULONG                       remaining;
    ULONG               tapePositionVector;
    ULONG               method;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                    DebugPrint((3,"TapeSetPosition: immediate\n"));
                    break;

                case TAPE_ABSOLUTE_BLOCK:
                case TAPE_LOGICAL_BLOCK:
                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:
                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        method = tapeSetPosition->Method;
        tapePositionVector = tapeSetPosition->Offset.LowPart;

        //
        // Prepare SCSI command (CDB)
        //
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (method) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;
            case TAPE_ABSOLUTE_BLOCK:
            case TAPE_LOGICAL_BLOCK:
            case TAPE_SPACE_END_OF_DATA:
            case TAPE_SPACE_SEQUENTIAL_FMKS:
            case TAPE_SPACE_SETMARKS:
            case TAPE_SPACE_SEQUENTIAL_SMKS:
            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if ( CallNumber == 1 ) {

        if (tapeSetPosition->Method == TAPE_REWIND ) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
                DebugPrint((1,"GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS ;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6INQUIRY.AllocationLength = sizeof(EXB_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        } else {

            return TAPE_STATUS_CALLBACK ;
        }
    }

    ASSERT(CallNumber == 2 );

    if ( LastError == TAPE_STATUS_SUCCESS ) {

        senseData = Srb->DataBuffer ;

        remaining =  (senseData->Remaining[0] << 16);
        remaining += (senseData->Remaining[1] << 8);
        remaining += (senseData->Remaining[2]);

        extension->Capacity = remaining ;
    }

    return TAPE_STATUS_SUCCESS;

} // end TapeSetPosition()


TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }


        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;

        switch (tapeWriteMarks->Type) {
            case TAPE_SHORT_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == short filemarks\n"));
                cdb->WRITE_TAPE_MARKS.Control = 0x80;
                break;

            case TAPE_LONG_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == long filemarks\n"));
                break;

            case TAPE_SETMARKS:
            case TAPE_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
           (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);


        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;

} // end TapeWriteMarks()



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES    mediaTypes = CommandParameters;
    PMINITAPE_EXTENSION extension = MinitapeExtension;
    PDEVICE_MEDIA_INFO  mediaInfo = &mediaTypes->MediaInfo[0];
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    ULONG                       modeLength;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            modeLength = (extension->DriveID == OEMIBM_8200)? OEMIBM_MODE_LENGTH : EXABYTE_MODE_LENGTH ;

            if (!TapeClassAllocateSrbBuffer(Srb, modeLength)) {
                DebugPrint((1,"TapeGetMediaParameters: insufficient resources (modeBuffer)\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            modeBuffer = Srb->DataBuffer;

            //
            // Prepare SCSI command (CDB)
            //

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)modeLength;
            if (extension->DriveID == OEMIBM_8200) {
                cdb->MODE_SENSE.Reserved2 = SETBITON ;
            }

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {

        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;
        mediaTypes->MediaInfoCount = 1;
        modeBuffer = Srb->DataBuffer;

        //
        // Determine the media type currently loaded.
        //

        if ( LastError == TAPE_STATUS_SUCCESS ) {

            mediaType = modeBuffer->ParameterListHeader.MediumType;
            blockSize = modeBuffer->ParameterListBlock.BlockLength[2];
            blockSize |= (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (modeBuffer->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                        mediaType,
                        blockSize));

            switch (mediaType) {
                case 0:

                    //
                    // Cleaner, unknown, no media mounted...
                    //

                    currentMedia = 0;
                    break;

                case 0x81:
                case 0x82:
                case 0x83:
                case 0x84:
                case 0x85:
                case 0x86:
                case 0xC1:
                case 0xC2:
                case 0xC3:
                case 0xC4:

                    //
                    // 15-160m non-AME
                    //

                    currentMedia = MP_8mm;
                    break;

                default:

                    //
                    // Unknown
                    //

                    currentMedia = 0;
                    break;
            }
        } else {
            currentMedia = 0;
        }

        for (i = 0; i < mediaTypes->MediaInfoCount; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = ExaMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (ExaMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((modeBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;


                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    modeBuffer->ParameterListBlock.DensityCode;

                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }
    }

    return TAPE_STATUS_SUCCESS;
}

static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"EXABYTE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-8200",8) == 8) {

            if (InquiryData->ResponseDataFormat == 0) {
                return EXABYTE_8200;
            }

            if (InquiryData->ResponseDataFormat == 1) {
                return OEMIBM_8200;
            }

        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB8200C",8) == 8) {
            return EXABYTE_8200;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"8200SX",6) == 6) {
            return EXABYTE_8200SX;
        }

// the drive was moved to exabyte2.sys
//        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-8205",8) == 8) {
//            return EXABYTE_8205;
//        }

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\exabyte2\exabyte2.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    exabyte2.c

Abstract:

    This module contains the device-specific routines for the Exabyte
    EXB-8500 tape drive.

Environment:

    kernel mode only

--*/

#include "minitape.h"
#include "exabyte2.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

STORAGE_MEDIA_TYPE ExaMedia[EXA_SUPPORTED_TYPES] = {MP_8mm};


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = TapeError;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = EXA_SUPPORTED_TYPES;

    tapeInitData.TapeWMIOperations = TapeWMIControl;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->CurrentPartition = 0;
    extension->DriveID = WhichIsIt(InquiryData);
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION          tapeExtension = MinitapeExtension;
    PTAPE_CREATE_PARTITION       tapeCreatePartition = CommandParameters;
    PMODE_PARAMETER_HEADER       parameterListHeader;
    PMODE_MEDIUM_PARTITION_PAGE  mediumPartPage;
    PMODE_MEDIUM_PART_PAGE       mediaInformation;
    ULONG                        partitionMethod;
    ULONG                        partitionCount;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));
    DebugPrint((1,"TapeCreatePartition: operation not supported\n"));





    if (CallNumber == 0) {

       if ((tapeCreatePartition->Method) == 
           TAPE_INITIATOR_PARTITIONS) {

          //
          // Prepare SCSI command (CDB)
          //
   
          Srb->CdbLength = CDB6GENERIC_LENGTH;
   
          TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
   
          cdb->CDB6GENERIC.Immediate = FALSE;
   
          cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
          Srb->TimeOutValue = 250;
          Srb->DataTransferLength = 0;
   
          return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
   
       } else {
          return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
       }

    }

    if (CallNumber == 1) {

        //
        // Build mode sense for the medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_MEDIUM_PART_PAGE))) {

            DebugPrint((1,
                        "Exabyte2.TapeCreatePartition: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_MEDIUM_PART_PAGE));
        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE) - 2;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_MEDIUM_PART_PAGE) - 2;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if (CallNumber == 2) {

        //
        // Issued the mode sense of the partition page successfully.
        //

        mediaInformation = Srb->DataBuffer;

        //
        // Extract each of the sub-blocks from the mode sense info.
        //

        parameterListHeader = &mediaInformation->ParameterListHeader;
        mediumPartPage = &mediaInformation->MediumPartPage;

        //
        // Zero out the extraneous bits.
        //

        parameterListHeader->ModeDataLength = 0;
        parameterListHeader->MediumType = 0;

        //
        // Get the count and method.
        //

        partitionCount = tapeCreatePartition->Count;
        partitionMethod = tapeCreatePartition->Method;

        switch (partitionCount) {

        case 0:
        case 1:
        case 2:
            break;


            //
            // Only supportes up to two partitions.
            //

        default:
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        switch (partitionMethod) {
        case TAPE_FIXED_PARTITIONS:

            //
            // The 85xx drives specify fixed as '1' partition encompassing the entire tape.
            // Being as the model doesn't export this fact, the driver won't support this function.
            //

            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
            break;

        case TAPE_SELECT_PARTITIONS:


            mediumPartPage->SDPBit = 1;
            mediumPartPage->PSUMBit = 2;
            mediumPartPage->AdditionalPartitionDefined = (UCHAR)(partitionCount - 1);
            break;

        case TAPE_INITIATOR_PARTITIONS:
            mediumPartPage->IDPBit = 1;
            mediumPartPage->PSUMBit = 2;
            if (partitionCount == 0) {
                mediumPartPage->AdditionalPartitionDefined = 0;
                mediumPartPage->Partition0Size[0] = 0;
                mediumPartPage->Partition0Size[1] = 0;
            } else {
                mediumPartPage->AdditionalPartitionDefined = (UCHAR)(partitionCount - 1);
                mediumPartPage->Partition0Size[0] = (UCHAR)((tapeCreatePartition->Size >> 8) & 0xFF);
                mediumPartPage->Partition0Size[1] = (UCHAR)(tapeCreatePartition->Size & 0xFF);
            }

            break;

        default:
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        Srb->CdbLength = CDB6GENERIC_LENGTH ;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_MEDIUM_PART_PAGE) - 2;

        Srb->TimeOutValue = 16500;
        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE) - 2;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3) {

        //
        // Build mode sense for the medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE) - 1)) {

            DebugPrint((1,
                        "Mammoth.TapeCreatePartition: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if (CallNumber == 4) {

        PMODE_DEVICE_CONFIG_PAGE deviceConfig = Srb->DataBuffer;
        PMODE_PARAMETER_HEADER       parameterListHeader = &deviceConfig->ParameterListHeader;
        PMODE_DEVICE_CONFIGURATION_PAGE  deviceConfigPage = &deviceConfig->DeviceConfigPage;

        tapeExtension->CurrentPartition = deviceConfigPage->ActivePartition;
    }

    return TAPE_STATUS_SUCCESS;
}


TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            switch (tapeErase->Type) {
                case TAPE_ERASE_LONG:
                    DebugPrint((3,"TapeErase: immediate\n"));
                    break;

                case TAPE_ERASE_SHORT:
                default:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }


        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = 0;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = SETBITON;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 18000;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer;
    UCHAR              sensekey;
    UCHAR              adsenseq;
    UCHAR              adsense;

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       senseBuffer = Srb->SenseInfoBuffer;
       sensekey = senseBuffer->SenseKey & 0x0F;
       adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
       adsense = senseBuffer->AdditionalSenseCode;

       if (*LastError == TAPE_STATUS_IO_DEVICE_ERROR) {
           if ((sensekey == SCSI_SENSE_ABORTED_COMMAND) &&
               (adsense  == 0x5A) &&
               (adsenseq == 0x01) ){    //operator medium removal request
   
               *LastError = TAPE_STATUS_NO_MEDIA;
   
           }
       }
    }

    DebugPrint((1,"TapeError: Status 0x%.8X \n", *LastError));

    return;

} // end TapeError()

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (modeParmBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        deviceConfigModeSenseBuffer = Srb->DataBuffer;

        tapeGetDriveParams->ReportSetmarks =
            (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk? 1 : 0 );

        switch (extension->DriveID) {
            case EXABYTE_8505:
            case EXABYTE_8500C:
            case IBM_8505:
                commandExtension->CurrentState = 0;
                break;

            default:
                commandExtension->CurrentState = 2;
                break;
        }
    }

    if (commandExtension->CurrentState == 0) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DATA_COMPRESS_PAGE))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        commandExtension->CurrentState = 1;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (commandExtension->CurrentState == 1) {

        compressionModeSenseBuffer = Srb->DataBuffer;

        if (compressionModeSenseBuffer->DataCompressPage.DCC) {
            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
                (compressionModeSenseBuffer->DataCompressPage.DCE? TRUE : FALSE);
        }

        commandExtension->CurrentState = 2;
    }

    if (commandExtension->CurrentState == 2) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(READ_BLOCK_LIMITS_DATA))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimits)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        commandExtension->CurrentState = 3;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(commandExtension->CurrentState == 3);

    blockLimits = Srb->DataBuffer;

    tapeGetDriveParams->MaximumBlockSize =  blockLimits->BlockMaximumSize[2];
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

    tapeGetDriveParams->MinimumBlockSize =  blockLimits->BlockMinimumSize[1];
    tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);

    tapeGetDriveParams->ECC = 0;
    tapeGetDriveParams->DataPadding = 0;
    tapeGetDriveParams->MaximumPartitionCount = 2;
    tapeGetDriveParams->DefaultBlockSize = 1024;

    tapeGetDriveParams->FeaturesLow |=
        TAPE_DRIVE_SELECT           |
        TAPE_DRIVE_INITIATOR        |
        TAPE_DRIVE_TAPE_CAPACITY    |
        TAPE_DRIVE_TAPE_REMAINING   |
        TAPE_DRIVE_ERASE_LONG       |
        TAPE_DRIVE_ERASE_IMMEDIATE  |
        TAPE_DRIVE_FIXED_BLOCK      |
        TAPE_DRIVE_VARIABLE_BLOCK   |
        TAPE_DRIVE_WRITE_PROTECT    |
        TAPE_DRIVE_GET_ABSOLUTE_BLK |
        TAPE_DRIVE_GET_LOGICAL_BLK  |
        TAPE_DRIVE_EJECT_MEDIA      |
        TAPE_DRIVE_CLEAN_REQUESTS;

    tapeGetDriveParams->FeaturesHigh |=
        TAPE_DRIVE_LOAD_UNLOAD       |
        TAPE_DRIVE_LOCK_UNLOCK       |
        TAPE_DRIVE_REWIND_IMMEDIATE  |
        TAPE_DRIVE_SET_BLOCK_SIZE    |
        TAPE_DRIVE_LOAD_UNLD_IMMED   |
        TAPE_DRIVE_RELATIVE_BLKS     |
        TAPE_DRIVE_FILEMARKS         |
        TAPE_DRIVE_REVERSE_POSITION  |
        TAPE_DRIVE_WRITE_SHORT_FMKS  |
        TAPE_DRIVE_WRITE_LONG_FMKS   |
        TAPE_DRIVE_WRITE_MARK_IMMED  |
        TAPE_DRIVE_ABSOLUTE_BLK      |
        TAPE_DRIVE_ABS_BLK_IMMED     |
        TAPE_DRIVE_LOGICAL_BLK       |
        TAPE_DRIVE_LOG_BLK_IMMED     |
        TAPE_DRIVE_END_OF_DATA;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PMODE_PARAMETER_HEADER      parameterListHeader;
    PMODE_MEDIUM_PARTITION_PAGE mediumPartPage;
    PMODE_MEDIUM_PART_PAGE      mediaInformation;
    PEXB_SENSE_DATA             senseData;
    ULONG                       remaining;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, EXABYTE_MODE_LENGTH)) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = EXABYTE_MODE_LENGTH;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        modeBuffer = Srb->DataBuffer;

        tapeGetMediaParams->BlockSize = modeBuffer->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (modeBuffer->ParameterListBlock.BlockLength[0] << 16);

        tapeGetMediaParams->WriteProtected =
            ((modeBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

        //
        // Set the even byte disconnect flag in the mode data.  This is the
        // first byte of the vendor unique data.
        //

        *((PUCHAR)(modeBuffer+1)) |= EXABYTE_EVEN_BYTE_DISCONNECT;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListBlock.DensityCode = 0x7F;
        modeBuffer->ParameterListBlock.NumberOfBlocks[0] = 0;
        modeBuffer->ParameterListBlock.NumberOfBlocks[1] = 0;
        modeBuffer->ParameterListBlock.NumberOfBlocks[2] = 0;
        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = EXABYTE_MODE_LENGTH;

        *RetryFlags |= IGNORE_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 3) {

        tapeGetMediaParams->Capacity.QuadPart = 0;
        tapeGetMediaParams->Remaining.QuadPart = 0;

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
            DebugPrint((1,"GetRemaining Size: insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS ;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6INQUIRY.AllocationLength = sizeof(EXB_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

        Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 4) {
        if ( LastError == TAPE_STATUS_SUCCESS ) {
            senseData = Srb->DataBuffer ;

            remaining =  (senseData->Remaining[0] << 16);
            remaining += (senseData->Remaining[1] << 8);
            remaining += (senseData->Remaining[2]);

            tapeGetMediaParams->Capacity.LowPart  = extension->Capacity ;
            tapeGetMediaParams->Remaining.LowPart = remaining ;
            tapeGetMediaParams->Capacity.QuadPart <<= 10;
            tapeGetMediaParams->Remaining.QuadPart <<= 10;
        }

        //
        // Build mode sense for the medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_MEDIUM_PART_PAGE))) {

            DebugPrint((1,
                        "Exabyte2.TapeCreatePartition: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_MEDIUM_PART_PAGE));
        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE) - 2;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_MEDIUM_PART_PAGE) - 2;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT(CallNumber == 5);

    if (LastError == TAPE_STATUS_SUCCESS) {

        //
        // Issued the mode sense of the partition page successfully.
        //

        mediaInformation = Srb->DataBuffer;

        //
        // Extract each of the sub-blocks from the mode sense info.
        //

        parameterListHeader = &mediaInformation->ParameterListHeader;
        mediumPartPage = &mediaInformation->MediumPartPage;

        tapeGetMediaParams->PartitionCount = mediaInformation->MediumPartPage.AdditionalPartitionDefined + 1;
    }


    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PTAPE_POSITION_DATA         logicalBuffer;
    ULONG                       type;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;

        switch (type) {
            case TAPE_ABSOLUTE_POSITION:
            case TAPE_LOGICAL_POSITION:
                if (!TapeClassAllocateSrbBuffer(Srb, sizeof(TAPE_POSITION_DATA))) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (logicalBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                logicalBuffer = Srb->DataBuffer;

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                Srb->TimeOutValue = 600;

                cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }
    }

    ASSERT(CallNumber == 1);

    logicalBuffer = Srb->DataBuffer;

    if (logicalBuffer->BlockPositionUnsupported) {
        DebugPrint((1,"TapeGetPosition: read position -- logical block position unsupported\n"));
        return TAPE_STATUS_INVALID_DEVICE_REQUEST;
    }

    tapeGetPosition->Partition = 0;
    if (tapeGetPosition->Type == TAPE_LOGICAL_POSITION) {
        tapeGetPosition->Partition = logicalBuffer->PartitionNumber + 1;
    }

    tapeGetPosition->Offset.HighPart = 0;
    REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                  (PFOUR_BYTE)logicalBuffer->FirstBlock);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCOMMAND_EXTENSION  commandExtension = CommandExtension;
    PCDB                cdb = (PCDB)Srb->Cdb;
    PEXB_SENSE_DATA     senseData;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags |= RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        commandExtension->CurrentState = LastError;

        //
        // Issue a request sense to get the cleaning info bits.
        //

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA))) {
            DebugPrint((1,
                        "GetStatus: Insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(EXB_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    } else if (CallNumber == 2) {
        if ((commandExtension->CurrentState == TAPE_STATUS_SUCCESS)  ||
            (commandExtension->CurrentState == TAPE_STATUS_NO_MEDIA)) {

            //
            // Return needs cleaning status if necessary, but only if
            // no other errors are present.
            //

            senseData = Srb->DataBuffer;

            //
            // Determine if the clean bit is set.
            //

            if (senseData->UnitSense[2] & EXB_DRIVE_NEEDS_CLEANING) {
                DebugPrint((1,
                           "Drive reports needs cleaning - UnitSense %x\n",
                           senseData->UnitSense[2]));

                return TAPE_STATUS_REQUIRES_CLEANING;
            } else {
               return (commandExtension->CurrentState);
            }
        } else {

            //
            // Return the saved error status.
            //

            return commandExtension->CurrentState;
        }
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_PREPARE               tapePrepare = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PEXB_SENSE_DATA             senseData;
    ULONG                       remaining;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_TENSION:
                case TAPE_LOCK:
                case TAPE_UNLOCK:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_TENSION:
            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if ( CallNumber == 1 ) {

        if (tapePrepare->Operation == TAPE_LOAD ) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
                DebugPrint((1,"GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS ;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6INQUIRY.AllocationLength = sizeof(EXB_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        } else {

            return TAPE_STATUS_CALLBACK ;
        }
    }

    ASSERT(CallNumber == 2 );

    if ( LastError == TAPE_STATUS_SUCCESS ) {
        senseData = Srb->DataBuffer ;

        remaining =  (senseData->Remaining[0] << 16);
        remaining += (senseData->Remaining[1] << 8);
        remaining += (senseData->Remaining[2]);

        extension->Capacity = remaining;
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;
    PMODE_DEVICE_CONFIG_PAGE    configBuffer;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        switch (extension->DriveID) {
            case EXABYTE_8505:
            case EXABYTE_8500C:
            case IBM_8505:
                break;

            default:
                DebugPrint((1,"TapeSetDriveParameters: operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE))) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        configBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        configBuffer = Srb->DataBuffer;

        configBuffer->ParameterListHeader.ModeDataLength = 0;
        configBuffer->ParameterListHeader.MediumType = 0;
        configBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        configBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        if (tapeSetDriveParams->ReportSetmarks) {
            configBuffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            configBuffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DATA_COMPRESS_PAGE))) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 3) {

        compressionBuffer = Srb->DataBuffer;

        if (!compressionBuffer->DataCompressPage.DCC) {
            return TAPE_STATUS_SUCCESS;
        }

        compressionBuffer->ParameterListHeader.ModeDataLength = 0;
        compressionBuffer->ParameterListHeader.MediumType = 0;
        compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        compressionBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        compressionBuffer->DataCompressPage.PageCode = MODE_PAGE_DATA_COMPRESS;
        compressionBuffer->DataCompressPage.PageLength = 0x0E;

        if (tapeSetDriveParams->Compression) {
            compressionBuffer->DataCompressPage.DCE = SETBITON;
        } else {
            compressionBuffer->DataCompressPage.DCE = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 4);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
            MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.DensityCode = 0x7F;
        modeBuffer->ParameterListBlock.BlockLength[0] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
            (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 2);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_POSITION          tapeSetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    ULONG                       tapePositionVector;
    ULONG                       method;
    PEXB_SENSE_DATA             senseData;
    ULONG                       remaining;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                case TAPE_ABSOLUTE_BLOCK:
                case TAPE_LOGICAL_BLOCK:
                    DebugPrint((3,"TapeSetPosition: immediate\n"));
                    break;

                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SETMARKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:
                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        method = tapeSetPosition->Method;
        tapePositionVector = tapeSetPosition->Offset.LowPart;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (method) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 250;
                break;

            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute/logical)\n"));

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)(tapePositionVector & 0xFF);

                Srb->TimeOutValue = 600;
                break;

            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute/logical)\n"));

                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)(tapePositionVector & 0xFF);

                if (tapeSetPosition->Partition != 0) {

                    //
                    // Specified non-default partition.
                    //

                    if (tapeSetPosition->Partition != (extension->CurrentPartition + 1)) {

                        DebugPrint((1,
                                    "SetPosition: Setting partition (tape relative) %x\n",
                                    tapeSetPosition->Partition - 1));
                        //
                        // Need to change to the new partition.
                        //

                        cdb->LOCATE.Partition = (UCHAR)(tapeSetPosition->Partition - 1);
                        cdb->LOCATE.CPBit = 1;
                    }
                }

                Srb->TimeOutValue = 600;
                break;

            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 300;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_SEQUENTIAL_FMKS:
            case TAPE_SPACE_SETMARKS:
            case TAPE_SPACE_SEQUENTIAL_SMKS:
            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if ( CallNumber == 1 ) {

        if (tapeSetPosition->Method == TAPE_LOGICAL_BLOCK) {
            if (tapeSetPosition->Partition > 0) {
               extension->CurrentPartition = tapeSetPosition->Partition - 1;
            }
            
            DebugPrint((1,
                        "SetPosition: CurrentPartition (tape relative) %x\n",
                        extension->CurrentPartition));
        }

        if (tapeSetPosition->Method == TAPE_REWIND ) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
                DebugPrint((1,"GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS ;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6INQUIRY.AllocationLength = sizeof(EXB_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        } else {

            return TAPE_STATUS_CALLBACK ;
        }
    }

    ASSERT(CallNumber == 2 );

    if ( LastError == TAPE_STATUS_SUCCESS ) {

        senseData = Srb->DataBuffer ;

        remaining =  (senseData->Remaining[0] << 16);
        remaining += (senseData->Remaining[1] << 8);
        remaining += (senseData->Remaining[2]);

        extension->Capacity = remaining ;
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SHORT_FILEMARKS:
                case TAPE_LONG_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SHORT_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == short filemarks\n"));
                cdb->WRITE_TAPE_MARKS.Control = 0x80;
                break;

            case TAPE_LONG_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == long filemarks\n"));
                break;

            case TAPE_SETMARKS:
            case TAPE_FILEMARKS:
            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
       if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {

                DebugPrint((1,
                            "4mmDAT.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS));
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS) - 1;

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)Srb->DataTransferLength;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    }


    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {


        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;
        PMODE_DEVICE_CONFIG_PAGE_PLUS configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;
        mediaTypes->MediaInfoCount = 1;


        if ( LastError == TAPE_STATUS_SUCCESS ) {

            //
            // Determine the media type currently loaded.
            //

            mediaType = configInformation->ParameterListHeader.MediumType;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                        mediaType,
                        blockSize));

            switch (mediaType) {
                case 0:

                    //
                    // Cleaner, unknown, no media mounted...
                    //

                    currentMedia = 0;
                    break;

                case 0x81:
                case 0x82:
                case 0x83:
                case 0x84:
                case 0x85:
                case 0x86:
                case 0xC1:
                case 0xC2:
                case 0xC3:
                case 0xC4:

                    //
                    // 15-160m non-AME
                    //

                    mediaTypes->MediaInfoCount = 1;
                    currentMedia = MP_8mm;
                    break;

                default:

                    //
                    // Unknown
                    //

                    mediaTypes->MediaInfoCount = 1;
                    currentMedia = 0;
                    break;
            }
        } else {
            currentMedia = 0;
        }

        for (i = 0; i < mediaTypes->MediaInfoCount; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = ExaMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (ExaMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;

                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    configInformation->ParameterListBlock.DensityCode;

                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }

    }

    return TAPE_STATUS_SUCCESS;
}


static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"EXABYTE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-8500",8) == 8) {
            return EXABYTE_8500;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB8500C",8) == 8) {
            return EXABYTE_8500C;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-8505",8) == 8) {
            return EXABYTE_8505;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"IBM-8505",8) == 8) {
            return IBM_8505;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-8205",8) == 8) {
            return EXABYTE_8500;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\ltotape\ltotape.h ===
/*++

Copyright (c) Microsoft 2000

Module Name:

    ltotape.c

Abstract:

    This module contains device specific routines for LTO drives.

Environment:

    kernel mode only

Revision History:


--*/
#ifndef _LTOTAPE_H
#define _LTOTAPE_H

#ifndef INLINE
#define INLINE __inline
#endif

//
// Number of media types supported
//
#define LTO_SUPPORTED_TYPES 2

//
// Log sense page codes
//
#define LOGSENSEPAGE0                        0x00
#define LOGSENSEPAGE2                        0x02
#define LOGSENSEPAGE3                        0x03
#define LTO_LOGSENSE_TAPE_CAPACITY           0x31

//
// Error counter upper limits
//
#define TAPE_READ_ERROR_LIMIT        0x8000
#define TAPE_WRITE_ERROR_LIMIT       0x8000

#define TAPE_READ_WARNING_LIMIT      0x4000
#define TAPE_WRITE_WARNING_LIMIT     0x4000

//
// Defines for type of parameter
//
#define TotalCorrectedErrors            0x0003
#define TotalTimesAlgorithmProcessed    0x0004
#define TotalGroupsProcessed            0x0005
#define TotalUncorrectedErrors          0x0006

//
// ASC and ASCQ unique to LTO drives
//
// Additional Sense Codes (ASC)
// 
#define LTO_ADSENSE_VENDOR_UNIQUE  0x82

//
// Additional Sense Code Qualifiers (ASCQ)
//
#define LTO_ASCQ_CLEANING_REQUIRED 0x82

//
// Logpage Paramcodes
//
#define LTO_TAPE_REMAINING_CAPACITY 0x01
#define LTO_TAPE_MAXIMUM_CAPACITY   0x03

//
// Tape capacity log information
//
typedef struct _LTO_TAPE_CAPACITY {
    ULONG RemainingCapacity;
    ULONG MaximumCapacity;
} LTO_TAPE_CAPACITY, *PLTO_TAPE_CAPACITY;

//
// Tape Alert Info format
//
typedef struct _TAPE_ALERT_INFO {
    UCHAR  ParamCodeUB; // Upper byte of the param code
    UCHAR  ParamCodeLB; // Lower byte of the param code
    UCHAR  BitFields;
    UCHAR  ParamLen;
    UCHAR  Flag;
} TAPE_ALERT_INFO, *PTAPE_ALERT_INFO;

//
// Minitape extension definition.
//
typedef struct _MINITAPE_EXTENSION {
    ULONG DriveID;
    ULONG Capacity;
    BOOLEAN CompressionOn;
} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION ;

//
// Command extension definition.
//
typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

//
// LTO Sense data 
//
typedef struct _LTO_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FRUCode;
    UCHAR SenseKeySpecific;
    UCHAR FieldPointer[2];
    UCHAR Reserved2[3];
    UCHAR Reserved3:3;
    UCHAR CLN:1;
    UCHAR Reserved4:4;
} LTO_SENSE_DATA, *PLTO_SENSE_DATA;

//
// Log Sense Page Header
//
typedef struct _LOG_SENSE_PAGE_HEADER {
    UCHAR PageCode:6;
    UCHAR Reserved1:2;
    UCHAR Reserverd2;
    UCHAR Length[2];
} LOG_SENSE_PAGE_HEADER, *PLOG_SENSE_PAGE_HEADER;

//
// Log Sense Parameter Header
//
typedef struct _LOG_SENSE_PARAMETER_HEADER {
    UCHAR ParameterCode[2];    // [0]=MSB ... [1]=LSB
    UCHAR LPBit     : 1;
    UCHAR Reserved1 : 1;
    UCHAR TMCBit    : 2;
    UCHAR ETCBit    : 1;
    UCHAR TSDBit    : 1;
    UCHAR DSBit     : 1;
    UCHAR DUBit     : 1;
    UCHAR ParameterLength;
} LOG_SENSE_PARAMETER_HEADER, *PLOG_SENSE_PARAMETER_HEADER;

//
// Log Sense Page Information
//
typedef struct _LOG_SENSE_PAGE_INFORMATION {
    union {

        struct {
            UCHAR Page00;
            UCHAR Page02;
            UCHAR Page03;
            UCHAR Page0C;
            UCHAR Page2E;
            UCHAR Page30;
            UCHAR Page31;
            UCHAR Page32;
            UCHAR Page3A;
        } PageData;

        struct {
            LOG_SENSE_PARAMETER_HEADER Param1;
            UCHAR RemainingCapacity[4];
            LOG_SENSE_PARAMETER_HEADER Param2;
            UCHAR Param2Reserved[4];
            LOG_SENSE_PARAMETER_HEADER Param3;
            UCHAR MaximumCapacity[4];
            LOG_SENSE_PARAMETER_HEADER Param4;
            UCHAR Param4Reserved[4];
        } LogSenseTapeCapacity;

       struct {
           LOG_SENSE_PARAMETER_HEADER Parm1;
           UCHAR ErrorsCorrectedWithDelay[4];
           LOG_SENSE_PARAMETER_HEADER Parm2;
           UCHAR ErrorsCorrectedWithLesserDelay[4];
           LOG_SENSE_PARAMETER_HEADER Parm3;
           UCHAR TotalNumberofErrors[4];
           LOG_SENSE_PARAMETER_HEADER Parm4;
           UCHAR TotalErrorsCorrected[4];
           LOG_SENSE_PARAMETER_HEADER Parm5;
           UCHAR TotalTimesAlgoProcessed[4];
           LOG_SENSE_PARAMETER_HEADER Parm6;
           UCHAR TotalGroupsWritten[4];
           LOG_SENSE_PARAMETER_HEADER Parm7;
           UCHAR TotalErrorsUncorrected[4];
       } Page2 ;

       struct {
           LOG_SENSE_PARAMETER_HEADER Parm1;
           UCHAR ErrorsCorrectedWithDelay[4];
           LOG_SENSE_PARAMETER_HEADER Parm2;
           UCHAR ErrorsCorrectedWithLesserDelay[4];
           LOG_SENSE_PARAMETER_HEADER Parm3;
           UCHAR TotalNumberofErrors[4];
           LOG_SENSE_PARAMETER_HEADER Parm4;
           UCHAR TotalErrorsCorrected[4];
           LOG_SENSE_PARAMETER_HEADER Parm5;
           UCHAR TotalTimesAlgoProcessed[4];
           LOG_SENSE_PARAMETER_HEADER Parm6;
           UCHAR TotalGroupsWritten[4];
           LOG_SENSE_PARAMETER_HEADER Parm7;
           UCHAR TotalErrorsUncorrected[4];
       } Page3 ;
    } LogSensePage;

} LOG_SENSE_PAGE_INFORMATION, *PLOG_SENSE_PAGE_INFORMATION;

//
// Log Sense Page format
//
typedef struct _LOG_SENSE_PAGE_FORMAT {
    LOG_SENSE_PAGE_HEADER LogSenseHeader;
    LOG_SENSE_PAGE_INFORMATION LogSensePageInfo;
} LOG_SENSE_PAGE_FORMAT, *PLOG_SENSE_PAGE_FORMAT;

//
//  Function Prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);


BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );

TAPE_STATUS
INLINE 
PrepareSrbForTapeCapacityInfo(
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN 
ProcessTapeCapacityInfo(
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PLTO_TAPE_CAPACITY LtoTapaCapacity
    );

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

//
// Internal routines for wmi
//

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
  );

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   );

TAPE_STATUS
PrepareSrbForTapeAlertInfo(
    PSCSI_REQUEST_BLOCK Srb
    );

LONG
GetNumberOfBytesReturned(
    PSCSI_REQUEST_BLOCK Srb
    );

#endif // _LTOTAPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\mammoth\mammoth.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    mammoth.h

Abstract:

    This file contains structures and defines that are used
    specifically for the tape drivers.

Revision History:

--*/

#ifndef _MAMMOTH_H
#define _MAMMOTH_H


//
//  Internal (module wide) defines that symbolize
//  the 8mm drives supported by this module.
//

#define EXABYTE_8900    0x01

//
// Define EXABYTE vendor unique mode select/sense information.
//

#define EXABYTE_MODE_LENGTH          0x11
#define EXABYTE_CARTRIDGE            0x80
#define EXABYTE_NO_DATA_DISCONNECT   0x20
#define EXABYTE_NO_BUSY_ENABLE       0x08
#define EXABYTE_EVEN_BYTE_DISCONNECT 0x04
#define EXABYTE_PARITY_ENABLE        0x02
#define EXABYTE_NO_AUTO_LOAD         0X01

//
// Internal Exabyte defines.
//

#define MEDIUM_PARTITION_PAGE_SIZE 0x94

#define MAMMOTH_SUPPORTED_TYPES    0x03

#define MAMMOTH_CLEANING_REQUEST 0x17

//
//  Function prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);

//
// Minitape extension definition.
//

typedef struct _MINITAPE_EXTENSION {

    ULONG   DriveID;
    ULONG   Capacity;
    ULONG   CurrentPartition;

} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION;

//
// Command extension definition.
//

typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

//
// Request structure used to determine cleaning needs, and remaining tape
// capacity.
//

typedef struct _EXB_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Reserved2;
    UCHAR SenseKeySpecific[3];
    UCHAR Reserved3;
    UCHAR UnitSense[3];
    UCHAR Reserved4;
    UCHAR Remaining[3];
    UCHAR RetryCounters[2];
    UCHAR FSC;
    UCHAR Reserved5[3];
} EXB_SENSE_DATA, *PEXB_SENSE_DATA;

//
// Bit definitions for UnitSense
//


#define EXB_DRIVE_NEEDS_CLEANING 0x08
#define EXB_DRIVE_CLEANED        0x10

//
// Error counter upper limits
//
#define TAPE_READ_ERROR_LIMIT        0x8000
#define TAPE_WRITE_ERROR_LIMIT       0x8000

#define TAPE_READ_WARNING_LIMIT      0x4000
#define TAPE_WRITE_WARNING_LIMIT     0x4000

//
// Defines for type of parameter
//
#define TotalCorrectedErrors            0x0003
#define TotalTimesAlgorithmProcessed    0x0004
#define TotalGroupsProcessed            0x0005
#define TotalUncorrectedErrors          0x0006

//
// Defines for Log Sense Pages
//

#define LOGSENSEPAGE0                        0x00
#define LOGSENSEPAGE2                        0x02
#define LOGSENSEPAGE3                        0x03

//
// Defined Log Sense Page Header
//

typedef struct _LOG_SENSE_PAGE_HEADER {

   UCHAR PageCode : 6;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR Length[2];           // [0]=MSB ... [1]=LSB

} LOG_SENSE_PAGE_HEADER, *PLOG_SENSE_PAGE_HEADER;


//
// Defined Log Sense Parameter Header
//

typedef struct _LOG_SENSE_PARAMETER_HEADER {

   UCHAR ParameterCode[2];    // [0]=MSB ... [1]=LSB
   UCHAR LPBit     : 1;
   UCHAR Reserved1 : 1;
   UCHAR TMCBit    : 2;
   UCHAR ETCBit    : 1;
   UCHAR TSDBit    : 1;
   UCHAR DSBit     : 1;
   UCHAR DUBit     : 1;
   UCHAR ParameterLength;

} LOG_SENSE_PARAMETER_HEADER, *PLOG_SENSE_PARAMETER_HEADER;


//
// Defined Log Page Information - statistical values, accounts
// for maximum parameter values that is returned for each page
//

typedef struct _LOG_SENSE_PAGE_INFORMATION {

   union {

       struct {
          UCHAR Page0;
          UCHAR Page2;
          UCHAR Page3;
       } PageData ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR TotalNumberOfErrors[3];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR TotalErrorsCorrected[3];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR TotalTimesAlgoProcessed[3];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR TotalGroupsWritten[5];
          LOG_SENSE_PARAMETER_HEADER Parm5;
          UCHAR TotalErrorsUncorrected[2];
       } Page2 ;

       struct {
           LOG_SENSE_PARAMETER_HEADER Parm1;
           UCHAR TotalNumberOfErrors[3];
           LOG_SENSE_PARAMETER_HEADER Parm2;
           UCHAR TotalErrorsCorrected[3];
           LOG_SENSE_PARAMETER_HEADER Parm3;
           UCHAR TotalTimesAlgoProcessed[3];
           LOG_SENSE_PARAMETER_HEADER Parm4;
           UCHAR TotalGroupsWritten[5];
           LOG_SENSE_PARAMETER_HEADER Parm5;
           UCHAR TotalErrorsUncorrected[2];
       } Page3 ;
   } LogSensePage;

} LOG_SENSE_PAGE_INFORMATION, *PLOG_SENSE_PAGE_INFORMATION;



//
// Defined Log Sense Parameter Format - statistical values, accounts
// for maximum parameter values that is returned
//

typedef struct _LOG_SENSE_PARAMETER_FORMAT {

   LOG_SENSE_PAGE_HEADER       LogSenseHeader;
   LOG_SENSE_PAGE_INFORMATION  LogSensePageInfo;

} LOG_SENSE_PARAMETER_FORMAT, *PLOG_SENSE_PARAMETER_FORMAT;

//
// Tape Alert Info format
//
typedef struct _TAPE_ALERT_INFO {
    UCHAR  ParamCodeUB; // Upper byte of the param code
    UCHAR  ParamCodeLB; // Lower byte of the param code
    UCHAR  BitFields;
    UCHAR  ParamLen;
    UCHAR  Flag;
} TAPE_ALERT_INFO, *PTAPE_ALERT_INFO;

BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

//
// Internal routines for wmi
//

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
  );

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   );

TAPE_STATUS
PrepareSrbForTapeAlertInfo(
    PSCSI_REQUEST_BLOCK Srb
    );

LONG
GetNumberOfBytesReturned(
    PSCSI_REQUEST_BLOCK Srb
    );

#endif // _MAMMOTH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\mammoth\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for mammoth drives.

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"
#include "mammoth.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TapeWMIControl)
#pragma alloc_text(PAGE, GetNumberOfBytesReturned)
#pragma alloc_text(PAGE, PrepareSrbForTapeAlertInfo)
#pragma alloc_text(PAGE, ProcessReadWriteErrors)
#pragma alloc_text(PAGE, QueryDeviceErrorData)
#pragma alloc_text(PAGE, QueryIoErrorData)
#pragma alloc_text(PAGE, VerifyReadWriteErrors)
#endif

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )
/*+
Routine Description:

   This is the common entry point for all WMI calls from tape class driver.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;

   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;

   switch (wmiOperations->Method) {
      case TAPE_CHECK_FOR_DRIVE_PROBLEM: {
         return QueryDeviceErrorData(MinitapeExtension, 
                                     CommandExtension,
                                     CommandParameters, 
                                     Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_IO_ERROR_DATA: {
         return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                 CommandParameters, Srb, CallNumber,
                                 LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_DEVICE_ERROR_DATA: {
         return QueryDeviceErrorData(MinitapeExtension, CommandExtension,
                                     CommandParameters, Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      default: {
         return TAPE_STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   } // switch (wmiOperations->Method) 
}

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns IO Error data such as read\write errors.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;

   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   IoErrorData = (PWMI_TAPE_PROBLEM_IO_ERROR)&(wmiData->TapeData);

   if (CallNumber == 0) {
      if (!TapeClassAllocateSrbBuffer(Srb, 
                                      sizeof(LOG_SENSE_PARAMETER_FORMAT))) {
         DebugPrint((1, "QueryIoErrorData : No memory for log sense info\n"));
         return TAPE_STATUS_INSUFFICIENT_RESOURCES;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(IoErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_IO_ERROR));
      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE2;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 1) {
      ProcessReadWriteErrors(Srb, FALSE, IoErrorData);

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE3;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 2) {
      ProcessReadWriteErrors(Srb, TRUE, IoErrorData);
      
      wmiData->DriveProblemType = VerifyReadWriteErrors(IoErrorData);
   }

   return TAPE_STATUS_SUCCESS;
}

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
)
/*+
Routine Description :

   This routine processes the buffer containing read\write counters,
   and sets the appropriate fields in WMI_TAPE_PROBLEM_IO_ERROR 
   buffer.
   
Arguments :

 Srb            SCSI Request Block
 Read           TRUE if we are to process read counters. FALSE if it is 
                Write counters
 IoErrorData    Buffer in which to return counter values.
 
Return Value :

  None  
-*/
{
   USHORT paramCode;
   UCHAR  paramLen;
   LONG  bytesLeft;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PLOG_SENSE_PARAMETER_HEADER logSenseParamHeader;
   PUCHAR  paramValue = NULL;
   ULONG transferLength;

   logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
   
   ASSERT(((logSenseHeader->PageCode) == LOGSENSEPAGE2) ||
          ((logSenseHeader->PageCode) == LOGSENSEPAGE3));
   bytesLeft = logSenseHeader->Length[0];
   bytesLeft <<= 8;
   bytesLeft += logSenseHeader->Length[1];

   transferLength = Srb->DataTransferLength;

   if (bytesLeft > (LONG)(transferLength -
                          sizeof(LOG_SENSE_PAGE_HEADER))) {
       bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
   }

   DebugPrint((3, "ProcessReadWriteErrors : BytesLeft %x, TransferLength %x\n",
               bytesLeft, transferLength));
   (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseHeader + sizeof(LOG_SENSE_PAGE_HEADER);
   while (bytesLeft >= sizeof(LOG_SENSE_PARAMETER_HEADER)) {
      paramCode = logSenseParamHeader->ParameterCode[0];
      paramCode <<= 8;
      paramCode |= logSenseParamHeader->ParameterCode[1];
      paramLen = logSenseParamHeader->ParameterLength;
      paramValue = (PUCHAR)logSenseParamHeader + sizeof(LOG_SENSE_PARAMETER_HEADER);

      //
      // Make sure we have at least
      // (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen) bytes left.
      // Otherwise, we've reached the end of the buffer.
      //
      if (bytesLeft < (LONG)(sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)) {
          DebugPrint((1,
                      "mammoth : Reached end of buffer. BytesLeft %x, Expected %x\n",
                      bytesLeft,
                      (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)));
          break;
      }

      switch (paramCode) {
         case TotalCorrectedErrors: {
            ULONG value;
            ULONG tmpVal;

            value = (UCHAR)*(paramValue);
            value <<= 16;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+2);
            DebugPrint((3, "ProcessReadWrite: TotalCorrectedErrors %x\n",
                        value));
            if (Read) {
               IoErrorData->ReadTotalCorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalCorrectedErrors = value;
            }
            break;
         }

         case TotalUncorrectedErrors: {
            USHORT value;

            value = (UCHAR)*(paramValue);
            value <<= 8;
            value += (UCHAR)*(paramValue+1);
            DebugPrint((3, "ProcessReadWrite: TotalUncorrectedErrors %x\n",
                        value));
            if (Read) {
               IoErrorData->ReadTotalUncorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalUncorrectedErrors = value;
            }

            break;
         }

         case TotalTimesAlgorithmProcessed: {
            ULONG value;
            ULONG tmpVal;

            value = (UCHAR)*(paramValue);
            value <<= 16;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+2);
            DebugPrint((3, "ProcessReadWrite: TotalTimesAlgorithmProcessed %x\n",
                        value));
            if (Read) {
               IoErrorData->ReadCorrectionAlgorithmProcessed = value;
            } else {
               IoErrorData->WriteCorrectionAlgorithmProcessed = value;
            }
            break;
         }

         default: {
            break;
         }
      } // switch (paramCode) 

      (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseParamHeader + 
                                    sizeof(LOG_SENSE_PARAMETER_HEADER) +
                                    paramLen;

      bytesLeft -= paramLen + sizeof(LOG_SENSE_PARAMETER_HEADER);
   } // while (bytesLeft > 0)

   if (Read) {
      IoErrorData->ReadTotalErrors = IoErrorData->ReadTotalUncorrectedErrors +
                                     IoErrorData->ReadTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: ReadErrors %x\n",
                  IoErrorData->ReadTotalErrors));
   } else {
      IoErrorData->WriteTotalErrors = IoErrorData->WriteTotalUncorrectedErrors +
                                      IoErrorData->WriteTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: WriteErrors %x\n",
                  IoErrorData->WriteTotalErrors));
   }
}

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   )
/*+

Routine Description :

   This routine looks at the read\write error counters.
   If the values are above a certain threshold, it returns
   appropriate error value.
   
Argument :

  IoErrorData  WMI_TAPE_PROBLEM_IO_ERROR struct
  
Return Value :
   
      TapeDriveReadWriteError If there are too many uncorrected 
                              read\write errors
                         
      TapeDriveReadWriteWarning If there are too many corrected
                                read\write errors 
                                
      TapeDriveProblemNone    If the read\write errors are below
                              threshold   
  
-*/
{
   if (((IoErrorData->ReadTotalUncorrectedErrors) >=
         TAPE_READ_ERROR_LIMIT)   ||       
       ((IoErrorData->WriteTotalUncorrectedErrors) >=
         TAPE_WRITE_ERROR_LIMIT)) {
      return TapeDriveReadWriteError;
   }

   if (((IoErrorData->ReadTotalCorrectedErrors) >=
         TAPE_READ_WARNING_LIMIT) ||
       ((IoErrorData->WriteTotalCorrectedErrors) >=
         TAPE_WRITE_WARNING_LIMIT)) {

      return TapeDriveReadWriteWarning;
   }

   return TapeDriveProblemNone;
}

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns device Error data such as "drive calibration"
   error, etc.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;
   PWMI_TAPE_PROBLEM_DEVICE_ERROR DeviceErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PCDB cdb = (PCDB)Srb->Cdb;
   
   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   DeviceErrorData = (PWMI_TAPE_PROBLEM_DEVICE_ERROR)wmiData->TapeData;

   if (CallNumber == 0) {

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(DeviceErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_DEVICE_ERROR));
   
      return PrepareSrbForTapeAlertInfo(Srb);
   }

   if (CallNumber == 1) {
       PTAPE_ALERT_INFO tapeAlertInfo;
       LONG  bytesLeft;
       UCHAR paramCode;
       UCHAR flagValue;

       bytesLeft = GetNumberOfBytesReturned(Srb);

       logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
       tapeAlertInfo= (PTAPE_ALERT_INFO)((PUCHAR)logSenseHeader +
                                         sizeof(LOG_SENSE_PAGE_HEADER));
         
       while (bytesLeft >= sizeof(TAPE_ALERT_INFO)) {
           //
           // ParamCode is 2 bytes long. Upper Byte is 0.
           // Lower Byte goes from 0x01 to 0x40. So, we just
           // pick up the lower byte
           //
           paramCode = tapeAlertInfo->ParamCodeLB;
           flagValue = tapeAlertInfo->Flag;
           ASSERT((tapeAlertInfo->ParamLen) == 1);
           DebugPrint((3, "QDED: ParamCode %x, FlagValue %x, ParamLen %x\n",
                       paramCode, flagValue, tapeAlertInfo->ParamLen));
           switch (paramCode) {
               case READ_WARNING: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : READ_WARNING\n"));
                     DeviceErrorData->ReadWarning = TRUE;
                     wmiData->DriveProblemType = TapeDriveReadWarning;
                  }
   
                  break;
               }
   
               case WRITE_WARNING: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : WRITE_WARNING\n"));
                     DeviceErrorData->WriteWarning = TRUE;
                     wmiData->DriveProblemType = TapeDriveWriteWarning;
                  }
   
                  break;
               }
   
               case HARD_ERROR: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : HARD_ERROR\n"));
                     DeviceErrorData->HardError = TRUE;
                     wmiData->DriveProblemType = TapeDriveHardwareError;
                  }
                  break;
               }
   
               case READ_FAILURE: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : READ_FAILURE\n"));
                     DeviceErrorData->ReadFailure = TRUE;
                     wmiData->DriveProblemType = TapeDriveReadError;
                  }
                  break;
               }
   
               case WRITE_FAILURE: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : WRITE_FAILURE\n"));
                     DeviceErrorData->WriteFailure = TRUE;
                     wmiData->DriveProblemType = TapeDriveWriteError;
                  }
                  break;
               }
   
               case MEDIA_LIFE: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : MEDIA_LIFE\n"));
                     DeviceErrorData->MediaLife = TRUE;
                     wmiData->DriveProblemType = TapeDriveMediaLifeExpired;
                  }
                  break;
               }
   
               case UNSUPPORTED_FORMAT: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : UNSUPPORTED_FORMAT\n"));
                     DeviceErrorData->UnsupportedFormat = TRUE;
                     wmiData->DriveProblemType = TapeDriveUnsupportedMedia;
                  }
                  break;
               }
   
               case SNAPPED_TAPE: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : SNAPPED_TAPE\n"));
                     DeviceErrorData->TapeSnapped = TRUE;
                     wmiData->DriveProblemType = TapeDriveSnappedTape;
                  }
                  break;
               }
   
               case CLEAN_NOW: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : CLEAN_NOW\n"));
                     DeviceErrorData->DriveRequiresCleaning = TRUE;
                     wmiData->DriveProblemType = TapeDriveCleanDriveNow;
                  }
                  break;
               }
   
               case CLEAN_PERIODIC: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : CLEAN_PERIODIC\n"));
                     DeviceErrorData->TimetoCleanDrive = TRUE;
                     wmiData->DriveProblemType = TapeDriveTimetoClean;
                  }
                  break;
               }
   
               case HARDWARE_A: case HARDWARE_B: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : HARDWARE_A\\B\n"));
                     DeviceErrorData->DriveHardwareError = TRUE;
                     wmiData->DriveProblemType = TapeDriveHardwareError;
                  }
                  break;
               }
   
               case INTERFACE_ERROR: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : INTERFACE_ERROR\n"));
                     DeviceErrorData->ScsiInterfaceError = TRUE;
                     wmiData->DriveProblemType = TapeDriveScsiConnectionError;
                  }
                  break;
               }
   
               default:
                  break;
            } // switch (paramCode) {

            tapeAlertInfo++;
            bytesLeft -= sizeof(TAPE_ALERT_INFO);   
         }

         DebugPrint((3, "QueryDeviceErrorData : DriveProblemType %x\n",
                     wmiData->DriveProblemType));
   }

   return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
PrepareSrbForTapeAlertInfo(
    PSCSI_REQUEST_BLOCK Srb
    )
/*+++

Routine Description:

        This routine sets the SCSI_REQUEST_BLOCK to retrieve
        Tape Alert information from the drive

Arguements:

        Srb - Pointer to the SCSI_REQUEST_BLOCK

Return Value:

        TAPE_STATUS_SEND_SRB_AND_CALLBACK if Srb fields were successfully set.

        TAPE_STATUS_SUCCESS if there was not enough memory for Srb Databuffer.
                            case is not treated as an error.
--*/
{
    PCDB cdb = (PCDB)Srb->Cdb;
    ULONG allocLength;

    allocLength = sizeof(LOG_SENSE_PAGE_HEADER) +
                   (sizeof(TAPE_ALERT_INFO) * 0x40);
    DebugPrint((3, "PrepareSrbForTapeAlertInfo: AlertInfo allocLength %x\n",
                allocLength));
    if (!TapeClassAllocateSrbBuffer(Srb, allocLength)) {
       DebugPrint((1, "PrepareSrbForTapeAlertInfo : No memory for log sense info\n"));
       return TAPE_STATUS_INSUFFICIENT_RESOURCES;
    }

    TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //
    Srb->CdbLength = CDB10GENERIC_LENGTH;

    cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
    cdb->LOGSENSE.PageCode = TapeAlertLogPage;
    cdb->LOGSENSE.PCBit = 1;
    cdb->LOGSENSE.AllocationLength[0] = (UCHAR)((allocLength & 0xFF00) >> 8);
    cdb->LOGSENSE.AllocationLength[1] = (UCHAR)(allocLength & 0xFF);

    Srb->DataTransferLength = allocLength;
    return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
}

LONG
GetNumberOfBytesReturned(
    PSCSI_REQUEST_BLOCK Srb
    )
{
    PLOG_SENSE_PAGE_HEADER logSenseHeader;
    ULONG transferLength;
    LONG  bytesLeft;

    logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
    ASSERT((logSenseHeader->PageCode) == TapeAlertLogPage);
    bytesLeft = logSenseHeader->Length[0];
    bytesLeft <<= 8;
    bytesLeft += logSenseHeader->Length[1];

    transferLength = Srb->DataTransferLength;

    if (bytesLeft > (LONG)(transferLength -
                           sizeof(LOG_SENSE_PAGE_HEADER))) {
        bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
    }

    DebugPrint((3, 
                "GetNumberOfBytesReturned : BytesLeft %x, TransferLength %x\n",
                bytesLeft, transferLength));

    return bytesLeft;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\mammoth\mammoth.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mammoth.c

Abstract:

    This module contains the device-specific routines for the Exabyte
    EXB-8900 tape drive - aka mammoth

Author:


Environment:

    kernel mode only

Revision History:


--*/

#include "minitape.h"
#include "mammoth.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

STORAGE_MEDIA_TYPE MammothMedia[MAMMOTH_SUPPORTED_TYPES] = {MP_8mm, AME_8mm, CLEANER_CARTRIDGE};


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = TapeError;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = MAMMOTH_SUPPORTED_TYPES;

    tapeInitData.TapeWMIOperations = TapeWMIControl;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData);
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.
    CommandExtension    - Supplies the ioctl extension.
    CommandParameters   - Supplies the command parameters.
    Srb                 - Supplies the SCSI request block.
    CallNumber          - Supplies the call number.
    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION          tapeExtension = MinitapeExtension;
    PTAPE_CREATE_PARTITION       tapeCreatePartition = CommandParameters;
    PMODE_PARAMETER_HEADER       parameterListHeader;
    PMODE_PARAMETER_BLOCK        parameterListBlock;
    PMODE_MEDIUM_PARTITION_PAGE  mediumPartPage;
    PMODE_TAPE_MEDIA_INFORMATION mediaInformation;
    ULONG                        partitionMethod;
    ULONG                        partitionCount;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));

    if (CallNumber == 0) {

       if ((tapeCreatePartition->Method) == 
           TAPE_INITIATOR_PARTITIONS) {

          //
          // Prepare SCSI command (CDB)
          //
   
          Srb->CdbLength = CDB6GENERIC_LENGTH;
   
          TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
   
          cdb->CDB6GENERIC.Immediate = FALSE;
   
          cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
          Srb->TimeOutValue = 500;
          Srb->DataTransferLength = 0;
   
          return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
   
       } else {
          return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
       }

    }

    if (CallNumber == 1) {

        //
        // Build mode sense for the medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, MEDIUM_PARTITION_PAGE_SIZE)) {

            DebugPrint((1,
                        "Mammoth.TapeCreatePartition: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(Srb->DataBuffer, MEDIUM_PARTITION_PAGE_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = MEDIUM_PARTITION_PAGE_SIZE;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = MEDIUM_PARTITION_PAGE_SIZE;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if (CallNumber == 2) {

        //
        // Issued the mode sense of the partition page successfully.
        //

        mediaInformation = Srb->DataBuffer;

        //
        // Extract each of the sub-blocks from the mode sense info.
        //

        parameterListHeader = &mediaInformation->ParameterListHeader;
        parameterListBlock = &mediaInformation->ParameterListBlock;
        mediumPartPage = &mediaInformation->MediumPartPage;

        parameterListHeader->ModeDataLength = 0;
        parameterListHeader->MediumType = 0;

        //
        // Get the count and method.
        //

        partitionCount = tapeCreatePartition->Count;
        partitionMethod = tapeCreatePartition->Method;

        switch (partitionCount) {

        case 0:
        case 1:
        case 2:
            break;

            //
            // Currently only a max. of 2 partitions is allowed.
            //


        default:
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        switch (partitionMethod) {
        case TAPE_FIXED_PARTITIONS:

            //
            // The mammoth drives specify fixed as '1' partition encompassing the entire tape.
            // Verify that count == 1;
            //

            mediumPartPage->FDPBit = 1;
            break;

        case TAPE_SELECT_PARTITIONS:

            //
            // Mammoth drives specify that each 'select' partition is 50 MB in size (1st part. will be tape size
            // - (N-1)*50.
            // The drive will ignore the size in the Partition Size fields.
            //

            if (partitionCount > 2) {
                DebugPrint((1,
                            "Mammoth.TapeCreatePartitions: Method Select, Size invalid (%x)\n",
                            tapeCreatePartition->Size));

                return TAPE_STATUS_INVALID_DEVICE_REQUEST;
            }

            mediumPartPage->SDPBit = 1;
            mediumPartPage->PSUMBit = 2;
            mediumPartPage->AdditionalPartitionDefined = (UCHAR)(partitionCount - 1);
            break;

        case TAPE_INITIATOR_PARTITIONS:
            mediumPartPage->IDPBit = 1;
            mediumPartPage->PSUMBit = 2;
            if (partitionCount == 0) {
                mediumPartPage->AdditionalPartitionDefined = 0;
                mediumPartPage->Partition1Size[0] = 0;
                mediumPartPage->Partition1Size[1] = 0;
            } else {
                mediumPartPage->AdditionalPartitionDefined = (UCHAR)(partitionCount - 1);
                mediumPartPage->Partition1Size[0] = (UCHAR)((tapeCreatePartition->Size >> 8) & 0xFF);
                mediumPartPage->Partition1Size[1] = (UCHAR)(tapeCreatePartition->Size & 0xFF);
            }

            break;

        default:
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        Srb->CdbLength = CDB6GENERIC_LENGTH ;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = MEDIUM_PARTITION_PAGE_SIZE;

        Srb->TimeOutValue = 16500;
        Srb->DataTransferLength = MEDIUM_PARTITION_PAGE_SIZE;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3) {

        //
        // Build mode sense for the medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE))) {

            DebugPrint((1,
                        "Mammoth.TapeCreatePartition: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if (CallNumber == 4) {

        PMODE_DEVICE_CONFIG_PAGE deviceConfig = Srb->DataBuffer;
        PMODE_PARAMETER_HEADER       parameterListHeader = &deviceConfig->ParameterListHeader;
        PMODE_DEVICE_CONFIGURATION_PAGE  deviceConfigPage = &deviceConfig->DeviceConfigPage;

        tapeExtension->CurrentPartition = (deviceConfigPage->ActivePartition + 1);
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            switch (tapeErase->Type) {
                case TAPE_ERASE_LONG:
                    DebugPrint((3,"TapeErase: immediate, long\n"));
                    break;

                case TAPE_ERASE_SHORT:
                    DebugPrint((3,"TapeErase: immediate, short\n"));
                    break;

                default:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
                DebugPrint((3,"TapeErase: short\n"));
                break;
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }


        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = 0;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = (tapeErase->Type == TAPE_ERASE_LONG) ? SETBITON : 0;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 18000;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer;
    UCHAR              sensekey;
    UCHAR              adsenseq;
    UCHAR              adsense;

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       sensekey = senseBuffer->SenseKey & 0x0F;
       adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
       adsense = senseBuffer->AdditionalSenseCode;

       if (*LastError == TAPE_STATUS_IO_DEVICE_ERROR) {
           if ((sensekey == SCSI_SENSE_ABORTED_COMMAND) &&
               (adsense  == 0x5A) &&
               (adsenseq == 0x01)) {    //operator medium removal request
   
               *LastError = TAPE_STATUS_NO_MEDIA;
   
           }
       }
   
       if (sensekey == SCSI_SENSE_RECOVERED_ERROR) {
           if ((adsense == SCSI_ADSENSE_NO_SENSE) && 
               (adsenseq == MAMMOTH_CLEANING_REQUEST)) {
               *LastError = TAPE_STATUS_REQUIRES_CLEANING;
           }
       }
    }

    //
    // If the sense buffer is of the correct size, check the additional sense bytes for
    // cleaning request.
    //

    if (senseBuffer->AdditionalSenseLength >= 14) {
        UCHAR unitSense;

        unitSense = (((PUCHAR)senseBuffer)[21]);

        DebugPrint((1,
                   "TapeError: unitSense %x\n",
                   unitSense));

        if (unitSense & 0x08) {

            //
            // Drive is requesting cleaning.
            //

            *LastError = TAPE_STATUS_REQUIRES_CLEANING;
        }
    }

    DebugPrint((1,"TapeError: Status 0x%.8X \n", *LastError));

    return;

} // end TapeError()

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE_PLUS    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (modeParmBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        deviceConfigModeSenseBuffer = Srb->DataBuffer;

        tapeGetDriveParams->ReportSetmarks =
            (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk? 1 : 0 );

        commandExtension->CurrentState = 0;
    }

    if (commandExtension->CurrentState == 0) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DATA_COMPRESS_PAGE))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        commandExtension->CurrentState = 1;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (commandExtension->CurrentState == 1) {

        compressionModeSenseBuffer = Srb->DataBuffer;

        if (compressionModeSenseBuffer->DataCompressPage.DCC) {
            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
                (compressionModeSenseBuffer->DataCompressPage.DCE? TRUE : FALSE);
        }

        commandExtension->CurrentState = 2;
    }

    if (commandExtension->CurrentState == 2) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(READ_BLOCK_LIMITS_DATA))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimits)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        commandExtension->CurrentState = 3;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(commandExtension->CurrentState == 3);

    blockLimits = Srb->DataBuffer;

    tapeGetDriveParams->MaximumBlockSize =  blockLimits->BlockMaximumSize[2];
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

    tapeGetDriveParams->MinimumBlockSize =  blockLimits->BlockMinimumSize[1];
    tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);

    tapeGetDriveParams->ECC = 0;
    tapeGetDriveParams->DataPadding = 0;
    tapeGetDriveParams->MaximumPartitionCount = 2;
    tapeGetDriveParams->DefaultBlockSize = 1024;

    tapeGetDriveParams->FeaturesLow |=
        TAPE_DRIVE_FIXED            |
        TAPE_DRIVE_SELECT           |
        TAPE_DRIVE_INITIATOR        |
        TAPE_DRIVE_TAPE_CAPACITY    |
        TAPE_DRIVE_TAPE_REMAINING   |
        TAPE_DRIVE_ERASE_SHORT      |
        TAPE_DRIVE_ERASE_LONG       |
        TAPE_DRIVE_ERASE_BOP_ONLY   |
        TAPE_DRIVE_ERASE_IMMEDIATE  |
        TAPE_DRIVE_FIXED_BLOCK      |
        TAPE_DRIVE_VARIABLE_BLOCK   |
        TAPE_DRIVE_WRITE_PROTECT    |
        TAPE_DRIVE_GET_ABSOLUTE_BLK |
        TAPE_DRIVE_GET_LOGICAL_BLK  |
        TAPE_DRIVE_REPORT_SMKS      |
        TAPE_DRIVE_ECC              |
        TAPE_DRIVE_EJECT_MEDIA      |
        TAPE_DRIVE_CLEAN_REQUESTS;

    tapeGetDriveParams->FeaturesHigh |=
        TAPE_DRIVE_LOAD_UNLOAD       |
        TAPE_DRIVE_REWIND_IMMEDIATE  |
        TAPE_DRIVE_LOCK_UNLOCK       |
        TAPE_DRIVE_SET_BLOCK_SIZE    |
        TAPE_DRIVE_LOAD_UNLD_IMMED   |
        TAPE_DRIVE_SET_REPORT_SMKS   |
        TAPE_DRIVE_RELATIVE_BLKS     |
        TAPE_DRIVE_FILEMARKS         |
        TAPE_DRIVE_SETMARKS          |
        TAPE_DRIVE_REVERSE_POSITION  |
        TAPE_DRIVE_WRITE_SETMARKS    |
        TAPE_DRIVE_WRITE_FILEMARKS   |
        TAPE_DRIVE_WRITE_SHORT_FMKS  |
        TAPE_DRIVE_WRITE_LONG_FMKS   |
        TAPE_DRIVE_WRITE_MARK_IMMED  |
        TAPE_DRIVE_ABSOLUTE_BLK      |
        TAPE_DRIVE_ABS_BLK_IMMED     |
        TAPE_DRIVE_LOGICAL_BLK       |
        TAPE_DRIVE_LOG_BLK_IMMED     |
        TAPE_DRIVE_END_OF_DATA;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_TAPE_MEDIA_INFORMATION mediaInformation;
    PEXB_SENSE_DATA              senseData;
    ULONG                        remaining;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        //
        // Build mode sense for medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, MEDIUM_PARTITION_PAGE_SIZE)) {

            DebugPrint((1,
                        "Mammoth.TapeGetMediaParameters: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(Srb->DataBuffer, MEDIUM_PARTITION_PAGE_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = MEDIUM_PARTITION_PAGE_SIZE;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = MEDIUM_PARTITION_PAGE_SIZE;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        ULONG partitionCount;

        mediaInformation = Srb->DataBuffer;

        tapeGetMediaParams->BlockSize = mediaInformation->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (mediaInformation->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (mediaInformation->ParameterListBlock.BlockLength[0] << 16);

        tapeGetMediaParams->WriteProtected =
            ((mediaInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

        tapeGetMediaParams->Capacity.QuadPart = 0;
        tapeGetMediaParams->Remaining.QuadPart = 0;

        partitionCount = mediaInformation->MediumPartPage.AdditionalPartitionDefined;
        tapeGetMediaParams->PartitionCount = partitionCount + 1;

        //
        // Build a request sense to get remaining values.
        //

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
            DebugPrint((1,
                       "GetRemaining Size: insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(EXB_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

        Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if (CallNumber == 3) {
        if (LastError == TAPE_STATUS_SUCCESS) {

            senseData = Srb->DataBuffer;

            remaining =  (senseData->Remaining[0] << 16);
            remaining += (senseData->Remaining[1] << 8);
            remaining += (senseData->Remaining[2]);


            tapeGetMediaParams->Capacity.LowPart  = extension->Capacity;

            //
            // The drive gives the information in 16KB units.
            //

            tapeGetMediaParams->Capacity.QuadPart <<= 14;

            tapeGetMediaParams->Remaining.LowPart = remaining;
            tapeGetMediaParams->Remaining.QuadPart <<= 14;
        }
    }

    return TAPE_STATUS_SUCCESS;
}


TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         tapeExtension = MinitapeExtension;
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PTAPE_POSITION_DATA         positionBuffer;
    ULONG                       type;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;

        switch (type) {
            case TAPE_ABSOLUTE_POSITION:
            case TAPE_LOGICAL_POSITION:
                if (!TapeClassAllocateSrbBuffer(Srb, sizeof(TAPE_POSITION_DATA))) {
                    DebugPrint((1,"TapeGetPosition: insufficient resources (logicalBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                positionBuffer = Srb->DataBuffer;

                //
                // Zero CDB in SRB on stack.
                //

                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB10GENERIC_LENGTH;

                cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }
    }

    ASSERT(CallNumber == 1);

    positionBuffer = Srb->DataBuffer;

    if (positionBuffer->BlockPositionUnsupported) {
        DebugPrint((1,"TapeGetPosition: read position -- logical block position unsupported\n"));
        return TAPE_STATUS_INVALID_DEVICE_REQUEST;
    }

    tapeGetPosition->Partition = 0;
    if (tapeGetPosition->Type == TAPE_LOGICAL_POSITION) {
        tapeGetPosition->Partition = positionBuffer->PartitionNumber + 1;
        tapeExtension->CurrentPartition = positionBuffer->PartitionNumber + 1;
    }
    tapeGetPosition->Offset.HighPart = 0;
    REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                  (PFOUR_BYTE)positionBuffer->FirstBlock);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{

    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PCDB    cdb = (PCDB)Srb->Cdb;
    PEXB_SENSE_DATA senseData;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags |= RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        commandExtension->CurrentState = LastError;

        //
        // Issue a request sense to get the cleaning info bits.
        //

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA))) {
            DebugPrint((1,
                        "GetStatus: Insufficient resources (SenseData)\n"));
            return TAPE_STATUS_SUCCESS;
        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->ScsiStatus = Srb->SrbStatus = 0;
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(EXB_SENSE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
        *RetryFlags |= RETURN_ERRORS;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    } else if (CallNumber == 2) {
        if ((commandExtension->CurrentState == TAPE_STATUS_SUCCESS)  ||
            (commandExtension->CurrentState == TAPE_STATUS_NO_MEDIA)) {

            //
            // Return needs cleaning status if necessary, but only if
            // no other errors are present (with the exception of no media as the
            // drive will spit out AME media when in this state).
            //

            senseData = Srb->DataBuffer;

            //
            // Determine if the clean bit is set.
            //

            if (senseData->UnitSense[2] & EXB_DRIVE_NEEDS_CLEANING) {
                DebugPrint((1,
                           "Drive reports needs cleaning - UnitSense %x\n",
                           senseData->UnitSense[2]));

                return TAPE_STATUS_REQUIRES_CLEANING;
            } else {
               return (commandExtension->CurrentState);
            }
        } else {

            //
            // Return the saved error status.
            //

            return commandExtension->CurrentState;
        }
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_PREPARE               tapePrepare = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PEXB_SENSE_DATA             senseData;
    ULONG                       remaining;
    ULONG                       temp ;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            switch (tapePrepare->Operation) {
                case TAPE_LOAD:
                case TAPE_UNLOAD:
                    DebugPrint((3,"TapePrepare: immediate\n"));
                    break;

                case TAPE_LOCK:
                case TAPE_UNLOCK:
                    break;

                case TAPE_TENSION:
                default:
                    DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.Immediate = tapePrepare->Immediate;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_TENSION:
            default:
                DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if ( CallNumber == 1 ) {

        if (tapePrepare->Operation == TAPE_LOAD ) {

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
                DebugPrint((1,
                           "GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS ;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->CdbLength = CDB6GENERIC_LENGTH;


            cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(EXB_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        } else {

            return TAPE_STATUS_CALLBACK ;
        }
    }

    ASSERT(CallNumber == 2 );

    if ( LastError == TAPE_STATUS_SUCCESS ) {
        senseData = Srb->DataBuffer;

        remaining =  (senseData->Remaining[0] << 16);
        remaining += (senseData->Remaining[1] << 8);
        remaining += (senseData->Remaining[2]);
        extension->Capacity = remaining;
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;
    PMODE_DEVICE_CONFIG_PAGE    configBuffer;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE))) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        configBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        configBuffer = Srb->DataBuffer;

        configBuffer->ParameterListHeader.ModeDataLength = 0;
        configBuffer->ParameterListHeader.MediumType = 0;
        configBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        configBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        if (tapeSetDriveParams->ReportSetmarks) {
            configBuffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            configBuffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE);
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DATA_COMPRESS_PAGE))) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 3) {

        compressionBuffer = Srb->DataBuffer;

        if (!compressionBuffer->DataCompressPage.DCC) {
            return TAPE_STATUS_SUCCESS;
        }

        compressionBuffer->ParameterListHeader.ModeDataLength = 0;
        compressionBuffer->ParameterListHeader.MediumType = 0;
        compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        compressionBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        compressionBuffer->DataCompressPage.PageCode = MODE_PAGE_DATA_COMPRESS;
        compressionBuffer->DataCompressPage.PageLength = 0x0E;

        if (tapeSetDriveParams->Compression) {
            compressionBuffer->DataCompressPage.DCE = SETBITON;
        } else {
            compressionBuffer->DataCompressPage.DCE = SETBITOFF;
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 4);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
            MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.DensityCode = 0x7F;
        modeBuffer->ParameterListBlock.BlockLength[0] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
            (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 2);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_POSITION          tapeSetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    ULONG                       tapePositionVector;
    ULONG                       method;
    PEXB_SENSE_DATA             senseData;
    ULONG                       remaining;
    ULONG                       partition = 0;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                case TAPE_ABSOLUTE_BLOCK:
                case TAPE_LOGICAL_BLOCK:
                case TAPE_SPACE_END_OF_DATA:
                case TAPE_SPACE_RELATIVE_BLOCKS:
                case TAPE_SPACE_FILEMARKS:
                case TAPE_SPACE_SETMARKS:
                    break;

                case TAPE_SPACE_SEQUENTIAL_FMKS:
                case TAPE_SPACE_SEQUENTIAL_SMKS:

                    //
                    // Fall through.
                    //

                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        method = tapeSetPosition->Method;
        tapePositionVector = tapeSetPosition->Offset.LowPart;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (method) {
            case TAPE_REWIND:
                DebugPrint((3,"TapeSetPosition: method == rewind\n"));

                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 500;
                break;

            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute)\n"));

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 500;
                break;

            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute)\n"));

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] = (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] = (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] = (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] = (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 500;

                partition = tapeSetPosition->Partition;
                if ((partition != 0) &&
                    (partition != (extension->CurrentPartition)) &&
                    ((extension->CurrentPartition) != 0)) {

                    //
                    // Specified non-default partition.
                    //

                    DebugPrint((1,
                                "SetPosition: Setting partition (tape relative) %x\n",
                                tapeSetPosition->Partition - 1));
                    //
                    // Need to change to the new partition.
                    //

                    cdb->LOCATE.Partition = (UCHAR)(tapeSetPosition->Partition - 1);
                    cdb->LOCATE.CPBit = 1;
                }

                break;


            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 150;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_FILEMARKS:
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB = (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks = (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB = (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

            case TAPE_SPACE_SETMARKS:

                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 4;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;
                break;

        case TAPE_SPACE_SEQUENTIAL_FMKS:
        case TAPE_SPACE_SEQUENTIAL_SMKS:

                //
                // Fall through.
                //

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1 ) {
        if (tapeSetPosition->Method == TAPE_LOGICAL_BLOCK) {
            if ((tapeSetPosition->Partition) != 0) {
                extension->CurrentPartition = tapeSetPosition->Partition;
            }
            DebugPrint((1,
                        "SetPosition: CurrentPartition (tape relative) %x\n",
                        extension->CurrentPartition));
        }

        if (tapeSetPosition->Method == TAPE_REWIND ) {

            //
            // Build a request sense to get remaining values.
            //

            if (!TapeClassAllocateSrbBuffer( Srb, sizeof(EXB_SENSE_DATA)) ) {
                DebugPrint((1,
                           "GetRemaining Size: insufficient resources (SenseData)\n"));
                return TAPE_STATUS_SUCCESS;
            }

            //
            // Prepare SCSI command (CDB)
            //

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->ScsiStatus = Srb->SrbStatus = 0;
            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->CDB6GENERIC.OperationCode = SCSIOP_REQUEST_SENSE;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(EXB_SENSE_DATA);

            //
            // Send SCSI command (CDB) to device
            //

            DebugPrint((3,"GetRemainingSize: SendSrb (request sense)\n"));

            Srb->DataTransferLength = sizeof(EXB_SENSE_DATA);
            *RetryFlags |= RETURN_ERRORS;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
        }
    }

    if (CallNumber == 2) {
        if (LastError == TAPE_STATUS_SUCCESS) {

            //
            // As a rewind was sent, get the remaining capacity from BOP.
            //

            senseData = Srb->DataBuffer;

            remaining =  (senseData->Remaining[0] << 16);
            remaining += (senseData->Remaining[1] << 8);
            remaining += (senseData->Remaining[2]);

            extension->Capacity = remaining;
        }
    }


    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SHORT_FILEMARKS:
                case TAPE_LONG_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                    break;

                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SHORT_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == short filemarks\n"));
                cdb->WRITE_TAPE_MARKS.Control = 0x80;
                break;

            case TAPE_LONG_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == long filemarks\n"));
                break;

            case TAPE_SETMARKS:
                cdb->WRITE_TAPE_MARKS.WriteSetMarks = 1;
                break;

            case TAPE_FILEMARKS:
                break;

            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}


TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION commandExtension = CommandExtension;
    ULONG i;
    ULONG currentMedia  = 0;
    ULONG blockSize = 0;
    UCHAR mediaType = 0;
    UCHAR densityCode = 0;
    UCHAR deviceSpecificParameter = 0;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        commandExtension->CurrentState = 0;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || 
        (LastError == TAPE_STATUS_MEDIA_CHANGED) || 
        (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, MEDIUM_PARTITION_PAGE_SIZE)) {

                DebugPrint((1,
                            "Mammoth.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, MEDIUM_PARTITION_PAGE_SIZE);
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = MEDIUM_PARTITION_PAGE_SIZE;

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
            cdb->MODE_SENSE.AllocationLength = MEDIUM_PARTITION_PAGE_SIZE;

            commandExtension->CurrentState = SCSIOP_MODE_SENSE;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        }
    } else if (LastError == TAPE_STATUS_NO_MEDIA) {
        if (CallNumber == 1) {

            //
            // If we get this status, it could mean there's no media in the
            // drive or there's a cleaner cartridge. Send TapeAlert Info
            // command
            //
            commandExtension->CurrentState = SCSIOP_LOG_SENSE;
            return PrepareSrbForTapeAlertInfo(Srb);
        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;
        mediaTypes->MediaInfoCount = MAMMOTH_SUPPORTED_TYPES;

        if ( LastError == TAPE_STATUS_SUCCESS ) {
            if ((commandExtension->CurrentState) ==  SCSIOP_MODE_SENSE) {
    
                PMODE_TAPE_MEDIA_INFORMATION mediaInformation = Srb->DataBuffer;
    
                //
                // Determine the media type currently loaded.
                //

                mediaType = mediaInformation->ParameterListHeader.MediumType;
                blockSize = mediaInformation->ParameterListBlock.BlockLength[2];
                blockSize |= (mediaInformation->ParameterListBlock.BlockLength[1] << 8);
                blockSize |= (mediaInformation->ParameterListBlock.BlockLength[0] << 16);

                deviceSpecificParameter = mediaInformation->ParameterListHeader.DeviceSpecificParameter;

                densityCode = mediaInformation->ParameterListBlock.DensityCode;

                DebugPrint((1,
                            "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                            mediaType,
                            blockSize));

                switch (mediaType) {
                    case 0:

                        //
                        // Cleaner, unknown, no media mounted...
                        //

                        currentMedia = 0;
                        break;

                    case 0x81:
                    case 0x82:
                    case 0x83:
                    case 0x84:
                    case 0x85:
                    case 0x86:
                    case 0xC1:
                    case 0xC2:
                    case 0xC3:
                    case 0xC4:

                        //
                        // 15-160m non-AME
                        //

                        currentMedia = MP_8mm;
                        break;

                    case 0xD1:
                    case 0xD2:

                        //
                        // 22 or 170m AME
                        //

                        currentMedia = AME_8mm;
                        break;

                    default:

                        //
                        // Unknown
                        //

                        currentMedia = 0;
                        break;
                }
            } else if ((commandExtension->CurrentState) ==  SCSIOP_LOG_SENSE) {
                PTAPE_ALERT_INFO tapeAlertInfo;
                PLOG_SENSE_PAGE_HEADER logSenseHeader;
                LONG bytesLeft = 0;
    
                //
                // Check if "CLEANER MEDIA" flag is set
                //
                currentMedia = 0;
                bytesLeft = GetNumberOfBytesReturned(Srb);
                
                logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
                tapeAlertInfo= (PTAPE_ALERT_INFO)((PUCHAR)logSenseHeader +
                                  sizeof(LOG_SENSE_PAGE_HEADER));
                while (bytesLeft >= sizeof(TAPE_ALERT_INFO)) {
                
                    if ((tapeAlertInfo->ParamCodeLB) == CLEANING_MEDIA) {
                
                        if (tapeAlertInfo->Flag) {
                            currentMedia = CLEANER_CARTRIDGE;
                        }
                
                        break;
                    }
                
                    tapeAlertInfo++;
                    bytesLeft -= sizeof(TAPE_ALERT_INFO);
                }
            }
        } else {
            currentMedia = 0;
        }

        //
        // At this point, currentMedia should either be 0, or a valid
        // mediatype supported
        //
        DebugPrint((3, "Currents Media is %d\n", currentMedia));

        for (i = 0; i < mediaTypes->MediaInfoCount; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = MammothMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (MammothMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((deviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;


                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    densityCode;

                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }
    }

    return TAPE_STATUS_SUCCESS;
}


static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"EXABYTE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-8900",8) == 8) {
            return EXABYTE_8900;
        }

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\miniqic\miniqic.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       miniqic.c
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1998 Microsoft

Module Name:

    miniqic.c

Abstract:

    This module contains device-specific routines for minicartridge
    QIC tape drive.

Environment:

    kernel mode only

--*/

#include "minitape.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

//
//  Internal (module wide) defines that symbolize
//  the minicartridge QIC drives supported by this module.
//
#define CTMS_3200           1  // the Conner CTMS 3200 drive
#define EXABYTE_2501        2  // the Exabyte EXB 2501 drive
#define EXABYTE_2505        3  // the Exabyte EXB 2502 drive
#define TDC_3500            4  // the Tandberg Data TDC 3500 drive
#define TDC_3700            5  // the Tandberg Data TDC 3700 drive
#define CONNER_CTT8000_S    6  // Conner CTT8000-S
#define SEAGATE_STT8000N    7  // Seagate STT8000N, STTx8000N
#define SEAGATE_STT20000N   8  // Seagate STT20000N
#define TECMAR_TRAVAN       9  // Tecmar ns20 and wangtek 51000

//
//  The timeout for positioning is 5 hours
//
#define POSITION_TIMEOUT      (5*60*60)
#define LONG_COMMAND_TIMEOUT  (5*60*60)
//
//  Internal (module wide) defines that symbolize
//  the non-QFA mode and the QFA mode partitions.
//
#define NOT_PARTITIONED      0  // non-QFA mode -- must be zero (!= 0 means partitioned)
#define DATA_PARTITION       1  // QFA mode, data partition #
#define DIRECTORY_PARTITION  2  // QFA mode, directory partition #

//
//  Internal (module wide) define that symbolizes
//  the minicartridge QIC "no partitions" partition method.
//
#define NO_PARTITIONS  0xFFFFFFFF

//
//  Internal (module wide) define that symbolizes
//  the minicartridge QIC "media not formated" condition.
//
#define SCSI_ADSENSE_MEDIUM_FORMAT_CORRUPTED 0x31


#define MINIQIC_SUPPORTED_TYPES 2
STORAGE_MEDIA_TYPE MiniQicMedia[MINIQIC_SUPPORTED_TYPES] = {MiniQic, Travan};

//
//  Function prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData);

//
// Minitape extension definition.
//

typedef struct _MINITAPE_EXTENSION {

    ULONG   DriveID;
    ULONG   CurrentPartition ;

} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION;

//
// Command extension definition.
//

typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;

BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 180;
    tapeInitData.TapeError = TapeError ;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = MINIQIC_SUPPORTED_TYPES;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData);
    extension->CurrentPartition = 0 ;
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION      extension = MinitapeExtension;
    PCOMMAND_EXTENSION       tapeCmdExtension = CommandExtension ;
    PTAPE_CREATE_PARTITION   tapePartition = CommandParameters;
    PMODE_DEVICE_CONFIG_PAGE deviceConfigModeSenseBuffer;
    PMODE_MEDIUM_PART_PAGE   modeSelectBuffer;
    ULONG                    modeSelectLength;
    ULONG                    partitionMethod;
    ULONG                    partitionCount;
    ULONG                    partition;
    ULONG                    driveID;
    PCDB                     cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));

    if (CallNumber == 0) {

        //
        //  Filter out drives that don't do this.
        //

        switch (extension->DriveID) {
            case EXABYTE_2501:
            case EXABYTE_2505:
            case TDC_3500:
            case TDC_3700:
            case TECMAR_TRAVAN:
                break;

            default:
                DebugPrint((1,"TapeCreatePartition: "));
                DebugPrint((1,"driveID -- invalid request\n"));
                return TAPE_STATUS_INVALID_DEVICE_REQUEST;

        }

        //
        //  Filter out invalid partition counts.
        //

        if ( tapePartition->Count > 2 ) {
            DebugPrint((1,"TapeCreatePartition: "));
            DebugPrint((1,"partitionCount -- invalid request\n"));
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;

        }

        //
        //  Filter out invalid partition methods.
        //

        if ( tapePartition->Method != TAPE_FIXED_PARTITIONS ) {
            DebugPrint((3,"TapeCreatePartition: %d - Not implemented\n", tapePartition->Method));
            return TAPE_STATUS_NOT_IMPLEMENTED;

        }

        //
        // Rewind: some drives must be at BOT to enable/disable QFA mode,
        //


        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (rewind)\n"));

        Srb->TimeOutValue = POSITION_TIMEOUT ;
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
     }

     if (CallNumber == 1 ) {

        DebugPrint((3,"TapeCreatePartition: fixed partitions\n"));

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_MEDIUM_PART_PAGE)) ) {
            DebugPrint((1,"TapeCreatePartition: insufficient resources (modeSelectBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_MEDIUM_PART_PAGE));

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode select)\n"));

        Srb->TimeOutValue = POSITION_TIMEOUT;

        Srb->DataTransferLength = cdb->MODE_SENSE.AllocationLength;
        Srb->SrbFlags |= SRB_FLAGS_DATA_IN;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
     if (CallNumber == 2 ) {

        partitionMethod = TAPE_FIXED_PARTITIONS;
        partitionCount  = tapePartition->Count;

        ASSERT( partitionMethod == TAPE_FIXED_PARTITIONS ) ;

        DebugPrint((3,"TapeCreatePartition: fixed partitions\n"));


        modeSelectBuffer = Srb->DataBuffer ;

        modeSelectBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeSelectBuffer->ParameterListHeader.ModeDataLength = 0;
        modeSelectBuffer->ParameterListHeader.MediumType = 0;

        modeSelectLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;
        modeSelectBuffer->MediumPartPage.PSBit = 0;

        switch (partitionMethod) {
            case TAPE_FIXED_PARTITIONS:
                modeSelectBuffer->MediumPartPage.FDPBit = SETBITON;
                partition = DATA_PARTITION;
                tapeCmdExtension->CurrentState = partition ;
                break;

            case NO_PARTITIONS:
                modeSelectBuffer->MediumPartPage.FDPBit = SETBITOFF;
                partition = NOT_PARTITIONED;
                tapeCmdExtension->CurrentState = partition ;
                break;
        }

        switch (extension->DriveID) {
            case EXABYTE_2501:
            case EXABYTE_2505:
                modeSelectBuffer->MediumPartPage.MediumFormatRecognition = 3;
                break;

            case TDC_3500:
            case TDC_3700:
            case TECMAR_TRAVAN:
                modeSelectBuffer->MediumPartPage.MaximumAdditionalPartitions = 1;
                 break;


        }

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)modeSelectLength;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode select)\n"));

        Srb->TimeOutValue = POSITION_TIMEOUT;

        Srb->DataTransferLength = (UCHAR)modeSelectLength ;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if (CallNumber == 3) {

        partition = extension->CurrentPartition = tapeCmdExtension->CurrentState ;

        if (partition == NOT_PARTITIONED) {

            return TAPE_STATUS_SUCCESS ;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeCreatePartition: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeCreatePartition: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT (CallNumber == 4);

    deviceConfigModeSenseBuffer = Srb->DataBuffer ;

    extension->CurrentPartition =
        deviceConfigModeSenseBuffer->DeviceConfigPage.ActivePartition?
        DIRECTORY_PARTITION : DATA_PARTITION;

    //
    // Account for the 1-based API values.
    //

    extension->CurrentPartition += 1;

    return TAPE_STATUS_SUCCESS;

} // end TapeCreatePartition()

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
                DebugPrint((3,"TapeErase: short\n"));
                break;

            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        if (tapeErase->Immediate) {

            DebugPrint((3,"TapeErase: immediate\n"));

        }

        //
        //  Rewind: some drives must be at BOT to erase/format.
        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (rewind)\n"));

        Srb->TimeOutValue = POSITION_TIMEOUT;
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if (CallNumber==1) {

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = (tapeErase->Type == TAPE_ERASE_LONG)?
                     SETBITON : SETBITOFF;


        //
        // Send SCSI command (CDB) to device
        //

        Srb->TimeOutValue = LONG_COMMAND_TIMEOUT;
        Srb->DataTransferLength = 0 ;

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT (CallNumber == 2) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapeErase()

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer;
    UCHAR              sensekey;
    UCHAR              adsenseq;
    UCHAR              adsense;

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       senseBuffer = Srb->SenseInfoBuffer;
       sensekey = senseBuffer->SenseKey & 0x0F;
       adsenseq = senseBuffer->AdditionalSenseCodeQualifier;
       adsense = senseBuffer->AdditionalSenseCode;

       DebugPrint((1,
                   "Miniqic: TapeError: Sense Key - %x\n",
                   sensekey));
       DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   adsense));
       DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   adsenseq));
       if (sensekey == SCSI_SENSE_MEDIUM_ERROR) {
          if ((adsense == SCSI_ADSENSE_MEDIUM_FORMAT_CORRUPTED) && (adsenseq == 0)) {

             *LastError = TAPE_STATUS_UNRECOGNIZED_MEDIA;
          }
       }
    }

    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));
    return;

} // end TapeError()


TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;
    BOOLEAN                     reportSetmarks = 0;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }
    if (CallNumber == 1) {

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        tapeGetDriveParams->ReportSetmarks =
            deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk? TRUE : FALSE ;


        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(READ_BLOCK_LIMITS_DATA) ) ) {

            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimitsModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;


        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        Srb->DataTransferLength = sizeof(READ_BLOCK_LIMITS_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }


    if ( CallNumber == 2 ) {

        blockLimits = Srb->DataBuffer ;

        tapeGetDriveParams->MaximumBlockSize =   blockLimits->BlockMaximumSize[2];
        tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
        tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

        tapeGetDriveParams->MinimumBlockSize =   blockLimits->BlockMinimumSize[1];
        tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);


        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE) ) ) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE) ;

        *RetryFlags = RETURN_ERRORS ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    ASSERT ( CallNumber == 3 ) ;

    if (LastError == TAPE_STATUS_SUCCESS ) {
        compressionModeSenseBuffer = Srb->DataBuffer ;

        if (compressionModeSenseBuffer->DataCompressPage.DCC) {

            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
                compressionModeSenseBuffer->DataCompressPage.DCE?
                    TRUE : FALSE ;

        }
    }

    switch (extension->DriveID) {
        case CTMS_3200:
        case CONNER_CTT8000_S:
        case SEAGATE_STT8000N:
        case SEAGATE_STT20000N:
            tapeGetDriveParams->DefaultBlockSize = 512;
            tapeGetDriveParams->MaximumPartitionCount = 2;

            tapeGetDriveParams->FeaturesLow |=
                TAPE_DRIVE_ERASE_SHORT |
                TAPE_DRIVE_ERASE_BOP_ONLY |
                TAPE_DRIVE_FIXED_BLOCK |
                TAPE_DRIVE_VARIABLE_BLOCK |
                TAPE_DRIVE_WRITE_PROTECT |
                TAPE_DRIVE_REPORT_SMKS |
                TAPE_DRIVE_GET_ABSOLUTE_BLK |
                TAPE_DRIVE_SET_CMP_BOP_ONLY |
                TAPE_DRIVE_GET_LOGICAL_BLK;

            tapeGetDriveParams->FeaturesHigh |=
                TAPE_DRIVE_LOAD_UNLOAD |
                TAPE_DRIVE_TENSION |
                TAPE_DRIVE_REWIND_IMMEDIATE |
                TAPE_DRIVE_SET_BLOCK_SIZE |
                TAPE_DRIVE_SET_REPORT_SMKS |
                TAPE_DRIVE_ABSOLUTE_BLK |
                TAPE_DRIVE_LOGICAL_BLK |
                TAPE_DRIVE_END_OF_DATA |
                TAPE_DRIVE_RELATIVE_BLKS |
                TAPE_DRIVE_FILEMARKS |
                TAPE_DRIVE_SEQUENTIAL_FMKS |
                TAPE_DRIVE_SETMARKS |
                TAPE_DRIVE_SEQUENTIAL_SMKS |
                TAPE_DRIVE_REVERSE_POSITION |
                TAPE_DRIVE_WRITE_SETMARKS |
                TAPE_DRIVE_WRITE_FILEMARKS |
                TAPE_DRIVE_WRITE_MARK_IMMED;
            break;

        case EXABYTE_2501:
        case EXABYTE_2505:
            tapeGetDriveParams->MaximumPartitionCount = 2;
            tapeGetDriveParams->DefaultBlockSize = 1024;

            tapeGetDriveParams->FeaturesLow |=
                TAPE_DRIVE_FIXED |
                TAPE_DRIVE_ERASE_LONG |
                TAPE_DRIVE_ERASE_BOP_ONLY |
                TAPE_DRIVE_FIXED_BLOCK |
                TAPE_DRIVE_WRITE_PROTECT |
                TAPE_DRIVE_GET_ABSOLUTE_BLK |
                TAPE_DRIVE_GET_LOGICAL_BLK;

            tapeGetDriveParams->FeaturesHigh |=
                TAPE_DRIVE_LOAD_UNLOAD |
                TAPE_DRIVE_TENSION |
                TAPE_DRIVE_ABSOLUTE_BLK |
                TAPE_DRIVE_LOGICAL_BLK |
                TAPE_DRIVE_END_OF_DATA |
                TAPE_DRIVE_RELATIVE_BLKS |
                TAPE_DRIVE_FILEMARKS |
                TAPE_DRIVE_WRITE_FILEMARKS |
                TAPE_DRIVE_WRITE_MARK_IMMED |
                TAPE_DRIVE_FORMAT;
            break;

        case TDC_3500:
        case TDC_3700:
            tapeGetDriveParams->DefaultBlockSize = 512;
            tapeGetDriveParams->MaximumPartitionCount = 2;

            tapeGetDriveParams->FeaturesLow |=
                TAPE_DRIVE_FIXED |
                TAPE_DRIVE_ERASE_SHORT |
                TAPE_DRIVE_ERASE_LONG |
                TAPE_DRIVE_ERASE_BOP_ONLY |
                TAPE_DRIVE_ERASE_IMMEDIATE |
                TAPE_DRIVE_FIXED_BLOCK |
                TAPE_DRIVE_VARIABLE_BLOCK |
                TAPE_DRIVE_WRITE_PROTECT |
                TAPE_DRIVE_REPORT_SMKS |
                TAPE_DRIVE_GET_ABSOLUTE_BLK |
                TAPE_DRIVE_GET_LOGICAL_BLK |
                TAPE_DRIVE_EJECT_MEDIA;

            tapeGetDriveParams->FeaturesHigh |=
                TAPE_DRIVE_LOAD_UNLOAD |
                TAPE_DRIVE_TENSION |
                TAPE_DRIVE_LOCK_UNLOCK |
                TAPE_DRIVE_SET_BLOCK_SIZE |
                TAPE_DRIVE_ABSOLUTE_BLK |
                TAPE_DRIVE_LOGICAL_BLK |
                TAPE_DRIVE_END_OF_DATA |
                TAPE_DRIVE_RELATIVE_BLKS |
                TAPE_DRIVE_FILEMARKS |
                TAPE_DRIVE_SEQUENTIAL_FMKS |
                TAPE_DRIVE_SETMARKS |
                TAPE_DRIVE_REVERSE_POSITION |
                TAPE_DRIVE_WRITE_SETMARKS |
                TAPE_DRIVE_WRITE_FILEMARKS |
                TAPE_DRIVE_WRITE_MARK_IMMED;
            break;

        case TECMAR_TRAVAN:
            tapeGetDriveParams->DefaultBlockSize = 512;
            tapeGetDriveParams->MaximumPartitionCount = 2;

            tapeGetDriveParams->FeaturesLow |=
                TAPE_DRIVE_FIXED |
                TAPE_DRIVE_ERASE_LONG |
                TAPE_DRIVE_ERASE_BOP_ONLY |
                TAPE_DRIVE_ERASE_IMMEDIATE |
                TAPE_DRIVE_FIXED_BLOCK |
                TAPE_DRIVE_VARIABLE_BLOCK |
                TAPE_DRIVE_WRITE_PROTECT |
                TAPE_DRIVE_GET_ABSOLUTE_BLK |
                TAPE_DRIVE_GET_LOGICAL_BLK |
                TAPE_DRIVE_EJECT_MEDIA;

            tapeGetDriveParams->FeaturesHigh |=
                TAPE_DRIVE_LOAD_UNLOAD |
                TAPE_DRIVE_TENSION |
                TAPE_DRIVE_LOCK_UNLOCK |
                TAPE_DRIVE_SET_BLOCK_SIZE |
                TAPE_DRIVE_ABSOLUTE_BLK |
                TAPE_DRIVE_LOGICAL_BLK |
                TAPE_DRIVE_END_OF_DATA |
                TAPE_DRIVE_RELATIVE_BLKS |
                TAPE_DRIVE_FILEMARKS |
                TAPE_DRIVE_SEQUENTIAL_FMKS |
                TAPE_DRIVE_REVERSE_POSITION |
                TAPE_DRIVE_WRITE_FILEMARKS |
                TAPE_DRIVE_WRITE_MARK_IMMED;
            break;

    }

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    DebugPrint((3,"TapeGetDriveParameters: FeaturesLow == 0x%.8X\n",
        tapeGetDriveParams->FeaturesLow));
    DebugPrint((3,"TapeGetDriveParameters: FeaturesHigh == 0x%.8X\n",
        tapeGetDriveParams->FeaturesHigh));

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetDriveParameters()


TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_MEDIUM_PART_PAGE      mediumPartitionModeSenseBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_PARM_READ_WRITE_DATA  rwparametersModeSenseBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    BOOLEAN                     qfaMode;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_MEDIUM_PART_PAGE)) ) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (mediumPartitionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        mediumPartitionModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;


        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 2) {

        mediumPartitionModeSenseBuffer = Srb->DataBuffer ;
        qfaMode = mediumPartitionModeSenseBuffer->MediumPartPage.FDPBit? TRUE : FALSE ;

        if (!qfaMode) {

            return TAPE_STATUS_CALLBACK ;
        }

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (deviceConfigModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3) {

        if (LastError == TAPE_STATUS_CALLBACK ) {

            extension->CurrentPartition = NOT_PARTITIONED;
            tapeGetMediaParams->PartitionCount = 1;

         } else {

            deviceConfigModeSenseBuffer = Srb->DataBuffer ;

            extension->CurrentPartition =
                deviceConfigModeSenseBuffer->DeviceConfigPage.ActivePartition?
                DIRECTORY_PARTITION : DATA_PARTITION ;

            //
            // Account for 1-based API value.
            //

            extension->CurrentPartition += 1;

            tapeGetMediaParams->PartitionCount = 2;
        }


        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {
            DebugPrint((1,"TapeGetMediaParameters: insufficient resources (rwparametersModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        rwparametersModeSenseBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetMediaParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    ASSERT(CallNumber == 4 ) ;

    rwparametersModeSenseBuffer = Srb->DataBuffer ;

    tapeGetMediaParams->BlockSize  =  rwparametersModeSenseBuffer->ParameterListBlock.BlockLength[2];
    tapeGetMediaParams->BlockSize += (rwparametersModeSenseBuffer->ParameterListBlock.BlockLength[1] << 8);
    tapeGetMediaParams->BlockSize += (rwparametersModeSenseBuffer->ParameterListBlock.BlockLength[0] << 16);

    tapeGetMediaParams->WriteProtected =
            ((rwparametersModeSenseBuffer->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetMediaParameters()



TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_POSITION          tapeGetPosition = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PTAPE_POSITION_DATA         positionBuffer;
    ULONG                       type;

    DebugPrint((3,"TapeGetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        type = tapeGetPosition->Type;
        TapeClassZeroMemory(tapeGetPosition, sizeof(TAPE_GET_POSITION));
        tapeGetPosition->Type = type;

        switch (type) {
            case TAPE_ABSOLUTE_POSITION:
                DebugPrint((3,"TapeGetPosition: absolute/logical\n"));
                break;

            case TAPE_LOGICAL_POSITION:
                DebugPrint((3,"TapeGetPosition: logical\n"));
                break;

            default:
                DebugPrint((1,"TapeGetPosition: PositionType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;

        }


        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }
    if ( CallNumber == 1 ) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(TAPE_POSITION_DATA) ) ) {
            DebugPrint((1,"TapeGetPosition: insufficient resources (positionBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        positionBuffer = Srb->DataBuffer ;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB10GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
        cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetPosition: SendSrb (read position)\n"));

        Srb->DataTransferLength = sizeof(TAPE_POSITION_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT (CallNumber == 2 ) ;

    positionBuffer = Srb->DataBuffer ;

    if (positionBuffer->BlockPositionUnsupported) {
        DebugPrint((1,"TapeGetPosition: read position -- block position unsupported\n"));
        return TAPE_STATUS_INVALID_DEVICE_REQUEST;
    }

    if (tapeGetPosition->Type == TAPE_LOGICAL_POSITION) {
        tapeGetPosition->Partition = positionBuffer->PartitionNumber?
            DIRECTORY_PARTITION : DATA_PARTITION ;
        if (extension->CurrentPartition &&
           (extension->CurrentPartition != tapeGetPosition->Partition)) {
           extension->CurrentPartition = tapeGetPosition->Partition;
        }
    }

    tapeGetPosition->Offset.HighPart = 0;
    REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                  (PFOUR_BYTE)positionBuffer->FirstBlock);

    return TAPE_STATUS_SUCCESS ;

} // end TapeGetPosition()


TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCDB    cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetStatus: Enter routine\n"));

    if (CallNumber == 0) {
        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;

} // end TapeGetStatus()


TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_PREPARE      tapePrepare = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapePrepare: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            DebugPrint((1,"TapePrepare: Operation, immediate -- operation not supported\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        if ( tapePrepare->Operation == TAPE_FORMAT ) {
            //first lets rewind

            DebugPrint((3,"TapePrepare: Operation == preformat rewind\n"));

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
            cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->TimeOutValue = POSITION_TIMEOUT;
            Srb->DataTransferLength = 0 ;
            return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

        } else {
            return TAPE_STATUS_CALLBACK ;
        }

    }

    if (CallNumber == 1) {

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                DebugPrint((3,"TapePrepare: Operation == load\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                 Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_UNLOAD:
                DebugPrint((3,"TapePrepare: Operation == unload\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                 Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_TENSION:
                DebugPrint((3,"TapePrepare: Operation == tension\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
                 Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_LOCK:
                DebugPrint((3,"TapePrepare: Operation == lock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                break;

            case TAPE_UNLOCK:
                DebugPrint((3,"TapePrepare: Operation == unlock\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                break;

            case TAPE_FORMAT:

                 DebugPrint((3,"TapePrepare: Operation == format\n"));
                 cdb->CDB6GENERIC.OperationCode = SCSIOP_ERASE;
                 Srb->TimeOutValue = LONG_COMMAND_TIMEOUT;
                 break;

            default:
                 DebugPrint((1,"TapePrepare: Operation -- operation not supported\n"));
                 return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapePrepare: SendSrb (Operation)\n"));

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    ASSERT( CallNumber == 2 ) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapePrepare()


TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;
    PMODE_DEVICE_CONFIG_PAGE    configBuffer;

    DebugPrint((3,"TapeSetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        switch (extension->DriveID) {
            case CTMS_3200:
            case CONNER_CTT8000_S:
            case SEAGATE_STT8000N:
            case SEAGATE_STT20000N:
            case TDC_3500:
            case TDC_3700:
            case TECMAR_TRAVAN:

                if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DEVICE_CONFIG_PAGE)) ) {
                    DebugPrint((1,"TapeSetDriveParameters: insufficient resources (configBuffer)\n"));
                    return TAPE_STATUS_INSUFFICIENT_RESOURCES;
                }

                configBuffer = Srb->DataBuffer ;

                //
                // Prepare SCSI command (CDB)
                //

                Srb->CdbLength = CDB6GENERIC_LENGTH;
                TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.Dbd = SETBITON;
                cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
                cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

                //
                // Send SCSI command (CDB) to device
                //

                DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense)\n"));

                Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

                return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

            default:
                DebugPrint((1,"TapeSetDriveParameters: operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }
    }

    if (CallNumber == 1 ) {

        configBuffer = Srb->DataBuffer;

        configBuffer->ParameterListHeader.ModeDataLength = 0;
        configBuffer->ParameterListHeader.MediumType = 0;
        configBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        configBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        configBuffer->DeviceConfigPage.PS = SETBITOFF;
        configBuffer->DeviceConfigPage.PageCode = MODE_PAGE_DEVICE_CONFIG;
        configBuffer->DeviceConfigPage.PageLength = 0x0E;

        if (tapeSetDriveParams->ReportSetmarks) {
            configBuffer->DeviceConfigPage.RSmk = SETBITON;
        } else {
            configBuffer->DeviceConfigPage.RSmk = SETBITOFF;
        }

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if ( CallNumber == 2 ) {

        if ( !TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_DATA_COMPRESS_PAGE) ) ) {
            DebugPrint((1,"TapeSetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode sense PAGE_DATA_COMPRESS)\n"));

        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        *RetryFlags = RETURN_ERRORS ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    *RetryFlags = 0;

    if ( CallNumber == 3 ) {
        compressionBuffer = Srb->DataBuffer;

        if ((LastError != TAPE_STATUS_SUCCESS ) ||
            (!compressionBuffer->DataCompressPage.DCC)) {

            //
            // Compression page not supported by device
            // or Not data compression capable.
            //

            if (tapeSetDriveParams->Compression) {

                //
                // Fail attempt to turn compresor on
                //

                return LastError;
            } else {

                //
                // No compressor and no request to turn it on
                //

                return TAPE_STATUS_SUCCESS ;
            }
        }

        compressionBuffer = Srb->DataBuffer ;
        compressionBuffer->ParameterListHeader.ModeDataLength = 0;
        compressionBuffer->ParameterListHeader.MediumType = 0;
        compressionBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        compressionBuffer->ParameterListHeader.BlockDescriptorLength = 0;

        DebugPrint((3,"TapeSetDriveParameters: sense DCE=%d\n",
            compressionBuffer->DataCompressPage.DCE));
        if (tapeSetDriveParams->Compression) {
            compressionBuffer->DataCompressPage.DCE = SETBITON;
        } else {
            compressionBuffer->DataCompressPage.DCE = SETBITOFF;
        }

        DebugPrint((3,"TapeSetDriveParameters: select DCE=%d\n",
            compressionBuffer->DataCompressPage.DCE));

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetDriveParameters: SendSrb (mode select PAGE_DATA_COMPRESS)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    ASSERT( CallNumber == 4 );

    return TAPE_STATUS_SUCCESS;

} // end TapeSetDriveParameters()

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;

    DebugPrint((3,"TapeSetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        switch (extension->DriveID) {
            case CTMS_3200:
            case CONNER_CTT8000_S:
            case SEAGATE_STT8000N:
            case SEAGATE_STT20000N:
            case TDC_3500:
            case TDC_3700:
            case TECMAR_TRAVAN:
                return TAPE_STATUS_CHECK_TEST_UNIT_READY ;

            default:
                DebugPrint((1,"TapeSetMediaParameters: operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }
    }

    if ( CallNumber == 1 ) {

        if (!TapeClassAllocateSrbBuffer( Srb, sizeof(MODE_PARM_READ_WRITE_DATA)) ) {

            DebugPrint((1,"TapeSetMediaParameters: insufficient resources (modeBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer ;

        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength = MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.DensityCode = 0x7F;
        if (extension->DriveID == TECMAR_TRAVAN) {
           modeBuffer->ParameterListBlock.DensityCode = 0;
        }
        modeBuffer->ParameterListBlock.BlockLength[0] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] =
            (UCHAR)((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] =
            (UCHAR)(tapeSetMediaParams->BlockSize & 0xFF);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetMediaParameters: SendSrb (mode select)\n"));

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA) ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

     }

     ASSERT( CAllNumber == 2 ) ;
     return TAPE_STATUS_SUCCESS;

} // end TapeSetMediaParameters()

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION extension = MinitapeExtension;
    PTAPE_SET_POSITION  tapeSetPosition = CommandParameters;
    PCDB                cdb = (PCDB)Srb->Cdb;
    ULONG               tapePositionVector;
    ULONG               partition = 0;
    ULONG               method;

    DebugPrint((3,"TapeSetPosition: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
            switch (tapeSetPosition->Method) {
                case TAPE_REWIND:
                    DebugPrint((3,"TapeSetPosition: immediate\n"));
                    break;

                default:
                    DebugPrint((1,"TapeSetPosition: PositionMethod, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        method = tapeSetPosition->Method;
        tapePositionVector = tapeSetPosition->Offset.LowPart;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->CDB6GENERIC.Immediate = tapeSetPosition->Immediate;

        switch (method) {
        case TAPE_REWIND:

                DebugPrint((3,"TapeSetPosition: method == rewind\n"));
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_ABSOLUTE_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (absolute/logical)\n"));
                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] =
                    (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_LOGICAL_BLOCK:
                DebugPrint((3,"TapeSetPosition: method == locate (logical)\n"));
                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                cdb->LOCATE.LogicalBlockAddress[0] =
                    (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] =
                    (UCHAR)(tapePositionVector & 0xFF);

                if ((tapeSetPosition->Partition != 0) &&
                    (extension->CurrentPartition != NOT_PARTITIONED) &&
                    (tapeSetPosition->Partition != extension->CurrentPartition)) {

                    partition = tapeSetPosition->Partition;
                    cdb->LOCATE.Partition = (UCHAR)partition - 1;
                    cdb->LOCATE.CPBit = SETBITON;
                } else {
                    partition = extension->CurrentPartition;
                }
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_SPACE_END_OF_DATA:
                DebugPrint((3,"TapeSetPosition: method == space to end-of-data\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
                DebugPrint((3,"TapeSetPosition: method == space blocks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 0;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_SPACE_FILEMARKS:
                DebugPrint((3,"TapeSetPosition: method == space filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_SPACE_SEQUENTIAL_FMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential filemarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 2;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_SPACE_SETMARKS:
                DebugPrint((3,"TapeSetPosition: method == space setmarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 4;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            case TAPE_SPACE_SEQUENTIAL_SMKS:
                DebugPrint((3,"TapeSetPosition: method == space sequential setmarks\n"));
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 5;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = POSITION_TIMEOUT;
                break;

            default:
                DebugPrint((1,"TapeSetPosition: PositionMethod -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeSetPosition: SendSrb (method)\n"));

        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    ASSERT( CallNumber == 1 );

    if (tapeSetPosition->Method == TAPE_LOGICAL_BLOCK) {
        extension->CurrentPartition = tapeSetPosition->Partition;
    }

    return TAPE_STATUS_SUCCESS ;

} // end TapeSetPosition()


TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeWriteMarks: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeWriteMarks->Immediate) {
            switch (tapeWriteMarks->Type) {
                case TAPE_SETMARKS:
                case TAPE_FILEMARKS:
                    DebugPrint((3,"TapeWriteMarks: immediate\n"));
                    break;

                default:
                    DebugPrint((1,"TapeWriteMarks: TapemarkType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        switch (tapeWriteMarks->Type) {
            case TAPE_SETMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == setmarks\n"));
                cdb->WRITE_TAPE_MARKS.WriteSetMarks = SETBITON;
                break;

            case TAPE_FILEMARKS:
                DebugPrint((3,"TapeWriteMarks: TapemarkType == filemarks\n"));
                break;

            default:
                DebugPrint((1,"TapeWriteMarks: TapemarkType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        cdb->WRITE_TAPE_MARKS.TransferLength[0] =
            (UCHAR)((tapeWriteMarks->Count >> 16) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[1] =
            (UCHAR)((tapeWriteMarks->Count >> 8) & 0xFF);
        cdb->WRITE_TAPE_MARKS.TransferLength[2] =
            (UCHAR)(tapeWriteMarks->Count & 0xFF);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeWriteMarks: SendSrb (TapemarkType)\n"));

        Srb->TimeOutValue = POSITION_TIMEOUT;
        Srb->DataTransferLength = 0 ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }
    ASSERT( CallNumber == 1) ;

    return TAPE_STATUS_SUCCESS ;

} // end TapeWriteMarks()



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense for medium partition page.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS))) {

                DebugPrint((1,
                            "SonyAIT.GetMediaTypes: Couldn't allocate Srb Buffer\n"));
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS));
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE_PLUS);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
            cdb->MODE_SENSE.AllocationLength = (UCHAR)Srb->DataTransferLength;

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {


        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;
        PMODE_DEVICE_CONFIG_PAGE_PLUS configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, only two types (either mc/travan) are returned.
        //

        mediaTypes->MediaInfoCount = 2;


        if ( LastError == TAPE_STATUS_SUCCESS ) {

            //
            // Determine the media type currently loaded.
            //

            mediaType = configInformation->ParameterListHeader.MediumType;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                        mediaType,
                        blockSize));


            switch (mediaType) {
                case 0:

                    //
                    // Cleaner, unknown, no media mounted...
                    //

                    currentMedia = 0;
                    break;

                case 0x82:
                case 0x83:
                case 0x86:
                case 0x87:
                case 0x91:
                case 0x92:
                case 0x93:
                case 0xA1:
                case 0xC3:
                case 0xC6:
                case 0xD3:

                    //
                    // MC media
                    //

                    currentMedia = MiniQic;
                    break;

                case 0xB7:
                case 0xB6:  // TR4
                case 0x85:  // TR5

                    //
                    // travan
                    //

                    currentMedia = Travan;
                    break;

                default:

                    //
                    // Unknown
                    //

                    DebugPrint((1,
                               "Miniqic.GetMediaTypes: Unknown type %x\n",
                               mediaType));

                    currentMedia = MiniQic;
                    break;
            }
        } else {
            currentMedia = 0;
        }

        //
        // fill in buffer based on spec. values
        // Only one type supported now.
        //

        for (i = 0; i < mediaTypes->MediaInfoCount; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = MiniQicMedia[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (MiniQicMedia[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;

                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    configInformation->ParameterListBlock.DensityCode;
                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x01;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }

    }

    return TAPE_STATUS_SUCCESS;
}

static
ULONG
WhichIsIt(
    IN PINQUIRYDATA InquiryData
    )

/*++
Routine Description:

    This routine determines a drive's identity from the Product ID field
    in its inquiry data.

Arguments:

    InquiryData (from an Inquiry command)

Return Value:

    driveID

--*/

{
    if (TapeClassCompareMemory(InquiryData->VendorId,"CONNER  ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"CTMS  3200",10) == 10) {
            return CTMS_3200;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"CTT8000-S",9) == 9) {
            return CONNER_CTT8000_S;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"EXABYTE ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-2501",8) == 8) {
            return EXABYTE_2501;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"EXB-2502",8) == 8) {
            return EXABYTE_2505;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"TANDBERG",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId," TDC 3500",9) == 9) {
            return TDC_3500;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId," TDC 3700",9) == 9) {
            return TDC_3700;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId," NS8",4) == 4) {
            return SEAGATE_STT8000N;
        }
        
        if (TapeClassCompareMemory(InquiryData->ProductId," NS20",5) == 5) {
            return SEAGATE_STT20000N;
        }
        
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"DEC", 3) == 3) {
        if (TapeClassCompareMemory(InquiryData->ProductId,"TZK20",5) == 5) {
            return TDC_3700;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"Seagate ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"STT8000N",8) == 8) {
            return SEAGATE_STT8000N;
        }

        if (TapeClassCompareMemory(InquiryData->ProductId,"STT20000N",9) == 9) {
            return SEAGATE_STT20000N;
        }
    }

    if (TapeClassCompareMemory(InquiryData->VendorId,"TECMAR  ",8) == 8) {

        if (TapeClassCompareMemory(InquiryData->ProductId,"TRAVAN NS20",11) == 11) {
            return TECMAR_TRAVAN;
        }
        if (TapeClassCompareMemory(InquiryData->ProductId,"TRAVAN NS8",10) == 10) {
            return TECMAR_TRAVAN;
        }

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\ltotape\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for LTO tape drives.

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"
#include "ltotape.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TapeWMIControl)
#pragma alloc_text(PAGE, GetNumberOfBytesReturned)
#pragma alloc_text(PAGE, PrepareSrbForTapeAlertInfo)
#pragma alloc_text(PAGE, ProcessReadWriteErrors)
#pragma alloc_text(PAGE, QueryDeviceErrorData)
#pragma alloc_text(PAGE, QueryIoErrorData)
#pragma alloc_text(PAGE, VerifyReadWriteErrors)
#endif

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )
/*+
Routine Description:

   This is the common entry point for all WMI calls from tape class driver.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;

   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;

   switch (wmiOperations->Method) {
      case TAPE_CHECK_FOR_DRIVE_PROBLEM: {
          return QueryDeviceErrorData(MinitapeExtension, 
                                      CommandExtension,
                                      CommandParameters, 
                                      Srb, CallNumber,
                                      LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_IO_ERROR_DATA: {
         return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                 CommandParameters, Srb, CallNumber,
                                 LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_DEVICE_ERROR_DATA: {
         return QueryDeviceErrorData(MinitapeExtension, CommandExtension,
                                     CommandParameters, Srb, CallNumber,
                                     LastError, RetryFlags);
         break;
      }

      default: {
         return TAPE_STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   } // switch (wmiOperations->Method) 
}

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns IO Error data such as read\write errors.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;

   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   IoErrorData = (PWMI_TAPE_PROBLEM_IO_ERROR)&(wmiData->TapeData);

   if (CallNumber == 0) {
      if (!TapeClassAllocateSrbBuffer(Srb, 
                                      sizeof(LOG_SENSE_PAGE_FORMAT))) {
         DebugPrint((1, "QueryIoErrorData : No memory for log sense info\n"));
         return TAPE_STATUS_INSUFFICIENT_RESOURCES;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(IoErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_IO_ERROR));
      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE2;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PAGE_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PAGE_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PAGE_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 1) {
      ProcessReadWriteErrors(Srb, FALSE, IoErrorData);

      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE3;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PAGE_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PAGE_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PAGE_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 2) {
      ProcessReadWriteErrors(Srb, TRUE, IoErrorData);
      
      wmiData->DriveProblemType = VerifyReadWriteErrors(IoErrorData);
      DebugPrint((3, "QueryIoErrorData: DriveProblemType %x\n",
                  wmiData->DriveProblemType));
   }

   return TAPE_STATUS_SUCCESS;
}

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
)
/*+
Routine Description :

   This routine processes the buffer containing read\write counters,
   and sets the appropriate fields in WMI_TAPE_PROBLEM_IO_ERROR 
   buffer.
   
Arguments :

 Srb            SCSI Request Block
 Read           TRUE if we are to process read counters. FALSE if it is 
                Write counters
 IoErrorData    Buffer in which to return counter values.
 
Return Value :

  None  
-*/
{
   USHORT paramCode;
   UCHAR  paramLen;
   LONG  bytesLeft;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PLOG_SENSE_PARAMETER_HEADER logSenseParamHeader;
   PUCHAR  paramValue = NULL;
   ULONG value;
   ULONG tmpVal;
   ULONG transferLength;

   logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
   
   ASSERT(((logSenseHeader->PageCode) == LOGSENSEPAGE2) ||
          ((logSenseHeader->PageCode) == LOGSENSEPAGE3));
   bytesLeft = logSenseHeader->Length[0];
   bytesLeft <<= 8;
   bytesLeft += logSenseHeader->Length[1];
   transferLength = Srb->DataTransferLength;

   if (bytesLeft > (LONG)(transferLength -
                          sizeof(LOG_SENSE_PAGE_HEADER))) {
       bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
   }
   DebugPrint((3, "ProcessReadWriteErrors : BytesLeft %x, TransferLength %x\n",
               bytesLeft, transferLength));

   (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseHeader + sizeof(LOG_SENSE_PAGE_HEADER);
   while (bytesLeft >= sizeof(LOG_SENSE_PARAMETER_HEADER)) {
      paramCode = logSenseParamHeader->ParameterCode[0];
      paramCode <<= 8;
      paramCode |= logSenseParamHeader->ParameterCode[1];
      paramLen = logSenseParamHeader->ParameterLength;
      paramValue = (PUCHAR)logSenseParamHeader + sizeof(LOG_SENSE_PARAMETER_HEADER);

      //
      // Make sure we have at least
      // (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen) bytes left.
      // Otherwise, we've reached the end of the buffer.
      //
      if (bytesLeft < (LONG)(sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)) {
          DebugPrint((1,
                      "ltotape : Reached end of buffer. BytesLeft %x, Expected %x\n",
                      bytesLeft,
                      (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)));
          break;
      }

      DebugPrint((3,
                  "ProcessReadWriteErrors : ParamCode %x, ParamLen %x\n",
                  paramCode, paramLen));
      switch (paramCode) {
         case TotalCorrectedErrors: {   
            value = (UCHAR)*(paramValue);
            value <<= 24;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 16;
            value += tmpVal;
            tmpVal = (UCHAR)*(paramValue+2);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+3);
            DebugPrint((3, "TotalCorrectedErrors %x\n", value));
            if (Read) {
               IoErrorData->ReadTotalCorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalCorrectedErrors = value;
            }
            break;
         }

         case TotalUncorrectedErrors: {
            value = (UCHAR)*(paramValue);
            value <<= 24;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 16;
            value += tmpVal;
            tmpVal = (UCHAR)*(paramValue+2);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+3);
            DebugPrint((3, "TotalUncorrectedErrors %x\n", value));
            if (Read) {
               IoErrorData->ReadTotalUncorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalUncorrectedErrors = value;
            }

            break;
         }

         case TotalTimesAlgorithmProcessed: {

            value = (UCHAR)*(paramValue);
            value <<= 24;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 16;
            value += tmpVal;
            tmpVal = (UCHAR)*(paramValue+2);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+3);
            DebugPrint((3, "TotalTimesAlgorithmProcessed %x\n", value));
            if (Read) {
               IoErrorData->ReadCorrectionAlgorithmProcessed = value;
            } else {
               IoErrorData->WriteCorrectionAlgorithmProcessed = value;
            }
            break;
         }

         default: {
            break;
         }
      } // switch (paramCode) 

      (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseParamHeader + 
                                    sizeof(LOG_SENSE_PARAMETER_HEADER) +
                                    paramLen;

      bytesLeft -= paramLen + sizeof(LOG_SENSE_PARAMETER_HEADER);
   } // while (bytesLeft > 0)

   if (Read) {
      IoErrorData->ReadTotalErrors = IoErrorData->ReadTotalUncorrectedErrors +
                                     IoErrorData->ReadTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: ReadErrors %x\n",
                  IoErrorData->ReadTotalErrors));
   } else {
      IoErrorData->WriteTotalErrors = IoErrorData->WriteTotalUncorrectedErrors +
                                      IoErrorData->WriteTotalCorrectedErrors;
      DebugPrint((3, "ProcessReadWriteErrors: WriteErrors %x\n",
                  IoErrorData->WriteTotalErrors));
   }
}

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   )
/*+

Routine Description :

   This routine looks at the read\write error counters.
   If the values are above a certain threshold, it returns
   appropriate error value.
   
Argument :

  IoErrorData  WMI_TAPE_PROBLEM_IO_ERROR struct
  
Return Value :
   
      TapeDriveReadWriteError If there are too many uncorrected 
                              read\write errors
                         
      TapeDriveReadWriteWarning If there are too many corrected
                                read\write errors 
                                
      TapeDriveProblemNone    If the read\write errors are below
                              threshold   
  
-*/
{
   if (((IoErrorData->ReadTotalUncorrectedErrors) >=
         TAPE_READ_ERROR_LIMIT)   ||       
       ((IoErrorData->WriteTotalUncorrectedErrors) >=
         TAPE_WRITE_ERROR_LIMIT)) {
      return TapeDriveReadWriteError;
   }

   if (((IoErrorData->ReadTotalCorrectedErrors) >=
         TAPE_READ_WARNING_LIMIT) ||
       ((IoErrorData->WriteTotalCorrectedErrors) >=
         TAPE_WRITE_WARNING_LIMIT)) {

      return TapeDriveReadWriteWarning;
   }

   return TapeDriveProblemNone;
}

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns device Error data such as "drive calibration"
   error, etc.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;
   PWMI_TAPE_PROBLEM_DEVICE_ERROR DeviceErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;
   ULONG bytesLeft;
   
   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   DeviceErrorData = (PWMI_TAPE_PROBLEM_DEVICE_ERROR)wmiData->TapeData;

   if (CallNumber == 0) {
      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(DeviceErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_DEVICE_ERROR));

      return PrepareSrbForTapeAlertInfo(Srb);
   }

   if (CallNumber == 1) {
       PTAPE_ALERT_INFO  tapeAlertInfo;
       PLOG_SENSE_PAGE_HEADER logSenseHeader;
       LONG  bytesLeft;
       UCHAR paramCode;
       UCHAR flagValue;

       bytesLeft = GetNumberOfBytesReturned(Srb);

       logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
       tapeAlertInfo= (PTAPE_ALERT_INFO)((PUCHAR)logSenseHeader +
                                         sizeof(LOG_SENSE_PAGE_HEADER));
       while (bytesLeft >= sizeof(TAPE_ALERT_INFO)) {
            //
            // ParamCode is 2 bytes long. Upper Byte is 0.
            // Lower Byte goes from 0x01 to 0x40. So, we just
            // pick up the lower byte
            //
            paramCode = tapeAlertInfo->ParamCodeLB;
            flagValue = tapeAlertInfo->Flag;
            ASSERT((tapeAlertInfo->ParamLen) == 1);
            DebugPrint((3, "QDED: ParamCode %x, FlagValue %x, ParamLen %x\n",
                        paramCode, flagValue, tapeAlertInfo->ParamLen));
            switch (paramCode) {
               case READ_WARNING: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : READ_WARNING\n"));
                     DeviceErrorData->ReadWarning = TRUE;
                     wmiData->DriveProblemType = TapeDriveReadWarning;
                  }
   
                  break;
               }
   
               case WRITE_WARNING: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : WRITE_WARNING\n"));
                     DeviceErrorData->WriteWarning = TRUE;
                     wmiData->DriveProblemType = TapeDriveWriteWarning;
                  }
   
                  break;
               }
   
               case HARD_ERROR: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : HARD_ERROR\n"));
                     DeviceErrorData->HardError = TRUE;
                     wmiData->DriveProblemType = TapeDriveHardwareError;
                  }
                  break;
               }
   
               case READ_FAILURE: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : READ_FAILURE\n"));
                     DeviceErrorData->ReadFailure = TRUE;
                     wmiData->DriveProblemType = TapeDriveReadError;
                  }
                  break;
               }
   
               case WRITE_FAILURE: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : WRITE_FAILURE\n"));
                     DeviceErrorData->WriteFailure = TRUE;
                     wmiData->DriveProblemType = TapeDriveWriteError;
                  }
                  break;
               }
   
               case CLEAN_NOW: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : CLEAN_NOW\n"));
                     DeviceErrorData->DriveRequiresCleaning = TRUE;
                     wmiData->DriveProblemType = TapeDriveCleanDriveNow;
                  }
                  break;
               }
   
               case HARDWARE_B: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : HARDWARE_B\n"));
                     DeviceErrorData->DriveHardwareError = TRUE;
                     wmiData->DriveProblemType = TapeDriveHardwareError;
                  }
                  break;
               }
   
               case INTERFACE_ERROR: {
                  if (flagValue) {
                     DebugPrint((3, "QueryDeviceErrorData : INTERFACE_ERROR\n"));
                     DeviceErrorData->ScsiInterfaceError = TRUE;
                     wmiData->DriveProblemType = TapeDriveScsiConnectionError;
                  }
                  break;
               }
   
               default:
                  break;
            } // switch (paramCode) {

            tapeAlertInfo++;
            bytesLeft -= sizeof(TAPE_ALERT_INFO);   
         }
   }

   return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
PrepareSrbForTapeAlertInfo(
    PSCSI_REQUEST_BLOCK Srb
    )
/*+++

Routine Description:

        This routine sets the SCSI_REQUEST_BLOCK to retrieve
        Tape Alert information from the drive

Arguements:

        Srb - Pointer to the SCSI_REQUEST_BLOCK

Return Value:

        TAPE_STATUS_SEND_SRB_AND_CALLBACK if Srb fields were successfully set.

        TAPE_STATUS_SUCCESS if there was not enough memory for Srb Databuffer.
                            case is not treated as an error.
--*/
{
    PCDB cdb = (PCDB)Srb->Cdb;
    ULONG allocLength;

    allocLength = sizeof(LOG_SENSE_PAGE_HEADER) +
                   (sizeof(TAPE_ALERT_INFO) * 0x40);
    if (!TapeClassAllocateSrbBuffer(Srb, allocLength)) {
       DebugPrint((1,
                   "PrepareSrbForTapeAlertInfo : No mem for logsense info\n"));
       return TAPE_STATUS_INSUFFICIENT_RESOURCES;
    }

    TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    //
    // Prepare SCSI command (CDB)
    //
    Srb->CdbLength = CDB10GENERIC_LENGTH;

    cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
    cdb->LOGSENSE.PageCode = TapeAlertLogPage;
    cdb->LOGSENSE.PCBit = 1;
    cdb->LOGSENSE.AllocationLength[0] = (UCHAR)((allocLength & 0xFF00) >> 8);
    cdb->LOGSENSE.AllocationLength[1] = (UCHAR)(allocLength & 0xFF);

    Srb->DataTransferLength = allocLength;
    return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
}

LONG
GetNumberOfBytesReturned(
    PSCSI_REQUEST_BLOCK Srb
    )
{
    PLOG_SENSE_PAGE_HEADER logSenseHeader;
    ULONG transferLength;
    LONG  bytesLeft;

    logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);

    ASSERT((logSenseHeader->PageCode) == TapeAlertLogPage);
    bytesLeft = logSenseHeader->Length[0];
    bytesLeft <<= 8;
    bytesLeft += logSenseHeader->Length[1];

    transferLength = Srb->DataTransferLength;

    if (bytesLeft > (LONG)(transferLength -
                           sizeof(LOG_SENSE_PAGE_HEADER))) {
        bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
    }

    DebugPrint((3, "GetNumberOfBytesReturned : BytesLeft %x, TransferLength %x\n",
                bytesLeft, transferLength));

    return bytesLeft;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\qic157\qic157.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    qic157.h

Abstract:

    This file contains structures and defines that are used
    specifically for the tape drivers.

Revision History:

--*/

#ifndef _QIC157_H
#define _QIC157_H

//
//  Internal (module wide) defines that symbolize
//  non-QFA mode and the two QFA mode partitions.
//
#define DATA_PARTITION          0  // non-QFA mode, or QFA mode, data partition #
#define DIRECTORY_PARTITION     1  // QFA mode, directory partition #


#define QIC157_SUPPORTED_TYPES 2


//
// Error counter upper limits
//
#define TAPE_READ_ERROR_LIMIT        0x8000
#define TAPE_WRITE_ERROR_LIMIT       0x8000

#define TAPE_READ_WARNING_LIMIT      0x4000
#define TAPE_WRITE_WARNING_LIMIT     0x4000

//
// Defines for Log Sense Pages
//
#define LOGSENSEPAGE0                        0x00
#define LOGSENSEPAGE3                        0x03

//
// Defines for parameter codes
//
#define ECCCorrectionsCode              0x0000
#define ReadRetriesCode                 0x0001
#define EventTrackECCCorrectionsCode    0x8020
#define OddTrackECCCorrectionsCode      0x8021
#define EventTrackRetriesCode           0x8022
#define OddTrackRetriesCode             0x8023

//
// Minitape extension definition.
//

typedef struct _MINITAPE_EXTENSION {

    ULONG                   CurrentPartition;
    MODE_CAPABILITIES_PAGE  CapabilitiesPage;

} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION;

//
// Defined Log Sense Page Header
//

typedef struct _LOG_SENSE_PAGE_HEADER {

   UCHAR PageCode : 6;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR Length[2];           // [0]=MSB ... [1]=LSB

} LOG_SENSE_PAGE_HEADER, *PLOG_SENSE_PAGE_HEADER;


//
// Defined Log Sense Parameter Header
//

typedef struct _LOG_SENSE_PARAMETER_HEADER {

   UCHAR ParameterCode[2];    // [0]=MSB ... [1]=LSB
   UCHAR LPBit     : 1;
   UCHAR Reserved1 : 1;
   UCHAR TMCBit    : 2;
   UCHAR ETCBit    : 1;
   UCHAR TSDBit    : 1;
   UCHAR DSBit     : 1;
   UCHAR DUBit     : 1;
   UCHAR ParameterLength;

} LOG_SENSE_PARAMETER_HEADER, *PLOG_SENSE_PARAMETER_HEADER;


//
// Defined Log Page Information - statistical values, accounts
// for maximum parameter values that is returned for each page
//

typedef struct _LOG_SENSE_PAGE_INFORMATION {

   union {

       struct {
          UCHAR Page0;
          UCHAR Page3;
       } PageData ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR ECCCorrections[4];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR ReadRetries[4];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR EvenTrackECCCorrections[4];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR OddTrackECCCorrections[4];
          LOG_SENSE_PARAMETER_HEADER Parm5;
          UCHAR EvenTrackReadRetries[4];
          LOG_SENSE_PARAMETER_HEADER Parm6;
          UCHAR OddTrackReadRetries[4];
       } Page3 ;

   } LogSensePage;


} LOG_SENSE_PAGE_INFORMATION, *PLOG_SENSE_PAGE_INFORMATION;



//
// Defined Log Sense Parameter Format - statistical values, accounts
// for maximum parameter values that is returned
//

typedef struct _LOG_SENSE_PARAMETER_FORMAT {

   LOG_SENSE_PAGE_HEADER       LogSenseHeader;
   LOG_SENSE_PAGE_INFORMATION  LogSensePageInfo;

} LOG_SENSE_PARAMETER_FORMAT, *PLOG_SENSE_PARAMETER_FORMAT;


BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

//
// Internal routines for wmi
//

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
  );

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   );

#endif // _QIC157_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\qic157\qic157.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    qic157.c

Abstract:

    This module contains device specific routines for QIC 157 (ATAPI)
    compliant tape drives.

Author:

    Norbert Kusters

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"
#include "qic157.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

STORAGE_MEDIA_TYPE Qic157Media[QIC157_SUPPORTED_TYPES] = {MiniQic, Travan};


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = TRUE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 600;
    tapeInitData.TapeError = NULL;
    tapeInitData.CommandExtensionSize = 0;;
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = QIC157_SUPPORTED_TYPES;

    tapeInitData.TapeWMIOperations = TapeWMIControl;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->CurrentPartition = 0;

    //
    // Check if we were given a valid 
    // ModeCapabilitiesPage. 
    //
    if (ModeCapabilitiesPage != NULL) {
       extension->CapabilitiesPage = *ModeCapabilitiesPage;
    } else {
       TapeClassZeroMemory(&(extension->CapabilitiesPage),
                           sizeof(MODE_CAPABILITIES_PAGE));
    }
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;
    PTAPE_CREATE_PARTITION  tapePartition = CommandParameters;
    PCDB                    cdb = (PCDB) Srb->Cdb;
    PMODE_MEDIUM_PART_PAGE  mediumPage;

    if (CallNumber == 0) {

        // Only FIXED QFA partitions are supported by this drive.

        if (tapePartition->Method != TAPE_FIXED_PARTITIONS ||
            !extension->CapabilitiesPage.QFA) {

            DebugPrint((1,
                        "Qic157.CreatePartition: returning STATUS_NOT_IMPLEMENTED.\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        // Make sure that the unit is ready.

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        // We need to rewind the tape before partitioning to QFA.

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_MEDIUM_PART_PAGE))) {
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        mediumPage = Srb->DataBuffer;

        //
        // Query the current values for the medium partition page.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;

        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 3) {

        mediumPage = Srb->DataBuffer;

        //
        // Verify that this device supports partitioning.
        //

        if (!mediumPage->MediumPartPage.FDPBit) {
            DebugPrint((1,
                        "Qic157.CreatePartition: returning INVALID_DEVICE_REQUEST.\n"));
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // Zero appropriate fields in the page data.
        //

        mediumPage->ParameterListHeader.ModeDataLength = 0;
        mediumPage->ParameterListHeader.MediumType = 0;

        mediumPage->MediumPartPage.PageLength = 0x06;

        //
        // Set partitioning via the medium partition page.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = 1;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;

        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE) - 4;
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 4);

    extension->CurrentPartition = DATA_PARTITION;

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    if (CallNumber == 0) {

        if (tapeErase->Type != TAPE_ERASE_LONG ||
            tapeErase->Immediate) {

            DebugPrint((1,
                        "Qic157.Erase: returning STATUS_NOT_IMPLEMENTED.\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Long = SETBITON;

        Srb->TimeOutValue = 600;

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB) Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (extension->CapabilitiesPage.ECC) {
            tapeGetDriveParams->ECC = TRUE;
            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_ECC;
        }

        if (extension->CapabilitiesPage.BLK512) {
            tapeGetDriveParams->MinimumBlockSize = 512;
        } else if (extension->CapabilitiesPage.BLK1024) {
            tapeGetDriveParams->MinimumBlockSize = 1024;
        } else {
            ASSERT(FALSE);
        }

        tapeGetDriveParams->DefaultBlockSize = tapeGetDriveParams->MinimumBlockSize;

        if (extension->CapabilitiesPage.BLK1024) {
            tapeGetDriveParams->MaximumBlockSize = 1024;
        } else if (extension->CapabilitiesPage.BLK512) {
            tapeGetDriveParams->MaximumBlockSize = 512;
        }

        if (extension->CapabilitiesPage.QFA) {
            tapeGetDriveParams->MaximumPartitionCount = 2;
            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_FIXED;
        } else {
            tapeGetDriveParams->MaximumPartitionCount = 0;
        }

        tapeGetDriveParams->FeaturesLow |=
                TAPE_DRIVE_ERASE_LONG |
                TAPE_DRIVE_ERASE_BOP_ONLY |
                TAPE_DRIVE_FIXED_BLOCK |
                TAPE_DRIVE_WRITE_PROTECT;

        tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_GET_LOGICAL_BLK;
        tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_GET_ABSOLUTE_BLK;

        tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_LOAD_UNLOAD;
        tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_TENSION;

        if (extension->CapabilitiesPage.UNLOAD) {
            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_EJECT_MEDIA;
        }
        if (extension->CapabilitiesPage.LOCK) {
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_LOCK_UNLOCK;
        }

        if (extension->CapabilitiesPage.BLK512 &&
            extension->CapabilitiesPage.BLK1024) {

            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_BLOCK_SIZE;
        }

        tapeGetDriveParams->FeaturesHigh |=
                TAPE_DRIVE_LOGICAL_BLK  |
                TAPE_DRIVE_ABSOLUTE_BLK |
                TAPE_DRIVE_END_OF_DATA  |
                TAPE_DRIVE_FILEMARKS;

        if (extension->CapabilitiesPage.SPREV) {
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_REVERSE_POSITION;
        }

        tapeGetDriveParams->FeaturesHigh |=
                TAPE_DRIVE_WRITE_FILEMARKS;

        if (extension->CapabilitiesPage.CMPRS) {

            // Do a mode sense for the compression page.

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DATA_COMPRESS_PAGE))) {
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }

            compressionModeSenseBuffer = Srb->DataBuffer;

            TapeClassZeroMemory(compressionModeSenseBuffer, sizeof(MODE_DATA_COMPRESS_PAGE));

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

            Srb->CdbLength = CDB6GENERIC_LENGTH;

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.Dbd = SETBITON;
            cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        } else {
            tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;
            return TAPE_STATUS_SUCCESS;
        }
    }

    ASSERT(CallNumber == 1);

    compressionModeSenseBuffer = Srb->DataBuffer;

    if (compressionModeSenseBuffer->DataCompressPage.DCC) {

        tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
        tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
        tapeGetDriveParams->Compression =
            (compressionModeSenseBuffer->DataCompressPage.DCE ? TRUE : FALSE);
    }

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_MEDIUM_PART_PAGE_PLUS mediumPage;

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));

        // Test unit ready.

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        // Do a mode sense for the medium capabilities page.

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_MEDIUM_PART_PAGE_PLUS))) {
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        mediumPage = Srb->DataBuffer;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_MEDIUM_PART_PAGE_PLUS) - 4;

        //
        // Send SCSI command (CDB) to device
        //

        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE_PLUS) - 4;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 2);

    mediumPage = Srb->DataBuffer;

    tapeGetMediaParams->BlockSize = mediumPage->ParameterListBlock.BlockLength[2];
    tapeGetMediaParams->BlockSize += (mediumPage->ParameterListBlock.BlockLength[1] << 8);
    tapeGetMediaParams->BlockSize += (mediumPage->ParameterListBlock.BlockLength[0] << 16);
    tapeGetMediaParams->WriteProtected =
        ((mediumPage->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01);

    if (mediumPage->MediumPartPage.FDPBit) {
        tapeGetMediaParams->PartitionCount = 2;
    } else {
        tapeGetMediaParams->PartitionCount = 0;
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;
    PTAPE_GET_POSITION      tapeGetPosition = CommandParameters;
    PCDB                    cdb = (PCDB) Srb->Cdb;
    PTAPE_POSITION_DATA     tapePosBuffer;

    if (CallNumber == 0) {

        tapeGetPosition->Partition = 0;
        tapeGetPosition->Offset.QuadPart = 0;

        // test unit ready.

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        // Perform a get position call.

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(TAPE_POSITION_DATA))) {
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        tapePosBuffer = Srb->DataBuffer;

        TapeClassZeroMemory(tapePosBuffer, sizeof(TAPE_POSITION_DATA));

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB10GENERIC_LENGTH;

        cdb->READ_POSITION.Operation = SCSIOP_READ_POSITION;
        if (tapeGetPosition->Type == TAPE_ABSOLUTE_POSITION) {
            cdb->READ_POSITION.BlockType = SETBITON;
        }

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 2);

    // Interpret READ POSITION data.

    tapePosBuffer = Srb->DataBuffer;

    if (tapeGetPosition->Type == TAPE_LOGICAL_POSITION) {
        extension->CurrentPartition = tapePosBuffer->PartitionNumber;
        tapeGetPosition->Partition = extension->CurrentPartition + 1;
    }

    REVERSE_BYTES((PFOUR_BYTE)&tapeGetPosition->Offset.LowPart,
                  (PFOUR_BYTE)tapePosBuffer->FirstBlock);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Status requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PCDB    cdb = (PCDB) Srb->Cdb;

    if (CallNumber == 0) {

        // Just do a test unit ready.

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Prepare requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;
    PTAPE_PREPARE           tapePrepare = CommandParameters;
    PCDB                    cdb = (PCDB)Srb->Cdb;

    if (CallNumber == 0) {

        if (tapePrepare->Immediate) {
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        // Prepare SCSI command (CDB)

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        switch (tapePrepare->Operation) {
            case TAPE_LOAD:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_UNLOAD:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_TENSION:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_LOAD_UNLOAD;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x03;
                Srb->TimeOutValue = 1800;
                break;

            case TAPE_LOCK:
                if (!extension->CapabilitiesPage.LOCK) {
                    return TAPE_STATUS_NOT_IMPLEMENTED;
                }
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = 0x01;
                Srb->TimeOutValue = 180;
                break;

            case TAPE_UNLOCK:
                if (!extension->CapabilitiesPage.LOCK) {
                    return TAPE_STATUS_NOT_IMPLEMENTED;
                }
                cdb->CDB6GENERIC.OperationCode = SCSIOP_MEDIUM_REMOVAL;
                Srb->TimeOutValue = 180;
                break;

            default:
                DebugPrint((1,
                            "Qic157.Prepare: returning STATUS_NOT_IMPLEMENTED.\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_DRIVE_PARAMETERS  tapeSetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PMODE_DATA_COMPRESS_PAGE    compressionBuffer;

    if (CallNumber == 0) {

        if (!extension->CapabilitiesPage.CMPRS) {
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        // Make a request for the data compression page.

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DATA_COMPRESS_PAGE))) {
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionBuffer = Srb->DataBuffer;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        compressionBuffer = Srb->DataBuffer;

        // If compression is not supported then we are done.

        if (!compressionBuffer->DataCompressPage.DCC) {
            return TAPE_STATUS_SUCCESS;
        }

        // Set compression on or off via a MODE SELECT operation.

        if (tapeSetDriveParams->Compression) {
            compressionBuffer->DataCompressPage.DCE = 1;
        } else {
            compressionBuffer->DataCompressPage.DCE = 0;
        }

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        Srb->DataTransferLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 2);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_SET_MEDIA_PARAMETERS  tapeSetMediaParams = CommandParameters;
    PMODE_PARM_READ_WRITE_DATA  modeBuffer;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    if (CallNumber == 0) {

        if (!extension->CapabilitiesPage.BLK512 ||
            !extension->CapabilitiesPage.BLK1024) {

            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        if (tapeSetMediaParams->BlockSize != 512 &&
            tapeSetMediaParams->BlockSize != 1024) {

            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        // Test unit ready.

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        // Issue a mode sense.

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        modeBuffer = Srb->DataBuffer;

        TapeClassZeroMemory(modeBuffer, sizeof(MODE_PARM_READ_WRITE_DATA));

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        // Issue a mode select.

        modeBuffer = Srb->DataBuffer;

        modeBuffer->ParameterListHeader.ModeDataLength = 0;
        modeBuffer->ParameterListHeader.MediumType = 0;
        modeBuffer->ParameterListHeader.DeviceSpecificParameter = 0x10;
        modeBuffer->ParameterListHeader.BlockDescriptorLength =
            MODE_BLOCK_DESC_LENGTH;

        modeBuffer->ParameterListBlock.BlockLength[0] = (UCHAR)
            ((tapeSetMediaParams->BlockSize >> 16) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[1] = (UCHAR)
            ((tapeSetMediaParams->BlockSize >> 8) & 0xFF);
        modeBuffer->ParameterListBlock.BlockLength[2] = (UCHAR)
            (tapeSetMediaParams->BlockSize & 0xFF);

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_PARM_READ_WRITE_DATA);

        Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA);
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 3);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Set Position requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;
    PTAPE_SET_POSITION      tapeSetPosition = CommandParameters;
    PCDB                    cdb = (PCDB)Srb->Cdb;
    ULONG                   tapePositionVector;
    ULONG                   method;

    if (CallNumber == 0) {

        if (tapeSetPosition->Immediate) {
            DebugPrint((1,
                        "Qic157.SetPosition: returning STATUS_NOT_IMPLEMENTED.\n"));
            return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        method = tapeSetPosition->Method;
        tapePositionVector = tapeSetPosition->Offset.LowPart;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        switch (method) {
            case TAPE_REWIND:
                cdb->CDB6GENERIC.OperationCode = SCSIOP_REWIND;
                Srb->TimeOutValue = 600;
                break;

            case TAPE_LOGICAL_BLOCK:

                Srb->CdbLength = CDB10GENERIC_LENGTH;
                cdb->LOCATE.OperationCode = SCSIOP_LOCATE;
                if (tapeSetPosition->Partition) {
                    cdb->LOCATE.CPBit = 1;
                    cdb->LOCATE.Partition = (UCHAR) tapeSetPosition->Partition - 1;
                }

                cdb->LOCATE.LogicalBlockAddress[0] =
                    (UCHAR)((tapePositionVector >> 24) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[1] =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[2] =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->LOCATE.LogicalBlockAddress[3] =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 600;
                break;

            case TAPE_SPACE_END_OF_DATA:
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 3;
                Srb->TimeOutValue = 600;
                break;

            case TAPE_SPACE_FILEMARKS:
                cdb->SPACE_TAPE_MARKS.OperationCode = SCSIOP_SPACE;
                cdb->SPACE_TAPE_MARKS.Code = 1;
                cdb->SPACE_TAPE_MARKS.NumMarksMSB =
                    (UCHAR)((tapePositionVector >> 16) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarks =
                    (UCHAR)((tapePositionVector >> 8) & 0xFF);
                cdb->SPACE_TAPE_MARKS.NumMarksLSB =
                    (UCHAR)(tapePositionVector & 0xFF);
                Srb->TimeOutValue = 4100;

                if (((cdb->SPACE_TAPE_MARKS.NumMarksMSB) & 0x80) &&
                    extension->CapabilitiesPage.SPREV == 0) {

                    DebugPrint((1,
                                "Qic157.CreatePartition: returning INVALID_DEVICE_REQUEST - Space in Rev (filemarks).\n"));
                    //
                    // Can't do a SPACE in reverse.
                    //

                    return TAPE_STATUS_INVALID_DEVICE_REQUEST;
                }
                break;

            case TAPE_SPACE_RELATIVE_BLOCKS:
            case TAPE_SPACE_SEQUENTIAL_FMKS:
            case TAPE_SPACE_SETMARKS:
            case TAPE_SPACE_SEQUENTIAL_SMKS:
            default:
                DebugPrint((1,
                            "Qic157.SetPosition: returning STATUS_NOT_IMPLEMENTED.\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Write Marks requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_WRITE_MARKS  tapeWriteMarks = CommandParameters;
    PCDB               cdb = (PCDB)Srb->Cdb;

    if (CallNumber == 0) {

        switch (tapeWriteMarks->Type) {
            case TAPE_FILEMARKS:
                break;

            case TAPE_SETMARKS:
            case TAPE_SHORT_FILEMARKS:
            case TAPE_LONG_FILEMARKS:
            default:
                DebugPrint((1,
                            "Qic157.WriteMarks: returning STATUS_NOT_IMPLEMENTED.\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }

        if (tapeWriteMarks->Immediate) {

            DebugPrint((1,
                        "Qic157 WriteMarks: Attempted to write FM immediate.\n"));
            return TAPE_STATUS_INVALID_PARAMETER;
        }

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->WRITE_TAPE_MARKS.OperationCode = SCSIOP_WRITE_FILEMARKS;
        cdb->WRITE_TAPE_MARKS.Immediate = tapeWriteMarks->Immediate;

        if (tapeWriteMarks->Count > 1) {
            DebugPrint((1,
                        "Qic157 WriteMarks: Attempted to write more than one mark.\n"));
            return TAPE_STATUS_INVALID_PARAMETER;
        }
        //
        // Only supports writing one.
        //

        cdb->WRITE_TAPE_MARKS.TransferLength[2] = (UCHAR)tapeWriteMarks->Count;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}



TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for TapeGetMediaTypes.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/
{
    PGET_MEDIA_TYPES  mediaTypes = CommandParameters;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    PCDB               cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"GetMediaTypes: Enter routine\n"));

    if (CallNumber == 0) {

        *RetryFlags = RETURN_ERRORS;
        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if ((LastError == TAPE_STATUS_BUS_RESET) || (LastError == TAPE_STATUS_MEDIA_CHANGED) || (LastError == TAPE_STATUS_SUCCESS)) {
        if (CallNumber == 1) {

            //
            // Zero the buffer, including the first media info.
            //

            TapeClassZeroMemory(mediaTypes, sizeof(GET_MEDIA_TYPES));

            //
            // Build mode sense to get header and bd.
            //

            if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_PARM_READ_WRITE_DATA))) {
                return TAPE_STATUS_INSUFFICIENT_RESOURCES;
            }


            TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_PARM_READ_WRITE_DATA));

            TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);
            Srb->CdbLength = CDB6GENERIC_LENGTH;
            Srb->DataTransferLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
            cdb->MODE_SENSE.AllocationLength = sizeof(MODE_PARM_READ_WRITE_DATA);

            return TAPE_STATUS_SEND_SRB_AND_CALLBACK;

        }
    }

    if ((CallNumber == 2) || ((CallNumber == 1) && (LastError != TAPE_STATUS_SUCCESS))) {

        ULONG i;
        ULONG currentMedia;
        ULONG blockSize;
        UCHAR mediaType;
        PMODE_PARM_READ_WRITE_DATA configInformation = Srb->DataBuffer;

        mediaTypes->DeviceType = 0x0000001f; // FILE_DEVICE_TAPE;

        //
        // Currently, only 2 types (either mc or travan) are returned.
        //

        mediaTypes->MediaInfoCount = 2;


        if ( LastError == TAPE_STATUS_SUCCESS ) {
            //
            // Determine the media type currently loaded.
            //

            mediaType = configInformation->ParameterListHeader.MediumType;
            blockSize = configInformation->ParameterListBlock.BlockLength[2];
            blockSize |= (configInformation->ParameterListBlock.BlockLength[1] << 8);
            blockSize |= (configInformation->ParameterListBlock.BlockLength[0] << 16);

            DebugPrint((1,
                        "GetMediaTypes: MediaType %x, Current Block Size %x\n",
                        mediaType,
                        blockSize));


            switch (mediaType) {

                case 0x83:
                case 0x86:
                case 0x87:
                case 0x91:
                case 0x92:
                case 0x93:
                case 0xA1:
                case 0xC3:
                case 0xC6:
                case 0xD3:

                    //
                    // MC media
                    //

                    currentMedia = MiniQic;
                    break;

                case 0xB6:
                case 0xB7:
                case 0x85:

                    //
                    // travan
                    //

                    currentMedia = Travan;
                    break;

                default:

                    //
                    // Unknown, assume miniqic
                    //

                    currentMedia = MiniQic;
                    break;
            }
        } else {
            currentMedia = 0;
        }

        //
        // fill in buffer based on spec. values
        // Only one type supported now.
        //

        for (i = 0; i < mediaTypes->MediaInfoCount; i++) {

            TapeClassZeroMemory(mediaInfo, sizeof(DEVICE_MEDIA_INFO));

            mediaInfo->DeviceSpecific.TapeInfo.MediaType = Qic157Media[i];

            //
            // Indicate that the media potentially is read/write
            //

            mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics = MEDIA_READ_WRITE;

            if (Qic157Media[i] == (STORAGE_MEDIA_TYPE)currentMedia) {

                //
                // This media type is currently mounted.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;

                //
                // Indicate whether the media is write protected.
                //

                mediaInfo->DeviceSpecific.TapeInfo.MediaCharacteristics |=
                    ((configInformation->ParameterListHeader.DeviceSpecificParameter >> 7) & 0x01) ? MEDIA_WRITE_PROTECTED : 0;


                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.MediumType = mediaType;
                mediaInfo->DeviceSpecific.TapeInfo.BusSpecificData.ScsiInformation.DensityCode =
                    configInformation->ParameterListBlock.DensityCode;

                mediaInfo->DeviceSpecific.TapeInfo.BusType = 0x02;

                //
                // Fill in current blocksize.
                //

                mediaInfo->DeviceSpecific.TapeInfo.CurrentBlockSize = blockSize;
            }

            //
            // Advance to next array entry.
            //

            mediaInfo++;
        }

    }

    return TAPE_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\sonyait\sonyait.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    sonyait.h

Abstract:

    This file contains structures and defines that are used
    specifically for the tape drivers.

Revision History:

--*/

#ifndef _SONYAIT_H
#define _SONYAIT_H
//
//  Internal (module wide) defines that symbolize
//  the 8mm drives supported by this module.
//

#define SONY_300      0x01
#define SONY_500      0x02

#define AIT_SUPPORTED_TYPES 2

#define SONY_CLEANING_REQUEST 0x80

//
// Minitape extension definition.
//

typedef struct _MINITAPE_EXTENSION {

    ULONG   DriveID;
    ULONG   Capacity;
    ULONG   CurrentPartition;
} MINITAPE_EXTENSION, *PMINITAPE_EXTENSION;

//
// Command extension definition.
//
typedef struct _COMMAND_EXTENSION {

    ULONG   CurrentState;

} COMMAND_EXTENSION, *PCOMMAND_EXTENSION;


//
// Request structure used to determine cleaning needs, and remaining tape
// capacity.
//

typedef struct _AIT_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FRUC;
    UCHAR SenseKeySpecific[3];
    UCHAR Reserved3;
    UCHAR RWDataErrors[3];
    UCHAR Remaining[4];
    UCHAR MEW:1;
    UCHAR Reserved4:2;
    UCHAR CleaningReq:1;
    UCHAR Reserved5:4;
    UCHAR Reserved6;
} AIT_SENSE_DATA, *PAIT_SENSE_DATA;

//
// Error counter upper limits
//
#define TAPE_READ_ERROR_LIMIT        0x8000
#define TAPE_WRITE_ERROR_LIMIT       0x8000

#define TAPE_READ_WARNING_LIMIT      0x4000
#define TAPE_WRITE_WARNING_LIMIT     0x4000

//
// Defines for type of parameter
//
#define TotalCorrectedErrors            0x0003
#define TotalTimesAlgorithmProcessed    0x0004
#define TotalGroupsProcessed            0x0005
#define TotalUncorrectedErrors          0x0006

//
// Defines for Log Sense Pages
//
#define LOGSENSEPAGE0                        0x00
#define LOGSENSEPAGE2                        0x02
#define LOGSENSEPAGE3                        0x03

//
// Defined Log Sense Page Header
//

typedef struct _LOG_SENSE_PAGE_HEADER {

   UCHAR PageCode : 6;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR Length[2];           // [0]=MSB ... [1]=LSB

} LOG_SENSE_PAGE_HEADER, *PLOG_SENSE_PAGE_HEADER;


//
// Defined Log Sense Parameter Header
//

typedef struct _LOG_SENSE_PARAMETER_HEADER {

   UCHAR ParameterCode[2];    // [0]=MSB ... [1]=LSB
   UCHAR LPBit     : 1;
   UCHAR Reserved1 : 1;
   UCHAR TMCBit    : 2;
   UCHAR ETCBit    : 1;
   UCHAR TSDBit    : 1;
   UCHAR DSBit     : 1;
   UCHAR DUBit     : 1;
   UCHAR ParameterLength;

} LOG_SENSE_PARAMETER_HEADER, *PLOG_SENSE_PARAMETER_HEADER;

//
// Defined Log Page Information - statistical values, accounts
// for maximum parameter values that is returned for each page
//

typedef struct _LOG_SENSE_PAGE_INFORMATION {

   union {

       struct {
          UCHAR Page0;
          UCHAR Page2;
          UCHAR Page3;
          UCHAR Page30;
          UCHAR Page31;
       } PageData ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR TotalErrorsCorrected[2];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR TotalTimesAlgoProcessed[4];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR TotalGroupsWritten[4];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR TotalErrorsUncorrected[2];
       } Page2 ;

       struct {
          LOG_SENSE_PARAMETER_HEADER Parm1;
          UCHAR TotalErrorsCorrected[2];
          LOG_SENSE_PARAMETER_HEADER Parm2;
          UCHAR TotalTimesAlgoProcessed[4];
          LOG_SENSE_PARAMETER_HEADER Parm3;
          UCHAR TotalGroupsWritten[4];
          LOG_SENSE_PARAMETER_HEADER Parm4;
          UCHAR TotalErrorsUncorrected[2];
       } Page3 ;
   } LogSensePage;

} LOG_SENSE_PAGE_INFORMATION, *PLOG_SENSE_PAGE_INFORMATION;

//
// Defined Log Sense Parameter Format - statistical values, accounts
// for maximum parameter values that is returned
//

typedef struct _LOG_SENSE_PARAMETER_FORMAT {

   LOG_SENSE_PAGE_HEADER       LogSenseHeader;
   LOG_SENSE_PAGE_INFORMATION  LogSensePageInfo;

} LOG_SENSE_PARAMETER_FORMAT, *PLOG_SENSE_PARAMETER_FORMAT;


//
//  Function prototype(s) for internal function(s)
//
static  ULONG  WhichIsIt(IN PINQUIRYDATA InquiryData,
                         IN OUT PMINITAPE_EXTENSION miniExtension);




BOOLEAN
VerifyInquiry(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetStatus(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
Prepare(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
SetPosition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
WriteMarks(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

TAPE_STATUS
GetMediaTypes(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN OUT  TAPE_STATUS         *LastError
    );


TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    );

//
// Internal routines for wmi
//

TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

TAPE_STATUS
QueryDeviceErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  );

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
  );

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   );

#endif // _SONYAIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\qic157\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for qic157 tape drives.

Environment:

    kernel mode only

Revision History:

--*/

#include "minitape.h"
#include "qic157.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TapeWMIControl)
#pragma alloc_text(PAGE, ProcessReadWriteErrors)
#pragma alloc_text(PAGE, QueryIoErrorData)
#pragma alloc_text(PAGE, VerifyReadWriteErrors)
#endif

TAPE_STATUS
TapeWMIControl(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )
/*+
Routine Description:

   This is the common entry point for all WMI calls from tape class driver.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PMINITAPE_EXTENSION miniExtension;

   miniExtension = (PMINITAPE_EXTENSION)MinitapeExtension;
   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;

   switch (wmiOperations->Method) {
      case TAPE_CHECK_FOR_DRIVE_PROBLEM: {
         
         return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                 CommandParameters, Srb, CallNumber,
                                 LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_IO_ERROR_DATA: {
         return QueryIoErrorData(MinitapeExtension, CommandExtension,
                                 CommandParameters, Srb, CallNumber,
                                 LastError, RetryFlags);
         break;
      }

      case TAPE_QUERY_DEVICE_ERROR_DATA: {
         return TAPE_STATUS_NOT_IMPLEMENTED;
         break;
      }

      default: {
         return TAPE_STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   } // switch (wmiOperations->Method) 
}


TAPE_STATUS
QueryIoErrorData(
  IN OUT  PVOID               MinitapeExtension,
  IN OUT  PVOID               CommandExtension,
  IN OUT  PVOID               CommandParameters,
  IN OUT  PSCSI_REQUEST_BLOCK Srb,
  IN      ULONG               CallNumber,
  IN      TAPE_STATUS         LastError,
  IN OUT  PULONG              RetryFlags
  )

/*+
Routine Description:

   This routine returns IO Error data such as read\write errors.
   
Arguments:

   MinitapeExtension   Pointer to the minidriver's device extension
   CommandExtension    Pointer to the minidriver's command extension
   CommandParameters   Pointer to TAPE_WMI_OPERATIONS struct
   Srb                 SCSI Request block
   CallNumber          Call sequence number
   LastError           Last command error
   RetryFlags          Bit mask for retrying commands
   
Return value:

   TAPE_STATUS
-*/
{
   PTAPE_WMI_OPERATIONS wmiOperations;
   PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData;
   PWMI_TAPE_PROBLEM_WARNING wmiData;
   TAPE_STATUS  status = TAPE_STATUS_SUCCESS;
   PCDB cdb = (PCDB)Srb->Cdb;

   wmiOperations = (PTAPE_WMI_OPERATIONS)CommandParameters;
   wmiData = (PWMI_TAPE_PROBLEM_WARNING)wmiOperations->DataBuffer;
   IoErrorData = (PWMI_TAPE_PROBLEM_IO_ERROR)&(wmiData->TapeData);

   if (CallNumber == 0) {
      if (!TapeClassAllocateSrbBuffer(Srb, 
                                      sizeof(LOG_SENSE_PARAMETER_FORMAT))) {
         DebugPrint((1, "QueryIoErrorData : No memory for log sense info\n"));
         return TAPE_STATUS_INSUFFICIENT_RESOURCES;
      }

      wmiData->DriveProblemType = TapeDriveProblemNone;
      TapeClassZeroMemory(IoErrorData, 
                          sizeof(WMI_TAPE_PROBLEM_IO_ERROR));
      TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

      //
      // Prepare SCSI command (CDB)
      //
      Srb->CdbLength = CDB10GENERIC_LENGTH;

      cdb->LOGSENSE.OperationCode = SCSIOP_LOG_SENSE;
      cdb->LOGSENSE.PageCode = LOGSENSEPAGE3;
      cdb->LOGSENSE.PCBit = 1;
      cdb->LOGSENSE.AllocationLength[0] = sizeof(LOG_SENSE_PARAMETER_FORMAT) >> 8;
      cdb->LOGSENSE.AllocationLength[1] = sizeof(LOG_SENSE_PARAMETER_FORMAT);

      Srb->DataTransferLength = sizeof(LOG_SENSE_PARAMETER_FORMAT);
      return  TAPE_STATUS_SEND_SRB_AND_CALLBACK;
   }

   if (CallNumber == 1) {
      ProcessReadWriteErrors(Srb, TRUE, IoErrorData);

      wmiData->DriveProblemType = VerifyReadWriteErrors(IoErrorData);
      DebugPrint((3, "QueryIoErrorData : DriveProblemType %x\n",
                  wmiData->DriveProblemType));
   }

   return TAPE_STATUS_SUCCESS;
}

VOID
ProcessReadWriteErrors(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN BOOLEAN Read,
    IN OUT PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
)
/*+
Routine Description :

   This routine processes the buffer containing read\write counters,
   and sets the appropriate fields in WMI_TAPE_PROBLEM_IO_ERROR 
   buffer.
   
Arguments :

 Srb            SCSI Request Block
 Read           TRUE if we are to process read counters. FALSE if it is 
                Write counters
 IoErrorData    Buffer in which to return counter values.
 
Return Value :

  None  
-*/
{
   USHORT paramCode;
   UCHAR  paramLen;
   LONG   bytesLeft;
   PLOG_SENSE_PAGE_HEADER logSenseHeader;
   PLOG_SENSE_PARAMETER_HEADER logSenseParamHeader;
   PUCHAR  paramValue = NULL;
   ULONG value;
   ULONG tmpVal;
   ULONG transferLength;

   logSenseHeader = (PLOG_SENSE_PAGE_HEADER)(Srb->DataBuffer);
   
   ASSERT(((logSenseHeader->PageCode) == LOGSENSEPAGE2) ||
          ((logSenseHeader->PageCode) == LOGSENSEPAGE3));
   bytesLeft = logSenseHeader->Length[0];
   bytesLeft <<= 8;
   bytesLeft += logSenseHeader->Length[1];

   transferLength = Srb->DataTransferLength;

   if (bytesLeft > (LONG)(transferLength -
                          sizeof(LOG_SENSE_PAGE_HEADER))) {
       bytesLeft = transferLength - sizeof(LOG_SENSE_PAGE_HEADER);
   }

   DebugPrint((3, "ProcessReadWriteErrors: BytesLeft %x, TransferLength %x\n",
               bytesLeft, transferLength));

   (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseHeader + sizeof(LOG_SENSE_PAGE_HEADER);
   while (bytesLeft >= sizeof(LOG_SENSE_PARAMETER_HEADER)) {
      paramCode = logSenseParamHeader->ParameterCode[0];
      paramCode <<= 8;
      paramCode |= logSenseParamHeader->ParameterCode[1];
      paramLen = logSenseParamHeader->ParameterLength;
      paramValue = (PUCHAR)logSenseParamHeader + sizeof(LOG_SENSE_PARAMETER_HEADER);

      //
      // Make sure we have at least
      // (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen) bytes left.
      // Otherwise, we've reached the end of the buffer.
      //
      if (bytesLeft < (LONG)(sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)) {
          DebugPrint((1,
                      "qic157 : Reached end of buffer. BytesLeft %x, Expected %x\n",
                      bytesLeft,
                      (sizeof(LOG_SENSE_PARAMETER_HEADER) + paramLen)));
          break;
      }
      DebugPrint((3, "ProcessReadWriteErrors: paramCode %x, paramLen %x\n",
                  paramCode, paramLen));
      switch (paramCode) {
         case ReadRetriesCode: {   
            value = (UCHAR)*(paramValue);
            value <<= 24;
            tmpVal = (UCHAR)*(paramValue+1);
            tmpVal <<= 16;
            value += tmpVal;
            tmpVal = (UCHAR)*(paramValue+2);
            tmpVal <<= 8;
            value += tmpVal + (UCHAR)*(paramValue+3);

            if (Read) {
               IoErrorData->ReadTotalCorrectedErrors = value;
            } else {
               IoErrorData->WriteTotalCorrectedErrors = value;
            }
            break;
         }

         default: {
            break;
         }
      } // switch (paramCode) 

      (PUCHAR)logSenseParamHeader = (PUCHAR)logSenseParamHeader + 
                                    sizeof(LOG_SENSE_PARAMETER_HEADER) +
                                    paramLen;

      bytesLeft -= paramLen + sizeof(LOG_SENSE_PARAMETER_HEADER);
   } // while (bytesLeft > 0)

   if (Read) {
      IoErrorData->ReadTotalErrors = IoErrorData->ReadTotalUncorrectedErrors +
                                     IoErrorData->ReadTotalCorrectedErrors;
   } else {
      IoErrorData->WriteTotalErrors = IoErrorData->WriteTotalUncorrectedErrors +
                                      IoErrorData->WriteTotalCorrectedErrors;
   }
}

TAPE_DRIVE_PROBLEM_TYPE
VerifyReadWriteErrors(
   IN PWMI_TAPE_PROBLEM_IO_ERROR IoErrorData
   )
/*+

Routine Description :

   This routine looks at the read\write error counters.
   If the values are above a certain threshold, it returns
   appropriate error value.
   
Argument :

  IoErrorData  WMI_TAPE_PROBLEM_IO_ERROR struct
  
Return Value :
   
      TapeDriveReadWriteError If there are too many uncorrected 
                              read\write errors
                         
      TapeDriveReadWriteWarning If there are too many corrected
                                read\write errors 
                                
      TapeDriveProblemNone    If the read\write errors are below
                              threshold   
  
-*/
{
   if (((IoErrorData->ReadTotalUncorrectedErrors) >=
         TAPE_READ_ERROR_LIMIT)   ||       
       ((IoErrorData->WriteTotalUncorrectedErrors) >=
         TAPE_WRITE_ERROR_LIMIT)) {
      return TapeDriveReadWriteError;
   }

   if (((IoErrorData->ReadTotalCorrectedErrors) >=
         TAPE_READ_WARNING_LIMIT) ||
       ((IoErrorData->WriteTotalCorrectedErrors) >=
         TAPE_WRITE_WARNING_LIMIT)) {

      return TapeDriveReadWriteWarning;
   }

   return TapeDriveProblemNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tape\drivers\sonyait\sonyait.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    sonyait.c

Abstract:

    This module contains the device-specific routines for the Sony
    SDX-300 tape drive.

Author:


Environment:

    kernel mode only

Revision History:


--*/

#include "minitape.h"
#include "sonyait.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CreatePartition)
#pragma alloc_text(PAGE, Erase)
#pragma alloc_text(PAGE, ExtensionInit)
#pragma alloc_text(PAGE, GetDriveParameters)
#pragma alloc_text(PAGE, GetMediaParameters)
#pragma alloc_text(PAGE, GetMediaTypes)
#pragma alloc_text(PAGE, GetPosition)
#pragma alloc_text(PAGE, GetStatus)
#pragma alloc_text(PAGE, Prepare)
#pragma alloc_text(PAGE, SetDriveParameters)
#pragma alloc_text(PAGE, SetMediaParameters)
#pragma alloc_text(PAGE, SetPosition)
#pragma alloc_text(PAGE, WhichIsIt)
#pragma alloc_text(PAGE, WriteMarks)
#endif

STORAGE_MEDIA_TYPE AITMedia[AIT_SUPPORTED_TYPES] = {AIT1_8mm, CLEANER_CARTRIDGE};


ULONG
DriverEntry(
    IN PVOID Argument1,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Driver entry point for tape minitape driver.

Arguments:

    Argument1   - Supplies the first argument.

    Argument2   - Supplies the second argument.

Return Value:

    Status from TapeClassInitialize()

--*/

{
    TAPE_INIT_DATA_EX  tapeInitData;

    TapeClassZeroMemory( &tapeInitData, sizeof(TAPE_INIT_DATA_EX));

    tapeInitData.InitDataSize = sizeof(TAPE_INIT_DATA_EX);
    tapeInitData.VerifyInquiry = NULL;
    tapeInitData.QueryModeCapabilitiesPage = FALSE ;
    tapeInitData.MinitapeExtensionSize = sizeof(MINITAPE_EXTENSION);
    tapeInitData.ExtensionInit = ExtensionInit;
    tapeInitData.DefaultTimeOutValue = 360;
    tapeInitData.TapeError = TapeError;
    tapeInitData.CommandExtensionSize = sizeof(COMMAND_EXTENSION);
    tapeInitData.CreatePartition = CreatePartition;
    tapeInitData.Erase = Erase;
    tapeInitData.GetDriveParameters = GetDriveParameters;
    tapeInitData.GetMediaParameters = GetMediaParameters;
    tapeInitData.GetPosition = GetPosition;
    tapeInitData.GetStatus = GetStatus;
    tapeInitData.Prepare = Prepare;
    tapeInitData.SetDriveParameters = SetDriveParameters;
    tapeInitData.SetMediaParameters = SetMediaParameters;
    tapeInitData.SetPosition = SetPosition;
    tapeInitData.WriteMarks = WriteMarks;
    tapeInitData.TapeGetMediaTypes = GetMediaTypes;
    tapeInitData.MediaTypesSupported = AIT_SUPPORTED_TYPES;
    tapeInitData.TapeWMIOperations = TapeWMIControl;

    return TapeClassInitialize(Argument1, Argument2, &tapeInitData);
}


VOID
ExtensionInit(
    OUT PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    )

/*++

Routine Description:

    This routine is called at driver initialization time to
    initialize the minitape extension.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

Return Value:

    None.

--*/

{
    PMINITAPE_EXTENSION     extension = MinitapeExtension;

    extension->DriveID = WhichIsIt(InquiryData, extension);
}

TAPE_STATUS
CreatePartition(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Create Partition requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.
    CommandExtension    - Supplies the ioctl extension.
    CommandParameters   - Supplies the command parameters.
    Srb                 - Supplies the SCSI request block.
    CallNumber          - Supplies the call number.
    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION          tapeExtension = MinitapeExtension;
    PTAPE_CREATE_PARTITION       tapeCreatePartition = CommandParameters;
    PMODE_PARAMETER_HEADER       parameterListHeader;
    PMODE_PARAMETER_BLOCK        parameterListBlock;
    PMODE_MEDIUM_PARTITION_PAGE  mediumPartPage;
    PMODE_TAPE_MEDIA_INFORMATION mediaInformation;
    ULONG                        partitionMethod;
    ULONG                        partitionCount;
    PCDB                         cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeCreatePartition: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY ;
    }

    if (CallNumber == 1) {

        //
        // Build mode sense for the medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_MEDIUM_PART_PAGE_PLUS))) {

            DebugPrint((1,
                        "sonyait.TapeCreatePartition: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_MEDIUM_PART_PAGE_PLUS));
        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE_PLUS);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_MEDIUM_PART_PAGE_PLUS);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if (CallNumber == 2) {

        //
        // Issued the mode sense of the partition page successfully.
        //

        mediaInformation = Srb->DataBuffer;

        //
        // Extract each of the sub-blocks from the mode sense info.
        //

        parameterListHeader = &mediaInformation->ParameterListHeader;
        parameterListBlock = &mediaInformation->ParameterListBlock;
        mediumPartPage = &mediaInformation->MediumPartPage;

        parameterListHeader->ModeDataLength = 0;
        parameterListHeader->MediumType = 0;

        //
        // Get the count and method.
        //

        partitionCount = tapeCreatePartition->Count;
        partitionMethod = tapeCreatePartition->Method;

        switch (partitionCount) {

        case 0:
        case 1:
        case 2:
            break;

            //
            // Currently only a max. of 2 partitions is allowed.
            //


        default:
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        switch (partitionMethod) {
        case TAPE_FIXED_PARTITIONS:

            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
            break;

        case TAPE_SELECT_PARTITIONS:

            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
            break;

        case TAPE_INITIATOR_PARTITIONS:
            mediumPartPage->IDPBit = 1;
            mediumPartPage->PSUMBit = 2;
            if (partitionCount == 0) {
                mediumPartPage->AdditionalPartitionDefined = 0;
                mediumPartPage->Partition1Size[0] = 0;
                mediumPartPage->Partition1Size[1] = 0;
            } else {
                mediumPartPage->AdditionalPartitionDefined = (UCHAR)(partitionCount - 1);
                mediumPartPage->Partition1Size[0] = (UCHAR)((tapeCreatePartition->Size >> 8) & 0xFF);
                mediumPartPage->Partition1Size[1] = (UCHAR)(tapeCreatePartition->Size & 0xFF);
            }

            break;

        default:
            return TAPE_STATUS_INVALID_DEVICE_REQUEST;
        }

        Srb->CdbLength = CDB6GENERIC_LENGTH ;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = SETBITON;
        cdb->MODE_SELECT.ParameterListLength = sizeof(MODE_MEDIUM_PART_PAGE_PLUS);

        Srb->TimeOutValue = 16500;
        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE_PLUS);
        Srb->SrbFlags |= SRB_FLAGS_DATA_OUT ;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;
    }

    if (CallNumber == 3) {

        //
        // Build mode sense for the medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE))) {

            DebugPrint((1,
                        "sonyait.TapeCreatePartition: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK ;

    }

    if (CallNumber == 4) {

        PMODE_DEVICE_CONFIG_PAGE deviceConfig = Srb->DataBuffer;
        PMODE_PARAMETER_HEADER       parameterListHeader = &deviceConfig->ParameterListHeader;
        PMODE_DEVICE_CONFIGURATION_PAGE  deviceConfigPage = &deviceConfig->DeviceConfigPage;

        tapeExtension->CurrentPartition = deviceConfigPage->ActivePartition;
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
Erase(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for an Erase requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PTAPE_ERASE        tapeErase = CommandParameters;
    PCDB               cdb = (PCDB) Srb->Cdb;

    DebugPrint((3,"TapeErase: Enter routine\n"));

    if (CallNumber == 0) {

        if (tapeErase->Immediate) {
            switch (tapeErase->Type) {
                case TAPE_ERASE_LONG:
                    DebugPrint((3,"TapeErase: immediate, long\n"));
                    break;

                case TAPE_ERASE_SHORT:
                    DebugPrint((3,"TapeErase: immediate, short\n"));
                    break;

                default:
                    DebugPrint((1,"TapeErase: EraseType, immediate -- operation not supported\n"));
                    return TAPE_STATUS_NOT_IMPLEMENTED;
            }
        }

        switch (tapeErase->Type) {
            case TAPE_ERASE_LONG:
                DebugPrint((3,"TapeErase: long\n"));
                break;

            case TAPE_ERASE_SHORT:
                DebugPrint((3,"TapeErase: short\n"));
                break;
            default:
                DebugPrint((1,"TapeErase: EraseType -- operation not supported\n"));
                return TAPE_STATUS_NOT_IMPLEMENTED;
        }


        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = 0;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->ERASE.OperationCode = SCSIOP_ERASE;
        cdb->ERASE.Immediate = tapeErase->Immediate;
        cdb->ERASE.Long = (tapeErase->Type == TAPE_ERASE_LONG) ? SETBITON : 0;

        //
        // Set timeout value.
        //

        Srb->TimeOutValue = 18000;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeErase: SendSrb (erase)\n"));

        Srb->DataTransferLength = 0;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(CallNumber == 1);

    return TAPE_STATUS_SUCCESS;
}

VOID
TapeError(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      TAPE_STATUS         *LastError
    )

/*++

Routine Description:

    This routine is called for tape requests, to handle tape
    specific errors: it may/can update the status.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    Srb                 - Supplies the SCSI request block.

    LastError           - Status used to set the IRP's completion status.

    Retry - Indicates that this request should be retried.

Return Value:

    None.

--*/

{
    PSENSE_DATA        senseBuffer;
    UCHAR              senseKey;
    UCHAR              adSense;
    UCHAR              adSenseQ;

    DebugPrint((3,"TapeError: Enter routine\n"));
    DebugPrint((1,"TapeError: Status 0x%.8X\n", *LastError));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       senseBuffer = Srb->SenseInfoBuffer;
       senseKey = senseBuffer->SenseKey & 0x0F;
       adSense = senseBuffer->AdditionalSenseCode;
       adSenseQ = senseBuffer->AdditionalSenseCodeQualifier;

       if (senseKey == SCSI_SENSE_NO_SENSE) {
           if ((adSense == SONY_CLEANING_REQUEST)) {
               *LastError = TAPE_STATUS_REQUIRES_CLEANING;
           }
       } else if (senseKey == SCSI_SENSE_NOT_READY) {
           if ((adSense == SCSI_ADSENSE_INVALID_MEDIA) &&
               (adSenseQ == SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED)) {
               *LastError = TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED;
           }
       }
    }

    DebugPrint((1,"TapeError: Status 0x%.8X \n", *LastError));

    return;

} // end TapeError()


TAPE_STATUS
GetDriveParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Drive Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PCOMMAND_EXTENSION          commandExtension = CommandExtension;
    PTAPE_GET_DRIVE_PARAMETERS  tapeGetDriveParams = CommandParameters;
    PCDB                        cdb = (PCDB)Srb->Cdb;
    PINQUIRYDATA                inquiryBuffer;
    PMODE_DEVICE_CONFIG_PAGE    deviceConfigModeSenseBuffer;
    PMODE_DATA_COMPRESS_PAGE    compressionModeSenseBuffer;
    PREAD_BLOCK_LIMITS_DATA     blockLimits;

    DebugPrint((3,"TapeGetDriveParameters: Enter routine\n"));

    if (CallNumber == 0) {

        TapeClassZeroMemory(tapeGetDriveParams, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DEVICE_CONFIG_PAGE))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (modeParmBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceConfigModeSenseBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CONFIG;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        Srb->DataTransferLength = sizeof(MODE_DEVICE_CONFIG_PAGE) - 1;

        *RetryFlags |= RETURN_ERRORS;
        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 1) {

        if (LastError == TAPE_STATUS_SUCCESS) {
            deviceConfigModeSenseBuffer = Srb->DataBuffer;

            tapeGetDriveParams->ReportSetmarks =
                (deviceConfigModeSenseBuffer->DeviceConfigPage.RSmk? 1 : 0 );

            commandExtension->CurrentState = 0;

        } else if (LastError == TAPE_STATUS_NO_MEDIA) {

            //
            // Work around FW - this will get chk condition, if no media.
            // Make the assumption that RSmk is set (as it's the default).
            //

            tapeGetDriveParams->ReportSetmarks = 1;
            commandExtension->CurrentState = 0;

        } else {
            return LastError;
        }
    }

    if (commandExtension->CurrentState == 0) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_DATA_COMPRESS_PAGE))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (compressionModeSenseBuffer)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        compressionModeSenseBuffer = Srb->DataBuffer;

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = SETBITON;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_DATA_COMPRESS;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_DATA_COMPRESS_PAGE);

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (mode sense)\n"));

        commandExtension->CurrentState = 1;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (commandExtension->CurrentState == 1) {

        compressionModeSenseBuffer = Srb->DataBuffer;

        if (compressionModeSenseBuffer->DataCompressPage.DCC) {
            tapeGetDriveParams->FeaturesLow |= TAPE_DRIVE_COMPRESSION;
            tapeGetDriveParams->FeaturesHigh |= TAPE_DRIVE_SET_COMPRESSION;
            tapeGetDriveParams->Compression =
                (compressionModeSenseBuffer->DataCompressPage.DCE? TRUE : FALSE);
        }

        commandExtension->CurrentState = 2;
    }

    if (commandExtension->CurrentState == 2) {

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(READ_BLOCK_LIMITS_DATA))) {
            DebugPrint((1,"TapeGetDriveParameters: insufficient resources (blockLimits)\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        blockLimits = Srb->DataBuffer;

        //
        // Zero CDB in SRB on stack.
        //

        TapeClassZeroMemory(cdb, MAXIMUM_CDB_SIZE);

        //
        // Prepare SCSI command (CDB)
        //

        Srb->CdbLength = CDB6GENERIC_LENGTH;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_BLOCK_LIMITS;

        //
        // Send SCSI command (CDB) to device
        //

        DebugPrint((3,"TapeGetDriveParameters: SendSrb (read block limits)\n"));

        commandExtension->CurrentState = 3;

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    ASSERT(commandExtension->CurrentState == 3);

    blockLimits = Srb->DataBuffer;

    tapeGetDriveParams->MaximumBlockSize =  blockLimits->BlockMaximumSize[2];
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[1] << 8);
    tapeGetDriveParams->MaximumBlockSize += (blockLimits->BlockMaximumSize[0] << 16);

    tapeGetDriveParams->MinimumBlockSize =  blockLimits->BlockMinimumSize[1];
    tapeGetDriveParams->MinimumBlockSize += (blockLimits->BlockMinimumSize[0] << 8);

    tapeGetDriveParams->ECC = 0;
    tapeGetDriveParams->DataPadding = 0;
    tapeGetDriveParams->MaximumPartitionCount = 2;
    tapeGetDriveParams->DefaultBlockSize = 1024;

    tapeGetDriveParams->FeaturesLow |=
        TAPE_DRIVE_TAPE_CAPACITY    |
        TAPE_DRIVE_TAPE_REMAINING   |
        TAPE_DRIVE_ERASE_SHORT      |
        TAPE_DRIVE_ERASE_LONG       |
        TAPE_DRIVE_ERASE_IMMEDIATE  |
        TAPE_DRIVE_FIXED_BLOCK      |
        TAPE_DRIVE_VARIABLE_BLOCK   |
        TAPE_DRIVE_WRITE_PROTECT    |
        TAPE_DRIVE_GET_ABSOLUTE_BLK |
        TAPE_DRIVE_GET_LOGICAL_BLK  |
        TAPE_DRIVE_REPORT_SMKS      |
        TAPE_DRIVE_ECC              |
        TAPE_DRIVE_INITIATOR        |
        TAPE_DRIVE_CLEAN_REQUESTS   |
        TAPE_DRIVE_EJECT_MEDIA;

    tapeGetDriveParams->FeaturesHigh |=
        TAPE_DRIVE_LOAD_UNLOAD       |
        TAPE_DRIVE_REWIND_IMMEDIATE  |
        TAPE_DRIVE_LOCK_UNLOCK       |
        TAPE_DRIVE_SET_BLOCK_SIZE    |
        TAPE_DRIVE_LOAD_UNLD_IMMED   |
        TAPE_DRIVE_SET_REPORT_SMKS   |
        TAPE_DRIVE_RELATIVE_BLKS     |
        TAPE_DRIVE_FILEMARKS         |
        TAPE_DRIVE_SETMARKS          |
        TAPE_DRIVE_REVERSE_POSITION  |
        TAPE_DRIVE_WRITE_SETMARKS    |
        TAPE_DRIVE_WRITE_FILEMARKS   |
        TAPE_DRIVE_WRITE_MARK_IMMED  |
        TAPE_DRIVE_SEQUENTIAL_FMKS   |
        TAPE_DRIVE_SEQUENTIAL_SMKS   |
        TAPE_DRIVE_ABSOLUTE_BLK      |
        TAPE_DRIVE_ABS_BLK_IMMED     |
        TAPE_DRIVE_LOGICAL_BLK       |
        TAPE_DRIVE_LOG_BLK_IMMED     |
        TAPE_DRIVE_END_OF_DATA;

    tapeGetDriveParams->FeaturesHigh &= ~TAPE_DRIVE_HIGH_FEATURES;

    switch (extension->DriveID) {
      case SONY_300:
      case SONY_500: {
           // 
           // SDX-300 does not support spacing over sequential
           // filemarks and setmarks
           //
         tapeGetDriveParams->FeaturesHigh &= ~(TAPE_DRIVE_SEQUENTIAL_FMKS |
                                               TAPE_DRIVE_SEQUENTIAL_SMKS);
         break;
      }

      default:
       break;
    }

    return TAPE_STATUS_SUCCESS;
}

TAPE_STATUS
GetMediaParameters(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         LastError,
    IN OUT  PULONG              RetryFlags
    )

/*++

Routine Description:

    This is the TAPE COMMAND routine for a Get Media Parameters requests.

Arguments:

    MinitapeExtension   - Supplies the minitape extension.

    CommandExtension    - Supplies the ioctl extension.

    CommandParameters   - Supplies the command parameters.

    Srb                 - Supplies the SCSI request block.

    CallNumber          - Supplies the call number.

    RetryFlags          - Supplies the retry flags.

Return Value:

    TAPE_STATUS_SEND_SRB_AND_CALLBACK   - The SRB is ready to be sent
                                            (a callback is requested.)

    TAPE_STATUS_SUCCESS                 - The command is complete and
                                            successful.

    Otherwise                           - An error occurred.

--*/

{
    PMINITAPE_EXTENSION         extension = MinitapeExtension;
    PTAPE_GET_MEDIA_PARAMETERS  tapeGetMediaParams = CommandParameters;
    PMODE_TAPE_MEDIA_INFORMATION mediaInformation;
    PAIT_SENSE_DATA              senseData;
    ULONG                       remaining;
    PCDB                        cdb = (PCDB)Srb->Cdb;

    DebugPrint((3,"TapeGetMediaParameters: Enter routine\n"));

    if (CallNumber == 0) {

        return TAPE_STATUS_CHECK_TEST_UNIT_READY;
    }

    if (CallNumber == 1) {

        TapeClassZeroMemory(tapeGetMediaParams, sizeof(TAPE_GET_MEDIA_PARAMETERS));

        //
        // Build mode sense for medium partition page.
        //

        if (!TapeClassAllocateSrbBuffer(Srb, sizeof(MODE_MEDIUM_PART_PAGE_PLUS))) {

            DebugPrint((1,
                        "sonyait.TapeGetMediaParameters: Couldn't allocate Srb Buffer\n"));
            return TAPE_STATUS_INSUFFICIENT_RESOURCES;
        }

        TapeClassZeroMemory(Srb->DataBuffer, sizeof(MODE_MEDIUM_PART_PAGE_PLUS));
        Srb->CdbLength = CDB6GENERIC_LENGTH;
        Srb->DataTransferLength = sizeof(MODE_MEDIUM_PART_PAGE_PLUS);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_MEDIUM_PARTITION;
        cdb->MODE_SENSE.AllocationLength = sizeof(MODE_MEDIUM_PART_PAGE_PLUS);

        return TAPE_STATUS_SEND_SRB_AND_CALLBACK;
    }

    if (CallNumber == 2) {

        ULONG partitionCount;

        mediaInformation = Srb->DataBuffer;

        tapeGetMediaParams->BlockSize = mediaInformation->ParameterListBlock.BlockLength[2];
        tapeGetMediaParams->BlockSize += (mediaInformation->ParameterListBlock.BlockLength[1] << 8);
        tapeGetMediaParams->BlockSize += (mediaInformation->ParameterListBlock.BlockLength[0] << 16);

        tapeGetMediaP