(!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((PBYTE)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !GetData( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !GetData( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (ULONG_PTR)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}


/*
 * 'ptr' points to a structure in our address space which is described by the MEMBERLIST bp.
 * Print out the structure according to the MEMBERLIST
 */
VOID
PrintMemberList( IN VOID *ptr, IN MEMBERLIST *bp )
{
    int i;
    PCSTR nl = "\n";
    PCSTR sep = " ";
    PCSTR nlsep = "\n    ";
    DWORD d;

    for( i=0; bp->name; i++, bp++ ) {

        if( (i&1) == 0 )
            dprintf( "    " );

        if( bp->type == 'T' ) {
            dprintf( "%s -- TABLE FOLLOWS -->\n", bp->name );

        } else if( strlen( bp->name ) > 30 ) {
            dprintf( "%-.17s...%s ", bp->name, bp->name+strlen(bp->name)-10 );

        } else {
            dprintf( "%-30s ", bp->name );
        }

        switch( bp->type ) {
        case 'R':
//          dprintf( "%-16X%s", (ULONG_PTR)ptr, i&1 ? nl : sep );
            break;

        case 'C':
            dprintf( "%-16X%s",
                (*(UCHAR *)(((char *)ptr) + bp->offset )) & 0xFF ,
                i&1 ? nl : sep );
            break;

        case 'B':
            dprintf( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + bp->offset ) ? "TRUE" : "FALSE",
                i&1 ? nl : sep );
            break;
        case 'H':
        case 'P':
            dprintf( "%-16X%s",
                *(ULONG *)(((char *)ptr) + bp->offset ),
                i&1 ? nl : sep );
            break;
        case 'N':
            //
            // IP Address
            //
            d = *(ULONG *)(((char *)ptr) + bp->offset );
            dprintf( "%-3.3u.%-3.3u.%-3.3u.%-3.3u %s",
                (d&0xFF),
                (d&0xFF00)>>8,
                (d&0xFF0000)>>16,
                (d&0xFF000000)>>24,
                i&1 ? nl : sep );
            break;
        case 'U':
        case 'L':
            dprintf( "%-16d%s",
                *(ULONG *)(((char *)ptr) + bp->offset ),
                i&1 ? nl : sep );
            break;
        case '6':
            {
            ULONGLONG l;
            RtlCopyMemory( &l, ((char *)ptr) + bp->offset, sizeof( l ) );
            dprintf( "%I64u%s", l, i&1 ? nl : sep );
            }
            break;
        case 'S':
            dprintf( "%-16X%s",
                *(SHORT *)(((char *)ptr) + bp->offset ) & 0xFFFF,
                i&1 ? nl : sep );
            break;
        case 'W':
            if( i&1 ) dprintf( nlsep );
            PrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + bp->offset ), NL );
            i |= 1;
            break;
        case 'A':
            if( i&1 ) dprintf( nlsep );
            PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + bp->offset ), NL );
            i |= 1;
            break;
        case 'I':
        {
            UCHAR SymbolName[ 200 ];
            ULONG_PTR Displacement;
            PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + bp->offset ));

            GetSymbol( sym, SymbolName, &Displacement );
            dprintf( "%-16s\n", SymbolName );
            i |= 1;
        }
            break;

        case 'T':
            DumpTable( (PTABLE_HEADER)(((char *)ptr) + bp->offset) );
            dprintf( "  --- End Of %s Table ---\n", bp->name );
            i |= 1;
            break;

        case 'K':
        {
            UCHAR Type = *(UCHAR *)(((char *)ptr) + bp->offset );

            if( Type < 0 || Type >= BlockTypeMax )
                dprintf( "%-16X%s", Type, i&1 ? nl : sep );
            else
                dprintf( "%-16s%s", BlockType[ Type ], i&1 ? nl : sep );
        }
            break;

        case 'Q':
        {
            UCHAR State = *(UCHAR *)(((char *)ptr) + bp->offset );
            if( State < 0 || State >= BlockStateMax )
                dprintf( "%-16X%s", State, i&1 ? nl : sep );
            else
                dprintf( "%-16s%s", BlockState[ State ], i&1 ? nl : sep );
        }
            break;

        case 'Z':
            if( i&1 ) dprintf( nl );
            PrintListEntryList( *(ULONG *)(((char *)ptr) + bp->offset ), -(bp->extra) );
            i |= 1;
            break;

        default:
            ERRPRT( "Unrecognized field type %c for %s\n", bp->type, bp->name );
            break;
        }
    }

    if( i & 1 )
        dprintf( "\n" );
}

/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}

/*
 *  Print out the TABLE structure at TABLE_HEADER
 */
BOOL
DumpTable( IN PTABLE_HEADER pt )
{
    LONG i;
    PTABLE_ENTRY pte;
    BOOL bEmpty = TRUE;

    PrintMemberList( pt, ML_TABLE_HEADER );

    if( pt->TableSize < 0 ) {
        ERRPRT( "    ILLEGAL TABLE SIZE\n" );
        return FALSE;
    }

    if( pt->FirstFreeEntry > pt->TableSize ) {
        ERRPRT( "    ILLEGAL FirstFreeEntry\n" );
        return FALSE;
    }

    if( pt->LastFreeEntry > pt->TableSize ) {
        ERRPRT( "    ILLEGAL LastFreeEntry\n" );
        return FALSE;
    }

    pte = (PTABLE_ENTRY)LocalAlloc( LPTR, pt->TableSize * sizeof( TABLE_ENTRY ) );
    if( pte == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    if( !GetData( pte, (ULONG_PTR)pt->Table, pt->TableSize * sizeof(TABLE_ENTRY), "TABLE_ENTRY" ) ) {
        LocalFree( (HLOCAL)pte );
        return FALSE;
    }

    for( i=0; i < pt->TableSize; i++ ) {

        if( pte[i].Owner != NULL ) {
            bEmpty = FALSE;
            dprintf( "%d-%X ", i, pte[i].Owner );
        }

        if( pte[i].NextFreeEntry > pt->TableSize ) {
            ERRPRT( "  ILLEGAL NextFreeEntry %d-%d\n    ", i, pte[i].NextFreeEntry );
            LocalFree( (HLOCAL)pte );
            return FALSE;
        }
    }

    dprintf( "\n" );
    LocalFree( (HLOCAL)pte );

    if( bEmpty )
        dprintf( "    ** Empty Table**\n    " );

    return TRUE;
}

/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

/*
 * Check out the BLOCK_HEADER structure, ensuring its Type is 'Desired'.
 * If bRefCount == TRUE, ensure the BLOCK_HEADER's reference is > 0
 */
BOOL
CheckBlockHeader( IN PBLOCK_HEADER ph, IN UCHAR Desired, IN BOOL bRefCount )
{
    if( ph->Type != Desired ) {
        ERRPRT( "BLOCK_HEADER.Type is %X, should be %X\n",
          ph->Type, Desired );
        return FALSE;
    }

    if( ph->State < 0 || ph->State >= BlockStateMax ) {
        ERRPRT( "  BLOCK_HEADER.State is %X:  INVALID\n", ph->State );
        return FALSE;
    }

    if( ph->Size == 0 ) {
        ERRPRT( "  BLOCK_HEADER ILLEGAL SIZE!\n" );
        return FALSE;
    }

    if( bRefCount && ph->ReferenceCount == 0 ) {
        ERRPRT( "  BLOCK_HEADER.ReferenceCount == 0!\n" );
        return FALSE;
    }

    return TRUE;
}

/*
 * Print out the BLOCK_HEADER, and optionally its ReferenceCount
 */
BOOL
PrintBlockHeader( IN PBLOCK_HEADER ph, IN BOOL bRefCount )
{
    dprintf( "BLOCK_HEADER Info:  " );
    if( ph->State < 0 || ph->State >= BlockStateMax ) {
        ERRPRT( "State is %X:  INVALID\n", ph->State );
        return FALSE;
    }

    dprintf( "%s", BlockState[ ph->State ] );

    if( ph->Type < 0 || ph->Type >= BlockTypeMax ) {
        ERRPRT( "\nBlockType is %X:  INVALID\n", ph->Type );
        return FALSE;
    }

    dprintf( ", %s", BlockType[ ph->Type ] );
    dprintf( ", Size %u", ph->Size );

    if( ph->Size == 0 ) {
        ERRPRT( "  BLOCK_HEADER ILLEGAL SIZE!\n" );
        return FALSE;
    }

    dprintf( ", ReferenceCount %u", ph->ReferenceCount );


    dprintf( "\n" );

    return TRUE;
}

/*
 * Print out the NONPAGED_HEADER structure, ensuring its type is 'Desired', that
 * it points back to its paged block at 'dwPagedBlock'.
 */
BOOL
PrintNonpagedHeader(
    IN PNONPAGED_HEADER ph,
    IN ULONG Desired,
    IN ULONG_PTR dwPagedBlock,
    IN BOOL bRefCount
)
{
    dprintf( "NONPAGED_HEADER Info:  " );
    if( ph->Type != Desired ) {
        ERRPRT( "NONPAGED_HEADER.Type is %X, should be %X\n",
          ph->Type, Desired );
        return FALSE;
    }
    if( bRefCount && ph->ReferenceCount == 0 ) {
        ERRPRT( "  NONPAGED_HEADER.ReferenceCount == 0!\n" );
        return FALSE;
    }
    if( (ULONG_PTR)ph->PagedBlock != dwPagedBlock ) {
        ERRPRT( "    NONPAGED_HEADER.PagedBlock is %X, should be %X\n", ph->PagedBlock, dwPagedBlock );
        return FALSE;
    }

    if( bRefCount )
        dprintf( "ReferenceCount %u\n", ph->ReferenceCount, ph->PagedBlock );

    return TRUE;
}

BOOL
DumpShare( IN ULONG_PTR dwAddress, IN SHARE_TYPE type, IN PCSTR ShareName OPTIONAL, OUT PLIST_ENTRY *Flink OPTIONAL )
{
    BOOL     b;
    SHARE    Share;

    if( !GetData( &Share, dwAddress, sizeof( Share ), "SHARE" ) ||
        !CheckBlockHeader( &Share.BlockHeader, BlockTypeShare, TRUE ) ) {

        return FALSE;
    }

    if( ARGUMENT_PRESENT( Flink ) ) {
        *Flink = Share.GlobalShareList.Flink;
    }

    if( type != (SHARE_TYPE)-1 && type != Share.ShareType ) {
        return TRUE;
    }

    if( ARGUMENT_PRESENT( ShareName ) ) {
        //
        // Only print this share structure out if the name is 'ShareName'
        //

        PWCHAR    StringData;
        ULONG BytesRead;
        CHAR   NameBuf[ MAX_PATH ];

        if( Share.ShareName.Length == 0 ) {
            return TRUE;
        }

        StringData = LocalAlloc(LPTR,Share.ShareName.Length + sizeof(UNICODE_NULL));
        if( StringData == NULL ) {
            dprintf( "Out of memory!\n" );
            return FALSE;
        }

        ReadMemory( (ULONG_PTR)Share.ShareName.Buffer, StringData, Share.ShareName.Length, &BytesRead );

        if (BytesRead == 0 )  {
            LocalFree( (HLOCAL)StringData );
            return FALSE;
        }

        StringData[ Share.ShareName.Length / sizeof( WCHAR ) ] = '\0';
        wcstombs( NameBuf, StringData, sizeof( NameBuf ) );
        LocalFree( (HLOCAL)StringData);

        if( _strcmpi( NameBuf, ShareName ) ) {
            return TRUE;
        }
    }

    dprintf( "\nSHARE at %X: ", dwAddress );

    PrintBlockHeader( &Share.BlockHeader, TRUE );
    dprintf( "    " );

    switch( Share.ShareType ) {
    case ShareTypeDisk:
        dprintf( "ShareTypeDisk\n" );
        break;
    case ShareTypePrint:
        dprintf( "ShareTypePrint, Type.hPrinter = %X  ", Share.Type.hPrinter );
        break;
    case ShareTypePipe:
        dprintf( "ShareTypePipe\n" );
        break;
    case ShareTypeWild:
        dprintf( "ShareTypeWild\n" );
        break;
    default:
        ERRPRT( "ShareType %X : INVALID!\n", Share.ShareType );
        return FALSE;
    }

    PrintMemberList( &Share, ML_SHARE );

    if( Share.CurrentUses > Share.MaxUses ) {
        ERRPRT( "    CurrentUses exceeds MaxUses!\n" );
        return FALSE;
    }

    dprintf( "\n" );


    return TRUE;
}

BOOL
DumpLock( IN ULONG_PTR dwAddress )
{
    SRV_LOCK sl;
    char namebuf[ 50 ];
    int i;

    if( !GetData( &sl, dwAddress, sizeof(sl), "ERESOURCE" ) )
        return FALSE;

    dprintf( "    ActiveCount %u, ",dwAddress, sl.ActiveCount );
    switch( sl.Flag ) {
    case ResourceNeverExclusive:
        dprintf( "ResourceNeverExclusive, " );
        break;
    case ResourceReleaseByOtherThread:
        dprintf( "ResourceReleaseByOtherThread, " );
        break;
    case ResourceOwnedExclusive:
        dprintf( "ResourceOwnedExclusive, " );
        break;
    default:
        ERRPRT( "Flag = %X%s, ", sl.Flag, sl.Flag ? "(?)" : "" );
        break;
    }
    dprintf( "SpinLock %d\n", sl.SpinLock );

    for( i=0; i < 2; i++ ) {
        if( sl.OwnerThreads[i].OwnerThread == 0 && sl.OwnerThreads[i].OwnerCount == 0 )
            continue;
        dprintf( "        OwnerThreads[%d].OwnerThread %X, OwnerCount %d\n",
            i, sl.OwnerThreads[i].OwnerThread, sl.OwnerThreads[i].OwnerCount );
    }

    return TRUE;
}

BOOL
DumpEndpoint( IN ULONG_PTR dwAddress, IN PLIST_ENTRY *Flink OPTIONAL )
{
    ENDPOINT    Endpoint;

    dprintf( "\nENDPOINT at %X: ", dwAddress );
    if( !GetData( &Endpoint, dwAddress, sizeof( Endpoint ), "ENDPOINT" ) ||
      !CheckBlockHeader( &Endpoint.BlockHeader, BlockTypeEndpoint, TRUE ) ||
      !PrintBlockHeader( &Endpoint.BlockHeader, TRUE ) ) {

        return FALSE;
    }

    PrintMemberList( &Endpoint, ML_ENDPOINT );

    dprintf( "    NetworkAddressData: %ws\n", Endpoint.NetworkAddressData );

    if( ARGUMENT_PRESENT( Flink ) )
        *Flink = Endpoint.GlobalEndpointListEntry.ListEntry.Flink;

    return TRUE;
}

BOOL
DumpSearch( IN ULONG_PTR dwAddress )
{
    SEARCH s;

    dprintf( "\nSEARCH at %X: ", dwAddress );

    if( !GetData( &s, dwAddress, sizeof(s), "SEARCH" ) ||
        !PrintBlockHeader( &s.BlockHeader, TRUE ) ) {
        return FALSE;
    }

    PrintMemberList( &s, ML_SEARCH );

    return TRUE;
}

BOOL
DumpBuffer( IN ULONG_PTR dwAddress )
{
    BUFFER b;

    dprintf( "\nBUFFER at %X:\n", dwAddress );

    if( !GetData( &b, dwAddress, sizeof(b), "BUFFER" ) )
        return FALSE;

    PrintMemberList( &b, ML_BUFFER );

    return TRUE;
}

BOOL
DumpSmb( IN ULONG_PTR dwAddress )
{
    NT_SMB_HEADER s;
    UCHAR WordCount;

    dprintf( "\nSMB_HEADER at %X\n", dwAddress );

    if( !GetData( &s, dwAddress, sizeof(s), "SMBHEADER" ) )
        return FALSE;

    PrintMemberList( &s, ML_SMB_HEADER );

    if( !GetData( &WordCount, dwAddress+sizeof( NT_SMB_HEADER ), sizeof( WordCount), "WordCount" )){
        ERRPRT( "Unable to retrieve WordCount at %X\n", dwAddress+sizeof(NT_SMB_HEADER) );
        return FALSE;
    }

    dprintf( "\nWordCount @ %X = %u\n", dwAddress + sizeof( NT_SMB_HEADER), WordCount );

    return TRUE;
}

BOOL
DumpTcon( IN ULONG_PTR dwAddress, IN DWORD offset, IN DWORD *value OPTIONAL )
{
    TREE_CONNECT Tcon;
    NONPAGED_HEADER NonpagedHeader;

    dprintf( "\nTREE_CONNECT at %X: ", dwAddress );

    if( !GetData( &Tcon, dwAddress, sizeof( Tcon ), "TREE_CONNECT" ) ||
      !CheckBlockHeader( &Tcon.BlockHeader, BlockTypeTreeConnect, FALSE ) ||
      !GetData( &NonpagedHeader, (ULONG_PTR)Tcon.NonpagedHeader, sizeof(NonpagedHeader),"NONPAGED_HEADER" ) ) {

        return FALSE;
    }

    if( !PrintBlockHeader( &Tcon.BlockHeader, FALSE ) ||
        !PrintNonpagedHeader( &NonpagedHeader, BlockTypeTreeConnect, dwAddress, TRUE ) ) {
        return FALSE;
    }

    PrintMemberList( &Tcon, ML_TREE_CONNECT );

    if( ARGUMENT_PRESENT( value ) )
        *value = *(DWORD *)(((UCHAR *)&Tcon) + offset);

    dprintf( "\n" );
    return TRUE;
}

BOOL
DumpConnection( IN ULONG_PTR dwAddress, IN DWORD offset, OUT DWORD *value OPTIONAL )
{
    CONNECTION Connection;
    PAGED_CONNECTION pc;
    WORK_CONTEXT wc;
    ULONG_PTR wcAddr;

    dprintf( "\nCONNECTION at %X: ", dwAddress );

    if( !GetData( &Connection, dwAddress, sizeof( Connection ), "CONNECTION" ) ||
      !CheckBlockHeader( &Connection.BlockHeader, BlockTypeConnection, TRUE ) ||
      !PrintBlockHeader( &Connection.BlockHeader, TRUE ) ) {

        return FALSE;
    }

    if( ARGUMENT_PRESENT( value ) )
        *value = *(DWORD *)(((UCHAR *)&Connection) + offset);

    dprintf( "    OemClientMachineName: %s\n", Connection.OemClientMachineName );

    PrintMemberList( &Connection, ML_CONNECTION );

    if( Connection.DeviceObject != NULL ) {
        //
        // Assume this is a VC oriented client
        //
        PrintMemberList( &Connection, ML_CONNECTION_VC );
    } else {
        //
        // Assume this is a direct host IPX client
        //
        PrintMemberList( &Connection, ML_CONNECTION_IPX );
    }

    dprintf( "\n  FileTable (contains RFCBs:)\n" );
    if( !DumpTable( &Connection.FileTable ) )
        return FALSE;

    /*
     * See if we can get the PAGED_CONNECTION data
     */
    dprintf( "\nPagedConnection Data->  " );

    if( !GetData( &pc, (ULONG_PTR)Connection.PagedConnection, sizeof(pc), "PAGED_CONNECTION" ) )
        return FALSE;

    PrintMemberList( &pc,ML_PAGED_CONNECTION );

    dprintf( "EncryptionKey: " );
    PrintHexBuf( pc.EncryptionKey, sizeof( pc.EncryptionKey ) );

    dprintf( "\n\n  SessionTable\n" );
    if( !DumpTable( &pc.SessionTable ) )
        return FALSE;

    dprintf( "\n  TreeConnectTable\n" );
    if( !DumpTable( &pc.TreeConnectTable ) )
        return FALSE;

    dprintf( "\n  SearchTable\n" );
    if( !DumpTable( &pc.SearchTable ) )
        return FALSE;

    //
    // Print out the in progress work item list
    //
    dwAddress += FIELD_OFFSET( CONNECTION, InProgressWorkItemList.Flink );

    if( (ULONG_PTR)Connection.InProgressWorkItemList.Flink != dwAddress ) {

        ULONG_PTR thisEntry;
        LIST_ENTRY le;

        dprintf( "\nIn-progress work contexts:\n" );

        thisEntry = (ULONG_PTR)Connection.InProgressWorkItemList.Flink;

        while( 1 ) {

            if( CheckControlC() ) {
                break;
            }

            if( thisEntry == dwAddress ) {
                break;
            }

            wcAddr = thisEntry - FIELD_OFFSET( WORK_CONTEXT, InProgressListEntry.Flink );

            RtlZeroMemory( &wc, sizeof( wc ) );
            GetData( &wc, wcAddr, sizeof( wc ), "WORK_CONTEXT" );

            dprintf( "  %p: Rfcb %p, Session %p, Share %p, TreeConnect %p\n",
                wcAddr, wc.Rfcb, wc.Session, wc.Share, wc.TreeConnect );

            if( !GetData( &le, thisEntry, sizeof( le ), "LIST_ENTRY" ) )
                break;

            thisEntry = (ULONG_PTR)le.Flink;
        }
    }

    dprintf( "\n" );

    return TRUE;
}

BOOL
DumpLfcb( IN ULONG_PTR dwAddress )
{
    LFCB l;

    if( !GetData( &l, dwAddress, sizeof( l ), "LFCB" ) ||
      !CheckBlockHeader( (PBLOCK_HEADER)&l.BlockHeader, BlockTypeLfcb, TRUE ) ||
      !PrintBlockHeader( (PBLOCK_HEADER)&l.BlockHeader, TRUE ) ) {
        return FALSE;
    }

    PrintMemberList( &l, ML_LFCB );
    return TRUE;
}

BOOL
DumpMfcb( IN ULONG_PTR dwAddress )
{
    MFCB m;
    NONPAGED_MFCB npm;

    if( !GetData( &m, dwAddress, sizeof( m ), "MFCB" ) ||
      !CheckBlockHeader( (PBLOCK_HEADER)&m.BlockHeader, BlockTypeMfcb, FALSE ) ||
      !PrintBlockHeader( (PBLOCK_HEADER)&m.BlockHeader, FALSE ) ||
      !GetData( &npm, (ULONG_PTR)m.NonpagedMfcb, sizeof( npm ), "NONPAGED_MFCB" ) ) {
        return FALSE;
    }

    PrintMemberList( &m, ML_MFCB );
    PrintMemberList( &npm, ML_NONPAGED_MFCB );
    return TRUE;
}

BOOL
DumpRfcb( ULONG_PTR dwAddress, PLIST_ENTRY *Flink )
{
    RFCB r;
    MFCB m;
    PAGED_RFCB p;
    BOOL PagedPresent;

    if( !GetData( &r, dwAddress, sizeof( r ), "RFCB" ) ||
      !CheckBlockHeader( (PBLOCK_HEADER)&r, BlockTypeRfcb, FALSE ) ) {
        return FALSE;
    }

    PagedPresent = GetData( &p,(ULONG_PTR)r.PagedRfcb, sizeof( p ), "PAGED_RFCB" );

    dprintf( "Rfcb @ %x:\n", dwAddress );
    if( Flink == NULL ) {
        if( !PrintBlockHeader( (PBLOCK_HEADER)&r, TRUE ) )
            return FALSE;
        PrintMemberList( &r, ML_RFCB );
        if( PagedPresent ) PrintMemberList( &p, ML_PAGED_RFCB );

    } else {

        PrintMemberList( &r, ML_RFCB_QUICK );
        *Flink = r.GlobalRfcbListEntry.ListEntry.Flink;
    }

    if( !GetData( &m, (ULONG_PTR)r.Mfcb, sizeof( m ), "MFCB" ) )
        return FALSE;

    PrintStringW( "File: ", &m.FileName, TRUE );

    return TRUE;
}

BOOL
DumpSession( IN ULONG_PTR dwAddress, IN DWORD offset, OUT DWORD *value OPTIONAL )
{
    SESSION Session;
    NONPAGED_HEADER NonpagedHeader;

    if( !GetData( &Session, dwAddress, sizeof( Session ), "SESSION" ) ||
      !CheckBlockHeader( &Session.BlockHeader, BlockTypeSession, FALSE ) ||
      !PrintBlockHeader( &Session.BlockHeader, FALSE ) ||
      !GetData( &NonpagedHeader, (ULONG_PTR)Session.NonpagedHeader, sizeof(NonpagedHeader),"NONPAGED_HEADER" ) ||
      !PrintNonpagedHeader( &NonpagedHeader, BlockTypeSession, dwAddress, TRUE ) ) {

        return FALSE;
    }

    if( ARGUMENT_PRESENT( value ) )
        *value = *(DWORD *)(((UCHAR *)&Session) + offset);

    PrintMemberList( &Session, ML_SESSION );

    dprintf(     "%-30s ", "NtUserSessionKey"  );
    PrintHexBuf( Session.NtUserSessionKey, sizeof( Session.NtUserSessionKey ) );
    dprintf( "\n    %-30s ", "LanManSessionKey" );
    PrintHexBuf( Session.LanManSessionKey, sizeof( Session.LanManSessionKey ) );
    dprintf( "\n\n" );

    return TRUE;
}

BOOL
DumpTransaction( IN ULONG_PTR dwAddress )
{
    TRANSACTION t;

    dprintf( "\nTRANSACTION at %X:\n", dwAddress );

    if( !GetData( &t, dwAddress, sizeof(t), "TRANSACTION" ) )
        return FALSE;

    PrintMemberList( &t, ML_TRANSACTION );

    return TRUE;
}

BOOL
DumpWorkContext( IN ULONG_PTR dwAddress )
{
    WORK_CONTEXT wc;

    dprintf( "\nWORK_CONTEXT at %X:\n", dwAddress );

    if( !GetData( &wc, dwAddress, sizeof(wc), "WORK_CONTEXT" ) )
        return FALSE;

    PrintMemberList( &wc, ML_WORK_CONTEXT );

    dprintf( "    Parameters addr %X, Parameters2 addr %X\n",
        dwAddress + FIELD_OFFSET( WORK_CONTEXT, Parameters ),
        dwAddress + FIELD_OFFSET( WORK_CONTEXT, Parameters2 ));

    if( wc.BlockingOperation )
        dprintf( "    BlockingOperation" );
    if( wc.UsingExtraSmbBuffer )
        dprintf( "    UsingExtraSmbBuffer" );
    if( wc.OplockOpen )
        dprintf( "    OplockOpen" );
    if( wc.ShareAclFailure )
        dprintf( "    ShareAclFailure" );
    if( wc.QueueToHead )
        dprintf( "    QueueToHead" );
    if( wc.NoResponseSmbSecuritySignature )
        dprintf( "    NoResponseSmbSecuritySignature" );
    if( wc.LargeIndication )
        dprintf( "    LargeIndication" );

    dprintf( "\n" );

    return TRUE;
}

VOID *
ThreadHandleToPointer( HANDLE hThread )
{
    return (VOID *)hThread;
}

BOOL
DumpWorkQueue( IN ULONG_PTR dwAddress )
{
    WORK_QUEUE WorkQueue;
    ULONG i;
    PHANDLE pHandles;

    dprintf( " at %X:\n", dwAddress );

    if( !GetData( &WorkQueue, dwAddress, sizeof( WorkQueue ), "WORK_QUEUE" ) )
        return FALSE;

    if( WorkQueue.Queue.Header.Type != QueueObject ) {
        ERRPRT( "WARNING: Queue.Header.Type is %X, should be %X\n",
            WorkQueue.Queue.Header.Type, QueueObject );
    }

    if( WorkQueue.Queue.Header.Size != sizeof( KQUEUE )/ sizeof( LONG ) ) {
        ERRPRT( "WARNING: Queue.Header.Size is %d, should be %d\n",
            WorkQueue.Queue.Header.Size, sizeof( KQUEUE ) );
    }

    PrintMemberList( &WorkQueue, ML_WORK_QUEUE );

    if( WorkQueue.Queue.Header.SignalState > 0 ) {
        dprintf( "  Queued WORK_CONTEXTs:\n" );
        if( !PrintListEntryList( dwAddress + FIELD_OFFSET(WORK_QUEUE, Queue.EntryListHead.Flink ),
             FIELD_OFFSET( KWAIT_BLOCK, Thread ))) {
        }
    }

    return TRUE;
}

VOID
PrintHelp( VOID )
{
    int i;

    for( i=0; Extensions[i]; i++ )
        dprintf( "   %s\n", Extensions[i] );
}
/*
 * Print out the usage message
 */
DECLARE_API( help )
{
    PrintHelp();
}

/*
 * Follow a LIST_ENTRY to the end
 */
DECLARE_API( df )
{
    LIST_ENTRY ListEntry;
    ULONG_PTR headAddress, dwAddress, prevAddress;
    ULONG count = 0;

    if( args == NULL || *args == '\0' ) {
        PrintHelp();
        return;
    }

    headAddress = GetExpression( args );

    if( !headAddress ||
        !GetData( &ListEntry, headAddress, sizeof( ListEntry ), "LIST_HEAD" ) ) {
        return;
    }

    prevAddress = headAddress;

    while( !CheckControlC() ) {

        dwAddress = (ULONG_PTR)ListEntry.Flink;

        if( dwAddress == headAddress ) {
            dprintf( "    %u elements in the list\n", count );
            return;
        }

        if( dwAddress == prevAddress ) {
            dprintf( "    Flink at %X points to itself.  Count %u\n", dwAddress, count );
        }

        if( !GetData( &ListEntry, dwAddress, sizeof( ListEntry ), "LIST_ENTRY" ) ) {
            dprintf( "    Flink at %X is bad --", prevAddress );
            dprintf( "  %u elements into list\n", count );
            return;
        }

        prevAddress = dwAddress;
        count++;
    }

    dprintf( "    CTRL-C: %u elements scanned\n", count );
}

DECLARE_API( pagedconnection )
{
    ULONG_PTR dwAddress;
    PAGED_CONNECTION pc;

    if( args == NULL || *args == '\0' ) {
        PrintHelp();
    } else {
        dwAddress = GetExpression( args );
        if( dwAddress && GetData( &pc, dwAddress, sizeof(pc), "PAGED_CONNECTION" ) ) {
            dprintf( "    sizeof( PAGED_CONNECTION ) = %d bytes\n", sizeof( pc ) );
            PrintMemberList( &pc, ML_PAGED_CONNECTION );
        }
    }
}

DECLARE_API( share )
{
    ULONG_PTR   dwAddress;
    BOOL    ShowMany = FALSE;
    SHARE_TYPE ShareType = (SHARE_TYPE)-1;
    LPCSTR ShareName = NULL;
    LIST_ENTRY SrvShareHashTable[ NSHARE_HASH_TABLE ];
    ULONG i;

    if( args == NULL || *args == '\0'  ) {
        ShowMany = TRUE;
    } else if( !_strcmpi( args, "disk" ) ) {
        ShowMany = TRUE;
        ShareType = ShareTypeDisk;
    } else if( !_strcmpi( args, "print" ) ) {
        ShowMany = TRUE;
        ShareType = ShareTypePrint;
    } else if( !_strcmpi( args, "pipe" ) ) {
        ShowMany = TRUE;
        ShareType = ShareTypePipe;
    } else if( args[0] == '=' ) {
        ShareName = args + 1;
        ShowMany = TRUE;
    } else if( !_strcmpi( args, "?" ) ) {
        PrintHelp();
        return;
    }

    if( ShowMany == FALSE ) {
        //
        // Get at the address that was passed to this on the command line.
        //
        dwAddress = GetExpression( args );

        if( dwAddress == 0 )
            return;

        DumpShare( dwAddress, ShareType, NULL, NULL );
        return;
    }

    //
    // Dump entries from the entire server share table!
    //

    dwAddress = GetExpression( "srv!SrvShareHashTable" );
    if( dwAddress == 0 ) {
        ERRPRT( "Unable to get address for srv!SrvShareHashTable\n" );
        return;
    }
    if( !GetData( &SrvShareHashTable, dwAddress, sizeof( SrvShareHashTable ), "HASH TABLE" ) ) {
        ERRPRT( "Unable to read hash table\n" );
        return;
    }

    for( i = 0; i < NSHARE_HASH_TABLE; i++ ) {

        LIST_ENTRY *NextShare;

        NextShare = SrvShareHashTable[i].Flink;

        while( (ULONG_PTR)NextShare != dwAddress + i*sizeof( LIST_ENTRY ) ) {

            ULONG_PTR ShareEntry;

            ShareEntry = (ULONG_PTR)CONTAINING_RECORD( NextShare, SHARE, GlobalShareList );

            if( !DumpShare( ShareEntry, ShareType, ShareName, &NextShare ) )
                break;

        }
    }
}

DECLARE_API( lock )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;

    if( args && *args ) {
        dwAddress = GetExpression( args );
        DumpLock( dwAddress );
        return;
    }

    strcpy( buf, "srv!" );
    for( i=0; SrvLocks[i]; i++ ) {
        strcpy( &buf[4], SrvLocks[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", SrvLocks[i] );
            continue;
        }
        dprintf( "\n%s\n", SrvLocks[i] );
        if( !DumpLock( dwAddress ) )
            break;
    }
}

DECLARE_API( endpoint )
{
    LIST_ENTRY *NextEndpoint;
    ORDERED_LIST_HEAD SrvEndpointList;
    ULONG_PTR dwAddress;
    int i;

    if( args && *args ) {
        dwAddress = GetExpression( args );
        DumpEndpoint( dwAddress, NULL );
        return;
    }

    dwAddress = GetExpression ( "srv!SrvEndpointList" );
    if( dwAddress == 0 ) {
        ERRPRT( "Unable to get address of srv!SrvEndpointList\n" );
        return;
    }
    if( !GetData( &SrvEndpointList, dwAddress, sizeof( SrvEndpointList ), "ORDERED_LIST_HEAD" ) ) {
        ERRPRT( "Unable to read data for srv!SrvEndpointList\n" );
        return;
    }
    if( SrvEndpointList.Initialized == 0 ) {
        ERRPRT( "srv!SrvEndpointList.Initialized == 0!\n" );
        return;
    }
    if( (ULONG_PTR)SrvEndpointList.ListHead.Flink == dwAddress ) {
        ERRPRT( "srv!SrvEndpointList list is empty\n" );
        return;
    }
    if( (ULONG_PTR)SrvEndpointList.ListHead.Flink == 0 ) {
        ERRPRT( "srv!SrvEndpointList.ListHead.Flink == 0: list is empty\n" );
        return;
    }

    NextEndpoint = SrvEndpointList.ListHead.Flink;

    do {
        ULONG_PTR EndpointEntry;

        if( CheckControlC() ) {
            dprintf( "\n" );
            break;
        }

        EndpointEntry = (ULONG_PTR)CONTAINING_RECORD( NextEndpoint, ENDPOINT, GlobalEndpointListEntry );

        if( !DumpEndpoint( EndpointEntry, &NextEndpoint ) )
            break;

    } while( (ULONG_PTR)NextEndpoint != dwAddress );
}

DECLARE_API( search )
{
    if( !args || !*args ) {
        ERRPRT( "SEARCH address required\n" );
    } else {
        DumpSearch( GetExpression( args ) );
    }
}


DECLARE_API( buffer )
{
    if( !args || !*args ) {
        ERRPRT( "BUFFER address required\n" );
    } else {
        DumpBuffer( GetExpression( args ) );
    }
}

DECLARE_API( smb )
{
    if( !args || !*args ) {
        ERRPRT( "BUFFER address required\n" );
    } else {
        DumpSmb( GetExpression( args ) );
    }
}


DECLARE_API( tcon )
{
    if( !args || !*args ) {
        ERRPRT( "Tcon address required\n" );
    } else {
        DumpTcon( GetExpression(args), 0, NULL );
    }
}

DECLARE_API ( connection )
{

    if( !args || !*args ) {
        ERRPRT( "Connection address required\n" );
    } else {
        DumpConnection( GetExpression(args), 0, NULL );
    }
}

DECLARE_API( lfcb )
{
    if( !args || !*args ) {
        ERRPRT( "LFCB address required\n" );
    } else {
        DumpLfcb( GetExpression(args) );
    }
}

DECLARE_API( mfcb )
{
    if( !args || !*args ) {
        ERRPRT( "MFCB address required\n" );
    } else {
        DumpMfcb( GetExpression(args) );
    }
}

DECLARE_API( rfcb )
{
    LIST_ENTRY *NextRfcb;
    ORDERED_LIST_HEAD SrvRfcbList;
    ULONG_PTR dwAddress;
    int i;

    if( args && *args ) {
        DumpRfcb( GetExpression(args), NULL );
        return;
    }

    dwAddress = GetExpression ( "srv!SrvRfcbList" );
    if( dwAddress == 0 ) {
        ERRPRT( "Unable to get address of srv!SrvSrvRfcbList\n" );
        return;
    }
    if( !GetData( &SrvRfcbList, dwAddress, sizeof( SrvRfcbList ), "ORDERED_LIST_HEAD" ) ) {
        ERRPRT( "Unable to read data for srv!SrvRfcbList\n" );
        return;
    }
    if( SrvRfcbList.Initialized == 0 ) {
        ERRPRT( "srv!SrvRfcbList.Initialized == 0!\n" );
        return;
    }
    if( (ULONG_PTR)SrvRfcbList.ListHead.Flink == dwAddress ) {
        ERRPRT( "srv!SrvRfcbList list is empty\n" );
        return;
    }
    if( (ULONG_PTR)SrvRfcbList.ListHead.Flink == 0 ) {
        ERRPRT( "srv!SrvRfcbList.ListHead.Flink == 0: list is empty\n" );
        return;
    }

    NextRfcb = SrvRfcbList.ListHead.Flink;

    do {
        ULONG_PTR RfcbEntry;

        RfcbEntry = (ULONG_PTR)CONTAINING_RECORD( NextRfcb, RFCB, GlobalRfcbListEntry );

        dprintf( "\n" );

        DumpRfcb( RfcbEntry, &NextRfcb );

        if( CheckControlC() ) {
            dprintf( "\n" );
            break;
        }

    } while( (ULONG_PTR)NextRfcb != dwAddress );
}

DECLARE_API( session )
{
    if( !args || !*args ) {
        ERRPRT( "Session address required\n" );
    } else {
        DumpSession( GetExpression(args), 0, NULL );
    }
}

DECLARE_API( globals )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 200 ];
    int i;
    int c=0;
    GUID guid;

    strcpy( buf, "srv!" );

    dprintf( "BOOLEAN Values (%u bytes):\n", sizeof( BOOLEAN ) );
    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOLEAN b;

        strcpy( &buf[4], GlobalBool[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &b, dwAddress, sizeof(b), GlobalBool[i] ) )
            return;

        dprintf( "%s%-35s %10s%s",
            c&1 ? "    " : "",
            GlobalBool[i],
            b ? " TRUE" : "FALSE",
            c&1 ? "\n" : "" );
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    dprintf( "%s\nSHORT Values (%u bytes):\n", c&1 ? "\n" : "" ,sizeof( SHORT ) );
    c &= ~01;
    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[4], GlobalShort[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &s, dwAddress, sizeof(s), GlobalShort[i] ) )
            return;

        dprintf( "%s%-35s %10d%s",
            c&1 ? "    " : "",
            GlobalShort[i],
            s,
            c&1 ? "\n" : "" );
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    dprintf( "%s\nLONG Values (%u bytes):\n", c&1 ? "\n" : "", sizeof( LONG ) );
    c &= ~01;
    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[4], GlobalLong[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &l, dwAddress, sizeof(l), GlobalLong[i] ) )
            return;

        dprintf( "%s%-35s %10u%s",
            c&1 ? "    " : "",
            GlobalLong[i],
            l,
            c&1 ? "\n" : "" );
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    for( i=0; GlobalLongHex[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[4], GlobalLongHex[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &l, dwAddress, sizeof(l), GlobalLongHex[i] ) )
            return;

        dprintf( "%s%-35s %10X%s",
            c&1 ? "    " : "",
            GlobalLongHex[i],
            l,
            c&1 ? "\n" : "" );
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    //
    // Dump out the server GUID
    //
    dwAddress = GetExpression( "srv!ServerGuid" );
    if( dwAddress != 0 &&
        GetData( &guid, dwAddress, sizeof(guid), "ServerGuid" ) ) {

        dprintf( "%s%s    ", c&1 ? "    " : "", "ServerGuid" );

        for( i=0; i < sizeof( guid ); i++ ) {
            dprintf( "%2.2X", ((CHAR *)&guid)[i] & 0xFF );
        }
    }

    for( i = 0; GlobalStrings[i]; i++ ) {
        UNICODE_STRING String;
        WCHAR wszbuf[35];

        dprintf( "\n%s%s:\n", c&1 ? "\n" : "", GlobalStrings[i] );
        c &= ~01;
        strcpy( &buf[4], GlobalStrings[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( GetData( &String, dwAddress, sizeof( String ), GlobalStrings[i] ) ) {
            wszbuf[ sizeof(wszbuf)/sizeof(wszbuf[0]) - 1 ] = L'\0';
            if( !GetString( (ULONG_PTR)String.Buffer, wszbuf, sizeof(wszbuf)/sizeof(wszbuf[0])-1) )
                continue;

            dprintf( "    %-35ws%s", wszbuf, c&1 ? "\n" : "" );
            c++;
        }
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    for( i=0; GlobalStringVector[i]; i++ ) {
        ULONG_PTR StringAddress;
        WCHAR wszbuf[ 35 ];

        dprintf( "\n%s%s:\n", c&1 ? "\n" : "", GlobalStringVector[i] );
        c &= ~01;

        strcpy( &buf[4], GlobalStringVector[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &dwAddress, dwAddress, sizeof( dwAddress ), GlobalStringVector[i] ) ) {
            return;
        }

        if( dwAddress == 0 )
            continue;

        wszbuf[ sizeof(wszbuf)/sizeof(wszbuf[0]) - 1 ] = L'\0';

        while( 1 ) {
            if( !GetData( &StringAddress, dwAddress, sizeof(StringAddress), GlobalStringVector[i] ) )
                break;
            if( StringAddress == 0 )
                break;
            if( !GetString( StringAddress, wszbuf, sizeof(wszbuf) / sizeof(wszbuf[0]) - 1 ) )
                break;
            dprintf( "    %-35ws%s",
                wszbuf,
                c&1 ? "\n" : "" );
            dwAddress += sizeof( LPSTR );
            c++;
        }
    }
    dprintf( "\n" );
}

DECLARE_API( context )
{

    if( args == NULL || !*args ) {
        ERRPRT( "WORK_CONTEXT address required\n" );
    } else {
        DumpWorkContext( GetExpression( args ) );
    }
}

DECLARE_API( transaction )
{
    if( args == NULL || !*args ) {
        ERRPRT( "TRANSACTION address required\n" );
    } else {
        DumpTransaction( GetExpression( args ) );
    }
}

DECLARE_API( queue )
{
    ULONG_PTR dwAddress, dweAddress;
    ULONG nProcessors;
    ULONG i;
    BOOLEAN mp;

    if( args && *args ) {
        dprintf( "WorkQueue" );
        DumpWorkQueue( GetExpression( args ) );
        return;
    }

    dwAddress = GetExpression( "srv!SrvMultiProcessorDriver" );
    if( !GetData( &mp, dwAddress, sizeof( mp ), "srv!SrvMultiProcessorDriver" ) )
        return;

    if( mp == TRUE ) {
        dwAddress = GetExpression( "srv!SrvNumberOfProcessors" );
        if( !GetData( &nProcessors, dwAddress, sizeof(nProcessors), "srv!SrvNumberOfProcessors" ) )
            return;
        dwAddress = GetExpression( "srv!SrvWorkQueues" );
        if( !GetData( &dwAddress, dwAddress, sizeof(dwAddress), "srv!SrvWorkQueues" ))
            return;
        dweAddress = GetExpression( "srv!eSrvWorkQueues" );
        if( !GetData( &dweAddress, dweAddress, sizeof(dweAddress), "srv!eSrvWorkQueues" ))
            return;

        if( dwAddress + nProcessors*sizeof(WORK_QUEUE) != dweAddress ) {
            ERRPRT( "eSrvWorkQueues is %X, should be %X\n",
                dweAddress, dwAddress + nProcessors*sizeof(WORK_QUEUE) );
        }
    } else {
        dwAddress = GetExpression( "srv!SrvWorkQueues" );
        nProcessors = 1;
    }

    for( i=0; i < nProcessors; i++, dwAddress += sizeof( WORK_QUEUE ) ) {
        dprintf( "%sProcessor %d ", i?"\n":"", i );
        if( DumpWorkQueue( dwAddress ) == FALSE )
            break;
    }

    dwAddress = GetExpression( "srv!SrvBlockingWorkQueue" );
    dprintf( "\nBlockingWorkQueue " );
    DumpWorkQueue( dwAddress );
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

void
DoLongLongBits( PCSTR symbol, PCSTR args, struct BitFields b[] )
{
    ULONGLONG value;
    ULONG_PTR dwAddress;
    char *p;
    ULONG bytesWritten;
    int i;
    int bsize;

    dwAddress = GetExpression( symbol );
    if( !GetData( &value, dwAddress, sizeof(value), symbol ) )
            return;

    if( !args || !*args ) {
        for( i=0; b[i].name; i++ ) {

            if( i && i%3 == 0 )
                dprintf( "\n" );

            if( strlen( b[i].name ) > 15 ) {
               dprintf( "    %2u %-.7s...%s ", i, b[i].name,
                        b[i].name+strlen(b[i].name)-5 );
            } else {
               dprintf( "    %2u %-15s ", i, b[i].name );
            }

            dprintf( " %c", value & b[i].value ? 'T' : 'F' );
        }
        dprintf( "\n" );
        return;
    }

    for( bsize=0; b[ bsize ].name; bsize++ )
        ;

    if( !_strcmpi( args, "on" )  || !_strcmpi( args, "true" ) || !_strcmpi( args, "t" ) ) {
        value = (ULONGLONG)-1;

    } else if( !_strcmpi( args, "off" ) || !_strcmpi( args, "false" ) || !_strcmpi( args, "f" ) ) {
        value = 0;

    } else {
        char argbuf[ MAX_PATH ];

        strcpy( argbuf, args );

        for( p = mystrtok( argbuf, " \t,;" ); p && *p; p = mystrtok( NULL, " \t,;" ) ) {
            i = atoi( p );
            if( i < 0 || i >= bsize ) {
                dprintf( "%s: illegal index number\n", p );
                continue;
            }
            if( value & b[i].value ) {
                value &= ~b[i].value;
            } else {
                value |= b[i].value;
            }
        }
    }

    WriteMemory( dwAddress, &value, sizeof(value), &bytesWritten );

    if( bytesWritten != sizeof( value ) )
        dprintf( "Write error\n" );

}

DECLARE_API( srvdebug )
{
#if SRVDBG == 1
    DoLongLongBits( "srv!SrvDebug", args, SrvDebugFlags );
#else
    dprintf( "Not Available!\n" );
#endif
}

DECLARE_API( smbdebug )
{
#if SRVDBG == 1
    DoLongLongBits( "srv!SmbDebug", args, SmbDebugFlags );
#else
    dprintf( "Not Available!\n" );
#endif
}

DECLARE_API( statistics )
{
    ULONG_PTR dwAddress;
    SRV_STATISTICS s;

    dwAddress = GetExpression( "srv!SrvStatistics" );
    if( !GetData( &s, dwAddress, sizeof(s), "SrvStatistics" ) )
        return;

    PrintMemberList( &s, ML_SRV_STATISTICS );
}

DECLARE_API( scavenger )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    strcpy( buf, "srv!" );

    dprintf( "BOOLEAN Values (%u bytes):\n", sizeof( BOOLEAN ) );
    for( i=0; ScavengerBool[i]; i++, c++ ) {
        BOOLEAN b;

        strcpy( &buf[4], ScavengerBool[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", ScavengerBool[i] );
            continue;
        }
        if( !GetData( &b, dwAddress, sizeof(b), ScavengerBool[i] ) )
            return;

        dprintf( "%s%-30s %10s%s",
            c&1 ? "    " : "",
            ScavengerBool[i],
            b ? " TRUE" : "FALSE",
            c&1 ? "\n" : "" );
    }

    dprintf( "%s\nLONG Values (%u bytes):\n", c&1 ? "\n" : "", sizeof( LONG ) );
    c &= ~01;
    for( i=0; ScavengerLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[4], ScavengerLong[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", ScavengerLong[i] );
            continue;
        }
        if( !GetData( &l, dwAddress, sizeof(l), ScavengerLong[i] ) )
            return;

        dprintf( "%s%-30s %10u%s",
            c&1 ? "    " : "",
            ScavengerLong[i],
            l,
            c&1 ? "\n" : "" );
    }
}

DECLARE_API( srv )
{
    ULONG_PTR dwAddress;
    BOOLEAN b;
    ULONG ul;
    ULONG bytesWritten;

    dwAddress = GetExpression( "srv!SrvProductTypeServer" );
    b = TRUE;
    WriteMemory( dwAddress, &b, sizeof(b), &bytesWritten );
    if( bytesWritten != sizeof(b) ) {
        ERRPRT( "Unable to update SrvProductTypeServer\n" );
        return;
    }

    dwAddress = GetExpression( "srv!SrvCachedOpenLimit" );
    ul = 5;
    WriteMemory( dwAddress, &ul, sizeof(ul), &bytesWritten );
    if( bytesWritten != sizeof(ul) ) {
        ERRPRT( "Unable to update SrvCachedOpenLimit\n" );
    }

}

DECLARE_API( wksta )
{
    ULONG_PTR dwAddress;
    BOOLEAN b;
    ULONG ul;
    ULONG bytesWritten;

    dwAddress = GetExpression( "srv!SrvProductTypeServer" );
    b = FALSE;
    WriteMemory( dwAddress, &b, sizeof(b), &bytesWritten );
    if( bytesWritten != sizeof(b) ) {
        ERRPRT( "Unable to update SrvProductTypeServer\n" );
        return;
    }

    dwAddress = GetExpression( "srv!SrvCachedOpenLimit" );
    ul = 0;
    WriteMemory( dwAddress, &ul, sizeof(ul), &bytesWritten );
    if( bytesWritten != sizeof(ul) ) {
        ERRPRT( "Unable to update SrvCachedOpenLimit\n" );
    }

}

DECLARE_API( client )
{
    ULONG_PTR epListAddress;
    LIST_ENTRY *NextEndpoint;
    ORDERED_LIST_HEAD SrvEndpointList;
    WORK_QUEUE WorkQueue;
    ULONG_PTR WorkQueueAddress = 0;
    LONG SrvConnectionNoSessionsTimeout = 0;
    ULONG_PTR dwAddress;

    epListAddress = GetExpression ( "srv!SrvEndpointList" );
    if( epListAddress == 0 ) {
        ERRPRT( "Unable to get address of srv!SrvEndpointList\n" );
        return;
    }
    if( !GetData( &SrvEndpointList,epListAddress,sizeof( SrvEndpointList ),"ORDERED_LIST_HEAD" )){
        ERRPRT( "Unable to read data for srv!SrvEndpointList\n" );
        return;
    }
    if( SrvEndpointList.Initialized == 0 ) {
        ERRPRT( "srv!SrvEndpointList.Initialized == 0!\n" );
        return;
    }
    if( (ULONG_PTR)SrvEndpointList.ListHead.Flink == epListAddress ) {
        ERRPRT( "srv!SrvEndpointList list is empty\n" );
        return;
    }
    if( (ULONG_PTR)SrvEndpointList.ListHead.Flink == 0 ) {
        ERRPRT( "srv!SrvEndpointList.ListHead.Flink == 0: list is empty\n" );
        return;
    }

    if( dwAddress = GetExpression( "srv!SrvConnectionNoSessionsTimeout" ) ) {
        GetData( &SrvConnectionNoSessionsTimeout, dwAddress, sizeof(ULONG_PTR), "SrvConnectionNoSessionsTimeout" );
        dprintf( "Session Idle Timeout: %d ticks\n", SrvConnectionNoSessionsTimeout );
    }

    NextEndpoint = SrvEndpointList.ListHead.Flink;

    //
    // Run the endpoint list, and run the connection list for each endpoint
    //
    do {
        ENDPOINT endpoint;
        CONNECTION connection;
        PTABLE_ENTRY table;
        USHORT i;
        LONG idleTime;

        dwAddress = (ULONG_PTR)CONTAINING_RECORD( NextEndpoint, ENDPOINT, GlobalEndpointListEntry );

        if( CheckControlC() ) {
            dprintf( "\n" );
            break;
        }

        if( !GetData( &endpoint, dwAddress, sizeof( endpoint ), "ENDPOINT" ) ||
            !CheckBlockHeader( &endpoint.BlockHeader, BlockTypeEndpoint, TRUE ) ) {
            break;
        }

        //
        // Now, run the connection table for this endpoint and print out the client names
        //  and connection structure address
        //
        if( endpoint.ConnectionTable.Table == NULL ) {
            continue;
        }

        table = (PTABLE_ENTRY)LocalAlloc( LPTR,
                    endpoint.ConnectionTable.TableSize*sizeof(TABLE_ENTRY) );

        if( table == NULL ) {
            continue;
        }

        if( !GetData( table, (ULONG_PTR)endpoint.ConnectionTable.Table,
                            endpoint.ConnectionTable.TableSize*sizeof(TABLE_ENTRY), "TABLE" ) ) {

            LocalFree( (HLOCAL)table );
            continue;
        }

        for( i = 0; i < endpoint.ConnectionTable.TableSize; i++ ) {
            if( table[i].Owner &&
                GetData( &connection,(ULONG_PTR)table[i].Owner, sizeof( connection ),"CONNECTION") &&
                connection.BlockHeader.ReferenceCount != 0 &&
                connection.OemClientMachineName[0] &&
                connection.OemClientMachineName[0] != ' ' ) {

                    if( args != NULL && *args != '\0' ) {

                        int j;

                        for( j = 0; args[j] ; j++ ) {
                            if( connection.OemClientMachineName[j] != args[j] )
                                break;
                        }

                        if( args[j] ) {
                            continue;
                        }
                    }

                    if( WorkQueueAddress != (ULONG_PTR)connection.CurrentWorkQueue ) {
                        if( GetData( &WorkQueue, (ULONG_PTR)connection.CurrentWorkQueue, sizeof( WorkQueue ), "WORK_QUEUE" ) ) {
                            WorkQueueAddress = (ULONG_PTR)connection.CurrentWorkQueue;
                        }
                    }

                    idleTime = WorkQueue.stats.SystemTime - connection.LastRequestTime;

                    dprintf( "%8X    %-16s, Idle %d ticks\n", table[i].Owner,connection.OemClientMachineName,idleTime);
                    if( idleTime > SrvConnectionNoSessionsTimeout ) {
                        dprintf( "*** Above client is due for idle disconnect, if no open files\n" );
                    }

                    if( CheckControlC() ) {
                        dprintf( "\n" );
                        return;
                    }
            }
        }

        LocalFree( (HLOCAL)table );

        NextEndpoint = endpoint.GlobalEndpointListEntry.ListEntry.Flink;

    } while( (ULONG_PTR)NextEndpoint != epListAddress );
}

DECLARE_API( errcodes )
{
    ULONG_PTR dwAddress;
    NTSTATUS status;
    int count = 0;

    dwAddress = GetExpression( "srv!SrvErrorLogIgnore" );

    while( 1 ) {
        if( !GetData( &status, dwAddress, sizeof( status ), "NTSTATUS" ) )
            return;
        if( status == 0 )
            break;
        dprintf( "   %X", status );
        dwAddress += sizeof( status );
        if( (++count & 7) == 0 )
            dprintf( "\n" );
    }
    dprintf( "\n" );
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s SMB Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\xssupp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xssupp.c

Abstract:

    This module contains the code necessary to support XACTSRV for down-level
    remote APIs.

Author:

    David Treadwell (davidtr)   05-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "xssupp.tmh"
#pragma hdrstop

//
// Xs forward declarations
//

VOID
SrvXsFreeSharedMemory (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvXsConnect )
#pragma alloc_text( PAGE, SrvXsRequest )
#pragma alloc_text( PAGE, SrvXsLSOperation )
#pragma alloc_text( PAGE, SrvXsDisconnect )
#pragma alloc_text( PAGE, SrvXsFreeSharedMemory )
#pragma alloc_text( PAGE, SrvXsAllocateHeap )
#pragma alloc_text( PAGE, SrvXsFreeHeap )
#pragma alloc_text( PAGE, SrvXsPnpOperation )
#endif

//
// Xs internal Globals
//

//
// This count indicates how many outstanding transactions are using
// the XS shared memory.  This prevents us from deleting the shared
// memory while it is still being accessed.
//

ULONG SrvXsSharedMemoryReference = 0;


NTSTATUS
SrvXsConnect (
    IN PUNICODE_STRING PortName
    )

/*++

Routine Description:

    This routine performs all the work necessary to connect the server
    to XACTSRV.  It creates a section of shared memory to use, then
    calls NtConnectPort to connect to the port that XACTSRV has already
    created.

Arguments:

    PortName - Name of the port XACTSRV has opened.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    PORT_VIEW clientView;
    SECURITY_QUALITY_OF_SERVICE dynamicQos;

    PAGED_CODE( );

    //
    // Initialize variables so that we know what to close on exit.
    //

    SrvXsSectionHandle = NULL;
    SrvXsPortHandle = NULL;
    SrvXsPortMemoryHeap = NULL;

    //
    // Create the section to be used as unnamed shared memory for
    // communication between the server and XACTSRV.
    //

    status = NtCreateSection(
                 &SrvXsSectionHandle,
                 SECTION_ALL_ACCESS,
                 NULL,                           // ObjectAttributes
                 &SrvXsSectionSize,
                 PAGE_READWRITE,
                 SEC_RESERVE,
                 NULL                            // FileHandle
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvXsConnect: NtCreateSection failed: %X\n", status ));
        }
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsConnect: created section of %ld bytes, handle %p\n",
                      SrvXsSectionSize.LowPart, SrvXsSectionHandle ));
    }

    //
    // Set up for a call to NtConnectPort and connect to XACTSRV.  This
    // includes a description of the port memory section so that the
    // LPC connection logic can make the section visible to both the
    // client and server processes.
    //

    clientView.Length = sizeof(clientView);
    clientView.SectionHandle = SrvXsSectionHandle;
    clientView.SectionOffset = 0;
    clientView.ViewSize = SrvXsSectionSize.LowPart;
    clientView.ViewBase = 0;
    clientView.ViewRemoteBase = 0;

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use dynamic tracking so that XACTSRV will impersonate the
    // user that we are impersonating when we call NtRequestWaitReplyPort.
    // If we used static tracking, XACTSRV would impersonate the context
    // when the connection is made.
    //

    dynamicQos.ImpersonationLevel = SecurityImpersonation;
    dynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    dynamicQos.EffectiveOnly = TRUE;

    // !!! We might want to use a timeout value.

    status = NtConnectPort(
                 &SrvXsPortHandle,
                 PortName,
                 &dynamicQos,
                 &clientView,
                 NULL,                           // ServerView
                 NULL,                           // MaxMessageLength
                 NULL,                           // ConnectionInformation
                 NULL                            // ConnectionInformationLength
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvXsConnect: NtConnectPort for port %wZ failed: %X\n",
                          PortName, status ));
        }
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsConnect: conected to port %wZ, handle %p\n",
                      PortName, SrvXsPortHandle ));
    }

    //
    // Store information about the section so that we can create pointers
    // meaningful to XACTSRV.
    //

    SrvXsPortMemoryBase = clientView.ViewBase;
    SrvXsPortMemoryDelta = PTR_DIFF_FULLPTR( clientView.ViewRemoteBase,
                                             clientView.ViewBase );

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsConnect: port mem base %p, port mem delta %p\n",
                      SrvXsPortMemoryBase, (PVOID)SrvXsPortMemoryDelta ));
    }

    //
    // Set up the port memory as heap.
    //
    // *** Note that we do our own heap serialization using
    //     SrvXsResource.
    //
    SrvXsPortMemoryHeap = RtlCreateHeap(
                              HEAP_NO_SERIALIZE,        // Flags
                              SrvXsPortMemoryBase,      // HeapBase
                              SrvXsSectionSize.LowPart, // ReserveSize
                              PAGE_SIZE,                // CommitSize
                              NULL,                     // Lock
                              0                         // Reserved
                              );

    SrvXsActive = TRUE;

    //
    // Test it out to ensure everything is working right
    //
    SrvXsFreeHeap( SrvXsAllocateHeap( 100, &status ) );

    return status;

exit:

    if ( SrvXsSectionHandle != NULL ) {
       SrvNtClose( SrvXsSectionHandle, FALSE );
    }

    if ( SrvXsPortHandle != NULL ) {
       SrvNtClose( SrvXsPortHandle, FALSE );
    }

    return status;

} // SrvXsConnect


SMB_TRANS_STATUS
SrvXsRequest (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine sends a remote API request to XACTSRV.  It first
    updates all the pointers in the transaction block so that they
    are meaningful to XACTSRV, then sends a message over the port
    indicating that there is a request in the shared memory ready to
    be serviced.  It then fixes all the pointers in the transaction
    block.

Arguments:

    WorkContext - a pointer to a work context block that has a pointer to
        transaction block to use.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    PCONNECTION connection = WorkContext->Connection;
    PSESSION session = WorkContext->Session;
    SMB_TRANS_STATUS returnStatus;
    PTRANSACTION transaction;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;
    PWCH destPtr, sourcePtr, sourceEndPtr;

    PAGED_CODE( );

    //
    // If this call is made on the NULL session, make sure it's one of
    // the authorized apis.
    //

    transaction = WorkContext->Parameters.Transaction;
    if ( session->IsNullSession && SrvRestrictNullSessionAccess ) {

        USHORT apiNumber;

        apiNumber = SmbGetUshort( (PSMB_USHORT)transaction->InParameters );

        if ( apiNumber != API_WUserPasswordSet2         &&
             apiNumber != API_WUserGetGroups            &&
             apiNumber != API_NetServerEnum2            &&
             apiNumber != API_WNetServerReqChallenge    &&
             apiNumber != API_WNetServerAuthenticate    &&
             apiNumber != API_WNetServerPasswordSet     &&
             apiNumber != API_WNetAccountDeltas         &&
             apiNumber != API_WNetAccountSync           &&
             apiNumber != API_WWkstaUserLogoff          &&
             apiNumber != API_WNetWriteUpdateLog        &&
             apiNumber != API_WNetAccountUpdate         &&
             apiNumber != API_SamOEMChgPasswordUser2_P  &&
             apiNumber != API_NetServerEnum3            &&
             apiNumber != API_WNetAccountConfirmUpdate  ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvXsRequest: Null session tried to call api.%d\n",
                              apiNumber ));
            }

            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            return SmbTransStatusErrorWithoutData;
        }
    }

    //
    // Initialize the transport name pointer to make sure we can know if
    // it has been allocated.
    //

    requestMessage.Message.DownLevelApi.TransportName = NULL;

    //
    // Convert the relevant pointers in the transaction block to the base
    // in XACTSRV.
    //

    transaction->TransactionName.Buffer += SrvXsPortMemoryDelta;
    transaction->InSetup += SrvXsPortMemoryDelta;
    transaction->OutSetup += SrvXsPortMemoryDelta;
    transaction->InParameters += SrvXsPortMemoryDelta;
    transaction->OutParameters += SrvXsPortMemoryDelta;
    transaction->InData += SrvXsPortMemoryDelta;
    transaction->OutData += SrvXsPortMemoryDelta;

    //
    // Build the transport name in the message.
    //

    requestMessage.Message.DownLevelApi.TransportName =
        SrvXsAllocateHeap(
            WorkContext->Endpoint->TransportName.Length + sizeof(WCHAR),
            &status
            );

    if ( requestMessage.Message.DownLevelApi.TransportName == NULL ) {
        SrvSetSmbError( WorkContext, status );
        returnStatus = SmbTransStatusErrorWithoutData;
        goto exit;
    }


    requestMessage.Message.DownLevelApi.TransportNameLength =
                        WorkContext->Endpoint->TransportName.Length;

    RtlCopyMemory(
        requestMessage.Message.DownLevelApi.TransportName,
        WorkContext->Endpoint->TransportName.Buffer,
        WorkContext->Endpoint->TransportName.Length
        );

    //
    // Null terminate the transport name.
    //

    requestMessage.Message.DownLevelApi.TransportName[ WorkContext->Endpoint->TransportName.Length / sizeof(WCHAR) ] = UNICODE_NULL;

    //
    // Adjust the transport name to be self relative within the buffer.
    //

    requestMessage.Message.DownLevelApi.TransportName =
        (PWSTR)((PUCHAR)requestMessage.Message.DownLevelApi.TransportName +
                                                SrvXsPortMemoryDelta);

    //
    // Build the server name in the message
    //
    RtlCopyMemory(
        requestMessage.Message.DownLevelApi.ServerName,
        WorkContext->Endpoint->TransportAddress.Buffer,
        MIN( sizeof(requestMessage.Message.DownLevelApi.ServerName),
             WorkContext->Endpoint->TransportAddress.Length )
        );

    requestMessage.Message.DownLevelApi.Transaction =
        (PTRANSACTION)( (PCHAR)transaction + SrvXsPortMemoryDelta );

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_DOWN_LEVEL_API;

    //
    // Copy the client machine name for XACTSRV, skipping over the
    // initial "\\", and deleting trailing spaces.
    //

    destPtr = requestMessage.Message.DownLevelApi.ClientMachineName;
    sourcePtr =
        connection->PagedConnection->ClientMachineNameString.Buffer + 2;
    sourceEndPtr = sourcePtr
        + min( connection->PagedConnection->ClientMachineNameString.Length,
               sizeof(requestMessage.Message.DownLevelApi.ClientMachineName) /
               sizeof(WCHAR) - 1 );

    while ( sourcePtr < sourceEndPtr && *sourcePtr != UNICODE_NULL ) {
        *destPtr++ = *sourcePtr++;
    }

    *destPtr-- = UNICODE_NULL;

    while ( destPtr >= requestMessage.Message.DownLevelApi.ClientMachineName
            &&
            *destPtr == L' ' ) {
        *destPtr-- = UNICODE_NULL;
    }

    //
    // Copy the lanman session key.  This will be used to decrypt doubly
    // encrypted passwords.
    //

    RtlCopyMemory(
            requestMessage.Message.DownLevelApi.LanmanSessionKey,
            session->LanManSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );

    //
    // Set the flags
    //

    requestMessage.Message.DownLevelApi.Flags = 0;

    if ( IS_NT_DIALECT( connection->SmbDialect ) ) {

        requestMessage.Message.DownLevelApi.Flags |= XS_FLAGS_NT_CLIENT;
    }

    //
    // Send the message to XACTSRV and wait for a response message.
    //
    // !!! We may want to put a timeout on this.
    //

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsRequest: Sending message at %p, port mem %p.\n",
                      &requestMessage,  transaction ));
    }

    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {

        status = NtRequestWaitReplyPort(
                     SrvXsPortHandle,
                     (PPORT_MESSAGE)&requestMessage,
                     (PPORT_MESSAGE)&replyMessage
                     );

        REVERT( );
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvXsRequest: NtRequestWaitReplyPort failed: %X\n",
                          status ));
        }
        SrvSetSmbError( WorkContext, status );
        returnStatus = SmbTransStatusErrorWithoutData;
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsRequest: Received response at %p\n", &replyMessage ));
    }

    //
    // Check the status returned in the reply.
    //

    status = replyMessage.Message.DownLevelApi.Status;

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvXsRequest: XACTSRV reply had status %X\n", status ));
        }
        SrvSetSmbError( WorkContext, status );
        returnStatus = SmbTransStatusErrorWithoutData;
        goto exit;
    }

    returnStatus = SmbTransStatusSuccess;

exit:

    //
    // We're done with the API.  Free up the buffer containing the
    // transport name.
    //

    if ( requestMessage.Message.DownLevelApi.TransportName != NULL ) {

        requestMessage.Message.DownLevelApi.TransportName =
            (PWSTR)((PUCHAR)requestMessage.Message.DownLevelApi.TransportName -
                            SrvXsPortMemoryDelta);

        SrvXsFreeHeap( requestMessage.Message.DownLevelApi.TransportName );

    }

    //
    // Convert the relevant pointers in the transaction block back to
    // the server base.
    //

    transaction->TransactionName.Buffer -= SrvXsPortMemoryDelta;
    transaction->InSetup -= SrvXsPortMemoryDelta;
    transaction->OutSetup -= SrvXsPortMemoryDelta;
    transaction->InParameters -= SrvXsPortMemoryDelta;
    transaction->OutParameters -= SrvXsPortMemoryDelta;
    transaction->InData -= SrvXsPortMemoryDelta;
    transaction->OutData -= SrvXsPortMemoryDelta;

    return returnStatus;

} // SrvXsRequest


NTSTATUS
SrvXsLSOperation (
IN PSESSION Session,
IN ULONG Type
)

/*++

Routine Description:

    This routine causes the Xact service to do an NtLSRequest call

Arguments:

    Session - a pointer to the session structure involved in the request

    Type - either XACTSRV_MESSAGE_LSREQUEST or XACTSRV_MESSAGE_LSRELEASE
            depending on whether a license is being requested or being
            released.

Return Value:

    STATUS_SUCCESS if the license was granted

Notes:
    Once a license is granted for a particular session, it is never released
      until the session is deallocated.  Therefore, it is only necessary to
      hold the Session->Connection->LicenseLock when we are checking for
      acquisition of the license.

    We don't need licenses if we are running on a workstation.
    We don't try for licenses over NULL sessions

--*/

{
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;
    NTSTATUS status;
    ULONG requestLength;
    UNICODE_STRING userName, userDomain;

    PAGED_CODE( );

    if( SrvProductTypeServer == FALSE || !SrvXsActive ) {
        return STATUS_SUCCESS;
    }

    switch( Type ) {
    case XACTSRV_MESSAGE_LSREQUEST:

        if( Session->IsNullSession ||
            Session->IsLSNotified ) {

                return STATUS_SUCCESS;
        }

        ACQUIRE_LOCK( &Session->Connection->LicenseLock );

        if( Session->IsLSNotified == TRUE ) {
            RELEASE_LOCK( &Session->Connection->LicenseLock );
            return STATUS_SUCCESS;
        }

        //
        // Put domainname\username in the message
        //
        status = SrvGetUserAndDomainName( Session, &userName, &userDomain );
        if( !NT_SUCCESS( status ) ) {
            RELEASE_LOCK( &Session->Connection->LicenseLock );
            return status;
        }

        requestMessage.Message.LSRequest.UserName =
            SrvXsAllocateHeap( userDomain.Length + sizeof(WCHAR)
                               + userName.Length + sizeof(WCHAR), &status
                             );

        if ( requestMessage.Message.LSRequest.UserName == NULL ) {
            RELEASE_LOCK( &Session->Connection->LicenseLock );
            SrvReleaseUserAndDomainName( Session, &userName, &userDomain );
            return status;
        }

        if( userDomain.Length ) {
            RtlCopyMemory(
                requestMessage.Message.LSRequest.UserName,
                userDomain.Buffer,
                userDomain.Length
                );
        }

        requestMessage.Message.LSRequest.UserName[ userDomain.Length / sizeof(WCHAR) ] = L'\\';

        RtlCopyMemory(
            requestMessage.Message.LSRequest.UserName + (userDomain.Length / sizeof( WCHAR )) + 1,
            userName.Buffer,
            userName.Length
            );

        requestMessage.Message.LSRequest.UserName[ (userDomain.Length
                                                   + userName.Length) / sizeof( WCHAR )
                                                   + 1 ]
            = UNICODE_NULL;

        requestMessage.Message.LSRequest.IsAdmin = SrvIsAdmin( Session->UserHandle );

        IF_DEBUG(LICENSE) {
            KdPrint(("XACTSRV_MESSAGE_LSREQUEST: %ws, IsAdmin: %d\n",
            requestMessage.Message.LSRequest.UserName,
            requestMessage.Message.LSRequest.IsAdmin ));
        }

        // Adjust the buffer pointers to be self relative within the buffer.

        requestMessage.Message.LSRequest.UserName =
            (PWSTR)((PUCHAR)requestMessage.Message.LSRequest.UserName + SrvXsPortMemoryDelta);

        SrvReleaseUserAndDomainName( Session, &userName, &userDomain );

        break;

    case XACTSRV_MESSAGE_LSRELEASE:

        if( Session->IsLSNotified == FALSE )
            return STATUS_SUCCESS;

        IF_DEBUG(LICENSE) {
            KdPrint(("XACTSRV_MESSAGE_LSRELEASE: Handle %p\n", Session->hLicense ));
        }


        requestMessage.Message.LSRelease.hLicense = Session->hLicense;

        break;

    default:

        ASSERT( !"Bad Type" );
        return STATUS_INVALID_PARAMETER;
    }

    requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = Type;

    //
    // Send the message to XACTSRV and wait for a response message.
    //
    // !!! We may want to put a timeout on this.
    //

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    IF_DEBUG( ERRORS ) {
        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "SrvXsLSOperation: NtRequestWaitReplyPort failed: %X\n", status ));
        }
    }

    if( NT_SUCCESS( status ) )
        status = replyMessage.Message.LSRequest.Status;

    switch( Type ) {

    case XACTSRV_MESSAGE_LSREQUEST:

        requestMessage.Message.LSRequest.UserName =
            (PWSTR)((PUCHAR)requestMessage.Message.LSRequest.UserName - SrvXsPortMemoryDelta);
        SrvXsFreeHeap( requestMessage.Message.LSRequest.UserName );

        if( NT_SUCCESS( status ) ) {
            Session->IsLSNotified = TRUE;
            Session->hLicense = replyMessage.Message.LSRequest.hLicense;
            IF_DEBUG( LICENSE ) {
                KdPrint(("  hLicense = %p\n", Session->hLicense ));
            }
        }
        RELEASE_LOCK( &Session->Connection->LicenseLock );
        break;

    case XACTSRV_MESSAGE_LSRELEASE:

        Session->IsLSNotified = FALSE;
        break;
    }

    IF_DEBUG( LICENSE ) {
        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "    SrvXsLSOperation returning status %X\n", status ));
        }
    }

    return status;

} // SrvXsLSOperation


VOID
SrvXsPnpOperation(
    PUNICODE_STRING DeviceName,
    BOOLEAN Bind
)

/*++

Routine Description:

    This routine sends the Xact service a PNP notification

--*/

{
    PXACTSRV_REQUEST_MESSAGE requestMessage;
    PXACTSRV_REQUEST_MESSAGE responseMessage;
    ULONG len;
    NTSTATUS status;

    PAGED_CODE( );

    if( SrvXsPortHandle == NULL ) {
        IF_DEBUG( PNP ) {
            KdPrint(( "SRV: SrvXsPnpOperation no SRVSVC handle!\n" ));
        }
        return;
    }

    len = (sizeof( XACTSRV_REQUEST_MESSAGE ) * 2) + DeviceName->Length + sizeof( WCHAR );

    requestMessage = SrvXsAllocateHeap( len, &status );

    if( requestMessage == NULL ) {
        IF_DEBUG( PNP ) {
            KdPrint(( "SRV: SrvXsPnpOperation unable to allocate memory: %X\n", status ));
        }
        return;
    }

    RtlZeroMemory( requestMessage, len );

    responseMessage = requestMessage + 1;
    requestMessage->Message.Pnp.TransportName.Buffer = (PWCHAR)(responseMessage + 1);

    requestMessage->Message.Pnp.Bind = Bind;

    //
    // Send the name of the transport of interest to Xactsrv
    //
    requestMessage->Message.Pnp.TransportName.Length = DeviceName->Length;
    requestMessage->Message.Pnp.TransportName.MaximumLength = DeviceName->Length + sizeof( WCHAR );

    RtlCopyMemory( requestMessage->Message.Pnp.TransportName.Buffer,
                   DeviceName->Buffer,
                   DeviceName->Length
                 );

    //
    // Normalize the buffer pointer so xactsrv can rebase it
    //
    requestMessage->Message.Pnp.TransportName.Buffer = 
            (PWSTR)((PUCHAR)requestMessage->Message.Pnp.TransportName.Buffer + SrvXsPortMemoryDelta);

    requestMessage->PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(*requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage->PortMessage.u1.s1.TotalLength = sizeof(*requestMessage);
    requestMessage->PortMessage.u2.ZeroInit = 0;
    requestMessage->PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage->MessageType = XACTSRV_MESSAGE_PNP;

    //
    // Send the message to XACTSRV
    //

    IF_DEBUG( PNP ) {
        KdPrint(( "SRV: Sending PNP %sbind request for %wZ to SRVSVC\n",
                    requestMessage->Message.Pnp.Bind ? "" : "un", DeviceName
               ));
    }

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                 (PPORT_MESSAGE)requestMessage,
                 (PPORT_MESSAGE)responseMessage
                 );


    IF_DEBUG( PNP ) {
        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "SRV: PNP response from xactsrv status %X\n", status ));
        }
    }

    SrvXsFreeHeap( requestMessage );
}


VOID
SrvXsDisconnect ( )
{
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Acquire exclusive access to the port resource, to prevent new
    // requests from being started.
    //

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsDisconnect: Xactsrv disconnect called.\n"));
    }

    ExAcquireResourceExclusiveLite( &SrvXsResource, TRUE );

    SrvXsActive = FALSE;

    SrvXsFreeSharedMemory();

    ExReleaseResourceLite( &SrvXsResource );

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsDisconnect: SrvXsResource released.\n"));
    }

    return;

} // SrvXsDisconnect


VOID
SrvXsFreeSharedMemory (
    VOID
    )

/*++

Routine Description:

    This routine frees the xactsrv shared memory.  SrvXsResource assumed
    held exclusive.

Arguments:

    none.

Return Value:

    TRUE if xactsrv memory was freed, FALSE otherwise.

--*/

{
    PAGED_CODE( );

    //
    // Free up memory only if we don't have any transactions using the
    // shared memory.
    //

    if ( SrvXsSharedMemoryReference == 0 ) {
        if ( SrvXsPortMemoryHeap != NULL ) {
            RtlDestroyHeap( SrvXsPortMemoryHeap );
            SrvXsPortMemoryHeap = NULL;
        }

        if ( SrvXsSectionHandle != NULL ) {
            SrvNtClose( SrvXsSectionHandle, FALSE );
            SrvXsSectionHandle = NULL;
        }

        if ( SrvXsPortHandle != NULL ) {
            SrvNtClose( SrvXsPortHandle, FALSE );
            SrvXsPortHandle = NULL;
        }

        IF_DEBUG(XACTSRV) {
            KdPrint(( "SrvXsFreeSharedMemory: Xactsrv memory freed.\n" ));
        }
    } else {
        IF_DEBUG(XACTSRV) {
            KdPrint(( "SrvXsFreeSharedMemory: Active transactions %d.\n",
                        SrvXsSharedMemoryReference ));
        }
    }

    return;

} // SrvXsFreeSharedMemory


PVOID
SrvXsAllocateHeap (
    IN ULONG SizeOfAllocation OPTIONAL,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    This routine allocates heap from the Xs shared memory.

Arguments:

    SizeOfAllocation - if specified, the number of bytes to allocate.
                       if zero, no memory will be allocated.

    Status - the status of the request.

Return Value:

    Address of the allocated memory.  NULL, if no memory is allocated.

--*/

{
    PVOID heapAllocated = NULL;

    PAGED_CODE( );

    *Status = STATUS_SUCCESS;

    //
    // Check that XACTSRV is active.  This must be done while holding
    // the resource.
    //

    ExAcquireResourceExclusiveLite( &SrvXsResource, TRUE );
    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsAllocateHeap: SrvXsResource acquired.\n"));
    }

    if ( !SrvXsActive ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvXsAllocateHeap: XACTSRV is not active.\n" ));
        }
        ExReleaseResourceLite( &SrvXsResource );
        IF_DEBUG(XACTSRV) {
            KdPrint(( "SrvXsAllocateHeap: SrvXsResource released.\n"));
        }
        *Status = STATUS_NOT_SUPPORTED;
        return NULL;
    }

    //
    // Increment reference to our shared memory.
    //

    SrvXsSharedMemoryReference++;

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsAllocateHeap: Incremented transaction count = %d.\n",
            SrvXsSharedMemoryReference
            ));
    }

    //
    // If SizeOfAllocation == 0, then the caller does not want any heap
    // allocated and only wants to have the lock held.
    //

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsAllocateHeap: Heap to allocate %d bytes.\n",
            SizeOfAllocation
            ));
    }

    if ( SizeOfAllocation > 0 ) {

        heapAllocated = RtlAllocateHeap(
                            SrvXsPortMemoryHeap,
                            HEAP_NO_SERIALIZE,
                            SizeOfAllocation
                            );

        if ( heapAllocated == NULL ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvXsAllocateHeap: RtlAllocateHeap failed "
                    "to allocate %d bytes.\n",
                    SizeOfAllocation
                    ));
            }

            *Status = STATUS_INSUFF_SERVER_RESOURCES;
        }
    }

    //
    // Release the resource.
    //

    ExReleaseResourceLite( &SrvXsResource );
    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsAllocateHeap: SrvXsResource released.\n"));
    }

    return heapAllocated;

} // SrvXsAllocateHeap


VOID
SrvXsFreeHeap (
    IN PVOID MemoryToFree OPTIONAL
    )

/*++

Routine Description:

    This routine frees heap allocated through SrvXsAllocateHeap.

Arguments:

    MemoryToFree - pointer to the memory to be freed. If NULL, no memory
                    is freed.

Return Value:

    none.

--*/

{
    PAGED_CODE( );

    //
    // We need exclusive access to the resource in order to free
    // heap and decrement the reference count.
    //

    ExAcquireResourceExclusiveLite( &SrvXsResource, TRUE );
    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsFreeHeap: SrvXsResource acquired.\n"));
    }

    //
    // Free the allocated heap (if any).
    //

    if ( MemoryToFree != NULL ) {
        RtlFreeHeap( SrvXsPortMemoryHeap, 0, MemoryToFree );
        IF_DEBUG(XACTSRV) {
            KdPrint(( "SrvXsFreeHeap: Heap %p freed.\n", MemoryToFree ));
        }
    }

    //
    // Decrement the shared memory reference count, and check whether XS
    // shutdown is in progress.  If so, complete XS cleanup if the
    // reference count reaches 0.
    //

    ASSERT( SrvXsSharedMemoryReference > 0 );
    SrvXsSharedMemoryReference--;

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsFreeHeap: Decrement transaction count = %d.\n",
            SrvXsSharedMemoryReference
            ));
    }

    //
    // If SrvXsActive is FALSE, XACTSRV cleanup is in progress.
    //

    if ( !SrvXsActive ) {
        SrvXsFreeSharedMemory( );
    }

    //
    // Release the resource.
    //

    ExReleaseResourceLite( &SrvXsResource );
    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsFreeHeap: SrvXsResource released.\n"));
    }

    return;

} // SrvXsFreeHeap
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\allocsup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements mappings to physical blocks on UDF media.  The basic
    structure used here is the Pcb, which contains lookup information for each
    partition reference in the volume.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	5-Sep-1996
    
Revision History:

    Tom Jolly       [TomJolly]  21-Jan-2000     CcPurge and append at vmcb end
    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_ALLOCSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_ALLOCSUP)

//
//  Local support routines.
//

PPCB
UdfCreatePcb (
    IN ULONG NumberOfPartitions
    );

NTSTATUS
UdfLoadSparingTables(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PPCB Pcb,
    ULONG Reference
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfAddToPcb)
#pragma alloc_text(PAGE, UdfCompletePcb)
#pragma alloc_text(PAGE, UdfCreatePcb)
#pragma alloc_text(PAGE, UdfDeletePcb)
#pragma alloc_text(PAGE, UdfEquivalentPcb)
#pragma alloc_text(PAGE, UdfInitializePcb)
#pragma alloc_text(PAGE, UdfLookupAllocation)
#pragma alloc_text(PAGE, UdfLookupMetaVsnOfExtent)
#pragma alloc_text(PAGE, UdfLookupPsnOfExtent)
#endif


BOOLEAN
UdfLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN LONGLONG FileOffset,
    OUT PLONGLONG DiskOffset,
    OUT PULONG ByteCount
    )

/*++

Routine Description:

    This routine looks through the mapping information for the file
    to find the logical diskoffset and number of bytes at that offset.

    This routine assumes we are looking up a valid range in the file.  If
    a mapping does not exist,

Arguments:

    Fcb - Fcb representing this stream.

    FileOffset - Lookup the allocation beginning at this point.

    DiskOffset - Address to store the logical disk offset.

    ByteCount - Address to store the number of contiguous bytes beginning
        at DiskOffset above.

Return Value:

    BOOLEAN - whether the extent is unrecorded data

--*/

{
    PVCB Vcb;

    BOOLEAN Recorded = TRUE;

    BOOLEAN Result;

    LARGE_INTEGER LocalPsn;
    LARGE_INTEGER LocalSectorCount;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  We will never be looking up the allocations of embedded objects.
    //

    ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_EMBEDDED_DATA ));

    Vcb = Fcb->Vcb;

    LocalPsn.QuadPart = LocalSectorCount.QuadPart = 0;

    //
    //  Lookup the entry containing this file offset.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_VMCB_MAPPING )) {

        //
        //  Map this offset into the metadata stream.
        //

        ASSERT( SectorOffset( Vcb, FileOffset ) == 0 );

        Result = UdfVmcbVbnToLbn( &Vcb->Vmcb,
                                  SectorsFromBytes( Vcb, FileOffset ),
                                  &LocalPsn.LowPart,
                                  &LocalSectorCount.LowPart );
    } else {

        //
        //  Map this offset in a regular stream.
        //

        ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED ));

        Result = FsRtlLookupLargeMcbEntry( &Fcb->Mcb,
                                           LlSectorsFromBytes( Vcb, FileOffset ),
                                           &LocalPsn.QuadPart,
                                           &LocalSectorCount.QuadPart,
                                           NULL,
                                           NULL,
                                           NULL );
    }

    //
    //  If within the Mcb then we use the data out of this entry and are nearly done.
    //

    if (Result) {

        if ( LocalPsn.QuadPart == -1 ) {

            //
            //  Regular files can have holey allocations which represent unrecorded extents.  For
            //  such extents which are sandwiched in between recorded extents of the file, the Mcb
            //  package tells us that it found a valid mapping but that it doesn't correspond to
            //  any extents on the media yet.  In this case, simply fake the disk offset.  The
            //  returned sector count is accurate.
            //

            *DiskOffset = 0;

            Recorded = FALSE;

        } else {

            //
            //  Now mimic the effects of physical sector sparing.  This may shrink the size of the
            //  returned run if sparing interrupted the extent on disc.
            //

            ASSERT( LocalPsn.HighPart == 0 );

            if (Vcb->Pcb->SparingMcb) {

                LONGLONG SparingPsn;
                LONGLONG SparingSectorCount;

                if (FsRtlLookupLargeMcbEntry( Vcb->Pcb->SparingMcb,
                                              LocalPsn.LowPart,
                                              &SparingPsn,
                                              &SparingSectorCount,
                                              NULL,
                                              NULL,
                                              NULL )) {

                    //
                    //  Only emit noise if we will really change anything as a result
                    //  of the sparing table.
                    //

                    if (SparingPsn != -1 ||
                        SparingSectorCount < LocalSectorCount.QuadPart) {

                        DebugTrace(( 0, Dbg, "UdfLookupAllocation, spared [%x, +%x) onto [%x, +%x)\n",
                                             LocalPsn.LowPart,
                                             LocalSectorCount.LowPart,
                                             (ULONG) SparingPsn,
                                             (ULONG) SparingSectorCount ));
                    }

                    //
                    //  If we did not land in a hole, map the sector.
                    //

                    if (SparingPsn != -1) {

                        LocalPsn.QuadPart = SparingPsn;
                    }

                    //
                    //  The returned sector count now reduces the previous sector count.
                    //  If we landed in a hole, this indicates that the trailing edge of
                    //  the extent is spared, if not this indicates that the leading
                    //  edge is spared.
                    //

                    if (SparingSectorCount < LocalSectorCount.QuadPart) {

                        LocalSectorCount.QuadPart = SparingSectorCount;
                    }
                }
            }

            *DiskOffset = LlBytesFromSectors( Vcb, LocalPsn.QuadPart ) + SectorOffset( Vcb, FileOffset );

            //
            //  Now we can apply method 2 fixups, which will again interrupt the size of the extent.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP )) {

                LARGE_INTEGER SectorsToRunout;

                SectorsToRunout.QuadPart= UdfMethod2NextRunoutInSectors( Vcb, *DiskOffset );

                if (SectorsToRunout.QuadPart < LocalSectorCount.QuadPart) {

                    LocalSectorCount.QuadPart = SectorsToRunout.QuadPart;
                }

                *DiskOffset = UdfMethod2TransformByteOffset( Vcb, *DiskOffset );
            }
        }

    } else {

        //
        //  We know that prior to this call the system has restricted IO to points within the
        //  the file data.  Since we failed to find a mapping this is an unrecorded extent at
        //  the end of the file, so just conjure up a proper representation.
        //

        if ((Ccb != NULL) && FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO )) {
            
            LocalSectorCount.QuadPart = LlSectorsFromBytes( Vcb, ByteCount );
            *DiskOffset = FileOffset;
            
            Recorded = TRUE;
            
        } else {
        
            ASSERT( FileOffset < Fcb->FileSize.QuadPart );
            
            LocalSectorCount.QuadPart = LlSectorsFromBytes( Vcb, Fcb->FileSize.QuadPart ) -
                                        LlSectorsFromBytes( Vcb, FileOffset ) +
                                        1;
            *DiskOffset = 0;
            
            Recorded = FALSE;

        }
        
    }

    //
    //  Restrict to MAXULONG bytes of allocation
    //

    if (LocalSectorCount.QuadPart > SectorsFromBytes( Vcb, MAXULONG )) {

        *ByteCount = MAXULONG;

    } else {

        *ByteCount = BytesFromSectors( Vcb, LocalSectorCount.LowPart );
    }

    *ByteCount -= SectorOffset( Vcb, FileOffset );

    return Recorded;
}


VOID
UdfDeletePcb (
    IN PPCB Pcb
    )

/*++

Routine Description:

    This routine deallocates a Pcb and all ancilliary structures.

Arguments:

    Pcb - Pcb being deleted

Return Value:

    None

--*/

{
    PPARTITION Partition;

    if (Pcb->SparingMcb) {

        FsRtlUninitializeLargeMcb( Pcb->SparingMcb );
        UdfFreePool( &Pcb->SparingMcb );
    }

    for (Partition = Pcb->Partition;
         Partition < &Pcb->Partition[Pcb->Partitions];
         Partition++) {

        switch (Partition->Type) {

            case Physical:

                UdfFreePool( &Partition->Physical.PartitionDescriptor );
                UdfFreePool( &Partition->Physical.SparingMap );                

                break;

            case Virtual:
            case Uninitialized:
                break;

            default:

                ASSERT( FALSE );
                break;
        }
    }

    ExFreePool( Pcb );
}


NTSTATUS
UdfInitializePcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PPCB *Pcb,
    IN PNSR_LVOL LVD
    )

/*++

Routine Description:

    This routine walks through the partition map of a Logical Volume Descriptor
    and builds an intializing Pcb from it.  The Pcb will be ready to be used
    in searching for the partition descriptors of a volume.

Arguments:

    Vcb - The volume this Pcb will pertain to

    Pcb - Caller's pointer to the Pcb

    LVD - The Logical Volume Descriptor being used

Return Value:

    STATUS_SUCCESS if the partition map is good and the Pcb is built

    STATUS_DISK_CORRUPT_ERROR if corrupt maps are found

    STATUS_UNRECOGNIZED_VOLUME if noncompliant maps are found

--*/

{
    PPARTMAP_UDF_GENERIC Map;
    PPARTITION Partition;

    BOOLEAN Found;

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_OPTIONAL_PCB( *Pcb );

    DebugTrace(( +1, Dbg,
                 "UdfInitializePcb, Lvd %08x\n",
                 LVD ));

    //
    //  Delete a pre-existing (partially initialized from a failed
    //  crawl of a VDS) Pcb.
    //

    if (*Pcb != NULL) {

        UdfDeletePcb( *Pcb );
        *Pcb = NULL;
    }

    *Pcb = UdfCreatePcb( LVD->MapTableCount );

    //
    //  Walk the table of partition maps intializing the Pcb for the descriptor
    //  initialization pass.
    //

    for (Map = (PPARTMAP_UDF_GENERIC) LVD->MapTable,
         Partition = (*Pcb)->Partition;

         Partition < &(*Pcb)->Partition[(*Pcb)->Partitions];

         Map = Add2Ptr( Map, Map->Length, PPARTMAP_UDF_GENERIC ),
         Partition++) {

        //
        //  Now check that this LVD can actually contain this map entry.  First check that
        //  the descriptor can contain the first few fields, then check that it can hold
        //  all of the bytes claimed by the descriptor.
        //

        if (Add2Ptr( Map, sizeof( PARTMAP_GENERIC ), PCHAR ) > Add2Ptr( LVD, ISONsrLvolSize( LVD ), PCHAR ) ||
            Add2Ptr( Map, Map->Length,               PCHAR ) > Add2Ptr( LVD, ISONsrLvolSize( LVD ), PCHAR )) {

            DebugTrace(( 0, Dbg,
                         "UdfInitializePcb, map at +%04x beyond Lvd size %04x\n",
                         (PCHAR) Map - (PCHAR) LVD,
                         ISONsrLvolSize( LVD )));

            DebugTrace(( -1, Dbg,
                         "UdfInitializePcb -> STATUS_DISK_CORRUPT_ERROR\n" ));

            return STATUS_DISK_CORRUPT_ERROR;
        }

        //
        //  Now load up this map entry.
        //

        switch (Map->Type) {

            case PARTMAP_TYPE_PHYSICAL:

                {
                    PPARTMAP_PHYSICAL MapPhysical = (PPARTMAP_PHYSICAL) Map;

                    //
                    //  Type 1 - Physical Partition
                    //

                    DebugTrace(( 0, Dbg,
                                 "UdfInitializePcb, map reference %02x is Physical (Partition # %08x)\n",
                                 (Partition - (*Pcb)->Partition)/sizeof(PARTITION),
                                 MapPhysical->Partition ));

                    //
                    //  It must be the case that the volume the partition is on is the first
                    //  one since we only do single disc UDF.  This will have already been
                    //  checked by the caller.
                    //

                    if (MapPhysical->VolSetSeq > 1) {

                        DebugTrace(( 0, Dbg,
                                     "UdfInitializePcb, ... but physical partition resides on volume set volume # %08x (> 1)!\n",
                                     MapPhysical->VolSetSeq ));

                        DebugTrace(( -1, Dbg,
                                     "UdfInitializePcb -> STATUS_DISK_CORRUPT_ERROR\n" ));

                        return STATUS_DISK_CORRUPT_ERROR;
                    }

                    SetFlag( (*Pcb)->Flags, PCB_FLAG_PHYSICAL_PARTITION );
                    Partition->Type = Physical;
                    Partition->Physical.PartitionNumber = MapPhysical->Partition;
                }

                break;

            case PARTMAP_TYPE_PROXY:

                //
                //  Type 2 - a Proxy Partition, something not explicitly physical.
                //

                DebugTrace(( 0, Dbg,
                             "UdfInitializePcb, map reference %02x is a proxy\n",
                             (Partition - (*Pcb)->Partition)/sizeof(PARTITION)));

                //
                //  Handle the various types of proxy partitions we recognize
                //

                if (UdfDomainIdentifierContained( &Map->PartID,
                                                  &UdfVirtualPartitionDomainIdentifier,
                                                  UDF_VERSION_150,
                                                  UDF_VERSION_RECOGNIZED )) {

                    {
                        PPARTMAP_VIRTUAL MapVirtual = (PPARTMAP_VIRTUAL) Map;

                        //
                        //  Only one of these guys can exist, since there can be only one VAT per media surface.
                        //

                        if (FlagOn( (*Pcb)->Flags, PCB_FLAG_VIRTUAL_PARTITION )) {

                            DebugTrace(( 0, Dbg,
                                         "UdfInitializePcb, ... but this is a second virtual partition!?!!\n" ));

                            DebugTrace(( -1, Dbg,
                                         "UdfInitializePcb -> STATUS_UNCRECOGNIZED_VOLUME\n" ));

                            return STATUS_UNRECOGNIZED_VOLUME;
                        }

                        DebugTrace(( 0, Dbg,
                                     "UdfInitializePcb, ... Virtual (Partition # %08x)\n",
                                     MapVirtual->Partition ));

                        SetFlag( (*Pcb)->Flags, PCB_FLAG_VIRTUAL_PARTITION );
                        Partition->Type = Virtual;

                        //
                        //  We will convert the partition number to a partition reference
                        //  before returning.
                        //

                        Partition->Virtual.RelatedReference = MapVirtual->Partition;
                    }

                } else if (UdfDomainIdentifierContained( &Map->PartID,
                                                         &UdfSparablePartitionDomainIdentifier,
                                                         UDF_VERSION_150,
                                                         UDF_VERSION_RECOGNIZED )) {

                    {
                        NTSTATUS Status;
                        PPARTMAP_SPARABLE MapSparable = (PPARTMAP_SPARABLE) Map;

                        //
                        //  It must be the case that the volume the partition is on is the first
                        //  one since we only do single disc UDF.  This will have already been
                        //  checked by the caller.
                        //

                        if (MapSparable->VolSetSeq > 1) {

                            DebugTrace(( 0, Dbg,
                                         "UdfInitializePcb, ... but sparable partition resides on volume set volume # %08x (> 1)!\n",
                                         MapSparable->VolSetSeq ));

                            DebugTrace(( -1, Dbg,
                                         "UdfInitializePcb -> STATUS_DISK_CORRUPT_ERROR\n" ));

                            return STATUS_DISK_CORRUPT_ERROR;
                        }

                        DebugTrace(( 0, Dbg,
                                     "UdfInitializePcb, ... Sparable (Partition # %08x)\n",
                                     MapSparable->Partition ));

                        //
                        //  We pretend that sparable partitions are basically the same as
                        //  physical partitions.  Since we are not r/w (and will never be
                        //  on media that requires host-based sparing in any case), this
                        //  is a good simplification.
                        //

                        SetFlag( (*Pcb)->Flags, PCB_FLAG_SPARABLE_PARTITION );
                        Partition->Type = Physical;
                        Partition->Physical.PartitionNumber = MapSparable->Partition;

                        //
                        //  Save this map for use when the partition descriptor is found.
                        //  We can't load the sparing table at this time because we have
                        //  to turn the Lbn->Psn mapping into a Psn->Psn mapping.  UDF
                        //  believes that the way sparing will be used in concert with
                        //  the Lbn->Psn mapping engine (like UdfLookupPsnOfExtent).
                        //
                        //  Unfortunately, this would be a bit painful at this time.
                        //  The users of UdfLookupPsnOfExtent would need to iterate
                        //  over a new interface (not so bad) but the Vmcb package
                        //  would need to be turned inside out so that it didn't do
                        //  the page-filling alignment of blocks in the metadata
                        //  stream - instead, UdfLookupMetaVsnOfExtent would need to
                        //  do this itself.  I choose to lay the sparing engine into
                        //  the read path and raw sector read engine instead.
                        //

                        Partition->Physical.SparingMap = FsRtlAllocatePoolWithTag( PagedPool,
                                                                                   sizeof(PARTMAP_SPARABLE),
                                                                                   TAG_NSR_FSD);
                        RtlCopyMemory( Partition->Physical.SparingMap,
                                       MapSparable,
                                       sizeof(PARTMAP_SPARABLE));
                    }

                } else {

                    DebugTrace(( 0, Dbg,
                                 "UdfInitializePcb, ... but we don't recognize this proxy!\n" ));

                    DebugTrace(( -1, Dbg,
                                 "UdfInitializePcb -> STATUS_UNRECOGNIZED_VOLUME\n" ));

                    return STATUS_UNRECOGNIZED_VOLUME;
                }

                break;

            default:

                DebugTrace(( 0, Dbg,
                             "UdfInitializePcb, map reference %02x is of unknown type %02x\n",
                             Map->Type ));

                DebugTrace(( -1, Dbg,
                             "UdfInitializePcb -> STATUS_UNRECOGNIZED_VOLUME\n" ));

                return STATUS_UNRECOGNIZED_VOLUME;
                break;
        }
    }

    if (!FlagOn( (*Pcb)->Flags, PCB_FLAG_PHYSICAL_PARTITION | PCB_FLAG_SPARABLE_PARTITION )) {

        DebugTrace(( 0, Dbg,
                     "UdfInitializePcb, no physical partition seen on this logical volume!\n" ));

        DebugTrace(( -1, Dbg,
                     "UdfInitializePcb -> STATUS_UNRECOGNIZED_VOLUME\n" ));

        return STATUS_UNRECOGNIZED_VOLUME;
    }

    if (FlagOn( (*Pcb)->Flags, PCB_FLAG_VIRTUAL_PARTITION )) {

        PPARTITION Host;

        //
        //  Confirm the validity of any type 2 virtual maps on this volume
        //  and convert partition numbers to partition references that will
        //  immediately index an element of the Pcb.
        //

        for (Partition = (*Pcb)->Partition;
             Partition < &(*Pcb)->Partition[(*Pcb)->Partitions];
             Partition++) {

            if (Partition->Type == Virtual) {

                //
                //  Go find the partition this thing is talking about
                //

                Found = FALSE;

                for (Host = (*Pcb)->Partition;
                     Host < &(*Pcb)->Partition[(*Pcb)->Partitions];
                     Host++) {

                    if (Host->Type == Physical &&
                        Host->Physical.PartitionNumber ==
                        Partition->Virtual.RelatedReference) {

                        Partition->Virtual.RelatedReference =
                            (USHORT)(Host - (*Pcb)->Partition)/sizeof(PARTITION);
                        Found = TRUE;
                        break;
                    }
                }

                //
                //  Failure to find a physical partition for this virtual guy
                //  is not a good sign.
                //

                if (!Found) {

                    return STATUS_DISK_CORRUPT_ERROR;
                }
            }
        }
    }

    DebugTrace(( -1, Dbg,
             "UdfInitializePcb -> STATUS_SUCCESS\n" ));

    return STATUS_SUCCESS;
}


VOID
UdfAddToPcb (
    IN PPCB Pcb,
    IN PNSR_PART PartitionDescriptor
)

/*++

Routine Description:

    This routine possibly adds a partition descriptor into a Pcb if it
    turns out to be of higher precendence than a descriptor already
    present.  Used in building a Pcb already initialized in preperation
    for UdfCompletePcb.

Arguments:

    Vcb - Vcb of the volume the Pcb describes

    Pcb - Pcb being filled in

Return Value:

    None. An old partition descriptor may be returned in the input field.

--*/

{
    USHORT Reference;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_PCB( Pcb );
    ASSERT( PartitionDescriptor );

    for (Reference = 0;
         Reference < Pcb->Partitions;
         Reference++) {

        DebugTrace(( 0, Dbg, "UdfAddToPcb,  considering partition reference %d (type %d)\n", (ULONG)Reference, Pcb->Partition[Reference].Type));
        
        switch (Pcb->Partition[Reference].Type) {

            case Physical:

                //
                //  Now possibly store this descriptor in the Pcb if it is
                //  the partition number for this partition reference.
                //

                if (Pcb->Partition[Reference].Physical.PartitionNumber == PartitionDescriptor->Number) {

                    //
                    //  It seems to be legal (if questionable) for multiple partition maps to reference 
                    //  the same partition descriptor.  So we make a copy of the descriptor for each 
                    //  referencing partitionmap to make life easier when it comes to freeing it.
                    //

                    UdfStoreVolumeDescriptorIfPrevailing( (PNSR_VD_GENERIC *) &Pcb->Partition[Reference].Physical.PartitionDescriptor,
                                                          (PNSR_VD_GENERIC) PartitionDescriptor );
                }
                
                break;

            case Virtual:
                break;

            default:

                ASSERT(FALSE);
                break;
        }
    }
}


NTSTATUS
UdfCompletePcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PPCB Pcb
    )

/*++

Routine Description:

    This routine completes initialization of a Pcb which has been filled
    in with partition descriptors.  Initialization-time data such as the
    physical partition descriptors will be returned to the system.

Arguments:

    Vcb - Vcb of the volume the Pcb describes

    Pcb - Pcb being completed

Return Value:

    NTSTATUS according to whether intialization completion was succesful

--*/

{
    ULONG Reference;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT_PCB( Pcb );

    DebugTrace(( +1, Dbg, "UdfCompletePcb, Vcb %08x Pcb %08x\n", Vcb, Pcb ));

    //
    //  Complete intialization all physical partitions
    //

    for (Reference = 0;
         Reference < Pcb->Partitions;
         Reference++) {

        DebugTrace(( 0, Dbg, "UdfCompletePcb, Examining Ref %u (type %u)!\n", Reference, Pcb->Partition[Reference].Type));

        switch (Pcb->Partition[Reference].Type) {

            case Physical:

                if (Pcb->Partition[Reference].Physical.PartitionDescriptor == NULL) {

                    DebugTrace(( 0, Dbg,
                                 "UdfCompletePcb, ... but didn't find Partition# %u!\n",
                                 Pcb->Partition[Reference].Physical.PartitionNumber ));

                    DebugTrace(( -1, Dbg, "UdfCompletePcb -> STATUS_DISK_CORRUPT_ERROR\n" ));

                    return STATUS_DISK_CORRUPT_ERROR;
                }

                Pcb->Partition[Reference].Physical.Start =
                    Pcb->Partition[Reference].Physical.PartitionDescriptor->Start;
                Pcb->Partition[Reference].Physical.Length =
                    Pcb->Partition[Reference].Physical.PartitionDescriptor->Length;


                //
                //  Retrieve the sparing information at this point if appropriate.
                //  We have to do this when we can map logical -> physical blocks.
                //

                if (Pcb->Partition[Reference].Physical.SparingMap) {

                    Status = UdfLoadSparingTables( IrpContext,
                                                   Vcb,
                                                   Pcb,
                                                   Reference );

                    if (!NT_SUCCESS( Status )) {

                        DebugTrace(( -1, Dbg,
                                     "UdfCompletePcb -> %08x\n", Status ));
                        return Status;
                    }
                }

                DebugTrace(( 0, Dbg, "Start Psn: 0x%X,  sectors: 0x%x\n", 
                             Pcb->Partition[Reference].Physical.Start,
                             Pcb->Partition[Reference].Physical.Length));

                //
                //  We will not need the descriptor or sparing map anymore, so drop them.  
                //

                UdfFreePool( &Pcb->Partition[Reference].Physical.PartitionDescriptor );
                UdfFreePool( &Pcb->Partition[Reference].Physical.SparingMap );
                break;

            case Virtual:
                break;

            default:

                ASSERT(FALSE);
                break;
        }
    }

    DebugTrace(( -1, Dbg, "UdfCompletePcb -> STATUS_SUCCESS\n" ));

    return STATUS_SUCCESS;
}


BOOLEAN
UdfEquivalentPcb (
    IN PIRP_CONTEXT IrpContext,
    IN PPCB Pcb1,
    IN PPCB Pcb2
    )

/*++

Routine Description:

    This routine compares two completed Pcbs to see if they appear equivalent.

Arguments:

    Pcb1 - Pcb being compared

    Pcb2 - Pcb being compared

Return Value:

    BOOLEAN according to whether they are equivalent (TRUE, else FALSE)

--*/

{
    ULONG Index;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    if (Pcb1->Partitions != Pcb2->Partitions) {

        return FALSE;
    }

    for (Index = 0;
         Index < Pcb1->Partitions;
         Index++) {

        //
        //  First check that the partitions are of the same type.
        //

        if (Pcb1->Partition[Index].Type != Pcb2->Partition[Index].Type) {

            return FALSE;
        }

        //
        //  Now the map content must be the same ...
        //

        switch (Pcb1->Partition[Index].Type) {

            case Physical:

                if (Pcb1->Partition[Index].Physical.PartitionNumber != Pcb2->Partition[Index].Physical.PartitionNumber ||
                    Pcb1->Partition[Index].Physical.Length != Pcb2->Partition[Index].Physical.Length ||
                    Pcb1->Partition[Index].Physical.Start != Pcb2->Partition[Index].Physical.Start) {

                    return FALSE;
                }
                break;

            case Virtual:

                if (Pcb1->Partition[Index].Virtual.RelatedReference != Pcb2->Partition[Index].Virtual.RelatedReference) {

                    return FALSE;
                }
                break;

            default:

                ASSERT( FALSE);
                return FALSE;
                break;
        }
    }

    //
    //  All map elements were equivalent.
    //

    return TRUE;
}


ULONG
UdfLookupPsnOfExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT Reference,
    IN ULONG Lbn,
    IN ULONG Len
    )

/*++

Routine Description:

    This routine maps the input logical block extent on a given partition to
    a starting physical sector.  It doubles as a bounds checker - if the routine
    does not raise, the caller is guaranteed that the extent lies within the
    partition.

Arguments:

    Vcb - Vcb of logical volume

    Reference - Partition reference to use in the mapping

    Lbn - Logical block number

    Len - Length of extent in bytes

Return Value:

    ULONG physical sector number

--*/

{
    PPCB Pcb = Vcb->Pcb;
    ULONG Psn;

    PBCB Bcb;
    LARGE_INTEGER Offset;
    PULONG MappedLbn;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT_PCB( Pcb );

    DebugTrace(( +1, Dbg, "UdfLookupPsnOfExtent, [%04x/%08x, +%08x)\n", Reference, Lbn, Len ));

    if (Reference < Pcb->Partitions) {

        while (TRUE) {

            switch (Pcb->Partition[Reference].Type) {

                case Physical:

                    //
                    //  Check that the input extent lies inside the partition.  Calculate the
                    //  Lbn of the last block and see that it is interior.
                    //

                    if (SectorsFromBlocks( Vcb, Lbn ) + SectorsFromBytes( Vcb, Len ) >
                        Pcb->Partition[Reference].Physical.Length) {

                        goto NoGood;
                    }

                    Psn = Pcb->Partition[Reference].Physical.Start + SectorsFromBlocks( Vcb, Lbn );

                    DebugTrace(( -1, Dbg, "UdfLookupPsnOfExtent -> %08x\n", Psn ));
                    return Psn;

                case Virtual:

                    //
                    //  Bounds check.  Per UDF 2.00 2.3.10 and implied in UDF 1.50, virtual
                    //  extent lengths cannot be greater than one block in size.  Lbn must also
                    //  fall within the VAT!
                    //

                    if ((Lbn >= Vcb->VATEntryCount) || (Len > BlockSize( Vcb )))  {

                        DebugTrace(( 0, Dbg, "UdfLookupPsnOfExtent() - Either Lbn (0x%x) > VatLbns (0x%X), or len (0x%x) > blocksize (0x%x)\n", Lbn, Vcb->VATEntryCount, Len, BlockSize(Vcb)));
                        goto NoGood;
                    }

                    try {

                        Bcb = NULL;
                        
                        //
                        //  Calculate the location of the mapping element in the VAT
                        //  and retrieve.  Bias by the size of the VAT header,  if any.
                        //

                        Offset.QuadPart = Vcb->OffsetToFirstVATEntry + Lbn * sizeof(ULONG);

                        CcMapData( Vcb->VatFcb->FileObject,
                                   &Offset,
                                   sizeof(ULONG),
                                   TRUE,
                                   &Bcb,
                                   &MappedLbn );

                        //
                        //  Now rewrite the inputs in terms of the virtual mapping.  We
                        //  will reloop to perform the logical -> physical mapping.
                        //

                        DebugTrace(( 0, Dbg,
                                     "UdfLookupPsnOfExtent, Mapping V %04x/%08x -> L %04x/%08x\n",
                                     Reference,
                                     Lbn,
                                     Pcb->Partition[Reference].Virtual.RelatedReference,
                                     *MappedLbn ));

                        Lbn = *MappedLbn;
                        Reference = Pcb->Partition[Reference].Virtual.RelatedReference;

                    } finally {

                        DebugUnwind( UdfLookupPsnOfExtent );

                        UdfUnpinData( IrpContext, &Bcb );
                    }

                    //
                    //  An Lbn of ~0 in the VAT is defined to indicate that the sector is unused,
                    //  so we should never see such a thing.
                    //

                    if (Lbn == ~0) {

                        goto NoGood;
                    }

                    break;

                default:

                    ASSERT(FALSE);
                    break;
            }
        }
    }

    NoGood:

    //
    //  Some people have misinterpreted a partition number to equal a
    //  partition reference, or perhaps this is just corrupt media.
    //

    UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
}


ULONG
UdfLookupMetaVsnOfExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT Reference,
    IN ULONG Lbn,
    IN ULONG Len,
    IN BOOLEAN ExactEnd
    )

/*++

Routine Description:

    This routine maps the input logical block extent on a given partition to
    a starting virtual block in the metadata stream.  If a mapping does not
    exist, one will be created and the metadata stream extended.

    Callers must hold NO mappings into the VMCB stream when calling this
    function.
    
Arguments:

    Vcb - Vcb of logical volume

    Reference - Partition reference to use in the mapping

    Lbn - Logical block number

    Len - Length of extent in bytes
    
    ExactEnd - Indicates the extension policy if these blocks are not mapped.

Return Value:

    ULONG virtual sector number

    Raised status if the Lbn extent is split across multiple Vbn extents.

--*/

{
    ULONG Vsn;
    ULONG Psn;
    ULONG SectorCount;

    BOOLEAN Result;

    BOOLEAN UnwindExtension = FALSE;
    BOOLEAN UnwindVmcb = FALSE;
    LONGLONG UnwindAllocationSize;

    PFCB Fcb = NULL;

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    //
    //  The extent must be a multiple of blocksize
    //

    if ((0 == Len) || BlockOffset( Vcb, Len)) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  Get the physical mapping of the extent.  The Mcb package operates on ULONG/ULONG
    //  keys and values so we must render our 48bit address into 32.  We can do this since
    //  this is a single surface implementation, and it is guaranteed that a surface cannot
    //  contain more than MAXULONG physical sectors.
    //

    Psn = UdfLookupPsnOfExtent( IrpContext,
                                Vcb,
                                Reference,
                                Lbn,
                                Len );

    //
    //  Use try-finally for cleanup
    //

    try {

        //
        //  We must safely establish a mapping and extend the metadata stream so that cached
        //  reads can occur on this new extent.  This lock was moved out here (rather than just
        //  protecting the actual Fcb changes) to protect against mappings being made
        //  by other threads between this thread extending the vmcb and calling CcSetFileSizes.
        //  this would result in zeroed pages being mapped...
        //
        
        Fcb = Vcb->MetadataFcb;
        UdfLockFcb( IrpContext, Fcb );

        //
        //  Add / lookup the mapping.  We know that it is being added to the end of the stream.
        //
        
        UnwindVmcb = UdfAddVmcbMapping(IrpContext,
                                       &Vcb->Vmcb,
                                       Psn,
                                       SectorsFromBytes( Vcb, Len ),
                                       ExactEnd,
                                       &Vsn,
                                       &SectorCount );

        ASSERT( SectorCount >= SectorsFromBytes( Vcb, Len));

        //
        //  If this was a new mapping,  then we need to extend the Vmcb file size
        //
        
        if (UnwindVmcb)  {

            UnwindAllocationSize = Fcb->AllocationSize.QuadPart;
            UnwindExtension = TRUE;

            Fcb->AllocationSize.QuadPart =
            Fcb->FileSize.QuadPart =
            Fcb->ValidDataLength.QuadPart = LlBytesFromSectors( Vcb, Vsn + SectorCount);

            CcSetFileSizes( Fcb->FileObject, (PCC_FILE_SIZES) &Fcb->AllocationSize );
            UnwindExtension = FALSE;
        }

    } 
    finally {

        if (UnwindExtension) {

            ULONG FirstZappedVsn;

            //
            //  Strip off the additional mappings we made.
            //

            Fcb->AllocationSize.QuadPart =
            Fcb->FileSize.QuadPart =
            Fcb->ValidDataLength.QuadPart = UnwindAllocationSize;

            FirstZappedVsn = SectorsFromBytes( Vcb, UnwindAllocationSize );

            if (UnwindVmcb)  {
                
                UdfRemoveVmcbMapping( &Vcb->Vmcb,
                                      FirstZappedVsn,
                                      Vsn + SectorCount - FirstZappedVsn );
            }

            CcSetFileSizes( Fcb->FileObject, (PCC_FILE_SIZES) &Fcb->AllocationSize );
        }

        if (Fcb) { UdfUnlockFcb( IrpContext, Fcb ); }
    }

    return Vsn;
}


//
//  Local support routine.
//

PPCB
UdfCreatePcb (
    IN ULONG NumberOfPartitions
    )

/*++

Routine Description:

    This routine creates a new Pcb of the indicated size.

Arguments:

    NumberOfPartitions - Number of partitions this Pcb will describe

Return Value:

    PPCB - the Pcb created

--*/

{
    PPCB Pcb;
    ULONG Size = sizeof(PCB) + sizeof(PARTITION)*NumberOfPartitions;

    PAGED_CODE();

    ASSERT( NumberOfPartitions );
    ASSERT( NumberOfPartitions < MAXUSHORT );

    Pcb = (PPCB) FsRtlAllocatePoolWithTag( UdfPagedPool,
                                           Size,
                                           TAG_PCB );

    RtlZeroMemory( Pcb, Size );

    Pcb->NodeTypeCode = UDFS_NTC_PCB;
    Pcb->NodeByteSize = (USHORT) Size;

    Pcb->Partitions = (USHORT)NumberOfPartitions;

    return Pcb;
}


//
//  Internal support routine
//

NTSTATUS
UdfLoadSparingTables(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PPCB Pcb,
    ULONG Reference
    )

/*++

Routine Description:

    This routine reads the sparing tables for a partition and fills
    in the sparing Mcb.

Arguments:

    Vcb - the volume hosting the spared partition

    Pcb - the partion block corresponding to the volume

    Reference - the partition reference being pulled in

Return Value:

    NTSTATUS according to whether the sparing tables were loaded

--*/

{
    NTSTATUS Status;

    ULONG SparingTable;
    PULONG SectorBuffer;
    ULONG Psn;

    ULONG RemainingBytes;
    ULONG ByteOffset;
    ULONG TotalBytes;

    BOOLEAN Complete;

    PSPARING_TABLE_HEADER Header;
    PSPARING_TABLE_ENTRY Entry;

    PPARTITION Partition = &Pcb->Partition[Reference];
    PPARTMAP_SPARABLE Map = Partition->Physical.SparingMap;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    ASSERT( Map != NULL );

    DebugTrace(( +1, Dbg, "UdfLoadSparingTables, Vcb %08x, PcbPartition %08x, Map @ %08x\n", Vcb, Partition, Map ));

    DebugTrace(( 0, Dbg, "UdfLoadSparingTables, Map sez: PacketLen %u, NTables %u, TableSize %u\n",
                         Map->PacketLength,
                         Map->NumSparingTables,
                         Map->TableSize));


    //
    //  Check that the sparale map appears sane.  If there are no sparing tables that
    //  is pretty OK, and it'll wind up looking like a regular physical partition.
    //

    if (Map->NumSparingTables == 0) {

        DebugTrace((  0, Dbg, "UdfLoadSparingTables, no sparing tables claimed!\n" ));
        DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_SUCCESS\n" ));
        return STATUS_SUCCESS;
    }

    if (Map->NumSparingTables > sizeof(Map->TableLocation)/sizeof(ULONG)) {

        DebugTrace((  0, Dbg, "UdfLoadSparingTables, too many claimed tables to fit! (max %u)\n",
                              sizeof(Map->TableLocation)/sizeof(ULONG)));
        DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_DISK_CORRUPT_ERROR\n" ));
        return  STATUS_DISK_CORRUPT_ERROR;
    }

    if (Map->PacketLength != UDF_SPARING_PACKET_LENGTH) {

        DebugTrace((  0, Dbg, "UdfLoadSparingTables, packet size is %u (not %u!\n",
                              Map->PacketLength,
                              UDF_SPARING_PACKET_LENGTH ));
        DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_DISK_CORRUPT_ERROR\n" ));
        return  STATUS_DISK_CORRUPT_ERROR;
    }

    if (Map->TableSize < sizeof(SPARING_TABLE_HEADER) ||
        (Map->TableSize - sizeof(SPARING_TABLE_HEADER)) % sizeof(SPARING_TABLE_ENTRY) != 0) {

        DebugTrace((  0, Dbg, "UdfLoadSparingTables, sparing table size is too small or unaligned!\n" ));
        DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_DISK_CORRUPT_ERROR\n" ));
        return  STATUS_DISK_CORRUPT_ERROR;
    }

#ifdef UDF_SANITY
    DebugTrace(( 0, Dbg, "UdfLoadSparingTables" ));
    for (SparingTable = 0; SparingTable < Map->NumSparingTables; SparingTable++) {

        DebugTrace(( 0, Dbg, ", Table %u @ %x", SparingTable, Map->TableLocation[SparingTable] ));
    }
    DebugTrace(( 0, Dbg, "\n" ));
#endif

    //
    //  If a sparing mcb doesn't exist, manufacture one.
    //

    if (Pcb->SparingMcb == NULL) {

        Pcb->SparingMcb = FsRtlAllocatePoolWithTag( PagedPool, sizeof(LARGE_MCB), TAG_SPARING_MCB );
        FsRtlInitializeLargeMcb( Pcb->SparingMcb, PagedPool );
    }

    SectorBuffer = FsRtlAllocatePoolWithTag( PagedPool, PAGE_SIZE, TAG_NSR_FSD );

    //
    //  Now loop across the sparing tables and pull the data in.
    //

    try {

        for (Complete = FALSE, SparingTable = 0;

             SparingTable < Map->NumSparingTables;

             SparingTable++) {

            DebugTrace((  0, Dbg, "UdfLoadSparingTables, loading sparing table %u!\n",
                                  SparingTable ));

            ByteOffset = 0;
            TotalBytes = 0;
            RemainingBytes = 0;

            do {

                if (RemainingBytes == 0) {

                    (VOID) UdfReadSectors( IrpContext,
                                           BytesFromSectors( Vcb, Map->TableLocation[SparingTable] ) + ByteOffset,
                                           SectorSize( Vcb ),
                                           FALSE,
                                           SectorBuffer,
                                           Vcb->TargetDeviceObject );

                    //
                    //  Verify the descriptor at the head of the sparing table.  If it is not
                    //  valid, we just break out for a chance at the next table, if any.
                    //

                    if (ByteOffset == 0) {

                        Header = (PSPARING_TABLE_HEADER) SectorBuffer;

                        if (!UdfVerifyDescriptor( IrpContext,
                                                  &Header->Destag,
                                                  0,
                                                  SectorSize( Vcb ),
                                                  Header->Destag.Lbn,
                                                  TRUE )) {

                            DebugTrace((  0, Dbg, "UdfLoadSparingTables, sparing table %u didn't verify destag!\n",
                                                  SparingTable ));
                            break;
                        }

                        if (!UdfUdfIdentifierContained( &Header->RegID,
                                                        &UdfSparingTableIdentifier,
                                                        UDF_VERSION_150,
                                                        UDF_VERSION_RECOGNIZED,
                                                        OSCLASS_INVALID,
                                                        OSIDENTIFIER_INVALID)) {

                            DebugTrace((  0, Dbg, "UdfLoadSparingTables, sparing table %u didn't verify regid!\n",
                                                  SparingTable ));
                            break;
                        }

                        //
                        //  Calculate the total number bytes this map spans and check it against what
                        //  we were told the sparing table sizes are.
                        //

                        DebugTrace(( 0, Dbg, "UdfLoadSparingTables, Sparing table %u has %u entries\n",
                                             SparingTable,
                                             Header->TableEntries ));

                        TotalBytes = sizeof(SPARING_TABLE_HEADER) + Header->TableEntries * sizeof(SPARING_TABLE_ENTRY);

                        if (Map->TableSize < TotalBytes) {

                            DebugTrace((  0, Dbg, "UdfLoadSparingTables, sparing table #ents %u overflows allocation!\n",
                                                  Header->TableEntries ));
                            break;
                        }

                        //
                        //  So far so good, advance past the header.
                        //

                        ByteOffset = sizeof(SPARING_TABLE_HEADER);
                        Entry = Add2Ptr( SectorBuffer, sizeof(SPARING_TABLE_HEADER), PSPARING_TABLE_ENTRY );

                    } else {

                        //
                        //  Pick up in the new sector.
                        //

                        Entry = (PSPARING_TABLE_ENTRY) SectorBuffer;
                    }

                    RemainingBytes = Min( SectorSize( Vcb ), TotalBytes - ByteOffset );
                }

                //
                //  Add the mapping.  Since sparing tables are an Lbn->Psn mapping,
                //  very odd, and I want to simplify things by putting the sparing
                //  in right at IO dispatch, translate this to a Psn->Psn mapping.
                //

                if (Entry->Original != UDF_SPARING_AVALIABLE &&
                    Entry->Original != UDF_SPARING_DEFECTIVE) {

                    Psn = Partition->Physical.Start + SectorsFromBlocks( Vcb, Entry->Original );

                    DebugTrace((  0, Dbg, "UdfLoadSparingTables, mapping from Psn %x (Lbn %x) -> Psn %x\n",
                                          Psn,
                                          Entry->Original,
                                          Entry->Mapped ));

                    FsRtlAddLargeMcbEntry( Pcb->SparingMcb,
                                           Psn,
                                           Entry->Mapped,
                                           UDF_SPARING_PACKET_LENGTH );
                }

                //
                //  Advance to the next, and drop out if we've hit the end.
                //

                ByteOffset += sizeof(SPARING_TABLE_ENTRY);
                RemainingBytes -= sizeof(SPARING_TABLE_ENTRY);
                Entry++;

            } while ( ByteOffset < TotalBytes );
        }

    } finally {

        DebugUnwind( UdfLoadSparingTables );

        UdfFreePool( &SectorBuffer );
    }

    DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_SUCCESS\n" ));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\cleanup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Udfs called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     31-Oct-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_CLEANUP)


NTSTATUS
UdfCommonCleanup (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by both
    the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is closed.
    This is different than the Close operation which is invoked when the last
    reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the file/directory
    after a user is done with it.  The Fcb/Dcb remains around (because MM
    still has the file object referenced) but is now available for another
    user to open (i.e., as far as the user is concerned the is now closed).

    See close for a more complete description of what close does.

    We do no synchronization in this routine until we get to the point
    where we modify the counts, share access and volume lock field.

    We need to update the Fcb and Vcb to show that a user handle has been closed.
    The following structures and fields are affected.

    Vcb:

        VolumeLockFileObject - Did the user lock the volume with this file object.
        VcbState - Check if we are unlocking the volume here.
        VcbCleanup - Count of outstanding handles on the volume.
        DirNotifyQueue - If this file object has pending DirNotify Irps.

    Fcb:

        ShareAccess - If this is a user handle.
        FcbCleanup - Count of outstanding handles on this Fcb.
        Oplock - Any outstanding oplocks on this file object.
        FileLock - Any outstanding filelocks on this file object.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN SendUnlockNotification = FALSE;
    BOOLEAN AttemptTeardown;
    BOOLEAN VcbAcquired = FALSE;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    KIRQL SavedIrql;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get the file object out of the Irp and decode the type of open.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    TypeOfOpen = UdfDecodeFileObject( FileObject,
                                      &Fcb,
                                      &Ccb );

    //
    //  No work here for either an UnopenedFile object or a StreamFileObject.
    //

    if (TypeOfOpen <= StreamFileOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    //
    //  Keep a local pointer to the Vcb.
    //

    Vcb = Fcb->Vcb;

    //
    //  If we're closing a volume handle,   and writes were made,
    //  hold the Vcb exclusive
    //

    if ((TypeOfOpen == UserVolumeOpen) && 
        FlagOn(FileObject->Flags, FO_FILE_MODIFIED))  {

        UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE);
        VcbAcquired = TRUE;
    }
    
    //
    //  Synchronise with reads while we set the cleanup complete 
    //  flag on this fileobject.  Once this flag is set,  any further
    //  reads will be rejected (CdVerifyFcbOperation)
    //

    UdfAcquireFileExclusive( IrpContext, Fcb);

    //
    //  Set the flag in the FileObject to indicate that cleanup is complete.
    //

    SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

    UdfReleaseFile( IrpContext, Fcb);

    //
    //  Acquire the current file.
    //

    UdfAcquireFcbExclusive( IrpContext, Fcb, FALSE );
    
    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Case on the type of open that we are trying to cleanup.
        //

        switch (TypeOfOpen) {

        case UserDirectoryOpen:

            DebugTrace(( +1, Dbg,
                         "UdfCommonCleanup, Fcb %08x FO %08x DIR\n",
                         Fcb,
                         FileObject ));
            
            //
            //  Check if we need to complete any dir notify Irps on this file object.
            //

            FsRtlNotifyCleanup( Vcb->NotifySync,
                                &Vcb->DirNotifyList,
                                Ccb );

            break;

        case UserFileOpen:

            DebugTrace(( +1, Dbg,
                         "UdfCommonCleanup, Fcb %08x FO %08x FILE\n",
                         Fcb,
                         FileObject ));
            
            //
            //  Coordinate the cleanup operation with the oplock state.
            //  Oplock cleanup operations can always cleanup immediately so no
            //  need to check for STATUS_PENDING.
            //

            FsRtlCheckOplock( &Fcb->Oplock,
                              Irp,
                              IrpContext,
                              NULL,
                              NULL );

            //
            //  Unlock all outstanding file locks.
            //

            if (Fcb->FileLock != NULL) {

                FsRtlFastUnlockAll( Fcb->FileLock,
                                    FileObject,
                                    IoGetRequestorProcess( Irp ),
                                    NULL );
            }

            //
            //  Cleanup the cache map.
            //

            CcUninitializeCacheMap( FileObject, NULL, NULL );

            //
            //  Check the fast io state.
            //

            UdfLockFcb( IrpContext, Fcb );
            Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
            UdfUnlockFcb( IrpContext, Fcb );

            break;

        case UserVolumeOpen :

            DebugTrace(( +1, Dbg,
                         "UdfCommonCleanup, Fcb %08x FO %08x VOL\n",
                         Fcb,
                         FileObject ));
                         
            //
            //  If this handle had write access, and actually wrote something,
            //  flush the device buffers, and then set the verify bit now
            //  just to be safe (in case there is no dismount).
            //

            if (FileObject->WriteAccess &&
                FlagOn(FileObject->Flags, FO_FILE_MODIFIED)) {

                (VOID)UdfHijackIrpAndFlushDevice( IrpContext,
                                                  Irp,
                                                  Vcb->TargetDeviceObject );

                UdfMarkRealDevForVerify( Vcb->Vpb->RealDevice);
            }

            break;

        default :

            UdfBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  Now lock the Vcb in order to modify the fields in the in-memory
        //  structures.
        //

        UdfLockVcb( IrpContext, Vcb );

        //
        //  Decrement the cleanup counts in the Vcb and Fcb.
        //

        UdfDecrementCleanupCounts( IrpContext, Fcb );

        //
        //  If the cleanup count hit zero and the volume is not mounted, we
        //  will want to try to spark teardown.
        //

        AttemptTeardown = (Vcb->VcbCleanup == 0 && Vcb->VcbCondition == VcbNotMounted);
        
        //
        //  If this file object has locked the volume then perform the unlock operation.
        //  We do this regardless of explicit or implicit (no share DASD open) lock.
        //

        if (FileObject == Vcb->VolumeLockFileObject) {

            ASSERT( FlagOn( Vcb->VcbState, VCB_STATE_LOCKED));

            IoAcquireVpbSpinLock( &SavedIrql );

            ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED );
            ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );
            Vcb->VolumeLockFileObject = NULL;
            SendUnlockNotification = TRUE;

            IoReleaseVpbSpinLock( SavedIrql );
        }

        UdfUnlockVcb( IrpContext, Vcb );

        //
        //  We must clean up the share access at this time, since we may not
        //  get a Close call for awhile if the file was mapped through this
        //  File Object.
        //

        IoRemoveShareAccess( FileObject, &Fcb->ShareAccess );

    } 
    finally {

        UdfReleaseFcb( IrpContext, Fcb );

        if (SendUnlockNotification) {

            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
        }

        if (VcbAcquired)  {

            UdfReleaseVcb( IrpContext, Vcb);
        }
    }

    DebugTrace(( -1, Dbg,
                 "UdfCommonCleanup, Fcb %08x FO %08x -> SUCCESS\n",
                 Fcb,
                 FileObject ));
    
    //
    //  If appropriate, try to spark teardown by purging the volume.  Should
    //  this very fileobject we were cleaning up be the last reason for the
    //  volume to remain, teardown will commence on completion of this Irp.
    //
    
    if (AttemptTeardown) {

        UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

        try {
            
            UdfPurgeVolume( IrpContext, Vcb, FALSE );

        } finally {

            UdfReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  If this is a normal termination then complete the request
    //

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\cachesup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    CacheSup.c

Abstract:

    This module implements the cache management routines for the Udfs
    FSD and FSP, by calling the Common Cache Manager.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     12-Sep-1996
    
Revision History:

    Tom Jolly       [tomjolly]  21-Jan-2000     CcPurge and append at end of vmcb stream

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_CACHESUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_CACHESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCompleteMdl)
#pragma alloc_text(PAGE, UdfCreateInternalStream)
#pragma alloc_text(PAGE, UdfDeleteInternalStream)
#pragma alloc_text(PAGE, UdfMapMetadataView)
#pragma alloc_text(PAGE, UdfPurgeVolume)
#endif


VOID
UdfCreateInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function creates an internal stream file for interaction
    with the cache manager.  The Fcb here will be for a directory
    stream.

Arguments:

    Vcb - Vcb for this volume.

    Fcb - Points to the Fcb for this file.  It is an Index Fcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT StreamFile = NULL;
    BOOLEAN DecrementReference = FALSE;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );

    //
    //  We may only have the Fcb shared.  Lock the Fcb and do a
    //  safe test to see if we need to really create the file object.
    //

    UdfLockFcb( IrpContext, Fcb );

    if (Fcb->FileObject != NULL) {

        UdfUnlockFcb( IrpContext, Fcb );
        return;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Create the internal stream.  The Vpb should be pointing at our volume
        //  device object at this point.
        //

        StreamFile = IoCreateStreamFileObject( NULL, Vcb->Vpb->RealDevice );

        if (StreamFile == NULL) {

            UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Initialize the fields of the file object.
        //

        StreamFile->ReadAccess = TRUE;
        StreamFile->WriteAccess = FALSE;
        StreamFile->DeleteAccess = FALSE;

        StreamFile->SectionObjectPointer = &Fcb->FcbNonpaged->SegmentObject;

        //
        //  Set the file object type and increment the Vcb counts.
        //

        UdfSetFileObject( IrpContext,
                         StreamFile,
                         StreamFileOpen,
                         Fcb,
                         NULL );

        //
        //  We will reference the current Fcb twice to keep it from going
        //  away in the error path.  Otherwise if we dereference it
        //  below in the finally clause a close could cause the Fcb to
        //  be deallocated.
        //

        UdfLockVcb( IrpContext, Vcb );
        
        DebugTrace(( +1, Dbg, 
                     "UdfCreateInternalStream, Fcb %08x Vcb %d/%d Fcb %d/%d\n",
                     Fcb,
                     Vcb->VcbReference,
                     Vcb->VcbUserReference,
                     Fcb->FcbReference,
                     Fcb->FcbUserReference ));

        UdfIncrementReferenceCounts( IrpContext, Fcb, 2, 0 );
        UdfUnlockVcb( IrpContext, Vcb );
        DecrementReference = TRUE;

        //
        //  Initialize the cache map for the file.
        //

        CcInitializeCacheMap( StreamFile,
                              (PCC_FILE_SIZES)&Fcb->AllocationSize,
                              TRUE,
                              &UdfData.CacheManagerCallbacks,
                              Fcb );

        //
        //  Go ahead and store the stream file into the Fcb.
        //

        Fcb->FileObject = StreamFile;
        StreamFile = NULL;

    } finally {

        DebugUnwind( "UdfCreateInternalStream" );

        //
        //  If we raised then we need to dereference the file object.
        //

        if (StreamFile != NULL) {

            ObDereferenceObject( StreamFile );
            Fcb->FileObject = NULL;
        }

        //
        //  Dereference and unlock the Fcb.
        //

        if (DecrementReference) {

            UdfLockVcb( IrpContext, Vcb );
            UdfDecrementReferenceCounts( IrpContext, Fcb, 1, 0 );
            
            DebugTrace(( -1, Dbg, 
                         "UdfCreateInternalStream, Vcb %d/%d Fcb %d/%d\n",
                         Vcb->VcbReference,
                         Vcb->VcbUserReference,
                         Fcb->FcbReference,
                         Fcb->FcbUserReference ));

            UdfUnlockVcb( IrpContext, Vcb );
        }

        UdfUnlockFcb( IrpContext, Fcb );
    }

    return;
}


VOID
UdfDeleteInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function creates an internal stream file for interaction
    with the cache manager.  The Fcb here can be for either a
    directory stream or for a metadata stream.

Arguments:

    Fcb - Points to the Fcb for this file.  It is either an Index or
        Metadata Fcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Lock the Fcb.
    //

    UdfLockFcb( IrpContext, Fcb );

    //
    //  Capture the file object.
    //

    FileObject = Fcb->FileObject;
    Fcb->FileObject = NULL;

    //
    //  It is now safe to unlock the Fcb.
    //

    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  Dereference the file object if present.
    //

    if (FileObject != NULL) {

        if (FileObject->PrivateCacheMap != NULL) {

            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }

        ObDereferenceObject( FileObject );
    }

    return;
}


NTSTATUS
UdfCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the function of completing Mdl reads.
    It should be called only from UdfCommonRead.

Arguments:

    Irp - Supplies the originating Irp.

Return Value:

    NTSTATUS - Will always be STATUS_SUCCESS.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    //
    // Do completion processing.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    CcMdlReadComplete( FileObject, Irp->MdlAddress );

    //
    // Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    // Complete the request and exit right away.
    //

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


VOID
UdfMapMetadataView (
    IN PIRP_CONTEXT IrpContext,
    IN PMAPPED_PVIEW View,
    IN PVCB Vcb,
    IN USHORT Partition,
    IN ULONG Lbn,
    IN ULONG Length,
    IN MAPMETAOP Operation
    )

/*++

Routine Description:

    Perform the common work of mapping an extent of metadata into a mapped view.
    Any existing view in the supplied MAPPED_VIEW is unmapped.

    Any single thread must only ever have ONE mapping ESTABLISHED through the
    Vmcb stream at any one time.  Failure to observe this may result in deadlocks
    when the Vmcb package tries to extend an existing mapping and hence do a 
    purge.  I.e. no more than one MAPPED_VIEW should be in use (actually mapped)
    by any given thread at any moment.

    Acquires Vcb->VmcbMappingResource shared (will be held on return, except for
    INIT_ONLY operation).  May acquire exclusive before shared if the mapping
    is not present in the vmcb, so calling threads must have no other active
    mappings through the vmcb stream.

Arguments:

    View - View structure to map the bytes into
    
    Vcb - Vcb of the volume the extent is on
    
    Partition - Partition of the extent
    
    Lbn - Lbn of the extent
    
    Length - Length of the extent

    Operation - METAMAPOP_INIT_VIEW_ONLY -  Just store the part/lbn/len. Doesn't
                                            access the vmcb,  or do a CcMap.
                                            
                METAMAPOP_REMAP_VIEW -      Do the CcMap through the vmcb using 
                                            the partition/lbn/len already in
                                            the supplied view record
                                            
                METAMAPOP_INIT_AND_MAP -    Does both of the above in sequence.
Return Value:

    None.

--*/

{
    LARGE_INTEGER Offset;

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Remove any existing mapping & release Vmcb mapping resource
    //
    
    UdfUnpinView( IrpContext, View );

    if ( METAMAPOP_REMAP_VIEW != Operation)  {
    
        //
        //  Update the view information if we're not remapping using the
        //  existing values in the view record.
        //

        View->Partition = Partition;
        View->Lbn = Lbn;
        View->Length = Length;
        View->Vsn = UDF_INVALID_VSN;
        View->Bcb = View->View = NULL;
    }

    if ( METAMAPOP_INIT_VIEW_ONLY != Operation)  {
    
        ASSERT_NOT_HELD_VMCB( Vcb);

        //
        //  Find (or add) the mapping for this extent in the vmcb stream.  We now
        //  store the Vsn in the MAPPED_VIEW,  so we don't have to do the lookup
        //  again later (simplifies locking,  amongst other things).
        //

        View->Vsn = UdfLookupMetaVsnOfExtent( IrpContext,
                                             Vcb,
                                             View->Partition,
                                             View->Lbn,
                                             View->Length,
                                             FALSE );

        Offset.QuadPart = LlBytesFromSectors( Vcb, View->Vsn );

        //
        //  Map the extent.  Acquire the vmcb map resource to synchronise against
        //  purges of the vmcb stream.  See comments in Vmcb code for more detail.
        //

        UdfAcquireVmcbForCcMap( IrpContext,  Vcb);
        
        try {
        
            CcMapData( Vcb->MetadataFcb->FileObject,
                       &Offset,
                       View->Length,
                       TRUE,
                       &View->Bcb,
                       &View->View );
        } 
        finally {

            //
            //  If this raised,  we should release the mapping lock.  Callers will
            //  only cleanup and release if a non-NULL BCB is present in the pview.
            //
            
            if (AbnormalTermination())  {

                UdfReleaseVmcb( IrpContext, Vcb);

                View->View = View->Bcb = NULL;
            }
            else {
            
                ASSERT( View->View && View->Bcb);
            }
        }
    }
}


NTSTATUS
UdfPurgeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DismountUnderway
    )

/*++

Routine Description:

    This routine is called to purge the volume.  The purpose is to make all the stale file
    objects in the system go away, minimizing the reference counts, so that the volume may
    be locked or deleted.

    The Vcb is already acquired exclusively.  We will lock out all file operations by
    acquiring the global file resource.  Then we will walk through all of the Fcb's and
    perform the purge.

Arguments:

    Vcb - Vcb for the volume to purge.

    DismountUnderway - Indicates that we are trying to delete all of the objects.
        We will purge the Metadata and VolumeDasd and dereference all internal streams.

Return Value:

    NTSTATUS - The first failure of the purge operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVOID RestartKey = NULL;
    PFCB ThisFcb = NULL;
    PFCB NextFcb;

    BOOLEAN RemovedFcb;

    PAGED_CODE();

    //
    //  Force any remaining Fcb's in the delayed close queue to be closed.
    //

    UdfFspClose( Vcb );

    //
    //  Acquire the global file resource.
    //

    UdfAcquireAllFiles( IrpContext, Vcb );

    //
    //  Loop through each Fcb in the Fcb Table and perform the flush.
    //

    while (TRUE) {

        //
        //  Lock the Vcb to lookup the next Fcb.
        //

        UdfLockVcb( IrpContext, Vcb );
        NextFcb = UdfGetNextFcb( IrpContext, Vcb, &RestartKey );

        //
        //  Reference the NextFcb if present.
        //

        if (NextFcb != NULL) {

            NextFcb->FcbReference += 1;
        }

        //
        //  If the last Fcb is present then decrement reference count and call teardown
        //  to see if it should be removed.
        //

        if (ThisFcb != NULL) {

            ThisFcb->FcbReference -= 1;

            UdfUnlockVcb( IrpContext, Vcb );

            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );

        } else {

            UdfUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Break out of the loop if no more Fcb's.
        //

        if (NextFcb == NULL) {

            break;
        }

        //
        //  Move to the next Fcb.
        //

        ThisFcb = NextFcb;

        //
        //  If there is a image section then see if that can be closed.
        //

        if (ThisFcb->FcbNonpaged->SegmentObject.ImageSectionObject != NULL) {

            MmFlushImageSection( &ThisFcb->FcbNonpaged->SegmentObject, MmFlushForWrite );
        }

        //
        //  If there is a data section then purge this.  If there is an image
        //  section then we won't be able to.  Remember this if it is our first
        //  error.
        //

        if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
            !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                   NULL,
                                   0,
                                   FALSE ) &&
            (Status == STATUS_SUCCESS)) {

            Status = STATUS_UNABLE_TO_DELETE_SECTION;
        }

        //
        //  Dereference the internal stream if dismounting.
        //

        if (DismountUnderway &&
            (SafeNodeType( ThisFcb ) != UDFS_NTC_FCB_DATA) &&
            (ThisFcb->FileObject != NULL)) {

            UdfDeleteInternalStream( IrpContext, ThisFcb );
        }
    }

    //
    //  Now look at the Root Index, Metadata, Volume Dasd and VAT Fcbs.
    //  Note that we usually hit the Root Index in the loop above, but
    //  it is possible miss it if it didn't get into the Fcb table in the
    //  first place!
    //

    if (DismountUnderway) {

        if (Vcb->RootIndexFcb != NULL) {

            ThisFcb = Vcb->RootIndexFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            UdfDeleteInternalStream( IrpContext, ThisFcb );
            InterlockedDecrement( &ThisFcb->FcbReference );
            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );
        }
        
        if (Vcb->MetadataFcb != NULL) {

            ThisFcb = Vcb->MetadataFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            UdfDeleteInternalStream( IrpContext, ThisFcb );
            InterlockedDecrement( &ThisFcb->FcbReference );
            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );
        }

        if (Vcb->VatFcb != NULL) {

            ThisFcb = Vcb->VatFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            UdfDeleteInternalStream( IrpContext, ThisFcb );
            InterlockedDecrement( &ThisFcb->FcbReference );
            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );
        }

        if (Vcb->VolumeDasdFcb != NULL) {

            ThisFcb = Vcb->VolumeDasdFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            InterlockedDecrement( &ThisFcb->FcbReference );
            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );
        }
    }

    //
    //  Release all of the files.
    //

    UdfReleaseAllFiles( IrpContext, Vcb );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\close.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Udfs called by the
    Fsd/Fsp dispatch routines.

    The close operation interacts with both the async and delayed close queues
    in the UdfData structure.  Since close may be called recursively we may
    violate the locking order in acquiring the Vcb or Fcb.  In this case
    we may move the request to the async close queue.  If this is the last
    reference on the Fcb and there is a chance the user may reopen this
    file again soon we would like to defer the close.  In this case we
    may move the request to the delayed close queue.

    Once we are past the decode file operation there is no need for the
    file object.  If we are moving the request to either of the work
    queues then we remember all of the information from the file object and
    complete the request with STATUS_SUCCESS.  The Io system can then
    reuse the file object and we can complete the request when convenient.

    The async close queue consists of requests which we would like to
    complete as soon as possible.  They are queued using the original
    IrpContext where some of the fields have been overwritten with
    information from the file object.  We will extract this information,
    cleanup the IrpContext and then call the close worker routine.

    The delayed close queue consists of requests which we would like to
    defer the close for.  We keep size of this list within a range
    determined by the size of the system.  We let it grow to some maximum
    value and then shrink to some minimum value.  We allocate a small
    structure which contains the key information from the file object
    and use this information along with an IrpContext on the stack
    to complete the request.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     04-Nov-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_CLOSE)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_CLOSE)

//
//  Local support routines
//

BOOLEAN
UdfCommonClosePrivate (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN FromFsd
    );

VOID
UdfQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN DelayedClose
    );

PIRP_CONTEXT
UdfRemoveClose (
    IN PVCB Vcb OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonClose)
#pragma alloc_text(PAGE, UdfCommonClosePrivate)
#pragma alloc_text(PAGE, UdfQueueClose)
#pragma alloc_text(PAGE, UdfRemoveClose)
#endif


VOID
UdfFspClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to process the close queues in the UdfData.  If the
    Vcb is passed then we want to remove all of the closes for this Vcb.
    Otherwise we will do as many of the delayed closes as we need to do.

Arguments:

    Vcb - If specified then we are looking for all of the closes for the
        given Vcb.

Return Value:

    None

--*/

{
    PIRP_CONTEXT IrpContext;
    IRP_CONTEXT StackIrpContext;

    THREAD_CONTEXT ThreadContext;

    PFCB Fcb;
    ULONG UserReference;

    ULONG VcbHoldCount = 0;
    PVCB CurrentVcb = NULL;

    BOOLEAN PotentialVcbTeardown = FALSE;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_OPTIONAL_VCB( Vcb );

    FsRtlEnterFileSystem();

    //
    //  Continue processing until there are no more closes to process.
    //

    while (IrpContext = UdfRemoveClose( Vcb )) {

        //
        //  If we don't have an IrpContext then use the one on the stack.
        //  Initialize it for this request.
        //

        if (SafeNodeType( IrpContext ) != UDFS_NTC_IRP_CONTEXT ) {

            //
            //  Update the local values from the IrpContextLite.
            //

            Fcb = ((PIRP_CONTEXT_LITE) IrpContext)->Fcb;
            UserReference = ((PIRP_CONTEXT_LITE) IrpContext)->UserReference;

            //
            //  Update the stack irp context with the values from the
            //  IrpContextLite.
            //

            UdfInitializeStackIrpContext( &StackIrpContext,
                                          (PIRP_CONTEXT_LITE) IrpContext );

            //
            //  Free the IrpContextLite.
            //

            UdfFreeIrpContextLite( (PIRP_CONTEXT_LITE) IrpContext );

            //
            //  Remember we have the IrpContext from the stack.
            //

            IrpContext = &StackIrpContext;

        //
        //  Otherwise cleanup the existing IrpContext.
        //

        } else {

            //
            //  Remember the Fcb and user reference count.
            //

            Fcb = (PFCB) IrpContext->Irp;
            IrpContext->Irp = NULL;

            UserReference = (ULONG) IrpContext->ExceptionStatus;
            IrpContext->ExceptionStatus = STATUS_SUCCESS;
        }

        //
        //  We have an IrpContext.  Now we need to set the top level thread
        //  context.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FSP_FLAGS );

        //
        //  If we were given a Vcb then there is a request on top of this.
        //

        if (ARGUMENT_PRESENT( Vcb )) {

            ClearFlag( IrpContext->Flags,
                       IRP_CONTEXT_FLAG_TOP_LEVEL | IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS );
        }

        UdfSetThreadContext( IrpContext, &ThreadContext );

        //
        //  If we have hit the maximum number of requests to process without
        //  releasing the Vcb then release the Vcb now.  If we are holding
        //  a different Vcb to this one then release the previous Vcb.
        //
        //  In either case acquire the current Vcb.
        //
        //  We use the MinDelayedCloseCount from the UdfData since it is
        //  a convenient value based on the system size.  Only thing we are trying
        //  to do here is prevent this routine starving other threads which
        //  may need this Vcb exclusively.
        //
        //  Note that the check for potential teardown below is unsafe.  We'll 
        //  repeat later within the UdfData lock.
        //

        PotentialVcbTeardown = !ARGUMENT_PRESENT( Vcb ) &&
                               (Fcb->Vcb->VcbCondition != VcbMounted) &&
                               (Fcb->Vcb->VcbCondition != VcbMountInProgress) &&
                               (Fcb->Vcb->VcbCleanup == 0);

        if (PotentialVcbTeardown ||
            (VcbHoldCount > UdfData.MinDelayedCloseCount) ||
            (Fcb->Vcb != CurrentVcb)) {

            if (CurrentVcb != NULL) {

                UdfReleaseVcb( IrpContext, CurrentVcb );
            }

            if (PotentialVcbTeardown) {

                UdfAcquireUdfData( IrpContext );
                
                //
                //  Repeat the checks with the global lock held.  The volume could have
                //  been remounted while we didn't hold the lock.
                //

                PotentialVcbTeardown = !ARGUMENT_PRESENT( Vcb ) &&
                                       (Fcb->Vcb->VcbCondition != VcbMounted) &&
                                       (Fcb->Vcb->VcbCondition != VcbMountInProgress) &&
                                       (Fcb->Vcb->VcbCleanup == 0);
                                       
                if (!PotentialVcbTeardown)  {

                    UdfReleaseUdfData( IrpContext);
                }
            }

            CurrentVcb = Fcb->Vcb;
            UdfAcquireVcbShared( IrpContext, CurrentVcb, FALSE );

            VcbHoldCount = 0;

        } else {

            VcbHoldCount += 1;
        }

        DebugTrace(( +1, Dbg,
                     "UdfFspClose, Fcb %08x %4s Vcb %d/%d Fcb %d/%d\n",
                     Fcb,
                     ( UserReference? "USER" : "SYS" ),
                     CurrentVcb->VcbReference,
                     CurrentVcb->VcbUserReference,
                     Fcb->FcbReference,
                     Fcb->FcbUserReference ));

        //
        //  Call our worker routine to perform the close operation.
        //

        UdfCommonClosePrivate( IrpContext, CurrentVcb, Fcb, UserReference, FALSE );

        //
        //  If the reference count on this Vcb is below our residual reference
        //  then check if we should dismount the volume.
        //

        if (PotentialVcbTeardown) {

            UdfReleaseVcb( IrpContext, CurrentVcb );
            UdfCheckForDismount( IrpContext, CurrentVcb, FALSE );

            CurrentVcb = NULL;

            UdfReleaseUdfData( IrpContext );
            PotentialVcbTeardown = FALSE;
        }

        //
        //  Complete the current request to cleanup the IrpContext.
        //

        UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

        DebugTrace(( -1, Dbg, "UdfFspClose -> VOID\n" ));
    }

    //
    //  Release any Vcb we may still hold.
    //

    if (CurrentVcb != NULL) {

        UdfReleaseVcb( IrpContext, CurrentVcb );
    }

    FsRtlExitFileSystem();
}


NTSTATUS
UdfCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the Fsd entry for the close operation.  We decode the file
    object to find the UDFS structures and type of open.  We call our internal
    worker routine to perform the actual work.  If the work wasn't completed
    then we post to one of our worker queues.  The Ccb isn't needed after this
    point so we delete the Ccb and return STATUS_SUCCESS to our caller in all
    cases.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    STATUS_SUCCESS

--*/

{
    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;
    ULONG UserReference = 0;

    BOOLEAN DelayedClose;
    BOOLEAN ForceDismount = FALSE;
    BOOLEAN PotentialVcbTeardown = FALSE;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Decode the file object to get the type of open and Fcb/Ccb.
    //

    TypeOfOpen = UdfDecodeFileObject( IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                      &Fcb,
                                      &Ccb );

    //
    //  No work to do for unopened file objects.
    //

    if (TypeOfOpen == UnopenedFileObject) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    Vcb = Fcb->Vcb;

    //
    //  Clean up any CCB associated with this open.
    //

    if (Ccb != NULL) {

        UserReference = 1;

        //
        //  Was a FSCTL_DISMOUNT issued on this handle?  If so,  we need to
        //  force a dismount of the volume now.
        //
        
        ForceDismount = BooleanFlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE);

        //
        //  We can always deallocate the Ccb if present.
        //

        UdfDeleteCcb( IrpContext, Ccb );
    }

    //
    //  If this is the last reference to a user file or directory on a 
    //  currently mounted volume, then post it to the delayed close queue.  Note
    //  that the VcbCondition check is unsafe,  but it doesn't really matter -
    //  we just might delay the volume teardown a little by posting this close.
    //

    if ((Vcb->VcbCondition == VcbMounted) &&
        (Fcb->FcbReference == 1) &&
        ((TypeOfOpen == UserFileOpen) ||
         (TypeOfOpen == UserDirectoryOpen))) {

        UdfQueueClose( IrpContext, Fcb, UserReference, TRUE );
        IrpContext = NULL;

    //
    //  Otherwise try to process this close.  Post to the async close queue
    //  if we can't acquire all of the resources.
    //

    } else {

        //
        //  If we may be dismounting this volume then acquire the UdfData
        //  resource.
        //
        //  Since we now must make volumes go away as soon as reasonable after
        //  the last user handles closes, key off of the cleanup count.  It is
        //  OK to do this more than neccesary.  Since this Fcb could be holding
        //  a number of other Fcbs (and thus their references), a simple check
        //  on reference count is not appropriate.
        //
        //  Do an unsafe check first to avoid taking the (global) udfdata lock in the 
        //  common case.
        //

        if (((Vcb->VcbCleanup == 0) || ForceDismount) &&
            (Vcb->VcbCondition != VcbMounted))  {

            //
            //  Possible.  Acquire UdfData to synchronise with the remount path,  and
            //  then repeat the tests.
            //
            //  Note that we must send the notification outside of any locks,  since 
            //  the worker that processes the notify could also be calling into our 
            //  pnp path which wants both UdfData and VcbResource.  For a force dismount
            //  the volume will be marked invalid (no going back),  so we will definitely
            //  go ahead and dismount below.
            //
            
            if (ForceDismount)  {

                //
                //  Send notification.
                //
                
                FsRtlNotifyVolumeEvent( IoGetCurrentIrpStackLocation( Irp )->FileObject, 
                                        FSRTL_VOLUME_DISMOUNT );
            }

            //
            //  Possible.  Acquire UdfData to synchronise with the remount path
            //  before looking at the vcb condition again.
            //
            
            UdfAcquireUdfData( IrpContext );

            if (((Vcb->VcbCleanup == 0) || ForceDismount) &&
                (Vcb->VcbCondition != VcbMounted) &&
                (Vcb->VcbCondition != VcbMountInProgress) &&
                FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS )) {

                PotentialVcbTeardown = TRUE;
            }
            else {

                //
                //  We can't dismount this volume now,  there are other references or
                //  it's just been remounted.
                //

                UdfReleaseUdfData( IrpContext);
            }
        }

        if (ForceDismount)  {

            //
            //  Physically disconnect this Vcb from the device so a new mount can
            //  occur.  Vcb deletion cannot happen at this time since there is
            //  a handle on it associated with this very request,  but we'll call
            //  check for dismount again later anyway.
            //

            UdfCheckForDismount( IrpContext, Vcb, TRUE );
        }

        //
        //  Call the worker routine to perform the actual work.  This routine
        //  should never raise except for a fatal error.
        //

        if (!UdfCommonClosePrivate( IrpContext, Vcb, Fcb, UserReference, TRUE )) {

            //
            //  If we didn't complete the request then post the request as needed.
            //

            UdfQueueClose( IrpContext, Fcb, UserReference, FALSE );
            IrpContext = NULL;

        //
        //  Check whether we should be dismounting the volume and then complete
        //  the request.
        //

        } else if (PotentialVcbTeardown) {

            UdfCheckForDismount( IrpContext, Vcb, FALSE );
        }
    }

    //
    //  Always complete this request with STATUS_SUCCESS.
    //

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    if (PotentialVcbTeardown) {

        UdfReleaseUdfData( IrpContext );
    }

    //
    //  Always return STATUS_SUCCESS for closes.
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

BOOLEAN
UdfCommonClosePrivate (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN FromFsd
    )

/*++

Routine Description:

    This is the worker routine for the close operation.  We can be called in
    an Fsd thread or from a worker Fsp thread.  If called from the Fsd thread
    then we acquire the resources without waiting.  Otherwise we know it is
    safe to wait.

    We check to see whether we should post this request to the delayed close
    queue.  If we are to process the close here then we acquire the Vcb and
    Fcb.  We will adjust the counts and call our teardown routine to see
    if any of the structures should go away.

Arguments:

    Vcb - Vcb for this volume.

    Fcb - Fcb for this request.

    UserReference - Number of user references for this file object.  This is
        zero for an internal stream.

    FromFsd - This request was called from an Fsd thread.  Indicates whether
        we should wait to acquire resources.

Return Value:

    BOOLEAN - TRUE if this thread processed the close, FALSE otherwise.

--*/

{
    BOOLEAN CompletedClose;
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    //
    //  Check inputs.
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT_FCB( Fcb );

    //
    //  Try to acquire the Vcb and Fcb.  If we can't acquire them then return
    //  and let our caller know he should post the request to the async
    //  queue.
    //

    if (UdfAcquireVcbShared( IrpContext, Vcb, FromFsd )) {

        if (!UdfAcquireFcbExclusive( IrpContext, Fcb, FromFsd )) {

            //
            //  We couldn't get the Fcb.  Release the Vcb and let our caller
            //  know to post this request.
            //

            UdfReleaseVcb( IrpContext, Vcb );
            return FALSE;
        }

    //
    //  We didn't get the Vcb.  Let our caller know to post this request.
    //

    } else {

        return FALSE;
    }

    //
    //  Lock the Vcb and decrement the reference counts.
    //

    UdfLockVcb( IrpContext, Vcb );
    
    DebugTrace(( +1, Dbg,
                 "UdfCommonClosePrivate, Fcb %08x %4s Vcb %d/%d Fcb %d/%d\n", Fcb,
                 ( UserReference? "USER" : "SYS" ),
                 Vcb->VcbReference,
                 Vcb->VcbUserReference,
                 Fcb->FcbReference,
                 Fcb->FcbUserReference ));

    UdfDecrementReferenceCounts( IrpContext, Fcb, 1, UserReference );

    DebugTrace(( +0, Dbg,
                 "UdfCommonClosePrivate, Vcb %d/%d Fcb %d/%d\n",
                 Vcb->VcbReference,
                 Vcb->VcbUserReference,
                 Fcb->FcbReference,
                 Fcb->FcbUserReference ));

    UdfUnlockVcb( IrpContext, Vcb );

    //
    //  Call our teardown routine to see if this object can go away.
    //  If we don't remove the Fcb then release it.
    //

    UdfTeardownStructures( IrpContext, Fcb, FALSE, &RemovedFcb );

    if (!RemovedFcb) {

        UdfReleaseFcb( IrpContext, Fcb );
    }

    DebugTrace(( -1, Dbg,
                 "UdfCommonClosePrivate, RemovedFcb %08x -> %c\n",
                 Fcb,
                 ( RemovedFcb? 'T' : 'F' )));

    //
    //  Release the Vcb and return to our caller.  Let him know we completed
    //  this request.
    //

    UdfReleaseVcb( IrpContext, Vcb );

    return TRUE;
}


VOID
UdfQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN DelayedClose
    )

/*++

Routine Description:

    This routine is called to queue a request to either the async or delayed
    close queue.  For the delayed queue we need to allocate a smaller
    structure to contain the information about the file object.  We do
    that so we don't put the larger IrpContext structures into this long
    lived queue.  If we can allocate this structure then we put this
    on the async queue instead.

Arguments:

    Fcb - Fcb for this file object.

    UserReference - Number of user references for this file object.  This is
        zero for an internal stream.

    DelayedClose - Indicates whether this should go on the async or delayed
        close queue.

Return Value:

    None

--*/

{
    PIRP_CONTEXT_LITE IrpContextLite = NULL;
    BOOLEAN StartWorker = FALSE;

    PAGED_CODE();

    //
    //  Check inputs.
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Start with the delayed queue request.  We can move this to the async
    //  queue if there is an allocation failure.
    //

    if (DelayedClose) {

        //
        //  Try to allocate non-paged pool for the IRP_CONTEXT_LITE.
        //

        IrpContextLite = UdfCreateIrpContextLite( IrpContext );
    }

    //
    //  We want to clear the top level context in this thread if
    //  necessary.  Call our cleanup routine to do the work.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
    UdfCleanupIrpContext( IrpContext, TRUE );

    //
    //  Synchronize with the UdfData lock.
    //

    UdfLockUdfData();

    DebugTrace(( +1, Dbg,
                 "UdfQueueClose, Fcb %08x %4s %5s\n",
                 Fcb,
                 ( UserReference? "USER" : "SYS" ),
                 ( IrpContextLite? "DELAY" : "ASYNC" )));


    //
    //  If we have an IrpContext then put the request on the delayed close queue.
    //

    if (IrpContextLite != NULL) {

        //
        //  Initialize the IrpContextLite.
        //

        IrpContextLite->NodeTypeCode = UDFS_NTC_IRP_CONTEXT_LITE;
        IrpContextLite->NodeByteSize = sizeof( IRP_CONTEXT_LITE );
        IrpContextLite->Fcb = Fcb;
        IrpContextLite->UserReference = UserReference;
        IrpContextLite->RealDevice = IrpContext->RealDevice;

        //
        //  Add this to the delayed close list and increment
        //  the count.
        //

        InsertTailList( &UdfData.DelayedCloseQueue,
                        &IrpContextLite->DelayedCloseLinks );

        UdfData.DelayedCloseCount += 1;

        //
        //  If we are above our threshold then start the delayed
        //  close operation.
        //

        if (UdfData.DelayedCloseCount > UdfData.MaxDelayedCloseCount) {

            UdfData.ReduceDelayedClose = TRUE;

            if (!UdfData.FspCloseActive) {

                UdfData.FspCloseActive = TRUE;
                StartWorker = TRUE;
            }
        }

        //
        //  Unlock the global data.
        //

        UdfUnlockUdfData();

        //
        //  Cleanup the IrpContext.
        //

        UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    //
    //  Otherwise drop into the async case below.
    //

    } else {

        //
        //  Store the information about the file object into the IrpContext.
        //

        IrpContext->Irp = (PIRP) Fcb;
        IrpContext->ExceptionStatus = (NTSTATUS) UserReference;

        //
        //  Add this to the async close list and increment the count.
        //

        InsertTailList( &UdfData.AsyncCloseQueue,
                        &IrpContext->WorkQueueItem.List );

        UdfData.AsyncCloseCount += 1;

        //
        //  Remember to start the Fsp close thread if not currently started.
        //

        if (!UdfData.FspCloseActive) {

            UdfData.FspCloseActive = TRUE;
            StartWorker = TRUE;
        }

        //
        //  Unlock the global data.
        //

        UdfUnlockUdfData();
    }

    //
    //  Start the FspClose thread if we need to.
    //

    if (StartWorker) {

        ExQueueWorkItem( &UdfData.CloseItem, CriticalWorkQueue );
    }

    DebugTrace(( -1, Dbg, "UdfQueueClose -> VOID\n" ));

    //
    //  Return to our caller.
    //

    return;
}


//
//  Local support routine
//

PIRP_CONTEXT
UdfRemoveClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

Arguments:

    This routine is called to scan the async and delayed close queues looking
    for a suitable entry.  If the Vcb is specified then we scan both queues
    looking for an entry with the same Vcb.  Otherwise we will look in the
    async queue first for any close item.  If none found there then we look
    in the delayed close queue provided that we have triggered the delayed
    close operation.

Return Value:

    PIRP_CONTEXT - NULL if no work item found.  Otherwise it is the pointer to
        either the IrpContext or IrpContextLite for this request.

--*/

{
    PIRP_CONTEXT IrpContext = NULL;
    PIRP_CONTEXT NextIrpContext;
    PIRP_CONTEXT_LITE NextIrpContextLite;

    PLIST_ENTRY Entry;

    PAGED_CODE();

    ASSERT_OPTIONAL_VCB( Vcb );

    //
    //  Lock the UdfData to perform the scan.
    //

    UdfLockUdfData();

    //
    //  First check the list of async closes.
    //

    Entry = UdfData.AsyncCloseQueue.Flink;

    while (Entry != &UdfData.AsyncCloseQueue) {

        //
        //  Extract the IrpContext.
        //

        NextIrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

        //
        //  If no Vcb was specified or this Vcb is for our volume
        //  then perform the close.
        //

        if (!ARGUMENT_PRESENT( Vcb ) || (NextIrpContext->Vcb == Vcb)) {

            RemoveEntryList( Entry );
            UdfData.AsyncCloseCount -= 1;

            IrpContext = NextIrpContext;
            break;
        }

        //
        //  Move to the next entry.
        //

        Entry = Entry->Flink;
    }

    //
    //  If we didn't find anything look through the delayed close
    //  queue.
    //
    //  We will only check the delayed close queue if we were given
    //  a Vcb or the delayed close operation is active.
    //

    if ((IrpContext == NULL) &&
        (ARGUMENT_PRESENT( Vcb ) ||
         (UdfData.ReduceDelayedClose &&
          (UdfData.DelayedCloseCount > UdfData.MinDelayedCloseCount)))) {

        Entry = UdfData.DelayedCloseQueue.Flink;

        while (Entry != &UdfData.DelayedCloseQueue) {

            //
            //  Extract the IrpContext.
            //

            NextIrpContextLite = CONTAINING_RECORD( Entry,
                                                    IRP_CONTEXT_LITE,
                                                    DelayedCloseLinks );

            //
            //  If no Vcb was specified or this Vcb is for our volume
            //  then perform the close.
            //

            if (!ARGUMENT_PRESENT( Vcb ) || (NextIrpContextLite->Fcb->Vcb == Vcb)) {

                RemoveEntryList( Entry );
                UdfData.DelayedCloseCount -= 1;

                IrpContext = (PIRP_CONTEXT) NextIrpContextLite;
                break;
            }

            //
            //  Move to the next entry.
            //

            Entry = Entry->Flink;
        }
    }

    //
    //  If the Vcb wasn't specified and we couldn't find an entry
    //  then turn off the Fsp thread.
    //

    if (!ARGUMENT_PRESENT( Vcb ) && (IrpContext == NULL)) {

        UdfData.FspCloseActive = FALSE;
        UdfData.ReduceDelayedClose = FALSE;
    }

    //
    //  Unlock the global data.
    //

    UdfUnlockUdfData();

    return IrpContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\devctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the File System Device Control routines for Udfs
    called by the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    {DanLo]     28-Jan-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_DEVCTRL)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_DEVCTRL)

//
//  Local support routines
//

NTSTATUS
UdfDvdReadStructure (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
UdfDvdTransferKey (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
UdfDevCtrlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonDevControl)
#pragma alloc_text(PAGE, UdfDvdReadStructure)
#pragma alloc_text(PAGE, UdfDvdTransferKey)
#endif


NTSTATUS
UdfCommonDevControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing Device control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PIO_STACK_LOCATION IrpSp;

    PVOID TargetBuffer;

    PAGED_CODE();

    //
    //  Extract and decode the file object.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject,
                                      &Fcb,
                                      &Ccb );

    //
    //  A few IOCTLs actually require some intervention on our part to
    //  translate some information from file-based to device-based units.
    //

    if (TypeOfOpen == UserFileOpen) {

        switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
            case IOCTL_DVD_READ_KEY:
            case IOCTL_DVD_SEND_KEY:

                Status = UdfDvdTransferKey( IrpContext, Irp, Fcb );
                break;

            case IOCTL_DVD_READ_STRUCTURE:

                Status = UdfDvdReadStructure( IrpContext, Irp, Fcb );
                break;

            case IOCTL_STORAGE_SET_READ_AHEAD:

                //
                //  We're just going to no-op this for now.
                //
                
                Status = STATUS_SUCCESS;
                UdfCompleteRequest( IrpContext, Irp, Status );
                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                UdfCompleteRequest( IrpContext, Irp, Status );
                break;
        }

        return Status;
    }

    //
    //  Now the only type of opens we accept are user volume opens.
    //

    if (TypeOfOpen != UserVolumeOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Handle the case of the disk type ourselves.  We're really just going to
    //  lie about this, but it is a good lie.
    //

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_DISK_TYPE) {

        //
        //  Verify the Vcb in this case to detect if the volume has changed.
        //

        UdfVerifyVcb( IrpContext, Fcb->Vcb );

        //
        //  Check the size of the output buffer.
        //

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof( CDROM_DISK_DATA )) {

            UdfCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  Copy the data from the Vcb.
        //

        ((PCDROM_DISK_DATA) Irp->AssociatedIrp.SystemBuffer)->DiskData = CDROM_DISK_DATA_TRACK;

        Irp->IoStatus.Information = sizeof( CDROM_DISK_DATA );
        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Copy the arguments and set up the completion routine
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );
    
    IoSetCompletionRoutine( Irp,
                            UdfDevCtrlCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );

    //
    //  Cleanup our Irp Context.  The driver has completed the Irp.
    //

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


NTSTATUS
UdfDvdTransferKey (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine handles the special form of the Dvd key negotiation IOCTLs
    performed in the context of a file.  For these IOCTLs, the incoming parameter
    is in file-relative form, which must be translated to a device-relatvie form
    before it can continue.

Arguments:

    Irp - Supplies the Irp to process
    
    Fcb - Supplies the file being operated with

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PDVD_COPY_PROTECT_KEY TransferKey;

    LARGE_INTEGER Offset;
    BOOLEAN Result;

    PIO_STACK_LOCATION IrpSp;

    //
    //  Grab the input buffer and confirm basic validity.
    //
    
    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TransferKey = (PDVD_COPY_PROTECT_KEY) Irp->AssociatedIrp.SystemBuffer;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(DVD_COPY_PROTECT_KEY) ||
        TransferKey->Parameters.TitleOffset.QuadPart > Fcb->FileSize.QuadPart) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Now, convert the file byte offset in the structure to a physical sector.
    //

    Result = FsRtlLookupLargeMcbEntry( &Fcb->Mcb,
                                       LlSectorsFromBytes( Fcb->Vcb, TransferKey->Parameters.TitleOffset.QuadPart ),
                                       &Offset.QuadPart,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL );

    //
    //  If we failed the lookup, we know that this must be some form of unrecorded
    //  extent on the media.  This IOCTL is ill-defined at this point, so we have
    //  to give up.
    //
    
    if (!Result || Offset.QuadPart == -1) {
        
        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }
    
    //
    //  The input is buffered from user space, so we know we can just rewrite it.
    //

    TransferKey->Parameters.TitleOffset.QuadPart = LlBytesFromSectors( Fcb->Vcb, Offset.QuadPart );

    //
    //  Copy the arguments and set up the completion routine
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    IoSetCompletionRoutine( Irp,
                            UdfDevCtrlCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );

    //
    //  Cleanup our Irp Context.  The driver has completed the Irp.
    //

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


NTSTATUS
UdfDvdReadStructure (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb

    )

/*++

Routine Description:

    This routine handles the special form of the Dvd structure reading IOCTLs
    performed in the context of a file.  For these IOCTLs, the incoming parameter
    is in file-relative form, which must be translated to a device-relatvie form
    before it can continue.

Arguments:

    Irp - Supplies the Irp to process
    
    Fcb - Supplies the file being operated with

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PDVD_READ_STRUCTURE ReadStructure;

    LARGE_INTEGER Offset;
    BOOLEAN Result;

    PIO_STACK_LOCATION IrpSp;
    
    //
    //  Grab the input buffer and confirm basic validity.
    //
    
    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    ReadStructure = (PDVD_READ_STRUCTURE) Irp->AssociatedIrp.SystemBuffer;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(DVD_READ_STRUCTURE)) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Now, convert the file byte offset in the structure to a physical sector.
    //

    Result = FsRtlLookupLargeMcbEntry( &Fcb->Mcb,
                                       LlSectorsFromBytes( Fcb->Vcb, ReadStructure->BlockByteOffset.QuadPart ),
                                       &Offset.QuadPart,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL );

    //
    //  If we failed the lookup, we know that this must be some form of unrecorded
    //  extent on the media.  This IOCTL is ill-defined at this point, so we have
    //  to give up.
    //
    
    if (!Result || Offset.QuadPart == -1) {
        
        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }
    
    //
    //  The input is buffered from user space, so we know we can just rewrite it.
    //

    ReadStructure->BlockByteOffset.QuadPart = LlBytesFromSectors( Fcb->Vcb, Offset.QuadPart );

    //
    //  Copy the arguments and set up the completion routine
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    IoSetCompletionRoutine( Irp,
                            UdfDevCtrlCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );

    //
    //  Cleanup our Irp Context.  The driver has completed the Irp.
    //

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfDevCtrlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Add the hack-o-ramma to fix formats.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\deviosup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the low lever disk read/write support for Udfs.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	11-Jun-1996
    Tom Jolly       [tomjolly]  21-Jan-2000

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_DEVIOSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_DEVIOSUP)

//
//  Local structure definitions
//

//
//  An array of these structures is passed to UdfMultipleAsync describing
//  a set of runs to execute in parallel.
//

typedef struct _IO_RUN {

    //
    //  Disk offset to read from and number of bytes to read.  These
    //  must be a multiple of a sector and the disk offset is also a
    //  multiple of sector.
    //

    LONGLONG DiskOffset;
    ULONG DiskByteCount;

    //
    //  Current position in user buffer.  This is the final destination for
    //  this portion of the Io transfer.
    //

    PVOID UserBuffer;

    //
    //  Buffer to perform the transfer to.  If this is the same as the
    //  user buffer above then we are using the user's buffer.  Otherwise
    //  we either allocated a temporary buffer or are using a different portion
    //  of the user's buffer.
    //
    //  TransferBuffer - Read full sectors into this location.  This can
    //      be a pointer into the user's buffer at the exact location the
    //      data should go.  It can also be an earlier point in the user's
    //      buffer if the complete I/O doesn't start on a sector boundary.
    //      It may also be a pointer into an allocated buffer.
    //
    //  TransferByteCount - Count of bytes to transfer to user's buffer.  A
    //      value of zero indicates that we did do the transfer into the
    //      user's buffer directly.
    //
    //  TransferBufferOffset - Offset in this buffer to begin the transfer
    //      to the user's buffer.
    //

    PVOID TransferBuffer;
    ULONG TransferByteCount;
    ULONG TransferBufferOffset;

    //
    //  This is the Mdl describing the locked pages in memory.  It may
    //  be allocated to describe the allocated buffer.  Or it may be
    //  the Mdl in the originating Irp.  The MdlOffset is the offset of
    //  the current buffer from the beginning of the buffer described by
    //  the Mdl below.  If the TransferMdl is not the same as the Mdl
    //  in the user's Irp then we know we have allocated it.
    //

    PMDL TransferMdl;
    PVOID TransferVirtualAddress;

    //
    //  Associated Irp used to perform the Io.
    //

    PIRP SavedIrp;

} IO_RUN;
typedef IO_RUN *PIO_RUN;

#define MAX_PARALLEL_IOS            5

//
//  Local support routines
//

BOOLEAN
UdfPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount,
    OUT PBOOLEAN SparseRuns
    );

BOOLEAN
UdfFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_RUN IoRuns,
    IN ULONG RunCount,
    IN BOOLEAN FinalCleanup
    );

VOID
UdfMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns
    );

VOID
UdfSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    );

VOID
UdfWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
UdfMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UdfMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UdfSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UdfSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCreateUserMdl)
#pragma alloc_text(PAGE, UdfMultipleAsync)
#pragma alloc_text(PAGE, UdfNonCachedRead)
#pragma alloc_text(PAGE, UdfFinishBuffers)
#pragma alloc_text(PAGE, UdfPrepareBuffers)
#pragma alloc_text(PAGE, UdfSingleAsync)
#pragma alloc_text(PAGE, UdfWaitSync)
#pragma alloc_text(PAGE, UdfPerformDevIoCtrl)
#pragma alloc_text(PAGE, UdfReadSectors)
#endif



NTSTATUS
UdfNonCachedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached reads of sectors.  This is done by
    performing the following in a loop.

        Fill in the IoRuns array for the next block of Io.
        Send the Io to the device.
        Perform any cleanup on the Io runs array.

    We will not do async Io to any request that generates non-aligned Io.
    Also we will not perform async Io if it will exceed the size of our
    IoRuns array.  These should be the unusual cases but we will raise
    or return CANT_WAIT in this routine if we detect this case.

Arguments:

    Fcb - Fcb representing the file to read.

    StartingOffset - Logical offset in the file to read from.

    ByteCount - Number of bytes to read.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    IO_RUN IoRuns[MAX_PARALLEL_IOS];
    ULONG RunCount = 0;
    ULONG CleanupRunCount = 0;

    PVOID UserBuffer;
    ULONG UserBufferOffset = 0;
    LONGLONG CurrentOffset = StartingOffset;
    ULONG RemainingByteCount = ByteCount;
    ULONG ThisByteCount;

    BOOLEAN Unaligned;
    BOOLEAN SparseRuns;
    BOOLEAN FlushIoBuffers = FALSE;
    BOOLEAN FirstPass = TRUE;

    PAGED_CODE();

    //
    //  We want to make sure the user's buffer is locked in all cases.
    //

    if (IrpContext->Irp->MdlAddress == NULL) {

        UdfCreateUserMdl( IrpContext, ByteCount, TRUE, IoWriteAccess );
    }

    //
    //  Use a try-finally to perform the final cleanup.
    //

    try {

        UdfMapUserBuffer( IrpContext, &UserBuffer);

        //
        //  Loop while there are more bytes to transfer.
        //

        do {

            //
            //  Call prepare buffers to set up the next entries
            //  in the IoRuns array.  Remember if there are any
            //  unaligned entries.
            //

            RtlZeroMemory( IoRuns, sizeof( IoRuns ));

            Unaligned = UdfPrepareBuffers( IrpContext,
                                           IrpContext->Irp,
                                           Fcb,
                                           Ccb,
                                           UserBuffer,
                                           UserBufferOffset,
                                           CurrentOffset,
                                           RemainingByteCount,
                                           IoRuns,
                                           &CleanupRunCount,
                                           &ThisByteCount,
                                           &SparseRuns );


            RunCount = CleanupRunCount;

            //
            //  Quickly finish if we wound up having no IO to perform.  This will
            //  occur in the presence of unrecorded sectors.
            //

            ASSERT( !(SparseRuns && FlagOn( Fcb->FcbState, FCB_STATE_EMBEDDED_DATA )));

            if (RunCount == 0) {

                try_leave( Status = IrpContext->Irp->IoStatus.Status = STATUS_SUCCESS );
            }

            //
            //  If this is an async request and there aren't enough entries
            //  in the Io array then post the request.  This routine will
            //  always raise if we are doing any unaligned Io for an
            //  async request.
            //

            if ((ThisByteCount < RemainingByteCount) &&
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  If the entire Io is contained in a single run then
            //  we can pass the Io down to the driver.  Send the driver down
            //  and wait on the result if this is synchronous.  We cannot
            //  do this simple form (just chucking the IRP down) if some
            //  sparse runs were encountered.
            //

            if ((RunCount == 1) && !Unaligned && !SparseRuns && FirstPass) {

                UdfSingleAsync( IrpContext,
                                IoRuns[0].DiskOffset,
                                IoRuns[0].DiskByteCount );

                //
                //  No cleanup needed for the IoRuns array here.
                //

                CleanupRunCount = 0;

                //
                //  Wait if we are synchronous, otherwise return
                //

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                    UdfWaitSync( IrpContext );

                    Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Our completion routine will free the Io context but
                //  we do want to return STATUS_PENDING.
                //

                } else {

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                    Status = STATUS_PENDING;
                }

                try_leave( NOTHING );
            }

            //
            //  Otherwise we will perform multiple Io to read in the data.
            //
            
            UdfMultipleAsync( IrpContext, RunCount, IoRuns );

            //
            //  If this is a synchronous request then perform any necessary
            //  post-processing.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                //
                //  Wait for the request to complete.
                //

                UdfWaitSync( IrpContext );

                Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Exit this loop if there is an error.
                //

                if (!NT_SUCCESS( Status )) {

                    try_leave( NOTHING );
                }

                //
                //  Perform post read operations on the IoRuns if
                //  necessary.
                //

                if (Unaligned &&
                    UdfFinishBuffers( IrpContext, IoRuns, RunCount, FALSE )) {

                    FlushIoBuffers = TRUE;
                }

                //
                //  No cleanup needed on the IoRuns now.
                //

                CleanupRunCount = 0;

                //
                //  Exit this loop if there are no more bytes to transfer
                //  or we have any error.
                //

                RemainingByteCount -= ThisByteCount;
                CurrentOffset += ThisByteCount;
                UserBuffer = Add2Ptr( UserBuffer, ThisByteCount, PVOID );
                UserBufferOffset += ThisByteCount;

            //
            //  Otherwise this is an asynchronous request.  Always return
            //  STATUS_PENDING.
            //

            } else {

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                CleanupRunCount = 0;
                try_leave( Status = STATUS_PENDING );
                break;
            }

            FirstPass = FALSE;
        } while (RemainingByteCount != 0);

        //
        //  Flush the hardware cache if we performed any copy operations.
        //

        if (FlushIoBuffers) {

            KeFlushIoBuffers( IrpContext->Irp->MdlAddress, TRUE, FALSE );
        }

    } finally {

        DebugUnwind( "UdfNonCachedRead" );

        //
        //  Perform final cleanup on the IoRuns if necessary.
        //

        if (CleanupRunCount != 0) {

            UdfFinishBuffers( IrpContext, IoRuns, CleanupRunCount, TRUE );
        }
    }

    return Status;
}


NTSTATUS
UdfCreateUserMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BufferLength,
    IN BOOLEAN RaiseOnError,
    IN ULONG Operation
    )

/*++

Routine Description:

    This routine locks the specified buffer for read access (we only write into
    the buffer).  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

    This routine is only called if there is not already an Mdl.

Arguments:

    BufferLength - Length of user buffer.

    RaiseOnError - Indicates if our caller wants this routine to raise on
        an error condition.

Return Value:

    NTSTATUS - Status from this routine.  Error status only returned if
        RaiseOnError is FALSE.

--*/

{
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
    PMDL Mdl;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( IrpContext->Irp );
    ASSERT( IrpContext->Irp->MdlAddress == NULL );

    //
    // Allocate the Mdl, and Raise if we fail.
    //

    Mdl = IoAllocateMdl( IrpContext->Irp->UserBuffer,
                         BufferLength,
                         FALSE,
                         FALSE,
                         IrpContext->Irp );

    if (Mdl != NULL) {

        //
        //  Now probe the buffer described by the Irp.  If we get an exception,
        //  deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl, IrpContext->Irp->RequestorMode, Operation );

            Status = STATUS_SUCCESS;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            IrpContext->Irp->MdlAddress = NULL;

            if (!FsRtlIsNtstatusExpected( Status )) {

                Status = STATUS_INVALID_USER_BUFFER;
            }
        }
    }

    //
    //  Check if we are to raise or return
    //

    if (Status != STATUS_SUCCESS) {

        if (RaiseOnError) {

            UdfRaiseStatus( IrpContext, Status );
        }
    }

    //
    //  Return the status code.
    //

    return Status;
}


NTSTATUS
UdfPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform DevIoCtrl functions internally within
    the filesystem.  We take the status from the driver and return it to our
    caller.

Arguments:

    IoControlCode - Code to send to driver.

    Device - This is the device to send the request to.

    OutPutBuffer - Pointer to output buffer.

    OutputBufferLength - Length of output buffer above.

    InternalDeviceIoControl - Indicates if this is an internal or external
        Io control code.

    OverrideVerify - Indicates if we should tell the driver not to return
        STATUS_VERIFY_REQUIRED for mount and verify.

    Iosb - If specified, we return the results of the operation here.

Return Value:

    NTSTATUS - Status returned by next lower driver.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK LocalIosb;
    PIO_STATUS_BLOCK IosbToUse = &LocalIosb;

    PAGED_CODE();

    //
    //  Check if the user gave us an Iosb.
    //

    if (ARGUMENT_PRESENT( Iosb )) {

        IosbToUse = Iosb;
    }

    IosbToUse->Status = 0;
    IosbToUse->Information = 0;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IoControlCode,
                                         Device,
                                         InputBuffer,
                                         InputBufferLength,
                                         OutputBuffer,
                                         OutputBufferLength,
                                         InternalDeviceIoControl,
                                         &Event,
                                         IosbToUse );

    if (Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (OverrideVerify) {

        SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    Status = IoCallDriver( Device, Irp );

    //
    //  We check for device not ready by first checking Status
    //  and then if status pending was returned, the Iosb status
    //  value.
    //

    if (Status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER)NULL );

        Status = IosbToUse->Status;
    }

    ASSERT( !(OverrideVerify && (STATUS_VERIFY_REQUIRED == Status)));

    return Status;

    UNREFERENCED_PARAMETER( IrpContext );
}


NTSTATUS
UdfReadSectors (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN BOOLEAN ReturnError,
    IN OUT PVOID Buffer,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine is called to transfer sectors from the disk to a
    specified buffer.  It is used for mount and volume verify operations.

    This routine is synchronous, it will not return until the operation
    is complete or until the operation fails.

    The routine allocates an IRP and then passes this IRP to a lower
    level driver.  Errors may occur in the allocation of this IRP or
    in the operation of the lower driver.

Arguments:

    StartingOffset - Logical offset on the disk to start the read.  This
        must be on a sector boundary, no check is made here.

    ByteCount - Number of bytes to read.  This is an integral number of
        sectors, or otherwise a value we know the driver can handle,
        no check is made here to confirm this.

    ReturnError - Indicates whether we should return TRUE or FALSE
        to indicate an error or raise an error condition.  This only applies
        to the result of the IO.  Any other error may cause a raise.

    Buffer - Buffer to transfer the disk data into.

    TargetDeviceObject - The device object for the volume to be read.

Return Value:

    The final status of the operation.

--*/

{
    PLONGLONG UseStartingOffset;
    LONGLONG LocalStartingOffset;
    NTSTATUS Status;
    KEVENT  Event;
    PIRP Irp;

    PAGED_CODE();

    DebugTrace(( +1, Dbg,
                 "UdfReadSectors, %x%08x +%x -> %08x from DO %08x\n",
                 ((PLARGE_INTEGER)&StartingOffset)->HighPart,
                 ((PLARGE_INTEGER)&StartingOffset)->LowPart,
                 ByteCount,
                 Buffer,
                 TargetDeviceObject ));
    
    //
    //  For the time being, we assume that we only read sector-at-a-time.
    //  This simplifies sparing, and is the only way I am aware of this
    //  code would not be ready for blocksize != sectorsize.  It just is
    //  not worth writing dead (but straightforward) code right now.
    //

    ASSERT( IrpContext->Vcb == NULL || ByteCount == SectorSize( IrpContext->Vcb ));

    //
    //  If the volume is spared (and at a point where sparing is possible),
    //  check if a mapping needs to be performed.
    //
    
    if (IrpContext->Vcb &&
        IrpContext->Vcb->Pcb &&
        IrpContext->Vcb->Pcb->SparingMcb) {
        
        LONGLONG SparingPsn;
    
        if (FsRtlLookupLargeMcbEntry( IrpContext->Vcb->Pcb->SparingMcb,
                                      LlSectorsFromBytes( IrpContext->Vcb, StartingOffset ),
                                      &SparingPsn,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL ) &&
            SparingPsn != -1) {

            StartingOffset = BytesFromSectors( IrpContext->Vcb, (ULONG) SparingPsn );
        }
    }
    
    //
    //  Initialize the event.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Correct the starting offset by the method 2 fixup if neccesary.  This also
    //  assumes sector-at-a-time and sector == block so we don't need to fragment
    //  the request or check if it spans a packet boundary.
    //
    //  We assume that no fixups are required until a Vcb exists.  This is true
    //  since volume recognition may proceed in the first packet.
    //

    UseStartingOffset = &StartingOffset;

    if (IrpContext->Vcb &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP )) {

        LocalStartingOffset = UdfMethod2TransformByteOffset( IrpContext->Vcb, StartingOffset );
        UseStartingOffset = &LocalStartingOffset;

        DebugTrace(( 0, Dbg,
                     "UdfReadSectors, Method2 Fixup to %x%08x\n",
                     ((PLARGE_INTEGER)UseStartingOffset)->HighPart,
                     ((PLARGE_INTEGER)UseStartingOffset)->LowPart ));
    }

    //
    //  Attempt to allocate the IRP.  If unsuccessful, raise
    //  STATUS_INSUFFICIENT_RESOURCES.
    //

    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        TargetDeviceObject,
                                        Buffer,
                                        ByteCount,
                                        (PLARGE_INTEGER) UseStartingOffset,
                                        &Event,
                                        &IrpContext->Irp->IoStatus );

    if (Irp == NULL) {

        UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Ignore the change line (verify) for mount and verify requests
    //

    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    //
    //  Send the request down to the driver.  If an error occurs return
    //  it to the caller.
    //

    Status = IoCallDriver( TargetDeviceObject, Irp );

    //
    //  If the status was STATUS_PENDING then wait on the event.
    //

    if (Status == STATUS_PENDING) {

        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );

        //
        //  On a successful wait pull the status out of the IoStatus block.
        //

        if (NT_SUCCESS( Status )) {

            Status = IrpContext->Irp->IoStatus.Status;
        }
    }

    DebugTrace(( -1, Dbg, "UdfReadSectors -> %08x\n", Status ));
    
    //
    //  Check whether we should raise in the error case.
    //

    if (!NT_SUCCESS( Status ) && !ReturnError) {

        UdfNormalizeAndRaiseStatus( IrpContext, Status );
    }

    return Status;
}


//
//  Local support routine
//

BOOLEAN
UdfPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount,
    IN PBOOLEAN SparseRuns
    )

/*++

Routine Description:

    This routine is the worker routine which looks up each run of an IO
    request and stores an entry for it in the IoRuns array.  If the run
    begins on an unaligned disk boundary then we will allocate a buffer
    and Mdl for the unaligned portion and put it in the IoRuns entry.

    This routine will raise CANT_WAIT if an unaligned transfer is encountered
    and this request can't wait.

Arguments:

    Irp - Originating Irp for this request.

    Fcb - This is the Fcb for this data stream.  It may be a file, directory,
        path table or the volume file.

    UserBuffer - Current position in the user's buffer.

    UserBufferOffset - Offset from the start of the original user buffer.

    StartingOffset - Offset in the stream to begin the read.

    ByteCount - Number of bytes to read.  We will fill the IoRuns array up
        to this point.  We will stop early if we exceed the maximum number
        of parallel Ios we support.

    IoRuns - Pointer to the IoRuns array.  The entire array is zeroes when
        this routine is called.

    RunCount - Number of entries in the IoRuns array filled here.

    ThisByteCount - Number of bytes described by the IoRun entries.  Will
        not exceed the ByteCount passed in.
        
    SparseRuns - Will indicate whether sparse runs were a component of the
        range returned.  While not part of the IoRuns, this will affect
        our ability to do simple IO.

Return Value:

    BOOLEAN - TRUE if one of the entries in an unaligned buffer (provided
        this is synchronous).  FALSE otherwise.

--*/

{
    PVCB Vcb;

    BOOLEAN Recorded;
    
    BOOLEAN FoundUnaligned = FALSE;
    PIO_RUN ThisIoRun = IoRuns;

    //
    //  Following indicate where we are in the current transfer.  Current
    //  position in the file and number of bytes yet to transfer from
    //  this position.
    //

    ULONG RemainingByteCount = ByteCount;
    LONGLONG CurrentFileOffset = StartingOffset;

    //
    //  Following indicate the state of the user's buffer.  We have
    //  the destination of the next transfer and its offset in the
    //  buffer.  We also have the next available position in the buffer
    //  available for a scratch buffer.  We will align this up to a sector
    //  boundary.
    //

    PVOID CurrentUserBuffer = UserBuffer;
    ULONG CurrentUserBufferOffset = UserBufferOffset;

    PVOID ScratchUserBuffer = UserBuffer;
    ULONG ScratchUserBufferOffset = UserBufferOffset;

    //
    //  The following is the next contiguous bytes on the disk to
    //  transfer.  Read from the allocation package.
    //

    LONGLONG DiskOffset;
    ULONG CurrentByteCount;

    PAGED_CODE();

    Vcb = Fcb->Vcb;

    //
    //  Initialize the RunCount, ByteCount and SparseRuns.
    //

    *RunCount = 0;
    *ThisByteCount = 0;
    *SparseRuns = FALSE;

    //
    //  Loop while there are more bytes to process or there are
    //  available entries in the IoRun array.
    //

    while (TRUE) {

        *RunCount += 1;

        //
        //  Initialize the current position in the IoRuns array.
        //  Find the user's buffer for this portion of the transfer.
        //

        ThisIoRun->UserBuffer = CurrentUserBuffer;

        //
        //  Find the allocation information for the current offset in the
        //  stream.
        //

        Recorded = UdfLookupAllocation( IrpContext,
                                        Fcb,
                                        Ccb,
                                        CurrentFileOffset,
                                        &DiskOffset,
                                        &CurrentByteCount );

        //
        //  Limit ourselves to the data requested.
        //

        if (CurrentByteCount > RemainingByteCount) {

            CurrentByteCount = RemainingByteCount;
        }

        //
        //  Handle the case of unrecorded data first.
        //

        if (!Recorded) {

            //
            //  Note that we did not consume an entry.
            //

            *RunCount -= 1;

            //
            //  Immediately zero the user buffer and indicate that we found sparse
            //  runs to the caller.
            //

            RtlZeroMemory( CurrentUserBuffer, CurrentByteCount );
            *SparseRuns = TRUE;

            //
            //  Push the scratch buffer pointers forward so that we don't stomp
            //  on the zeroed buffer.
            //

            ScratchUserBuffer = Add2Ptr( CurrentUserBuffer,
                                         CurrentByteCount,
                                         PVOID );

            ScratchUserBufferOffset += CurrentByteCount;

        //
        //  Handle the case where this is an unaligned transfer.  The
        //  following must all be true for this to be an aligned transfer.
        //
        //      Disk offset on a 2048 byte boundary (Start of transfer)
        //
        //      Byte count is a multiple of 2048 (Length of transfer)
        //
        //      Current buffer offset is also on a 2048 byte boundary.
        //
        //  If the ByteCount is at least one sector then do the
        //  unaligned transfer only for the tail.  We can use the
        //  user's buffer for the aligned portion.
        //

        } else if (SectorOffset( Vcb, DiskOffset ) ||
                   SectorOffset( Vcb, CurrentUserBufferOffset ) ||
                   (SectorOffset( Vcb, CurrentByteCount ) &&
                    CurrentByteCount < SectorSize( Vcb ))) {

            //
            //  If we can't wait then raise.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  Remember the offset and the number of bytes out of
            //  the transfer buffer to copy into the user's buffer.
            //  We will truncate the current read to end on a sector
            //  boundary.
            //

            ThisIoRun->TransferBufferOffset = SectorOffset( Vcb, DiskOffset );

            //
            //  Make sure this transfer ends on a sector boundary.
            //

            ThisIoRun->DiskOffset = LlSectorTruncate( Vcb, DiskOffset );

            //
            //  Check if we can use a free portion of the user's buffer.
            //  If we can copy the bytes to an earlier portion of the
            //  buffer then read into that location and slide the bytes
            //  up.
            //
            //  We can use the user's buffer if:
            //
            //      The temporary location in the buffer is before the
            //      final destination.
            //
            //      There is at least one sector of data to read.
            //

            if ((ScratchUserBufferOffset + ThisIoRun->TransferBufferOffset < CurrentUserBufferOffset) &&
                (ThisIoRun->TransferBufferOffset + CurrentByteCount >= SectorSize( Vcb ))) {

                ThisIoRun->DiskByteCount = SectorTruncate( Vcb, ThisIoRun->TransferBufferOffset + CurrentByteCount );
                CurrentByteCount = ThisIoRun->DiskByteCount - ThisIoRun->TransferBufferOffset;
                ThisIoRun->TransferByteCount = CurrentByteCount;

                //
                //  Point to the user's buffer and Mdl for this transfer.
                //

                ThisIoRun->TransferBuffer = ScratchUserBuffer;
                ThisIoRun->TransferMdl = Irp->MdlAddress;
                ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer,
                                                             ScratchUserBufferOffset,
                                                             PVOID );

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             ThisIoRun->DiskByteCount,
                                             PVOID );

                ScratchUserBufferOffset += ThisIoRun->DiskByteCount;

            //
            //  Otherwise we need to allocate an auxilary buffer for the next sector.
            //

            } else {

                //
                //  Read up to a page containing the partial data
                //

                ThisIoRun->DiskByteCount = SectorAlign( Vcb, ThisIoRun->TransferBufferOffset + CurrentByteCount );

                if (ThisIoRun->DiskByteCount > PAGE_SIZE) {

                    ThisIoRun->DiskByteCount = PAGE_SIZE;
                }

                if (ThisIoRun->TransferBufferOffset + CurrentByteCount > ThisIoRun->DiskByteCount) {

                    CurrentByteCount = ThisIoRun->DiskByteCount - ThisIoRun->TransferBufferOffset;
                }

                ThisIoRun->TransferByteCount = CurrentByteCount;

                //
                //  Allocate a buffer for the non-aligned transfer.
                //

                ThisIoRun->TransferBuffer = FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                      PAGE_SIZE,
                                                                      TAG_IO_BUFFER );

                //
                //  Allocate and build the Mdl to describe this buffer.
                //

                ThisIoRun->TransferMdl = IoAllocateMdl( ThisIoRun->TransferBuffer,
                                                        PAGE_SIZE,
                                                        FALSE,
                                                        FALSE,
                                                        NULL );

                ThisIoRun->TransferVirtualAddress = ThisIoRun->TransferBuffer;

                if (ThisIoRun->TransferMdl == NULL) {

                    IrpContext->Irp->IoStatus.Information = 0;
                    UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
                }

                MmBuildMdlForNonPagedPool( ThisIoRun->TransferMdl );
            }

            //
            //  Remember we found an unaligned transfer.
            //

            FoundUnaligned = TRUE;

        //
        //  Otherwise we use the buffer and Mdl from the original request.
        //

        } else {

            //
            //  Truncate the read length to a sector-aligned value.  We know
            //  the length must be at least one sector or we wouldn't be
            //  here now.
            //

            CurrentByteCount = SectorTruncate( Vcb, CurrentByteCount );

            //
            //  Read these sectors from the disk.
            //

            ThisIoRun->DiskOffset = DiskOffset;
            ThisIoRun->DiskByteCount = CurrentByteCount;

            //
            //  Use the user's buffer and Mdl as our transfer buffer
            //  and Mdl.
            //

            ThisIoRun->TransferBuffer = CurrentUserBuffer;
            ThisIoRun->TransferMdl = Irp->MdlAddress;
            ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer,
                                                         CurrentUserBufferOffset,
                                                         PVOID );

            ScratchUserBuffer = Add2Ptr( CurrentUserBuffer,
                                         CurrentByteCount,
                                         PVOID );

            ScratchUserBufferOffset += CurrentByteCount;
        }

        //
        //  Update our position in the transfer and the RunCount and
        //  ByteCount for the user.
        //

        RemainingByteCount -= CurrentByteCount;

        //
        //  Break out if no more positions in the IoRuns array or
        //  we have all of the bytes accounted for.
        //

        *ThisByteCount += CurrentByteCount;

        if ((RemainingByteCount == 0) || (*RunCount == MAX_PARALLEL_IOS)) {

            break;
        }

        //
        //  Update our pointers for the user's buffer.
        //

        ThisIoRun = IoRuns + *RunCount;
        CurrentUserBuffer = Add2Ptr( CurrentUserBuffer, CurrentByteCount, PVOID );
        CurrentUserBufferOffset += CurrentByteCount;
        CurrentFileOffset += CurrentByteCount;
    }

    return FoundUnaligned;
}


//
//  Local support routine
//

BOOLEAN
UdfFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_RUN IoRuns,
    IN ULONG RunCount,
    IN BOOLEAN FinalCleanup
    )

/*++

Routine Description:

    This routine is called to perform any data transferred required for
    unaligned Io or to perform the final cleanup of the IoRuns array.

    In all cases this is where we will deallocate any buffer and mdl
    allocated to perform the unaligned transfer.  If this is not the
    final cleanup then we also transfer the bytes to the user buffer
    and flush the hardware cache.

    We walk backwards through the run array because we may be shifting data
    in the user's buffer.  Typical case is where we allocated a buffer for
    the first part of a read and then used the user's buffer for the
    next section (but stored it at the beginning of the buffer.

Arguments:

    IoRuns - Pointer to the IoRuns array.

    RunCount - Number of entries in the IoRuns array filled here.

    FinalCleanup - Indicates if we should be deallocating temporary buffers
        (TRUE) or transferring bytes for a unaligned transfers and
        deallocating the buffers (FALSE).  Flush the system cache if
        transferring data.

Return Value:

    BOOLEAN - TRUE if this request needs the Io buffers to be flushed, FALSE otherwise.

--*/

{
    BOOLEAN FlushIoBuffers = FALSE;

    ULONG RemainingEntries = RunCount;
    PIO_RUN ThisIoRun = &IoRuns[RunCount - 1];

    PAGED_CODE();

    //
    //  Walk through each entry in the IoRun array.
    //

    while (RemainingEntries != 0) {

        //
        //  We only need to deal with the case of an unaligned transfer.
        //

        if (ThisIoRun->TransferByteCount != 0) {

            //
            //  If not the final cleanup then transfer the data to the
            //  user's buffer and remember that we will need to flush
            //  the user's buffer to memory.
            //

            if (!FinalCleanup) {

                //
                //  If we are shifting in the user's buffer then use
                //  MoveMemory.
                //

                if (ThisIoRun->TransferMdl == IrpContext->Irp->MdlAddress) {

                    RtlMoveMemory( ThisIoRun->UserBuffer,
                                   Add2Ptr( ThisIoRun->TransferBuffer,
                                            ThisIoRun->TransferBufferOffset,
                                            PVOID ),
                                   ThisIoRun->TransferByteCount );

                } else {

                    RtlCopyMemory( ThisIoRun->UserBuffer,
                                   Add2Ptr( ThisIoRun->TransferBuffer,
                                            ThisIoRun->TransferBufferOffset,
                                            PVOID ),
                                   ThisIoRun->TransferByteCount );
                }

                FlushIoBuffers = TRUE;
            }

            //
            //  Free any Mdl we may have allocated.  If the Mdl isn't
            //  present then we must have failed during the allocation
            //  phase.
            //

            if (ThisIoRun->TransferMdl != IrpContext->Irp->MdlAddress) {

                if (ThisIoRun->TransferMdl != NULL) {

                    IoFreeMdl( ThisIoRun->TransferMdl );
                }

                //
                //  Now free any buffer we may have allocated.  If the Mdl
                //  doesn't match the original Mdl then free the buffer.
                //

                if (ThisIoRun->TransferBuffer != NULL) {

                    UdfFreePool( &ThisIoRun->TransferBuffer );
                }
            }
        }

        //
        //  Now handle the case where we failed in the process
        //  of allocating associated Irps and Mdls.
        //

        if (ThisIoRun->SavedIrp != NULL) {

            if (ThisIoRun->SavedIrp->MdlAddress != NULL) {

                IoFreeMdl( ThisIoRun->SavedIrp->MdlAddress );
            }

            IoFreeIrp( ThisIoRun->SavedIrp );
        }

        //
        //  Move to the previous IoRun entry.
        //

        ThisIoRun -= 1;
        RemainingEntries -= 1;
    }

    //
    //  If we copied any data then flush the Io buffers.
    //

    return FlushIoBuffers;
}


//
//  Local support routine
//

VOID
UdfMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine should not
    be used if only one async request is needed, instead the single read
    async routines should be called.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    RunCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Offset and ByteCount for the
        separate requests.

Return Value:

    None.

--*/

{
    PIO_COMPLETION_ROUTINE CompletionRoutine;
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    PIRP Irp;
    PIRP MasterIrp;
    ULONG UnwindRunCount;

    PAGED_CODE();

    //
    //  Set up things according to whether this is truely async.
    //

    CompletionRoutine = UdfMultiSyncCompletionRoutine;

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        CompletionRoutine = UdfMultiAsyncCompletionRoutine;
    }

    //
    //  Initialize some local variables.
    //

    MasterIrp = IrpContext->Irp;

    //
    //  Itterate through the runs, doing everything that can fail.
    //  We let the cleanup in CdFinishBuffers clean up on error.
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount += 1) {

        //
        //  Create an associated IRP, making sure there is one stack entry for
        //  us, as well.
        //

        IoRuns[UnwindRunCount].SavedIrp =
        Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(IrpContext->Vcb->TargetDeviceObject->StackSize + 1) );

        if (Irp == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        // Allocate and build a partial Mdl for the request.
        //

        Mdl = IoAllocateMdl( IoRuns[UnwindRunCount].TransferVirtualAddress,
                             IoRuns[UnwindRunCount].DiskByteCount,
                             FALSE,
                             FALSE,
                             Irp );

        if (Mdl == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        IoBuildPartialMdl( IoRuns[UnwindRunCount].TransferMdl,
                           Mdl,
                           IoRuns[UnwindRunCount].TransferVirtualAddress,
                           IoRuns[UnwindRunCount].DiskByteCount );

        //
        //  Get the first IRP stack location in the associated Irp
        //

        IoSetNextIrpStackLocation( Irp );
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Setup the Stack location to describe our read.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;

        //
        // Set up the completion routine address in our stack frame.
        //

        IoSetCompletionRoutine( Irp,
                                CompletionRoutine,
                                IrpContext->IoContext,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location in the associated Irp for the disk
        //  driver beneath us.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Setup the Stack location to do a read from the disk driver.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;
    }

    //
    //  We only need to set the associated IRP count in the master irp to
    //  make it a master IRP.  But we set the count to one more than our
    //  caller requested, because we do not want the I/O system to complete
    //  the I/O.  We also set our own count.
    //

    IrpContext->IoContext->IrpCount = RunCount;
    IrpContext->IoContext->MasterIrp = MasterIrp;

    //
    //  We set the count in the master Irp to 1 since typically we
    //  will clean up the associated irps ourselves.  Setting this to one
    //  means completing the last associated Irp with SUCCESS (in the async
    //  case) will complete the master irp.
    //

    MasterIrp->AssociatedIrp.IrpCount = 1;

    //
    //  Now that all the dangerous work is done, issue the Io requests
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount++) {

        Irp = IoRuns[UnwindRunCount].SavedIrp;
        IoRuns[UnwindRunCount].SavedIrp = NULL;

        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be caught by our completion routines
        //  and dealt with as a normal IO error.
        //

        (VOID) IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );
    }

    return;
}


//
//  Local support routine
//

VOID
UdfSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine reads one or more contiguous sectors from a device
    asynchronously, and is used if there is only one read necessary to
    complete the IRP.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    ByteOffset - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIO_COMPLETION_ROUTINE CompletionRoutine;

    PAGED_CODE();

    //
    //  Set up things according to whether this is truely async.
    //

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        CompletionRoutine = UdfSingleSyncCompletionRoutine;

    } else {

        CompletionRoutine = UdfSingleAsyncCompletionRoutine;
    }

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( IrpContext->Irp,
                            CompletionRoutine,
                            IrpContext->IoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( IrpContext->Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = IrpContext->MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = ByteOffset;

    //
    //  Issue the Io request
    //

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    (VOID)IoCallDriver( IrpContext->Vcb->TargetDeviceObject, IrpContext->Irp );
}


//
//  Local support routine
//

VOID
UdfWaitSync (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine waits for one or more previously started I/O requests
    from the above routines, by simply waiting on the event.

Arguments:

Return Value:

    None

--*/

{
    PAGED_CODE();

    KeWaitForSingleObject( &IrpContext->IoContext->SyncEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    KeClearEvent( &IrpContext->IoContext->SyncEvent );

    return;
}


//
//  Local support routine
//

NTSTATUS
UdfMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all synchronous reads
    started via UdfMultipleAsync.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
        Irp will no longer be accessible after this routine returns.)

    Context - The context parameter which was specified for all of
        the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    PUDF_IO_CONTEXT IoContext = Context;

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        InterlockedExchange( &IoContext->Status, Irp->IoStatus.Status );
        IoContext->MasterIrp->IoStatus.Information = 0;
    }

    //
    //  We must do this here since IoCompleteRequest won't get a chance
    //  on this associated Irp.
    //

    IoFreeMdl( Irp->MdlAddress );
    IoFreeIrp( Irp );

    if (InterlockedDecrement( &IoContext->IrpCount ) == 0) {

        //
        //  Update the Master Irp with any error status from the associated Irps.
        //

        IoContext->MasterIrp->IoStatus.Status = IoContext->Status;
        KeSetEvent( &IoContext->SyncEvent, 0, FALSE );
    }

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//
//  Local support routine
//

NTSTATUS
UdfMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads
    started via UdfMultipleAsync.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        and remember the error status in the Context.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
        Irp will no longer be accessible after this routine returns.)

    Context - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PUDF_IO_CONTEXT IoContext = Context;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        InterlockedExchange( &IoContext->Status, Irp->IoStatus.Status );
    }

    //
    //  Decrement IrpCount and see if it goes to zero.
    //

    if (InterlockedDecrement( &IoContext->IrpCount ) == 0) {

        //
        //  Mark the master Irp pending
        //

        IoMarkIrpPending( IoContext->MasterIrp );

        //
        //  Update the Master Irp with any error status from the associated Irps.
        //

        IoContext->MasterIrp->IoStatus.Status = IoContext->Status;

        //
        //  Update the information field with the correct value.
        //

        IoContext->MasterIrp->IoStatus.Information = 0;

        if (NT_SUCCESS( IoContext->MasterIrp->IoStatus.Status )) {

            IoContext->MasterIrp->IoStatus.Information = IoContext->RequestedByteCount;
        }

        //
        //  Now release the resource
        //

        ExReleaseResourceForThreadLite( IoContext->Resource,
                                    IoContext->ResourceThreadId );

        //
        //  and finally, free the context record.
        //

        UdfFreeIoContext( IoContext );

        //
        //  Return success in this case.
        //

        return STATUS_SUCCESS;

    } else {

        //
        //  We need to cleanup the associated Irp and its Mdl.
        //

        IoFreeMdl( Irp->MdlAddress );
        IoFreeIrp( Irp );

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

NTSTATUS
UdfSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all reads started via UdfSingleAsync.

    The completion routine has has the following responsibilities:

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Context - The context parameter which was specified in the call to
        UdfSingleAsynch.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    //
    //  Store the correct information field into the Irp.
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        Irp->IoStatus.Information = 0;
    }

    KeSetEvent( &((PUDF_IO_CONTEXT)Context)->SyncEvent, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

NTSTATUS
UdfSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads
    started via UdfSingleAsynch.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Context - The context parameter which was specified in the call to
        UdfSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    //
    //  Update the information field with the correct value for bytes read.
    //

    Irp->IoStatus.Information = 0;

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        Irp->IoStatus.Information = ((PUDF_IO_CONTEXT) Context)->RequestedByteCount;
    }

    //
    //  Mark the Irp pending
    //

    IoMarkIrpPending( Irp );

    //
    //  Now release the resource
    //

    ExReleaseResourceForThreadLite( ((PUDF_IO_CONTEXT) Context)->Resource,
                                ((PUDF_IO_CONTEXT) Context)->ResourceThreadId );

    //
    //  and finally, free the context record.
    //

    UdfFreeIoContext( (PUDF_IO_CONTEXT) Context );
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\dirsup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    DirSup.c

Abstract:

    This module implements the support for walking across on-disk directory
    structures.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   11-Jun-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_DIRSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_DIRSUP)

//
//  Local support routines.
//

BOOLEAN
UdfLookupDirEntryPostProcessing (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN ReturnError
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCleanupDirContext)
#pragma alloc_text(PAGE, UdfFindDirEntry)
#pragma alloc_text(PAGE, UdfInitializeDirContext)
#pragma alloc_text(PAGE, UdfLookupDirEntryPostProcessing)
#pragma alloc_text(PAGE, UdfLookupInitialDirEntry)
#pragma alloc_text(PAGE, UdfLookupNextDirEntry)
#pragma alloc_text(PAGE, UdfUpdateDirNames)
#endif


VOID
UdfInitializeDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine initializes a directory enumeartion context.
    
    Call this exactly once in the lifetime of a context.

Arguments:

    DirContext - a context to initialize

Return Value:

    None.

--*/

{
    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Provide defaults for fields, nothing too special.
    //

    RtlZeroMemory( DirContext, sizeof(DIR_ENUM_CONTEXT) );
}


VOID
UdfCleanupDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine cleans up a directory enumeration context for reuse.

Arguments:

    DirContext - a context to clean.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    
    //
    //  Dump the allocation we store the triple of names in.
    //

    UdfFreePool( &DirContext->NameBuffer );

    //
    //  And the short name.
    //

    UdfFreePool( &DirContext->ShortObjectName.Buffer );

    //
    //  Unpin the view.
    //

    UdfUnpinData( IrpContext, &DirContext->Bcb );

    //
    //  Free a buffered Fid that may remain.
    //
    
    if (FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_FID_BUFFERED )) {

        UdfFreePool( &DirContext->Fid );
    }
    
    //
    //  Zero everything else out.
    //

    RtlZeroMemory( DirContext, sizeof( DIR_ENUM_CONTEXT ) );
}


BOOLEAN
UdfLookupInitialDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN PLONGLONG InitialOffset OPTIONAL
    )

/*++

Routine Description:

    This routine begins the enumeration of a directory by setting the context
    at the first avaliable directory entry.

Arguments:

    Fcb - the directory being enumerated.
    
    DirContext - a corresponding context for the enumeration.
    
    InitialOffset - an optional starting byte offset to base the enumeration.

Return Value:

    If InitialOffset is unspecified, TRUE will always be returned.  Failure will result
    in a raised status indicating corruption.
    
    If InitialOffset is specified, TRUE will be returned if a valid entry is found at this
    offset, FALSE otherwise.

--*/

{
    BOOLEAN Result;

    PAGED_CODE();
    
    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );
    
    //
    //  Create the internal stream if it isn't already in place.
    //

    if (Fcb->FileObject == NULL) {

        UdfCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Reset the flags.
    //

    DirContext->Flags = 0;
    
    if (InitialOffset) {

        //
        //  If we are beginning in the middle of the stream, adjust the sanity check flags.
        //
        
        if (*InitialOffset != 0) {

            DirContext->Flags = DIR_CONTEXT_FLAG_SEEN_NONCONSTANT | DIR_CONTEXT_FLAG_SEEN_PARENT;
        }

        //
        //  Now set up the range we will map.  This is constrained by the size of a cache view.
        //
        
        DirContext->BaseOffset.QuadPart = GenericTruncate( *InitialOffset, VACB_MAPPING_GRANULARITY );
        DirContext->ViewOffset = (ULONG) GenericOffset( *InitialOffset, VACB_MAPPING_GRANULARITY );

    } else {
        
        //
        //  Map at the beginning.
        //
    
        DirContext->BaseOffset.QuadPart = 0;
        DirContext->ViewOffset = 0;
    }

    //
    //  Contain the view length by the size of the stream and map.
    //

    DirContext->ViewLength = VACB_MAPPING_GRANULARITY;

    if (DirContext->BaseOffset.QuadPart + DirContext->ViewLength > Fcb->FileSize.QuadPart) {

        DirContext->ViewLength = (ULONG) (Fcb->FileSize.QuadPart - DirContext->BaseOffset.QuadPart);
    }
    
    UdfUnpinData( IrpContext, &DirContext->Bcb );
    
    CcMapData( Fcb->FileObject,
               &DirContext->BaseOffset,
               DirContext->ViewLength,
               TRUE,
               &DirContext->Bcb,
               &DirContext->View );

    DirContext->Fid = Add2Ptr( DirContext->View, DirContext->ViewOffset, PNSR_FID );

    //
    //  The state of the context is now valid.  Tail off into our common post-processor
    //  to finish the work.
    //

    return UdfLookupDirEntryPostProcessing( IrpContext,
                                            Fcb,
                                            DirContext,
                                            (BOOLEAN) (InitialOffset != NULL));
}


BOOLEAN
UdfLookupNextDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine advances the enumeration of a directory by one entry.

Arguments:

    Fcb - the directory being enumerated.
    
    DirContext - a corresponding context for the enumeration.

Return Value:

    BOOLEAN True if another Fid is avaliable, False if we are at the end.

--*/

{
    PAGED_CODE();
    
    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );

    //
    //  If we have reached the end, stop.
    //
    
    if (DirContext->BaseOffset.QuadPart + DirContext->NextFidOffset == Fcb->FileSize.QuadPart) {

        return FALSE;
    }

    //
    //  If the previous Fid was buffered, dismantle it now.
    //
    
    if (FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_FID_BUFFERED )) {

        ClearFlag( DirContext->Flags, DIR_CONTEXT_FLAG_FID_BUFFERED );
        UdfFreePool( &DirContext->Fid );
    }
    
    //
    //  Move the pointers based on the knowledge generated in the previous iteration.
    //

    DirContext->ViewOffset = DirContext->NextFidOffset;
    DirContext->Fid = Add2Ptr( DirContext->View, DirContext->ViewOffset, PNSR_FID );

    //
    //  The state of the context is now valid.  Tail off into our common post-processor
    //  to finish the work.
    //

    return UdfLookupDirEntryPostProcessing( IrpContext,
                                            Fcb,
                                            DirContext,
                                            FALSE );
}


VOID
UdfUpdateDirNames (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine fills in the non-short names of a directory enumeration context
    for the Fid currently referenced.

Arguments:

    DirContext - a corresponding context to fill in.
    
    IgnoreCase - whether the caller wants to be insensitive to case.

Return Value:

    None.
    
--*/

{
    PUCHAR NameDstring;
    BOOLEAN ContainsIllegal;
    
    USHORT NameLength;
    USHORT RequiredBufferLength;
    USHORT PresentLength;
     
    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace(( +1, Dbg, "UdfUpdateDirNames\n" ));

    //
    //  Handle the case of the self directory entry.
    //

    if (DirContext->Fid == NULL) {

        //
        //  Simply synthesize
        //
        
        //
        //  It doesn't hurt to be pedantic about initialization, so do it all.
        //
        
        DirContext->PureObjectName.Length =
        DirContext->CaseObjectName.Length =
        DirContext->ObjectName.Length = UdfUnicodeDirectoryNames[SELF_ENTRY].Length;
        
        DirContext->PureObjectName.MaximumLength =
        DirContext->CaseObjectName.MaximumLength =
        DirContext->ObjectName.MaximumLength = UdfUnicodeDirectoryNames[SELF_ENTRY].MaximumLength;

        DirContext->PureObjectName.Buffer = 
        DirContext->CaseObjectName.Buffer = 
        DirContext->ObjectName.Buffer = UdfUnicodeDirectoryNames[SELF_ENTRY].Buffer;

        //
        //  All done.
        //

        DebugTrace((  0, Dbg, "Self Entry case\n" ));
        DebugTrace(( -1, Dbg, "UdfUpdateDirNames -> VOID\n" ));
        
        return;
    }
    
    //
    //  Handle the case of the parent directory entry.
    //

    if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_PARENT )) {

        //
        //  Parent entries must occur at the front of the directory and
        //  have a fid length of zero (13346 4/14.4.4).
        //

        if (FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT ) ||
            DirContext->Fid->FileIDLen != 0) {

            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Note that we have seen the parent entry.
        //

        SetFlag( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_PARENT );
        
        //
        //  It doesn't hurt to be pedantic about initialization, so do it all.
        //
        
        DirContext->PureObjectName.Length =
        DirContext->CaseObjectName.Length =
        DirContext->ObjectName.Length = UdfUnicodeDirectoryNames[PARENT_ENTRY].Length;
        
        DirContext->PureObjectName.MaximumLength =
        DirContext->CaseObjectName.MaximumLength =
        DirContext->ObjectName.MaximumLength = UdfUnicodeDirectoryNames[PARENT_ENTRY].MaximumLength;

        DirContext->PureObjectName.Buffer = 
        DirContext->CaseObjectName.Buffer = 
        DirContext->ObjectName.Buffer = UdfUnicodeDirectoryNames[PARENT_ENTRY].Buffer;

        //
        //  All done.
        //

        DebugTrace((  0, Dbg, "Parent Entry case\n" ));
        DebugTrace(( -1, Dbg, "UdfUpdateDirNames -> VOID\n" ));
        
        return;
    }

    //
    //  We now know that we will need to convert the name in a real FID, so figure out where
    //  it sits in the descriptor.
    //
    
    NameDstring = Add2Ptr( DirContext->Fid, ISONsrFidConstantSize + DirContext->Fid->ImpUseLen, PUCHAR );
     
    //
    //  Every directory must record a parent entry.
    //
    
    if (!FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_PARENT)) {
    
        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
    
    //
    //  Note that we are proceeding into the non-constant portion of a directory.
    //
    
    SetFlag( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT );
    
    //
    //  Make sure the dstring is good CS0
    //
    
    UdfCheckLegalCS0Dstring( IrpContext,
                             NameDstring,
                             DirContext->Fid->FileIDLen,
                             0,
                             FALSE );
    
    //
    //  Don't bother allocating tiny buffers - always make sure we get enough for an 8.3 name.
    //

    RequiredBufferLength =
    NameLength = Max( BYTE_COUNT_8_DOT_3, UdfCS0DstringUnicodeSize( IrpContext,
                                                                    NameDstring,
                                                                    DirContext->Fid->FileIDLen) );

    //
    //  Illegality is both actual illegal characters and too many characters.
    //
    
    ContainsIllegal = (!UdfCS0DstringIsLegalFileName( NameDstring, DirContext->Fid->FileIDLen ) ||
                       (NameLength / sizeof( WCHAR )) > MAX_LEN);

    
    //
    //  If we're illegal, we will need more characters to hold the uniqifying stamp.
    //
    
    if (ContainsIllegal) {

        RequiredBufferLength = (NameLength += (CRC_LEN * sizeof(WCHAR)));
    }
    
    
    //
    //  If we need to build a case insensitive name, need more space.
    //
        
    if (IgnoreCase) {

        RequiredBufferLength += NameLength;
    }
    
    //
    //  If we need to render the names due to illegal characters, more space again.
    //
        
    if (ContainsIllegal) {

        RequiredBufferLength += NameLength;
    
    } else {

        //
        //  Make sure the names aren't seperated. If more illegal names are found we can
        //  resplit the buffer but until then avoid the expense of having to copy bytes
        //  ... odds are that illegal characters are going to be a rarish occurance.
        //
        
        DirContext->PureObjectName.Buffer = DirContext->ObjectName.Buffer;
    }

    //
    //  We expect the name lengths and hence buffer size to be multiple of WCHAR
    //
    
    ASSERT( 0 == (RequiredBufferLength & 1));

    DebugTrace(( 0, Dbg,
                 "Ob %s%sneeds %d bytes (%d byte chunks), have %d\n",
                 (IgnoreCase? "Ic " : ""),
                 (ContainsIllegal? "Ci " : ""),
                 RequiredBufferLength,
                 NameLength,
                 DirContext->AllocLength ));

    //
    //  Check if we need more space for the names.  We will need more if the name size is greater
    //  than the maximum we can currently store, or if we have stumbled across illegal characters
    //  and the current Pure name is not seperated from the exposed Object name.
    //
    //  Note that IgnoreCase remains constant across usage of a context so we don't have to wonder
    //  if it has been seperated from the ObjectName - it'll always be correct.
    //

    if ((NameLength > DirContext->ObjectName.MaximumLength) ||
        (ContainsIllegal && (DirContext->ObjectName.Buffer == DirContext->PureObjectName.Buffer))) {

        USHORT DividedBufferLength = 0;
        
        DebugTrace(( 0, Dbg, "Resizing buffers\n" ));

        //
        //  Figure out if we can break up the current allocation in a different way before falling 
        //  back to a new allocation.  Ensure we use even byte size chunks,  or else we can land 
        //  up with alignment faults on IA64.
        //

        if (DirContext->AllocLength >= RequiredBufferLength)  {
        
            DividedBufferLength = (DirContext->AllocLength / (1 +
                                                             (IgnoreCase? 1 : 0) +
                                                             (ContainsIllegal? 1 : 0))) & ~(USHORT)1;
        }

        if (DividedBufferLength >= NameLength)  {

            //
            //  So we can still use the current allocation,  re-divided.
            //

            DirContext->PureObjectName.MaximumLength =
            DirContext->CaseObjectName.MaximumLength =
            DirContext->ObjectName.MaximumLength = DividedBufferLength;

            DebugTrace(( 0, Dbg, 
                         "... by resplit into %d byte chunks\n",
                         DirContext->ObjectName.MaximumLength ));
            
            //
            //  Set the buffer pointers up.  Required adjustment will occur below.
            //
                
            DirContext->PureObjectName.Buffer = 
            DirContext->CaseObjectName.Buffer = 
            DirContext->ObjectName.Buffer = DirContext->NameBuffer;
        
        } else {

            DebugTrace(( 0, Dbg, "... by allocating new pool\n" ));
            
            //
            //  Oh well, no choice but to fall back into the pool.  Drop our previous hunk.
            //
            
            UdfFreePool( &DirContext->NameBuffer );
            DirContext->AllocLength = 0;
            
            //
            //  The names share an allocation for efficiency.
            //
            
            DirContext->PureObjectName.MaximumLength =
            DirContext->CaseObjectName.MaximumLength =
            DirContext->ObjectName.MaximumLength = NameLength;
    
            DirContext->NameBuffer =
            DirContext->PureObjectName.Buffer = 
            DirContext->CaseObjectName.Buffer = 
            DirContext->ObjectName.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                                      RequiredBufferLength,
                                                                      TAG_FILE_NAME );
            DirContext->AllocLength = RequiredBufferLength;
        }
        
        //
        //  In the presence of the "as appropriate" names, adjust the buffer locations.  Note
        //  that ObjectName.Buffer is always the base of the allocated space.
        //
        
        if (IgnoreCase) {

            DirContext->CaseObjectName.Buffer = Add2Ptr( DirContext->ObjectName.Buffer, 
                                                         DirContext->ObjectName.MaximumLength,
                                                         PWCHAR );
        }

        if (ContainsIllegal) {
            
            DirContext->PureObjectName.Buffer = Add2Ptr( DirContext->CaseObjectName.Buffer,
                                                         DirContext->CaseObjectName.MaximumLength,
                                                         PWCHAR );
        }
    }

    ASSERT( RequiredBufferLength <= DirContext->AllocLength );

    //
    //  Convert the dstring.
    //
    
    UdfConvertCS0DstringToUnicode( IrpContext,
                                   NameDstring,
                                   DirContext->Fid->FileIDLen,
                                   0,
                                   &DirContext->PureObjectName );

    //
    //  If illegal characters were present, run the name through the UDF transmogrifier.
    //

    if (ContainsIllegal) {

        UdfRenderNameToLegalUnicode( IrpContext,
                                     &DirContext->PureObjectName,
                                     &DirContext->ObjectName );

    //
    //  The ObjectName is the same as the PureObjectName.
    //

    } else {

        DirContext->ObjectName.Length = DirContext->PureObjectName.Length;
    }

    //
    //  Upcase the result if required.
    //

    if (IgnoreCase) {

        UdfUpcaseName( IrpContext,
                       &DirContext->ObjectName,
                       &DirContext->CaseObjectName );
    }

    DebugTrace(( -1, Dbg, "UdfUpdateDirNames -> VOID\n" ));
    
    return;
}


BOOLEAN
UdfFindDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortName,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine walks the directory specified for an entry which matches the input
    criteria.

Arguments:

    Fcb - the directory to search
    
    Name - name to search for
    
    IgnoreCase - whether this search should be case-insensitive (Name will already
        be upcased)
        
    ShortName - whether the name should be searched for according to short name rules
    
    DirContext - context structure to use and return results in

Return Value:

    BOOLEAN True if a matching directory entry is being returned, False otherwise.

--*/

{
    PUNICODE_STRING MatchName;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );

    DebugTrace(( +1, Dbg,
                 "UdfFindDirEntry, Fcb=%08x Name=\"%wZ\" Ignore=%u Short=%u, DC=%08x\n",
                 Fcb,
                 Name,
                 IgnoreCase,
                 ShortName,
                 DirContext ));

    //
    //  Depending on the kind of search we are performing a different flavor of the found name
    //  wil be used in the comparison.
    //
    
    if (ShortName) {

        MatchName = &DirContext->ShortObjectName;
    
    } else {

        MatchName = &DirContext->CaseObjectName;
    }


    //
    //  Go get the first entry.
    //

    UdfLookupInitialDirEntry( IrpContext,
                              Fcb,
                              DirContext,
                              NULL );

    //
    //  Now loop looking for a good match.
    //
    
    do {

        //
        //  If it is deleted, we obviously aren't interested in it.
        //
        
        if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_DELETED )) {

            continue;
        }

        UdfUpdateDirNames( IrpContext,
                           DirContext,
                           IgnoreCase );
            
        
        //
        //  If this is a constant entry, just keep going.
        //
        
        if (!FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT )) {
            
            continue;
        }

        DebugTrace(( 0, Dbg,
                     "\"%wZ\" (pure \"%wZ\") @ +%08x\n",
                     &DirContext->ObjectName,
                     &DirContext->PureObjectName,
                     DirContext->ViewOffset ));

        //
        //  If we are searching for generated shortnames, a small subset of the names
        //  in the directory are actually candidates for a match.  Go get the name.
        //
        
        if (ShortName) {

            //
            //  Now, only if this Fid's name is non 8.3 is it neccesary to work with it.
            //
            
            if (!UdfIs8dot3Name( IrpContext, DirContext->ObjectName )) {

                //
                //  Allocate the shortname if it isn't already done.
                //
                
                if (DirContext->ShortObjectName.Buffer == NULL) {

                    DirContext->ShortObjectName.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                                                   BYTE_COUNT_8_DOT_3,
                                                                                   TAG_SHORT_FILE_NAME );
                    DirContext->ShortObjectName.MaximumLength = BYTE_COUNT_8_DOT_3;
                }

                UdfGenerate8dot3Name( IrpContext,
                                      &DirContext->PureObjectName,
                                      &DirContext->ShortObjectName );

                DebugTrace(( 0, Dbg,
                             "built shortname \"%wZ\"\n", &DirContext->ShortObjectName ));

            } else {

                //
                //  As an 8.3 name already, this name will not have caused us to have to generate
                //  a short name, so it can't be the case that the caller is looking for it.
                //
                
                continue;
            }
        }

        if (UdfFullCompareNames( IrpContext,
                                 MatchName,
                                 Name ) == EqualTo) {

            //
            //  Got a match, so give it up.
            //

            DebugTrace((  0, Dbg, "HIT\n" ));
            DebugTrace(( -1, Dbg, "UdfFindDirEntry -> TRUE\n" ));

            return TRUE;
        }

    } while ( UdfLookupNextDirEntry( IrpContext,
                                     Fcb,
                                     DirContext ));

    //
    //  No match was found.
    //

    DebugTrace(( -1, Dbg, "UdfFindDirEntry -> FALSE\n" ));

    return FALSE;
}


//
//  Local support routine
//

BOOLEAN
UdfLookupDirEntryPostProcessing (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN ReturnError
    )

/*++

Routine Description:

    This routine is the core engine of directory stream enumeration. It receives
    a context which has been advanced and does the integrity checks and final
    extraction of the Fid with respect to file cache granularity restrictions.

    NOTE: we assume that a Fid cannot span a cache view.  The maximum size of a
    Fid is just over 32k, so this is a good and likely permanent assumption.

Arguments:

    Fcb - the directory being enumerated.
    
    DirContext - a corresponding context for the enumeration.
    
    ReturnError - whether errors should be returned (or raised)

Return Value:

    BOOLEAN according to the successful extraction of the Fid.  If ReturnError is
    FALSE, then failure will result in a raised status.

--*/

{
    BOOLEAN Result = TRUE;
    
    PNSR_FID FidBufferC = NULL;
    PNSR_FID FidBuffer = NULL;

    PNSR_FID FidC;
    PNSR_FID Fid;

    ULONG FidSize;

    ULONG FidBytesInPreviousView = 0;
    
    PAGED_CODE();
    
    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );
    
    try {
        
        //
        //  First check that the stream can contain another FID.
        //
    
        if (DirContext->BaseOffset.QuadPart +
            DirContext->ViewOffset +
            ISONsrFidConstantSize > Fcb->FileSize.QuadPart) {
    
            DebugTrace(( 0, Dbg,
                         "UdfLookupDirEntryPostProcessing: DC %p, constant header overlaps end of dir\n",
                         DirContext ));

            try_leave( Result = FALSE );
        }
            
        //
        //  We now build up the constant portion of the FID for use.  It may be the case that
        //  this spans a view boundary and must be buffered, or is entirely in the next view
        //  and we simply need to advance.
        //
    
        if (GenericTruncatePtr( Add2Ptr( DirContext->Fid, ISONsrFidConstantSize - 1, PUCHAR ), VACB_MAPPING_GRANULARITY ) !=
            DirContext->View) {
            
            FidBytesInPreviousView = GenericRemainderPtr( DirContext->Fid, VACB_MAPPING_GRANULARITY );
            
            //
            //  Only buffer if there are really bytes in the previous view.
            //
            
            if (FidBytesInPreviousView) {
                
                FidC =
                FidBufferC = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                       ISONsrFidConstantSize,
                                                       TAG_FID_BUFFER );
        
                RtlCopyMemory( FidBufferC,
                               DirContext->Fid,
                               FidBytesInPreviousView );
            }
    
            //
            //  Now advance into the next view to pick up the rest.
            //
            
            DirContext->BaseOffset.QuadPart += VACB_MAPPING_GRANULARITY;
            DirContext->ViewOffset = 0;
            
            //
            //  Contain the view length by the size of the stream and map.
            //
        
            DirContext->ViewLength = VACB_MAPPING_GRANULARITY;
        
            if (DirContext->BaseOffset.QuadPart + DirContext->ViewLength > Fcb->FileSize.QuadPart) {
        
                DirContext->ViewLength = (ULONG) (Fcb->FileSize.QuadPart - DirContext->BaseOffset.QuadPart);
            }
            
            UdfUnpinData( IrpContext, &DirContext->Bcb );
            
            CcMapData( Fcb->FileObject,
                       &DirContext->BaseOffset,
                       DirContext->ViewLength,
                       TRUE,
                       &DirContext->Bcb,
                       &DirContext->View );

            //
            //  We are guaranteed that this much lies in the stream.  Build the rest of the
            //  constant header.
            //
    
            if (FidBytesInPreviousView) {
                
                RtlCopyMemory( Add2Ptr( FidBufferC, FidBytesInPreviousView, PUCHAR ),
                               DirContext->View,
                               ISONsrFidConstantSize - FidBytesInPreviousView );
            
            //
            //  In fact, this FID is perfectly aligned to the front of this view.  No buffering
            //  is required, and we just set the FID pointer.
            //

            } else {


                DirContext->Fid = DirContext->View;
            }
        }
         
        //
        //  If no buffering was required, we can use the cache directly.
        //
            
        if (!FidBytesInPreviousView) {
    
            FidC = DirContext->Fid;
        }
    
        //
        //  Now we can check that the Fid data lies within the stream bounds and is sized
        //  within a logical block (per UDF).  This will complete the size-wise integrity
        //  verification.
        //

        if (((DirContext->BaseOffset.QuadPart +
              DirContext->ViewOffset -
              FidBytesInPreviousView +
              ISONsrFidSize( FidC ) > Fcb->FileSize.QuadPart) &&
             DebugTrace(( 0, Dbg,
                          "UdfLookupDirEntryPostProcessing: DC %p, FID (FidC %p, FBIPV %u) overlaps end of dir\n",
                          DirContext,
                          FidC,
                          FidBytesInPreviousView )))
              ||

            (ISONsrFidSize( FidC ) > BlockSize( Fcb->Vcb ) &&
             DebugTrace(( 0, Dbg,
             "UdfLookupDirEntryPostProcessing: DC %p, FID (FidC %p) larger than a logical block\n",
                          DirContext,
                          FidC )))) {

            try_leave( Result = FALSE );

        }

        //
        //  Final Fid rollup.
        //
        
        //
        //  The Fid may span a view boundary and should be buffered.  If we already buffered, we know
        //  we have to do this.
        //

        if (FidBytesInPreviousView ||
            GenericTruncatePtr( Add2Ptr( DirContext->Fid, ISONsrFidSize( FidC ) - 1, PUCHAR ), VACB_MAPPING_GRANULARITY ) !=
            DirContext->View) {
        
            Fid =
            FidBuffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                  ISONsrFidSize( FidC ),
                                                  TAG_FID_BUFFER );

            //
            //  Pull the fidsize out now in case we're still pointing to the cache (ie. no
            //  buffering was required for fixed portion) but are about to change the mapping
            //  below (need to buffer for variable portion).
            //
            
            FidSize = ISONsrFidSize( FidC);
            
            //
            //  If we already buffered and advanced for the header, just prefill
            //  the final Fid buffer with the bytes that are now unavaliable.
            //
            
            if (FidBytesInPreviousView) {

                RtlCopyMemory( FidBuffer,
                               FidBufferC,
                               FidBytesInPreviousView );

            } else {
                
                //
                //  Buffer and advance the view.
                //
                
                FidBytesInPreviousView = GenericRemainderPtr( DirContext->Fid, VACB_MAPPING_GRANULARITY );
                
                RtlCopyMemory( FidBuffer,
                               DirContext->Fid,
                               FidBytesInPreviousView );
                
                //
                //  Now advance into the next view to pick up the rest.
                //
                
                DirContext->BaseOffset.QuadPart += VACB_MAPPING_GRANULARITY;
                DirContext->ViewOffset = 0;
                
                //
                //  Contain the view length by the size of the stream and map.
                //
            
                DirContext->ViewLength = VACB_MAPPING_GRANULARITY;
            
                if (DirContext->BaseOffset.QuadPart + DirContext->ViewLength > Fcb->FileSize.QuadPart) {
            
                    DirContext->ViewLength = (ULONG) (Fcb->FileSize.QuadPart - DirContext->BaseOffset.QuadPart);
                }
                
                UdfUnpinData( IrpContext, &DirContext->Bcb );
                
                CcMapData( Fcb->FileObject,
                           &DirContext->BaseOffset,
                           DirContext->ViewLength,
                           TRUE,
                           &DirContext->Bcb,
                           &DirContext->View );
            }
    
            //
            //  We are guaranteed that this much lies in the stream.
            //
    
            RtlCopyMemory( Add2Ptr( FidBuffer, FidBytesInPreviousView, PUCHAR ),
                           DirContext->View,
                           FidSize - FidBytesInPreviousView );
    
        } else {

            Fid = DirContext->Fid;
        }
        
        //
        //  We finally have the whole Fid safely extracted from the cache, so the
        //  integrity check is now the last step before success.  For simplicity's
        //  sake we trust the Lbn field.
        //
    
        Result = UdfVerifyDescriptor( IrpContext,
                                      &Fid->Destag,
                                      DESTAG_ID_NSR_FID,
                                      ISONsrFidSize( Fid ),
                                      Fid->Destag.Lbn,
                                      ReturnError );

        //
        //  Prepare to return a buffered Fid.
        //
        
        if (FidBuffer && Result) {

            SetFlag( DirContext->Flags, DIR_CONTEXT_FLAG_FID_BUFFERED );
            DirContext->Fid = FidBuffer;
            FidBuffer = NULL;
        }
        
    } finally {

        UdfFreePool( &FidBuffer );
        UdfFreePool( &FidBufferC );
    }

    if (!ReturnError && !Result) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  On success update the next Fid information in the context.
    //  Note that  we must drop in a hint as to where the next Fid
    //  will be found so that the next advance will know how much
    //  of a buffered Fid isn't in this view.
    //

    if (Result) {

        DirContext->NextFidOffset = DirContext->ViewOffset +
                                    ISONsrFidSize( Fid );
        
        if (FidBytesInPreviousView) {
            
            DirContext->NextFidOffset -= FidBytesInPreviousView;
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\dirctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routines for Udfs called
    by the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     27-Nov-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support
    
// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_DIRCTRL)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_DIRCTRL)

//
//  Local structures
//

//
//  The following is used for the more complete enumeration required in the DirectoryControl path
//  and encapsulates the structures for enumerating both directories and ICBs, as well as converted
//  data from the ICB.
//

typedef struct _COMPOUND_DIR_ENUM_CONTEXT {

    //
    //  Standard enumeration contexts.  For this enumeration we walk the directory and lift the
    //  associated ICB for each entry.
    //
    
    DIR_ENUM_CONTEXT DirContext;
    ICB_SEARCH_CONTEXT IcbContext;

    //
    //  Timestamps converted from the ICB into NT-native form.
    //

    TIMESTAMP_BUNDLE Timestamps;

    //
    //  File index corresponding to the current position in the enumeration.
    //

    LARGE_INTEGER FileIndex;

} COMPOUND_DIR_ENUM_CONTEXT, *PCOMPOUND_DIR_ENUM_CONTEXT;

//
//  Local macros
//

//
//  Constants defining the space of FileIndices for directory enumeration.
//

//
//  The virtual (synthesized) file indices
//

#define UDF_FILE_INDEX_VIRTUAL_SELF         0

//
//  The file index where the physical directory entries begin
//

#define UDF_FILE_INDEX_PHYSICAL             1

//
//  Provide initialization and cleanup for compound enumeration contexts.
//

INLINE
VOID
UdfInitializeCompoundDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    )
{

    UdfInitializeDirContext( IrpContext, &CompoundDirContext->DirContext );
    UdfFastInitializeIcbContext( IrpContext, &CompoundDirContext->IcbContext );

    RtlZeroMemory( &CompoundDirContext->Timestamps, sizeof( TIMESTAMP_BUNDLE ));

    CompoundDirContext->FileIndex.QuadPart = 0;
}

INLINE
VOID
UdfCleanupCompoundDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    )
{

    UdfCleanupDirContext( IrpContext, &CompoundDirContext->DirContext );
    UdfCleanupIcbContext( IrpContext, &CompoundDirContext->IcbContext );
}

//
//  UDF directories are unsorted (UDF 1.0.1 2.3.5.3) and do not contain self
//  entries.  For directory enumeration we must provide a way for a restart to
//  occur at a random entry (SL_INDEX_SPECIFIED), but the key used is only
//  32bits.  Since the directory is unsorted, the filename is unsuitable for
//  quickly finding a restart point (even assuming that it was sorted,
//  discovering a directory entry is still not fast).  Additionally, we must
//  synthesize the self-entry.  So, here is how we map the space of file
//  indices to directory entries:
//
//    File Index              Directory Entry
//  
//    0                       self ('.')
//    1                       at byte offset 0 in the stream
//    N                       at byte offset N-1 in the stream
//  
//  The highest 32bit FileIndex returned will be stashed in the Ccb.
//  
//  For FileIndex > 2^32, we will return FileIndex 0 in the query structure.
//  On a restart, we will notice a FileIndex of zero and use the saved high
//  32bit FileIndex as the starting point for a linear scan to find the named
//  directory entry in the restart request.  In this way we only penalize the
//  improbable case of a directory stream > 2^32 bytes.
//
//  The following inline routines assist with this mapping.
//

INLINE
LONGLONG
UdfFileIndexToPhysicalOffset(
    LONGLONG FileIndex
    )
{

    return FileIndex - UDF_FILE_INDEX_PHYSICAL;
}

INLINE
LONGLONG
UdfPhysicalOffsetToFileIndex(
    LONGLONG PhysicalOffset
    )
{

    return PhysicalOffset + UDF_FILE_INDEX_PHYSICAL;
}

INLINE
BOOLEAN
UdfIsFileIndexVirtual(
   LONGLONG FileIndex
   )
{

    return FileIndex < UDF_FILE_INDEX_PHYSICAL;
}

//
//  Local support routines
//

NTSTATUS
UdfQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN PCCB Ccb
    );

NTSTATUS
UdfNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PCCB Ccb
    );

NTSTATUS
UdfInitializeEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN OUT PCCB Ccb,
    IN OUT PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    OUT PBOOLEAN ReturnNextEntry,
    OUT PBOOLEAN ReturnSingleEntry,
    OUT PBOOLEAN InitialQuery
    );

BOOLEAN
UdfEnumerateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN OUT PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    IN BOOLEAN ReturnNextEntry
    );

VOID
UdfLookupFileEntryInEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    );

BOOLEAN
UdfLookupInitialFileIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    IN PLONGLONG InitialIndex
    );

BOOLEAN
UdfLookupNextFileIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonDirControl)
#pragma alloc_text(PAGE, UdfEnumerateIndex)
#pragma alloc_text(PAGE, UdfInitializeEnumeration)
#pragma alloc_text(PAGE, UdfLookupFileEntryInEnumeration)
#pragma alloc_text(PAGE, UdfLookupInitialFileIndex)
#pragma alloc_text(PAGE, UdfLookupNextFileIndex)
#pragma alloc_text(PAGE, UdfNotifyChangeDirectory)
#pragma alloc_text(PAGE, UdfQueryDirectory)
#endif


NTSTATUS
UdfCommonDirControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the entry point for the directory control operations.  These
    are directory enumerations and directory notify calls.  We verify the
    user's handle is for a directory and then call the appropriate routine.

Arguments:

    Irp - Irp for this request.

Return Value:

    NTSTATUS - Status returned from the lower level routines.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the user file object and fail this request if it is not
    //  a user directory.
    //

    if (UdfDecodeFileObject( IrpSp->FileObject,
                             &Fcb,
                             &Ccb ) != UserDirectoryOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_QUERY_DIRECTORY:

        Status = UdfQueryDirectory( IrpContext, Irp, IrpSp, Fcb, Ccb );
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        Status = UdfNotifyChangeDirectory( IrpContext, Irp, IrpSp, Ccb );
        break;

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routines
//

NTSTATUS
UdfQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing of enqueuing the input Irp.  We store the state of the
    search in the Ccb.

Arguments:

    Irp - Supplies the Irp to process

    IrpSp - Stack location for this Irp.

    Fcb - Fcb for this directory.

    Ccb - Ccb for this directory open.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Information = 0;

    ULONG LastEntry = 0;
    ULONG NextEntry = 0;

    ULONG FileNameBytes;
    ULONG BytesConverted;

    LARGE_INTEGER PreviousFileIndex;

    COMPOUND_DIR_ENUM_CONTEXT CompoundDirContext;

    PNSR_FID ThisFid;
    PICBFILE ThisFe;
    
    BOOLEAN InitialQuery;
    BOOLEAN ReturnNextEntry;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN Found;
    BOOLEAN EasCorrupt;

    PCHAR UserBuffer;
    ULONG BytesRemainingInBuffer;

    ULONG BaseLength;

    PFILE_BOTH_DIR_INFORMATION DirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;
    PFILE_ID_FULL_DIR_INFORMATION IdFullDirInfo;
    PFILE_ID_BOTH_DIR_INFORMATION IdBothDirInfo;

    PAGED_CODE();

    DebugTrace(( 0, Dbg, "UdfQueryDirectory\n" ));
    
    //
    //  Check if we support this search mode.  Also remember the size of the base part of
    //  each of these structures.
    //

    switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {

    case FileDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                   FileName[0] );
        break;

    case FileFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileNamesInformation:

        BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                   FileName[0] );
        break;

    case FileBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_INFO_CLASS );
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    //  Get the user buffer.
    //

    UdfMapUserBuffer( IrpContext, &UserBuffer);

    //
    //  Initialize our search context.
    //

    UdfInitializeCompoundDirContext( IrpContext, &CompoundDirContext );
    
    //
    //  Acquire the directory.
    //

    UdfAcquireFileShared( IrpContext, Fcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Fcb is still good.
        //

        UdfVerifyFcbOperation( IrpContext, Fcb );

        //
        //  Start by getting the initial state for the enumeration.  This will set up the Ccb with
        //  the initial search parameters and let us know the starting offset in the directory
        //  to search.
        //

        Status = UdfInitializeEnumeration( IrpContext,
                                           IrpSp,
                                           Fcb,
                                           Ccb,
                                           &CompoundDirContext,
                                           &ReturnNextEntry,
                                           &ReturnSingleEntry,
                                           &InitialQuery );
        if (!NT_SUCCESS( Status )) {

            try_leave( Status );
        }


        //
        //  At this point we are about to enter our query loop.  We have
        //  determined the index into the directory file to begin the
        //  search.  LastEntry and NextEntry are used to index into the user
        //  buffer.  LastEntry is the last entry we've added, NextEntry is
        //  current one we're working on.  If NextEntry is non-zero, then
        //  at least one entry was added.
        //

        while (TRUE) {

            //
            //  If the user had requested only a single match and we have
            //  returned that, then we stop at this point.  We update the Ccb with
            //  the status based on the last entry returned.
            //

            if ((NextEntry != 0) && ReturnSingleEntry) {

                try_leave( Status );
            }

            //
            //  We try to locate the next matching dirent.  Our search if based on a starting
            //  dirent offset, whether we should return the current or next entry, whether
            //  we should be doing a short name search and finally whether we should be
            //  checking for a version match.
            //

            PreviousFileIndex = CompoundDirContext.FileIndex;
            
            try {
            
                Found = UdfEnumerateIndex( IrpContext, Ccb, &CompoundDirContext, ReturnNextEntry );
            }
            except (((0 != NextEntry) && 
                     ((GetExceptionCode() == STATUS_FILE_CORRUPT_ERROR) || 
                      (GetExceptionCode() == STATUS_CRC_ERROR)))
                     ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)  {

                DebugTrace((0, Dbg, "UdfQueryDirectory - Corrupt. Returning buffer so far,  setting back enumeration\n"));
                
                //
                //  We encountered corruption in the directory.  We will swallow this 
                //  error since we have already placed some previous entries in the user 
                //  buffer,  and raise it when we're called again.  This is
                //  to return as much as possible in the case of corrupt directories, 
                //  particularly discs which are padded wrong at the end of the dir.
                //

                ReturnNextEntry = TRUE;

                //
                //  Point to the previous Fid,  so that we will advance again to the point
                //  of corruption on next call (we only do bounds checking on advance,  not 
                //  when restarting *at* a particular entry).
                //

                CompoundDirContext.FileIndex = PreviousFileIndex;

                try_leave( Status = STATUS_SUCCESS);
            }

            //
            //  Initialize the value for the next search.
            //

            ReturnNextEntry = TRUE;

            //
            //  If we didn't receive a dirent, then we are at the end of the
            //  directory.  If we have returned any files, we exit with
            //  success, otherwise we return STATUS_NO_MORE_FILES.
            //

            if (!Found) {

                if (NextEntry == 0) {

                    Status = STATUS_NO_MORE_FILES;

                    if (InitialQuery) {

                        Status = STATUS_NO_SUCH_FILE;
                    }
                }

                try_leave( Status );
            }

            //
            //  Remember the dirent/file entry for the file we just found.
            //

            ThisFid = CompoundDirContext.DirContext.Fid;

            //
            //  Here are the rules concerning filling up the buffer:
            //
            //  1.  The Io system garentees that there will always be
            //      enough room for at least one base record.
            //
            //  2.  If the full first record (including file name) cannot
            //      fit, as much of the name as possible is copied and
            //      STATUS_BUFFER_OVERFLOW is returned.
            //
            //  3.  If a subsequent record cannot completely fit into the
            //      buffer, none of it (as in 0 bytes) is copied, and
            //      STATUS_SUCCESS is returned.  A subsequent query will
            //      pick up with this record.
            //

            //
            //  We can look directly at the dirent that we found.
            //

            FileNameBytes = CompoundDirContext.DirContext.CaseObjectName.Length;

            //
            //  If the slot for the next entry would be beyond the length of the
            //  user's buffer just exit (we know we've returned at least one entry
            //  already). This will happen when we align the pointer past the end.
            //

            if (NextEntry > IrpSp->Parameters.QueryDirectory.Length) {
                
                ReturnNextEntry = FALSE;
                try_leave( Status = STATUS_SUCCESS );
            }

            //
            //  Compute the number of bytes remaining in the buffer.  Round this
            //  down to a WCHAR boundary so we can copy full characters.
            //

            BytesRemainingInBuffer = IrpSp->Parameters.QueryDirectory.Length - NextEntry;
            ClearFlag( BytesRemainingInBuffer, 1 );

            //
            //  If this won't fit and we have returned a previous entry then just
            //  return STATUS_SUCCESS.
            //

            if ((BaseLength + FileNameBytes) > BytesRemainingInBuffer) {

                //
                //  If we already found an entry then just exit.
                //

                if (NextEntry != 0) {

                    ReturnNextEntry = FALSE;
                    try_leave( Status = STATUS_SUCCESS );
                }

                //
                //  Reduce the FileNameBytes to just fit in the buffer.
                //

                FileNameBytes = BytesRemainingInBuffer - BaseLength;

                //
                //  Use a status code of STATUS_BUFFER_OVERFLOW.  Also set
                //  ReturnSingleEntry so that we will exit the loop at the top.
                //

                Status = STATUS_BUFFER_OVERFLOW;
                ReturnSingleEntry = TRUE;
            }

            //
            //  Protect access to the user buffer with an exception handler.
            //  Since (at our request) IO doesn't buffer these requests, we have
            //  to guard against a user messing with the page protection and other
            //  such trickery.
            //

            try {
                
                //
                //  Zero and initialize the base part of the current entry.
                //

                RtlZeroMemory( Add2Ptr( UserBuffer, NextEntry, PVOID ),
                               BaseLength );
    
                //
                //  Now we have an entry to return to our caller.
                //  We'll case on the type of information requested and fill up
                //  the user buffer if everything fits.
                //
    
                switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {
    
                case FileBothDirectoryInformation:
                case FileFullDirectoryInformation:
                case FileIdBothDirectoryInformation:
                case FileIdFullDirectoryInformation:
                case FileDirectoryInformation:
    
                    DirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_BOTH_DIR_INFORMATION );
    
                    //
                    //  These information types require we look up the file entry.
                    //  We will swallow certain corruption errors here in the interest of
                    //  allowing users to access other objects in the directory.  The
                    //  errors will be reported later if the corrupt object is opened.
                    //

                    EasCorrupt = FALSE;
                    ThisFe = NULL;

                    try {

                        UdfLookupFileEntryInEnumeration( IrpContext,
                                                         Fcb,
                                                         &CompoundDirContext );
                        //
                        //  Directly reference the file entry we just looked up.
                        //
                        
                        ThisFe = (PICBFILE) CompoundDirContext.IcbContext.Active.View;
                        
                        //
                        //  Now go gather all of the timestamps for this guy.
                        //
                        
                        UdfUpdateTimestampsFromIcbContext ( IrpContext,
                                                            &CompoundDirContext.IcbContext,
                                                            &CompoundDirContext.Timestamps );
                    }
                    except (UdfQueryDirExceptionFilter( GetExceptionInformation()))  {

                        //
                        //  The currently mapped ICB will have been left in IcbContext->Current,
                        //  and we could look at it and pull out timestamps / filesizes,
                        //  but it could be complete trash,  so we'll just zero these fields 
                        //  in this dir record.
                        //

                        DebugTrace(( 0, Dbg, "Ignoring corrupt FE (referenced by FID in dir FCB 0x%p) during dir enum\n",  Fcb));

                        //
                        //  We either failed verification of the core FE fields,  or looking
                        //  up the EAs for timestamps.  Either way,  the EAs are definitely dead
                        //  which means the create time is invalid
                        //

                        EasCorrupt = TRUE;

                        IrpContext->ExceptionStatus = STATUS_SUCCESS;
                    }

                    //
                    //  If we actually have an FE here that means that the core content verified 
                    //  ok,  so pull out the relevant information.
                    //

                    if (NULL != ThisFe)  {                    

                        DirInfo->LastWriteTime =
                        DirInfo->ChangeTime = CompoundDirContext.Timestamps.ModificationTime;
        
                        DirInfo->LastAccessTime = CompoundDirContext.Timestamps.AccessTime;
        
                        if (!EasCorrupt)  {

                            DirInfo->CreationTime = CompoundDirContext.Timestamps.CreationTime;
                        }
                        else {
                        
                            DirInfo->CreationTime = UdfCorruptFileTime;
                        }

                        //
                        //  Set the attributes and sizes separately for directories and
                        //  files.
                        //
        
                        if (ThisFe->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY) {
        
                            DirInfo->EndOfFile.QuadPart = DirInfo->AllocationSize.QuadPart = 0;
        
                            SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
        
                        } else {
        
                            DirInfo->EndOfFile.QuadPart = ThisFe->InfoLength;
                            DirInfo->AllocationSize.QuadPart = LlBlockAlign( Fcb->Vcb, ThisFe->InfoLength );
                        }
                    }
                    else {

                        //
                        //  FE is corrupt.  Fill in (irrelevant) valid times.  
                        //

                        DirInfo->CreationTime =
                        DirInfo->ChangeTime =
                        DirInfo->LastWriteTime =
                        DirInfo->LastAccessTime = UdfCorruptFileTime;
                    }
                    
                    //
                    //  All Cdrom files are readonly.  We also copy the existence
                    //  bit to the hidden attribute, assuming that synthesized FIDs
                    //  are never hidden.
                    //

                    SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_READONLY );
    
                    if (ThisFid && FlagOn( ThisFid->Flags, NSR_FID_F_HIDDEN )) {
    
                        SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
                    }

                    //
                    //  The file index for real file indices > 2^32 is zero.  When asked to
                    //  restart at an index of zero, we will know to use a stashed starting
                    //  point to beging to search, by name, for the correct restart point.
                    //
                    
                    if (CompoundDirContext.FileIndex.HighPart == 0) {
                        
                        DirInfo->FileIndex = CompoundDirContext.FileIndex.LowPart;
                    
                    } else {
    
                        DirInfo->FileIndex = 0;
                    }
    
                    DirInfo->FileNameLength = FileNameBytes;
    
                    break;
    
                case FileNamesInformation:
    
                    NamesInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_NAMES_INFORMATION );
    
                    if (CompoundDirContext.FileIndex.HighPart == 0) {
                        
                        NamesInfo->FileIndex = CompoundDirContext.FileIndex.LowPart;
                    
                    } else {
    
                        NamesInfo->FileIndex = 0;
                    }
    
                    NamesInfo->FileNameLength = FileNameBytes;
    
                    break;
                }

                //
                //  Fill in the FileId
                //

                switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {

                case FileIdBothDirectoryInformation:

                    IdBothDirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_ID_BOTH_DIR_INFORMATION );
                    UdfSetFidFromFidAndFe( IdBothDirInfo->FileId, ThisFid, ThisFe );
                    break;

                case FileIdFullDirectoryInformation:

                    IdFullDirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_ID_FULL_DIR_INFORMATION );
                    UdfSetFidFromFidAndFe( IdFullDirInfo->FileId, ThisFid, ThisFe );
                    break;

                default:
                    break;
                }
    
                //
                //  Now copy as much of the name as possible.
                //
    
                if (FileNameBytes != 0) {
    
                    //
                    //  This is a Unicode name, we can copy the bytes directly.
                    //
    
                    RtlCopyMemory( Add2Ptr( UserBuffer, NextEntry + BaseLength, PVOID ),
                                   CompoundDirContext.DirContext.ObjectName.Buffer,
                                   FileNameBytes );
                }

                //
                //  Fill in the short name if we got STATUS_SUCCESS.  The short name
                //  may already be in the file context, otherwise we will check
                //  whether the long name is 8.3.  Special case the self and parent
                //  directory names.
                //
    
                if ((Status == STATUS_SUCCESS) &&
                    (IrpSp->Parameters.QueryDirectory.FileInformationClass == FileBothDirectoryInformation ||
                     IrpSp->Parameters.QueryDirectory.FileInformationClass == FileIdBothDirectoryInformation) &&
                    FlagOn( CompoundDirContext.DirContext.Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT )) {
    
                    //
                    //  If we already have the short name then copy into the user's buffer.
                    //
    
                    if (CompoundDirContext.DirContext.ShortObjectName.Length != 0) {
    
                        RtlCopyMemory( DirInfo->ShortName,
                                       CompoundDirContext.DirContext.ShortObjectName.Buffer,
                                       CompoundDirContext.DirContext.ShortObjectName.Length );
    
                        DirInfo->ShortNameLength = (CCHAR) CompoundDirContext.DirContext.ShortObjectName.Length;
    
                    //
                    //  If the short name length is currently zero then check if
                    //  the long name is not 8.3.  We can copy the short name in
                    //  unicode form directly into the caller's buffer.
                    //
    
                    } else {
    
                        if (!UdfIs8dot3Name( IrpContext,
                                             CompoundDirContext.DirContext.ObjectName )) {
    
                            UNICODE_STRING ShortName;
    
                            ShortName.Buffer = DirInfo->ShortName;
                            ShortName.MaximumLength = BYTE_COUNT_8_DOT_3;
                            
                            UdfGenerate8dot3Name( IrpContext,
                                                  &CompoundDirContext.DirContext.PureObjectName,
                                                  &ShortName );
    
                            DirInfo->ShortNameLength = (CCHAR) ShortName.Length;
                        }
                    }
                }

                //
                //  Update the information with the number of bytes stored in the
                //  buffer.  We quad-align the existing buffer to add any necessary
                //  pad bytes.
                //

                Information = NextEntry + BaseLength + FileNameBytes;

                //
                //  Go back to the previous entry and fill in the update to this entry.
                //

                *(Add2Ptr( UserBuffer, LastEntry, PULONG )) = NextEntry - LastEntry;

                //
                //  Set up our variables for the next dirent.
                //

                InitialQuery = FALSE;

                LastEntry = NextEntry;
                NextEntry = QuadAlign( Information );
            
            } 
            except (!FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

                  //
                  //  We must have had a problem filling in the user's buffer, so stop
                  //  and fail this request.
                  //
                  
                  Information = 0;
                  try_leave( Status = GetExceptionCode());
            }
        }

    } 
    finally {

        if (!AbnormalTermination() && !NT_ERROR( Status )) {
        
            //
            //  Update the Ccb to show the current state of the enumeration.
            //
    
            UdfLockFcb( IrpContext, Fcb );
    
            Ccb->CurrentFileIndex = CompoundDirContext.FileIndex.QuadPart;

            //
            //  Update our notion of a high 32bit file index.  We only do this once to avoid the hit
            //  of thrashing the Fcb mutex to do this for every entry.  If it is ever neccesary to use
            //  this information, the difference of a few dozen entries from the optimal pick-up point
            //  will be trivial.
            //
            
            if (CompoundDirContext.FileIndex.HighPart == 0 &&
                CompoundDirContext.FileIndex.LowPart > Ccb->HighestReturnableFileIndex) {

                    Ccb->HighestReturnableFileIndex = CompoundDirContext.FileIndex.LowPart;
            }

            //
            //  Mark in the CCB whether or not to skip the current entry on next call
            //  (if we  returned it in the current buffer).
            //
                
            ClearFlag( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
    
            if (ReturnNextEntry) {
    
                SetFlag( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
            }
    
            UdfUnlockFcb( IrpContext, Fcb );
        }

        //
        //  Cleanup our search context.
        //

        UdfCleanupCompoundDirContext( IrpContext, &CompoundDirContext );

        //
        //  Release the Fcb.
        //

        UdfReleaseFile( IrpContext, Fcb );
    }

    DebugTrace(( 0, Dbg, "UdfQueryDirectory -> %x\n", Status ));
    
    //
    //  Complete the request here.
    //

    Irp->IoStatus.Information = Information;

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routines
//

NTSTATUS
UdfNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing of enqueuing the input Irp.  Although there
    will never be a notify signalled on a readonly disk we still support this call.

    We have already checked that this is not an OpenById handle.

Arguments:

    Irp - Supplies the Irp to process

    IrpSp - Io stack location for this request.

    Ccb - Handle to the directory being watched.

Return Value:

    NTSTATUS - STATUS_PENDING, any other error will raise.

--*/

{
    PAGED_CODE();

    //
    //  Always set the wait bit in the IrpContext so the initial wait can't fail.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  Acquire the Vcb shared.
    //

    UdfAcquireVcbShared( IrpContext, IrpContext->Vcb, FALSE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Vcb.
        //

        UdfVerifyVcb( IrpContext, IrpContext->Vcb );

        //
        //  Call the Fsrtl package to process the request.  We cast the
        //  unicode strings to ansi strings as the dir notify package
        //  only deals with memory matching.
        //

        FsRtlNotifyFullChangeDirectory( IrpContext->Vcb->NotifySync,
                                        &IrpContext->Vcb->DirNotifyList,
                                        Ccb,
                                        (PSTRING) &IrpSp->FileObject->FileName,
                                        BooleanFlagOn( IrpSp->Flags, SL_WATCH_TREE ),
                                        FALSE,
                                        IrpSp->Parameters.NotifyDirectory.CompletionFilter,
                                        Irp,
                                        NULL,
                                        NULL );

    } finally {

        //
        //  Release the Vcb.
        //

        UdfReleaseVcb( IrpContext, IrpContext->Vcb );
    }

    //
    //  Cleanup the IrpContext.
    //

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return STATUS_PENDING;
}


//
//  Local support routine
//

NTSTATUS
UdfInitializeEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN OUT PCCB Ccb,
    IN OUT PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    OUT PBOOLEAN ReturnNextEntry,
    OUT PBOOLEAN ReturnSingleEntry,
    OUT PBOOLEAN InitialQuery
    )

/*++

Routine Description:

    This routine is called to initialize the enumeration variables and structures.
    We look at the state of a previous enumeration from the Ccb as well as any
    input values from the user.  On exit we will position the DirContext at
    a file in the directory and let the caller know whether this entry or the
    next entry should be returned.

Arguments:

    IrpSp - Irp stack location for this request.

    Fcb - Fcb for this directory.

    Ccb - Ccb for the directory handle.

    CompoundDirContext - Context to use for this enumeration.

    ReturnNextEntry - Address to store whether we should return the entry at
        the context position or the next entry.

    ReturnSingleEntry - Address to store whether we should only return
        a single entry.

    InitialQuery - Address to store whether this is the first enumeration
        query on this handle.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PUNICODE_STRING FileName;
    UNICODE_STRING SearchExpression;

    PUNICODE_STRING RestartName = NULL;
    
    ULONG CcbFlags;

    LONGLONG FileIndex;
    ULONG HighFileIndex;
    BOOLEAN KnownIndex;

    BOOLEAN Found;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );
    ASSERT_CCB( Ccb );

    //
    //  If this is the initial query then build a search expression from the input
    //  file name.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_ENUM_INITIALIZED )) {

        FileName = (PUNICODE_STRING) IrpSp->Parameters.QueryDirectory.FileName;

        CcbFlags = 0;

        //
        //  If the filename is not specified or is a single '*' then we will
        //  match all names.
        //

        if ((FileName == NULL) ||
            (FileName->Buffer == NULL) ||
            (FileName->Length == 0) ||
            ((FileName->Length == sizeof( WCHAR )) &&
             (FileName->Buffer[0] == L'*'))) {

            SetFlag( CcbFlags, CCB_FLAG_ENUM_MATCH_ALL );

            SearchExpression.Length =
            SearchExpression.MaximumLength = 0;
            SearchExpression.Buffer = NULL;

        //
        //  Otherwise build the name from the name in the stack location.
        //  This involves checking for wild card characters and upcasing the
        //  string if this is a case-insensitive search.
        //

        } else {

            //
            //  The name better have at least one character.
            //

            if (FileName->Length == 0) {

                UdfRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER );
            }

            //
            //  Check for wildcards in the separate components.
            //

            if (FsRtlDoesNameContainWildCards( FileName)) {

                SetFlag( CcbFlags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD );
            }
            
            //
            //  Now create the search expression to store in the Ccb.
            //

            SearchExpression.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                                FileName->Length,
                                                                TAG_ENUM_EXPRESSION );

            SearchExpression.MaximumLength = FileName->Length;

            //
            //  Either copy the name directly or perform the upcase.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE )) {

                Status = RtlUpcaseUnicodeString( &SearchExpression,
                                                 FileName,
                                                 FALSE );

                //
                //  This should never fail.
                //

                ASSERT( Status == STATUS_SUCCESS );

            } else {

                RtlCopyMemory( SearchExpression.Buffer,
                               FileName->Buffer,
                               FileName->Length );
            }

            SearchExpression.Length = FileName->Length;
        }

        //
        //  But we do not want to return the constant "." and ".." entries for
        //  the root directory, for consistency with the rest of Microsoft's
        //  filesystems.
        //

        if (Fcb == Fcb->Vcb->RootIndexFcb) {

            SetFlag( CcbFlags, CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY );
        }

        //
        //  Now lock the Fcb in order to update the Ccb with the inital
        //  enumeration values.
        //

        UdfLockFcb( IrpContext, Fcb );

        //
        //  Check again that this is the initial search.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ENUM_INITIALIZED )) {

            //
            //  Update the values in the Ccb.
            //

            Ccb->CurrentFileIndex = 0;
            Ccb->SearchExpression = SearchExpression;

            //
            //  Set the appropriate flags in the Ccb.
            //

            SetFlag( Ccb->Flags, CcbFlags | CCB_FLAG_ENUM_INITIALIZED );

        //
        //  Otherwise cleanup any buffer allocated here.
        //

        } else {

            if (!FlagOn( CcbFlags, CCB_FLAG_ENUM_MATCH_ALL )) {

                UdfFreePool( &SearchExpression.Buffer );
            }
        }

    //
    //  Otherwise lock the Fcb so we can read the current enumeration values.
    //

    } else {

        UdfLockFcb( IrpContext, Fcb );
    }

    //
    //  Capture the current state of the enumeration.
    //
    //  If the user specified an index then use his offset.  We always
    //  return the next entry in this case.  If  no name is specified,
    //  then we can't perform the restart.
    //

    if (FlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED ) &&
        IrpSp->Parameters.QueryDirectory.FileName != NULL) {

        KnownIndex = FALSE;
        FileIndex = IrpSp->Parameters.QueryDirectory.FileIndex;
        RestartName = (PUNICODE_STRING) IrpSp->Parameters.QueryDirectory.FileName;
        *ReturnNextEntry = TRUE;

        //
        //  We will use the highest file index reportable to the caller as a
        //  starting point as required if we cannot directly land at the
        //  specified location.
        //
        
        HighFileIndex = Ccb->HighestReturnableFileIndex;

    //
    //  If we are restarting the scan then go from the self entry.
    //

    } else if (FlagOn( IrpSp->Flags, SL_RESTART_SCAN )) {

        KnownIndex = TRUE;
        FileIndex = 0;
        *ReturnNextEntry = FALSE;

    //
    //  Otherwise use the values from the Ccb.
    //

    } else {

        KnownIndex = TRUE;
        FileIndex = Ccb->CurrentFileIndex;
        *ReturnNextEntry = BooleanFlagOn( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
    }

    //
    //  Unlock the Fcb.
    //

    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  We have the starting offset in the directory and whether to return
    //  that entry or the next.  If we are at the beginning of the directory
    //  and are returning that entry, then tell our caller this is the
    //  initial query.
    //

    *InitialQuery = FALSE;

    if ((FileIndex == 0) &&
        !(*ReturnNextEntry)) {

        *InitialQuery = TRUE;
    }

    //
    //  Determine the offset in the stream to position the context and
    //  whether this offset is known to be a file offset.
    //
    //  If this offset is known to be safe then go ahead and position the
    //  context.  This handles the cases where the offset is the beginning
    //  of the stream, the offset is from a previous search or this is the
    //  initial query.
    //

    if (KnownIndex) {

        Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &FileIndex );

        ASSERT( Found );

        //
        //  Avoid a raise in UdfUpdateDirNames if we're re-starting from a CCB index
        //  after the parent entry,  but in a new call to querydirectory (new DirContext)
        //
        
        if (1 <= FileIndex)  {
        
            SetFlag( CompoundDirContext->DirContext.Flags, DIR_CONTEXT_FLAG_SEEN_PARENT );
        }
        
    //
    //  Try to directly jump to the specified file index.  Otherwise we walk through
    //  the directory from the beginning (or the saved highest known offset if that is
    //  useful) until we reach the entry which contains this offset.
    //

    } else {
        
        //
        //  We need to handle the special case of a restart from a synthesized
        //  entry - this is the one time where the restart index can be zero
        //  without requiring us to search above the 2^32 byte mark.
        //
        
        if (UdfFullCompareNames( IrpContext,
                                 RestartName,
                                 &UdfUnicodeDirectoryNames[SELF_ENTRY] ) == EqualTo) {

            FileIndex = UDF_FILE_INDEX_VIRTUAL_SELF;

            Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &FileIndex );
    
            ASSERT( Found );
            
        //
        //  We are restarting from a physical entry.  If the restart index is zero, we were
        //  unable to inform the caller as to the "real" file index due to the dispartity
        //  between the ULONG FileIndex in the return structures and the LONGLONG offsets
        //  possible in directory streams.  In this case, we will go as high as we were able
        //  to inform the caller of and search linearly from that point forward.
        //
        //  It is also possible (realistic? unknown) that the restart index is somewhere in the
        //  middle of an entry and we won't find anything useable.  In this case we try to find
        //  the entry which contains this index, using it as the real restart point.
        //
        
        } else {

            //
            //  See if we need the high water mark.
            //
            
            if (FileIndex == 0) {

                //
                //  We know that this is good.
                //
                
                FileIndex = Max( Ccb->HighestReturnableFileIndex, UDF_FILE_INDEX_PHYSICAL );;
                KnownIndex = TRUE;
            
            }
            
            //
            //  The file index is now useful, falling into two cases
            //
            //      1) KnownIndex == FALSE - searching by index
            //      2) KnownIndex == TRUE  - searching by name
            //
            //  Go set up our inquiry.
            //

            Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &FileIndex );
            
            if (KnownIndex) {
                
                //
                //  Walk forward to discover an entry named per the caller's expectation.
                //
                
                do {
    
                    UdfUpdateDirNames( IrpContext,
                                       &CompoundDirContext->DirContext,
                                       BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
                    
                    if (UdfFullCompareNames( IrpContext,
                                             &CompoundDirContext->DirContext.CaseObjectName,
                                             RestartName ) == EqualTo) {

                        break;
                    }

                    Found = UdfLookupNextFileIndex( IrpContext, Fcb, CompoundDirContext );
    
                } while (Found);
            
            } else if (!Found) {

                LONGLONG LastFileIndex;

                //
                //  Perform the search for the entry by index from the beginning of the physical directory.
                //

                LastFileIndex = UDF_FILE_INDEX_PHYSICAL;

                Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &LastFileIndex );

                ASSERT( Found );

                //
                //  Keep walking through the directory until we run out of
                //  entries or we find an entry which ends beyond the input
                //  index value (index search case) or corresponds to the
                //  name we are looking for (name search case).
                //
    
                do {
    
                    //
                    //  If we have passed the index value then exit.
                    //

                    if (CompoundDirContext->FileIndex.QuadPart > FileIndex) {

                        Found = FALSE;
                        break;
                    }

                    //
                    //  Remember the current position in case we need to go back.
                    //

                    LastFileIndex = CompoundDirContext->FileIndex.QuadPart;

                    //
                    //  Exit if the next entry is beyond the desired index value.
                    //

                    if (LastFileIndex + ISONsrFidSize( CompoundDirContext->DirContext.Fid ) > FileIndex) {

                        break;
                    }
    
                    Found = UdfLookupNextFileIndex( IrpContext, Fcb, CompoundDirContext );
    
                } while (Found);
    
                //
                //  If we didn't find the entry then go back to the last known entry.
                //
    
                if (!Found) {
    
                    UdfCleanupDirContext( IrpContext, &CompoundDirContext->DirContext );
                    UdfInitializeDirContext( IrpContext, &CompoundDirContext->DirContext );
    
                    Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &LastFileIndex );

                    ASSERT( Found );
                }
            }
        }
    }

    //
    //  Only update the dirent name if we will need it for some reason.
    //  Don't update this name if we are returning the next entry, and
    //  don't update it if it was already done.
    //

    if (!(*ReturnNextEntry) &&
        CompoundDirContext->DirContext.PureObjectName.Buffer == NULL) {

        //
        //  If the caller specified an index that corresponds to a
        //  deleted file, they are trying to be tricky. Don't let them.
        //

        if (CompoundDirContext->DirContext.Fid &&
            FlagOn( CompoundDirContext->DirContext.Fid->Flags, NSR_FID_F_DELETED )) {

            return STATUS_INVALID_PARAMETER;
        }
        
        //
        //  Update the names in the dirent.
        //

        UdfUpdateDirNames( IrpContext,
                           &CompoundDirContext->DirContext,
                           BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
    }

    //
    //  Look at the flag in the IrpSp indicating whether to return just
    //  one entry.
    //

    *ReturnSingleEntry = FALSE;

    if (FlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY )) {

        *ReturnSingleEntry = TRUE;
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

BOOLEAN
UdfEnumerateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN OUT PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    IN BOOLEAN ReturnNextEntry
    )

/*++

Routine Description:

    This routine is the worker routine for index enumeration.  We are positioned
    at some dirent in the directory and will either return the first match
    at that point or look to the next entry.  The Ccb contains details about
    the type of matching to do.

Arguments:

    Ccb - Ccb for this directory handle.

    CompoundDirContext - context already positioned at some entry in the directory.

    ReturnNextEntry - Indicates if we are returning this entry or should start
        with the next entry.

Return Value:

    BOOLEAN - TRUE if next entry is found, FALSE otherwise.

--*/

{
    BOOLEAN Found = FALSE;
    PDIR_ENUM_CONTEXT DirContext;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );

    //
    //  Directly reference the directory enumeration context for convenience.
    //

    DirContext = &CompoundDirContext->DirContext;

    //
    //  Loop until we find a match or exaust the directory.
    //

    while (TRUE) {

        //
        //  Move to the next entry unless we want to consider the current
        //  entry.
        //

        if (ReturnNextEntry) {

            if (!UdfLookupNextFileIndex( IrpContext, Ccb->Fcb, CompoundDirContext )) {

                break;
            }
        
            if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_DELETED )) {

                continue;
            }

            UdfUpdateDirNames( IrpContext,
                               DirContext,
                               BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
        } else {

            ReturnNextEntry = TRUE;
        }
            
        //
        //  Don't bother if we have a constant entry and are ignoring them.
        //
        
        if (!FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT ) &&
            FlagOn( Ccb->Flags, CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY )) {

            continue;
        }

        //
        //  If we match all names then return to our caller.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_ENUM_MATCH_ALL )) {

            DirContext->ShortObjectName.Length = 0;
            Found = TRUE;

            break;
        }

        //
        //  Check if the long name matches the search expression.
        //

        if (UdfIsNameInExpression( IrpContext,
                                   &DirContext->CaseObjectName,
                                   &Ccb->SearchExpression,
                                   BooleanFlagOn( Ccb->Flags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD ))) {

            //
            //  Let our caller know we found an entry.
            //

            DirContext->ShortObjectName.Length = 0;
            Found = TRUE;

            break;
        }

        //
        //  The long name didn't match so we need to check for a
        //  possible short name match.  There is no match if the
        //  long name is one of the constant entries or already
        //  is 8dot3.
        //

        if (!(!FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT ) ||
              UdfIs8dot3Name( IrpContext,
                              DirContext->CaseObjectName ))) {

            //
            //  Allocate the shortname if it isn't already done.
            //
            
            if (DirContext->ShortObjectName.Buffer == NULL) {

                DirContext->ShortObjectName.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                                               BYTE_COUNT_8_DOT_3,
                                                                               TAG_SHORT_FILE_NAME );
                DirContext->ShortObjectName.MaximumLength = BYTE_COUNT_8_DOT_3;
            }

            UdfGenerate8dot3Name( IrpContext,
                                  &DirContext->PureObjectName,
                                  &DirContext->ShortObjectName );

            //
            //  Check if this name matches.
            //

            if (UdfIsNameInExpression( IrpContext,
                                       &DirContext->ShortObjectName,
                                       &Ccb->SearchExpression,
                                       BooleanFlagOn( Ccb->Flags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD ))) {
                
                //
                //  Let our caller know we found an entry.
                //

                Found = TRUE;

                break;
            }
        }
    }

    return Found;
}


//
//  Local support routine
//

VOID
UdfLookupFileEntryInEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    )

/*++

Routine Description:

    This routine retrieves the file entry associated with the current location in
    the enumeration of a compound directory context.
  
Arguments:

    Fcb - the directory being enumerated.
    
    CompoundDirContext - a corresponding context for the enumeration.
    
Return Value:

    None.  Status may be raised on discovery of corruption.

--*/

{
    PNSR_FID Fid;
    PICBFILE Fe;
    ULONG Length;

    Fid = CompoundDirContext->DirContext.Fid;

    //
    //  Figure out where the ICB we want is.
    //
    
    if (UdfIsFileIndexVirtual( CompoundDirContext->FileIndex.QuadPart )) {

        //
        //  Synthesize!  We only have to synthesize the self entry.  The name is already done,
        //  so the remaining work is trivial.
        //

        ASSERT( Fid == NULL );

        //
        //  Lift the FE corresponding to this directory
        //

        UdfCleanupIcbContext( IrpContext, &CompoundDirContext->IcbContext );
        
        UdfInitializeIcbContextFromFcb( IrpContext,
                                        &CompoundDirContext->IcbContext,
                                        Fcb );

        Length = Fcb->RootExtentLength;

    } else {

        //
        //  Lift the FE corresponding to this FID.
        //

        ASSERT( Fid != NULL );

        UdfCleanupIcbContext( IrpContext, &CompoundDirContext->IcbContext );

        UdfInitializeIcbContext( IrpContext,
                                 &CompoundDirContext->IcbContext,
                                 Fcb->Vcb,
                                 DESTAG_ID_NSR_FILE,
                                 Fid->Icb.Start.Partition,
                                 Fid->Icb.Start.Lbn,
                                 BlockSize( IrpContext->Vcb) );

        Length = Fid->Icb.Length.Length;
    }

    //
    //  Retrieve the ICB for inspection.
    //
    
    UdfLookupActiveIcb( IrpContext, 
                        &CompoundDirContext->IcbContext,
                        Length);

    Fe = (PICBFILE) CompoundDirContext->IcbContext.Active.View;

    //
    //  Perform some basic verification that the FE is of the proper type and that
    //  FID and FE agree as to the type of the object.  We explicitly check that
    //  a legal filesystem-level FE type is discovered, even though we don't support
    //  them in other paths.  Note that we leave the IcbContext->IcbType as FILE even
    //  though we may have picked up an extended file entry.
    //

    if (((Fe->Destag.Ident != DESTAG_ID_NSR_FILE) &&
         ((Fe->Destag.Ident != DESTAG_ID_NSR_EXT_FILE) || (!UdfExtendedFEAllowed( IrpContext->Vcb)))) ||

        (((Fid && FlagOn( Fid->Flags, NSR_FID_F_DIRECTORY )) ||
          Fid == NULL) &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_DIRECTORY) ||

        (Fe->Icbtag.FileType != ICBTAG_FILE_T_FILE &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_DIRECTORY &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_BLOCK_DEV &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_CHAR_DEV &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_FIFO &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_C_ISSOCK &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_PATHLINK &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_REALTIME)
       )  {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
}


//
//  Local support routine
//

BOOLEAN
UdfLookupInitialFileIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    IN PLONGLONG InitialIndex
    )

/*++

Routine Description:

    This routine begins the enumeration of a directory by setting the context
    at the first avaliable virtual directory entry.
  
Arguments:

    Fcb - the directory being enumerated.
    
    CompoundDirContext - a corresponding context for the enumeration.
    
    InitialIndex - an optional starting file index to base the enumeration.
    
Return Value:

   TRUE will be returned if a valid entry is found at this offset, FALSE otherwise.

--*/

{
    LONGLONG DirOffset;

    if (UdfIsFileIndexVirtual( *InitialIndex )) {

        //
        //  We only synthesize a single virtual directory entry.  Position the context
        //  at the virtual self entry.
        //
        
        CompoundDirContext->FileIndex.QuadPart = UDF_FILE_INDEX_VIRTUAL_SELF;
        
        return TRUE;
    }

    CompoundDirContext->FileIndex.QuadPart = *InitialIndex;

    //
    //  Find the base offset in the directory and look it up.
    //
    
    DirOffset = UdfFileIndexToPhysicalOffset( *InitialIndex );
        
    return UdfLookupInitialDirEntry( IrpContext,
                                     Fcb,
                                     &CompoundDirContext->DirContext,
                                     &DirOffset );
}


//
//  Local support routine
//

BOOLEAN
UdfLookupNextFileIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    )

/*++

Routine Description:

    This routine advances the enumeration of a virtual directory by one entry.

Arguments:

    Fcb - the directory being enumerated.
    
    CompoundDirContext - a corresponding context for the enumeration.

Return Value:

    BOOLEAN True if another Fid is avaliable, False if we are at the end.

--*/

{
    ULONG Advance;
    BOOLEAN Result;

    //
    //  Advance from the synthesized to the physical directory.
    //
    
    if (UdfIsFileIndexVirtual( CompoundDirContext->FileIndex.QuadPart )) {

        Result = UdfLookupInitialDirEntry( IrpContext,
                                           Fcb,
                                           &CompoundDirContext->DirContext,
                                           NULL );
        
        if (Result) {
            
            CompoundDirContext->FileIndex.QuadPart = UDF_FILE_INDEX_PHYSICAL;
        }

        return Result;
    }
    
    Advance = ISONsrFidSize( CompoundDirContext->DirContext.Fid );
    
    //
    //  Advance to the next entry in this directory.
    //
    
    Result = UdfLookupNextDirEntry( IrpContext, Fcb, &CompoundDirContext->DirContext );

    if (Result) {

        CompoundDirContext->FileIndex.QuadPart += Advance;
    }
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\fileinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Udfs called by
    the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     16-Jan-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FILEINFO)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FILEINFO)

//
//  Local macros
//

INLINE
ULONG
UdfGetExtraFileAttributes (
    IN PCCB Ccb
    )

/*++

Routine Description:

    Safely figure out extra name-based file attributes given a context block.

Arguments:

    Ccb - a context block to examine.

Return Value:

    ULONG - file attributes for a file based on how it was opened (seperate from
        those based on the object that was opened).

--*/

{
    return ( Ccb->Lcb != NULL? Ccb->Lcb->FileAttributes : 0 );
}

//
//  Local support routines
//

VOID
UdfQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonQueryInfo)
#pragma alloc_text(PAGE, UdfCommonSetInfo)
#pragma alloc_text(PAGE, UdfFastQueryBasicInfo)
#pragma alloc_text(PAGE, UdfFastQueryStdInfo)
#pragma alloc_text(PAGE, UdfFastQueryNetworkInfo)
#pragma alloc_text(PAGE, UdfQueryAlternateNameInfo)
#pragma alloc_text(PAGE, UdfQueryBasicInfo)
#pragma alloc_text(PAGE, UdfQueryEaInfo)
#pragma alloc_text(PAGE, UdfQueryInternalInfo)
#pragma alloc_text(PAGE, UdfQueryNameInfo)
#pragma alloc_text(PAGE, UdfQueryNetworkInfo)
#pragma alloc_text(PAGE, UdfQueryPositionInfo)
#pragma alloc_text(PAGE, UdfQueryStandardInfo)
#endif


NTSTATUS
UdfCommonQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query file information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for this operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_ALL_INFORMATION Buffer;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN ReleaseFcb = FALSE;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We only support query on file and directory handles.
        //

        switch (TypeOfOpen) {

        case UserDirectoryOpen :
        case UserFileOpen :

            //
            //  Acquire shared access to this file.  NOTE that this could be
            //  a recursive acquire,  if we already preacquired in
            //  UdfAcquireForCreateSection().
            //

            UdfAcquireFileShared( IrpContext, Fcb );
            ReleaseFcb = TRUE;

            ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED ));
            
            //
            //  Make sure the Fcb is in a usable condition.  This will raise
            //  an error condition if the volume is unusable
            //

            UdfVerifyFcbOperation( IrpContext, Fcb );

            //
            //  Based on the information class we'll do different
            //  actions.  Each of hte procedures that we're calling fills
            //  up the output buffer, if possible.  They will raise the
            //  status STATUS_BUFFER_OVERFLOW for an insufficient buffer.
            //  This is considered a somewhat unusual case and is handled
            //  more cleanly with the exception mechanism rather than
            //  testing a return status value for each call.
            //

            switch (FileInformationClass) {

            case FileAllInformation:

                //
                //  We don't allow this operation on a file opened by file Id.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                //  In this case go ahead and call the individual routines to
                //  fill in the buffer.  Only the name routine will
                //  pointer to the output buffer and then call the
                //  individual routines to fill in the buffer.
                //

                Length -= (sizeof( FILE_ACCESS_INFORMATION ) +
                           sizeof( FILE_MODE_INFORMATION ) +
                           sizeof( FILE_ALIGNMENT_INFORMATION ));

                UdfQueryBasicInfo( IrpContext, Fcb, Ccb, &Buffer->BasicInformation, &Length );
                UdfQueryStandardInfo( IrpContext, Fcb, &Buffer->StandardInformation, &Length );
                UdfQueryInternalInfo( IrpContext, Fcb, &Buffer->InternalInformation, &Length );
                UdfQueryEaInfo( IrpContext, Fcb, &Buffer->EaInformation, &Length );
                UdfQueryPositionInfo( IrpContext, IrpSp->FileObject, &Buffer->PositionInformation, &Length );
                Status = UdfQueryNameInfo( IrpContext, IrpSp->FileObject, &Buffer->NameInformation, &Length );

                break;

            case FileBasicInformation:

                UdfQueryBasicInfo( IrpContext, Fcb, Ccb, (PFILE_BASIC_INFORMATION) Buffer, &Length );
                break;

            case FileStandardInformation:

                UdfQueryStandardInfo( IrpContext, Fcb, (PFILE_STANDARD_INFORMATION) Buffer, &Length );
                break;

            case FileInternalInformation:

                UdfQueryInternalInfo( IrpContext, Fcb, (PFILE_INTERNAL_INFORMATION) Buffer, &Length );
                break;

            case FileEaInformation:

                UdfQueryEaInfo( IrpContext, Fcb, (PFILE_EA_INFORMATION) Buffer, &Length );
                break;

            case FilePositionInformation:

                UdfQueryPositionInfo( IrpContext, IrpSp->FileObject, (PFILE_POSITION_INFORMATION) Buffer, &Length );
                break;

            case FileNameInformation:

                //
                //  We don't allow this operation on a file opened by file Id.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = UdfQueryNameInfo( IrpContext, IrpSp->FileObject, (PFILE_NAME_INFORMATION) Buffer, &Length );

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                }

                break;

            case FileAlternateNameInformation:

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = UdfQueryAlternateNameInfo( IrpContext, Fcb, Ccb, (PFILE_NAME_INFORMATION) Buffer, &Length );

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                }

                break;

            case FileNetworkOpenInformation:

                UdfQueryNetworkInfo( IrpContext, Fcb, Ccb, (PFILE_NETWORK_OPEN_INFORMATION) Buffer, &Length );
                break;

            default :

                Status = STATUS_INVALID_PARAMETER;
            }

            break;

        default :

            Status = STATUS_INVALID_PARAMETER;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //  and then complete the request
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

    } finally {

        //
        //  Release the file.
        //

        if (ReleaseFcb) {

            UdfReleaseFile( IrpContext, Fcb );
        }
    }

    //
    //  Complete the request if we didn't raise.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
UdfCommonSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set file information called by both the
    fsd and fsp threads.  We only support operations which set the file position.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for this operation.

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFILE_POSITION_INFORMATION Buffer;

    PAGED_CODE();

    //
    //  Decode the file object
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  We only support a SetPositionInformation on a user file.
    //

    if ((TypeOfOpen != UserFileOpen) ||
        (IrpSp->Parameters.QueryFile.FileInformationClass != FilePositionInformation)) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Acquire shared access to this file.
    //

    UdfAcquireFileShared( IrpContext, Fcb );

    try {

        //
        //  Make sure the Fcb is in a usable condition.  This
        //  will raise an error condition if the fcb is unusable
        //

        UdfVerifyFcbOperation( IrpContext, Fcb );

        Buffer = Irp->AssociatedIrp.SystemBuffer;

        //
        //  Check if the file does not use intermediate buffering.  If it
        //  does not use intermediate buffering then the new position we're
        //  supplied must be aligned properly for the device
        //

        if (FlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            ((Buffer->CurrentByteOffset.LowPart & IrpSp->DeviceObject->AlignmentRequirement) != 0)) {

            try_leave( NOTHING );
        }

        //
        //  The input parameter is fine so set the current byte offset and
        //  complete the request
        //

        //
        //  Lock the Fcb to provide synchronization.
        //

        UdfLockFcb( IrpContext, Fcb );
        IrpSp->FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;
        UdfUnlockFcb( IrpContext, Fcb );

        Status = STATUS_SUCCESS;

    } finally {

        UdfReleaseFile( IrpContext, Fcb );
    }

    //
    //  Complete the request if there was no raise.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


BOOLEAN
UdfFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for basic file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = UdfDecodeFileObject( FileObject, &Fcb, &Ccb );

    //
    //  We only support this request on user file or directory objects.
    //

    ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED ));
    
    if (TypeOfOpen != UserFileOpen && TypeOfOpen != UserDirectoryOpen) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (UdfVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Fill in the input buffer from the Fcb fields.
            //

            Buffer->CreationTime = Fcb->Timestamps.CreationTime;
            Buffer->LastWriteTime =
            Buffer->ChangeTime =  Fcb->Timestamps.ModificationTime;
            Buffer->LastAccessTime = Fcb->Timestamps.AccessTime;

            Buffer->FileAttributes = Fcb->FileAttributes | UdfGetExtraFileAttributes( Ccb );

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_BASIC_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


BOOLEAN
UdfFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    //
    //  We only support this request on initialized user file or directory objects.
    //

    if (TypeOfOpen != UserFileOpen && TypeOfOpen != UserDirectoryOpen) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (UdfVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Check whether this is a directory.
            //

            if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                Buffer->AllocationSize.QuadPart =
                Buffer->EndOfFile.QuadPart = 0;

                Buffer->Directory = TRUE;

            } else {

                Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
                Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;

                Buffer->Directory = FALSE;
            }

            Buffer->NumberOfLinks = Fcb->LinkCount;
            Buffer->DeletePending = FALSE;

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_STANDARD_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


BOOLEAN
UdfFastQueryNetworkInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for network file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = UdfDecodeFileObject( FileObject, &Fcb, &Ccb );

    //
    //  We only support this request on user file or directory objects.
    //

    if (TypeOfOpen != UserFileOpen && TypeOfOpen != UserDirectoryOpen) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (UdfVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Fill in the input buffer from the Fcb fields.
            //

            Buffer->CreationTime = Fcb->Timestamps.CreationTime;
            Buffer->LastWriteTime =
            Buffer->ChangeTime =  Fcb->Timestamps.ModificationTime;
            Buffer->LastAccessTime = Fcb->Timestamps.AccessTime;

            Buffer->FileAttributes = Fcb->FileAttributes | UdfGetExtraFileAttributes( Ccb );

            //
            //  Check whether this is a directory.
            //

            if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                Buffer->AllocationSize.QuadPart =
                Buffer->EndOfFile.QuadPart = 0;

            } else {

                Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
                Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;
            }

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_NETWORK_OPEN_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


//
//  Local support routine
//

VOID
UdfQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

 Description:

    This routine performs the query basic information function for Udfs

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified
    
    Ccb - Supplies the Ccb associated with the fileobject being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We support all times on Udfs.
    //

    Buffer->CreationTime = Fcb->Timestamps.CreationTime;
    Buffer->LastWriteTime =
    Buffer->ChangeTime =  Fcb->Timestamps.ModificationTime;
    Buffer->LastAccessTime = Fcb->Timestamps.AccessTime;

    Buffer->FileAttributes = Fcb->FileAttributes | UdfGetExtraFileAttributes( Ccb );

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
UdfQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length
    )
/*++

Routine Description:

    This routine performs the query standard information function for Udfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Delete is never pending on a readonly file.
    //

    Buffer->NumberOfLinks = Fcb->LinkCount;
    Buffer->DeletePending = FALSE;

    //
    //  We get the sizes from the header.  Return a size of zero
    //  for all directories.
    //

    if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

        Buffer->AllocationSize.QuadPart =
        Buffer->EndOfFile.QuadPart = 0;

        Buffer->Directory = TRUE;

    } else {

        Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;

        Buffer->Directory = FALSE;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
UdfQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information function for Udfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Index number is the file Id number in the Fcb.
    //

    Buffer->IndexNumber = Fcb->FileId;
    *Length -= sizeof( FILE_INTERNAL_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
UdfQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query Ea information function for Udfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  No Ea's on Udfs volumes.  At least not that our EA support would understand.
    //

    Buffer->EaSize = 0;
    *Length -= sizeof( FILE_EA_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
UdfQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query position information function for Udfs.

Arguments:

    FileObject - Supplies the File object being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Get the current position found in the file object.
    //

    Buffer->CurrentByteOffset = FileObject->CurrentByteOffset;

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_POSITION_INFORMATION );

    return;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information function for Udfs.

Arguments:

    FileObject - Supplies the file object containing the name.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_BUFFER_OVERFLOW if the entire name can't be copied.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LengthToCopy;

    PAGED_CODE();

    ASSERT(*Length >= sizeof(ULONG));
    
    //
    //  Simply copy the name in the file object to the user's buffer.
    //

    //
    //  Place the size of the filename in the user's buffer and reduce the remaining
    //  size to match.
    //

    Buffer->FileNameLength = LengthToCopy = FileObject->FileName.Length;
    *Length -= sizeof(ULONG);

    if (LengthToCopy > *Length) {

        LengthToCopy = *Length;
        Status = STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory( Buffer->FileName, FileObject->FileName.Buffer, LengthToCopy );

    //
    //  Reduce the available bytes by the amount stored into this buffer.  In the overflow
    //  case, this simply drops to zero.  The returned filenamelength will indicate to the
    //  caller how much space is required.
    //

    *Length -= LengthToCopy;

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query alternate name information function.
    We lookup the dirent for this file and then check if there is a
    short name.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified.

    Ccb - Ccb for this open handle.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned.

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the whole name would fit into the user buffer,
               STATUS_OBJECT_NAME_NOT_FOUND if we can't return the name,
               STATUS_BUFFER_OVERFLOW otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    DIR_ENUM_CONTEXT DirContext;

    PLCB Lcb;
    
    PFCB ParentFcb;
    BOOLEAN ReleaseParentFcb = FALSE;

    BOOLEAN CleanupDirContext = FALSE;
    BOOLEAN Result;

    PUNICODE_STRING ShortName;

    UNICODE_STRING LocalShortName;
    WCHAR LocalShortNameBuffer[ BYTE_COUNT_8_DOT_3 / sizeof(WCHAR) ];
    
    PAGED_CODE();

    //
    //  Initialize the buffer length to zero.
    //

    Buffer->FileNameLength = 0;

    //
    //  If there was no associated Lcb then there is no short name.
    //

    Lcb = Ccb->Lcb;
    
    if (Lcb == NULL) {

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    //  Use a try-finally to cleanup the structures.
    //

    try {

        if (FlagOn( Lcb->Flags, LCB_FLAG_SHORT_NAME )) {

            //
            //  This caller opened the file by a generated short name, so simply hand it back.
            //

            ShortName = &Lcb->FileName;
        
        } else {

            //
            //  The open occured by a regular name.  Now, if this name is already 8.3 legal then
            //  there is no short name.
            //

            if (UdfIs8dot3Name( IrpContext, Lcb->FileName )) {

                try_leave( Status = STATUS_OBJECT_NAME_NOT_FOUND );
            }

            //
            //  This name has a generated short name.  In order to calculate this name we have to
            //  retrieve the FID for this file, since UDF specifies that a short name is uniquified
            //  with a CRC of the original in-FID byte representation of the filename.
            //
            //  N.B.: if this is a common operation, we may wish to cache the CRC in the Lcb.
            //

            ParentFcb = Lcb->ParentFcb;
            UdfAcquireFileShared( IrpContext, ParentFcb );
            ReleaseParentFcb = TRUE;

            //
            //  Now go find the FID for this filename in the parent.
            //

            UdfInitializeDirContext( IrpContext, &DirContext );
            CleanupDirContext = TRUE;

            Result = UdfFindDirEntry( IrpContext,
                                      ParentFcb,
                                      &Lcb->FileName,
                                      BooleanFlagOn( Lcb->Flags, LCB_FLAG_IGNORE_CASE ),
                                      FALSE,
                                      &DirContext );
            
            //
            //  We should always be able to find this entry, but don't bugcheck because
            //  we messed this up.
            //
            
            ASSERT( Result );
            
            if (!Result) {
                
                try_leave( Status = STATUS_OBJECT_NAME_NOT_FOUND );
            }

            //
            //  Build the local unicode string to use and fill it in.
            //

            ShortName = &LocalShortName;

            LocalShortName.Buffer = LocalShortNameBuffer;
            LocalShortName.Length = 0;
            LocalShortName.MaximumLength = sizeof( LocalShortNameBuffer );

            UdfGenerate8dot3Name( IrpContext,
                                  &DirContext.CaseObjectName,
                                  ShortName );
        }
        
        //
        //  We now have the short name.  We have left it in Unicode form so copy it directly.
        //

        Buffer->FileNameLength = ShortName->Length;

        if (Buffer->FileNameLength + sizeof( ULONG ) > *Length) {

            Buffer->FileNameLength = *Length - sizeof( ULONG );
            Status = STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory( Buffer->FileName, ShortName->Buffer, Buffer->FileNameLength );

    } finally {

        if (CleanupDirContext) {

            UdfCleanupDirContext( IrpContext, &DirContext );
        }

        if (ReleaseParentFcb) {

            UdfReleaseFile( IrpContext, ParentFcb );
        }
    }

    //
    //  Reduce the available bytes by the amount stored into this buffer.
    //

    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

        *Length -= sizeof( ULONG ) + Buffer->FileNameLength;
    }

    return Status;
}


//
//  Local support routine
//

VOID
UdfQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

 Description:

    This routine performs the query network open information function for Udfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We support all times on Udfs.
    //

    Buffer->CreationTime = Fcb->Timestamps.CreationTime;
    Buffer->LastWriteTime =
    Buffer->ChangeTime =  Fcb->Timestamps.ModificationTime;
    Buffer->LastAccessTime = Fcb->Timestamps.AccessTime;

    Buffer->FileAttributes = Fcb->FileAttributes | UdfGetExtraFileAttributes( Ccb );

    //
    //  We get the sizes from the header.  Return a size of zero
    //  for all directories.
    //

    if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

        Buffer->AllocationSize.QuadPart =
        Buffer->EndOfFile.QuadPart = 0;

    } else {

        Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_NETWORK_OPEN_INFORMATION );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\create.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Udfs called by the
    Fsd/Fsp dispatch routines.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     9-October-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_CREATE)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_CREATE)

//
//  Local support routines
//

NTSTATUS
UdfNormalizeFileNames (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OpenByFileId,
    IN BOOLEAN IgnoreCase,
    IN TYPE_OF_OPEN RelatedTypeOfOpen,
    IN PCCB RelatedCcb OPTIONAL,
    IN PUNICODE_STRING RelatedFileName OPTIONAL,
    IN OUT PUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING RemainingName
    );

NTSTATUS
UdfOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB *CurrentFcb,
    IN PLCB OpenLcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN IgnoreCase,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
UdfOpenObjectByFileId (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb
    );

NTSTATUS
UdfOpenObjectFromDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN BOOLEAN ShortNameMatch,                             
    IN BOOLEAN IgnoreCase,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN PerformUserOpen,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
UdfCompleteFcbOpen (
    IN PIRP_CONTEXT IrpContext,
    PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PLCB OpenLcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ULONG UserCcbFlags,
    IN ACCESS_MASK DesiredAccess
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonCreate)
#pragma alloc_text(PAGE, UdfCompleteFcbOpen)
#pragma alloc_text(PAGE, UdfNormalizeFileNames)
#pragma alloc_text(PAGE, UdfOpenObjectByFileId)
#pragma alloc_text(PAGE, UdfOpenExistingFcb)
#pragma alloc_text(PAGE, UdfOpenObjectFromDirContext)
#endif


NTSTATUS
UdfCommonCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for opening a file called by both the
    Fsp and Fsd threads.

    The file can be opened either by name or by file Id either with or without
    a relative name.  The file name field in the file object passed to this routine
    contains either a unicode string or a 64 bit value which is the file Id.
    If there is a related file object with a name then we will already have converted
    that name to Oem. 

    We will store the full name for the file in the file object on a successful
    open.  We will allocate a larger buffer if necessary and combine the
    related and file object names.  The only exception is the relative open
    when the related file object is for an OpenByFileId file.  If we need to
    allocate a buffer for a case insensitive name then we allocate it at
    the tail of the buffer we will store into the file object.  The upcased
    portion will begin immediately after the name defined by the FileName
    in the file object.

    Once we have the full name in the file object we don't want to split the
    name in the event of a retry.  We use a flag in the IrpContext to indicate
    that the name has been split.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - This is the status from this open operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFILE_OBJECT FileObject;

    DIR_ENUM_CONTEXT DirContext;
    BOOLEAN CleanupDirContext = FALSE;

    BOOLEAN FoundEntry;

    PVCB Vcb;

    BOOLEAN OpenByFileId;
    BOOLEAN IgnoreCase;
    ULONG CreateDisposition;

    BOOLEAN ShortNameMatch;

    BOOLEAN VolumeOpen = FALSE;

    //
    //  We will be acquiring and releasing file Fcb's as we move down the
    //  directory tree during opens.  At any time we need to know the deepest
    //  point we have traversed down in the tree in case we need to cleanup
    //  any structures created here.
    //
    //  CurrentFcb - represents this point.  If non-null it means we have
    //      acquired it and need to release it in finally clause.
    //
    //  NextFcb - represents the NextFcb to walk to but haven't acquired yet.
    //
    //  CurrentLcb - represents the name of the CurrentFcb.
    //

    TYPE_OF_OPEN RelatedTypeOfOpen = UnopenedFileObject;
    PFILE_OBJECT RelatedFileObject;
    PCCB RelatedCcb = NULL;

    PFCB NextFcb;
    PFCB CurrentFcb = NULL;

    PLCB CurrentLcb = NULL;

    //
    //  During the open we need to combine the related file object name
    //  with the remaining name.  We also may need to upcase the file name
    //  in order to do a case-insensitive name comparison.  We also need
    //  to restore the name in the file object in the event that we retry
    //  the request.  We use the following string variables to manage the
    //  name.  We will can put these strings into either Unicode or Ansi
    //  form.
    //
    //  FileName - Pointer to name as currently stored in the file
    //      object.  We store the full name into the file object early in
    //      the open operation.
    //
    //  RelatedFileName - Pointer to the name in the related file object.
    //
    //  RemainingName - String containing remaining name to parse.
    //

    PUNICODE_STRING FileName;
    PUNICODE_STRING RelatedFileName;

    UNICODE_STRING RemainingName;
    UNICODE_STRING FinalName;

    PAGED_CODE();

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get create parameters from the Irp.
    //

    OpenByFileId = BooleanFlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID );
    IgnoreCase = !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE );
    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    //
    //  Do some preliminary checks to make sure the operation is supported.
    //  We fail in the following cases immediately.
    //
    //      - Open a paging file.
    //      - Open a target directory.
    //      - Open a file with Eas.
    //      - Create a file.
    //

    if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE | SL_OPEN_TARGET_DIRECTORY) ||
        (IrpSp->Parameters.Create.EaLength != 0) ||
        (CreateDisposition == FILE_CREATE)) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Copy the Vcb to a local.  Assume the starting directory is the root.
    //

    Vcb = IrpContext->Vcb;
    NextFcb = Vcb->RootIndexFcb;

    //
    //  Reference our input parameters to make things easier
    //

    FileObject = IrpSp->FileObject;
    RelatedFileObject = NULL;

    FileName = &FileObject->FileName;

    //
    //  Set up the file object's Vpb pointer in case anything happens.
    //  This will allow us to get a reasonable pop-up.
    //

    if ((FileObject->RelatedFileObject != NULL) && !OpenByFileId) {

        RelatedFileObject = FileObject->RelatedFileObject;
        FileObject->Vpb = RelatedFileObject->Vpb;

        RelatedTypeOfOpen = UdfDecodeFileObject( RelatedFileObject, &NextFcb, &RelatedCcb );

        //
        //  Fail the request if this is not a user file object.
        //

        if (RelatedTypeOfOpen < UserVolumeOpen) {

            UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Remember the name in the related file object.
        //

        RelatedFileName = &RelatedFileObject->FileName;
    }

    //
    //  If we haven't initialized the names then make sure the strings are valid.
    //  If this an OpenByFileId then verify the file id buffer.
    //
    //  After this routine returns we know that the full name is in the
    //  FileName buffer and the buffer will hold the upcased portion
    //  of the name yet to parse immediately after the full name in the
    //  buffer.  Any trailing backslash has been removed and the flag
    //  in the IrpContext will indicate whether we removed the
    //  backslash.
    //

    Status = UdfNormalizeFileNames( IrpContext,
                                    Vcb,
                                    OpenByFileId,
                                    IgnoreCase,
                                    RelatedTypeOfOpen,
                                    RelatedCcb,
                                    RelatedFileName,
                                    FileName,
                                    &RemainingName );

    //
    //  Return the error code if not successful.
    //

    if (!NT_SUCCESS( Status )) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  We want to acquire the Vcb.  Exclusively for a volume open, shared otherwise.
    //  The file name is empty for a volume open.
    //

    if ((FileName->Length == 0) &&
        (RelatedTypeOfOpen <= UserVolumeOpen) &&
        !OpenByFileId) {

        VolumeOpen = TRUE;
        UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    } else {

        UdfAcquireVcbShared( IrpContext, Vcb, FALSE );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify that the Vcb is not in an unusable condition.  This routine
        //  will raise if not usable.
        //

        UdfVerifyVcb( IrpContext, Vcb );

        //
        //  If the Vcb is locked then we cannot open another file
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) {

            try_leave( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If we are opening this file by FileId then process this immediately
        //  and exit.
        //

        if (OpenByFileId) {

            //
            //  The only create disposition we allow is OPEN.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {

                try_leave( Status = STATUS_ACCESS_DENIED );
            }

            try_leave( Status = UdfOpenObjectByFileId( IrpContext,
                                                       IrpSp,
                                                       Vcb,
                                                       &CurrentFcb ));
        }

        //
        //  If we are opening this volume Dasd then process this immediately
        //  and exit.
        //

        if (VolumeOpen) {

            //
            //  The only create disposition we allow is OPEN.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {

                try_leave( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  If they wanted to open a directory, surprise.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                try_leave( Status = STATUS_NOT_A_DIRECTORY );
            }

            //
            //  Acquire the Fcb first.
            //

            CurrentFcb = Vcb->VolumeDasdFcb;
            UdfAcquireFcbExclusive( IrpContext, CurrentFcb, FALSE );

            try_leave( Status = UdfOpenExistingFcb( IrpContext,
                                                    IrpSp,
                                                    &CurrentFcb,
                                                    NULL,
                                                    UserVolumeOpen,
                                                    FALSE,
                                                    NULL ));
        }

        //
        //  Acquire the Fcb at the beginning of our search to keep it from being
        //  deleted beneath us.
        //

        UdfAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
        CurrentFcb = NextFcb;

        //
        //  Do a prefix search if there is more of the name to parse.
        //

        if (RemainingName.Length != 0) {

            //
            //  Do the prefix search to find the longest matching name.
            //

            CurrentLcb = UdfFindPrefix( IrpContext,
                                        &CurrentFcb,
                                        &RemainingName,
                                        IgnoreCase );
        }

        //
        //  At this point CurrentFcb points at the lowest Fcb in the tree for this
        //  file name, CurrentLcb is that name, and RemainingName is the rest of the
        //  name we have to do any directory traversals for.
        //

        //
        //  If the remaining name length is zero then we have found our
        //  target.
        //

        if (RemainingName.Length == 0) {

            //
            //  If this is a file so verify the user didn't want to open
            //  a directory.
            //

            if (SafeNodeType( CurrentFcb ) == UDFS_NTC_FCB_DATA) {

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH ) ||
                    FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                    try_leave( Status = STATUS_NOT_A_DIRECTORY );
                }

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_leave( Status = STATUS_ACCESS_DENIED );
                }

                try_leave( Status = UdfOpenExistingFcb( IrpContext,
                                                         IrpSp,
                                                         &CurrentFcb,
                                                         CurrentLcb,
                                                         UserFileOpen,
                                                         IgnoreCase,
                                                         RelatedCcb ));

            //
            //  This is a directory.  Verify the user didn't want to open
            //  as a file.
            //

            } else if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                try_leave( Status = STATUS_FILE_IS_A_DIRECTORY );

            //
            //  Open the file as a directory.
            //

            } else {

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_leave( Status = STATUS_ACCESS_DENIED );
                }

                try_leave( Status = UdfOpenExistingFcb( IrpContext,
                                                         IrpSp,
                                                         &CurrentFcb,
                                                         CurrentLcb,
                                                         UserDirectoryOpen,
                                                         IgnoreCase,
                                                         RelatedCcb ));
            }
        }

        //
        //  We have more work to do.  We have a starting Fcb which we own shared.
        //  We also have the remaining name to parse.  Walk through the name
        //  component by component looking for the full name.
        //

        //
        //  Our starting Fcb better be a directory.
        //

        if (!FlagOn( CurrentFcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

            try_leave( Status = STATUS_OBJECT_PATH_NOT_FOUND );
        }

        //
        //  If we can't wait then post this request.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

            UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        //
        //  Prepare the enumeration context for use.
        //
        
        UdfInitializeDirContext( IrpContext, &DirContext );
        CleanupDirContext = TRUE;

        while (TRUE) {

            ShortNameMatch = FALSE;

            //
            //  Split off the next component from the name.
            //

            UdfDissectName( IrpContext,
                            &RemainingName,
                            &FinalName );

            //
            //  Go ahead and look this entry up in the directory.
            //

            FoundEntry = UdfFindDirEntry( IrpContext,
                                          CurrentFcb,
                                          &FinalName,
                                          IgnoreCase,
                                          FALSE,
                                          &DirContext );

            //
            //  If we didn't find the entry then check if the current name
            //  is a possible short name.
            //

            if (!FoundEntry && UdfCandidateShortName( IrpContext, &FinalName)) {

                //
                //  If the name looks like it could be a short name, try to find
                //  a matching real directory entry.
                //

                ShortNameMatch =
                FoundEntry = UdfFindDirEntry( IrpContext,
                                              CurrentFcb,
                                              &FinalName,
                                              IgnoreCase,
                                              TRUE,
                                              &DirContext );
            }

            //
            //  If we didn't find a match then check what the caller was trying to do to
            //  determine which error code to return.
            //
    
            if (!FoundEntry) {
    
                if ((CreateDisposition == FILE_OPEN) ||
                    (CreateDisposition == FILE_OVERWRITE)) {
    
                    try_leave( Status = STATUS_OBJECT_NAME_NOT_FOUND );
                }
    
                //
                //  Any other operation return STATUS_ACCESS_DENIED.
                //
    
                try_leave( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  If this is an ignore case open then copy the exact case
            //  in the file object name.
            //

            if (IgnoreCase && !ShortNameMatch) {

                ASSERT( FinalName.Length == DirContext.ObjectName.Length );
                
                RtlCopyMemory( FinalName.Buffer,
                               DirContext.ObjectName.Buffer,
                               DirContext.ObjectName.Length );
            }

            //
            //  If we have found the last component then break out to open for the caller.
            //

            if (RemainingName.Length == 0) {

                break;
            }
            
            //
            //  The object we just found must be a directory.
            //

            if (!FlagOn( DirContext.Fid->Flags, NSR_FID_F_DIRECTORY )) {

                try_leave( Status = STATUS_OBJECT_PATH_NOT_FOUND );
            }

            //
            //  Now open an Fcb for this intermediate index Fcb.
            //

            UdfOpenObjectFromDirContext( IrpContext,
                                         IrpSp,
                                         Vcb,
                                         &CurrentFcb,
                                         ShortNameMatch,
                                         IgnoreCase,
                                         &DirContext,
                                         FALSE,
                                         NULL );
        }
        
        //
        //  Make sure our opener is about to get what they expect.
        //

        if ((FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH ) ||
             FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) &&
            !FlagOn( DirContext.Fid->Flags, NSR_FID_F_DIRECTORY )) {

            try_leave( Status = STATUS_NOT_A_DIRECTORY );
        
        }

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE ) &&
            FlagOn( DirContext.Fid->Flags, NSR_FID_F_DIRECTORY )) {

            try_leave( Status = STATUS_FILE_IS_A_DIRECTORY );
        }

        //
        //  The only create disposition we allow is OPEN.
        //

        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {

            try_leave( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  Open the object for the caller.
        //

        try_leave( Status = UdfOpenObjectFromDirContext( IrpContext,
                                                         IrpSp,
                                                         Vcb,
                                                         &CurrentFcb,
                                                         ShortNameMatch,
                                                         IgnoreCase,
                                                         &DirContext,
                                                         TRUE,
                                                         RelatedCcb ));
    } finally {
        
        //
        //  Cleanup the enumeration context if initialized.
        //

        if (CleanupDirContext) {

            UdfCleanupDirContext( IrpContext, &DirContext );
        }

        //
        //  The result of this open could be success, pending or some error
        //  condition.
        //

        if (AbnormalTermination()) {


            //
            //  In the error path we start by calling our teardown routine if we
            //  have a CurrentFcb.
            //

            if (CurrentFcb != NULL) {

                BOOLEAN RemovedFcb;

                UdfTeardownStructures( IrpContext, CurrentFcb, FALSE, &RemovedFcb );

                if (RemovedFcb) {

                    CurrentFcb = NULL;
                }
            }
            
            //
            //  No need to complete the request.
            //

            IrpContext = NULL;
            Irp = NULL;

        //
        //  If we posted this request through the oplock package we need
        //  to show that there is no reason to complete the request.
        //

        } else if (Status == STATUS_PENDING) {

            IrpContext = NULL;
            Irp = NULL;
        }

        //
        //  Release the Current Fcb if still acquired.
        //

        if (CurrentFcb != NULL) {

            UdfReleaseFcb( IrpContext, CurrentFcb );
        }

        //
        //  Release the Vcb.
        //

        UdfReleaseVcb( IrpContext, Vcb );

        //
        //  Call our completion routine.  It will handle the case where either
        //  the Irp and/or IrpContext are gone.
        //

        UdfCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfNormalizeFileNames (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OpenByFileId,
    IN BOOLEAN IgnoreCase,
    IN TYPE_OF_OPEN RelatedTypeOfOpen,
    IN PCCB RelatedCcb OPTIONAL,
    IN PUNICODE_STRING RelatedFileName OPTIONAL,
    IN OUT PUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine is called to store the full name and upcased name into the
    filename buffer.  We only upcase the portion yet to parse.  We also
    check for a trailing backslash and lead-in double backslashes.  This
    routine also verifies the mode of the related open against the name
    currently in the filename.

Arguments:

    Vcb - Vcb for this volume.

    OpenByFileId - Indicates if the filename should be a 64 bit FileId.

    IgnoreCase - Indicates if this open is a case-insensitive operation.

    RelatedTypeOfOpen - Indicates the type of the related file object.

    RelatedCcb - Ccb for the related open.  Ignored if no relative open.

    RelatedFileName - FileName buffer for related open.  Ignored if no
        relative open.

    FileName - FileName to update in this routine.  The name should
        either be a 64-bit FileId or a Unicode string.

    RemainingName - Name with the remaining portion of the name.  This
        will begin after the related name and any separator.  For a
        non-relative open we also step over the initial separator.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the names are OK, appropriate error code
        otherwise.

--*/

{
    ULONG RemainingNameLength;
    ULONG RelatedNameLength = 0;
    ULONG SeparatorLength = 0;

    ULONG BufferLength;

    UNICODE_STRING NewFileName;

    PAGED_CODE();

    //
    //  If this is the first pass then we need to build the full name and
    //  check for name compatibility.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FULL_NAME )) {

        //
        //  Deal with the regular file name case first.
        //

        if (!OpenByFileId) {

            //
            //  This is here because the Win32 layer can't avoid sending me double
            //  beginning backslashes.
            //

            if ((FileName->Length > sizeof( WCHAR )) &&
                (FileName->Buffer[1] == L'\\') &&
                (FileName->Buffer[0] == L'\\')) {

                //
                //  If there are still two beginning backslashes, the name is bogus.
                //

                if ((FileName->Length > 2 * sizeof( WCHAR )) &&
                    (FileName->Buffer[2] == L'\\')) {

                    return STATUS_OBJECT_NAME_INVALID;
                }

                //
                //  Slide the name down in the buffer.
                //

                FileName->Length -= sizeof( WCHAR );

                RtlMoveMemory( FileName->Buffer,
                               FileName->Buffer + 1,
                               FileName->Length );
            }

            //
            //  Check for a trailing backslash.  Don't strip off if only character
            //  in the full name or for relative opens where this is illegal.
            //

            if (((FileName->Length > sizeof( WCHAR)) ||
                 ((FileName->Length == sizeof( WCHAR )) && (RelatedTypeOfOpen == UserDirectoryOpen))) &&
                (FileName->Buffer[ (FileName->Length/2) - 1 ] == L'\\')) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH );
                FileName->Length -= sizeof( WCHAR );
            }

            //
            //  Remember the length we need for this portion of the name.
            //

            RemainingNameLength = FileName->Length;

            //
            //  If this is a related file object then we verify the compatibility
            //  of the name in the file object with the relative file object.
            //

            if (RelatedTypeOfOpen != UnopenedFileObject) {

                //
                //  If the filename length was zero then it must be legal.
                //  If there are characters then check with the related
                //  type of open.
                //

                if (FileName->Length != 0) {

                    //
                    //  The name length must always be zero for a volume open.
                    //

                    if (RelatedTypeOfOpen <= UserVolumeOpen) {

                        return STATUS_INVALID_PARAMETER;

                    //
                    //  The remaining name cannot begin with a backslash.
                    //

                    } else if (FileName->Buffer[0] == L'\\' ) {

                        return STATUS_INVALID_PARAMETER;

                    //
                    //  If the related file is a user file then there
                    //  is no file with this path.
                    //

                    } else if (RelatedTypeOfOpen == UserFileOpen) {

                        return STATUS_OBJECT_PATH_NOT_FOUND;
                    }
                }

                //
                //  Remember the length of the related name when building
                //  the full name.  We leave the RelatedNameLength and
                //  SeparatorLength at zero if the relative file is opened
                //  by Id.
                //

                if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    //
                    //  Add a separator if the name length is non-zero
                    //  unless the relative Fcb is at the root.
                    //

                    if ((FileName->Length != 0) &&
                        (RelatedCcb->Fcb != Vcb->RootIndexFcb)) {

                        SeparatorLength = sizeof( WCHAR );
                    }

                    RelatedNameLength = RelatedFileName->Length;
                }

            //
            //  The full name is already in the filename.  It must either
            //  be length 0 or begin with a backslash.
            //

            } else if (FileName->Length != 0) {

                if (FileName->Buffer[0] != L'\\') {

                    return STATUS_INVALID_PARAMETER;
                }

                //
                //  We will want to trim the leading backslash from the
                //  remaining name we return.
                //

                RemainingNameLength -= sizeof( WCHAR );
                SeparatorLength = sizeof( WCHAR );
            }

            //
            //  Now see if the buffer is large enough to hold the full name.
            //

            BufferLength = RelatedNameLength + SeparatorLength + RemainingNameLength;

            //
            //  Check for an overflow of the maximum filename size.
            //
            
            if (BufferLength > MAXUSHORT) {

                return STATUS_INVALID_PARAMETER;
            }

            //
            //  Now see if we need to allocate a new buffer.
            //

            if (FileName->MaximumLength < BufferLength) {

                NewFileName.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                               BufferLength,
                                                               TAG_FILE_NAME );

                NewFileName.MaximumLength = (USHORT) BufferLength;

            } else {

                NewFileName.Buffer = FileName->Buffer;
                NewFileName.MaximumLength = FileName->MaximumLength;
            }

            //
            //  If there is a related name then we need to slide the remaining bytes up and
            //  insert the related name.  Otherwise the name is in the correct position
            //  already.
            //

            if (RelatedNameLength != 0) {

                //
                //  Store the remaining name in its correct position.
                //

                if (RemainingNameLength != 0) {

                    RtlMoveMemory( Add2Ptr( NewFileName.Buffer, RelatedNameLength + SeparatorLength, PVOID ),
                                   FileName->Buffer,
                                   RemainingNameLength );
                }

                RtlCopyMemory( NewFileName.Buffer,
                               RelatedFileName->Buffer,
                               RelatedNameLength );

                //
                //  Add the separator if needed.
                //

                if (SeparatorLength != 0) {

                    *(Add2Ptr( NewFileName.Buffer, RelatedNameLength, PWCHAR )) = L'\\';
                }

                //
                //  Update the filename value we got from the user.
                //

                if (NewFileName.Buffer != FileName->Buffer) {

                    if (FileName->Buffer != NULL) {

                        ExFreePool( FileName->Buffer );
                    }

                    FileName->Buffer = NewFileName.Buffer;
                    FileName->MaximumLength = NewFileName.MaximumLength;
                }

                //
                //  Copy the name length to the user's filename.
                //

                FileName->Length = (USHORT) (RelatedNameLength + SeparatorLength + RemainingNameLength);
            }

            //
            //  Now update the remaining name to parse.
            //

            RemainingName->MaximumLength =
            RemainingName->Length = (USHORT) RemainingNameLength;

            RemainingName->Buffer = Add2Ptr( FileName->Buffer,
                                             RelatedNameLength + SeparatorLength,
                                             PWCHAR );

            //
            //  Upcase the name if necessary.
            //

            if (IgnoreCase && (RemainingNameLength != 0)) {

                UdfUpcaseName( IrpContext,
                               RemainingName,
                               RemainingName );
            }

            //
            //  Do a quick check to make sure there are no wildcards.
            //

            if (FsRtlDoesNameContainWildCards( RemainingName )) {

                return STATUS_OBJECT_NAME_INVALID;
            }

        //
        //  For the open by file Id case we verify the name really contains
        //  a 64 bit value.
        //

        } else {

            //
            //  Check for validity of the buffer.
            //

            if (FileName->Length != sizeof( FILE_ID )) {

                return STATUS_INVALID_PARAMETER;
            }
        }

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FULL_NAME );

    //
    //  If we are in the retry path then the full name is already in the
    //  file object name.  If this is a case-sensitive operation then
    //  we need to upcase the name from the end of any related file name already stored
    //  there.
    //

    } else {

        //
        //  Assume there is no relative name.
        //

        *RemainingName = *FileName;

        //
        //  Nothing to do if the name length is zero.
        //

        if (RemainingName->Length != 0) {

            //
            //  If there is a relative name then we need to walk past it.
            //

            if (RelatedTypeOfOpen != UnopenedFileObject) {

                //
                //  Nothing to walk past if the RelatedCcb is opened by FileId.
                //


                if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    //
                    //  Related file name is a proper prefix of the full name.
                    //  We step over the related name and if we are then
                    //  pointing at a separator character we step over that.
                    //

                    RemainingName->Buffer = Add2Ptr( RemainingName->Buffer,
                                                     RelatedFileName->Length,
                                                     PWCHAR );

                    RemainingName->Length -= RelatedFileName->Length;
                }
            }

            //
            //  If we are pointing at a separator character then step past that.
            //

            if (RemainingName->Length != 0) {

                if (*(RemainingName->Buffer) == L'\\') {

                    RemainingName->Buffer = Add2Ptr( RemainingName->Buffer,
                                                     sizeof( WCHAR ),
                                                     PWCHAR );

                    RemainingName->Length -= sizeof( WCHAR );
                }
            }
        }

        //
        //  Upcase the name if necessary.
        //

        if (IgnoreCase && (RemainingName->Length != 0)) {

            UdfUpcaseName( IrpContext,
                           RemainingName,
                           RemainingName );
        }
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfOpenObjectByFileId (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb
    )

/*++

Routine Description:

    This routine is called to open a file by the FileId.  The file Id is in
    the FileObject name buffer and has been verified to be 64 bits.

    We extract the Id number and then check to see whether we are opening a
    file or directory and compare that with the create options.  If this
    generates no error then optimistically look up the Fcb in the Fcb Table.

    If we don't find the Fcb then we take what is effectively a wild-a** guess.
    Since we would need more than 64bits to contain the root extent length along
    with the partition, lbn and dir/file flag we have to speculate that the
    opener knows what they are doing and try to crack an ICB hierarchy at the
    specified location.  This can fail for any number of reasons, which then have
    to be mapped to an open failure.
    
    If found then build the Fcb from this entry and store the new Fcb in the
    tree.

    Finally we call our worker routine to complete the open on this Fcb.

Arguments:

    IrpSp - Stack location within the create Irp.

    Vcb - Vcb for this volume.

    CurrentFcb - Address to store the Fcb for this open.  We only store the
        CurrentFcb here when we have acquired it so our caller knows to
        free or deallocate it.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_ACCESS_DENIED;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN Found;
    BOOLEAN FcbExisted;

    ICB_SEARCH_CONTEXT IcbContext;
    BOOLEAN CleanupIcbContext = FALSE;

    NODE_TYPE_CODE NodeTypeCode;
    TYPE_OF_OPEN TypeOfOpen;

    FILE_ID FileId;

    PFCB NextFcb = NULL;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    //
    //  Extract the FileId from the FileObject.
    //

    RtlCopyMemory( &FileId, IrpSp->FileObject->FileName.Buffer, sizeof( FILE_ID ));

    //
    //  Now do a quick check that the reserved, unused chunk of the fileid is
    //  unused in this specimen.
    //

    if (UdfGetFidReservedZero( FileId )) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Go ahead and figure out the TypeOfOpen and NodeType.  We can
    //  get these from the input FileId.
    //

    if (UdfIsFidDirectory( FileId )) {

        TypeOfOpen = UserDirectoryOpen;
        NodeTypeCode = UDFS_NTC_FCB_INDEX;

    } else {

        TypeOfOpen = UserFileOpen;
        NodeTypeCode = UDFS_NTC_FCB_DATA;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the Vcb and check if there is already an Fcb.
        //  If not we will need to carefully hunt for the on-disc
        //  structures.
        //
        //  We will post the request if we don't find the Fcb and this
        //  request can't wait.
        //

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        NextFcb = UdfCreateFcb( IrpContext, FileId, NodeTypeCode, &FcbExisted );

        //
        //  Now, if the Fcb was not already here we have some work to do.
        //
        
        if (!FcbExisted) {

            //
            //  If we can't wait then post this request.
            //
    
            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {
    
                UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }
    
            //
            //  Use a try-finally to transform errors we get as a result of going
            //  off on a wild goose chase into a simple open failure.
            //
            
            try {

                NextFcb->FileId = FileId;
                
                UdfInitializeIcbContextFromFcb( IrpContext, &IcbContext, NextFcb );
                CleanupIcbContext = TRUE;
    
                UdfLookupActiveIcb( IrpContext, 
                                    &IcbContext, 
                                    NextFcb->RootExtentLength);
                
                UdfInitializeFcbFromIcbContext( IrpContext,
                                                NextFcb,
                                                &IcbContext,
                                                NULL);
    
                UdfCleanupIcbContext( IrpContext, &IcbContext );
                CleanupIcbContext = FALSE;

            } except( UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

                //
                //   Any error we receive is an indication that the given fileid is
                //   not valid.
                //

                Status = STATUS_INVALID_PARAMETER;
            }

            //
            //  Do a little dance to leave the exception handler if we had problems.
            //
            
            if (Status == STATUS_INVALID_PARAMETER) {

                try_leave( NOTHING );
            }
        }
        
        //
        //  We have the Fcb.  Check that the type of the file is compatible with
        //  the desired type of file to open.
        //

        if (FlagOn( NextFcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                try_leave( Status = STATUS_FILE_IS_A_DIRECTORY );
            }

        } else if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

            try_leave( Status = STATUS_NOT_A_DIRECTORY );
        }

        //
        //  We now know the Fcb and currently hold the Vcb lock.
        //  Try to acquire this Fcb without waiting.  Otherwise we
        //  need to reference it, drop the Vcb, acquire the Fcb, the
        //  Vcb and then dereference the Fcb.
        //

        if (!UdfAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;
            UdfUnlockVcb( IrpContext, Vcb );

            UdfAcquireFcbExclusive( IrpContext, NextFcb, FALSE );

            UdfLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
        }

        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        //
        //  Move to this Fcb.
        //

        *CurrentFcb = NextFcb;

        //
        //  Check the requested access on this Fcb.
        //

        if (!UdfIllegalFcbAccess( IrpContext,
                                  TypeOfOpen,
                                  IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

            //
            //  Call our worker routine to complete the open.
            //

            Status = UdfCompleteFcbOpen( IrpContext,
                                         IrpSp,
                                         Vcb,
                                         CurrentFcb,
                                         NULL,
                                         TypeOfOpen,
                                         CCB_FLAG_OPEN_BY_ID,
                                         IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
        }

    } finally {

        if (UnlockVcb) {

            UdfUnlockVcb( IrpContext, Vcb );
        }

        if (CleanupIcbContext) {

            UdfCleanupIcbContext( IrpContext, &IcbContext );
        }
        
        //
        //  Destroy the new Fcb if it was not fully initialized.
        //

        if (NextFcb && !FlagOn( NextFcb->FcbState, FCB_STATE_INITIALIZED )) {

            UdfDeleteFcb( IrpContext, NextFcb );
        }

    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB *CurrentFcb,
    IN PLCB OpenLcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN IgnoreCase,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open an Fcb which is already in the Fcb table.
    We will verify the access to the file and then call our worker routine
    to perform the final operations.

Arguments:

    IrpSp - Pointer to the stack location for this open.

    CurrentFcb - Address of Fcb to open.  We will clear this if the Fcb
        is released here.
        
    OpenLcb - Lcb used to find this Fcb.

    TypeOfOpen - Indicates whether we are opening a file, directory or volume.

    IgnoreCase - Indicates if this open is case-insensitive.

    RelatedCcb - Ccb for related file object if relative open.  We use
        this when setting the Ccb flags for this open.  It will tell
        us whether the name currently in the file object is relative or
        absolute.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;

    NTSTATUS Status = STATUS_ACCESS_DENIED;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_EXCLUSIVE_FCB( *CurrentFcb );
    ASSERT_OPTIONAL_CCB( RelatedCcb );

    //
    //  Check that the desired access is legal.
    //

    if (!UdfIllegalFcbAccess( IrpContext,
                              TypeOfOpen,
                              IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        //
        //  Set the Ignore case.
        //

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Check the related Ccb to see if this was an OpenByFileId and
        //  whether there was a version.
        //

        if (ARGUMENT_PRESENT( RelatedCcb )) {

            if (FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

                SetFlag( CcbFlags, CCB_FLAG_OPEN_RELATIVE_BY_ID );
            }
        }

        //
        //  Call our worker routine to complete the open.
        //

        Status = UdfCompleteFcbOpen( IrpContext,
                                     IrpSp,
                                     (*CurrentFcb)->Vcb,
                                     CurrentFcb,
                                     OpenLcb,
                                     TypeOfOpen,
                                     CcbFlags,
                                     IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfOpenObjectFromDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN BOOLEAN ShortNameMatch,                             
    IN BOOLEAN IgnoreCase,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN PerformUserOpen,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open an object found in a directory scan.  This
    can be a directory or a file as indicated in the scan's results.

    We first check that the desired access is legal for this file.  Then we
    construct the FileId for this and do a check to see if it is the Fcb
    Table.  It is always possible that either it was created since or simply
    wasn't in the prefix table at the time of the prefix table search.
    Lookup the active ICB, initialize the Fcb and store into the FcbTable
    if not present.

    Next we will add this to the prefix table of our parent if needed.

    Once we know that the new Fcb has been initialized then we move our pointer
    in the tree down to this position.

    This routine does not own the Vcb lock on entry.  We must be sure to release
    it on exit.

Arguments:

    IrpSp - Stack location for this request.

    Vcb - Vcb for the current volume.

    CurrentFcb - On input this is the parent of the Fcb to open.  On output we
        store the Fcb for the file being opened.
        
    ShortNameMatch - Indicates whether this object was opened by the shortname.

    IgnoreCase - Indicates the case sensitivity of the caller.

    DirContext - This is the context used to find the object.
    
    PerformUserOpen - Indicates if we are at the object the user wants to finally open.

    RelatedCcb - RelatedCcb for relative file object used to make this open.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;
    FILE_ID FileId;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN FcbExisted;

    PFCB NextFcb = NULL;
    PFCB ParentFcb = NULL;

    TYPE_OF_OPEN TypeOfOpen;
    NODE_TYPE_CODE NodeTypeCode;

    ICB_SEARCH_CONTEXT IcbContext;
    BOOLEAN CleanupIcbContext = FALSE;

    PLCB OpenLcb;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Figure out what kind of open we will be performing here.  The caller has already insured
    //  that the user is expecting us to do this.
    //

    if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_DIRECTORY )) {

        TypeOfOpen = UserDirectoryOpen;
        NodeTypeCode = UDFS_NTC_FCB_INDEX;
    
    } else {
        
        TypeOfOpen = UserFileOpen;
        NodeTypeCode = UDFS_NTC_FCB_DATA;
    }

    //
    //  Check for illegal access to this file.
    //

    if (PerformUserOpen &&
        UdfIllegalFcbAccess( IrpContext,
                             TypeOfOpen,
                             IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        return STATUS_ACCESS_DENIED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Check the related Ccb to see if this was an OpenByFileId.
        //

        if (ARGUMENT_PRESENT( RelatedCcb ) &&
            FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

            SetFlag( CcbFlags, CCB_FLAG_OPEN_RELATIVE_BY_ID );
        }

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Build the file Id for this object.
        //
        
        UdfSetFidFromLbAddr( FileId, DirContext->Fid->Icb.Start );

        if (TypeOfOpen == UserDirectoryOpen) {

            UdfSetFidDirectory( FileId );
        }

        //
        //  Lock the Vcb so we can examine the Fcb Table.
        //

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        //
        //  Get the Fcb for this file.
        //

        NextFcb = UdfCreateFcb( IrpContext, FileId, NodeTypeCode, &FcbExisted );

        //
        //  If the Fcb was created here then initialize from the values in the
        //  dirent.  We have optimistically assumed that there isn't any corrupt
        //  information to this point - we're about to discover it if there is.
        //

        if (!FcbExisted) {

            //
            //  Set the root extent length and go get the active ICB, initialize.
            //

            NextFcb->RootExtentLength = DirContext->Fid->Icb.Length.Length;

            UdfInitializeIcbContextFromFcb( IrpContext, &IcbContext, NextFcb );
            CleanupIcbContext = TRUE;

            UdfLookupActiveIcb( IrpContext, 
                                &IcbContext, 
                                NextFcb->RootExtentLength );
            
            UdfInitializeFcbFromIcbContext( IrpContext,
                                            NextFcb,
                                            &IcbContext,
                                            *CurrentFcb);

            UdfCleanupIcbContext( IrpContext, &IcbContext );
            CleanupIcbContext = FALSE;

        }

        //
        //  Now try to acquire the new Fcb without waiting.  We will reference
        //  the Fcb and retry with wait if unsuccessful.
        //

        if (!UdfAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;

            UdfUnlockVcb( IrpContext, Vcb );

            UdfReleaseFcb( IrpContext, *CurrentFcb );
            UdfAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
            UdfAcquireFcbExclusive( IrpContext, *CurrentFcb, FALSE );

            UdfLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
        }

        //
        //  Move down to this new Fcb.  Remember that we still own the parent however.
        //

        ParentFcb = *CurrentFcb;
        *CurrentFcb = NextFcb;

        //
        //  Store this name into the prefix table for the parent.
        //

        OpenLcb = UdfInsertPrefix( IrpContext,
                                   NextFcb,
                                   ( ShortNameMatch?
                                     &DirContext->ShortObjectName :
                                     &DirContext->CaseObjectName ),
                                   ShortNameMatch,
                                   IgnoreCase,
                                   ParentFcb );

        //
        //  Now increment the reference counts for the parent and drop the Vcb.
        //

        DebugTrace(( +1, Dbg,
                     "UdfOpenObjectFromDirContext, PFcb %08x Vcb %d/%d Fcb %d/%d\n", ParentFcb,
                     Vcb->VcbReference,
                     Vcb->VcbUserReference,
                     ParentFcb->FcbReference,
                     ParentFcb->FcbUserReference ));

        UdfIncrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );
        
        DebugTrace(( -1, Dbg, 
                     "UdfOpenObjectFromDirContext, Vcb %d/%d Fcb %d/%d\n",
                     Vcb->VcbReference,
                     Vcb->VcbUserReference,
                     ParentFcb->FcbReference,
                     ParentFcb->FcbUserReference ));

        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        //
        //  Perform initialization associated with the directory context.
        //
            
        UdfInitializeLcbFromDirContext( IrpContext,
                                        OpenLcb,
                                        DirContext );

        //
        //  If we just opened VIDEO_TS directory,  on a UDF1.02 file system,
        //  then mark the Fcb to allow the >=1Gb single AD workaround
        //  to be used on it's children (works around some corrupt DVD-Videos)
        //

        if ((NextFcb->NodeTypeCode == UDFS_NTC_FCB_INDEX) &&
            (ParentFcb == Vcb->RootIndexFcb) &&
            (Vcb->UdfRevision == UDF_VERSION_102) &&
            (OpenLcb->FileName.Length == 16) &&
            (!_wcsnicmp( OpenLcb->FileName.Buffer, L"VIDEO_TS", 8)))  {

            DebugTrace(( 0, Dbg, "Enabled >= 1gig AD workaround\n"));
            
            SetFlag( NextFcb->FcbState, FCB_STATE_ALLOW_ONEGIG_WORKAROUND);
        }
        
        //
        //  Release the parent Fcb at this point.
        //

        UdfReleaseFcb( IrpContext, ParentFcb );
        ParentFcb = NULL;

        //
        //  Call our worker routine to complete the open.
        //

        if (PerformUserOpen) {

            Status = UdfCompleteFcbOpen( IrpContext,
                                         IrpSp,
                                         Vcb,
                                         CurrentFcb,
                                         OpenLcb,
                                         TypeOfOpen,
                                         CcbFlags,
                                         IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
        }

    } finally {

        //
        //  Unlock the Vcb if held.
        //

        if (UnlockVcb) {

            UdfUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Release the parent if held.
        //

        if (ParentFcb != NULL) {

            UdfReleaseFcb( IrpContext, ParentFcb );
        }

        //
        //  Destroy the new Fcb if it was not fully initialized.
        //

        if (NextFcb && !FlagOn( NextFcb->FcbState, FCB_STATE_INITIALIZED )) {

            UdfDeleteFcb( IrpContext, NextFcb );
        }

        //
        //  Clean up the Icb context if used.
        //

        if (CleanupIcbContext) {

            UdfCleanupIcbContext( IrpContext, &IcbContext );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfCompleteFcbOpen (
    IN PIRP_CONTEXT IrpContext,
    PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PLCB OpenLcb OPTIONAL,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ULONG UserCcbFlags,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This is the worker routine which takes an existing Fcb and completes
    the open.  We will do any necessary oplock checks and sharing checks.
    Finally we will create the Ccb and update the file object and any
    file object flags.

Arguments:

    IrpSp - Stack location for the current request.

    Vcb - Vcb for the current volume.

    CurrentFcb - Address of pointer to Fcb to open.  We clear this field if
        we release the resource for this file.
        
    OpenLcb - Lcb this Fcb is being opened by

    TypeOfOpen - Type of open for this request.

    UserCcbFlags - Flags to OR into the Ccb flags.

    DesiredAccess - Desired access for this open.

Return Value:

    NTSTATUS - STATUS_SUCCESS if we complete this request, STATUS_PENDING if
        the oplock package takes the Irp or SHARING_VIOLATION if there is a
        sharing check conflict.

--*/

{
    NTSTATUS Status;
    NTSTATUS OplockStatus = STATUS_SUCCESS;
    ULONG Information = FILE_OPENED;

    BOOLEAN LockVolume = FALSE;

    PFCB Fcb = *CurrentFcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Expand maximum allowed to something sensible for share access checking
    //

    if (MAXIMUM_ALLOWED == DesiredAccess)  {
    
        DesiredAccess = FILE_ALL_ACCESS & ~((TypeOfOpen != UserVolumeOpen ?
                                             (FILE_WRITE_ATTRIBUTES           |
                                              FILE_WRITE_DATA                 |
                                              FILE_WRITE_EA                   |
                                              FILE_ADD_FILE                   |                     
                                              FILE_ADD_SUBDIRECTORY           |
                                              FILE_APPEND_DATA) : 0)          |
                                            FILE_DELETE_CHILD                 |
                                            DELETE                            |
                                            WRITE_DAC );
    }

    //
    //  If this a volume open and the user wants to lock the volume then
    //  purge and lock the volume.
    //

    if ((TypeOfOpen <= UserVolumeOpen) &&
        !FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ )) {

        //
        //  If there are open handles then fail this immediately.
        //

        if (Vcb->VcbCleanup != 0) {

            return STATUS_SHARING_VIOLATION;
        }

        //
        //  If we can't wait then force this to be posted.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

            UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        LockVolume = TRUE;

        //
        //  Purge the volume and make sure all of the user references
        //  are gone.
        //

        Status = UdfPurgeVolume( IrpContext, Vcb, FALSE );

        if (Status != STATUS_SUCCESS) {

            return Status;
        }

        //
        //  Now force all of the delayed close operations to go away.
        //

        UdfFspClose( Vcb );

        if (Vcb->VcbUserReference > Vcb->VcbResidualUserReference) {

            return STATUS_SHARING_VIOLATION;
        }
    }
    
    //
    //  If the Fcb already existed then we need to check the oplocks and
    //  the share access.
    //

    if (Fcb->FcbCleanup != 0) {

        //
        //  If this is a user file open then check whether there are any
        //  batch oplock.
        //

        if (TypeOfOpen == UserFileOpen) {

            //
            //  Store the address of the Fcb for a possible teardown into
            //  the IrpContext.  We will release this in the call to
            //  prepost the Irp.
            //

            IrpContext->TeardownFcb = CurrentFcb;

            if (FsRtlCurrentBatchOplock( &Fcb->Oplock )) {

                //
                //  We remember if a batch oplock break is underway for the
                //  case where the sharing check fails.
                //

                Information = FILE_OPBATCH_BREAK_UNDERWAY;

                OplockStatus = FsRtlCheckOplock( &Fcb->Oplock,
                                                 IrpContext->Irp,
                                                 IrpContext,
                                                 UdfOplockComplete,
                                                 UdfPrePostIrp );

                if (OplockStatus == STATUS_PENDING) {

                    return STATUS_PENDING;
                }
            }

            //
            //  Check the share access before breaking any exclusive oplocks.
            //

            Status = IoCheckShareAccess( DesiredAccess,
                                         IrpSp->Parameters.Create.ShareAccess,
                                         IrpSp->FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE );

            if (!NT_SUCCESS( Status )) {

                return Status;
            }

            //
            //  Now check that we can continue based on the oplock state of the
            //  file.
            //

            OplockStatus = FsRtlCheckOplock( &Fcb->Oplock,
                                             IrpContext->Irp,
                                             IrpContext,
                                             UdfOplockComplete,
                                             UdfPrePostIrp );

            if (OplockStatus == STATUS_PENDING) {

                return STATUS_PENDING;
            }

            IrpContext->TeardownFcb = NULL;

        //
        //  Otherwise just do the sharing check.
        //

        } else {

            Status = IoCheckShareAccess( DesiredAccess,
                                         IrpSp->Parameters.Create.ShareAccess,
                                         IrpSp->FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE );

            if (!NT_SUCCESS( Status )) {

                return Status;
            }
        }
    }

    //
    //  Create the Ccb now.
    //

    Ccb = UdfCreateCcb( IrpContext, Fcb, OpenLcb, UserCcbFlags );

    //
    //  Update the share access.
    //

    if (Fcb->FcbCleanup == 0) {

        IoSetShareAccess( DesiredAccess,
                          IrpSp->Parameters.Create.ShareAccess,
                          IrpSp->FileObject,
                          &Fcb->ShareAccess );

    } else {

        IoUpdateShareAccess( IrpSp->FileObject, &Fcb->ShareAccess );
    }

    //
    //  Set the file object type.
    //

    UdfSetFileObject( IrpContext, IrpSp->FileObject, TypeOfOpen, Fcb, Ccb );

    //
    //  Set the appropriate cache flags for a user file object.
    //

    if (TypeOfOpen == UserFileOpen) {

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_INTERMEDIATE_BUFFERING )) {

            SetFlag( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );

        } else {

            SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
        }
    }
    else if (TypeOfOpen == UserVolumeOpen)  {

        //
        //  DASD access is always noncached
        //
        
        SetFlag( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );
    }
    
    //
    //  Update the open and cleanup counts.  Check the fast io state here.
    //

    UdfLockVcb( IrpContext, Vcb );

    UdfIncrementCleanupCounts( IrpContext, Fcb );
    
    DebugTrace(( +1, Dbg,
                 "UdfCompleteFcbOpen, Fcb %08x Vcb %d/%d Fcb %d/%d\n", Fcb,
                 Vcb->VcbReference,
                 Vcb->VcbUserReference,
                 Fcb->FcbReference,
                 Fcb->FcbUserReference ));

    UdfIncrementReferenceCounts( IrpContext, Fcb, 1, 1 );
    
    DebugTrace(( -1, Dbg,
                 "UdfCompleteFcbOpen, Vcb %d/%d Fcb %d/%d\n",
                 Vcb->VcbReference,
                 Vcb->VcbUserReference,
                 Fcb->FcbReference,
                 Fcb->FcbUserReference ));

    if (LockVolume) {

        Vcb->VolumeLockFileObject = IrpSp->FileObject;
        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
    }

    UdfUnlockVcb( IrpContext, Vcb );

    UdfLockFcb( IrpContext, Fcb );

    if (TypeOfOpen == UserFileOpen) {

        Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );

    } else {

        Fcb->IsFastIoPossible = FastIoIsNotPossible;
    }

    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  Show that we opened the file.
    //

    IrpContext->Irp->IoStatus.Information = Information;

    //
    //  Point to the section object pointer in the non-paged Fcb.
    //

    IrpSp->FileObject->SectionObjectPointer = &Fcb->FcbNonpaged->SegmentObject;
    return OplockStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\flush.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Flush.c

Abstract:

    This module implements device flush functionality for UDF.

// @@BEGIN_DDKSPLIT

Author:

    Tom Jolly   [08-15-2000]

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FLUSH)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FLUSH)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfHijackIrpAndFlushDevice)
#endif

//
//  Local support routine
//

NTSTATUS
UdfHijackCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Set the event so that our call will wake up.
    //

    KeSetEvent( (PKEVENT)Contxt, 0, FALSE );

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
UdfHijackIrpAndFlushDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine is called when we need to send a flush to a device but
    we don't have a flush Irp.  What this routine does is make a copy
    of its current Irp stack location, but changes the Irp Major code
    to a IRP_MJ_FLUSH_BUFFERS amd then send it down, but cut it off at
    the knees in the completion routine, fix it up and return to the
    user as if nothing had happened.

Arguments:

    Irp - The Irp to hijack

    TargetDeviceObject - The device to send the request to.

Return Value:

    NTSTATUS - The Status from the flush in case anybody cares.

--*/

{
    KEVENT Event;
    NTSTATUS Status;
    PIO_STACK_LOCATION NextIrpSp;

    PAGED_CODE();

    //
    //  Get the next stack location, and copy over the stack location
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    *NextIrpSp = *IoGetCurrentIrpStackLocation( Irp );

    NextIrpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    NextIrpSp->MinorFunction = 0;

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    IoSetCompletionRoutine( Irp,
                            UdfHijackCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( TargetDeviceObject, Irp );

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );

        Status = Irp->IoStatus.Status;
    }

    //
    //  If the driver doesn't support flushes, return SUCCESS.
    //

    if (Status == STATUS_INVALID_DEVICE_REQUEST) {
        Status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\iso13346.h ===
/***    ISO13346.H - ISO 13346 File System Disk Format
 *
 *      Microsoft Confidential
 *      Copyright (c) 1996-2000 Microsoft Corporation
 *      All Rights Reserved
 *
 *      This file defines the ISO 13346 Data Structures.
 *
 *      The UDF file system uses these data structures to interpret the
 *      media's contents.
 *
 */

//
//  All 13346 structures are aligned on natural boundaries even though it will
//  not be obvious to the compiler.  Disable compiler smarts for the duration
//  of the ISO definitions.
//
//  As an example, the LONGAD definition is {ULONG {ULONG USHORT} UCHAR[6]} and
//  normal packing will pad out the internal NSRLBA, nevermind that the UCHAR
//  reserved field is doing exactly that.
//

#pragma pack(1)

/***    ISO 13346 Part 1: General
 *
 *
 */

/***    charspec - Character Set Specification (1/7.2.1)
 *
 */

typedef struct  CHARSPEC {
    UCHAR       Type;                   // Character Set Type (CHARSPEC_T_...)
    UCHAR       Info[63];               // Character Set Information
} CHARSPEC, *PCHARSPEC;

//  CHARSPEC_T_... - Values for charspec_Type Character Set Types (1/7.2.1.1)

#define CHARSPEC_T_CS0  0               // By Agreement
#define CHARSPEC_T_CS1  1               // Unicode (according to ISO 2022)
#define CHARSPEC_T_CS2  2               // 38 Glyphs
#define CHARSPEC_T_CS3  3               // 65 Glyphs
#define CHARSPEC_T_CS4  4               // 95 Glyphs
#define CHARSPEC_T_CS5  5               // 191 Glyphs
#define CHARSPEC_T_CS6  6               // Unicode or ISO 2022
#define CHARSPEC_T_CS7  7               // Unicode or ISO 2022
#define CHARSPEC_T_CS8  8               // 53 Glyphs

/***    timestamp - Timestamp Structure (1/7.3)
 *
 */

typedef struct  TIMESTAMP {
    SHORT       Zone:12;                // Time Zone (+-1440 minutes from CUT)
    USHORT      Type:4;                 // Timestamp Type (TIMESTAMP_T_...)
    USHORT      Year;                   // Year (1..9999)
    UCHAR       Month;                  // Month (1..12)
    UCHAR       Day;                    // Day (1..31)
    UCHAR       Hour;                   // Hour (0..23)
    UCHAR       Minute;                 // Minute (0..59)
    UCHAR       Second;                 // Second (0..59)
    UCHAR       CentiSecond;            // Centiseconds (0..99)
    UCHAR       Usec100;                // Hundreds of microseconds (0..99)
    UCHAR       Usec;                   // microseconds (0..99)
} TIMESTAMP, *PTIMESTAMP;

//  TIMESTAMP_T_... - Values for timestamp_Type (1/7.3.1)

#define TIMESTAMP_T_CUT         0       // Coordinated Universal Time
#define TIMESTAMP_T_LOCAL       1       // Local Time
#define TIMESTAMP_T_AGREEMENT   2       // Time format by agreement

//  TIMESTAMP_Z_... Values for timestamp_Zone

#define TIMESTAMP_Z_MIN         (-1440) // Minimum timezone offset (minutes)
#define TIMESTAMP_Z_MAX         ( 1440) // Maximum timezone offset (minutes)
#define TIMESTAMP_Z_NONE        (-2047) // No timezone in timestamp_Zone


/****   regid - Entity Identifier (1/7.4)
 *
 */

typedef struct  REGID {
    UCHAR       Flags;                  // Flags (REGID_F_...)
    UCHAR       Identifier[23];         // Identifier
    UCHAR       Suffix[8];              // Identifier Suffix
} REGID, *PREGID;

//  REGID_F_... - Definitions for regid_Flags bits

#define REGID_F_DIRTY           (0x01)  // Information Modified
#define REGID_F_PROTECTED       (0x02)  // Changes Locked Out

//  REGID_LENGTH_... - regid field lengths

#define REGID_LENGTH_IDENT      23      // Length of regid_Identifier (bytes)
#define REGID_LENGTH_SUFFIX     8       // Length of regid_Suffix (bytes)

//  REGID_ID_... - Values for regid_Identifier[0]

#define REGID_ID_ISO13346       (0x2B)  // regid_Identifier within ISO 13346
#define REGID_ID_NOTREGISTERED  (0x2D)  // regid_Identifier is not registered


/***    Various Structures from Parts 3 and 4 moved here for compilation.
 *
 */


/***    extentad - Extent Address Descriptor (3/7.1)
 *
 */

typedef struct  EXTENTAD {
    ULONG       Len;                    // Extent Length in Bytes
    ULONG       Lsn;                    // Extent Logical Sector Number
} EXTENTAD, *PEXTENTAD;


/***    nsr_lba - Logical Block Address (4/7.1) (lb_addr)
 *
 */

typedef struct  NSRLBA {
    ULONG       Lbn;                    // Logical Block Number
    USHORT      Partition;              // Partition Reference Number
} NSRLBA, *PNSRLBA;


/***    nsr_length - Format of a NSR allocation descriptor length field (4/14.14.1.1)
 *
 *
 */

typedef struct NSRLENGTH {
    ULONG       Length:30;
    ULONG       Type:2;
} NSRLENGTH, *PNSRLENGTH;

#define NSRLENGTH_TYPE_RECORDED         0
#define NSRLENGTH_TYPE_UNRECORDED       1
#define NSRLENGTH_TYPE_UNALLOCATED      2
#define NSRLENGTH_TYPE_CONTINUATION     3


/***    Short Allocation Descriptor (4/14.14.1)
 *
 *      Note that a SHORTAD precisely overlaps a LONGAD.  Use this by defining
 *      a generic allocation descriptor structure.
 */

typedef struct  SHORTAD {
    NSRLENGTH   Length;                 // Extent Length
    ULONG       Start;                  // Extent Logical Block Number
} SHORTAD, *PSHORTAD;

typedef SHORTAD AD_GENERIC, *PAD_GENERIC;


/***    Long Allocation Descriptor (4/14.14.2)
 *
 */

typedef struct  LONGAD {
    NSRLENGTH   Length;                 // Extent Length
    NSRLBA      Start;                  // Extent Location
    UCHAR       ImpUse[6];              // Implementation Use
} LONGAD, *PLONGAD;


/***    Extended Allocation Descriptor (4/14.14.3)
 *
 */

typedef struct  EXTAD {
    NSRLENGTH   ExtentLen;              // Extent Length
    NSRLENGTH   RecordedLen;            // Recorded Length
    ULONG       InfoLen;                // Information Length
    NSRLBA      Start;                  // Extent Location
    UCHAR       ImpUse[2];              // Implementation Use
} EXTAD, *PEXTAD;

/***    ISO 13346 Part 2: Volume and Boot Block Recognition
 *
 *
 */


/***    vsd_generic - Generic Volume Structure Descriptor (2/9.1)
 *
 */

typedef struct  VSD_GENERIC {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_GENERIC, *PVSD_GENERIC;

//  VSD_LENGTH_... - vsd field lengths

#define VSD_LENGTH_IDENT        5       // Length of regid_Identifier (bytes)

//  VSD_IDENT_... - Values for vsd_generic_Ident

#define VSD_IDENT_BEA01     "BEA01"     // Begin Extended Area
#define VSD_IDENT_TEA01     "TEA01"     // Terminate Extended Area
#define VSD_IDENT_CDROM     "CDROM"     // High Sierra Group (pre-ISO 9660)
#define VSD_IDENT_CD001     "CD001"     // ISO 9660
#define VSD_IDENT_CDW01     "CDW01"     // ECMA 168
#define VSD_IDENT_CDW02     "CDW02"     // ISO 13490
#define VSD_IDENT_NSR01     "NSR01"     // ECMA 167
#define VSD_IDENT_NSR02     "NSR02"     // ISO 13346
#define VSD_IDENT_BOOT2     "BOOT2"     // Boot Descriptor
#define VSD_IDENT_NSR03     "NSR03"     // ECMA 167 3rd Edition

typedef enum _VSD_IDENT {
    VsdIdentBad = 0,
    VsdIdentBEA01,
    VsdIdentTEA01,
    VsdIdentCDROM,
    VsdIdentCD001,
    VsdIdentCDW01,
    VsdIdentCDW02,
    VsdIdentNSR01,
    VsdIdentNSR02,
    VsdIdentBOOT2,
    VsdIdentNSR03
} VSD_IDENT, *PVSD_IDENT;

/***    vsd_bea01 - Begin Extended Area Descriptor (2/9.2)
 *
 */

typedef struct  VSD_BEA01 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('BEA01')
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_BEA01, *PVSD_BEA01;


/***    vsd_tea01 - Terminate Extended Area Descriptor (2/9.3)
 *
 */

typedef struct  VSD_TEA01 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('TEA01')
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_TEA01, *PVSD_TEA01;


/***    vsd_boot2 - Boot Descriptor (2/9.4)
 *
 */

typedef struct  VSD_BOOT2 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('BOOT2')
    UCHAR       Version;                // Standard Version
    UCHAR       Res8;                   // Reserved Zero
    REGID       Architecture;           // Architecture Type
    REGID       BootIdent;              // Boot Identifier
    ULONG       BootExt;                // Boot Extent Start
    ULONG       BootExtLen;             // Boot Extent Length
    ULONG       LoadAddr[2];            // Load Address
    ULONG       StartAddr[2];           // Start Address
    TIMESTAMP   Timestamp;              // Creation Time
    USHORT      Flags;                  // Flags (VSD_BOOT2_F_...)
    UCHAR       Res110[32];             // Reserved Zeros
    UCHAR       BootUse[1906];          // Boot Use
} VSD_BOOT2, *PVSD_BOOT2;

//  VSD_BOOT2_F_... - Definitions for vsd_boot2_Flags bits

#define VSD_BOOT2_F_ERASE   (0x0001)    // Ignore previous similar BOOT2 vsds

//
//  Aligning this byte offset to a sector boundary by rounding up will
//  yield the starting offset of the Volume Recognition Area (2/8.3)
//

#define VRA_BOUNDARY_LOCATION (32767 + 1)

/***    ISO 13346 Part 3: Volume Structure
 *
 *
 */

/***    destag - Descriptor Tag (3/7.1 and 4/7.2)
 *
 *      destag_Checksum = Byte sum of bytes 0-3 and 5-15 of destag.
 *
 *      destag_CRC = CRC (X**16 + X**12 + X**5 + 1)
 *
 */

typedef struct  DESTAG {
    USHORT      Ident;                  // Tag Identifier
    USHORT      Version;                // Descriptor Version
    UCHAR       Checksum;               // Tag Checksum
    UCHAR       Res5;                   // Reserved
    USHORT      Serial;                 // Tag Serial Number
    USHORT      CRC;                    // Descriptor CRC
    USHORT      CRCLen;                 // Descriptor CRC Length
    ULONG       Lbn;                    // Tag Location (Logical Block Number)
} DESTAG, *PDESTAG;

//  DESTAG_ID_... - Values for destag_Ident
//  Descriptor Tag Values from NSR Part 3 (3/7.2.1)

#define DESTAG_ID_NOTSPEC           0   // Format Not Specified
#define DESTAG_ID_NSR_PVD           1   // (3/10.1) Primary Volume Descriptor
#define DESTAG_ID_NSR_ANCHOR        2   // (3/10.2) Anchor Volume Desc Pointer
#define DESTAG_ID_NSR_VDP           3   // (3/10.3) Volume Descriptor Pointer
#define DESTAG_ID_NSR_IMPUSE        4   // (3/10.4) Implementation Use Vol Desc
#define DESTAG_ID_NSR_PART          5   // (3/10.5) Partition Descriptor
#define DESTAG_ID_NSR_LVOL          6   // (3/10.6) Logical Volume Descriptor
#define DESTAG_ID_NSR_UASD          7   // (3/10.8) Unallocated Space Desc
#define DESTAG_ID_NSR_TERM          8   // (3/10.9) Terminating Descriptor
#define DESTAG_ID_NSR_LVINTEG       9   // (3/10.10) Logical Vol Integrity Desc

#define DESTAG_ID_MINIMUM_PART3     1   // The lowest legal DESTAG in Part 3
#define DESTAG_ID_MAXIMUM_PART3     9   // The highest legal DESTAG in Part 3

//  DESTAG_ID_... - Values for destag_Ident, continued...
//  Descriptor Tag Values from NSR Part 4 (4/7.2.1)

#define DESTAG_ID_NSR_FSD           256 // (4/14.1) File Set Descriptor
#define DESTAG_ID_NSR_FID           257 // (4/14.4) File Identifier Descriptor
#define DESTAG_ID_NSR_ALLOC         258 // (4/14.5) Allocation Extent Desc
#define DESTAG_ID_NSR_ICBIND        259 // (4/14.7) ICB Indirect Entry
#define DESTAG_ID_NSR_ICBTRM        260 // (4/14.8) ICB Terminal Entry
#define DESTAG_ID_NSR_FILE          261 // (4/14.9) File Entry
#define DESTAG_ID_NSR_EA            262 // (4/14.10) Extended Attribute Header
#define DESTAG_ID_NSR_UASE          263 // (4/14.11) Unallocated Space Entry
#define DESTAG_ID_NSR_SBP           264 // (4/14.12) Space Bitmap Descriptor
#define DESTAG_ID_NSR_PINTEG        265 // (4/14.13) Partition Integrity
#define DESTAG_ID_NSR_EXT_FILE      266 // (4/14.17) Extended File Entry (ECMA167r3+)

#define DESTAG_ID_MINIMUM_PART4         256 // The lowest legal DESTAG in Part 4
#define DESTAG_ID_MAXIMUM_PART4         265 // The highest legal DESTAG in Part 4 (NSR02)
#define DESTAG_ID_MAXIMUM_PART4_NSR03   266 // The highest legal DESTAG in Part 4 (NSR03)

//  DESTAG_VER_... - Values for destag_Version (3/7.2.2)

#define DESTAG_VER_NSR02          2   // Current Descriptor Tag Version
#define DESTAG_VER_NSR03          3   // Current Descriptor Tag Version

//  DESTAG_SERIAL_... - Values for destag_Serial (3/7.2.5)

#define DESTAG_SERIAL_NONE          0   // No Serial Number specified


/***    Anchor Points (3/8.4.2.1)
 *
 */

#define ANCHOR_SECTOR   256


/***    vsd_nsr02 - NSR02/3 Volume Structure Descriptor (3/9.1)
 *
 */

typedef struct  VSD_NSR02 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('NSR02' or 'NSR03')
    UCHAR       Version;                // Standard Version
    UCHAR       Res7;                   // Reserved 0 Byte
    UCHAR       Data[2040];             // Structure Data
} VSD_NSR02, *PVSD_NSR02;


//  Values for vsd_nsr02_Type

#define VSD_NSR02_TYPE_0        0       // Reserved 0

//  Values for vsd_nsr02_Version

#define VSD_NSR02_VER           1       // Standard Version 1


/***    nsr_vd_generic - Generic Volume Descriptor of 512 bytes
 *
 */

typedef struct  NSR_VD_GENERIC {
    DESTAG      Destag;                 // Descriptor Tag
    ULONG       Sequence;               // Volume Descriptor Sequence Number
    UCHAR       Data20[492];            // Descriptor Data
} NSR_VD_GENERIC, *PNSR_VD_GENERIC;


/***    nsr_pvd - NSR Primary Volume Descriptor (3/10.1)
 *
 *      nsr_pvd_destag.destag_Ident = DESTAG_ID_NSR_PVD
 *
 */

typedef struct  NSR_PVD {
    DESTAG      Destag;                 // Descriptor Tag (NSR_PVD)
    ULONG       VolDescSeqNum;          // Volume Descriptor Sequence Number
    ULONG       Number;                 // Primary Volume Descriptor Number
    UCHAR       VolumeID[32];           // Volume Identifier
    USHORT      VolSetSeq;              // Volume Set Sequence Number
    USHORT      VolSetSeqMax;           // Maximum Volume Set Sequence Number
    USHORT      Level;                  // Interchange Level
    USHORT      LevelMax;               // Maximum Interchange Level
    ULONG       CharSetList;            // Character Set List (See 1/7.2.11)
    ULONG       CharSetListMax;         // Maximum Character Set List
    UCHAR       VolSetID[128];          // Volume Set Identifier
    CHARSPEC    CharsetDesc;            // Descriptor Character Set
    CHARSPEC    CharsetExplan;          // Explanatory Character Set
    EXTENTAD    Abstract;               // Volume Abstract Location
    EXTENTAD    Copyright;              // Volume Copyright Notice Location
    REGID       Application;            // Application Identifier
    TIMESTAMP   RecordTime;             // Recording Time
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[64];             // Implementation Use
    ULONG       Predecessor;            // Predecessor Vol Desc Seq Location
    USHORT      Flags;                  // Flags
    UCHAR       Res490[22];             // Reserved Zeros
} NSR_PVD, *PNSR_PVD;

//  NSRPVD_F_... - Definitions for nsr_pvd_Flags

#define NSRPVD_F_COMMON_VOLID   (0x0001)// Volume ID is common across Vol Set


/***    nsr_anchor - Anchor Volume Descriptor Pointer (3/10.2)
 *
 *      nsr_anchor_destag.destag_Ident = DESTAG_ID_NSR_ANCHOR
 *
 */

typedef struct  NSR_ANCHOR {
    DESTAG      Destag;                 // Descriptor Tag (NSR_ANCHOR)
    EXTENTAD    Main;                   // Main Vol Desc Sequence Location
    EXTENTAD    Reserve;                // Reserve Vol Desc Sequence Location
    UCHAR       Res32[480];             // Reserved Zeros
} NSR_ANCHOR, *PNSR_ANCHOR;


/***    nsr_vdp - Volume Descriptor Pointer (3/10.3)
 *
 *      nsr_vdp_destag.destag_Ident = DESTAG_ID_NSR_VDP
 *
 */

typedef struct  NSR_VDP {
    DESTAG      Destag;                 // Descriptor Tag (NSR_VDP)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    EXTENTAD    Next;                   // Next Vol Desc Sequence Location
    UCHAR       Res28[484];             // Reserved Zeros
} NSR_VDP, *PNSR_VDP;


/***    nsr_impuse - Implementation Use Volume Descriptor (3/10.4)
 *
 *      nsr_impuse_destag.destag_Ident = DESTAG_ID_NSR_IMPUSE
 *
 */

typedef struct  NSR_IMPUSE {
    DESTAG      Destag;                 // Descriptor Tag (NSR_IMPUSE)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[460];            // Implementation Use
} NSR_IMPUSE, *PNSR_IMPUSE;


/***    nsr_part - Partition Descriptor (3/10.5)
 *
 *      nsr_part_destag.destag_Ident = DESTAG_ID_NSR_PART
 *
 */

typedef struct  NSR_PART {
    DESTAG      Destag;                 // Descriptor Tag (NSR_PART)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    USHORT      Flags;                  // Partition Flags (NSR_PART_F_...)
    USHORT      Number;                 // Partition Number
    REGID       ContentsID;             // Partition Contents ID
    UCHAR       ContentsUse[128];       // Partition Contents Use
    ULONG       AccessType;             // Access Type
    ULONG       Start;                  // Partition Starting Location
    ULONG       Length;                 // Partition Length (sector count)
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[128];            // Implementation Use
    UCHAR       Res356[156];            // Reserved Zeros
} NSR_PART, *PNSR_PART;


//  NSR_PART_F_... - Definitions for nsr_part_Flags

#define NSR_PART_F_ALLOCATION   (0x0001)    // Volume Space Allocated

//  Values for nsr_part_ContentsID.regid_Identifier

#define NSR_PART_CONTID_FDC01   "+FDC01"    // ISO 9293-1987
#define NSR_PART_CONTID_CD001   "+CD001"    // ISO 9660
#define NSR_PART_CONTID_CDW01   "+CDW01"    // ECMA 168
#define NSR_PART_CONTID_CDW02   "+CDW02"    // ISO 13490
#define NSR_PART_CONTID_NSR01   "+NSR01"    // ECMA 167
#define NSR_PART_CONTID_NSR02   "+NSR02"    // ISO 13346
#define NSR_PART_CONTID_NSR03   "+NSR03"    // ECMA 167 r3

typedef enum NSR_PART_CONTID {
    NsrPartContIdBad = 0,
    NsrPartContIdFDC01,
    NsrPartContIdCD001,
    NsrPartContIdCDW01,
    NsrPartContIdCDW02,
    NsrPartContIdNSR01,
    NsrPartContIdNSR02,
    NsrPartContIdNSR03    
} NSR_PART_CONTID, *PNSR_PART_CONTID;

//  Values for nsr_part_AccessType

#define NSR_PART_ACCESS_NOSPEC  0       // Partition Access Unspecified
#define NSR_PART_ACCESS_RO      1       // Read Only Access
#define NSR_PART_ACCESS_WO      2       // Write-Once Access
#define NSR_PART_ACCESS_RW_PRE  3       // Read/Write with preparation
#define NSR_PART_ACCESS_RW_OVER 4       // Read/Write, fully overwritable


/***    nsr_lvol - Logical Volume Descriptor (3/10.6)
 *
 *      nsr_lvol_destag.destag_Ident = DESTAG_ID_NSR_LVOL
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      File Set Descriptor Sequence (FSD) address.  See (4/3.1).
 *
 */

typedef struct  NSR_LVOL {
    DESTAG      Destag;                 // Descriptor Tag (NSR_LVOL)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    CHARSPEC    Charset;                // Descriptor Character Set
    UCHAR       VolumeID[128];          // Logical Volume ID
    ULONG       BlockSize;              // Logical Block Size (in bytes)
    REGID       DomainID;               // Domain Identifier
    LONGAD      FSD;                    // Logical Volume Contents Use
    ULONG       MapTableLength;         // Map Table Length (bytes)
    ULONG       MapTableCount;          // Map Table Partition Maps Count
    REGID       ImpUseID;               // Implementaion Identifier
    UCHAR       ImpUse[128];            // Implementation Use
    EXTENTAD    Integrity;              // Integrity Sequence Extent
    UCHAR       MapTable[0];            // Partition Map Table (variant!)

//  The true length of this structure may vary!

} NSR_LVOL, *PNSR_LVOL;

#define ISONsrLvolConstantSize (FIELD_OFFSET( NSR_LVOL, MapTable ))
#define ISONsrLvolSize( L ) (QuadAlign( ISONsrLvolConstantSize + (L)->MapTableLength ))

/***    partmap_generic - Generic Partition Map (3/10.7.1)
 *
 */

typedef struct  PARTMAP_GENERIC {
    UCHAR       Type;                   // Partition Map Type
    UCHAR       Length;                 // Partition Map Length
    UCHAR       Map[0];                 // Partion Mapping (variant!)

//  The true length of this structure may vary!

} PARTMAP_GENERIC, *PPARTMAP_GENERIC;

//  Values for partmap_g_Type

#define PARTMAP_TYPE_NOTSPEC        0   // Partition Map Format Not Specified
#define PARTMAP_TYPE_PHYSICAL       1   // Partition Map in Volume Set (Type 1)
#define PARTMAP_TYPE_PROXY          2   // Partition Map by identifier (Type 2)


/***    partmap_physical - Normal (Type 1) Partition Map (3/10.7.2)
 *
 *      A Normal Partion Map specifies a partition number on a volume
 *      within the same volume set.
 *
 */

typedef struct  PARTMAP_PHYSICAL {
    UCHAR       Type;                   // Partition Map Type = 1
    UCHAR       Length;                 // Partition Map Length = 6
    USHORT      VolSetSeq;              // Partition Volume Set Sequence Number
    USHORT      Partition;              // Partition Number
} PARTMAP_PHYSICAL, *PPARTMAP_PHYSICAL;


/***    partmap_proxy - Proxy (Type 2) Partition Map (3/10.7.3)
 *
 *      A Proxy Partition Map is commonly not interchangeable.
 *
 */

typedef struct  PARTMAP_PROXY {
    UCHAR       Type;                   // Partition Map Type = 2
    UCHAR       Length;                 // Partition Map Length = 64
    UCHAR       PartID[62];             // Partition Identifier (Proxy)
} PARTMAP_PROXY, *PPARTMAP_PROXY;


/***    nsr_uasd - Unallocated Space Descriptor (3/10.8)
 *
 *      nsr_uasd_destag.destag_Ident = DESTAG_ID_NSR_UASD
 *
 *      The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8), and
 *      the last logical sector of nsr_uasd_Extents is zero padded.
 *
 */

typedef struct  NSR_UASD {
    DESTAG      Destag;                 // Descriptor Tag (NSR_UASD)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    ULONG       ExtentCount;            // Number of Allocation Descriptors
    EXTENTAD    Extents[0];             // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8) bytes.
//  The last logical sector of nsr_uasd_Extents is zero padded.

} NSR_UASD, *PNSR_UASD;


/***    nsr_term - Terminating Descriptor (3/10.9 and 4/14.2)
 *
 *      nsr_term_destag.destag_Ident = DESTAG_ID_NSR_TERM
 *
 */

typedef struct  NSR_TERM {
    DESTAG      Destag;                 // Descriptor Tag (NSR_TERM)
    UCHAR       Res16[496];             // Reserved Zeros
} NSR_TERM, *PNSR_TERM;


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      This descriptor is found in the Logical Volume Content Use
 *      field of a Logical Volume Integrity Descriptor.
 *
 *      This definition is moved to here to avoid forward reference.
 */

typedef struct  NSR_LVHD {
    ULONG       UniqueID[2];            // Unique ID
    UCHAR       Res8[24];               // Reserved Zeros
} NSR_LVHD, *PNSR_LVHD;


/***    nsr_integ - Logical Volume Integrity Descriptor (3/10.10)
 *
 *      nsr_integ_destag.destag_Ident = DESTAG_ID_NSR_LVINTEG
 *
 *      WARNING: WARNING: WARNING: nsr_integ is a multi-variant structure!
 *
 *      The starting address of nsr_integ_Size is not acurrate.
 *      Compensate for this nsr_integ_Size problem by adding the value of
 *      (nsr_integ_PartitionCount-1) to the ULONG ARRAY INDEX.
 *
 *      The starting address of nsr_integ_ImpUse[0] is not accurate.
 *      Compensate for this nsr_integ_ImpUse problem by adding the value of
 *      ((nsr_integ_PartitionCount-1)<<3) to the UCHAR ARRAY INDEX.
 *
 *      This descriptor is padded with zero bytes to the end of the last
 *      logical sector it occupies.
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      Logical Volume Header Descriptor.  See (4/3.1) second last point.
 */

typedef struct  NSR_INTEG {
    DESTAG      Destag;                 // Descriptor Tag (NSR_LVINTEG)
    TIMESTAMP   Time;                   // Recording Date
    ULONG       Type;                   // Integrity Type (INTEG_T_...)
    EXTENTAD    Next;                   // Next Integrity Extent
    NSR_LVHD    LVHD;                   // Logical Volume Contents Use
    ULONG       PartitionCount;         // Number of Partitions
    ULONG       ImpUseLength;           // Length of Implementation Use
    ULONG       Free[1];                // Free Space Table

//  nsr_integ_Free has a variant length = (4*nsr_integ_PartitionCount)

    ULONG       Size[1];                // Size Table

//  nsr_integ_Size has a variant starting offset due to nsr_integ_Free
//  nsr_integ_Size has a variant length = (4*nsr_integ_PartitionCount)

    UCHAR       ImpUse[0];              // Implementation Use

//  nsr_integ_ImpUse has a variant starting offset due to nsr_integ_Free and
//  nsr_integ_Size.
//  nsr_integ_ImpUse has a variant length = (nsr_integ_ImpUseLength)

} NSR_INTEG, *PNSR_INTEG;

// Values for nsr_integ_Type

#define NSR_INTEG_T_OPEN        0           // Open Integrity Descriptor
#define NSR_INTEG_T_CLOSE       1           // Close Integrity Descriptor


/***    ISO 13346 Part 4: File Structure
 *
 *      See DESTAG structure in Part 3 for definitions found in (4/7.2).
 *
 */


/***    nsr_fsd - File Set Descriptor (4/14.1)
 *
 *      nsr_fsd_destag.destag_Ident = DESTAG_ID_NSR_FSD
 */

typedef struct  NSR_FSD {
    DESTAG      Destag;                     // Descriptor Tag (NSR_LVOL)
    TIMESTAMP   Time;                       // Recording Time
    USHORT      Level;                      // Interchange Level
    USHORT      LevelMax;                   // Maximum Interchange Level
    ULONG       CharSetList;                // Character Set List (See 1/7.2.11)
    ULONG       CharSetListMax;             // Maximum Character Set List
    ULONG       FileSet;                    // File Set Number
    ULONG       FileSetDesc;                // File Set Descriptor Number
    CHARSPEC    CharspecVolID;              // Volume ID Character Set
    UCHAR       VolID[128];                 // Volume ID
    CHARSPEC    CharspecFileSet;            // File Set Character Set
    UCHAR       FileSetID[32];              // File Set ID
    UCHAR       Copyright[32];              // Copyright File Name
    UCHAR       Abstract[32];               // Abstract File Name
    LONGAD      IcbRoot;                    // Root Directory ICB Address
    REGID       DomainID;                   // Domain Identifier
    LONGAD      NextExtent;                 // Next FSD Extent
    
    LONGAD      StreamDirectoryICB;         // >= UDF 2.00 only.  System stream dir.
                                            // These bytes must be zero on discs 
                                            // comforming to earlier revisions.
    
    UCHAR       Res464[32];                 // Reserved Zeros
} NSR_FSD, *PNSR_FSD;


/***    nsr_part_h - Partition Header Descriptor (4/14.3)
 *
 *      No Descriptor Tag.
 *
 *      This descriptor is found in the nsr_part_ContentsUse field of
 *      an NSR02 Partition Descriptor.  See NSR_PART_CONTID_NSR02.
 *
 */

typedef struct  NSR_PART_H {
    SHORTAD     UASTable;                   // Unallocated Space Table
    SHORTAD     UASBitmap;                  // Unallocated Space Bitmap
    SHORTAD     IntegTable;                 // Integrity Table
    SHORTAD     FreedTable;                 // Freed Space Table
    SHORTAD     FreedBitmap;                // Freed Space Bitmap
    UCHAR       Res40[88];                  // Reserved Zeros
} NSR_PART_H, *PNSR_PART_H;


/***    nsr_fid - File Identifier Descriptor (4/14.4)
 *
 *      nsr_fid_destag.destag_Ident = DESTAG_ID_NSR_FID
 *
 *      WARNING: WARNING: WARNING: nsr_fid is a multi-variant structure!
 *
 *      The starting address of nsr_fid_FileID is not acurrate.
 *      Compensate for this nsr_fid_FileID problem by adding the value of
 *      (nsr_fid_ImpUseLen-1) to the UCHAR ARRAY INDEX.
 *
 *      The starting address of nsr_fid_Padding is not acurrate.
 *      Compensate for this nsr_fid_Padding problem by adding the value of
 *      (nsr_fid_ImpUseLen+nsr_fid_FileIDLen-2) to the UCHAR ARRAY INDEX.
 *
 *      The true total size of nsr_fid_s is
 *          ((38 + nsr_fid_FileIDLen + nsr_fid_ImpUseLen) + 3) & ~3)
 *
 */

typedef struct  NSR_FID {
    DESTAG      Destag;                     // Descriptor Tag (NSR_FID)
    USHORT      Version;                    // File Version Number
    UCHAR       Flags;                      // File Flags (NSR_FID_F_...)
    UCHAR       FileIDLen;                  // File ID Length
    LONGAD      Icb;                        // ICB (long) Address
    USHORT      ImpUseLen;                  // Implementation Use Length

    UCHAR       ImpUse[1];                  // Implementation Use Area

//  nsr_fid_ImpUse has a variant length = nsr_fid_ImpUseLen

    UCHAR       FileID[1];                  // File Identifier

//  nsr_fid_FileID has a variant starting offset due to nsr_fid_ImpUse
//  nsr_fid_FileID has a variant length = nsr_fid_FileIDLen

    UCHAR       Padding[1];                 // Padding

//  nsr_fid_Paddinghas a variant starting offset due to nsr_fid_ImpUse and
//  nsr_fid_FileID
//  nsr_fid_Padding has a variant length. Round up to the next ULONG boundary.

} NSR_FID, *PNSR_FID;

#define ISONsrFidConstantSize (ULONG)(FIELD_OFFSET( NSR_FID, ImpUse ))
#define ISONsrFidSize( F ) (LongAlign( ISONsrFidConstantSize + (F)->FileIDLen + (F)->ImpUseLen ))

//  NSR_FID_F_... - Definitions for nsr_fid_Flags (Characteristics, 4/14.4.3)

#define NSR_FID_F_HIDDEN        (0x01)  // Hidden Bit
#define NSR_FID_F_DIRECTORY     (0x02)  // Directory Bit
#define NSR_FID_F_DELETED       (0x04)  // Deleted Bit
#define NSR_FID_F_PARENT        (0x08)  // Parent Directory Bit
#define NSR_FID_F_META          (0x10)  // (ECMAr3) Indicates impl. use
                                        // metadata stream.

#define NSR_FID_OFFSET_FILEID   38      // Field Offset of nsr_fid_FileID[];


/***    nsr_alloc - Allocation Extent Descriptor (4/14.5)
 *
 *      nsr_alloc_destag.destag_Ident = DESTAG_ID_NSR_ALLOC
 *
 *      This descriptor is immediately followed by AllocLen bytes
 *      of allocation descriptors, which is not part of this
 *      descriptor (so CRC calculation doesn't include it).
 *
 */

typedef struct  NSR_ALLOC {
    DESTAG      Destag;                 // Descriptor Tag (NSR_ALLOC)
    ULONG       Prev;                   // Previous Allocation Descriptor
    ULONG       AllocLen;               // Length of Allocation Descriptors
} NSR_ALLOC, *PNSR_ALLOC;


/***    icbtag - Information Control Block Tag (4/14.6)
 *
 *      An ICBTAG is commonly preceeded by a Descriptor Tag (DESTAG).
 *
 */

typedef struct  ICBTAG {
    ULONG       PriorDirectCount;// Prior Direct Entry Count
    USHORT      StratType;       // Strategy Type (ICBTAG_STRAT_...)
    USHORT      StratParm;       // Strategy Parameter (2 bytes)
    USHORT      MaxEntries;      // Maximum Number of Entries in ICB
    UCHAR       Res10;           // Reserved Zero
    UCHAR       FileType;        // File Type (ICBTAG_FILE_T_...)
    NSRLBA      IcbParent;       // Parent ICB Location
    USHORT      Flags;           // ICB Flags (ICBTAG_F_...)
} ICBTAG, *PICBTAG;


//  ICBTAG_STRAT_T_... - ICB Strategy Types

#define ICBTAG_STRAT_NOTSPEC    0       // ICB Strategy Not Specified
#define ICBTAG_STRAT_TREE       1       // Strategy 1 (4/A.2) (Plain Tree)
#define ICBTAG_STRAT_MASTER     2       // Strategy 2 (4/A.3) (Master ICB)
#define ICBTAG_STRAT_BAL_TREE   3       // Strategy 3 (4/A.4) (Balanced Tree)
#define ICBTAG_STRAT_DIRECT     4       // Strategy 4 (4/A.5) (One Direct)

//  ICBTAG_FILE_T_... - Values for icbtag_FileType

#define ICBTAG_FILE_T_NOTSPEC    0      // Not Specified
#define ICBTAG_FILE_T_UASE       1      // Unallocated Space Entry
#define ICBTAG_FILE_T_PINTEG     2      // Partition Integrity Entry
#define ICBTAG_FILE_T_INDIRECT   3      // Indirect Entry
#define ICBTAG_FILE_T_DIRECTORY  4      // Directory
#define ICBTAG_FILE_T_FILE       5      // Ordinary File
#define ICBTAG_FILE_T_BLOCK_DEV  6      // Block Special Device
#define ICBTAG_FILE_T_CHAR_DEV   7      // Character Special Device
#define ICBTAG_FILE_T_XA         8      // Extended Attributes
#define ICBTAG_FILE_T_FIFO       9      // FIFO file
#define ICBTAG_FILE_T_C_ISSOCK  10      // Socket
#define ICBTAG_FILE_T_TERMINAL  11      // Terminal Entry
#define ICBTAG_FILE_T_PATHLINK  12      // Symbolic Link with a pathname

//  ICBTAG_F_... - Values for icbtag_Flags

#define ICBTAG_F_ALLOC_MASK     (0x0007)// Mask for Allocation Descriptor Info
#define ICBTAG_F_ALLOC_SHORT          0 // Short Allocation Descriptors Used
#define ICBTAG_F_ALLOC_LONG           1 // Long Allocation Descriptors Used
#define ICBTAG_F_ALLOC_EXTENDED       2 // Extended Allocation Descriptors Used
#define ICBTAG_F_ALLOC_IMMEDIATE      3 // File Data Recorded Immediately

#define ISOAllocationDescriptorSize(T) ( (T) == ICBTAG_F_ALLOC_SHORT ? sizeof(SHORTAD) : \
                                         (T) == ICBTAG_F_ALLOC_LONG ? sizeof(LONGAD) :   \
                                         sizeof(EXTAD) )

#define ICBTAG_F_SORTED         (0x0008)// Directory is Sorted (4/8.6.1)
#define ICBTAG_F_NO_RELOCATE    (0x0010)// Data is not relocateable
#define ICBTAG_F_ARCHIVE        (0x0020)// Archive Bit
#define ICBTAG_F_SETUID         (0x0040)// S_ISUID Bit
#define ICBTAG_F_SETGID         (0x0080)// S_ISGID Bit
#define ICBTAG_F_STICKY         (0x0100)// C_ISVTX Bit
#define ICBTAG_F_CONTIGUOUS     (0x0200)// File Data is Contiguous
#define ICBTAG_F_SYSTEM         (0x0400)// System Bit
#define ICBTAG_F_TRANSFORMED    (0x0800)// Data Transformed
#define ICBTAG_F_MULTIVERSIONS  (0x1000)// Multi-version Files in Directory


/***    icbind - Indirect ICB Entry (4/14.7)
 *
 */

typedef struct  ICBIND {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBIND)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_INDIRECT)
    LONGAD      Icb;                    // ICB Address
} ICBIND, *PICBIND;


/***    icbtrm - Terminal ICB Entry (4/14.8)
 *
 */

typedef struct  ICBTRM {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBTRM)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_TERMINAL)
} ICBTRM, *PICBTRM;


/***    icbfile - File ICB Entry (4/14.9)
 *
 *      WARNING: WARNING: WARNING: icbfile is a multi-variant structure!
 *
 *      The starting address of icbfile_Allocs is not acurrate.
 *      Compensate for this icbfile_Allocs problem by adding the value of
 *      (icbfile_XALength-1) to the UCHAR ARRAY INDEX.
 *
 *      icbfile_XALength is a multiple of 4.
 *
 */

typedef struct  ICBFILE {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_FILE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_FILE)
    ULONG       UID;                    // User ID of file's owner
    ULONG       GID;                    // Group ID of file's owner
    ULONG       Permissions;            // File Permissions
    USHORT      LinkCount;              // File hard-link count
    UCHAR       RecordFormat;           // Record Format
    UCHAR       RecordDisplay;          // Record Display Attributes
    ULONG       RecordLength;           // Record Length
    ULONGLONG   InfoLength;             // Information Length (file size)
    ULONGLONG   BlocksRecorded;         // Logical Blocks Recorded
    TIMESTAMP   AccessTime;             // Last-Accessed Time
    TIMESTAMP   ModifyTime;             // Last-Modification Time
    TIMESTAMP   AttributeTime;          // Last-Attribute-Change Time
    ULONG       Checkpoint;             // File Checkpoint
    LONGAD      IcbEA;                  // Extended Attribute ICB
    REGID       ImpUseID;               // Implementation Use Identifier
    ULONGLONG   UniqueID;               // Unique ID
    ULONG       EALength;               // Length of Extended Attributes
    ULONG       AllocLength;            // Length of Allocation Descriptors
    UCHAR       EAs[1];                 // Extended Attributes

//  icbfile_EAs has a variant length = icbfile_EALength

    UCHAR       Allocs[0];              // Allocation Descriptors.

//  icbfile_Allocs has a variant starting offset due to icbfile_EAs.
//  icbfile_Allocs has a variant length = icbfile_AllocLen.

} ICBFILE, *PICBFILE;


/***    icbextfile - Extended File ICB Entry (4/14.17 ECMA167r3 and later)
 *
 *      WARNING: WARNING: WARNING: icbextfile is a multi-variant structure!
 *
 *      The starting address of icbfile_Allocs is not acurrate.
 *      Compensate for this icbfile_Allocs problem by adding the value of
 *      (icbfile_XALength-1) to the UCHAR ARRAY INDEX.
 *
 *      icbfile_XALength is a multiple of 4.
 *
 */

typedef struct  ICBEXTFILE {
    DESTAG      Destag;                 // Descriptor Tag (DESTAG_ID_NSR_EXT_FILE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_FILE)
    ULONG       UID;                    // User ID of file's owner
    ULONG       GID;                    // Group ID of file's owner
    ULONG       Permissions;            // File Permissions
    USHORT      LinkCount;              // File hard-link count
    UCHAR       RecordFormat;           // Record Format
    UCHAR       RecordDisplay;          // Record Display Attributes
    ULONG       RecordLength;           // Record Length
    ULONGLONG   InfoLength;             // Information Length (file size)
    ULONGLONG   ObjectSize;             // Object Size (Sum of InfoLengths for all streams)
    
                                        // THE ABOVE FIELD IS NEW IN THE EXT FE vs BASIC
                                        // FE.  FIELDS AFTER THIS POINT ARE DISPLACED AND SHOULD
                                        // BE ACCESSED USING THE MACROS BELOW WHEN 
                                        // MANIPULATING RAW, MAPPED, FEs
                                        
    ULONGLONG   BlocksRecorded;         // Logical Blocks Recorded
    TIMESTAMP   AccessTime;             // Last-Accessed Time
    TIMESTAMP   ModifyTime;             // Last-Modification Time
    TIMESTAMP   CreationTime;           // Creation Time
    TIMESTAMP   AttributeTime;          // Last-Attribute-Change Time
    ULONG       Checkpoint;             // File Checkpoint
    ULONG       Reserved;
    LONGAD      IcbEA;                  // Extended Attribute ICB
    LONGAD      IcbStream;              // Stream Directory ICB
    REGID       ImpUseID;               // Implementation Use Identifier
    ULONGLONG   UniqueID;               // Unique ID
    ULONG       EALength;               // Length of Extended Attributes
    ULONG       AllocLength;            // Length of Allocation Descriptors
    UCHAR       EAs[1];                 // Extended Attributes

//  icbfile_EAs has a variant length = icbfile_EALength

    UCHAR       Allocs[0];              // Allocation Descriptors.

//  icbfile_Allocs has a variant starting offset due to icbfile_EAs.
//  icbfile_Allocs has a variant length = icbfile_AllocLen.

} ICBEXTFILE, *PICBEXTFILE;

//
//  Macros for accessing FEs and EXT FEs transparently.  Note that we
//  only need these for fields after the first new (in ext fe) field (which is
//  ObjectSize) and only for fields that we actually access.
//
//  All of the following macros expect a parameter of type PICBFILE
//

#define FeBlocksRecorded( F)        (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->BlocksRecorded : ((PICBEXTFILE)(F))->BlocksRecorded)
                                     
#define PFeAccessTime( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->AccessTime : &((PICBEXTFILE)(F))->AccessTime)
                                     
#define PFeModifyTime( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->ModifyTime : &((PICBEXTFILE)(F))->ModifyTime)
                                     
#define PFeCreationTime( F)         (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->ModifyTime : &((PICBEXTFILE)(F))->CreationTime)
                                     
#define FeEALength( F)              (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->EALength : ((PICBEXTFILE)(F))->EALength)
                                     
#define FeAllocLength( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->AllocLength : ((PICBEXTFILE)(F))->AllocLength)

#define FeEAs( F)                   (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->EAs : ((PICBEXTFILE)(F))->EAs)

#define FeEAsFieldOffset( F)        (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     FIELD_OFFSET( ICBFILE, EAs ) : FIELD_OFFSET( ICBEXTFILE, EAs ))

#define UdfFEIsExtended( F)         ((F)->Destag.Ident == DESTAG_ID_NSR_EXT_FILE)

//  Definitions for icbfile_Permissions (4/14.9.6)

#define ICBFILE_PERM_OTH_X  (0x00000001)    // Other: Execute OK
#define ICBFILE_PERM_OTH_W  (0x00000002)    // Other: Write OK
#define ICBFILE_PERM_OTH_R  (0x00000004)    // Other: Read OK
#define ICBFILE_PERM_OTH_A  (0x00000008)    // Other: Set Attributes OK
#define ICBFILE_PERM_OTH_D  (0x00000010)    // Other: Delete OK
#define ICBFILE_PERM_GRP_X  (0x00000020)    // Group: Execute OK
#define ICBFILE_PERM_GRP_W  (0x00000040)    // Group: Write OK
#define ICBFILE_PERM_GRP_R  (0x00000080)    // Group: Read OK
#define ICBFILE_PERM_GRP_A  (0x00000100)    // Group: Set Attributes OK
#define ICBFILE_PERM_GRP_D  (0x00000200)    // Group: Delete OK
#define ICBFILE_PERM_OWN_X  (0x00000400)    // Owner: Execute OK
#define ICBFILE_PERM_OWN_W  (0x00000800)    // Owner: Write OK
#define ICBFILE_PERM_OWN_R  (0x00001000)    // Owner: Read OK
#define ICBFILE_PERM_OWN_A  (0x00002000)    // Owner: Set Attributes OK
#define ICBFILE_PERM_OWN_D  (0x00004000)    // Owner: Delete OK

//  (4/14.9.7) Record Format
//      Skipped

//  (4/14.9.8) Record Display Attributes
//      Skipped


/***    nsr_eah - Extended Attributes Header Descriptor (4/14.10.1)
 *
 */

typedef struct  NSR_EAH {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_XA)
    ULONG       EAImp;                  // Implementation Attributes Location
    ULONG       EAApp;                  // Application Attributes Location
} NSR_EAH, *PNSR_EAH;


/***    nsr_ea_g - Generic Extended Attributes Format (4/14.10.2)
 *
 */

typedef struct  NSR_EA_GENERIC {
    ULONG       EAType;                 // Extended Attribute Type
    UCHAR       EASubType;              // Extended Attribute Sub Type
    UCHAR       Res5[3];                // Reserved Zeros
    ULONG       EALength;               // Extended Attribute Length
    UCHAR       EAData[0];              // Extended Attribute Data (variant!)

} NSR_EA_GENERIC, *PNSR_EA_GENERIC;

//
//  Extended Attribute Types (14.4.10)
//

#define EA_TYPE_CHARSET     1
#define EA_TYPE_ALTPERM     3
#define EA_TYPE_FILETIMES   5
#define EA_TYPE_INFOTIMES   6
#define EA_TYPE_DEVICESPEC  12
#define EA_TYPE_IMPUSE      2048
#define EA_TYPE_APPUSE      65536

#define EA_SUBTYPE_BASE     1


//  (4/14.10.3) Character Set Information Extended Attribute Format
//      Skipped

//  (4/14.10.4) Alternate Permissions Extended Attribute Format
//      Skipped

//  (4/14.10.5) File Times Extended Attribute Format

typedef struct  NSR_EA_FILETIMES {
    ULONG       EAType;                 // Extended Attribute Type
    UCHAR       EASubType;              // Extended Attribute Sub Type
    UCHAR       Res5[3];                // Reserved Zeros
    ULONG       EALength;               // Extended Attribute Length
    ULONG       DataLength;             // EAData Length
    ULONG       Existence;              // Specifies which times are recorded
    TIMESTAMP   Stamps[0];              // Timestamps (variant!)

} NSR_EA_FILETIMES, *PNSR_EA_FILETIMES;


//  Definitions for nsr_ea_filetimes_Existence (4/14.10.5.6)

#define EA_FILETIMES_E_CREATION     (0x00000001)
#define EA_FILETIMES_E_DELETION     (0x00000004)
#define EA_FILETIMES_E_EFFECTIVE    (0x00000008)
#define EA_FILETIMES_E_LASTBACKUP   (0x00000020)


//  (4/14.10.6) Information Times Extended Attribute Format
//
//  Exactly the same as an NSR_EA_FILETIMES

//  Definitions for nsr_ea_infotimes_Existence (4/14.10.6.6)

#define EA_INFOTIMES_E_CREATION     (0x00000001)
#define EA_INFOTIMES_E_MODIFICATION (0x00000002)
#define EA_INFOTIMES_E_EXPIRATION   (0x00000004)
#define EA_INFOTIMES_E_EFFECTIVE    (0x00000008)


//  (4/14.10.7) Device Specification Extended Attribute Format
//      Skipped

//  (4/14.10.8) Implementation Use Extended Attribute Format
//      Skipped

//  (4/14.10.9) Application Use Extended Attribute Format
//      Skipped


/***    icbuase - Unallocated Space Entry (4/14.11)
 *
 *      icbuase_destag.destag_Ident = DESTAG_ID_NSR_UASE
 *      icbuase_icbtag.icbtag_FileType = ICBTAG_FILE_T_UASE
 *
 */

typedef struct  ICBUASE {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBUASE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_UASE)
    ULONG       AllocLen;               // Allocation Descriptors Length
    UCHAR       Allocs[0];              // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  icbuase_Allocs has a variant length = icbuase_AllocLen;

} ICBUASE, *PICBUASE;


/***    nsr_sbd - Space Bitmap Descriptor (4/14.12)
 *
 *      nsr_sbd_destag.destag_Ident = DESTAG_ID_NSR_SBD
 *
 */

typedef struct  NSR_SBD {
    DESTAG      Destag;                 // Descriptor Tag (DESTAG_ID_NSR_SBD)
    ULONG       BitCount;               // Number of bits in Space Bitmap
    ULONG       ByteCount;              // Number of bytes in Space Bitmap
    UCHAR       Bits[0];                // Space Bitmap (variant!)

//  The true length of this structure may vary!
//  nsr_sbd_Bits has a variant length = nsr_sbd_ByteCount;

} NSR_SBD, *PNSR_SBD;


/***    icbpinteg - Partition Integrity ICB Entry (4/14.13)
 *
 */

typedef struct  ICBPINTEG {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_PINTEG)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_PINTEG)
    TIMESTAMP   Recording;              // Recording Time
    UCHAR       IntegType;              // Integrity Type (ICBPINTEG_T_...)
    UCHAR       Res49[175];             // Reserved Zeros
    REGID       ImpUseID;               // Implemetation Use Identifier
    UCHAR       ImpUse[256];            // Implemetation Use Area
} ICBPINTEG, *PICBPINTEG;

//  ICBPINTEG_T_... - Values for icbpinteg_IntegType

#define ICBPINTEG_T_OPEN        0       // Open Partition Integrity Entry
#define ICBPINTEG_T_CLOSE       1       // Close Partition Integrity Entry
#define ICBPINTEG_T_STABLE      2       // Stable Partition Integrity Entry


/***    (4/14.14.1) Short Allocation Descriptor
 ***    (4/14.14.2) Long Allocation Descriptor
 ***    (4/14.14.3) Extended Allocation Descriptor
 *
 *      See SHORTAD, LONGAD, EXTAD, already defined above.
 *
 */


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      The definition is moved to before Logical Volume Integrity
 *      Descriptor.
 *
 */


/***    nsr_path - Path Component (4/14.16)
 *
 */

typedef struct  NSR_PATH {
    UCHAR       Type;                   // Path Component Type (NSR_PATH_T_...)
    UCHAR       CompLen;                // Path Component Length
    UCHAR       CompVer;                // Path Component Version
    UCHAR       Comp[0];                // Path Component Identifier (variant!)

//  nsr_path_Comp has a variant length = nsr_path_CompLen

} NSR_PATH, *PNSR_PATH;

//  NSR_PATH_T_... - Values for nsr_path_Type

#define NSR_PATH_T_RESERVED     0       // Reserved Value
#define NSR_PATH_T_OTHER_ROOT   1       // Another root directory, by agreement
#define NSR_PATH_T_ROOTDIR      2       // Root Directory ('\')
#define NSR_PATH_T_PARENTDIR    3       // Parent Directory ('..')
#define NSR_PATH_T_CURDIR       4       // Current Directory ('.')
#define NSR_PATH_T_FILE         5       // File


/***    ISO 13346 Part 5: Record Structure
 *
 *      Skipped
 *
 */

//
//  Restore the standard structure packing.
//

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\lockctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the Lock Control routines for Udfs called
    by the Fsd/Fsp dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     20-Jan-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_LOCKCTRL)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_LOCKCTRL)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonLockControl)
#pragma alloc_text(PAGE, UdfFastLock)
#pragma alloc_text(PAGE, UdfFastUnlockAll)
#pragma alloc_text(PAGE, UdfFastUnlockAllByKey)
#pragma alloc_text(PAGE, UdfFastUnlockSingle)
#endif


NTSTATUS
UdfCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Lock Control called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Extract and decode the type of file object we're being asked to process
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != UserFileOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We check whether we can proceed based on the state of the file oplocks.
    //  This call might post the irp for us.
    //

    Status = FsRtlCheckOplock( &Fcb->Oplock,
                               Irp,
                               IrpContext,
                               UdfOplockComplete,
                               NULL );

    //
    //  If we don't get success then the oplock package completed the request.
    //

    if (Status != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Verify the Fcb.
    //

    UdfVerifyFcbOperation( IrpContext, Fcb );

    //
    //  If we don't have a file lock, then get one now.
    //

    if (Fcb->FileLock == NULL) { UdfCreateFileLock( IrpContext, Fcb, TRUE ); }

    //
    //  Now call the FsRtl routine to do the actual processing of the
    //  Lock request
    //

    Status = FsRtlProcessFileLock( Fcb->FileLock, Irp, NULL );

    //
    //  Set the flag indicating if Fast I/O is possible
    //

    UdfLockFcb( IrpContext, Fcb );
    Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  Complete the request.
    //

    UdfCompleteRequest( IrpContext, NULL, Status );
    return Status;
}


BOOLEAN
UdfFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast lock call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    IoStatus - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;

    PFCB Fcb;
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!UdfVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    FsRtlEnterFileSystem();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_leave( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !UdfCreateFileLock( NULL, Fcb, FALSE )) {

            try_leave( NOTHING );
        }

        //
        //  Now call the FsRtl routine to perform the lock request.
        //

        if (Results = FsRtlFastLock( Fcb->FileLock,
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     ProcessId,
                                     Key,
                                     FailImmediately,
                                     ExclusiveLock,
                                     IoStatus,
                                     NULL,
                                     FALSE )) {

            //
            //  Set the flag indicating if Fast I/O is questionable.  We
            //  only change this flag if the current state is possible.
            //  Retest again after synchronizing on the header.
            //

            if (Fcb->IsFastIoPossible == FastIoIsPossible) {

                UdfLockFcb( NULL, Fcb );
                Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
                UdfUnlockFcb( NULL, Fcb );
            }
        }

    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
UdfFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock single call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!UdfVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_leave( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !UdfCreateFileLock( NULL, Fcb, FALSE )) {

            try_leave( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockSingle( Fcb->FileLock,
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  ProcessId,
                                                  Key,
                                                  NULL,
                                                  FALSE );

        //
        //  Set the flag indicating if Fast I/O is possible.  We are
        //  only concerned if there are no longer any filelocks on this
        //  file.
        //

        if (!FsRtlAreThereCurrentFileLocks( Fcb->FileLock ) &&
            (Fcb->IsFastIoPossible != FastIoIsPossible)) {

            UdfLockFcb( IrpContext, Fcb );
            Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
            UdfUnlockFcb( IrpContext, Fcb );
        }

    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
UdfFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!UdfVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_leave( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !UdfCreateFileLock( NULL, Fcb, FALSE )) {

            try_leave( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAll( Fcb->FileLock,
                                               FileObject,
                                               ProcessId,
                                               NULL );


        //
        //  Set the flag indicating if Fast I/O is possible
        //

        UdfLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
        UdfUnlockFcb( IrpContext, Fcb );

    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
UdfFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all by key call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!UdfVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_leave( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !UdfCreateFileLock( NULL, Fcb, FALSE )) {

            try_leave( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAllByKey( Fcb->FileLock,
                                                    FileObject,
                                                    ProcessId,
                                                    Key,
                                                    NULL );


        //
        //  Set the flag indicating if Fast I/O is possible
        //

        UdfLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
        UdfUnlockFcb( IrpContext, Fcb );

    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\filobsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Udfs File object support routines.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Sep-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FILOBSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FILOBSUP)

//
//  Local constants.
//

#define TYPE_OF_OPEN_MASK               (0x00000007)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfDecodeFileObject)
#pragma alloc_text(PAGE, UdfFastDecodeFileObject)
#pragma alloc_text(PAGE, UdfSetFileObject)
#endif


VOID
UdfSetFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PFCB Fcb OPTIONAL,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine will initialize the FileObject context fields based on the
    input type and data structures.

Arguments:

    FileObject - Supplies the file object pointer being initialized.

    TypeOfOpen - Sets the type of open.

    Fcb - Fcb for this file object.  Ignored for UnopenedFileObject.

    Ccb - Ccb for the handle corresponding to this file object.  Will not
        be present for stream file objects.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  We only have values 0 to 7 available so make sure we didn't
    //  inadvertantly add a new type.
    //

    ASSERTMSG( "FileObject types exceed available bits\n", BeyondValidType <= 8 );

    //
    //  Setting a file object to type UnopenedFileObject means just
    //  clearing all of the context fields.  All the other input
    //

    if (TypeOfOpen == UnopenedFileObject) {

        FileObject->FsContext =
        FileObject->FsContext2 = NULL;

        return;
    }

    //
    //  Check that the 3 low-order bits of the Ccb are clear.
    //

    ASSERTMSG( "Ccb is not quad-aligned\n", !FlagOn( ((ULONG_PTR) Ccb), TYPE_OF_OPEN_MASK ));

    //
    //  We will or the type of open into the low order bits of FsContext2
    //  along with the Ccb value.
    //  The Fcb is stored into the FsContext field.
    //

    FileObject->FsContext = Fcb;
    FileObject->FsContext2 = Ccb;

    SetFlag( ((ULONG_PTR) FileObject->FsContext2), TypeOfOpen );

    //
    //  Set the Vpb field in the file object.
    //

    FileObject->Vpb = Fcb->Vcb->Vpb;

    return;
}



TYPE_OF_OPEN
UdfDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PCCB *Ccb
    )

/*++

Routine Description:

    This routine takes a file object and extracts the Fcb and Ccb (possibly NULL)
    and returns the type of open.

Arguments:

    FileObject - Supplies the file object pointer being initialized.

    Fcb - Address to store the Fcb contained in the file object.

    Ccb - Address to store the Ccb contained in the file object.

Return Value:

    TYPE_OF_OPEN - Indicates the type of file object.

--*/

{
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    //
    //  If this is an unopened file object then return NULL for the
    //  Fcb/Ccb.  Don't trust any other values in the file object.
    //

    TypeOfOpen = (TYPE_OF_OPEN) FlagOn( (ULONG_PTR) FileObject->FsContext2,
                                        TYPE_OF_OPEN_MASK );

    if (TypeOfOpen == UnopenedFileObject) {

        *Fcb = NULL;
        *Ccb = NULL;

    } else {

        //
        //  The Fcb is pointed to by the FsContext field.  The Ccb is in
        //  FsContext2 (after clearing the low three bits).  The low three
        //  bits are the file object type.
        //

        *Fcb = FileObject->FsContext;
        *Ccb = FileObject->FsContext2;

        ClearFlag( (ULONG_PTR) *Ccb, TYPE_OF_OPEN_MASK );
    }

    //
    //  Now return the type of open.
    //

    return TypeOfOpen;
}


TYPE_OF_OPEN
UdfFastDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by Udfs and does a quick decode operation.  It will only return
    a non null value if the file object is a user file open

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    Fcb - Address to store Fcb if this is a user file object.  NULL
        otherwise.

Return Value:

    TYPE_OF_OPEN - type of open of this file object.

--*/

{
    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    //
    //  The Fcb is in the FsContext field.  The type of open is in the low
    //  bits of the Ccb.
    //

    *Fcb = FileObject->FsContext;

    return (TYPE_OF_OPEN) FlagOn( (ULONG_PTR) FileObject->FsContext2, TYPE_OF_OPEN_MASK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\fspdisp.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the Udfs
    Fsp

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Sep-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FSPDISP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FSPDISP)


VOID
UdfFspDispatch (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:

    IrpContext - IrpContext for a request to process.

Return Value:

    None

--*/

{
    THREAD_CONTEXT ThreadContext;
    NTSTATUS Status;

    PIRP Irp = IrpContext->Irp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVOLUME_DEVICE_OBJECT VolDo = NULL;

    //
    //  If this request has an associated volume device object, remember it.
    //

    if (IrpSp->FileObject != NULL) {

        VolDo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                   VOLUME_DEVICE_OBJECT,
                                   DeviceObject );
    }

    //
    //  Now case on the function code.  For each major function code,
    //  either call the appropriate worker routine.  This routine that
    //  we call is responsible for completing the IRP, and not us.
    //  That way the routine can complete the IRP and then continue
    //  post processing as required.  For example, a read can be
    //  satisfied right away and then read can be done.
    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble.
    //

    while (TRUE) {

        //
        //  Set all the flags indicating we are in the Fsp.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FSP_FLAGS );

        FsRtlEnterFileSystem();

        UdfSetThreadContext( IrpContext, &ThreadContext );

        while (TRUE) {

            try {

                //
                //  Reinitialize for the next try at completing this
                //  request.
                //

                Status =
                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                //
                //  Initialize the Io status field in the Irp.
                //

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;

                //
                //  Case on the major irp code.
                //

                switch (IrpContext->MajorFunction) {

                    case IRP_MJ_CLEANUP :
                        
                        Status = UdfCommonCleanup( IrpContext, Irp );
                        break;
        
                    case IRP_MJ_CLOSE :

                        //
                        //  Closes should never be posted.
                        //
                        
                        ASSERT( FALSE );
                        break;

                    case IRP_MJ_CREATE :
                        
                        Status = UdfCommonCreate( IrpContext, Irp );
                        break;
        
                    case IRP_MJ_DEVICE_CONTROL :
    
                        Status = UdfCommonDevControl( IrpContext, Irp );
                        break;
    
                    case IRP_MJ_DIRECTORY_CONTROL :
    
                        Status = UdfCommonDirControl( IrpContext, Irp );
                        break;
    
                    case IRP_MJ_FILE_SYSTEM_CONTROL :
    
                        Status = UdfCommonFsControl( IrpContext, Irp );
                        break;
    
                    case IRP_MJ_LOCK_CONTROL :

                        Status = UdfCommonLockControl( IrpContext, Irp );
                        break;

                    case IRP_MJ_PNP :

                        ASSERT( FALSE );
                        Status = UdfCommonPnp( IrpContext, Irp );
                        break;

                    case IRP_MJ_QUERY_INFORMATION :

                        Status = UdfCommonQueryInfo( IrpContext, Irp );
                        break;
                
                    case IRP_MJ_QUERY_VOLUME_INFORMATION :

                        Status = UdfCommonQueryVolInfo( IrpContext, Irp );
                        break;
                
                    case IRP_MJ_READ :
    
                        Status = UdfCommonRead( IrpContext, Irp );
                        break;
    
                    case IRP_MJ_WRITE :
                    
                        Status = UdfCommonWrite( IrpContext, Irp );
                        break;
                        
                    case IRP_MJ_SET_INFORMATION :
                
                        Status = UdfCommonSetInfo( IrpContext, Irp );
                        break;
                
                    default :
    
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        UdfCompleteRequest( IrpContext, Irp, Status );
                }

            } except( UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

                Status = UdfProcessException( IrpContext, Irp, GetExceptionCode() );
            }

            //
            //  Break out of the loop if we didn't get CANT_WAIT.
            //

            if (Status != STATUS_CANT_WAIT) { break; }

            //
            //  We are retrying this request.  Cleanup the IrpContext for the retry.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
            UdfCleanupIrpContext( IrpContext, FALSE );
        }

        FsRtlExitFileSystem();

        //
        //  If there are any entries on this volume's overflow queue, service
        //  them.
        //

        if (VolDo != NULL) {

            KIRQL SavedIrql;
            PVOID Entry = NULL;

            //
            //  We have a volume device object so see if there is any work
            //  left to do in its overflow queue.
            //

            KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );

            if (VolDo->OverflowQueueCount > 0) {

                //
                //  There is overflow work to do in this volume so we'll
                //  decrement the Overflow count, dequeue the IRP, and release
                //  the Event
                //

                VolDo->OverflowQueueCount -= 1;

                Entry = RemoveHeadList( &VolDo->OverflowQueue );
            }

            KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );

            //
            //  There wasn't an entry, break out of the loop and return to
            //  the Ex Worker thread.
            //

            if (Entry == NULL) { break; }

            //
            //  Extract the IrpContext , Irp, set wait to TRUE, and loop.
            //

            IrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

            Irp = IrpContext->Irp;
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            continue;
        }

        break;
    }

    //
    //  Decrement the PostedRequestCount if there was a volume device object.
    //

    if (VolDo) {

        InterlockedDecrement( &VolDo->PostedRequestCount );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\fsctrl.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Udfs called
    by the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   11-Jun-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support
    
// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FSCTRL)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FSCTRL)

//
//  Local constants
//

BOOLEAN UdfDisable = FALSE;

//
//  CRC of the PVD on Disney's Snow White title,  so we can 
//  ignore the volsetseqmax on that disc only.
//

#define UDF_SNOW_WHITE_PVD_CRC ((USHORT)0x1d05)
#define UDF_SNOW_WHITE_PVD_CRC_VARIANT_2 ((USHORT)0x534e)

//
//  Local macros
//

INLINE
VOID
UdfStoreFileSetDescriptorIfPrevailing (
    IN OUT PNSR_FSD *StoredFSD,
    IN OUT PNSR_FSD *NewFSD
    )
{
    PNSR_FSD TempFSD;

    //
    //  If we haven't stored a fileset descriptor or the fileset number
    //  of the stored descriptor is less than the new descriptor, swap the
    //  pointers around.
    //

    if (*StoredFSD == NULL || (*StoredFSD)->FileSet < (*NewFSD)->FileSet) {

        TempFSD = *StoredFSD;
        *StoredFSD = *NewFSD;
        *NewFSD = TempFSD;
    }
}

//
//  Local support routines
//

VOID
UdfDetermineVolumeBounding ( 
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PULONG S,
    IN PULONG N
    );

NTSTATUS
UdfDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfFindAnchorVolumeDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PNSR_ANCHOR *AnchorVolumeDescriptor
    );

NTSTATUS
UdfFindFileSetDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLONGAD LongAd,
    IN OUT PNSR_FSD *FileSetDescriptor
    );

NTSTATUS
UdfFindVolumeDescriptors (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PEXTENTAD Extent,
    IN OUT PPCB *Pcb,
    IN OUT PNSR_PVD *PrimaryVolumeDescriptor,
    IN OUT PNSR_LVOL *LogicalVolumeDescriptor
    );

NTSTATUS
UdfInvalidateVolumes (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
UdfIsRemount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PVCB *OldVcb
    );

UdfIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
UdfRemountOldVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB OldVcb,
    IN PVCB NewVcb,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo
    );

NTSTATUS
UdfMountVolume(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
UdfRecognizeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN PULONG BoundS,
    IN OUT PBOOLEAN Bridge,
    OUT PUSHORT NSRVerFound
    );

VOID
UdfScanForDismountedVcb (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
UdfUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
UdfUpdateVolumeLabel (
    IN PIRP_CONTEXT IrpContext,
    IN PWCHAR VolumeLabel,
    IN OUT PUSHORT VolumeLabelLength,
    IN PUCHAR Dstring,
    IN UCHAR FieldLength
    );

VOID
UdfUpdateVolumeSerialNumber (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PULONG VolumeSerialNumber,
    IN PNSR_FSD Fsd
    );

NTSTATUS
UdfUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfAllowExtendedDasdIo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonFsControl)
#pragma alloc_text(PAGE, UdfDetermineVolumeBounding)
#pragma alloc_text(PAGE, UdfDismountVolume)
#pragma alloc_text(PAGE, UdfFindAnchorVolumeDescriptor)
#pragma alloc_text(PAGE, UdfFindFileSetDescriptor)
#pragma alloc_text(PAGE, UdfFindVolumeDescriptors)
#pragma alloc_text(PAGE, UdfIsPathnameValid)
#pragma alloc_text(PAGE, UdfIsRemount)
#pragma alloc_text(PAGE, UdfIsVolumeDirty)
#pragma alloc_text(PAGE, UdfIsVolumeMounted)
#pragma alloc_text(PAGE, UdfLockVolume)
#pragma alloc_text(PAGE, UdfMountVolume)
#pragma alloc_text(PAGE, UdfOplockRequest)
#pragma alloc_text(PAGE, UdfRecognizeVolume)
#pragma alloc_text(PAGE, UdfScanForDismountedVcb)
#pragma alloc_text(PAGE, UdfStoreVolumeDescriptorIfPrevailing)
#pragma alloc_text(PAGE, UdfUnlockVolume)
#pragma alloc_text(PAGE, UdfUpdateVolumeLabel)
#pragma alloc_text(PAGE, UdfUpdateVolumeSerialNumber)
#pragma alloc_text(PAGE, UdfUserFsctl)
#pragma alloc_text(PAGE, UdfVerifyVolume)
#pragma alloc_text(PAGE, UdfAllowExtendedDasdIo)
#endif


VOID
UdfStoreVolumeDescriptorIfPrevailing (
    IN OUT PNSR_VD_GENERIC *StoredVD,
    IN OUT PNSR_VD_GENERIC NewVD
    )

/*++

Routine Description:

    This routine updates Volume Descriptor if the new descriptor
    is more prevailing than the one currently stored.

Arguments:

    StoredVD - pointer to a currently stored descriptor

    NewVD - pointer to a candidate descriptor

Return Value:

    None.

--*/

{
    PNSR_VD_GENERIC TempVD;

    //
    //  If we haven't stored a volume descriptor or the sequence number
    //  of the stored descriptor is less than the new descriptor, make a copy
    //  of it and store it.
    //

    if ((NULL == *StoredVD) || ((*StoredVD)->Sequence < NewVD->Sequence)) {

        if ( NULL == *StoredVD)  {

            *StoredVD = (PNSR_VD_GENERIC) FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                    sizeof(NSR_VD_GENERIC),
                                                                    TAG_NSR_VDSD );
        }

        RtlCopyMemory( *StoredVD,  NewVD,  sizeof( NSR_VD_GENERIC));
    }
}


NTSTATUS
UdfCommonFsControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_MOUNT_VOLUME:

        Status = UdfMountVolume( IrpContext, Irp );
        break;

    case IRP_MN_VERIFY_VOLUME:

        Status = UdfVerifyVolume( IrpContext, Irp );
        break;

    case IRP_MN_USER_FS_REQUEST:

        Status = UdfUserFsctl( IrpContext, Irp );
        break;

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  Case on the control code.
    //

    switch ( IrpSp->Parameters.FileSystemControl.FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1 :
    case FSCTL_REQUEST_OPLOCK_LEVEL_2 :
    case FSCTL_REQUEST_BATCH_OPLOCK :
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_NOTIFY :
    case FSCTL_OPLOCK_BREAK_ACK_NO_2 :
    case FSCTL_REQUEST_FILTER_OPLOCK :

        Status = UdfOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_LOCK_VOLUME :

        Status = UdfLockVolume( IrpContext, Irp );
        break;

    case FSCTL_UNLOCK_VOLUME :

        Status = UdfUnlockVolume( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME :

        Status = UdfDismountVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_DIRTY :

        Status = UdfIsVolumeDirty( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_MOUNTED :

        Status = UdfIsVolumeMounted( IrpContext, Irp );
        break;

    case FSCTL_IS_PATHNAME_VALID :

        Status = UdfIsPathnameValid( IrpContext, Irp );
        break;

    case FSCTL_INVALIDATE_VOLUMES :

        Status = UdfInvalidateVolumes( IrpContext, Irp );
        break;

    case FSCTL_ALLOW_EXTENDED_DASD_IO:
    
        Status = UdfAllowExtendedDasdIo( IrpContext, Irp );
        break;

    //
    //  We don't support any of the known or unknown requests.
    //

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine to handle oplock requests made via the
    NtFsControlFile call.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb;
    PCCB Ccb;

    ULONG OplockCount = 0;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  We only permit oplock requests on files.
    //

    if (UdfDecodeFileObject( IrpSp->FileObject,
                             &Fcb,
                             &Ccb ) != UserFileOpen ) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make this a waitable Irpcontext so we don't fail to acquire
    //  the resources.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

    //
    //  Switch on the function control code.  We grab the Fcb exclusively
    //  for oplock requests, shared for oplock break acknowledgement.
    //

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1 :
    case FSCTL_REQUEST_OPLOCK_LEVEL_2 :
    case FSCTL_REQUEST_BATCH_OPLOCK :
    case FSCTL_REQUEST_FILTER_OPLOCK :

        UdfAcquireFcbExclusive( IrpContext, Fcb, FALSE );

        if (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {

            if (Fcb->FileLock != NULL) {

                OplockCount = (ULONG) FsRtlAreThereCurrentFileLocks( Fcb->FileLock );
            }

        } else {

            OplockCount = Fcb->FcbCleanup;
        }

        break;

    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        UdfAcquireFcbShared( IrpContext, Fcb, FALSE );
        break;

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Use a try finally to free the Fcb.
    //

    try {

        //
        //  Verify the Fcb.
        //

        UdfVerifyFcbOperation( IrpContext, Fcb );

        //
        //  Call the FsRtl routine to grant/acknowledge oplock.
        //

        Status = FsRtlOplockFsctrl( &Fcb->Oplock,
                                    Irp,
                                    OplockCount );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        UdfLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
        UdfUnlockFcb( IrpContext, Fcb );

        //
        //  The oplock package will complete the Irp.
        //

        Irp = NULL;

    } finally {

        //
        //  Release all of our resources
        //

        UdfReleaseFcb( IrpContext, Fcb );
    }

    //
    //  Complete the request if there was no exception.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual lock volume operation.  It will be called
    by anyone wishing to try to protect the volume for a long duration.  PNP
    operations are such a user.
    
    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.
    
    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    NTSTATUS FinalStatus = (FileObject? STATUS_ACCESS_DENIED: STATUS_DEVICE_BUSY);
    ULONG RemainingUserReferences = (FileObject? 1: 0);
    
    KIRQL SavedIrql;

    ASSERT_EXCLUSIVE_VCB( Vcb );
    
    //
    //  The cleanup count for the volume only reflects the fileobject that
    //  will lock the volume.  Otherwise, we must fail the request.
    //
    //  Since the only cleanup is for the provided fileobject, we will try
    //  to get rid of all of the other user references.  If there is only one
    //  remaining after the purge then we can allow the volume to be locked.
    //
    
    UdfPurgeVolume( IrpContext, Vcb, FALSE );

    //
    //  Now back out of our synchronization and wait for the lazy writer
    //  to finish off any lazy closes that could have been outstanding.
    //
    //  Since we purged, we know that the lazy writer will issue all
    //  possible lazy closes in the next tick - if we hadn't, an otherwise
    //  unopened file with a large amount of dirty data could have hung
    //  around for a while as the data trickled out to the disk.
    //
    //  This is even more important now since we send notification to
    //  alert other folks that this style of check is about to happen so
    //  that they can close their handles.  We don't want to enter a fast
    //  race with the lazy writer tearing down his references to the file.
    //

    UdfReleaseVcb( IrpContext, Vcb );

    Status = CcWaitForCurrentLazyWriterActivity();

    //
    //  This is intentional. If we were able to get the Vcb before, just
    //  wait for it and take advantage of knowing that it is OK to leave
    //  the flag up.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    
    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    UdfFspClose( Vcb );
        
    //
    //  If the volume is already explicitly locked then fail.  We use the
    //  Vpb locked flag as an 'explicit lock' flag in the same way as Fat.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    if (!FlagOn( Vcb->Vpb->Flags, VPB_LOCKED ) && 
        (Vcb->VcbCleanup == RemainingUserReferences) &&
        (Vcb->VcbUserReference == Vcb->VcbResidualUserReference + RemainingUserReferences)) {

        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        SetFlag( Vcb->Vpb->Flags, VPB_LOCKED );
        Vcb->VolumeLockFileObject = FileObject;
        FinalStatus = STATUS_SUCCESS;
    }

    IoReleaseVpbSpinLock( SavedIrql );

    return FinalStatus;
}


NTSTATUS
UdfUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual unlock volume operation. 
    
    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.
    
    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation
    
    Attempting to remove a system lock that did not exist is OK.

--*/

{
    NTSTATUS Status = STATUS_NOT_LOCKED;
    KIRQL SavedIrql;

    IoAcquireVpbSpinLock( &SavedIrql ); 

    if (FlagOn(Vcb->Vpb->Flags, VPB_LOCKED) && 
        (FileObject == Vcb->VolumeLockFileObject)) {

        ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED);
        Vcb->VolumeLockFileObject = NULL;
        Status = STATUS_SUCCESS;
    }
    
    IoReleaseVpbSpinLock( SavedIrql );  

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }
    
    DebugTrace(( +1, Dbg, "UdfLockVolume()\n"));

    //
    //  Send our notification so that folks that like to hold handles on
    //  volumes can get out of the way.
    //

    FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK );

    //
    //  Acquire exclusive access to the Vcb.
    //

    Vcb = Fcb->Vcb;
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    try {

        //
        //  Verify the Vcb.
        //

        UdfVerifyVcb( IrpContext, Vcb );

        Status = UdfLockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );

    } finally {

        //
        //  Release the Vcb.
        //

        UdfReleaseVcb( IrpContext, Vcb );

        if (AbnormalTermination() || !NT_SUCCESS( Status )) {

            FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }
        
        DebugTrace(( -1, Dbg, "UdfLockVolume() -> 0x%X\n", Status));
    }

    //
    //  Complete the request if there haven't been any exceptions.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen ) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Vcb.
    //

    Vcb = Fcb->Vcb;

    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  We won't check for a valid Vcb for this request.  An unlock will always
    //  succeed on a locked volume.
    //

    Status = UdfUnlockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );    
    
    //
    //  Release all of our resources
    //

    UdfReleaseVcb( IrpContext, Vcb );

    //
    //  Send notification that the volume is avaliable.
    //

    if (NT_SUCCESS( Status )) {

        FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_UNLOCK );
    }

    //
    //  Complete the request if there haven't been any exceptions.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}



//
//  Local support routine
//

NTSTATUS
UdfDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the dismount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.  We only dismount a volume which
    has been locked.  The intent here is that someone has locked the volume (they are the
    only remaining handle).  We set the volume state to invalid so that it will be torn
    down quickly.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    if (UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen ) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    DebugTrace(( +1, Dbg, "UdfDismountVolume()\n"));

    Vcb = Fcb->Vcb;
    
    //
    //  Acquire exclusive access to the Vcb,  and take the global resource to
    //  sync. against mounts,  verifies etc.
    //

    UdfAcquireUdfData( IrpContext);    
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Mark the volume as invalid, but only do it if the vcb is locked
    //  by this handle and the volume is currently mounted.  No more
    //  operations will occur on this vcb except cleanup/close.
    //

    if (Vcb->VcbCondition != VcbMounted)  {

        Status = STATUS_VOLUME_DISMOUNTED;
    }
    else {

        //
        //  Invalidate the volume right now.
        //
        //  The intent here is to make every subsequent operation
        //  on the volume fail and grease the rails toward dismount.
        //
            
        UdfLockVcb( IrpContext, Vcb );
        
        if (Vcb->VcbCondition != VcbDismountInProgress) {
            Vcb->VcbCondition = VcbInvalid;
        }
        
        UdfUnlockVcb( IrpContext, Vcb );

        //
        //  Set flag to tell the close path that we want to force dismount
        //  the volume when this handle is closed.
        //
        
        SetFlag( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE);

        Status = STATUS_SUCCESS;
    }

    //
    //  Release all of our resources
    //

    UdfReleaseVcb( IrpContext, Vcb );
    UdfReleaseUdfData( IrpContext);
    
    DebugTrace(( -1, Dbg, "UdfDismountVolume() -> 0x%x\n", Status));
    
    //
    //  Complete the request if there haven't been any exceptions.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


NTSTATUS
UdfAllowExtendedDasdIo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine marks the CCB to indicate that the handle
    may be used to read past the end of the volume file.  The
    handle must be a dasd handle.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;
    PFCB Fcb;
    PCCB Ccb;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    if (UserVolumeOpen != UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb )) {

        Status = STATUS_INVALID_PARAMETER;
    }
    else {

        SetFlag( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO );
    }        

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

UdfIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently dirty.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PULONG VolumeState;
    
    //
    //  Get the current stack location and extract the output
    //  buffer information.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        VolumeState = Irp->AssociatedIrp.SystemBuffer;

    } else {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the volume isn't dirty.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ULONG)) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *VolumeState = 0;

    //
    //  Decode the file object
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    if (TypeOfOpen != UserVolumeOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (Fcb->Vcb->VcbCondition != VcbMounted) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Now set up to return the clean state.  If we paid attention to the dirty
    //  state of the media we could be more accurate, but since this is a readonly
    //  implementation at the moment we think it is clean all of the time.
    //
    
    Irp->IoStatus.Information = sizeof( ULONG );

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently mounted.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object.
    //

    UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    if (Fcb != NULL) {

        //
        //  Disable PopUps, we want to return any error.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS );

        //
        //  Verify the Vcb.  This will raise in the error condition.
        //

        UdfVerifyVcb( IrpContext, Fcb->Vcb );
    }

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if pathname is a valid UDFS pathname.
    We always succeed this request.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    None

--*/

{
    PAGED_CODE();

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfInvalidateVolumes (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine searches for all the volumes mounted on the same real device
    of the current DASD handle, and marks them all bad.  The only operation
    that can be done on such handles is cleanup and close.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    KIRQL SavedIrql;

    LUID TcbPrivilege = {SE_TCB_PRIVILEGE, 0};

    HANDLE Handle;

    PVCB Vcb;

    PLIST_ENTRY Links;

    PFILE_OBJECT FileToMarkBad;
    PDEVICE_OBJECT DeviceToMarkBad;

    //
    //  Check for the correct security access.
    //  The caller must have the SeTcbPrivilege.
    //

    if (!SeSinglePrivilegeCheck( TcbPrivilege, Irp->RequestorMode )) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_PRIVILEGE_NOT_HELD );

        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  Try to get a pointer to the device object from the handle passed in.
    //

#if defined(_WIN64)
    if (IoIs32bitProcess( Irp )) {
        
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof( UINT32 )) {

            UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        Handle = (HANDLE) LongToHandle( *((PUINT32) Irp->AssociatedIrp.SystemBuffer) );
    
    } else {
#endif
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof( HANDLE )) {

            UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }
        Handle = *((PHANDLE) Irp->AssociatedIrp.SystemBuffer);
#if defined(_WIN64)
    }
#endif

    Status = ObReferenceObjectByHandle( Handle,
                                        0,
                                        *IoFileObjectType,
                                        KernelMode,
                                        &FileToMarkBad,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Grab the DeviceObject from the FileObject.
    //

    DeviceToMarkBad = FileToMarkBad->DeviceObject;

    //
    //  We only needed the device object involved, not a reference to the file.
    //

    ObDereferenceObject( FileToMarkBad );

    //
    //  Make sure this request can wait.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

    UdfAcquireUdfData( IrpContext );

    //
    //  Nothing can go wrong now.
    //

    //
    //  Now walk through all the mounted Vcb's looking for candidates to
    //  mark invalid.
    //
    //  On volumes we mark invalid, check for dismount possibility (which is
    //  why we have to get the next link so early).
    //

    Links = UdfData.VcbQueue.Flink;

    while (Links != &UdfData.VcbQueue) {

        Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks);

        Links = Links->Flink;

        //
        //  If we get a match, mark the volume Bad, and also check to
        //  see if the volume should go away.
        //

        UdfLockVcb( IrpContext, Vcb );

        if (Vcb->Vpb->RealDevice == DeviceToMarkBad) {

            //
            //  Take the VPB spinlock,  and look to see if this volume is the 
            //  one currently mounted on the actual device.  If it is,  pull it 
            //  off immediately.
            //

            IoAcquireVpbSpinLock( &SavedIrql );
    
            if (DeviceToMarkBad->Vpb == Vcb->Vpb) {

                PVPB NewVpb = Vcb->SwapVpb;

                ASSERT( FlagOn( Vcb->Vpb->Flags, VPB_MOUNTED));
                ASSERT( NULL != NewVpb);

                RtlZeroMemory( NewVpb, sizeof( VPB ) );

                NewVpb->Type = IO_TYPE_VPB;
                NewVpb->Size = sizeof( VPB );
                NewVpb->RealDevice = DeviceToMarkBad;
                NewVpb->Flags = FlagOn( DeviceToMarkBad->Vpb->Flags, VPB_REMOVE_PENDING );

                DeviceToMarkBad->Vpb = NewVpb;
                Vcb->SwapVpb = NULL;
            }

            IoReleaseVpbSpinLock( SavedIrql );

            if (Vcb->VcbCondition != VcbDismountInProgress) {

                UdfSetVcbCondition( Vcb, VcbInvalid);
            }

            UdfUnlockVcb( IrpContext, Vcb );

            UdfPurgeVolume( IrpContext, Vcb, FALSE );

            UdfCheckForDismount( IrpContext, Vcb, FALSE );

        } else {

            UdfUnlockVcb( IrpContext, Vcb );
        }
    }

    UdfReleaseUdfData( IrpContext );

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


VOID
UdfRemountOldVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB OldVcb,
    IN PVCB NewVcb,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo
    )
{
    KIRQL SavedIrql;
    
    ObDereferenceObject( OldVcb->TargetDeviceObject );

    IoAcquireVpbSpinLock( &SavedIrql);
    
    NewVcb->Vpb->RealDevice->Vpb = OldVcb->Vpb;

    OldVcb->Vpb->RealDevice = NewVcb->Vpb->RealDevice;
    OldVcb->TargetDeviceObject = DeviceObjectWeTalkTo;

    UdfSetVcbCondition( OldVcb, VcbMounted);

    UdfSetMediaChangeCount( OldVcb, NewVcb->MediaChangeCount);

    ClearFlag( OldVcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE);

    IoReleaseVpbSpinLock( SavedIrql);
}


//
//  Local support routine
//

NTSTATUS
UdfMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the mount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

    Its job is to verify that the volume denoted in the IRP is a UDF volume,
    and create the VCB and root directory FCB structures.  The algorithm it
    uses is essentially as follows:

    1. Create a new Vcb Structure, and initialize it enough to do I/O
       through the on-disk volume descriptors.

    2. Read the disk and check if it is a UDF volume.

    3. If it is not a UDF volume then delete the Vcb and
       complete the IRP with STATUS_UNRECOGNIZED_VOLUME

    4. Check if the volume was previously mounted and if it was then do a
       remount operation.  This involves deleting the VCB, hook in the
       old VCB, and complete the IRP.

    5. Otherwise create a Vcb and root directory FCB

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PVOLUME_DEVICE_OBJECT VolDo = NULL;
    PVCB Vcb = NULL;
    PVCB OldVcb = NULL;
    PPCB Pcb = NULL;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT DeviceObjectWeTalkTo = IrpSp->Parameters.MountVolume.DeviceObject;
    PVPB Vpb = IrpSp->Parameters.MountVolume.Vpb;

    PFILE_OBJECT FileObjectToNotify = NULL;

    ULONG MediaChangeCount = 0;

    DISK_GEOMETRY DiskGeometry;

    PNSR_ANCHOR AnchorVolumeDescriptor = NULL;
    PNSR_PVD PrimaryVolumeDescriptor = NULL;
    PNSR_LVOL LogicalVolumeDescriptor = NULL;
    PNSR_FSD FileSetDescriptor = NULL;

    BOOLEAN BridgeMedia;
    BOOLEAN SetDoVerifyOnFail;

    USHORT NSRVerFound;

    ULONG BoundS;
    ULONG BoundN;

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Check that we are talking to a Cdrom or Disk device.  This request should
    //  always be waitable.
    //

    ASSERT( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ||
            Vpb->RealDevice->DeviceType == FILE_DEVICE_DISK );
    ASSERT( FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

    DebugTrace(( +1, Dbg | UDFS_DEBUG_LEVEL_VERFYSUP,  "UdfMountVolume (Vpb %p, Dev %p)\n",
                 Vpb, Vpb->RealDevice));

    //
    //  Update the real device in the IrpContext from the Vpb.  There was no available
    //  file object when the IrpContext was created.
    //

    IrpContext->RealDevice = Vpb->RealDevice;
    
    SetDoVerifyOnFail = UdfRealDevNeedsVerify( IrpContext->RealDevice);

    //
    //  Check if we have disabled the mount process.
    //

    if (UdfDisable) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        DebugTrace(( 0, Dbg, "UdfMountVolume, disabled\n" ));
        DebugTrace(( -1, Dbg, "UdfMountVolume -> STATUS_UNRECOGNIZED_VOLUME\n" ));

        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Don't even attempt to mount floppy discs
    //
    
    if (FlagOn( Vpb->RealDevice->Characteristics, FILE_FLOPPY_DISKETTE)) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Do a CheckVerify here to lift the MediaChange ticker from the driver
    //

    Status = UdfPerformDevIoCtrl( IrpContext,
                                  ( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                                    IOCTL_CDROM_CHECK_VERIFY :
                                    IOCTL_DISK_CHECK_VERIFY ),
                                  DeviceObjectWeTalkTo,
                                  NULL,
                                  0,
                                  &MediaChangeCount,
                                  sizeof(ULONG),
                                  FALSE,
                                  TRUE,
                                  NULL );

    if (!NT_SUCCESS( Status )) {
        
        UdfCompleteRequest( IrpContext, Irp, Status );
        DebugTrace(( 0, Dbg,
                     "UdfMountVolume, CHECK_VERIFY handed back status %08x (so don't continue)\n",
                     Status ));
        DebugTrace(( -1, Dbg,
                     "UdfMountVolume -> %08x\n",
                     Status ));

        return Status;
    }
    
    //
    //  Now let's make Jeff delirious and call to get the disk geometry.  This
    //  will fix the case where the first change line is swallowed.
    //
    //  This IOCTL does not have a generic STORAGE equivalent, so we must figure
    //  our which variant to pass down from the real underlying device object (as
    //  opposed to the top of the driver filter stack we will really be attaching
    //  on top of).
    //

    Status = UdfPerformDevIoCtrl( IrpContext,
                                  ( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                                    IOCTL_CDROM_GET_DRIVE_GEOMETRY :
                                    IOCTL_DISK_GET_DRIVE_GEOMETRY ),
                                  DeviceObjectWeTalkTo,
                                  NULL,
                                  0,
                                  &DiskGeometry,
                                  sizeof( DISK_GEOMETRY ),
                                  FALSE,
                                  TRUE,
                                  NULL );

    //
    //  If this call failed, we might be able to get away with a heuristic guess as to
    //  what the sector size is (per CDFS), but that is playing with fire.  Nearly every
    //  failure here will be a permanent problem of some form.
    //

    if (!NT_SUCCESS( Status )) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        DebugTrace(( 0, Dbg, "UdfMountVolume, GET_DRIVE_GEOMETRY failed\n" ));
        DebugTrace(( -1, Dbg,
                     "UdfMountVolume -> %08x\n",
                     Status ));

        return Status;
    }

    //
    //  Acquire the global resource to do mount operations.
    //

    UdfAcquireUdfData( IrpContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Do a quick check to see if there any Vcb's which can be removed.
        //

        UdfScanForDismountedVcb( IrpContext );

        //
        //  Make sure that the driver/drive is not screwing up underneath of us by
        //  feeding us garbage for the sector size.
        //

        if (DiskGeometry.BytesPerSector == 0 ||
            (DiskGeometry.BytesPerSector & ~( 1 << UdfHighBit( DiskGeometry.BytesPerSector ))) != 0) {

            DebugTrace(( 0, 0,
                         "UdfMountVolume, bad DiskGeometry (%08x) .BytesPerSector == %08x\n",
                         &DiskGeometry,
                         DiskGeometry.BytesPerSector ));

            ASSERT( FALSE );

            try_leave( Status = STATUS_DRIVER_INTERNAL_ERROR );
        }

        //
        //  Now find the multi-session bounds on this media.
        //

        UdfDetermineVolumeBounding( IrpContext,
                                    DeviceObjectWeTalkTo,
                                    &BoundS,
                                    &BoundN );

        //
        //  Now go confirm that this volume may be a UDF image by looking for a
        //  valid ISO 13346 Volume Recognition Sequence in the last and first
        //  sessions.
        //

        if (!UdfRecognizeVolume( IrpContext,
                                 DeviceObjectWeTalkTo,
                                 DiskGeometry.BytesPerSector,
                                 &BoundS,
                                 &BridgeMedia,
                                 &NSRVerFound)) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, recognition failed so not mounting\n" ));

            try_leave( Status = STATUS_UNRECOGNIZED_VOLUME );
        }

        //
        //  Create the DeviceObject for this mount attempt
        //

        Status = IoCreateDevice( UdfData.DriverObject,
                                 sizeof( VOLUME_DEVICE_OBJECT ) - sizeof( DEVICE_OBJECT ),
                                 NULL,
                                 FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                                 0,
                                 FALSE,
                                 (PDEVICE_OBJECT *) &VolDo );

        if (!NT_SUCCESS( Status )) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, couldn't get voldo! (%08x)\n", Status ));
            try_leave( Status );
        }

        //
        //  Our alignment requirement is the larger of the processor alignment requirement
        //  already in the volume device object and that in the DeviceObjectWeTalkTo
        //

        if (DeviceObjectWeTalkTo->AlignmentRequirement > VolDo->DeviceObject.AlignmentRequirement) {

            VolDo->DeviceObject.AlignmentRequirement = DeviceObjectWeTalkTo->AlignmentRequirement;
        }

        //
        //  Initialize the overflow queue for the volume
        //

        VolDo->OverflowQueueCount = 0;
        InitializeListHead( &VolDo->OverflowQueue );

        VolDo->PostedRequestCount = 0;
        KeInitializeSpinLock( &VolDo->OverflowQueueSpinLock );

        //
        //  Now before we can initialize the Vcb we need to set up the
        //  device object field in the VPB to point to our new volume device
        //  object.
        //

        Vpb->DeviceObject = (PDEVICE_OBJECT) VolDo;

        //
        //  Initialize the Vcb.  This routine will raise on an allocation
        //  failure.
        //

        UdfInitializeVcb( IrpContext,
                          &VolDo->Vcb,
                          DeviceObjectWeTalkTo,
                          Vpb,
                          &DiskGeometry,
                          MediaChangeCount );

        //
        //  We must initialize the stack size in our device object before
        //  the following reads, because the I/O system has not done it yet.
        //

        ((PDEVICE_OBJECT) VolDo)->StackSize = (CCHAR) (DeviceObjectWeTalkTo->StackSize + 1);

        //
        //  Set the correct sector size.  IO defaults to 512b for DISK_FS and 2k for
        //  CDROM_FS....
        //

        ((PDEVICE_OBJECT) VolDo)->SectorSize = (USHORT) DiskGeometry.BytesPerSector;

        //
        //  Pick up a local pointer to the new Vcb.  Here is where we start
        //  thinking about cleanup of structures if the mount is failed.
        //

        ClearFlag( VolDo->DeviceObject.Flags, DO_DEVICE_INITIALIZING );

        Vcb = &VolDo->Vcb;
        Vpb = NULL;
        VolDo = NULL;

        //
        //  Store the session bounds we determined earlier.
        //
        
        Vcb->BoundS = BoundS;
        Vcb->BoundN = BoundN;

        //
        //  Store the Vcb in the IrpContext as we didn't have one before.
        //

        IrpContext->Vcb = Vcb;

        UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

        //
        //  Store the NSR version that we found
        //

        Vcb->NsrVersion = NSRVerFound;

        //
        //  Let's reference the Vpb to make sure we are the one to
        //  have the last dereference.
        //

        Vcb->Vpb->ReferenceCount += 1;

        //
        //  Clear the verify bit for the start of mount.
        //

        UdfMarkRealDevVerifyOk( Vcb->Vpb->RealDevice);

        //
        //  Now find the Anchor Volume Descriptor so we can discover the Volume Set
        //  Descriptor Sequence extent.
        //

        Status = UdfFindAnchorVolumeDescriptor( IrpContext,
                                                Vcb,
                                                &AnchorVolumeDescriptor );

        if (!NT_SUCCESS(Status)) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, couldn't find anchor descriptors\n" ));
            try_leave( Status );
        }

        //
        //  Now search for the prevailing copies of the PVD, LVD, and related PD in the
        //  extents indicated by the AVD.
        //

        Status = UdfFindVolumeDescriptors( IrpContext,
                                           Vcb,
                                           &AnchorVolumeDescriptor->Main,
                                           &Pcb,
                                           &PrimaryVolumeDescriptor,
                                           &LogicalVolumeDescriptor );

        //
        //  If we discovered invalid structures on the main extent, we may still
        //  be able to use the reserve extent.  By definition the two extents
        //  must be logically equal, so just plow into it on any error.
        //

        if (!NT_SUCCESS( Status )) {

            Status = UdfFindVolumeDescriptors( IrpContext,
                                               Vcb,
                                               &AnchorVolumeDescriptor->Reserve,
                                               &Pcb,
                                               &PrimaryVolumeDescriptor,
                                               &LogicalVolumeDescriptor );
        }

        if (!NT_SUCCESS(Status)) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, couldn't find good VSD descriptors (PVD/LVD/PD) status %X\n", Status ));
            try_leave( Status );
        }

        //
        //  Now go complete initialization of the Pcb.  After this point, we can perform
        //  physical partition mappings and know that the partition table is good.
        //

        Status = UdfCompletePcb( IrpContext,
                                 Vcb,
                                 Pcb );

        if (!NT_SUCCESS(Status)) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, Pcb completion failed\n" ));
            try_leave( Status );
        }

        Vcb->Pcb = Pcb;
        Pcb = NULL;

        //
        //  Set up all the support we need to do reads into the volume.
        //

        UdfUpdateVcbPhase0( IrpContext, Vcb );

        //
        //  Now go get the fileset descriptor that will finally reveal the location
        //  of the root directory on this volume.
        //

        Status = UdfFindFileSetDescriptor( IrpContext,
                                           Vcb,
                                           &LogicalVolumeDescriptor->FSD,
                                           &FileSetDescriptor );

        if (!NT_SUCCESS(Status)) {

            try_leave( NOTHING );
        }

        //
        //  Now that we have everything together, update the Vpb with identification
        //  of this volume.
        //

        UdfUpdateVolumeLabel( IrpContext,
                              Vcb->Vpb->VolumeLabel,
                              &Vcb->Vpb->VolumeLabelLength,
                              LogicalVolumeDescriptor->VolumeID,
                              sizeof( LogicalVolumeDescriptor->VolumeID ));

        UdfUpdateVolumeSerialNumber( IrpContext,
                                     &Vcb->Vpb->SerialNumber,
                                     FileSetDescriptor );

        //
        //  Check if this is a remount operation.  If so then clean up
        //  the data structures passed in and created here.
        //

        if (UdfIsRemount( IrpContext, Vcb, &OldVcb )) {

            KIRQL SavedIrql;

            DebugTrace((0, Dbg | UDFS_DEBUG_LEVEL_VERFYSUP, "Remounting Vcb %p (Vpb %p)\n",
                        OldVcb , OldVcb->Vpb));
            //
            //  Link the old Vcb to point to the new device object that we
            //  should be talking to, dereferencing the previous.  Call a nonpaged
            //  routine to do this since we take the Vpb spinlock.
            //

            UdfRemountOldVcb( IrpContext, 
                              OldVcb, 
                              Vcb,
                              DeviceObjectWeTalkTo);

            //
            //  Push the state of the method 2 bit across.  In changing the device,
            //  we may now be on one with a different requirement.
            //

            ClearFlag( OldVcb->VcbState, VCB_STATE_METHOD_2_FIXUP );
            SetFlag( OldVcb->VcbState, FlagOn( Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP ));
            
            //
            //  See if we will need to provide notification of the remount.  This is the readonly
            //  filesystem's form of dismount/mount notification - we promise that whenever a
            //  volume is "dismounted", that a mount notification will occur when it is revalidated.
            //  Note that we do not send mount on normal remounts - that would duplicate the media
            //  arrival notification of the device driver.
            //
    
            if (FlagOn( OldVcb->VcbState, VCB_STATE_NOTIFY_REMOUNT )) {
    
                ClearFlag( OldVcb->VcbState, VCB_STATE_NOTIFY_REMOUNT );
                
                FileObjectToNotify = OldVcb->RootIndexFcb->FileObject;
                ObReferenceObject( FileObjectToNotify );
            }
            
            DebugTrace(( 0, Dbg, "UdfMountVolume, remounted old Vcb %08x\n", OldVcb ));

            try_leave( Status = STATUS_SUCCESS );
        }

        //
        //  Initialize the Vcb and associated structures from our volume descriptors
        //

        UdfUpdateVcbPhase1( IrpContext,
                            Vcb,
                            FileSetDescriptor );

        //
        //  Drop an extra reference on the root dir file so we'll be able to send
        //  notification.
        //

        if (Vcb->RootIndexFcb) {

            FileObjectToNotify = Vcb->RootIndexFcb->FileObject;
            ObReferenceObject( FileObjectToNotify );
        }

        //
        //  The new mount is complete.  Remove the additional references on this
        //  Vcb since, at this point, we have added the real references this volume
        //  will have during its lifetime.  We also need to drop the additional
        //  reference on the device we mounted.
        //

        Vcb->VcbReference -= Vcb->VcbResidualReference;
        ASSERT( Vcb->VcbReference == Vcb->VcbResidualReference );

        ObDereferenceObject( Vcb->TargetDeviceObject );

        UdfSetVcbCondition( Vcb, VcbMounted);

        UdfReleaseVcb( IrpContext, Vcb );
        Vcb = NULL;

        Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( "UdfMountVolume" );

        //
        //  If we are not mounting the device,  then set the verify bit again.
        //
        
        if ((AbnormalTermination() || (Status != STATUS_SUCCESS)) && 
            SetDoVerifyOnFail)  {

            UdfMarkRealDevForVerify( IrpContext->RealDevice);
        }

        //
        //  If we didn't complete the mount then cleanup any remaining structures.
        //

        if (Vpb != NULL) { Vpb->DeviceObject = NULL; }

        if (Pcb != NULL) {

            UdfDeletePcb( Pcb );
        }

        if (Vcb != NULL) {

            //
            //  Make sure there is no Vcb in the IrpContext since it could go away
            //

            IrpContext->Vcb = NULL;

            Vcb->VcbReference -= Vcb->VcbResidualReference;

            if (UdfDismountVcb( IrpContext, Vcb )) {

                UdfReleaseVcb( IrpContext, Vcb );
            }

        } else if (VolDo != NULL) {

            IoDeleteDevice( (PDEVICE_OBJECT)VolDo );
            Vpb->DeviceObject = NULL;
        }
        
        //
        //  Release the global resource.
        //

        UdfReleaseUdfData( IrpContext );

        //
        //  Free any structures we may have been allocated
        //

        UdfFreePool( &AnchorVolumeDescriptor );
        UdfFreePool( &PrimaryVolumeDescriptor );
        UdfFreePool( &LogicalVolumeDescriptor );
        UdfFreePool( &FileSetDescriptor );
    }

    //
    //  Now send mount notification.
    //
    
    if (FileObjectToNotify) {

        FsRtlNotifyVolumeEvent( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( FileObjectToNotify );
    }

    //
    //  Complete the request if no exception.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    DebugTrace(( -1, Dbg, "UdfMountVolume -> %08x\n", Status ));

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the verify volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PVPB Vpb = IrpSp->Parameters.VerifyVolume.Vpb;
    PVCB Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->Parameters.VerifyVolume.DeviceObject)->Vcb;

    PPCB Pcb = NULL;

    PNSR_ANCHOR AnchorVolumeDescriptor = NULL;
    PNSR_PVD PrimaryVolumeDescriptor = NULL;
    PNSR_LVOL LogicalVolumeDescriptor = NULL;
    PNSR_FSD FileSetDescriptor = NULL;

    ULONG MediaChangeCount = Vcb->MediaChangeCount;
    ULONG Index;

    PFILE_OBJECT FileObjectToNotify = NULL;

    BOOLEAN ReturnError;
    BOOLEAN ReleaseVcb;

    IO_STATUS_BLOCK Iosb;

    WCHAR VolumeLabel[ MAXIMUM_VOLUME_LABEL_LENGTH / sizeof( WCHAR )];
    USHORT VolumeLabelLength;
    ULONG VolumeSerialNumber;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Check that we are talking to a Cdrom or Disk device.  This request should
    //  always be waitable.
    //

    ASSERT( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ||
            Vpb->RealDevice->DeviceType == FILE_DEVICE_DISK );

    ASSERT_VCB( Vcb );

    //
    //  Update the real device in the IrpContext from the Vpb.  There was no available
    //  file object when the IrpContext was created.
    //

    IrpContext->RealDevice = Vpb->RealDevice;

    //
    //  Acquire the global to synchronise against mounts and teardown.
    //

    UdfAcquireUdfData( IrpContext );
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    ReleaseVcb = TRUE;

    DebugTrace(( +1, Dbg, "UdfVerifyVolume, Vcb %08x\n", Vcb ));

    try {

        //
        //  Verify that there is a disk here.
        //

        Status = UdfPerformDevIoCtrl( IrpContext,
                                      ( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                                        IOCTL_CDROM_CHECK_VERIFY :
                                        IOCTL_DISK_CHECK_VERIFY ),
                                      Vcb->TargetDeviceObject,
                                      NULL,
                                      0,
                                      &MediaChangeCount,
                                      sizeof(ULONG),
                                      FALSE,
                                      TRUE,
                                      &Iosb );

        if (!NT_SUCCESS( Status )) {

            DebugTrace(( 0, Dbg, "UdfVerifyVolume, CHECK_VERIFY failed\n" ));

            //
            //  If we will allow a raw mount then return WRONG_VOLUME to
            //  allow the volume to be mounted by raw.
            //

            if (FlagOn( IrpSp->Flags, SL_ALLOW_RAW_MOUNT )) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, ... allowing raw mount\n" ));

                Status = STATUS_WRONG_VOLUME;
            }

            try_leave( Status );
        }

        if (Iosb.Information != sizeof(ULONG)) {

            //
            //  Be safe about the count in case the driver didn't fill it in
            //

            MediaChangeCount = 0;
        }

        //
        //  Verify that the device actually saw a change. If the driver does not
        //  support the MCC, then we must verify the volume in any case.
        //

        if (MediaChangeCount == 0 || (Vcb->MediaChangeCount != MediaChangeCount)) {

            //
            //  Now we need to navigate the disc to find the relavent decriptors.  This is
            //  much the same as the mount process.
            //

            //
            //  Find the AVD.
            //

            Status = UdfFindAnchorVolumeDescriptor( IrpContext,
                                                    Vcb,
                                                    &AnchorVolumeDescriptor );

            if (!NT_SUCCESS(Status)) {
                
                DebugTrace(( 0, Dbg, "UdfVerifyVolume, No AVD visible\n" ));
                try_leave( Status = STATUS_WRONG_VOLUME );
            }
            
            //
            //  Get the prevailing descriptors out of the VDS, building a fresh Pcb.
            //

            Status = UdfFindVolumeDescriptors( IrpContext,
                                               Vcb,
                                               &AnchorVolumeDescriptor->Main,
                                               &Pcb,
                                               &PrimaryVolumeDescriptor,
                                               &LogicalVolumeDescriptor );

            //
            //  Try the reserve sequence in case of error.
            //

            if (Status == STATUS_DISK_CORRUPT_ERROR) {

                Status = UdfFindVolumeDescriptors( IrpContext,
                                                   Vcb,
                                                   &AnchorVolumeDescriptor->Reserve,
                                                   &Pcb,
                                                   &PrimaryVolumeDescriptor,
                                                   &LogicalVolumeDescriptor );
            }

            //
            //  If we're totally unable to find a VDS, give up.
            //

            if (!NT_SUCCESS(Status)) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, PVD/LVD/PD pickup failed\n" ));

                try_leave( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  Now go complete initialization of the Pcb so we can compare it.
            //

            Status = UdfCompletePcb( IrpContext,
                                     Vcb,
                                     Pcb );

            if (!NT_SUCCESS(Status)) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, Pcb completion failed\n" ));

                try_leave( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  Now let's compare this new Pcb to the previous Vcb's Pcb to see if they
            //  appear to be equivalent.
            //

            if (!UdfEquivalentPcb( IrpContext,
                                   Pcb,
                                   Vcb->Pcb)) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, Pcbs are not equivalent\n" ));

                try_leave( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  At this point we know that the Vcb's Pcb is OK for mapping to find the fileset
            //  descriptor, so we can drop the new one we built for comparison purposes.
            //

            UdfDeletePcb( Pcb );
            Pcb = NULL;

            //
            //  Go pick up the fileset descriptor.
            //

            Status = UdfFindFileSetDescriptor( IrpContext,
                                               Vcb,
                                               &LogicalVolumeDescriptor->FSD,
                                               &FileSetDescriptor );

            if (!NT_SUCCESS(Status)) {

                try_leave( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  Now that everything is in place, build a volume label and serial number from these
            //  descriptors and perform the final check that this Vcb is (or is not) the right one
            //  for the media now in the drive.
            //

            UdfUpdateVolumeLabel( IrpContext,
                                  VolumeLabel,
                                  &VolumeLabelLength,
                                  LogicalVolumeDescriptor->VolumeID,
                                  sizeof( LogicalVolumeDescriptor->VolumeID ));

            UdfUpdateVolumeSerialNumber( IrpContext,
                                         &VolumeSerialNumber,
                                         FileSetDescriptor );

            if ((Vcb->Vpb->SerialNumber != VolumeSerialNumber) ||
                (Vcb->Vpb->VolumeLabelLength != VolumeLabelLength) ||
                (VolumeLabelLength != RtlCompareMemory( Vcb->Vpb->VolumeLabel,
                                                        VolumeLabel,
                                                        VolumeLabelLength))) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, volume label/sn mismatch\n" ));

                try_leave( Status = STATUS_WRONG_VOLUME );
            }
        }

        //
        //  The volume is OK, clear the verify bit.
        //

        DebugTrace(( 0, Dbg, "UdfVerifyVolume, looks like the same volume\n" ));

        UdfSetVcbCondition( Vcb, VcbMounted);

        UdfMarkRealDevVerifyOk( Vpb->RealDevice);

        //
        //  See if we will need to provide notification of the remount.  This is the readonly
        //  filesystem's form of dismount/mount notification.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_NOTIFY_REMOUNT )) {

            ClearFlag( Vcb->VcbState, VCB_STATE_NOTIFY_REMOUNT );
            
            FileObjectToNotify = Vcb->RootIndexFcb->FileObject;
            ObReferenceObject( FileObjectToNotify );
        }
        
    } finally {

        //
        //  If we did not raise an exception, update the current Vcb.
        //

        if (!AbnormalTermination()) {

            //
            //  Update the media change count to note that we have verified the volume
            //  at this value
            //

            UdfSetMediaChangeCount( Vcb, MediaChangeCount);

            //
            //  Mark the Vcb as not mounted.
            //

            if (Status == STATUS_WRONG_VOLUME) {

                UdfSetVcbCondition( Vcb, VcbNotMounted);
                
                //
                //  Now, if there are no user handles to the volume, try to spark
                //  teardown by purging the volume.
                //

                if (Vcb->VcbCleanup == 0) {

                    if (NT_SUCCESS( UdfPurgeVolume( IrpContext, Vcb, FALSE ))) {

                        ReleaseVcb = UdfCheckForDismount( IrpContext, Vcb, FALSE );
                    }
                }
            }
        }

        DebugTrace(( -1, Dbg, "UdfVerifyVolume -> %08x\n", Status ));

        if (ReleaseVcb) {
            
            UdfReleaseVcb( IrpContext, Vcb );
        }

        UdfReleaseUdfData( IrpContext );

        //
        //  Delete the Pcb if built.
        //

        if (Pcb != NULL) {

            UdfDeletePcb( Pcb );
        }

        UdfFreePool( &AnchorVolumeDescriptor );
        UdfFreePool( &PrimaryVolumeDescriptor );
        UdfFreePool( &LogicalVolumeDescriptor );
        UdfFreePool( &FileSetDescriptor );
    }

    //
    //  Now send mount notification.
    //
    
    if (FileObjectToNotify) {

        FsRtlNotifyVolumeEvent( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( FileObjectToNotify );
    }
    
    //
    //  Complete the request if no exception.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

BOOLEAN
UdfIsRemount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PVCB *OldVcb
    )

/*++

Routine Description:

    This routine walks through the links of the Vcb chain in the global
    data structure.  The remount condition is met when the following
    conditions are all met:

            1 - The 32 serial for this VPB matches that in a previous
                VPB.

            2 - The volume label for this VPB matches that in the previous
                VPB.

            3 - The system pointer to the real device object in the current
                VPB matches that in the same previous VPB.

            4 - Finally the previous Vcb cannot be invalid or have a dismount
                underway.

    If a VPB is found which matches these conditions, then the address of
    the Vcb for that VPB is returned via the pointer OldVcb.

    Skip over the current Vcb.

Arguments:

    Vcb - This is the Vcb we are checking for a remount.

    OldVcb -  A pointer to the address to store the address for the Vcb
              for the volume if this is a remount.  (This is a pointer to
              a pointer)

Return Value:

    BOOLEAN - TRUE if this is in fact a remount, FALSE otherwise.

--*/

{
    PLIST_ENTRY Link;

    PVPB Vpb = Vcb->Vpb;
    PVPB OldVpb;

    BOOLEAN Remount = FALSE;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    DebugTrace(( +1, Dbg, "UdfIsRemount, Vcb %08x\n", Vcb ));

    for (Link = UdfData.VcbQueue.Flink;
         Link != &UdfData.VcbQueue;
         Link = Link->Flink) {

        *OldVcb = CONTAINING_RECORD( Link, VCB, VcbLinks );

        //
        //  Skip ourselves.
        //

        if (Vcb == *OldVcb) { continue; }

        //
        //  Look at the Vpb and state of the previous Vcb.
        //

        OldVpb = (*OldVcb)->Vpb;

        if ((OldVpb != Vpb) &&
            (OldVpb->RealDevice == Vpb->RealDevice) &&
            ((*OldVcb)->VcbCondition == VcbNotMounted)) {

            //
            //  Go ahead and compare serial numbers and volume label.
            //

            if ((OldVpb->SerialNumber == Vpb->SerialNumber) &&
                       (Vpb->VolumeLabelLength == OldVpb->VolumeLabelLength) &&
                       (RtlEqualMemory( OldVpb->VolumeLabel,
                                        Vpb->VolumeLabel,
                                        Vpb->VolumeLabelLength ))) {

                //
                //  Got it.
                //

                DebugTrace(( 0, Dbg, "UdfIsRemount, matched OldVcb %08x\n", *OldVcb ));

                Remount = TRUE;
                break;
            }
        }
    }

    DebugTrace(( -1, Dbg, "UdfIsRemount -> %c\n", (Remount? 'T' : 'F' )));

    return Remount;
}


//
//  Local support routine
//

NTSTATUS
UdfFindFileSetDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLONGAD LongAd,
    IN OUT PNSR_FSD *FileSetDescriptor
    )

/*++

Routine Description:

    This routine walks a Fileset Descriptor Sequence looking for the default
    descriptor.  This will reveal the location of the root directory on the
    volume.

Arguments:

    Vcb - Vcb of volume to search

    LongAd - Long allocation descriptor describing the start of the sequence

    FileSetDescriptor - Address of caller's pointer to an FSD

Return Value:

    STATUS_SUCCESS if all descriptors are found, read, and are valid.

    STATUS_DISK_CORRUPT_ERROR if corrupt/bad descriptors are found (may be raised)

--*/

{
    PNSR_FSD FSD = NULL;
    ULONGLONG Offset;
    ULONG Lbn, Len;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( *FileSetDescriptor == NULL );

    DebugTrace(( +1, Dbg,
                 "UdfFindFileSetDescriptor, Vcb %08x, LongAd %08x %x/%08x +%08x (type %x)\n",
                 Vcb,
                 LongAd,
                 LongAd->Start.Partition,
                 LongAd->Start.Lbn,
                 LongAd->Length.Length,
                 LongAd->Length.Type ));
    
    //
    //  If the extent we begin from is not a whole number of recorded logical blocks,
    //  we can't continue.
    //

    if (LongAd->Length.Length == 0 ||
        LongAd->Length.Type != NSRLENGTH_TYPE_RECORDED ||
        BlockOffset( Vcb, LongAd->Length.Length )) {

        DebugTrace(( +0, Dbg,
                     "UdfFindFileSetDescriptor, bad longad length\n" ));
        DebugTrace(( -1, Dbg,
                     "UdfFindFileSetDescriptor ->  STATUS_DISK_CORRUPT_ERROR\n" ));
        
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    //  Use a try-finally for cleanup
    //

    try {

        try {
            
            for ( //
                  //  Home ourselves in the search and make a pass through the sequence.
                  //

                  Len = LongAd->Length.Length,
                  Lbn = LongAd->Start.Lbn;

                  Len;

                  //
                  //  Advance to the next descriptor offset in the sequence.
                  //

                  Len -= BlockSize( Vcb ),
                  Lbn++) {

                //
                //  Allocate a buffer to read fileset descriptors.
                //

                if (FSD == NULL) {

                    FSD = FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                    UdfRawBufferSize( Vcb, sizeof(NSR_FSD) ),
                                                    TAG_NSR_FSD );
                }

                //
                //  Lookup the physical offset for this block.  We could be mapping
                //  through a VAT here so we can't just assume that all the
                //  blocks in the extent are physically contiguous.  The FSD seems to 
                //  be the exception here - there's nothing that says it must be in
                //  physical partition,  and it can have a terminator, => 2 blocks
                //  minumum.  There is no single block virtual extent limitation in UDF 1.50.
                //
                
                Offset = LlBytesFromSectors( Vcb, UdfLookupPsnOfExtent( IrpContext,
                                                                        Vcb,
                                                                        LongAd->Start.Partition,
                                                                        Lbn,
                                                                        BlockSize( Vcb)));

                Status = UdfReadSectors( IrpContext,
                                         Offset,
                                         UdfRawReadSize( Vcb, sizeof(NSR_FSD) ),
                                         TRUE,
                                         FSD,
                                         Vcb->TargetDeviceObject );

                if (!NT_SUCCESS( Status ) ||
                    FSD->Destag.Ident == DESTAG_ID_NOTSPEC) {

                    //
                    //  These are both an excellent sign that this is an unrecorded sector, which
                    //  is defined to terminate the sequence. (3/8.4.2)
                    //

                    break;
                }

                if ((FSD->Destag.Ident != DESTAG_ID_NSR_FSD &&
                     FSD->Destag.Ident != DESTAG_ID_NSR_TERM) ||

                    !UdfVerifyDescriptor( IrpContext,
                                          &FSD->Destag,
                                          FSD->Destag.Ident,
                                          sizeof(NSR_FSD),
                                          Lbn,
                                          TRUE)) {

                    //
                    //  If we spot an illegal descriptor type in the stream, there is no reasonable
                    //  way to guess that we can continue (the disc may be trash beyond this point).
                    //  Clearly, we also cannot trust the next extent pointed to by a corrupt
                    //  descriptor.
                    //

                    try_leave( Status = STATUS_DISK_CORRUPT_ERROR );
                }

                if (FSD->Destag.Ident == DESTAG_ID_NSR_TERM) {

                    //
                    //  This is a way to terminate the sequence.
                    //

                    break;
                }

                //
                //  Reset the pointers to the possible next extent
                //

                LongAd = &FSD->NextExtent;

                if (LongAd->Length.Length) {

                    //
                    //  A fileset descriptor containing a nonzero next extent pointer also
                    //  terminates this extent of the FSD sequence. (4/8.3.1)
                    //
                    //  If the extent referred to is not fully recorded, this will
                    //  terminate the sequence.
                    //

                    if (LongAd->Length.Type != NSRLENGTH_TYPE_RECORDED) {

                        break;
                    }

                    Len = LongAd->Length.Length;

                    //
                    //  The extent must be a multiple of a block size.
                    //

                    if (BlockOffset( Vcb, Len )) {

                        DebugTrace(( +0, Dbg,
                                     "UdfFindFileSetDescriptor, interior extent not blocksize in length\n" ));
                        try_leave ( Status = STATUS_DISK_CORRUPT_ERROR );
                    }

                    Lbn = LongAd->Start.Lbn;

                    //
                    //  Note that we must correct the values to take into account
                    //  the changes that will be made next time through the for loop.
                    //

                    Len += BlockSize( Vcb );
                    Lbn -= 1;
                }

                UdfStoreFileSetDescriptorIfPrevailing( FileSetDescriptor, &FSD );
            }
        
        } 
        finally {

            DebugUnwind( "UdfFindFileSetDescriptor");
            
            //
            //  Free up the buffer space we may have allocated
            //

            UdfFreePool( &FSD );

        }
    
    } except( UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  Transmute raised apparent file corruption to disk corruption - we are not
        //  yet touching the visible filesystem.
        //

        Status = IrpContext->ExceptionStatus;
        
        DebugTrace(( +0, Dbg,
                     "UdfFindFileSetDescriptor, exception %08x thrown\n", Status ));

        if (Status == STATUS_FILE_CORRUPT_ERROR) {

            DebugTrace(( +0, Dbg,
                         "UdfFindFileSetDescriptor, translating file corrupt to disk corrupt\n" ));
            Status = STATUS_DISK_CORRUPT_ERROR;
        }
    }

    //
    //  Success is when we've really found something.  If we failed to find the
    //  descriptor, commute whatever intermediate status was involved and clean up.
    //

    if (*FileSetDescriptor == NULL) {
        
        Status = STATUS_UNRECOGNIZED_VOLUME;
    }

    if (!NT_SUCCESS( Status )) {

        UdfFreePool( FileSetDescriptor );
    }
    
    DebugTrace(( -1, Dbg,
                 "UdfFindFileSetDescriptor -> %08x\n", Status ));
    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfFindVolumeDescriptors (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PEXTENTAD Extent,
    IN OUT PPCB *Pcb,
    IN OUT PNSR_PVD *PrimaryVolumeDescriptor,
    IN OUT PNSR_LVOL *LogicalVolumeDescriptor
    )

/*++

Routine Description:

    This routine walks the indicated Volume Descriptor Sequence searching for the
    active descriptors for this volume and generates an initializing Pcb from the
    referenced partitions.  No updating of the Vcb occurs.

Arguments:

    Vcb - Vcb of volume to search

    Extent - Extent to search

    Pcb - Address of a caller's pointer to a Pcb

    PrimaryVolumeDescriptor - Address of caller's pointer to a PVD

    LogicalVolumeDescriptor - Address of caller's pointer to an LVD

Return Value:

    STATUS_SUCCESS if all descriptors are found, read, and are valid.

    STATUS_DISK_CORRUPT_ERROR if corrupt descriptors are found.

    STATUS_UNRECOGNIZED_VOLUME if noncompliant descriptors are found.
    
    Descriptors are only returned on success.

--*/

{
    PNSR_VD_GENERIC GenericVD = NULL;
    ULONGLONG Offset;
    ULONG Len;
    ULONG MaxSize;
    ULONG UnitSize = UdfRawReadSize( Vcb, sizeof(NSR_VD_GENERIC) );

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ThisPass = 1;
    ULONG MaxVdpExtents;
    
    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext);
    ASSERT_VCB( Vcb );
    ASSERT_OPTIONAL_PCB( *Pcb );

    DebugTrace(( +1, Dbg,
                 "UdfFindVolumeDescriptors, Vcb %08x, Extent %08x +%08x\n",
                 Vcb,
                 Extent->Lsn,
                 Extent->Len ));

    //
    //  If the extent we begin from is not at least the size of an aligned descriptor
    //  or is sized in base units other than aligned descriptors, we can't continue.
    //

    if (Extent->Len < UnitSize ||
        Extent->Len % UnitSize) {

        DebugTrace(( 0, Dbg,
                     "UdfFindVolumeDescriptors, Base extent length %08x is mismatched with read size %08x\n",
                     Extent->Len,
                     UnitSize ));

        DebugTrace(( -1, Dbg,
                     "UdfFindVolumeDescriptors -> STATUS_DISK_CORRUPT_ERROR\n" ));

        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        DebugTrace(( 0, Dbg,
                     "UdfFindVolumeDescriptors, starting pass 1, find LVD/PVD\n" ));

        //
        //  We will make at least one pass through the Volume Descriptor Sequence to find
        //  the prevailing versions of the two controlling descriptors - the PVD and LVD.
        //  In order to avoid picking up partition descriptors that aren't actually going
        //  to be referenced by the LVD, we will pick them up in a second pass if we find
        //  a PVD and LVD that look reasonable and then stick them in a Pcb.
        //

        for (ThisPass = 1; ThisPass <= 2; ThisPass++) {

            MaxVdpExtents = 16;

            for ( //
                  //  Home ourselves in the search and make a pass through the sequence.
                  //

                  Offset = LlBytesFromSectors( Vcb, Extent->Lsn ),
                  Len = Extent->Len;

                  //
                  //  If we have reached the end of the extent's indicated valid
                  //  length, we are done. This usually will not happen.
                  //

                  Len;

                  //
                  //  Advance to the next descriptor offset in the sequence.
                  //

                  Offset += UnitSize,
                  Len -= UnitSize 
                )  {

                //
                //  Allocate a buffer to read generic volume descriptors.
                //

                if (GenericVD == NULL) {

                    GenericVD = (PNSR_VD_GENERIC) FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                            UdfRawBufferSize( Vcb, sizeof(NSR_VD_GENERIC) ),
                                                                            TAG_NSR_VDSD );
                }

                Status = UdfReadSectors( IrpContext,
                                         Offset,
                                         UnitSize,
                                         TRUE,
                                         GenericVD,
                                         Vcb->TargetDeviceObject );

                //
                //  Thise is a decent sign that this is an unrecorded sector and is
                //  defined to terminate the sequence.
                //

                if (!NT_SUCCESS( Status )) {

                    break;
                }

                //
                //  Calculate the maximum size we expect this descriptor to be.  For LVDs 
                //  the descriptor can be followed by upto 2 partition maps,  pushing it 
                //  over the 512 byte ECMA desc. limit which we were assuming was the max.
                //
                
                MaxSize = sizeof( NSR_VD_GENERIC);
                
                if (DESTAG_ID_NSR_LVOL == GenericVD->Destag.Ident)  {
                
                    MaxSize += 2 * sizeof( PARTMAP_UDF_GENERIC);

                    ASSERT( BlockSize( Vcb) >= 1024);
                }

                if (GenericVD->Destag.Ident > DESTAG_ID_MAXIMUM_PART3 ||

                    !UdfVerifyDescriptor( IrpContext,
                                          &GenericVD->Destag,
                                          GenericVD->Destag.Ident,
                                          MaxSize,
                                          (ULONG) SectorsFromBytes( Vcb, Offset ),
                                          TRUE)) {

                    //
                    //  If we spot an illegal descriptor type in the stream, there is no reasonable
                    //  way to guess that we can continue (the disc may be trash beyond this point).
                    //  Likewise, even if we have a single corrupt descriptor we cannot continue because
                    //  this may be corruption of a descriptor we may have otherwise required for operation
                    //  (i.e., one of the prevailing descriptors).
                    //

                    DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, descriptor didn't verify\n" ));

                    try_leave( Status = STATUS_DISK_CORRUPT_ERROR );
                }

                if (GenericVD->Destag.Ident == DESTAG_ID_NSR_TERM) {

                    //
                    //  The Terminating Descriptor (3/10.9) is the usual way to stop a search.
                    //

                    break;
                }

                if (GenericVD->Destag.Ident == DESTAG_ID_NSR_VDP) {
                
                    //
                    //  Follow a Volume Desciptor Pointer (3/10.3) to the next extent of the sequence.
                    //  We will only follow a maximum of 16 extents,  to guard against loops.
                    //

                    if (0 == --MaxVdpExtents)  {
                    
                        try_leave( Status = STATUS_DISK_CORRUPT_ERROR );
                    }

                    //
                    //  Bias the values by UnitSize,  so that the next loop iteration will change them
                    //  to the correct values.
                    //

                    Offset = LlBytesFromSectors( Vcb, ((PNSR_VDP) GenericVD)->Next.Lsn ) - UnitSize;
                    Len = ((PNSR_VDP) GenericVD)->Next.Len;

                    //
                    //  We cannot do anything if the extent is invalid
                    //

                    if (Len < UnitSize ||
                        Len % UnitSize) {

                        DebugTrace(( 0, Dbg,
                                     "UdfFindVolumeDescriptors, following extent length %08x is mismatched with read size %08x\n",
                                     Extent->Len,
                                     UnitSize ));

                        try_leave( Status = STATUS_DISK_CORRUPT_ERROR );
                    }

                    Len += UnitSize;
                    continue;
                }

                DebugTrace(( 0, Dbg,
                             "UdfFindVolumeDescriptors, descriptor tag %08x\n",
                             GenericVD->Destag.Ident ));

                if (ThisPass == 1) {

                    //
                    //  Our first pass is to find prevailing LVD and PVD.
                    //

                    switch (GenericVD->Destag.Ident) {

                        case DESTAG_ID_NSR_PVD:

                            UdfStoreVolumeDescriptorIfPrevailing( (PNSR_VD_GENERIC *) PrimaryVolumeDescriptor,
                                                                  GenericVD );
                            break;

                        case DESTAG_ID_NSR_LVOL:

                            UdfStoreVolumeDescriptorIfPrevailing( (PNSR_VD_GENERIC *) LogicalVolumeDescriptor,
                                                                  GenericVD );
                            break;

                        default:

                            break;
                    }

                } else {

                    PNSR_PART PartitionDescriptor = (PNSR_PART) GenericVD;
                    USHORT ExpectedNsrVer;

                    //
                    //  Our second pass is to pick up all relevant NSR02/3 PD
                    //

                    if (PartitionDescriptor->Destag.Ident != DESTAG_ID_NSR_PART)  {
                    
                        continue;
                    }

                    //
                    //  Look at the NSR standard revision
                    //
                    
                    if (UdfEqualEntityId( &PartitionDescriptor->ContentsID, &UdfNSR02Identifier, NULL ))  {

                        ExpectedNsrVer = VsdIdentNSR02;
                    }
                    else if (UdfEqualEntityId( &PartitionDescriptor->ContentsID, &UdfNSR03Identifier, NULL ))  {
                    
                        ExpectedNsrVer = VsdIdentNSR03;
                    }
                    else {

                        //
                        //  Unknown NSR revision
                        //
                        
                        ExpectedNsrVer = VsdIdentBad;
                    }

                    //
                    //  Check that the NSR version in this PD matches what we found in the VRS earlier.
                    //
                    
                    if (ExpectedNsrVer != Vcb->NsrVersion)  {
                        
                        DebugTrace(( 0, Dbg, "UdfFindVolumeDescriptors: NSR version in PartitionDescriptor (%d) != NSR found in VRS (%d)\n", ExpectedNsrVer, Vcb->NsrVersion));
                        try_leave( Status = STATUS_UNRECOGNIZED_VOLUME );
                    }
                                        
                    UdfAddToPcb( *Pcb, (PNSR_PART) GenericVD );
                }
            } // inner descriptor loop.

            //
            //  Now that a pass through the VDS has been completed, analyze the results.
            //

            if (ThisPass == 1) {

                PNSR_PVD PVD;
                PNSR_LVOL LVD;
                USHORT MaxVerBasedOnNSR;

                //
                //  Reference the descriptors for ease of use
                //

                PVD = *PrimaryVolumeDescriptor;
                LVD = *LogicalVolumeDescriptor;

                //
                //  Check that the descriptors indicate a logical volume which appears to
                //  be a valid UDF volume.
                //

                if ((PVD == NULL &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, don't have a PVD\n" ))) ||
                    (LVD == NULL &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, don't have an LVD\n" ))))  {

                    try_leave( Status = STATUS_UNRECOGNIZED_VOLUME );
                }

                //
                //  Store away the UDF revision in the VCB for future reference,  and clamp the
                //  maximum acceptable revision based on the previously encountered NSR version.
                //
                
                Vcb->UdfRevision = ((PUDF_SUFFIX_DOMAIN)&(LVD->DomainID.Suffix))->UdfRevision;
                MaxVerBasedOnNSR = (VsdIdentNSR03 > Vcb->NsrVersion) ? UDF_VERSION_150 : UDF_VERSION_RECOGNIZED;
                
                DebugTrace((0,Dbg,"UdfFindVolumeDescriptors() Pass 1: Found LVD specifying DomainID %x\n", ((PUDF_SUFFIX_DOMAIN)&(LVD->DomainID.Suffix))->UdfRevision));
                
                if (
                    //
                    //  Now check the PVD
                    //

                    //
                    //  The Volume Set Sequence fields indicates how many volumes form
                    //  the volume set and what number this volume is in that sequence.
                    //  We are a level 2 implementation, meaning that the volumes we read
                    //  consist of a single volume. (3/11)
                    //

                    (PVD->VolSetSeq > 1 &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD VolSetSeq %08x - not volume 1 of a volume set\n",
                                  PVD->VolSetSeq ))) ||
                    (((PVD->VolSetSeqMax > 1) && (PVD->Destag.CRC != UDF_SNOW_WHITE_PVD_CRC) &&
                      (PVD->Destag.CRC != UDF_SNOW_WHITE_PVD_CRC_VARIANT_2)) &&
                     DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, PVD VolSetSeqMax %08x - volume in a non-unit volume set\n",
                                  PVD->VolSetSeqMax ))) ||

                    (PVD->CharSetList != UDF_CHARSETLIST &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD CharSetList %08x != CS0 only\n",
                                  PVD->CharSetList ))) ||
                    (PVD->CharSetListMax != UDF_CHARSETLIST &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD CharSetListMax %08x != CS0 only\n",
                                  PVD->CharSetListMax ))) ||
                    //
                    //  The two character sets must be UDF CS0.  CS0 is a "by convention"
                    //  character set in ISO 13346, which UDF specifies for our domain.
                    //

                    (!UdfEqualCharspec( &PVD->CharsetDesc, &UdfCS0Identifier, CHARSPEC_T_CS0 ) &&
                     DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, PVD CharsetDesc != CS0 only\n" ))) ||
                    (!UdfEqualCharspec( &PVD->CharsetExplan, &UdfCS0Identifier, CHARSPEC_T_CS0 ) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD CharsetExplan != CS0 only\n" ))) ||

                    //
                    //  Now check the LVD
                    //

                    //
                    //  The LVD is a variant sized structure.  Check that the claimed size fits in a single
                    //  logical sector.  Although an LVD may legally exceed a single sector, we will never
                    //  want to deal with such a volume.
                    //

                    (ISONsrLvolSize( LVD ) > SectorSize( Vcb ) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, LVD is bigger than a sector\n" ))) ||

                    //
                    //  The character set used in the LVD must be UDF CS0 as well.
                    //

                    (!UdfEqualCharspec( &LVD->Charset, &UdfCS0Identifier, CHARSPEC_T_CS0 ) &&
                     DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, LVD Charset != CS0 only\n" ))) ||

                    //
                    //  The specified block size must equal the physical sector size.
                    //

                    (LVD->BlockSize != SectorSize( Vcb ) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, LVD BlockSize %08x != SectorSize %08x\n" ))) ||

                    //
                    //  The domain must be within the version we read
                    //

                    (!UdfDomainIdentifierContained( &LVD->DomainID,
                                                    &UdfDomainIdentifier,
                                                    UDF_VERSION_MINIMUM,
                                                    MaxVerBasedOnNSR ) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, domain ID indicates unreadable volume\n" ))) ||

                    //
                    //  Although we can handle any number of partitions, UDF only specifies
                    //  a single partition or special dual partition formats.
                    //

                    (LVD->MapTableCount > 2 &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, LVD MapTableCount %08x greater than allowed (2)\n",
                                  LVD->MapTableCount )))
                    ) {

                    DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, ... so returning STATUS_UNRECOGNIZED_VOLUME\n" ));

                    try_leave( Status = STATUS_UNRECOGNIZED_VOLUME );
                }
                
                //
                //  Now that we have performed the simple field checks, build a Pcb.
                //

                Status = UdfInitializePcb( IrpContext, Vcb, Pcb, LVD );

                if (!NT_SUCCESS(Status)) {

                    DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, Pcb intialization failed (!)\n" ));

                    try_leave( Status );
                }
            }

            //
            //  Go onto Pass 2 to find the Partition Descriptors
            //

            DebugTrace(( 0, Dbg,
                         "UdfFindVolumeDescriptors, starting pass 2, find associated PD\n" ));
        }

    } finally {

        DebugUnwind( "UdfFindVolumeDescriptors" );

        //
        //  Free up the buffer space we may have allocated
        //

        UdfFreePool( &GenericVD );
    }

    DebugTrace(( -1, Dbg,
                 "UdfFindVolumeDescriptors -> %08x\n", Status ));

    //
    //  Success is when we've really found something.  If we failed to find both
    //  descriptors, commute whatever intermediate status was involved and clean up.
    //

    if (*PrimaryVolumeDescriptor == NULL || *LogicalVolumeDescriptor == NULL) {
        
        Status = STATUS_UNRECOGNIZED_VOLUME;
    }

    if (!NT_SUCCESS( Status )) {
        
        UdfFreePool(PrimaryVolumeDescriptor);
        UdfFreePool(LogicalVolumeDescriptor);
    }
    
    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfFindAnchorVolumeDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PNSR_ANCHOR *AnchorVolumeDescriptor
    )

/*++

Routine Description:

    This routine will find the Anchor Volume Descriptor for a piece of media

Arguments:

    Vcb - Vcb of volume to search

    AnchorVolumeDescriptor - Caller's pointer to an AVD

Return Value:

    Boolean TRUE if AVD is discovered, FALSE otherwise.

--*/

{
    ULONG ThisPass;
    ULONG ReadLsn;
    ULONG Lsn;
    BOOLEAN Found = FALSE;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext);
    ASSERT_VCB( Vcb );

    ASSERT(*AnchorVolumeDescriptor == NULL);

    DebugTrace(( +1, Dbg, "UdfFindAnchorVolumeDescriptors()\n"));

    //
    //  Discover the Anchor Volume Descriptor, which will point towards the
    //  Volume Set Descriptor Sequence.  The AVD may exist at sector 256 or
    //  in the last sector of the volume.
    //

    *AnchorVolumeDescriptor = (PNSR_ANCHOR) FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                      UdfRawBufferSize( Vcb, sizeof(NSR_ANCHOR) ),
                                                                      TAG_NSR_VDSD );


    //
    //  Search the three possible locations for an AVD to exist on the volume,
    //  plus check for the possibility of a method 2 fixup requirement.
    //

    for ( ThisPass = 1; ThisPass < 11; ThisPass++ ) {

        if (ThisPass == 1) {

            ReadLsn = Lsn = ANCHOR_SECTOR + Vcb->BoundS;

        } else if (ThisPass == 2) {

            //
            //  It is so unlikely that we will get a disk that doesn't have
            //  an anchor at 256 that this is a pretty good indication we
            //  have a CD-RW here and the drive is method 2 goofy.  Take
            //  a shot.
            //

            ReadLsn = UdfMethod2TransformSector( Vcb, ANCHOR_SECTOR );
            Lsn = ANCHOR_SECTOR;

        } else if (ThisPass >= 3) {

            ULONG SubPass = (ThisPass > 6) ? (ThisPass - 4) : ThisPass;

            //
            //  Our remaining two chances depend on being able to determine
            //  the last recorded sector for the volume.  If we were unable
            //  to do this, stop.
            //
 
            if (!Vcb->BoundN) {

                break;
            }
            
            //
            //  Note that although we're only looking at 2 sectors (N, N-256),
            //  because of the fuzziness of N on CD media (can include runout
            //  of 2 sectors) and method 2 addressing bugs in some drives,  we
            //  potentially have to look at 8 locations... We work fowards to 
            //  try and avoid reading invalid sectors (which can take some time).
            //

            ReadLsn = Lsn = Vcb->BoundN - ( SubPass == 3? (ANCHOR_SECTOR + 2): // 3,7
                                          ( SubPass == 4? ANCHOR_SECTOR:       // 4,8
                                          ( SubPass == 5? 2 : 0 )));           // 5,9 6,10

            //
            //  Also try the method 2 transformed version of each address (pass 7..10)
            //  If we get this far,  it might take a while...
            //
            
            if (6 < ThisPass)  {
            
                ReadLsn = UdfMethod2TransformSector( Vcb, Lsn);
            }
        }

        DebugTrace(( 0, Dbg, "Pass: %d  Trying Lsn/ReadLsn %X / %X\n", ThisPass, Lsn, ReadLsn));
        
        //
        //  We may have more chances to succeed if failure occurs.
        //

        Status = UdfReadSectors( IrpContext,
                                 LlBytesFromSectors( Vcb, ReadLsn ),
                                 UdfRawReadSize( Vcb, sizeof(NSR_ANCHOR) ),
                                 TRUE,
                                 *AnchorVolumeDescriptor,
                                 Vcb->TargetDeviceObject );

        if ( NT_SUCCESS( Status ) && 
             UdfVerifyDescriptor( IrpContext,
                                  &(*AnchorVolumeDescriptor)->Destag,
                                  DESTAG_ID_NSR_ANCHOR,
                                  sizeof(NSR_ANCHOR),
                                  Lsn,
                                  TRUE)
           )  {
                
            //
            //  Got one!  Set the method 2 fixup appropriately.
            //

            if (ReadLsn != Lsn) {

                DebugTrace(( 0, Dbg, "************************************************\n"));
                DebugTrace(( 0, Dbg, "METHOD 2 FIXUPS ACTIVATED FOR Vcb @ %08x\n", Vcb ));
                DebugTrace(( 0, Dbg, "************************************************\n"));

                SetFlag( Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP );
            
            } else {
                
                ClearFlag( Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP );
            }
            
            Status = STATUS_SUCCESS;
            break;
        }
    }

    if (11 == ThisPass)  {
    
        Status = STATUS_UNRECOGNIZED_VOLUME;
    }
    
    DebugTrace(( -1, Dbg, "UdfFindAnchorVolumeDescriptors() -> %X\n",  Status));
    
    return Status;
}


//
//  Local support routine
//

BOOLEAN
UdfRecognizeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN OUT PULONG BoundS,
    IN OUT PBOOLEAN Bridge,
    OUT PUSHORT NSRVerFound
    )

/*++

Routine Description:

    This routine walks the Volume Recognition Sequence to determine
    whether this volume contains an NSR02 (ISO 13346 Section 4) image.

Arguments:

    DeviceObject - device we are checking

    SectorSize - size of a physical sector on this device

    Bridge - will return whether there appear to be ISO 9660 structures
        on the media

    NSRVerFound - returns either VsdIdentNSR02 or VsdIdentNSR03 if successful

Return Value:

    Boolean TRUE if we found NSR02/3, FALSE otherwise.

--*/

{
    NTSTATUS Status;

    BOOLEAN FoundBEA;
    BOOLEAN FoundNSR;
    BOOLEAN Resolved;

    USHORT ThisRecordType;

    PVSD_GENERIC VolumeStructureDescriptor;
    PVSD_GENERIC VolumeStructureDescriptorBuffer;

    ULONGLONG Offset;

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext);

    VolumeStructureDescriptorBuffer = (PVSD_GENERIC) FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                         UdfRawBufferSizeN( SectorSize,
                                                                                            sizeof(VSD_GENERIC) ),
                                                                         TAG_NSR_VSD );

    DebugTrace(( +1, Dbg,
                 "UdfRecognizeVolume, DevObj %08x SectorSize %08x\n",
                 DeviceObject,
                 SectorSize ));

    //
    //  Use try-finally to facilitate cleanup
    //

    try {

Retry:

        FoundBEA = 
        FoundNSR =
        Resolved = FALSE;

        Offset = (SectorSize * (*BoundS)) + SectorAlignN( SectorSize, VRA_BOUNDARY_LOCATION );

        while (!Resolved) {

            //
            //  It's possible that the sector size is > 2k which is the descriptor 
            //  size.  Only read if we've processed all 2k blocks in the prev. sector 
            //
            
            if (0 == (Offset & (SectorSize - 1)))  {

                VolumeStructureDescriptor = VolumeStructureDescriptorBuffer;
                
                Status = UdfReadSectors( IrpContext,
                                         Offset,
                                         UdfRawReadSizeN( SectorSize,
                                                          sizeof(VSD_GENERIC) ),
                                         TRUE,
                                         VolumeStructureDescriptor,
                                         DeviceObject );

                if (!NT_SUCCESS( Status )) {
                    break;
                }
            }
            
            //
            //  Now check the type of the descriptor. All ISO 13346 VSDs are
            //  of Type 0, 9660 PVDs are Type 1, 9660 SVDs are Type 2, and 9660
            //  terminating descriptors are Type 255.
            //

            if (VolumeStructureDescriptor->Type == 0) {

                //
                //  In order to properly recognize the volume, we must know all of the
                //  Structure identifiers in ISO 13346 so that we can terminate if a
                //  badly formatted (or, shockingly, non 13346) volume is presented to us.
                //

                ThisRecordType = (USHORT)UdfFindInParseTable( VsdIdentParseTable,
                                                              VolumeStructureDescriptor->Ident,
                                                              VSD_LENGTH_IDENT );
                switch ( ThisRecordType ) {
                
                    case VsdIdentBEA01:

                        //
                        //  Only one BEA may exist and its version must be 1 (2/9.2.3)
                        //

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got a BEA01\n" ));


                        if ((FoundBEA &&
                             DebugTrace(( 0, Dbg,
                                          "UdfRecognizeVolume, ... but it is a duplicate!\n" ))) ||

                            (VolumeStructureDescriptor->Version != 1 &&
                             DebugTrace(( 0, Dbg,
                                          "UdfRecognizeVolume, ... but it has a wacky version number %02x != 1!\n",
                                          VolumeStructureDescriptor->Version )))) {

                            Resolved = TRUE;
                            break;
                        }

                        FoundBEA = TRUE;
                        break;

                    case VsdIdentTEA01:

                        //
                        //  If we reach the TEA it must be the case that we don't recognize
                        //

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got a TEA01\n" ));
                        Resolved = TRUE;
                        break;

                    case VsdIdentNSR02:
                    case VsdIdentNSR03:

                        //
                        //  We recognize NSR02/3 version 1 embedded after a BEA (3/9.1.3).  For
                        //  simplicity we will not bother being a complete nitpick and check
                        //  for a bounding TEA, although we will be optimistic in the case where
                        //  we fail to match the version.
                        //

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got an NSR0%c\n", ((VsdIdentNSR02 == ThisRecordType) ? '2' : '3')));

                        if ((FoundBEA ||
                             !DebugTrace(( 0, Dbg, "UdfRecognizeVolume, ... but we haven't seen a BEA01 yet!\n" ))) &&

                            (VolumeStructureDescriptor->Version == 1 ||
                             !DebugTrace(( 0, Dbg, "UdfRecognizeVolume, ... but it has a wacky version number %02x != 1\n",
                                           VolumeStructureDescriptor->Version )))
                           )  {
                            
                            FoundNSR = Resolved = TRUE;
                            *NSRVerFound = ThisRecordType;       // Report the NSR version we found here
                            break;
                        }

                        break;

                    case VsdIdentCD001:
                    case VsdIdentCDW01:
                    case VsdIdentNSR01:
                    case VsdIdentCDW02:
                    case VsdIdentBOOT2:

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got a valid but uninteresting 13346 descriptor (%d)\n", ThisRecordType ));

                        //
                        //  Valid but uninteresting (to us) descriptors
                        //

                        break;

                    default:

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got an invalid 13346 descriptor (%d)\n", ThisRecordType ));

                        //
                        //  Stumbling across something we don't know, it must be that this
                        //  is not a valid 13346 image
                        //

                        Resolved = TRUE;
                        break;

                }

            } 
            else if (!FoundBEA && (VolumeStructureDescriptor->Type < 3 ||
                     VolumeStructureDescriptor->Type == 255)) {

                DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got a 9660 descriptor\n" ));

                //
                //  Only HSG (CDROM) and 9660 (CD001) are possible, and they are only legal
                //  before the ISO 13346 BEA/TEA extent.  By design, an ISO 13346 VSD precisely
                //  overlaps a 9660 PVD/SVD in the appropriate fields.
                //
                //  Note that we aren't being strict about the structure of the 9660 descriptors
                //  since that really isn't very interesting.  We care more about the 13346.
                //
                //

                switch (UdfFindInParseTable( VsdIdentParseTable,
                                             VolumeStructureDescriptor->Ident,
                                             VSD_LENGTH_IDENT )) {
                    case VsdIdentCDROM:
                    case VsdIdentCD001:

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, ... seems we have 9660 here\n" ));

                        //
                        //  Note to our caller that we seem to have ISO 9660 here
                        //

                        *Bridge = TRUE;

                        break;

                    default:

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, ... but it looks wacky\n" ));

                        //
                        //  This probably was a false alert, but in any case there is nothing
                        //  on this volume for us.
                        //

                        Resolved = TRUE;
                        break;
                }

            } else {

                //
                //  Something else must be recorded on this volume.
                //

                DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got an unrecognizeable descriptor, probably not 13346/9660\n" ));
                break;
            }

            //
            //  Unfortunately the VRS is specified as 2k descriptors regardless of sector 
            //  size,  4k sectors iterate through the 2k blocks within a sector.
            //

            Offset += sizeof(VSD_GENERIC);
            VolumeStructureDescriptor = Add2Ptr( VolumeStructureDescriptor, 
                                                 sizeof( VSD_GENERIC), 
                                                 PVSD_GENERIC);
        }

        //
        //  If this was the first pass,  and we weren't looking at the start
        //  of the disc (i.e. later session),  and we didn't find anything,
        //  then try the first track in the first session.
        //

        if (!FoundNSR && (0 != *BoundS))  {

            DebugTrace(( 0, Dbg, "UdfRecognizeVolume, failed to find VRS in last session,  trying first\n" ));

            *BoundS = 0;

            goto Retry;
        }
    } 
    finally {

        DebugUnwind( "UdfRecognizeVolume" );

        //
        //  Free up our temporary buffer
        //

        UdfFreePool( &VolumeStructureDescriptorBuffer );

        if (AbnormalTermination()) {

            //
            //  Commute a status we raised for empty devices so that other filesystems
            //  can have a crack at this.
            //

            if (UdfIsRawDevice(IrpContext, IrpContext->ExceptionStatus)) {

                IrpContext->ExceptionStatus = STATUS_UNRECOGNIZED_VOLUME;
            }
        }
    }

    DebugTrace(( -1, Dbg, "UdfRecognizeVolume -> %u\n", FoundNSR ));

    return FoundNSR;
}


//
//  Local support routine
//

VOID
UdfScanForDismountedVcb (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine walks through the list of Vcb's looking for any which may
    now be deleted.  They may have been left on the list because there were
    outstanding references.

Arguments:

Return Value:

    None

--*/

{
    PVCB Vcb;
    PLIST_ENTRY Links;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    ASSERT_EXCLUSIVE_UDFDATA;

    //
    //  Walk through all of the Vcb's attached to the global data.
    //

    Links = UdfData.VcbQueue.Flink;

    while (Links != &UdfData.VcbQueue) {

        Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks );

        //
        //  Move to the next link now since the current Vcb may be deleted.
        //

        Links = Links->Flink;

        //
        //  If dismount is already underway then check if this Vcb can
        //  go away.
        //

        if ((Vcb->VcbCondition == VcbDismountInProgress) ||
            (Vcb->VcbCondition == VcbInvalid) ||
            ((Vcb->VcbCondition == VcbNotMounted) && (Vcb->VcbReference <= Vcb->VcbResidualReference))) {

            UdfCheckForDismount( IrpContext, Vcb, FALSE );
        }
    }

    return;
}


VOID
UdfDetermineVolumeBounding (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PULONG S,
    IN PULONG N
    )

/*++

Routine Description:

    This routine will figure out where the base offset to discover volume descriptors
    lies and where the end of the disc is.  In the case where this is a non-CD media,
    this will tend to not to set the end bound since there is no uniform way to figure
    that piece of information out.
    
    The bounding information is used to start the hunt for CD-UDF (UDF 1.5) volumes.
    Anyone who puts CD-UDF on non-CD media deserves what they get.

Arguments:

    Vcb - the volume we are operating on
    
    S - an address to store the start of the volume for the purposes of finding descriptors
    
    N - an address to store the end of the volume for the purposes of finding descriptors

Return Value:

    None.
    
    Benign inability find the S/N information will result in 0/0 being returned.

--*/

{
    NTSTATUS Status;
    PCDROM_TOC CdromToc;
    PTRACK_DATA TrackData;
    CDROM_READ_TOC_EX Command;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
        
    //
    //  Whack the inputs to the benign state.
    //
    
    *S = *N = 0;

    //
    //  Currently we do nothing here for non CD class devices.  This does
    //  mean that we can't mount (e.g.) WORM/RAM/MO media which has been
    //  recorded with sequential UDF and a VAT.
    //

    if (TargetDeviceObject->DeviceType != FILE_DEVICE_CD_ROM)  {

        DebugTrace(( 0, Dbg, "Not determining volume bounds / session info - not CDROM class device\n"));
        return;
    }
    
    //
    //  Allocate a buffer for the last session information.
    //

    CdromToc = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                         sizeof( CDROM_TOC ),
                                         TAG_CDROM_TOC );

    RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

    DebugTrace(( +1, Dbg,
               "UdfDetermineVolumeBounding, S %08x N %08x\n",
               S,
               N ));
    //
    //  Zero the command block.  This conveniently corresponds to an
    //  LBA mode READ_TOC request.
    //
    
    RtlZeroMemory( &Command, sizeof( Command));

    //
    //  Try to retrieve the CDROM last session information.
    //

    try {

        //
        //  Pull up the TOC.  The information for track AA (start of leadout)
        //  will get us the end of disc within some tolerance dependent on how
        //  much the device manufacturer paid attention to specifications.
        //  (-152, -150, -2, and 0 are possible offsets to the real end).
        //

        Status = UdfPerformDevIoCtrl( IrpContext,
                                      IOCTL_CDROM_READ_TOC_EX,
                                      TargetDeviceObject,
                                      &Command,
                                      sizeof( Command),
                                      CdromToc,
                                      sizeof( CDROM_TOC ),
                                      FALSE,
                                      TRUE,
                                      NULL );

        //
        //  If this failed,  try again with the MSF variant of the command
        //

        if (!NT_SUCCESS(Status) && 
            (STATUS_INSUFFICIENT_RESOURCES != Status))  {

            Command.Msf = 1;

            Status = UdfPerformDevIoCtrl( IrpContext,
                                          IOCTL_CDROM_READ_TOC_EX,
                                          TargetDeviceObject,
                                          &Command,
                                          sizeof( Command),
                                          CdromToc,
                                          sizeof( CDROM_TOC ),
                                          FALSE,
                                          TRUE,
                                          NULL );
        }

        //
        //  Raise an exception if there was an allocation failure.
        //

        if (Status == STATUS_INSUFFICIENT_RESOURCES) {

            DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, READ_TOC failed INSUFFICIENT_RESOURCES\n" ));
            UdfRaiseStatus( IrpContext, Status );
        }

        //
        //  For other errors, just fail.  Perhaps this will turn out to be benign, in any case
        //  the mount will rapidly and correctly fail if it really was dependant on this work.
        //
        
        if (!NT_SUCCESS( Status )) {

            try_leave( NOTHING );
        }

        //
        //  Sanity chck that the TOC is well-bounded.
        //
        
        if (CdromToc->LastTrack - CdromToc->FirstTrack >= MAXIMUM_NUMBER_TRACKS) {

            DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, TOC malf (too many tracks)\n" ));
            try_leave( NOTHING );
        }

#if DBG
        {
            ULONG Track;
            
            for ( Track = 0;  Track <= (ULONG)(CdromToc->LastTrack - CdromToc->FirstTrack + 1); Track++)  {

                DebugTrace(( 0, Dbg, "  TOC[%02x]:  Num: %x  Ctrl/Adr: %x/%x  Addr: %08x\n", Track, CdromToc->TrackData[Track].TrackNumber, CdromToc->TrackData[Track].Control, CdromToc->TrackData[Track].Adr, *(PULONG)(CdromToc->TrackData[Track].Address)));
            }
        }
#endif

        TrackData = &CdromToc->TrackData[(CdromToc->LastTrack - CdromToc->FirstTrack + 1)];

        //
        //  Last track better have number 0xAA ...
        //
        
        if (TrackData->TrackNumber != 0xaa) {

            DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, TOC malf (aa not last)\n" ));

            //
            //  Some drives do this wrong, apparently,  so we won't enforce it.
            //
            
            //  try_leave( NOTHING );
        }

        //
        //  Now, find the AA (leadout 'track') info 
        //

        if (Command.Msf)  {

            //  
            //  Convert MSF to a logical block address.  75 frames/sectors
            //  per second, 60 seconds per minute.  The MSF address is stored LSB (the F byte) high
            //  in the word.
            //
            //  NOTE: MSF is only capable of representing 256*(256+256*60)*75 = 0x11ce20 sectors.
            //  This is 2.3gb, much less than the size of DVD media, which will respond to CDROM_TOC.
            //  Caveat user.  And actually the maximum 'legal' value is 63/59/74.
            //

            *N = (TrackData->Address[3] + (TrackData->Address[2] + TrackData->Address[1] * 60) * 75) - 1;
            
            //
            //  We must bias back by 0/2/0 MSF since that is the defined location of sector 0.  This
            //  works out to 150 sectors.
            //

            if (*N <= 150) {

                *N = 0;
                try_leave( NOTHING );
            }

            *N -= 150;
        }
        else {

            //
            //  The non-MSF (LBA) request succeeded,  so just fix the endianness.
            //

            SwapCopyUchar4( N, &TrackData->Address);

            if (0 != *N)  {

                *N -= 1;
            }
        }

        //
        //  Seems that some DVD drives always return AA start 0x6dd39 (which is the max legally
        //  representable MSF value 99/59/74) to TOC queries,  even in LBA mode.  If this 
        //  is what we have for the leadout address,  then lets see what READ_CAPACITY says.
        //  We'll also issue read capacity if the address is > than this,  since we must
        //  be dealing with DVD or DDCD media,  so the drive must support the command and
        //  it should give a definitive answer.
        //

        if (0x6dd38 <= *N)  {

            PDISK_GEOMETRY_EX Geometry = (PVOID)CdromToc;
            ULONG Blocks;
        
            Status = UdfPerformDevIoCtrl( IrpContext,
                                          IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX,
                                          TargetDeviceObject,
                                          NULL,
                                          0,
                                          CdromToc,
                                          sizeof( CDROM_TOC ),
                                          FALSE,
                                          TRUE,
                                          NULL );

            if (NT_SUCCESS( Status))  {

                Blocks = (ULONG)(Geometry->DiskSize.QuadPart / Geometry->Geometry.BytesPerSector) - 1;

                if (Blocks > *N)  {

                    DebugTrace((0, Dbg, "Using READ_CAPACITY media size of 0x%X in place of maxed out READ_TOC value\n", Blocks));

                    *N = Blocks;
                }
            }
            else {

                DebugTrace(( 0, Dbg, "GET_DRIVE_GEO failed,  %x\n", Status));
            }
        }

        //
        //  Query the last session information from the driver.  Not that this
        //  actually issues an LBA mode READ_TOC_EX and pulls the address from
        //  there.
        //

        Status = UdfPerformDevIoCtrl( IrpContext,
                                      IOCTL_CDROM_GET_LAST_SESSION,
                                      TargetDeviceObject,
                                      NULL,
                                      0,
                                      CdromToc,
                                      sizeof( CDROM_TOC ),
                                      FALSE,
                                      TRUE,
                                      NULL );
        //
        //  Raise an exception if there was an allocation failure.
        //

        if (Status == STATUS_INSUFFICIENT_RESOURCES) {

            DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, GET_LAST_SESSION failed INSUFFICIENT_RESOURCES\n" ));
            UdfRaiseStatus( IrpContext, Status );
        }

        //
        //  Now, if we got anything interesting out of this try, return it.  If this                                                
        //  failed for any other reason, we don't really care - it just means that
        //  if this was CDUDF media, we're gonna fail to figure it out pretty quickly.
        //
        //  Life is tough.
        //

        if (NT_SUCCESS( Status ) &&
            CdromToc->FirstTrack != CdromToc->LastTrack) {

            //
            //  The 0 entry in TrackData tells us about the first track in the last 
            //  session as a logical block address.
            //

            SwapCopyUchar4( S, &CdromToc->TrackData[0].Address );

            //
            //  Save grief if the session info is messed up.
            //
            
            if (*N <= *S) {

                DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, N (0x%x) before S (0x%x), whacking both back!\n", *N, *S ));
                *S = *N = 0;
            }
        }

        DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, S 0x%08x, N (== AA start - 150) 0x%08x\n", *S, *N));

    } 
    finally {

        DebugUnwind( "UdfDetermineVolumeBounding" );
        
        if (CdromToc != NULL) {
            
            UdfFreePool( &CdromToc );
        }
    }

    DebugTrace(( -1, Dbg, "UdfDetermineVolumeBounding -> VOID\n" ));

    return;
}


//
//  Local support routine
//

VOID
UdfUpdateVolumeLabel (
    IN PIRP_CONTEXT IrpContext,
    IN PWCHAR VolumeLabel,
    IN OUT PUSHORT VolumeLabelLength,
    IN PUCHAR Dstring,
    IN UCHAR FieldLength
    )

/*++

Routine Description:

    This routine will retrieve an NT volume label from a logical volume descriptor.

Arguments:

    VolumeLabel - a volume label to fill in.

    VolumeLabelLength - returns the length of the returned volume label.

    Dstring - the dstring field containing the volume id.

    FieldLength - the length of the dstring field.

Return Value:

    None.

--*/

{
    BOOLEAN Result;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace(( +1, Dbg,
                 "UdfUpdateVolumeLabel, Label %08x, Dstring %08x FieldLength %02x\n",
                 VolumeLabel,
                 Dstring,
                 FieldLength ));

    //
    //  Check that the dstring is usable as a volume identification.
    //

    Result = UdfCheckLegalCS0Dstring( IrpContext,
                                      Dstring,
                                      0,
                                      FieldLength,
                                      TRUE );


    //
    //  Update the label directly if the dstring is good.
    //

    if (Result) {

        UNICODE_STRING TemporaryUnicodeString;

        TemporaryUnicodeString.Buffer = VolumeLabel;
        TemporaryUnicodeString.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;
        TemporaryUnicodeString.Length = 0;

        UdfConvertCS0DstringToUnicode( IrpContext,
                                       Dstring,
                                       0,
                                       FieldLength,
                                       &TemporaryUnicodeString );

        //
        //  Now retrieve the name for return to the caller.
        //

        RtlCopyMemory( VolumeLabel, TemporaryUnicodeString.Buffer, TemporaryUnicodeString.Length );
        *VolumeLabelLength = TemporaryUnicodeString.Length;

        DebugTrace(( 0, Dbg,
                     "UdfUpdateVolumeLabel, Labeled as \"%wZ\"\n",
                     &TemporaryUnicodeString ));

    //
    //  Treat as label.
    //

    } else {

        *VolumeLabelLength = 0;

        DebugTrace(( 0, Dbg,
                     "UdfUpdateVolumeLabel, invalid label.\n" ));
    }

    DebugTrace(( -1, Dbg,
                 "UdfUpdateVolumeLabel -> VOID\n" ));
}


//
//  Local support routine
//

VOID
UdfUpdateVolumeSerialNumber (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PULONG VolumeSerialNumber,
    IN PNSR_FSD Fsd
    )

/*++

Routine Description:

    This routine will compute the volume serial number for a set of descriptors.

Arguments:

    VolumeSerialNumber - returns the volume serial number corresponding to these descriptors.

    Fsd - the fileset descriptor to examine.

Return Value:

    None.

--*/

{
    ULONG VsnLe;
    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  The serial number is just off of the FSD. This matches Win9x.
    //

    VsnLe = UdfSerial32( (PCHAR) Fsd, sizeof( NSR_FSD ));
    SwapCopyUchar4( VolumeSerialNumber, &VsnLe );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\namesup.c ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    NameSup.c

Abstract:

    This module implements the Udfs Name support routines

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     9-October-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_NAMESUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_NAMESUP)

//
//  Local constants
//

static CONST CHAR UdfCrcChar[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#_~-@";

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCandidateShortName)
#pragma alloc_text(PAGE, UdfCheckLegalCS0Dstring)
#pragma alloc_text(PAGE, UdfConvertCS0DstringToUnicode)
#pragma alloc_text(PAGE, UdfDissectName)
#pragma alloc_text(PAGE, UdfFullCompareNames)
#pragma alloc_text(PAGE, UdfGenerate8dot3Name)
#pragma alloc_text(PAGE, UdfIs8dot3Name)
#pragma alloc_text(PAGE, UdfIsNameInExpression)
#pragma alloc_text(PAGE, UdfRenderNameToLegalUnicode)
#endif


INLINE
ULONG
NativeDosCharLength (
    IN WCHAR Wchar
    )

/*++

Routine Description:

    This routine is a translation layer for asking how big a given UNICODE
    character will be when converted to OEM.  Aside from adding more material
    to the kernel export table, this is how ya do it.

Arguments:

    Wchar - pointer to the character

Return Value:

    Size in bytes.

--*/

{
    NTSTATUS Status;
    CHAR OemBuf[2];
    ULONG Length;

    Status = RtlUpcaseUnicodeToOemN( OemBuf,
                                     sizeof(OemBuf),
                                     &Length,
                                     &Wchar,
                                     sizeof(WCHAR));
    
    ASSERT( NT_SUCCESS( Status ));

    return Length;
}


VOID
UdfDissectName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PUNICODE_STRING FinalName
    )

/*++

Routine Description:

    This routine is called to strip off leading components of the name strings.  We search
    for either the end of the string or separating characters.  The input remaining
    name strings should have neither a trailing or leading backslash.

Arguments:

    RemainingName - Remaining name.

    FinalName - Location to store next component of name.

Return Value:

    None.

--*/

{
    ULONG NameLength;
    PWCHAR NextWchar;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Find the offset of the next component separators.
    //

    for (NameLength = 0, NextWchar = RemainingName->Buffer;
         (NameLength < RemainingName->Length) && (*NextWchar != L'\\');
         NameLength += sizeof( WCHAR) , NextWchar += 1);

    //
    //  Adjust all the strings by this amount.
    //

    FinalName->Buffer = RemainingName->Buffer;

    FinalName->MaximumLength = FinalName->Length = (USHORT) NameLength;

    //
    //  If this is the last component then set the RemainingName lengths to zero.
    //

    if (NameLength == RemainingName->Length) {

        RemainingName->Length = 0;

    //
    //  Otherwise we adjust the string by this amount plus the separating character.
    //

    } else {

        RemainingName->MaximumLength -= (USHORT) (NameLength + sizeof( WCHAR ));
        RemainingName->Length -= (USHORT) (NameLength + sizeof( WCHAR ));
        RemainingName->Buffer = Add2Ptr( RemainingName->Buffer,
                                         NameLength + sizeof( WCHAR ),
                                         PWCHAR );
    }

    return;
}


BOOLEAN
UdfIs8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING FileName
    )

/*++

Routine Description:

    This routine checks if the name follows the 8.3 name conventions.  We check for
    the name length and whether the characters are valid.

Arguments:

    FileName - String of bytes containing the name.

Return Value:

    BOOLEAN - TRUE if this name is a legal 8.3 name, FALSE otherwise.

--*/

{
    CHAR DbcsNameBuffer[ BYTE_COUNT_8_DOT_3 ];
    STRING DbcsName;

    PWCHAR NextWchar;
    ULONG Count;

    ULONG DotCount = 0;
    BOOLEAN LastCharDot = FALSE;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  The length must be less than 24 bytes.
    //

    ASSERT( FileName.Length != 0 );
    if (FileName.Length > BYTE_COUNT_8_DOT_3) {

        return FALSE;
    }

    //
    //  Walk though and check for a space character.
    //

    NextWchar = FileName.Buffer;
    Count = 0;

    do {

        //
        //  No spaces allowed.
        //

        if (*NextWchar == L' ') { return FALSE; }

        if (*NextWchar == L'.') {

            //
            //  Not an 8.3 name if more than 1 dot or more than 8 characters
            //  remaining.  (It is legal for the dot to be in the ninth
            //  position)
            //

            if ((DotCount > 0) ||
                (Count > 8 * sizeof( WCHAR ))) {

                return FALSE;
            }

            DotCount += 1;
            LastCharDot = TRUE;

        } else {

            LastCharDot = FALSE;
        }

        Count += 2;
        NextWchar += 1;

    } while (Count < FileName.Length);

    //
    //  We can't have a period at the end of the name.
    //

    if (LastCharDot) {

        return FALSE;
    }

    //
    //  Create an Oem name to use to check for a valid short name.
    //

    DbcsName.MaximumLength = BYTE_COUNT_8_DOT_3;
    DbcsName.Buffer = DbcsNameBuffer;

    if (!NT_SUCCESS( RtlUnicodeStringToCountedOemString( &DbcsName,
                                                         &FileName,
                                                         FALSE ))) {

        return FALSE;
    }

    //
    //  We have now initialized the Oem string.  Call the FsRtl package to check for a
    //  valid FAT name.
    //

    return FsRtlIsFatDbcsLegal( DbcsName, FALSE, FALSE, FALSE );
}


BOOLEAN
UdfCandidateShortName (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine is called to determine if the input name could be a generated
    short name.

Arguments:

    Name - Pointer to the name to stare at.

Return Value:

    BOOLEAN True if it is possible that this is a shortname, False otherwise.

--*/

{
    ULONG Index, SubIndex;
    BOOLEAN LooksShort = FALSE;
    
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  The length can't be larger than an 8.3 name and must be
    //  at least as big as the uniqifier stamp.
    //

    ASSERT( Name->Length != 0 );
    
    if (Name->Length > BYTE_COUNT_8_DOT_3 ||
        Name->Length < DOS_CRC_LEN * sizeof(WCHAR)) {

        return FALSE;
    }
    
    //
    //  Walk across the name looking for the uniquifier stamp.  The stamp
    //  is of the form #<hex><hex><hex> so if we can stop before the end
    //  of the full name.
    //
    
    for ( Index = 0;
          Index <= (Name->Length / sizeof(WCHAR)) - DOS_CRC_LEN;
          Index++ ) {

        //
        //  Is the current character the stamp UDF uses to offset the stamp?
        //
        
        if (Name->Buffer[Index] == CRC_MARK) {
        
            //
            //  We may potentially have just a CRC at the end
            //  of the name OR have a period following.  If we
            //  do, it is reasonable to think the name may be
            //  a generated shorty.
            //
            //  #123 (a very special case - orignal name was ".")
            //  FOO#123
            //  FOO#123.TXT
            //
            
            if (Index == (Name->Length / sizeof(WCHAR)) - DOS_CRC_LEN ||
                Name->Buffer[Index + DOS_CRC_LEN] == PERIOD) {

                LooksShort = TRUE;
                break;
            }
        }
    }

    return LooksShort;
}


VOID
UdfGenerate8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING FileName,
    OUT PUNICODE_STRING ShortFileName
    )

/*++

Routine Description:

    This routine is called to generate a short name from the given long name.  We will
    generate a short name from the given long name.

    The short form is to convert all runs of illegal characters to "_" and tack
    on a base41 representation of the CRC of the original name.  The algorithm is
    nearly directly lifted from the UDF (2.01 proposed!) standard, so apologies for the
    style clash.
    
Arguments:

    FileName - String of bytes containing the name.

    ShortFileName - Pointer to the string to store the short name into.
        
Return Value:

    None.

--*/

{
    INT16 index;
    INT16 targetIndex;
    INT16 crcIndex;
    INT16 extLen;
    INT16 nameLen;
    INT16 charLen;
    INT16 overlayBytes;
    INT16 bytesLeft;
    UNICODE_CHAR current;
    BOOLEAN needsCRC;
    UNICODE_CHAR ext[DOS_EXT_LEN];

    //
    //  So as to lift as directly as possible from the standard, chunk things around.
    //
 
    PWCHAR dosName = ShortFileName->Buffer;
    PWCHAR udfName = FileName->Buffer;
    SHORT udfNameLen = FileName->Length / sizeof(WCHAR);
    
    needsCRC = FALSE;

    /* Start at the end of the UDF file name and scan for a period */
    /* ('.').  This will be where the DOS extension starts (if     */
    /* any).                                                       */
    index = udfNameLen;
    while (index-- > 0) {
        if (udfName[index] == PERIOD)
            break;
    }

    if (index < 0) {
        /* There name was scanned to the beginning of the buffer   */
        /* and no extension was found.                             */
        extLen = 0;
        nameLen = udfNameLen;
    }
    else {
        /* A DOS extension was found, process it first.            */
        extLen = udfNameLen - index - 1;
        nameLen = index;
        targetIndex = 0;
        bytesLeft = DOS_EXT_LEN;

        while (++index < udfNameLen && bytesLeft > 0) {
            /* Get the current character and convert it to upper   */
            /* case.                                               */
            current = UnicodeToUpper(udfName[index]);
            if (current == SPACE) {
                /* If a space is found, a CRC must be appended to  */
                /* the mangled file name.                          */
                needsCRC = TRUE;
            }
            else {
                /* Determine if this is a valid file name char and */
                /* calculate its corresponding BCS character byte  */
                /* length (zero if the char is not legal or        */
                /* undisplayable on this system).                  */
                charLen = (IsFileNameCharLegal(current)) ?
                    (USHORT)NativeDosCharLength(current) : 0;

                /* If the char is larger than the available space  */
                /* in the buffer, pretend it is undisplayable.     */
                if (charLen > bytesLeft)
                    charLen = 0;

                if (charLen == 0) {
                    /* Undisplayable or illegal characters are     */
                    /* substituted with an underscore ("_"), and   */
                    /* required a CRC code appended to the mangled */
                    /* file name.                                  */
                    needsCRC = TRUE;
                    charLen = 1;
                    current = ILLEGAL_CHAR_MARK;

                    /* Skip over any following undiplayable or     */
                    /* illegal chars.                              */
                    while (index + 1 < udfNameLen &&
                        (!IsFileNameCharLegal(udfName[index + 1]) ||
                        NativeDosCharLength(udfName[index + 1]) == 0))
                        index++;
                }

                /* Assign the resulting char to the next index in  */
                /* the extension buffer and determine how many BCS */
                /* bytes are left.                                 */
                ext[targetIndex++] = current;
                bytesLeft -= charLen;
            }
        }

        /* Save the number of Unicode characters in the extension  */
        extLen = targetIndex;

        /* If the extension was too large, or it was zero length   */
        /* (i.e. the name ended in a period), a CRC code must be   */
        /* appended to the mangled name.                           */
        if (index < udfNameLen || extLen == 0)
            needsCRC = TRUE;
    }

    /* Now process the actual file name.                           */
    index = 0;
    targetIndex = 0;
    crcIndex = 0;
    overlayBytes = -1;
    bytesLeft = DOS_NAME_LEN;
    while (index < nameLen && bytesLeft > 0) {
        /* Get the current character and convert it to upper case. */
        current = UnicodeToUpper(udfName[index]);
        if (current == SPACE || current == PERIOD) {
            /* Spaces and periods are just skipped, a CRC code     */
            /* must be added to the mangled file name.             */
            needsCRC = TRUE;
        }
        else {
            /* Determine if this is a valid file name char and     */
            /* calculate its corresponding BCS character byte      */
            /* length (zero if the char is not legal or            */
            /* undisplayable on this system).                      */
            charLen = (IsFileNameCharLegal(current)) ?
                (USHORT)NativeDosCharLength(current) : 0;

            /* If the char is larger than the available space in   */
            /* the buffer, pretend it is undisplayable.            */
            if (charLen > bytesLeft)
                charLen = 0;

            if (charLen == 0) {
                /* Undisplayable or illegal characters are         */
                /* substituted with an underscore ("_"), and       */
                /* required a CRC code appended to the mangled     */
                /* file name.                                      */
                needsCRC = TRUE;
                charLen = 1;
                current = ILLEGAL_CHAR_MARK;

                /* Skip over any following undiplayable or illegal */
                /* chars.                                          */
                while (index + 1 < nameLen &&
                    (!IsFileNameCharLegal(udfName[index + 1]) ||
                    NativeDosCharLength(udfName[index + 1]) == 0))
                    index++;

                /* Terminate loop if at the end of the file name.  */
                if (index >= nameLen)
                    break;
            }

            /* Assign the resulting char to the next index in the  */
            /* file name buffer and determine how many BCS bytes   */
            /* are left.                                           */
            dosName[targetIndex++] = current;
            bytesLeft -= charLen;

            /* This figures out where the CRC code needs to start  */
            /* in the file name buffer.                            */
            if (bytesLeft >= DOS_CRC_LEN) {
                /* If there is enough space left, just tack it     */
                /* onto the end.                                   */
                crcIndex = targetIndex;
            }
            else {
                /* If there is not enough space left, the CRC      */
                /* must overlay a character already in the file    */
                /* name buffer.  Once this condition has been      */
                /* met, the value will not change.                 */
                if (overlayBytes < 0) {
                    /* Determine the index and save the length of  */
                    /* the BCS character that is overlayed.  It    */
                    /* is possible that the CRC might overlay      */
                    /* half of a two-byte BCS character depending  */
                    /* upon how the character boundaries line up.  */
                    overlayBytes = (bytesLeft + charLen > DOS_CRC_LEN)
                        ? 1 : 0;
                    crcIndex = targetIndex - 1;
                }
            }
        }

        /* Advance to the next character.                          */
        index++;
    }

    /* If the scan did not reach the end of the file name, or the  */
    /* length of the file name is zero, a CRC code is needed.      */
    if (index < nameLen || index == 0)
        needsCRC = TRUE;

    /* If the name has illegal characters or and extension, it     */
    /* is not a DOS device name.                                   */
    if (needsCRC == FALSE && extLen == 0) {
        /* If this is the name of a DOS device, a CRC code should  */
        /* be appended to the file name.                           */
        if (IsDeviceName(udfName, udfNameLen))
            needsCRC = TRUE;
    }

    /* Append the CRC code to the file name, if needed.            */
    if (needsCRC) {
        /* Get the CRC value for the original Unicode string       */
        UINT16 udfCRCValue;

        //
        //  In UDF 2.00, the sample code changed to take the CRC
        //  from the UNICODE expansion of the CS0 as opposed to
        //  the CS0 itself.  In UDF 2.01, the wording of the spec
        //  will actually match this.
        //
        //  Additionally, the checksum changes to be byte-order
        //  independent.
        //
        
        udfCRCValue = UdfComputeCrc16Uni(udfName, udfNameLen);

        /* Determine the character index where the CRC should      */
        /* begin.                                                  */
        targetIndex = crcIndex;

        /* If the character being overlayed is a two-byte BCS      */
        /* character, replace the first byte with an underscore.   */
        if (overlayBytes > 0)
            dosName[targetIndex++] = ILLEGAL_CHAR_MARK;

        //
        //  UDF 2.01 changes to a base 41 encoding.  UDF 1.50 and
        //  UDF 2.00 exchanged the # delimeter with the high 4bits
        //  of the CRC.
        //

        dosName[targetIndex++] = CRC_MARK;
        
        dosName[targetIndex++] =
            UdfCrcChar[udfCRCValue / (41 * 41)];
        udfCRCValue %= (41 * 41);
        
        dosName[targetIndex++] =
            UdfCrcChar[udfCRCValue / 41];
        udfCRCValue %= 41;
        
        dosName[targetIndex++] =
            UdfCrcChar[udfCRCValue];
    }

    /* Append the extension, if any.                               */
    if (extLen > 0) {
        /* Tack on a period and each successive byte in the        */
        /* extension buffer.                                       */
        dosName[targetIndex++] = PERIOD;
        for (index = 0; index < extLen; index++)
            dosName[targetIndex++] = ext[index];
    }

    ASSERT( (targetIndex * sizeof(WCHAR)) <= ShortFileName->MaximumLength );
 
    ShortFileName->Length = (USHORT) (targetIndex * sizeof(WCHAR));

    //
    //  Now we upcase the whole name at once.
    //

    UdfUpcaseName( IrpContext,
                   ShortFileName,
                   ShortFileName );
}


VOID
UdfConvertCS0DstringToUnicode (
    IN PIRP_CONTEXT IrpContext,
    IN PUCHAR Dstring,
    IN UCHAR Length OPTIONAL,
    IN UCHAR FieldLength OPTIONAL,
    IN OUT PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine will convert the CS0 input dstring (1/7.2.12) to Unicode.  We assume that
    the length is sane.
    
    This "compression" in CS0 is really just a special case hack for ASCII.

Arguments:

    Dstring - the input dstring field
    
    Length - length of the dstring.  If unspecified, we assume that the characters come
        from a proper 1/7.2.12 dstring that specifies length in the last character of the
        field.
    
    FieldLength - length of the dstring field.  If unspecified, we assume that the characters
        come from an uncounted length of CS0 characters and that the Length parameter is
        specified.
    
    Name - the output Unicode string

Return Value:

    None.

--*/

{
    ULONG CompressID;
    ULONG UnicodeIndex, ByteIndex;
    PWCHAR Unicode = Name->Buffer;

    UCHAR NameLength;
    ULONG CopyNameLength;

    PAGED_CODE();
   
    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    CompressID = *Dstring;

    //
    //  If the length is unspecified, this is a real 1/7.2.12 dstring and the length is in
    //  the last character of the field.
    //
    
    ASSERT( Length || FieldLength );

    if (Length) {

        NameLength = FieldLength = Length;
    
    } else {

        NameLength = *(Dstring + FieldLength - 1);
    }
    
    //
    //  If the caller specified a size, they should have made sure the buffer is big enough.
    //  Otherwise, we will trim to fit.
    //
    
    ASSERT( Length == 0 || Name->MaximumLength >= UdfCS0DstringUnicodeSize( IrpContext, Dstring, NameLength ) );
 
    //
    //  Decide how many UNICODE bytes to "copy".
    //
    
    CopyNameLength = Min( Name->MaximumLength, UdfCS0DstringUnicodeSize( IrpContext, Dstring, NameLength ));
    
    //
    //  Reset the name length and advance over the compression ID in the dstring.
    //
    
    Name->Length = 0;
    Dstring++;
 
    //
    //  Loop through all the bytes.
    //

    while (CopyNameLength > Name->Length) {
      
        if (CompressID == 16) {
       
            //
            //  We're little endian, and this is the single place in the entire UDF/ISO standard
            //  where they use big endian.
            //
            //  Thank you.  Thank you very much.
            //
            //  Do an unaligned swapcopy of this 16bit value.
            //

            SwapCopyUchar2( Unicode, Dstring );
            Dstring += sizeof(WCHAR);
       
        } else {

            //
            //  Drop the byte into the low bits.
            //
                
            *Unicode = *Dstring;
            Dstring += sizeof(CHAR);
        }

        Name->Length += sizeof(WCHAR);
        Unicode++;
    }

    return;
}


BOOLEAN
UdfCheckLegalCS0Dstring (
    PIRP_CONTEXT IrpContext,
    PUCHAR Dstring,
    UCHAR Length OPTIONAL,
    UCHAR FieldLength OPTIONAL,
    BOOLEAN ReturnOnError
    )

/*++

Routine Description:

    This routine inspects a CS0 Dstring for conformance.
    
Arguments:

    Dstring - a dstring to check
    
    Length - length of the dstring.  If unspecified, we assume that the characters come
        from a proper 1/7.2.12 dstring that specifies length in the last character of the
        field.
    
    FieldLength - length of the dstring field.  If unspecified, we assume that the characters
        come from an uncounted length of CS0 characters and that the Length parameter is
        specified.
    
    ReturnOnError - whether to return or raise on a discovered error
    
Return Value:

    None. Raised status if corruption is found.
    
--*/

{
    UCHAR NameLength;

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  If the length is unspecified, this is a real 1/7.2.12 dstring and the length is in
    //  the last character of the field.
    //
    
    ASSERT( Length || FieldLength );

    if (Length) {

        NameLength = FieldLength = Length;
    
    } else {

        NameLength = *(Dstring + FieldLength - 1);
    }

    DebugTrace(( +1, Dbg,
                 "UdfCheckLegalCS0Dstring, Dstring %08x Length %02x FieldLength %02x (NameLength %02x)\n",
                 Dstring,
                 Length,
                 FieldLength,
                 NameLength ));

    //
    //  The string must be "compressed" in 8bit or 16bit chunks.  If it
    //  is in 16bit chunks, we better have an integral number of them -
    //  remember we have the compression ID, so the length will be odd.
    //
    
    if ((NameLength <= 1 &&
         DebugTrace(( 0, Dbg,
                      "UdfCheckLegalCS0Dstring, NameLength is too small!\n" ))) ||

        (NameLength > FieldLength &&
         DebugTrace(( 0, Dbg,
                      "UdfCheckLegalCS0Dstring, NameLength is bigger than the field itself!\n" ))) ||

        ((*Dstring != 8 && *Dstring != 16) &&
         DebugTrace(( 0, Dbg,
                      "UdfCheckLegalCS0Dstring, claims encoding %02x, unknown! (not 0x8 or 0x10)\n",
                      *Dstring ))) ||

        ((*Dstring == 16 && !FlagOn( NameLength, 1)) &&
         DebugTrace(( 0, Dbg,
                     "UdfCheckLegalCS0Dstring, NameLength not odd, encoding 0x10!\n" )))) {

        if (ReturnOnError) {

            DebugTrace(( -1, Dbg, "UdfCheckLegalCS0Dstring -> FALSE\n" ));

            return FALSE;
        }

        DebugTrace(( -1, Dbg, "UdfCheckLegalCS0Dstring -> raised status\n" ));

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    DebugTrace(( -1, Dbg, "UdfCheckLegalCS0Dstring -> TRUE\n" ));

    return TRUE;
}


VOID
UdfRenderNameToLegalUnicode (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING RenderedName
    )

/*++

Routine Description:

    This routine will take a Unicode string containing illegal characters and
    run it through the UDF standard algorithim to render it into a "legal"
    name.
    
    The short form is to convert all runs of illegal characters to "_" and tack
    on a hex representation of the CRC of the original name.  The algorithm is
    nearly directly lifted from the UDF (2.01 proposed!) standard, so apologies
    for the style clash.
    
Arguments:

    Name - the actual name
    
    RenderedName - the name rendered into legal characters
    
Return Value:

    BOOLEAN - TRUE if the expressions match, FALSE otherwise.

--*/

{
    INT16 index;
    INT16 targetIndex;
    INT16 crcIndex;
    INT16 extLen;
    INT16 nameLen;
    INT16 charLen;
    INT16 overlayBytes;
    INT16 bytesLeft;
    UNICODE_CHAR current;
    BOOLEAN needsCRC;
    BOOLEAN foundDot;
    UNICODE_CHAR ext[EXT_LEN];

    //
    //  So as to lift as directly as possible from the standard, chunk things around.
    //
 
    PWCHAR newName = RenderedName->Buffer;
    PWCHAR udfName = Name->Buffer;
    SHORT udfNameLen = Name->Length / sizeof(WCHAR);

    /* Remove trailing periods ('.') and spaces (' '), Windows     */
    /* does not like them.                                         */
    foundDot = FALSE;
    index = udfNameLen;
    while (index-- > 0) {
        if (udfName[index] == PERIOD)
            foundDot = TRUE;
        else if (udfName[index] != SPACE)
            break;
    }

    needsCRC = FALSE;
    bytesLeft = MAX_LEN;
    extLen = 0;

    /* If any trailing periods or spaces were found, a CRC code    */
    /* needs to be added to the resulting file name.               */
    nameLen = index + 1;
    if (nameLen < udfNameLen)
        needsCRC = TRUE;

    if (needsCRC == FALSE || foundDot == FALSE) {
        /* Look for an extension in the file name.  We do not      */
        /* need to look for one if there were any trailing periods */
        /* or spaces removed.                                      */
        INT16 endIndex;
        INT16 prevCharLen = 1;
        INT16 extBytes = 0;

        targetIndex = 0;
        index = nameLen;

        /* Determine how many bytes we need to scan to find the    */
        /* extension delimiter.  The extension has a maximum of    */
        /* five characters, but we do not want to scan past the    */
        /* beginning of the buffer.                                */
        endIndex = (udfNameLen > EXT_LEN + 1) ?
            udfNameLen - EXT_LEN - 1 : 1;

        /* Start at the end of the name and scan backward, looking */
        /* for the extension delimiter (".").                      */
        while (index-- > endIndex) {
            /* Get the character to test.                          */
            current = udfName[index];

            if (current == '.') {
                /* The extension delimiter was found, figure out   */
                /* how many characters the extension contains and  */
                /* the length of the resulting file name without   */
                /* the extension.                                  */
                extLen = nameLen - index - 1;
                nameLen = index;
                break;
            }

            /* Determine the byte length of the current character  */
            /* when converted to native format.                    */
            charLen = (IsFileNameCharLegal(current)) ?
                NativeCharLength(current) : 0;

            if (charLen == 0) {
                /* If the character byte length is zero, it is     */
                /* illegal or unprintable, place an underscore     */
                /* ("_") in the extension buffer if the previous   */
                /* character tested was legal.  Not that the       */
                /* characters placed in the extension buffer are   */
                /* in reverse order.                               */
                if (prevCharLen != 0) {
                    ext[targetIndex++] = ILLEGAL_CHAR_MARK;
                    extBytes++;
                }
            }
            else {
                /* The current character is legal and printable,   */
                /* put it in the extension buffer.  Note that the  */
                /* characters placed in the extension buffer are   */
                /* in reverse order.                               */
                ext[targetIndex++] = current;
                extBytes += charLen;
            }

            /* Save the byte length of the current character, so   */
            /* we can determine if it was a legal character during */
            /* the next test.                                      */
            prevCharLen = charLen;
        }

        /* If an extension was found, determine how many bytes     */
        /* remain in the file name buffer once we account for it.  */
        if (extLen > 0)
            bytesLeft -= extBytes + 1;
    }

    index = 0;
    targetIndex = 0;
    crcIndex = 0;
    overlayBytes = -1;
    while (index < nameLen && bytesLeft > 0) {
        /* Get the current character and convert it to upper case. */
        current = udfName[index];

        /* Determine if this is a valid file name char and         */
        /* calculate its corresponding native character byte       */
        /* length (zero if the char is not legal or undiplayable   */
        /* on this system).                                        */
        charLen = (IsFileNameCharLegal(current)) ?
            NativeCharLength(current) : 0;

        /* If the char is larger than the available space in the   */
        /* buffer, pretend it is undisplayable.                    */
        if (charLen > bytesLeft)
            charLen = 0;

        if (charLen == 0) {
            /* Undisplayable or illegal characters are substituted */
            /* with an underscore ("_"), and requires a CRC code   */
            /* appended to the mangled file name.                  */
            needsCRC = TRUE;
            charLen = 1;
            current = '_';

            /* Skip over any following undiplayable or illegal     */
            /* chars.                                              */
            while (index + 1 < udfNameLen &&
                (!IsFileNameCharLegal(udfName[index + 1]) ||
                NativeCharLength(udfName[index + 1]) == 0))
                index++;

            /* Terminate loop if at the end of the file name.      */
            if (index >= udfNameLen)
                break;
        }

        /* Assign the resulting char to the next index in the file */
        /* name buffer and determine how many native bytes are     */
        /* left.                                                   */
        newName[targetIndex++] = current;
        bytesLeft -= charLen;

        /* This figures out where the CRC code needs to start in   */
        /* the file name buffer.                                   */
        if (bytesLeft >= CRC_LEN) {
            /* If there is enough space left, just tack it onto    */
            /* the end.                                            */
            crcIndex = targetIndex;
        }
        else {
            /* If there is not enough space left, the CRC must     */
            /* overlay a character already in the file name        */
            /* buffer.  Once this condition has been met, the      */
            /* value will not change.                              */
            if (overlayBytes < 0) {
                /* Determine the index and save the length of the  */
                /* native character that is overlayed.  It is      */
                /* possible that the CRC might overlay half of a   */
                /* two-byte native character depending upon how    */
                /* the character boundaries line up.               */
                overlayBytes = (bytesLeft + charLen > CRC_LEN)
                    ? 1 : 0;
                crcIndex = targetIndex - 1;
            }
        }

        /* Advance to the next character.                          */
        index++;
    }

    /* If the scan did not reach the end of the file name, or the  */
    /* length of the file name is zero, a CRC code is needed.      */
    if (index < nameLen || index == 0)
        needsCRC = TRUE;

    /* If the name has illegal characters or and extension, it     */
    /* is not a DOS device name.                                   */
    if (needsCRC == FALSE && extLen == 0) {
        /* If this is the name of a DOS device, a CRC code should  */
        /* be appended to the file name.                           */
        if (IsDeviceName(udfName, udfNameLen))
            needsCRC = TRUE;
    }

    /* Append the CRC code to the file name, if needed.            */
    if (needsCRC) {
        /* Get the CRC value for the original Unicode string       */
        UINT16 udfCRCValue = UdfComputeCrc16Uni(udfName, udfNameLen);

        /* Determine the character index where the CRC should      */
        /* begin.                                                  */
        targetIndex = crcIndex;

        /* If the character being overlayed is a two-byte native   */
        /* character, replace the first byte with an underscore.   */
        if (overlayBytes > 0)
            newName[targetIndex++] = ILLEGAL_CHAR_MARK;

        /* Append the encoded CRC value with delimiter.            */
        newName[targetIndex++] = CRC_MARK;
        newName[targetIndex++] = UdfCrcChar[(udfCRCValue & 0xf000) >> 12];
        newName[targetIndex++] = UdfCrcChar[(udfCRCValue & 0x0f00) >> 8];
        newName[targetIndex++] = UdfCrcChar[(udfCRCValue & 0x00f0) >> 4];
        newName[targetIndex++] = UdfCrcChar[(udfCRCValue & 0x000f)];
    }


    /* If an extension was found, append it here.                  */
    if (extLen > 0) {
        /* Add the period ('.') for the extension delimiter.       */
        newName[targetIndex++] = PERIOD;

        /* Append the characters in the extension buffer.  They    */
        /* were stored in reverse order, so we need to begin with  */
        /* the last character and work forward.                    */
        while (extLen-- > 0)
            newName[targetIndex++] = ext[extLen];
    }

    ASSERT( (targetIndex * sizeof(WCHAR)) <= RenderedName->MaximumLength );
 
    RenderedName->Length = (USHORT) (targetIndex * sizeof(WCHAR));
}


BOOLEAN
UdfIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING CurrentName,
    IN PUNICODE_STRING SearchExpression,
    IN BOOLEAN Wild
    )

/*++

Routine Description:

    This routine will compare two Unicode strings.  We assume that if this
    is to be a case-insensitive search then they are already upcased.

Arguments:

    CurrentName - Filename from the disk.

    SearchExpression - Filename expression to use for match.
    
    Wild - True if wildcards are present in SearchExpression.

Return Value:

    BOOLEAN - TRUE if the expressions match, FALSE otherwise.

--*/

{
    BOOLEAN Match = TRUE;
    
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  If there are wildcards in the expression then we call the
    //  appropriate FsRtlRoutine.
    //

    if (Wild) {

        Match = FsRtlIsNameInExpression( SearchExpression,
                                         CurrentName,
                                         FALSE,
                                         NULL );

    //
    //  Otherwise do a direct memory comparison for the name string.
    //

    } else {

        if ((CurrentName->Length != SearchExpression->Length) ||
            (!RtlEqualMemory( CurrentName->Buffer,
                              SearchExpression->Buffer,
                              CurrentName->Length ))) {

            Match = FALSE;
        }
    }

    return Match;
}


FSRTL_COMPARISON_RESULT
UdfFullCompareNames (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    )

/*++

Routine Description:

    This function compares two names as fast as possible.  Note that since
    this comparison is case sensitive we can do a direct memory comparison.

Arguments:

    NameA & NameB - The names to compare.

Return Value:

    COMPARISON - returns

        LessThan    if NameA < NameB lexicalgraphically,
        GreaterThan if NameA > NameB lexicalgraphically,
        EqualTo     if NameA is equal to NameB

--*/

{
    ULONG i;
    ULONG MinLength = NameA->Length;
    FSRTL_COMPARISON_RESULT Result = LessThan;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Figure out the minimum of the two lengths
    //

    if (NameA->Length > NameB->Length) {

        MinLength = NameB->Length;
        Result = GreaterThan;

    } else if (NameA->Length == NameB->Length) {

        Result = EqualTo;
    }

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty, less than, and greater than
    //

    i = (ULONG) RtlCompareMemory( NameA->Buffer, NameB->Buffer, MinLength );

    if (i < MinLength) {

        //
        //  We know the offset of the first character which is different.
        //

        return ((NameA->Buffer[ i / 2 ] < NameB->Buffer[ i / 2 ]) ?
                 LessThan :
                 GreaterThan);
    }

    //
    //  The names match up to the length of the shorter string.
    //  The shorter string lexically appears first.
    //

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\nodetype.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code.  This code is the first CSHORT in the structure and is followed
    by a CSHORT containing the size, in bytes, of the structure.

    A single structure can fake polymorphism by using a set of node type codes.
    This is what the two FCB types do.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	20-May-1996
    Tom Jolly       [tomjolly]  21-Jan-2000

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _UDFNODETYPE_
#define _UDFNODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

#define UDFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0901)
#define UDFS_NTC_VCB                    ((NODE_TYPE_CODE)0x0902)
#define UDFS_NTC_FCB_INDEX              ((NODE_TYPE_CODE)0x0903)
#define UDFS_NTC_FCB_DATA               ((NODE_TYPE_CODE)0x0904)
#define UDFS_NTC_FCB_NONPAGED           ((NODE_TYPE_CODE)0x0905)
#define UDFS_NTC_CCB                    ((NODE_TYPE_CODE)0x0906)
#define UDFS_NTC_IRP_CONTEXT            ((NODE_TYPE_CODE)0x0907)
#define UDFS_NTC_IRP_CONTEXT_LITE       ((NODE_TYPE_CODE)0x0908)
#define UDFS_NTC_LCB                    ((NODE_TYPE_CODE)0x0909)
#define UDFS_NTC_PCB                    ((NODE_TYPE_CODE)0x090a)
#define UDFS_NTC_VMCB                   ((NODE_TYPE_CODE)0x090b)


typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#ifndef NodeType
#define NodeType(P) ((P) != NULL ? (*((PNODE_TYPE_CODE)(P))) : NTC_UNDEFINED)
#endif
#ifndef SafeNodeType
#define SafeNodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))
#endif

//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  UDFS_BUG_CHECK_ values defined below and then use UdfBugCheck to bugcheck
//  the system.
//
//  We also will define the debug trace level masks here.  Set UdfsDebugTraceLevel
//  to include a given filemask to see debug information from that module when
//  compiled with debugging.
//

//
//  Not all of these are actually used in UDFS. Perhaps this list will be
//  optimized when UDFS is functionally complete.
//

#define UDFS_BUG_CHECK_ALLOCSUP          (0x00010000)
#define UDFS_BUG_CHECK_CACHESUP          (0x00020000)
#define UDFS_BUG_CHECK_CLEANUP           (0x00030000)
#define UDFS_BUG_CHECK_CLOSE             (0x00040000)
#define UDFS_BUG_CHECK_CREATE            (0x00050000)
#define UDFS_BUG_CHECK_DEVCTRL           (0x00060000)
#define UDFS_BUG_CHECK_DEVIOSUP          (0x00070000)
#define UDFS_BUG_CHECK_DIRCTRL           (0x00080000)
#define UDFS_BUG_CHECK_DIRSUP            (0x00090000)
#define UDFS_BUG_CHECK_FILEINFO          (0x000a0000)
#define UDFS_BUG_CHECK_FILOBSUP          (0x000b0000)
#define UDFS_BUG_CHECK_FSCTRL            (0x000c0000)
#define UDFS_BUG_CHECK_FSPDISP           (0x000d0000)
#define UDFS_BUG_CHECK_LOCKCTRL          (0x000e0000)
#define UDFS_BUG_CHECK_NAMESUP           (0x000f0000)
#define UDFS_BUG_CHECK_PREFXSUP          (0x00100000)
#define UDFS_BUG_CHECK_READ              (0x00110000)
#define UDFS_BUG_CHECK_RESRCSUP          (0x00120000)
#define UDFS_BUG_CHECK_STRUCSUP          (0x00130000)
#define UDFS_BUG_CHECK_UDFDATA           (0x00140000)
#define UDFS_BUG_CHECK_UDFINIT           (0x00150000)
#define UDFS_BUG_CHECK_VERFYSUP          (0x00160000)
#define UDFS_BUG_CHECK_VMCBSUP           (0x00170000)
#define UDFS_BUG_CHECK_VOLINFO           (0x00180000)
#define UDFS_BUG_CHECK_WORKQUE           (0x00190000)
#define UDFS_BUG_CHECK_COMMON            (0x001a0000)
#define UDFS_BUG_CHECK_WRITE             (0x001b0000)
#define UDFS_BUG_CHECK_FLUSH             (0x001c0000)

#define UDFS_DEBUG_LEVEL_ALLOCSUP        (0x00000001)
#define UDFS_DEBUG_LEVEL_CACHESUP        (0x00000002)
#define UDFS_DEBUG_LEVEL_CLEANUP         (0x00000004)
#define UDFS_DEBUG_LEVEL_CLOSE           (0x00000008)
#define UDFS_DEBUG_LEVEL_CREATE          (0x00000010)
#define UDFS_DEBUG_LEVEL_DEVCTRL         (0x00000020)
#define UDFS_DEBUG_LEVEL_DEVIOSUP        (0x00000040)
#define UDFS_DEBUG_LEVEL_DIRCTRL         (0x00000080)
#define UDFS_DEBUG_LEVEL_DIRSUP          (0x00000100)
#define UDFS_DEBUG_LEVEL_FILEINFO        (0x00000200)
#define UDFS_DEBUG_LEVEL_FILOBSUP        (0x00000400)
#define UDFS_DEBUG_LEVEL_FSCTRL          (0x00000800)
#define UDFS_DEBUG_LEVEL_FSPDISP         (0x00001000)
#define UDFS_DEBUG_LEVEL_LOCKCTRL        (0x00002000)
#define UDFS_DEBUG_LEVEL_NAMESUP         (0x00004000)
#define UDFS_DEBUG_LEVEL_PREFXSUP        (0x00008000)
#define UDFS_DEBUG_LEVEL_READ            (0x00010000)
#define UDFS_DEBUG_LEVEL_RESRCSUP        (0x00020000)
#define UDFS_DEBUG_LEVEL_STRUCSUP        (0x00040000)
#define UDFS_DEBUG_LEVEL_UDFDATA         (0x00080000)
#define UDFS_DEBUG_LEVEL_UDFINIT         (0x00100000)
#define UDFS_DEBUG_LEVEL_VERFYSUP        (0x00200000)
#define UDFS_DEBUG_LEVEL_VMCBSUP         (0x00400000)
#define UDFS_DEBUG_LEVEL_VOLINFO         (0x00800000)
#define UDFS_DEBUG_LEVEL_WORKQUE         (0x01000000)
#define UDFS_DEBUG_LEVEL_COMMON          (0x02000000)
#define UDFS_DEBUG_LEVEL_WRITE           (0x04000000)
#define UDFS_DEBUG_LEVEL_FLUSH           (0x08000000)

//
//  Use UNWIND for reports from exception handlers.
//

#define UDFS_DEBUG_LEVEL_UNWIND          (0x80000000)

#define UdfBugCheck(A,B,C) { KeBugCheckEx(UDFS_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }

#ifndef BUILDING_FSKDEXT

//
//  The following are the pool tags for UDFS memory allocations
//

#define TAG_CCB                         'xfdU'
#define TAG_CDROM_TOC                   'tfdU'
#define TAG_CRC_TABLE                   'CfdU'
#define TAG_ENUM_EXPRESSION             'efdU'
#define TAG_FCB_DATA                    'dfdU'
#define TAG_FCB_INDEX                   'ifdU'
#define TAG_FCB_NONPAGED                'FfdU'
#define TAG_FID_BUFFER                  'DfdU'
#define TAG_FILE_NAME                   'ffdU'
#define TAG_GENERIC_TABLE               'TfdU'
#define TAG_IO_BUFFER                   'bfdU'
#define TAG_IO_CONTEXT                  'IfdU'
#define TAG_IRP_CONTEXT                 'cfdU'
#define TAG_IRP_CONTEXT_LITE            'LfdU'
#define TAG_LCB                         'lfdU'
#define TAG_PCB                         'pfdU'
#define TAG_SHORT_FILE_NAME             'SfdU'
#define TAG_VPB                         'vfdU'
#define TAG_SPARING_MCB                 'sfdU'

#define TAG_NSR_FSD                     '1fdU'
#define TAG_NSR_VSD                     '2fdU'
#define TAG_NSR_VDSD                    '3fdU'

#endif

#endif // _UDFNODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\pnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    Pnp.c

Abstract:

    This module implements the Plug and Play routines for UDFS called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Jul-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_PNP)

NTSTATUS
UdfPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
UdfPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
UdfPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
UdfPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
UdfPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonPnp)
#pragma alloc_text(PAGE, UdfPnpCancelRemove)
#pragma alloc_text(PAGE, UdfPnpQueryRemove)
#pragma alloc_text(PAGE, UdfPnpRemove)
#pragma alloc_text(PAGE, UdfPnpSurpriseRemove)
#endif


NTSTATUS
UdfCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing PnP operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    
    PIO_STACK_LOCATION IrpSp;

    PVOLUME_DEVICE_OBJECT OurDeviceObject;
    PVCB Vcb;

    //
    //  Get the current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Find our Vcb.  This is tricky since we have no file object in the Irp.
    //

    OurDeviceObject = (PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject;

    //
    //  Make sure this device object really is big enough to be a volume device
    //  object.  If it isn't, we need to get out before we try to reference some
    //  field that takes us past the end of an ordinary device object.
    //
    
    if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
        NodeType( &OurDeviceObject->Vcb ) != UDFS_NTC_VCB) {
        
        //
        //  We were called with something we don't understand.
        //
        
        Status = STATUS_INVALID_PARAMETER;
        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Force all PnP operations to be synchronous.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    Vcb = &OurDeviceObject->Vcb;

    //
    //  Case on the minor code.
    //
    
    switch ( IrpSp->MinorFunction ) {

        case IRP_MN_QUERY_REMOVE_DEVICE:
            
            Status = UdfPnpQueryRemove( IrpContext, Irp, Vcb );
            break;
        
        case IRP_MN_SURPRISE_REMOVAL:
        
            Status = UdfPnpSurpriseRemove( IrpContext, Irp, Vcb );
            break;

        case IRP_MN_REMOVE_DEVICE:

            Status = UdfPnpRemove( IrpContext, Irp, Vcb );
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
    
            Status = UdfPnpCancelRemove( IrpContext, Irp, Vcb );
            break;

        default:
    
            //
            //  Just pass the IRP on.  As we do not need to be in the
            //  way on return, ellide ourselves out of the stack.
            //
            
            IoSkipCurrentIrpStackLocation( Irp );
    
            Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);
            
            //
            //  Cleanup our Irp Context.  The driver has completed the Irp.
            //
        
            UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
            
            break;
    }
        
    return Status;
}


NTSTATUS
UdfPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP query remove operation.  The filesystem
    is responsible for answering whether there are any reasons it sees
    that the volume can not go away (and the device removed).  Initiation
    of the dismount begins when we answer yes to this question.
    
    Query will be followed by a Cancel or Remove.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being queried.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;

    //
    //  Having said yes to a QUERY, any communication with the
    //  underlying storage stack is undefined (and may block)
    //  until the bounding CANCEL or REMOVE is sent.
    //

    //
    //  Acquire the global resource so that we can try to vaporize
    //  the volume, and the vcb resource itself.
    //
    
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    Status = UdfLockVolumeInternal( IrpContext, Vcb, NULL );

    UdfReleaseVcb( IrpContext, Vcb );
    UdfAcquireUdfData( IrpContext );
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    if (NT_SUCCESS( Status )) {

        //
        //  We need to pass this down before starting the dismount, which
        //  could disconnect us immediately from the stack.
        //
        
        //
        //  Get the next stack location, and copy over the stack location
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        //  Set up the completion routine
        //
    
        KeInitializeEvent( &Event, NotificationEvent, FALSE );
        IoSetCompletionRoutine( Irp,
                                UdfPnpCompletionRoutine,
                                &Event,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Send the request and wait.
        //

        Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

        if (Status == STATUS_PENDING) {

            KeWaitForSingleObject( &Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = Irp->IoStatus.Status;
        }

        //
        //  Now if no one below us failed already, initiate the dismount
        //  on this volume, make it go away.  PnP needs to see our internal
        //  streams close and drop their references to the target device.
        //
        //  Since we were able to lock the volume, we are guaranteed to
        //  move this volume into dismount state and disconnect it from
        //  the underlying storage stack.  The force on our part is actually
        //  unnecesary, though complete.
        //
        //  What is not strictly guaranteed, though, is that the closes
        //  for the metadata streams take effect synchronously underneath
        //  of this call.  This would leave references on the target device
        //  even though we are disconnected!
        //

        if (NT_SUCCESS( Status )) {
            
            VcbPresent = UdfCheckForDismount( IrpContext, Vcb, TRUE );
    
            ASSERT( !VcbPresent || Vcb->VcbCondition == VcbDismountInProgress );
        }
    }
    
    //
    //  Release the Vcb if it could still remain.
    //
    //  Note: if everything else succeeded and the Vcb is persistent because the
    //  internal streams did not vaporize, we really need to pend this IRP off on
    //  the side until the dismount is completed.  I can't think of a reasonable
    //  case (in UDFS) where this would actually happen, though it might still need
    //  to be implemented.
    //
    //  The reason this is the case is that handles/fileobjects place a reference
    //  on the device objects they overly.  In the filesystem case, these references
    //  are on our target devices.  PnP correcly thinks that if references remain
    //  on the device objects in the stack that someone has a handle, and that this
    //  counts as a reason to not succeed the query - even though every interrogated
    //  driver thinks that it is OK.
    //
    
    ASSERT( !(NT_SUCCESS( Status ) && VcbPresent && Vcb->VcbReference != 0));
    
    if (VcbPresent) {

        UdfReleaseVcb( IrpContext, Vcb );
    }

    UdfReleaseUdfData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP if neccesary.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
UdfPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP remove operation.  This is our notification
    that the underlying storage device for the volume we have is gone, and
    an excellent indication that the volume will never reappear. The filesystem
    is responsible for initiation or completion the dismount.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;
    
    //
    //  REMOVE - a storage device is now gone.  We either got
    //  QUERY'd and said yes OR got a SURPRISE OR a storage
    //  stack failed to spin back up from a sleep/stop state
    //  (the only case in which this will be the first warning).
    //
    //  Note that it is entirely unlikely that we will be around
    //  for a REMOVE in the first two cases, as we try to intiate
    //  dismount.
    //
    
    //
    //  Acquire the global resource so that we can try to vaporize
    //  the volume, and the vcb resource itself.
    //
    
    UdfAcquireUdfData( IrpContext );
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  The device will be going away.  Remove our lock and find
    //  out if we ever had one in the first place.
    //

    Status = UdfUnlockVolumeInternal( IrpContext, Vcb, NULL );

    //
    //  If the volume had not been locked, we must invalidate the
    //  volume to ensure it goes away properly.  The remove will
    //  succeed.
    //

    if (!NT_SUCCESS( Status )) {

        UdfLockVcb( IrpContext, Vcb );
        
        if (Vcb->VcbCondition != VcbDismountInProgress) {
            
            UdfSetVcbCondition( Vcb, VcbInvalid);
        }
        
        UdfUnlockVcb( IrpContext, Vcb );
        
        Status = STATUS_SUCCESS;
    }
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            UdfPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }

    //
    //  Now make our dismount happen.  This may not vaporize the
    //  Vcb, of course, since there could be any number of handles
    //  outstanding if we were not preceeded by a QUERY.
    //
    //  PnP will take care of disconnecting this stack if we
    //  couldn't get off of it immediately.
    //

    VcbPresent = UdfCheckForDismount( IrpContext, Vcb, TRUE );

    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        UdfReleaseVcb( IrpContext, Vcb );
    }

    UdfReleaseUdfData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
UdfPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP surprise remove operation.  This is another
    type of notification that the underlying storage device for the volume we
    have is gone, and is excellent indication that the volume will never reappear.
    The filesystem is responsible for initiation or completion the dismount.
    
    For the most part, only "real" drivers care about the distinction of a
    surprise remove, which is a result of our noticing that a user (usually)
    physically reached into the machine and pulled something out.
    
    Surprise will be followed by a Remove when all references have been shut down.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;
    
    //
    //  SURPRISE - a device was physically yanked away without
    //  any warning.  This means external forces.
    //
    
    UdfAcquireUdfData( IrpContext );
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
        
    //
    //  Invalidate the volume right now.
    //
    //  The intent here is to make every subsequent operation
    //  on the volume fail and grease the rails toward dismount.
    //  By definition there is no going back from a SURPRISE.
    //
        
    UdfLockVcb( IrpContext, Vcb );
    
    if (Vcb->VcbCondition != VcbDismountInProgress) {

        UdfSetVcbCondition( Vcb, VcbInvalid);
    }
    
    UdfUnlockVcb( IrpContext, Vcb );
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            UdfPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }
    
    //
    //  Now make our dismount happen.  This may not vaporize the
    //  Vcb, of course, since there could be any number of handles
    //  outstanding since this is an out of band notification.
    //

    VcbPresent = UdfCheckForDismount( IrpContext, Vcb, TRUE );
    
    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        UdfReleaseVcb( IrpContext, Vcb );
    }

    UdfReleaseUdfData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
UdfPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP cancel remove operation.  This is our
    notification that a previously proposed remove (query) was eventually
    vetoed by a component.  The filesystem is responsible for cleaning up
    and getting ready for more IO.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    //
    //  CANCEL - a previous QUERY has been rescinded as a result
    //  of someone vetoing.  Since PnP cannot figure out who may
    //  have gotten the QUERY (think about it: stacked drivers),
    //  we must expect to deal with getting a CANCEL without having
    //  seen the QUERY.
    //
    //  For UDFS, this is quite easy.  In fact, we can't get a
    //  CANCEL if the underlying drivers succeeded the QUERY since
    //  we disconnect the Vpb on our dismount initiation.  This is
    //  actually pretty important because if PnP could get to us
    //  after the disconnect we'd be thoroughly unsynchronized
    //  with respect to the Vcb getting torn apart - merely referencing
    //  the volume device object is insufficient to keep us intact.
    //
    
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    
    //
    //  Unlock the volume.  This is benign if we never had seen
    //  a QUERY.
    //

    (VOID) UdfUnlockVolumeInternal( IrpContext, Vcb, NULL );

    UdfReleaseVcb( IrpContext, Vcb );

    //
    //  Send the request.  The underlying driver will complete the
    //  IRP.  Since we don't need to be in the way, simply ellide
    //  ourselves out of the IRP stack.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )
{
    PKEVENT Event = (PKEVENT) Contxt;

    KeSetEvent( Event, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\udf.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    Udf.h

Abstract:

    This module contains all definitions specified by the OSTA UDF standard which
    are not defined in ISO 13346 and associated errta.  UDF is a subset of ISO 13346
    which restricts many facets of the ISO standard and is currently standardized
    by the Optical Storage Technology Association (http://www.osta.org).  Some
    aspects of the structures we read may seem illogical unless viewed in this light.

    Unless otherwise specified, section references will be to ISO 13346.

    Also unless otherwise specified, all descriptors mentioned will be sector aligned 

    A UDF volume is recognized by searching the Volume Recognition Area (2/8.3) for a
    Volume Structure Descriptor (2/9.1) which advertises itself as NSR02, the filesystem
    format specified by ISO 13346 section 4.  This is aligned to match ISO 9660, and the
    first descriptor may in fact be a 9660 PVD.  ISO 13346 descriptors are bounded by
    a Begin Extended Area descriptor (2/9.2) and a Terminate Extended Area descriptor
    (2/9.3).

    +-------+-------+     +-------+     +-------+
    |       |       |     |       |     |       |
    | CD001 | BEA01 | ... | NSR02 | ... | TEA01 |
    |       |       |     |       |     |       |
    +-------+-------+     +-------+     +-------+

    A UDF volume is then discovered by looking for an Anchor Volume Descriptor (3/10.2),
    which reveals the location of a pair of extents of the physical volume that contain
    copies of the Volume Descriptor Sequence.  Both of these copies are defined to be
    equivalent (duplication is intended for diasaster recovery).

    +-------+              +------------------------------------+
    |       | -----------> |                                    |
    |  AVD  |              |   Main Volume Descriptor Sequence  |
    |       | ----+        |                                    |
    +-------+     |        +------------------------------------+
                  |         
                  |        +------------------------------------+
                  |        |                                    | 
                  +------> | Reserve Volume Descriptor Sequence |
                           |                                    |
                           +------------------------------------+

    An ISO 13346 logical (mountable) volume is composed of a number Np of physical partitions
    spread across a number Nd of physical volumes (media), all of which may be multiply
    referenced to create a numbed Nv of logical volumes.  While ISO 13346 allows this level of
    complexity, UDF restricts as follows: Nv = 1 and Np = Nd except if Nd = 1 then perhaps
    Np = 2 and one partition is read/write while the other is readonly.  There are three levels
    of conforming implementations which are defined by ISO 1336 in 3/11 which progress from 1,
    a restricted Nd = 1, to 3 where Nd > 1.  This is a readonly level 2 implementation, which
    is an unrestricted single physical media implementation - other than those imposed by UDF.

    A Volume Descriptor Sequence is composed of a number of descriptors which collectively nail
    down a volume:

        Primary Volume Descriptor           (PVD)  Identification of the physical media and its
        (3/10.1)                                     relation to a volume set.

        Volume Descriptor Pointer           (VSD)  Identification of a continuing extent of the Volume
        (3/10.3)                                    Descriptor Sequence (the VDS need not be a single
                                                    extent).
                                                
        Implementation Use Volume Desciptor (IUVD) Exactly that.
        (3/10.4)

        Partition Descriptor                (PD)   Identification of a linear extent of sectors
        (3/10.5)                                    on a physical media (type 1) or an implementation
                                                    defined object (type 2).

        Logical Volume Descriptor           (LVD)  Identification of a mountable volume by
        (3/10.6)                                    referring to partition(s) and a location for
                                                    a File Set Descriptor.
                                                
        Unallocated Space Descriptor        (USD)  Identification of an unallocated extents of the
        (3/10.8)                                    media which could be added to existing partitions
                                                    or allocated through new partitions.

        Terminating Descriptor              (TD)   A method of terminating the Volume Descriptor
        (3/10.9)                                    Sequence.  A VDS may also be terminated by an
                                                    unrecorded sector or running to the end of an
                                                    extent.

    An ISO 13346 volume set is a grouping of physical media, identified collectively by examining
    the PVD of each unit. A Volume Descriptor Sequence is recorded on each constituent of the volume
    set, but only the volume with the highest Volume Sequence Number may contain LVD.  An LVD may
    refer to any PD on any member of the volume set.

    Each descriptor contains a Volume Sequence Number which allows an otherwise identification
    equivalent descriptor (i.e., specifies the same Partition Number (for PD), same Logical
    Volume Identifier (for LVD), etc. (3/8.4.3)) to override one of lower VSN.
    
    So, a picture of what a Volume Descriptor Sequence could look like is
    
    +------+------+------+------+------+
    |      |      |      |      |      |
    | PVD  | LVD  |  PD  |  PD  |  VDP |
    |      |      |      |      |      |
    +------+------+------+------+------+
                                    |
                                    |  +------+------+------+------+
                                    |  |      |      |      |      |
                                    +->| USD  | IUVD | IUVD |  TD  |
                                       |      |      |      |      |
                                       +------+------+------+------+
                                       
    The LVD points to a File Set Descriptor (4/14.1), which finally points to a root directory.
    
// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   10-Jul-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#ifndef _UDF_
#define _UDF_

#include <iso13346.h>

//
//  This is the version of UDF that we recognize, per the Domain Identifier
//  specification in UDF 2.1.5.3.
//
//  The values below indicate we understand UDF 2.01.  We will also define
//  specific revisions so that we can assert correctness for some structures
//  that we know appeared for the first time in certain specifications.
//
//

#define UDF_VERSION_100         0x0100
#define UDF_VERSION_101         0x0101
#define UDF_VERSION_102         0x0102
#define UDF_VERSION_150         0x0150
#define UDF_VERSION_200         0x0200
#define UDF_VERSION_201         0x0201

#define UDF_VERSION_RECOGNIZED  UDF_VERSION_201

#define UDF_VERSION_MINIMUM     UDF_VERSION_100


//
//  Method 2 Fixup.
//
//  This really isn't UDF, but for lack of a better place ... and since we are doing
//  the work for UDF only.  In the filesystem.  Sigh.
//
//  Various bad CD-ROM units, when reading fixed-packet CD-RW media, fail to map out
//  the runin/out  blocks that follow each packet of 32 sectors on the media.  As a
//  result, we have to fixup all of the byte offsets to read the image.
//
//  Note: fixed packet. Variable packet discs do have the runin/out exposed, but
//  imaging software will have realized this and numbered sectors right.
//
//  Normally we would refuse to deal with this garbage, but Adaptec made the decision
//  for us by having their reader handle these drives.  So that we don't have to deal
//  with endless "but it works with Adaptec", we've got to do it here.
//
//  This is really depressing.
//

#define CDRW_PACKET_LENGTH              32
#define CDRW_RUNOUT_LENGTH              7

//
//  LONGLONG UdfMethod2TransformByteOffset (
//      PVCB Vcb,
//      LONGLONG ByteOffset
//      )
//
//  Takes a normal byteoffset and adds in the differential implied by the number
//  of runout areas it spans.
//

#define UdfMethod2TransformByteOffset(V, BO)                                \
    ((BO) + LlBytesFromSectors((V), ((LlSectorsFromBytes((V), BO) / CDRW_PACKET_LENGTH) * CDRW_RUNOUT_LENGTH)))

#define UdfMethod2TransformSector(V, S)                                     \
    ((S) + ((S) / CDRW_PACKET_LENGTH) * CDRW_RUNOUT_LENGTH)

//
//  ULONG UdfMethod2NextRunoutInSectors (
//      PVCB Vcb,
//      LONGLONG ByteOffset
//      )
//
//  Takes a normal byteoffset and figures out how many sectors remain until the next
//  (forward) runout area.
//

#define UdfMethod2NextRunoutInSectors(V, BO)                                \
    (CDRW_PACKET_LENGTH - (LlSectorsFromBytes((V), (BO)) % CDRW_PACKET_LENGTH))


//
//  Generic constants
//

#define BYTE_COUNT_8_DOT_3                          (24)

//
//  Constants for the name transform algorithm.  Names greater than MAXLEN will be
//  rendered.  MAX_PATH comes from user-side includes that we don't get here.
//
//  UDF specifies rules for converting names from illegal->legal forms for a given OS.
//  The rest of the constants/macros are used to convert the clipped code for these
//  algorithims into a form we can directly use.
//
//  The NativeCharLength question is really not answerable for the non-8.3 case, since
//  NT internally is completely ignorant of the eventual destination of the name.
//

#define MAX_PATH            260

#define MAX_LEN             (MAX_PATH - 5)
#define EXT_LEN             5
#define CRC_LEN             5

#define DOS_NAME_LEN        8
#define DOS_EXT_LEN         3
#define DOS_CRC_LEN         4

#define IsFileNameCharLegal(c)      UdfIsCharacterLegal(c)
#define IsDeviceName(s, n)          FALSE
#define NativeCharLength(c)         1
#define UnicodeToUpper(c)           (c)

#define INT16 SHORT
#define UINT16 USHORT
#define UNICODE_CHAR WCHAR

#define PERIOD              (L'.')
#define SPACE               (L' ')
#define CRC_MARK            (L'#')
#define ILLEGAL_CHAR_MARK   (L'_')

//
//  Place a non-tail recursable depth limit on ICB hierarchies.  We cannot read
//  ICB hierarchies that are deeper than this.
//

#define UDF_ICB_RECURSION_LIMIT 10


//
//  Entity ID (REGID) Suffixes are used in UDF to encode extra information away from
//  the string data in the Identifier.  See UDF 2.1.4.2.
//

//
//  A Domain Suffix is encoded for the Logical Volume Descriptor and File Set Descriptor
//

typedef struct _UDF_SUFFIX_DOMAIN {

    USHORT UdfRevision;
    UCHAR Flags;
    UCHAR Reserved[5];

} UDF_SUFFIX_DOMAIN, *PUDF_SUFFIX_DOMAIN;

#define UDF_SUFFIX_DOMAIN_FLAG_HARD_WRITEPROTECT 0x01
#define UDF_SUFFIX_DOMAIN_FLAG_SOFT_WRITEPROTECT 0x02

//
//  A UDF Suffix is encoded for extended attributes, Implementation Use Volume
//  Descriptors and VATs (among others).
//

typedef struct _UDF_SUFFIX_UDF {

    USHORT UdfRevision;
    UCHAR OSClass;
    UCHAR OSIdentifier;
    UCHAR Reserved[4];

} UDF_SUFFIX_UDF, *PUDF_SUFFIX_UDF;

//
//  An Implementation Suffix is encoded for almost every other structure containing
//  an Entity ID.
//

typedef struct _UDF_SUFFIX_IMPLEMENTATION {

    UCHAR OSClass;
    UCHAR OSIdentifier;
    UCHAR ImplementationUse[6];

} UDF_SUFFIX_IMPLEMENTATION, *PUDF_SUFFIX_IMPLEMENTATION;

//
//  OS Classes and Identifiers are defined by OSTA as of UDF 1.50
//
//  We also take the minor liberty of defining an invalid set for
//  the purposes of hinting internally that we don't care about them.
//  It is unlikely that UDF will ever hit 255, even though these are
//  technically avaliable for allocation.
//

#define OSCLASS_INVALID             255
#define OSIDENTIFIER_INVALID        255


#define OSCLASS_UNDEFINED           0
#define OSCLASS_DOS                 1
#define OSCLASS_OS2                 2
#define OSCLASS_MACOS               3
#define OSCLASS_UNIX                4
#define OSCLASS_WIN9X               5
#define OSCLASS_WINNT               6

#define OSIDENTIFIER_DOS_DOS        0

#define OSIDENTIFIER_OS2_OS2        0

#define OSIDENTIFIER_MACOS_MACOS7   0

#define OSIDENTIFIER_UNIX_GENERIC   0
#define OSIDENTIFIER_UNIX_AIX       1
#define OSIDENTIFIER_UNIX_SOLARIS   2
#define OSIDENTIFIER_UNIX_HPUX      3
#define OSIDENTIFIER_UNIX_IRIX      4
#define OSIDENTIFIER_UNIX_LINUX     5
#define OSIDENTIFIER_UNIX_MKLINUX   6
#define OSIDENTIFIER_UNIX_FREEBSD   7

#define OSIDENTIFIER_WIN9X_WIN95    0

#define OSIDENTIFIED_WINNT_WINNT    0


//
//  Character Set Lists are actually just a 32bit word where each bit N on/off specifies
//  that Character Set N is used on the volume.  Per UDF, the only character set we
//  recognize is CS0, so construct a bitmask Character Set List for that. (1/7.2.11)
//

#define UDF_CHARSETLIST 0x00000001


//
//  Generic partition map for UDF.  This allows partition maps to be typed and the
//  UDF entity identifier for the various type 2 maps to be inspected.
//

typedef struct _PARTMAP_UDF_GENERIC {

    UCHAR       Type;                   //  Partition Map Type = 2
    UCHAR       Length;                 //  Partition Map Length = 64
    UCHAR       Reserved2[2];           //  Reserved Padding
    REGID       PartID;                 //  Paritition Entity Identifier
    UCHAR       Reserved24[28];         //  Reserved Padding

} PARTMAP_UDF_GENERIC, *PPARTMAP_UDF_GENERIC;

//
//  UDF 1.50 CD UDF Partition Types
//

//////////
//  UDF Virtual Partitions are identified via a type 2 partition map of the following form.
//////////

typedef struct _PARTMAP_VIRTUAL {

    UCHAR       Type;                   //  Partition Map Type = 2
    UCHAR       Length;                 //  Partition Map Length = 64
    UCHAR       Reserved2[2];           //  Reserved Padding
    REGID       PartID;                 //  Paritition Entity Identifier
                                        //   == UdfVirtualPartitionDomainIdentifier
    USHORT      VolSetSeq;              //  Volume Set Sequence
    USHORT      Partition;              //  Related Partition
    UCHAR       Reserved40[24];         //  Reserved Padding

} PARTMAP_VIRTUAL, *PPARTMAP_VIRTUAL;


//
//  UDF 2.00 CD UDF VAT Header
//
//  Note that values in this record supedcede those in the LDV or LVID
//

typedef struct _VAT_HEADER {

    USHORT      Length;                 //  Header length = 152 + ImpUseLength
    USHORT      ImpUseLength;
    
    UCHAR       VolumeID[128];
    
    ULONG       PreviousVatIcbLbn;
    
    ULONG       FileFidCount;
    ULONG       NonParentDirFidCount;
    
    USHORT      MinUdfReadRevision;
    USHORT      MinUdfWriteRevision;
    USHORT      MaxUdfWriteRevision;
    USHORT      Reserved;

    UCHAR       ImpUse[0];
    
    //  VAT entries immediately follow impuse data.
    //
    //  UINT32  Lba of virtual sector 0
    //  UINT32  Lba of virtual sector 1
    //  ...    

} VAT_HEADER, *PVAT_HEADER;


//
//  A UDF 1.50 VAT minimally contains a mapping for a single block, the REGID identifying
//  the VAT, and the identification of a previous VAT ICB location.  
//
//  A UDF 2.0x VAT minimally contains a VAT header,  and a mapping for a single block.
//
//  We also identify
//  an arbitrary sanity limit that the VAT isn't bigger than 8mb since it is extremely
//  difficult to imagine such a VAT existing in practice since each sector describes
//  (on most of our media) 2048/4 = 512 entries ... meaning at 8mb the VAT would
//  describe ~2^21 blocks.  4/12/01 Increased for DVD-R.
//

#define UDF_CDUDF_TRAILING_DATA_SIZE    (sizeof(REGID) + sizeof(ULONG))

#define UDF_CDUDF_MINIMUM_150_VAT_SIZE  (sizeof(ULONG) + UDF_CDUDF_TRAILING_DATA_SIZE)
#define UDF_CDUDF_MINIMUM_20x_VAT_SIZE  (sizeof(ULONG) + sizeof( VAT_HEADER))

#define UDF_CDUDF_MAXIMUM_VAT_SIZE      (16 * 1024 * 1024)

//////////
//  UDF Sparable Partitions are identified via a type 2 partition map of the following form.
//////////

typedef struct _PARTMAP_SPARABLE {

    UCHAR       Type;                   //  Partition Map Type = 2
    UCHAR       Length;                 //  Partition Map Length = 64
    UCHAR       Reserved2[2];           //  Reserved Padding
    REGID       PartID;                 //  Paritition Entity Identifier
                                        //   == UdfSparablePartitionDomainIdentifier
    USHORT      VolSetSeq;              //  Volume Set Sequence
    USHORT      Partition;              //  Related Partition
    USHORT      PacketLength;           //  Packet Length == 32 (number of data blocks
                                        //   per packet)
    UCHAR       NumSparingTables;       //  Number of pparing tables on the media
    UCHAR       Reserved43;             //  Reserved Padding
    ULONG       TableSize;              //  Size of sparing tables
    ULONG       TableLocation[4];       //  Location of each sparing table (each
                                        //   sparing table should be in a distinct packet)

} PARTMAP_SPARABLE, *PPARTMAP_SPARABLE;

//
//  Sparing tables lead off with this header structure.
//

typedef struct _SPARING_TABLE_HEADER {

    DESTAG      Destag;                 //  Ident = 0
    REGID       RegID;                  //  == UdfSparingTableIdentifier
    USHORT      TableEntries;           //  Number of entries in the table
    USHORT      Reserved50;             //  Reserved Padding
    ULONG       Sequence;               //  Sequence Number (incremented on rewrite of table)

} *PSPARING_TABLE_HEADER, SPARING_TABLE_HEADER;

//
//  Sparing table map entries.
//

typedef struct _SPARING_TABLE_ENTRY {

    ULONG Original;                     //  Original LBN
    ULONG Mapped;                       //  Mapped PSN

} *PSPARING_TABLE_ENTRY, SPARING_TABLE_ENTRY;

//
//  Fixed values for original sectors, indicating that either the
//  mapped packet is avaliable for sparing use or is defective.
//

#define UDF_SPARING_AVALIABLE           0xffffffff
#define UDF_SPARING_DEFECTIVE           0xfffffff0
 
//
//  The unit of media in each sparing packet is fixed at 32 physical sectors.
//

#define UDF_SPARING_PACKET_LENGTH       CDRW_PACKET_LENGTH

//
//  Additional Values defined in UDF,   over and above those in ISO13346.h
//

//  ICBTAG_FILE_T_... - Values for icbtag_FileType

#define ICBTAG_FILE_T_VAT       248     // VAT (new format - UDF 2.00 and later)
#define ICBTAG_FILE_T_REALTIME  249     // Real Time File (UDF 2.01, 2.3.5.2.1)


#endif // _UDF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\udfdata.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    UdfData.c

Abstract:

    This module declares the global data used by the Udfs file system.

    This module also handles the dispath routines in the Fsd threads as well as
    handling the IrpContext and Irp through the exception path.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   24-May-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_UDFDATA)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_UDFDATA)

//
//  Global data structures
//

UDF_DATA UdfData;
FAST_IO_DISPATCH UdfFastIoDispatch;

//
//  Debug trace levels
//

#ifdef UDF_SANITY

//
//  For UdfDebugTrace (only live in checked builds) to be able to swing
//  variable argument lists and varargs printfs.
//

#include <stdarg.h>
#include <stdio.h>

BOOLEAN UdfTestTopLevel = TRUE;
BOOLEAN UdfTestRaisedStatus = TRUE;

LONG UdfDebugTraceLevel = 0;
LONG UdfDebugTraceIndent = 0;

//
//  Control whether UdfVerifyDescriptor will only emit info on failure (FALSE) or
//  all of the time (TRUE).
//

BOOLEAN UdfNoisyVerifyDescriptor = FALSE;

#endif

//
//  This is the time reported for any files whose FE is corrupt during
//  directory enumeration.
//

LARGE_INTEGER UdfCorruptFileTime;

//
//  Reserved directory strings.
//

WCHAR UdfUnicodeSelfArray[] = { L'.' };
WCHAR UdfUnicodeParentArray[] = { L'.', L'.' };

UNICODE_STRING UdfUnicodeDirectoryNames[] = {
    { sizeof(UdfUnicodeSelfArray), sizeof(UdfUnicodeSelfArray), UdfUnicodeSelfArray},
    { sizeof(UdfUnicodeParentArray), sizeof(UdfUnicodeParentArray), UdfUnicodeParentArray}
    };

//
//  Identifier strings defined by UDF.
//

CHAR UdfCS0IdentifierArray[] = { 'O', 'S', 'T', 'A', ' ',
                                 'C', 'o', 'm', 'p', 'r', 'e', 's', 's', 'e', 'd', ' ',
                                 'U', 'n', 'i', 'c', 'o', 'd', 'e' };

STRING UdfCS0Identifier = {
    sizeof(UdfCS0IdentifierArray),
    sizeof(UdfCS0IdentifierArray),
    UdfCS0IdentifierArray
    };

CHAR UdfDomainIdentifierArray[] = { '*', 'O', 'S', 'T', 'A', ' ',
                                    'U', 'D', 'F', ' ',
                                    'C', 'o', 'm', 'p', 'l', 'i', 'a', 'n', 't' };

STRING UdfDomainIdentifier = {
    sizeof(UdfDomainIdentifierArray),
    sizeof(UdfDomainIdentifierArray),
    UdfDomainIdentifierArray
    };

CHAR UdfVirtualPartitionDomainIdentifierArray[] = { '*', 'U', 'D', 'F', ' ',
                                                    'V', 'i', 'r', 't', 'u', 'a', 'l', ' ',
                                                    'P', 'a', 'r', 't', 'i', 't', 'i', 'o', 'n' };

STRING UdfVirtualPartitionDomainIdentifier = {
    sizeof(UdfVirtualPartitionDomainIdentifierArray),
    sizeof(UdfVirtualPartitionDomainIdentifierArray),
    UdfVirtualPartitionDomainIdentifierArray 
    };

CHAR UdfVatTableIdentifierArray[] = { '*', 'U', 'D', 'F', ' ',
                                      'V', 'i', 'r', 't', 'u', 'a', 'l', ' ',
                                      'A', 'l', 'l', 'o', 'c', ' ',
                                      'T', 'b', 'l' };

STRING UdfVatTableIdentifier = {
    sizeof(UdfVatTableIdentifierArray),
    sizeof(UdfVatTableIdentifierArray),
    UdfVatTableIdentifierArray
    };
                                    
CHAR UdfSparablePartitionDomainIdentifierArray[] = { '*', 'U', 'D', 'F', ' ',
                                                     'S', 'p', 'a', 'r', 'a', 'b', 'l', 'e', ' ',
                                                     'P', 'a', 'r', 't', 'i', 't', 'i', 'o', 'n' };

STRING UdfSparablePartitionDomainIdentifier = {
    sizeof(UdfSparablePartitionDomainIdentifierArray),
    sizeof(UdfSparablePartitionDomainIdentifierArray),
    UdfSparablePartitionDomainIdentifierArray
    };

CHAR UdfSparingTableIdentifierArray[] = { '*', 'U', 'D', 'F', ' ',
                                          'S', 'p', 'a', 'r', 'i', 'n', 'g', ' ',
                                          'T', 'a', 'b', 'l', 'e' };

STRING UdfSparingTableIdentifier = {
    sizeof(UdfSparingTableIdentifierArray),
    sizeof(UdfSparingTableIdentifierArray),
    UdfSparingTableIdentifierArray
    };

CHAR UdfNSR02IdentifierArray[] = NSR_PART_CONTID_NSR02;

STRING UdfNSR02Identifier = {
    sizeof(UdfNSR02IdentifierArray),
    sizeof(UdfNSR02IdentifierArray),
    UdfNSR02IdentifierArray
    };
    
CHAR UdfNSR03IdentifierArray[] = NSR_PART_CONTID_NSR03;

STRING UdfNSR03Identifier = {
    sizeof(UdfNSR03IdentifierArray),
    sizeof(UdfNSR03IdentifierArray),
    UdfNSR03IdentifierArray
    };

//
//  Tables of tokens we have to parse up from mount-time on-disk structures
//

PARSE_KEYVALUE VsdIdentParseTable[] = {
    { VSD_IDENT_BEA01, VsdIdentBEA01 },
    { VSD_IDENT_TEA01, VsdIdentTEA01 },
    { VSD_IDENT_CDROM, VsdIdentCDROM },
    { VSD_IDENT_CD001, VsdIdentCD001 },
    { VSD_IDENT_CDW01, VsdIdentCDW01 },
    { VSD_IDENT_CDW02, VsdIdentCDW02 },
    { VSD_IDENT_NSR01, VsdIdentNSR01 },
    { VSD_IDENT_NSR02, VsdIdentNSR02 },
    { VSD_IDENT_BOOT2, VsdIdentBOOT2 },
    { VSD_IDENT_NSR03, VsdIdentNSR03 },
    { NULL,            VsdIdentBad }
    };

PARSE_KEYVALUE NsrPartContIdParseTable[] = {
    { NSR_PART_CONTID_FDC01, NsrPartContIdFDC01 },
    { NSR_PART_CONTID_CD001, NsrPartContIdCD001 },
    { NSR_PART_CONTID_CDW01, NsrPartContIdCDW01 },
    { NSR_PART_CONTID_CDW02, NsrPartContIdCDW02 },
    { NSR_PART_CONTID_NSR01, NsrPartContIdNSR01 },
    { NSR_PART_CONTID_NSR02, NsrPartContIdNSR02 },
    { NSR_PART_CONTID_NSR03, NsrPartContIdNSR03 },
    { NULL,                  NsrPartContIdBad }
    };

//
//  Lookaside allocation lists for various volatile structures
//

NPAGED_LOOKASIDE_LIST UdfFcbNonPagedLookasideList;
NPAGED_LOOKASIDE_LIST UdfIrpContextLookasideList;

PAGED_LOOKASIDE_LIST UdfCcbLookasideList;
PAGED_LOOKASIDE_LIST UdfFcbIndexLookasideList;
PAGED_LOOKASIDE_LIST UdfFcbDataLookasideList;
PAGED_LOOKASIDE_LIST UdfLcbLookasideList;

//
//  16bit CRC table
//

PUSHORT UdfCrcTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfComputeCrc16)
#pragma alloc_text(PAGE, UdfComputeCrc16Uni)
#ifdef UDF_SANITY
#pragma alloc_text(PAGE, UdfDebugTrace)
#endif
#pragma alloc_text(PAGE, UdfFastIoCheckIfPossible)
#pragma alloc_text(PAGE, UdfHighBit)
#pragma alloc_text(PAGE, UdfInitializeCrc16)
#pragma alloc_text(PAGE, UdfSerial32)
#endif


NTSTATUS
UdfFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry to all of the Fsd dispatch points.

    Conceptually the Io routine will call this routine on all requests
    to the file system.  We case on the type of request and invoke the
    correct handler for this type of request.  There is an exception filter
    to catch any exceptions in the UDFS code as well as the UDFS process
    exception routine.

    This routine allocates and initializes the IrpContext for this request as
    well as updating the top-level thread context as necessary.  We may loop
    in this routine if we need to retry the request for any reason.  The
    status code STATUS_CANT_WAIT is used to indicate this.  Suppose the disk
    in the drive has changed.  An Fsd request will proceed normally until it
    recognizes this condition.  STATUS_VERIFY_REQUIRED is raised at that point
    and the exception code will handle the verify and either return
    STATUS_CANT_WAIT or STATUS_PENDING depending on whether the request was
    posted.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    THREAD_CONTEXT ThreadContext;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN Wait;

#ifdef UDF_SANITY
    PVOID PreviousTopLevel;
#endif

    NTSTATUS Status;

    KIRQL SaveIrql = KeGetCurrentIrql();

    ASSERT_OPTIONAL_IRP( Irp );

    FsRtlEnterFileSystem();

#ifdef UDF_SANITY
    PreviousTopLevel = IoGetTopLevelIrp();
#endif

    //
    //  Loop until this request has been completed or posted.
    //

    do {

        //
        //  Use a try-except to handle the exception cases.
        //

        try {

            //
            //  If the IrpContext is NULL then this is the first pass through
            //  this loop.
            //

            if (IrpContext == NULL) {

                //
                //  Decide if this request is waitable an allocate the IrpContext.
                //  If the file object in the stack location is NULL then this
                //  is a mount which is always waitable.  Otherwise we look at
                //  the file object flags.
                //

                if (IoGetCurrentIrpStackLocation( Irp )->FileObject == NULL) {

                    Wait = TRUE;

                } else {

                    Wait = CanFsdWait( Irp );
                }

                IrpContext = UdfCreateIrpContext( Irp, Wait );

                //
                //  Update the thread context information.
                //

                UdfSetThreadContext( IrpContext, &ThreadContext );

#ifdef UDF_SANITY
                ASSERT( !UdfTestTopLevel ||
                        SafeNodeType( IrpContext->TopLevel ) == UDFS_NTC_IRP_CONTEXT );
#endif

            //
            //  Otherwise cleanup the IrpContext for the retry.
            //

            } else {

                //
                //  Set the MORE_PROCESSING flag to make sure the IrpContext
                //  isn't inadvertently deleted here.  Then cleanup the
                //  IrpContext to perform the retry.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
                UdfCleanupIrpContext( IrpContext, FALSE );
            }

            //
            //  Case on the major irp code.
            //

            switch (IrpContext->MajorFunction) {

                case IRP_MJ_CLEANUP :
                    
                    Status = UdfCommonCleanup( IrpContext, Irp );
                    break;
    
                case IRP_MJ_CLOSE :

                    Status = UdfCommonClose( IrpContext, Irp );
                    break;

                case IRP_MJ_CREATE :
                    
                    Status = UdfCommonCreate( IrpContext, Irp );
                    break;
    
                case IRP_MJ_DEVICE_CONTROL :
    
                    Status = UdfCommonDevControl( IrpContext, Irp );
                    break;
    
                case IRP_MJ_DIRECTORY_CONTROL :

                    Status = UdfCommonDirControl( IrpContext, Irp );
                    break;

                case IRP_MJ_FILE_SYSTEM_CONTROL :
    
                    Status = UdfCommonFsControl( IrpContext, Irp );
                    break;

                case IRP_MJ_LOCK_CONTROL :

                    Status = UdfCommonLockControl( IrpContext, Irp );
                    break;

                case IRP_MJ_PNP :

                    Status = UdfCommonPnp( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_INFORMATION :

                    Status = UdfCommonQueryInfo( IrpContext, Irp );
                    break;
                
                case IRP_MJ_QUERY_VOLUME_INFORMATION :

                    Status = UdfCommonQueryVolInfo( IrpContext, Irp );
                    break;
                
                case IRP_MJ_READ :
    
                    //
                    //  If this is an Mdl complete request, don't go through
                    //  common read.
                    //
    
                    if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {
    
                        Status = UdfCompleteMdl( IrpContext, Irp );
    
                    } else {
    
                        Status = UdfCommonRead( IrpContext, Irp );
                    }
    
                    break;
                    
                case IRP_MJ_WRITE :
                
                    Status = UdfCommonWrite( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_INFORMATION :

                    Status = UdfCommonSetInfo( IrpContext, Irp );
                    break;
                
                default :
                            
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    UdfCompleteRequest( IrpContext, Irp, Status );
            }

        } except( UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

            Status = UdfProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT);

#ifdef UDF_SANITY
    ASSERT( !UdfTestTopLevel ||
            (PreviousTopLevel == IoGetTopLevelIrp()) );
#endif

    FsRtlExitFileSystem();

    ASSERT( SaveIrql == KeGetCurrentIrql( ));

    return Status;
}


LONG
UdfExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide whether we will handle a raised exception
    status.  If UDFS explicitly raised an error then this status is already
    in the IrpContext.  We choose which is the correct status code and
    either indicate that we will handle the exception or bug-check the system.

Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;
    BOOLEAN TestStatus = TRUE;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );

    ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    DebugTrace(( 0, Dbg,
                 "UdfExceptionFilter: %08x (exr %08x cxr %08x)\n",
                 ExceptionCode,
                 ExceptionPointer->ExceptionRecord,
                 ExceptionPointer->ContextRecord ));


    //
    // If the exception is STATUS_IN_PAGE_ERROR, get the I/O error code
    // from the exception record.
    //

    if ((ExceptionCode == STATUS_IN_PAGE_ERROR) &&
        (ExceptionPointer->ExceptionRecord->NumberParameters >= 3)) {

        ExceptionCode = (NTSTATUS) ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
    }

    //
    //  If there is an Irp context then check which status code to use.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        if (IrpContext->ExceptionStatus == STATUS_SUCCESS) {

            //
            //  Store the real status into the IrpContext.
            //

            IrpContext->ExceptionStatus = ExceptionCode;

        } else {

            //
            //  No need to test the status code if we raised it ourselves.
            //

            TestStatus = FALSE;
        }
    }

    //
    //  Bug check if this status is not supported.
    //

    if (TestStatus && !FsRtlIsNtstatusExpected( ExceptionCode )) {

        UdfBugCheck( (ULONG_PTR) ExceptionPointer->ExceptionRecord,
                     (ULONG_PTR) ExceptionPointer->ContextRecord,
                     (ULONG_PTR) ExceptionPointer->ExceptionRecord->ExceptionAddress );

    }

    return EXCEPTION_EXECUTE_HANDLER;
}


LONG
UdfQueryDirExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
/*++

Routine Description:

    This routine is used to decide whether we will handle a raised exception
    while opening FES during directory traversal.
    
Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or EXCEPTION_CONTINUE_SEARCH

--*/

{
    NTSTATUS ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;

    if ((ExceptionCode == STATUS_FILE_CORRUPT_ERROR) ||
        (ExceptionCode == STATUS_CRC_ERROR))  {

        return EXCEPTION_EXECUTE_HANDLER;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}



NTSTATUS
UdfProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine processes an exception.  It either completes the request
    with the exception status in the IrpContext, sends this off to the Fsp
    workque or causes it to be retried in the current thread if a verification
    is needed.

    If the volume needs to be verified (STATUS_VERIFY_REQUIRED) and we can
    do the work in the current thread we will translate the status code
    to STATUS_CANT_WAIT to indicate that we need to retry the request.

Arguments:

    Irp - Supplies the Irp being processed

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    NTSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PDEVICE_OBJECT Device;
    PVPB Vpb;
    PETHREAD Thread;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If there is not an irp context, then complete the request with the
    //  current status code.
    //

    if (!ARGUMENT_PRESENT( IrpContext )) {

        UdfCompleteRequest( NULL, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Get the real exception status from the IrpContext.
    //

    ExceptionCode = IrpContext->ExceptionStatus;

    //
    //  If we are not a top level request then we just complete the request
    //  with the current status code.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL )) {

        UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

        return ExceptionCode;
    }

    //
    //  Check if we are posting this request.  One of the following must be true
    //  if we are to post a request.
    //
    //      - Status code is STATUS_CANT_WAIT and the request is asynchronous
    //          or we are forcing this to be posted.
    //
    //      - Status code is STATUS_VERIFY_REQUIRED and we are at APC level
    //          or higher.  Can't wait for IO in the verify path in this case.
    //
    //  Set the MORE_PROCESSING flag in the IrpContext to keep if from being
    //  deleted if this is a retryable condition.
    //
    //  Note:  Children of UdfFsdPostRequest() can raise.
    //

    try {
    
        if (ExceptionCode == STATUS_CANT_WAIT) {

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST )) {

                ExceptionCode = UdfFsdPostRequest( IrpContext, Irp );
            }

        } else if (ExceptionCode == STATUS_VERIFY_REQUIRED) {

            if (KeGetCurrentIrql() >= APC_LEVEL) {

                ExceptionCode = UdfFsdPostRequest( IrpContext, Irp );
            }
        }
    }
    except (UdfExceptionFilter( IrpContext, GetExceptionInformation()))  {
    
        ExceptionCode = GetExceptionCode(); 
    }

    //
    //  If we posted the request or our caller will retry then just return here.
    //

    if ((ExceptionCode == STATUS_PENDING) ||
        (ExceptionCode == STATUS_CANT_WAIT)) {

        return ExceptionCode;
    }

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );

    //
    //  Store this error into the Irp for posting back to the Io system.
    //

    Irp->IoStatus.Status = ExceptionCode;

    if (IoIsErrorUserInduced( ExceptionCode )) {

        //
        //  Check for the various error conditions that can be caused by,
        //  and possibly resolved my the user.
        //

        if (ExceptionCode == STATUS_VERIFY_REQUIRED) {
                
                //
                //  Now we are at the top level file system entry point.
                //
                //  If we have already posted this request then the device to
                //  verify is in the original thread.  Find this via the Irp.
                //

                Device = IoGetDeviceToVerify( Irp->Tail.Overlay.Thread );
                IoSetDeviceToVerify( Irp->Tail.Overlay.Thread, NULL );

                //
                //  If there is no device in that location then check in the
                //  current thread.
                //

                if (Device == NULL) {

                    Device = IoGetDeviceToVerify( PsGetCurrentThread() );
                    IoSetDeviceToVerify( PsGetCurrentThread(), NULL );

                    ASSERT( Device != NULL );

                    //
                    //  Let's not BugCheck just because the driver is messed up.
                    //

                    if (Device == NULL) {

                        ExceptionCode = STATUS_DRIVER_INTERNAL_ERROR;

                        UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

                        return ExceptionCode;
                    }
                }

            //
            //  CdPerformVerify() will do the right thing with the Irp.
            //  If we return STATUS_CANT_WAIT then the current thread
            //  can retry the request.
            //

            return UdfPerformVerify( IrpContext, Irp, Device );
        }

        //
        //  The other user induced conditions generate an error unless
        //  they have been disabled for this request.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS )) {

            UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

            return ExceptionCode;

        } 
        //
        //  Generate a pop-up.
        //
        else {

            if (IoGetCurrentIrpStackLocation( Irp )->FileObject != NULL) {

                Vpb = IoGetCurrentIrpStackLocation( Irp )->FileObject->Vpb;

            } else {

                Vpb = NULL;
            }

            //
            //  The device to verify is either in my thread local storage
            //  or that of the thread that owns the Irp.
            //

            Thread = Irp->Tail.Overlay.Thread;
            Device = IoGetDeviceToVerify( Thread );

            if (Device == NULL) {

                Thread = PsGetCurrentThread();
                Device = IoGetDeviceToVerify( Thread );

                ASSERT( Device != NULL );

                //
                //  Let's not BugCheck just because the driver is messed up.
                //

                if (Device == NULL) {

                    UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

                    return ExceptionCode;
                }
            }

            //
            //  This routine actually causes the pop-up.  It usually
            //  does this by queuing an APC to the callers thread,
            //  but in some cases it will complete the request immediately,
            //  so it is very important to IoMarkIrpPending() first.
            //

            DebugTrace(( 0, Dbg | UDFS_DEBUG_LEVEL_VERFYSUP, 
                         "Raising hard error on exception %x\n", ExceptionCode));

            IoMarkIrpPending( Irp );
            IoRaiseHardError( Irp, Vpb, Device );

            //
            //  We will be handing control back to the caller here, so
            //  reset the saved device object.
            //

            IoSetDeviceToVerify( Thread, NULL );

            //
            //  The Irp will be completed by Io or resubmitted.  In either
            //  case we must clean up the IrpContext here.
            //

            UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
            return STATUS_PENDING;
        }
    }
    
    //
    //  If we were in the process of mount,  then we need to morph any
    //  corruption errors to STATUS_UNRECOGNIZED_VOLUME,  so that Io continues
    //  the mount process and RAW will get the volume.  Otherwise we keep
    //  getting remount requests when we try to reformat a corrupt volume
    //  (or do anything with the drive).
    //
    
#if 0
    //  Not sure about this.  Format should do a 'raw allowed' open,  so....
    
    if ((IRP_MJ_FILE_SYSTEM_CONTROL == IrpContext->MajorFunction) &&
        (IRP_MN_MOUNT_VOLUME == IrpContext->MinorFunction))  {

        ExceptionCode = STATUS_UNRECOGNIZED_VOLUME;
    }
#endif

    //
    //  This is just a run of the mill error.
    //

    UdfCompleteRequest( IrpContext, Irp, ExceptionCode );

    return ExceptionCode;
}


VOID
UdfCompleteRequest (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine completes a Irp and cleans up the IrpContext.  Either or
    both of these may not be specified.

Arguments:

    Irp - Supplies the Irp being processed.

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_OPTIONAL_IRP( Irp );

    //
    //  Cleanup the IrpContext if passed in here.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        UdfCleanupIrpContext( IrpContext, FALSE );
    }

    //
    //  If we have an Irp then complete the irp.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        //
        //  Clear the information field in case we have used this Irp
        //  internally.
        //

        if (NT_ERROR( Status ) &&
            FlagOn( Irp->Flags, IRP_INPUT_OPERATION )) {

            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
    }

    return;
}


VOID
UdfSetThreadContext (
    IN PIRP_CONTEXT IrpContext,
    IN PTHREAD_CONTEXT ThreadContext
    )

/*++

Routine Description:

    This routine is called at each Fsd/Fsp entry point set up the IrpContext
    and thread local storage to track top level requests.  If there is
    not a Udfs context in the thread local storage then we use the input one.
    Otherwise we use the one already there.  This routine also updates the
    IrpContext based on the state of the top-level context.

    If the TOP_LEVEL flag in the IrpContext is already set when we are called
    then we force this request to appear top level.

Arguments:

    ThreadContext - Address on stack for local storage if not already present.

    ForceTopLevel - We force this request to appear top level regardless of
        any previous stack value.

Return Value:

    None

--*/

{
    PTHREAD_CONTEXT CurrentThreadContext;
    ULONG_PTR StackTop;
    ULONG_PTR StackBottom;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Get the current top-level irp out of the thread storage.
    //  If NULL then this is the top-level request.
    //

    CurrentThreadContext = (PTHREAD_CONTEXT) IoGetTopLevelIrp();

    if (CurrentThreadContext == NULL) {

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL );
    }

    //
    //  Initialize the input context unless we are using the current
    //  thread context block.  We use the new block if our caller
    //  specified this or the existing block is invalid.
    //
    //  The following must be true for the current to be a valid Udfs context.
    //
    //      Structure must lie within current stack.
    //      Address must be ULONG aligned.
    //      Udfs signature must be present.
    //
    //  If this is not a valid Udfs context then use the input thread
    //  context and store it in the top level context.
    //

    IoGetStackLimits( &StackTop, &StackBottom);

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL ) ||
        (((ULONG_PTR) CurrentThreadContext > StackBottom - sizeof( THREAD_CONTEXT )) ||
         ((ULONG_PTR) CurrentThreadContext <= StackTop) ||
         LongOffsetPtr( CurrentThreadContext ) ||
         (CurrentThreadContext->Udfs != UDFS_SIGNATURE))) {

        ThreadContext->Udfs = UDFS_SIGNATURE;
        ThreadContext->SavedTopLevelIrp = (PIRP) CurrentThreadContext;
        ThreadContext->TopLevelIrpContext = IrpContext;
        IoSetTopLevelIrp( (PIRP) ThreadContext );

        IrpContext->TopLevel = IrpContext;
        IrpContext->ThreadContext = ThreadContext;

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS );

    //
    //  Otherwise use the IrpContext in the thread context.
    //

    } else {

        IrpContext->TopLevel = CurrentThreadContext->TopLevelIrpContext;
    }

    return;
}


BOOLEAN
UdfFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route.

--*/

{
    PAGED_CODE();

    return TRUE;
}


ULONG
UdfSerial32 (
    IN PCHAR Buffer,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine is called to generate a 32 bit serial number.  This is
    done by doing four separate checksums into an array of bytes and
    then treating the bytes as a ULONG.

Arguments:

    Buffer - Pointer to the buffer to generate the ID for.

    ByteCount - Number of bytes in the buffer.

Return Value:

    ULONG - The 32 bit serial number.

--*/

{
    union {
        UCHAR   Bytes[4];
        ULONG   SerialId;
    } Checksum;

    PAGED_CODE();

    //
    //  Initialize the serial number.
    //

    Checksum.SerialId = 0;

    //
    //  Continue while there are more bytes to use.
    //

    while (ByteCount--) {

        //
        //  Increment this sub-checksum.
        //

        Checksum.Bytes[ByteCount & 0x3] += *(Buffer++);
    }

    //
    //  Return the checksums as a ULONG.
    //

    return Checksum.SerialId;
}


VOID
UdfInitializeCrc16 (
    ULONG Polynomial
    )

/*++

Routine Description:

    This routine generates the 16bit CRC Table to be used in CRC calculation.

Arguments:

    Polynomial - Starting seed for the generation

Return Value:

    None

--*/

{
    ULONG n, i, Crc;

    //
    //  All CRC code was devised by Don P. Mitchell of AT&T Bell Laboratories
    //  and Ned W. Rhodes of Software Systems Group.  It has been published in
    //  "Design and Validation of Computer Protocols", Prentice Hall, Englewood
    //  Cliffs, NJ, 1991, Chapter 3, ISBN 0-13-539925-4.
    //
    //  Copyright is held by AT&T.
    //
    //  AT&T gives permission for the free use of the source code.
    //

    UdfCrcTable = (PUSHORT) FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                      256 * sizeof(USHORT),
                                                      TAG_CRC_TABLE );

    for (n = 0; n < 256; n++) {

        Crc = n << 8;

        for (i = 0; i < 8; i++) {

            if(Crc & 0x8000) {

                Crc = (Crc << 1) ^ Polynomial;

            } else {

                Crc <<= 1;
            }

            Crc &= 0xffff;
        }

        UdfCrcTable[n] = (USHORT) Crc;
    }
}



USHORT
UdfComputeCrc16 (
	PUCHAR Buffer,
	ULONG ByteCount
    )

/*++

Routine Description:

    This routine generates a 16 bit CRC of the input buffer in accordance
    with the precomputed CRC table.

Arguments:

    Buffer - Pointer to the buffer to generate the CRC for.

    ByteCount - Number of bytes in the buffer.

Return Value:

    USHORT - The 16bit CRC

--*/

{
	USHORT Crc = 0;

    //
    //  All CRC code was devised by Don P. Mitchell of AT&T Bell Laboratories
    //  and Ned W. Rhodes of Software Systems Group.  It has been published in
    //  "Design and Validation of Computer Protocols", Prentice Hall, Englewood
    //  Cliffs, NJ, 1991, Chapter 3, ISBN 0-13-539925-4.
    //
    //  Copyright is held by AT&T.
    //
    //  AT&T gives permission for the free use of the source code.
    //

    while (ByteCount-- > 0) {

        Crc = UdfCrcTable[((Crc >> 8) ^ *Buffer++) & 0xff] ^ (Crc << 8);
    }

	return Crc;
}


USHORT
UdfComputeCrc16Uni (
    PWCHAR Buffer,
    ULONG CharCount
    )

/*++

Routine Description:

    This routine generates a 16 bit CRC of the input buffer in accordance
    with the precomputed CRC table.
    
    It performs a byte-order independent crc (hi then lo). This is a bit
    suspect, but is called for in the specification. 

Arguments:

    Buffer - Pointer to the buffer to generate the CRC for.

    ShortCount - Number of wide characters in the buffer.

Return Value:

    USHORT - The 16bit CRC

--*/

{
    USHORT Crc = 0;

    //
    //  Byte order independent CRC, hi byte to low byte per character.
    //

    while (CharCount-- > 0) {

        Crc = UdfCrcTable[((Crc >> 8) ^ (*Buffer >> 8)) & 0xff] ^ (Crc << 8);
        Crc = UdfCrcTable[((Crc >> 8) ^ (*Buffer++ & 0xff)) & 0xff] ^ (Crc << 8);
    }

    return Crc;
}


ULONG
UdfHighBit (
    ULONG Word
    )

/*++

Routine Description:

    This routine discovers the highest set bit of the input word.  It is
    equivalent to the integer logarithim base 2.

Arguments:

    Word - word to check

Return Value:

    Bit offset of highest set bit. If no bit is set, return is zero.

--*/

{
    ULONG Offset = 31;
    ULONG Mask = (ULONG)(1 << 31);

    if (Word == 0) {

        return 0;
    }

    while ((Word & Mask) == 0) {

        Offset--;
        Mask >>= 1;
    }

    return Offset;
}


#ifdef UDF_SANITY
BOOLEAN
UdfDebugTrace (
    LONG IndentIncrement,
    ULONG TraceMask,
    PCHAR Format,
    ...
    )

/*++

Routine Description:

    This routine is a simple debug info printer that returns a constant boolean value.  This
    makes it possible to splice it into the middle of boolean expressions to discover which
    elements are firing.
    
    We will use this as our general debug printer.  See udfdata.h for how we use the DebugTrace
    macro to accomplish the effect.
    
Arguments:

    IndentIncrement - amount to change the indentation by.
    
    TraceMask - specification of what debug trace level this call should be noisy at.

Return Value:

    USHORT - The 16bit CRC

--*/

{
    va_list Arglist;
    LONG i;
    UCHAR Buffer[256];
    int Bytes;
    int ThreadIdChars;

    if (TraceMask == 0 || (UdfDebugTraceLevel & TraceMask) != 0) {

        if (IndentIncrement < 0) {
            
            UdfDebugTraceIndent += IndentIncrement;
        }

        if (UdfDebugTraceIndent < 0) {
            
            UdfDebugTraceIndent = 0;
        }

        //
        //  Print out the current thread,  otherwise all this trace is completely
        //  useless in the face of multi threaded issues.
        //
        
        ThreadIdChars = sprintf(Buffer, "%p ", PsGetCurrentThread());
        // DbgPrint( Buffer );

        //
        //  The indent stuff doesn't work too well across multi thread output.
        //
#if 0        
        //
        //  Build the indent in big chunks since calling DbgPrint repeatedly is expensive.
        //
        
        for (i = UdfDebugTraceIndent; i > 0; i -= (sizeof(Buffer) - 1)) {

            RtlFillMemory( Buffer, Min( i, (sizeof(Buffer) - 1 )), ' ');
            *(Buffer + Min( i, (sizeof(Buffer) - 1 ))) = '\0';
            
            DbgPrint( Buffer );
        }
#endif
        //
        // Format the output into a buffer and then print it.
        //

        va_start( Arglist, Format );
        Bytes = _vsnprintf( Buffer + ThreadIdChars, sizeof(Buffer) - ThreadIdChars, Format, Arglist );
        va_end( Arglist );

        //
        // detect buffer overflow
        //

        if (Bytes == -1) {

            Buffer[sizeof(Buffer) - 1] = '\n';
        }

        DbgPrint( Buffer );

        if (IndentIncrement > 0) {

            UdfDebugTraceIndent += IndentIncrement;
        }
    }

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\udfdata.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    UdfData.h

Abstract:

    This module declares the global data used by the Udfs file system.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   20-May-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#ifndef _UDFDATA_
#define _UDFDATA_

//
//  Global data structures
//

extern UDF_DATA UdfData;
extern FAST_IO_DISPATCH UdfFastIoDispatch;

//
//  Global constants
//

//
//  These are the number of times a mounted Vcb will be referenced on behalf
//  of the system.  The counts include the following references.
//
//      1 reference - shows the volume is mounted
//      1 reference - 1 for VolumeDasdFcb.
//      2 references - 1 for RootIndexFcb, 1 for internal stream.
//      2 references - 1 for MetadataFcb, 1 for internal stream.
//
//  AND THEN, IF THIS IS CD-UDF
//
//      2 references - 1 for the VatFcb, 1 for the internal stream.
//
//  For user references we add one for the reference in each of the internal
//  Fcbs.
//

#define UDFS_BASE_RESIDUAL_REFERENCE                (6)
#define UDFS_BASE_RESIDUAL_USER_REFERENCE           (3)

#define UDFS_CDUDF_RESIDUAL_REFERENCE               (2)
#define UDFS_CDUDF_RESIDUAL_USER_REFERENCE          (1)

//
//  The UDFS signature for thread contexts
//

#define UDFS_SIGNATURE                              0x53464455 

//
//  Reserved directory strings
//

#define SELF_ENTRY   0
#define PARENT_ENTRY 1

extern WCHAR UdfUnicodeSelfArray[];
extern WCHAR UdfUnicodeParentArray[];

extern LARGE_INTEGER UdfCorruptFileTime;

extern UNICODE_STRING UdfUnicodeDirectoryNames[];

//
//  Static Identifier strings
//

extern STRING UdfCS0Identifier;
extern STRING UdfDomainIdentifier;
extern STRING UdfVirtualPartitionDomainIdentifier;
extern STRING UdfVatTableIdentifier;
extern STRING UdfSparablePartitionDomainIdentifier;
extern STRING UdfSparingTableIdentifier;
extern STRING UdfNSR02Identifier;
extern STRING UdfNSR03Identifier;

//
//  Lookup tables for rudimentary parsing of strings we will
//  discover in on-disk structures
//

extern PARSE_KEYVALUE VsdIdentParseTable[];
extern PARSE_KEYVALUE NsrPartContIdParseTable[];

//
//  Lookaside lists
//

extern NPAGED_LOOKASIDE_LIST UdfFcbNonPagedLookasideList;
extern NPAGED_LOOKASIDE_LIST UdfIrpContextLookasideList;

extern PAGED_LOOKASIDE_LIST UdfCcbLookasideList;
extern PAGED_LOOKASIDE_LIST UdfFcbIndexLookasideList;
extern PAGED_LOOKASIDE_LIST UdfFcbDataLookasideList;
extern PAGED_LOOKASIDE_LIST UdfLcbLookasideList;

//
//  16bit CRC table
//

extern PUSHORT UdfCrcTable;

//
//  Turn on pseudo-asserts if UDFS_FREE_ASSERTS is defined.
//

#if (!DBG && defined( UDFS_FREE_ASSERTS )) || defined( UDFSDBG )
#undef ASSERT
#undef ASSERTMSG
#define ASSERT(exp)                                             \
    ((exp) ? TRUE :                                             \
             (DbgPrint( "%s:%d %s\n",__FILE__,__LINE__,#exp ),  \
              DbgBreakPoint(),                                  \
              TRUE))
#define ASSERTMSG(msg,exp)                                              \
    ((exp) ? TRUE :                                                     \
             (DbgPrint( "%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp ),   \
              DbgBreakPoint(),                                          \
              TRUE))
#endif


//
//  McDebugging Stuff
//

//
//  The following assertion macros ensure that the indicated structure
//  is valid
//
//      ASSERT_STRUCT( IN PVOID Struct, IN CSHORT NodeType );
//      ASSERT_OPTIONAL_STRUCT( IN PVOID Struct OPTIONAL, IN CSHORT NodeType );
//
//      ASSERT_VCB( IN PVCB Vcb );
//      ASSERT_OPTIONAL_VCB( IN PVCB Vcb OPTIONAL );
//
//      ASSERT_FCB( IN PFCB Fcb );
//      ASSERT_OPTIONAL_FCB( IN PFCB Fcb OPTIONAL );
//
//      ASSERT_LCB( IN PLCB Lcb );
//      ASSERT_OPTIONAL_LCB( IN PLCB Lcb OPTIONAL );
//
//      ASSERT_PCB( IN PFCB Pcb );
//      ASSERT_OPTIONAL_PCB( IN PPCB Pcb OPTIONAL );
//
//      ASSERT_FCB_NONPAGED( IN PFCB_NONPAGED FcbNonpaged );
//      ASSERT_OPTIONAL_FCB( IN PFCB_NONPAGED FcbNonpaged OPTIONAL );
//
//      ASSERT_CCB( IN PSCB Ccb );
//      ASSERT_OPTIONAL_CCB( IN PSCB Ccb OPTIONAL );
//
//      ASSERT_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext );
//      ASSERT_OPTIONAL_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext OPTIONAL );
//
//      ASSERT_IRP( IN PIRP Irp );
//      ASSERT_OPTIONAL_IRP( IN PIRP Irp OPTIONAL );
//
//      ASSERT_FILE_OBJECT( IN PFILE_OBJECT FileObject );
//      ASSERT_OPTIONAL_FILE_OBJECT( IN PFILE_OBJECT FileObject OPTIONAL );
//
//  The following macros are used to check the current thread owns
//  the indicated resource
//
//      ASSERT_EXCLUSIVE_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_SHARED_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_RESOURCE_NOT_MINE( IN PERESOURCE Resource );
//
//  The following macros are used to check whether the current thread
//  owns the resoures in the given structures.
//
//      ASSERT_EXCLUSIVE_CDDATA
//
//      ASSERT_EXCLUSIVE_VCB( IN PVCB Vcb );
//
//      ASSERT_SHARED_VCB( IN PVCB Vcb );
//
//      ASSERT_EXCLUSIVE_FCB( IN PFCB Fcb );
//
//      ASSERT_SHARED_FCB( IN PFCB Fcb );
//
//      ASSERT_EXCLUSIVE_FILE( IN PFCB Fcb );
//
//      ASSERT_SHARED_FILE( IN PFCB Fcb );
//
//      ASSERT_LOCKED_VCB( IN PVCB Vcb );
//
//      ASSERT_NOT_LOCKED_VCB( IN PVCB Vcb );
//
//      ASSERT_LOCKED_FCB( IN PFCB Fcb );
//
//      ASSERT_NOT_LOCKED_FCB( IN PFCB Fcb );
//

//
//  Turn on the sanity checks if this is DBG or UDF_FREE_ASSERTS
//

#if DBG || UDF_FREE_ASSERTS
#undef UDF_SANITY
#define UDF_SANITY
#endif

#ifdef UDF_SANITY

extern LONG UdfDebugTraceLevel;
extern LONG UdfDebugTraceIndent;
extern BOOLEAN UdfNoisyVerifyDescriptor;
extern BOOLEAN UdfTestRaisedStatus;

BOOLEAN
UdfDebugTrace (
    LONG IndentIncrement,
    ULONG TraceMask,
    PCHAR Format,
    ...
    );

#define DebugTrace(x) UdfDebugTrace x

#define DebugUnwind(X) {                                                            \
    if (AbnormalTermination()) {                                                    \
        DebugTrace(( -1, UDFS_DEBUG_LEVEL_UNWIND, #X ", Abnormal termination.\n" )); \
    }                                                                               \
}

#define DebugBreakOnStatus(S) {                                                         \
    if (UdfTestRaisedStatus) {                                                          \
        if ((S) == STATUS_DISK_CORRUPT_ERROR ||                                         \
            (S) == STATUS_FILE_CORRUPT_ERROR ||                                         \
            (S) == STATUS_CRC_ERROR) {                                                  \
            DbgPrint( "UDFS: Breaking on possible media corruption (S = %08x)\n", (S)); \
            DbgPrint( "UDFS: Contact UDFS.SYS component owner for triage.\n");          \
            DbgPrint( "UDFS: 'eb %p 0' to disable this alert\n",&UdfTestRaisedStatus ); \
            DbgBreakPoint();                                                            \
        }                                                                               \
    }                                                                                   \
}    

#define ASSERT_STRUCT(S,T)                       ASSERT( SafeNodeType( S ) == (T) )
#define ASSERT_OPTIONAL_STRUCT(S,T)              ASSERT( ((S) == NULL) ||  (SafeNodeType( S ) == (T)) )

#define ASSERT_VCB(V)                            ASSERT_STRUCT( (V), UDFS_NTC_VCB )
#define ASSERT_OPTIONAL_VCB(V)                   ASSERT_OPTIONAL_STRUCT( (V), UDFS_NTC_VCB )

#define ASSERT_FCB(F)                                           \
    ASSERT( (SafeNodeType( F ) == UDFS_NTC_FCB_DATA ) ||        \
            (SafeNodeType( F ) == UDFS_NTC_FCB_INDEX ) )

#define ASSERT_OPTIONAL_FCB(F)                                  \
    ASSERT( ((F) == NULL) ||                                    \
            (SafeNodeType( F ) == UDFS_NTC_FCB_DATA ) ||        \
            (SafeNodeType( F ) == UDFS_NTC_FCB_INDEX ) )

#define ASSERT_FCB_DATA(F)                       ASSERT( (SafeNodeType( F ) == UDFS_NTC_FCB_DATA ) )

#define ASSERT_OPTIONAL_FCB_DATA(F)                             \
    ASSERT( ((F) == NULL) ||                                    \
            (SafeNodeType( F ) == UDFS_NTC_FCB_DATA ) )

#define ASSERT_FCB_INDEX(F)                      ASSERT( (SafeNodeType( F ) == UDFS_NTC_FCB_INDEX ) )

#define ASSERT_OPTIONAL_FCB_INDEX(F)                            \
    ASSERT( ((F) == NULL) ||                                    \
            (SafeNodeType( F ) == UDFS_NTC_FCB_INDEX ) )

#define ASSERT_FCB_NONPAGED(FN)                  ASSERT_STRUCT( (FN), UDFS_NTC_FCB_NONPAGED )
#define ASSERT_OPTIONAL_FCB_NONPAGED(FN)         ASSERT_OPTIONAL_STRUCT( (FN), UDFS_NTC_FCB_NONPAGED )

#define ASSERT_CCB(C)                            ASSERT_STRUCT( (C), UDFS_NTC_CCB )
#define ASSERT_OPTIONAL_CCB(C)                   ASSERT_OPTIONAL_STRUCT( (C), UDFS_NTC_CCB )

#define ASSERT_PCB(C)                            ASSERT_STRUCT( (C), UDFS_NTC_PCB )
#define ASSERT_OPTIONAL_PCB(C)                   ASSERT_OPTIONAL_STRUCT( (C), UDFS_NTC_PCB )

#define ASSERT_LCB(C)                            ASSERT_STRUCT( (C), UDFS_NTC_LCB )
#define ASSERT_OPTIONAL_LCB(C)                   ASSERT_OPTIONAL_STRUCT( (C), UDFS_NTC_LCB )

#define ASSERT_IRP_CONTEXT(IC)                   ASSERT_STRUCT( (IC), UDFS_NTC_IRP_CONTEXT )
#define ASSERT_OPTIONAL_IRP_CONTEXT(IC)          ASSERT_OPTIONAL_STRUCT( (IC), UDFS_NTC_IRP_CONTEXT )

#define ASSERT_IRP_CONTEXT_LITE(IC)              ASSERT_STRUCT( (IC), UDFS_NTC_IRP_CONTEXT_LITE )
#define ASSERT_OPTIONAL_IRP_CONTEXT_LITE(IC)     ASSERT_OPTIONAL_STRUCT( (IC), UDFS_NTC_IRP_CONTEXT_LITE )

#define ASSERT_IRP(I)                            ASSERT_STRUCT( (I), IO_TYPE_IRP )
#define ASSERT_OPTIONAL_IRP(I)                   ASSERT_OPTIONAL_STRUCT( (I), IO_TYPE_IRP )

#define ASSERT_FILE_OBJECT(FO)                   ASSERT_STRUCT( (FO), IO_TYPE_FILE )
#define ASSERT_OPTIONAL_FILE_OBJECT(FO)          ASSERT_OPTIONAL_STRUCT( (FO), IO_TYPE_FILE )

#define ASSERT_EXCLUSIVE_RESOURCE(R)             ASSERT( ExIsResourceAcquiredExclusiveLite( R ))

#define ASSERT_SHARED_RESOURCE(R)                ASSERT( ExIsResourceAcquiredSharedLite( R ))

#define ASSERT_RESOURCE_NOT_MINE(R)              ASSERT( !ExIsResourceAcquiredSharedLite( R ))

#define ASSERT_EXCLUSIVE_UDFDATA                 ASSERT( ExIsResourceAcquiredExclusiveLite( &UdfData.DataResource ))
#define ASSERT_EXCLUSIVE_VCB(V)                  ASSERT( ExIsResourceAcquiredExclusiveLite( &(V)->VcbResource ))
#define ASSERT_SHARED_VCB(V)                     ASSERT( ExIsResourceAcquiredSharedLite( &(V)->VcbResource ))

#define ASSERT_EXCLUSIVE_FCB_OR_VCB(F)           ASSERT( ExIsResourceAcquiredExclusiveLite( &(F)->FcbNonpaged->FcbResource ) || \
                                                         ExIsResourceAcquiredExclusiveLite( &(F)->Vcb->VcbResource ))

#define ASSERT_EXCLUSIVE_FCB(F)                  ASSERT( ExIsResourceAcquiredExclusiveLite( &(F)->FcbNonpaged->FcbResource ))
#define ASSERT_SHARED_FCB(F)                     ASSERT( ExIsResourceAcquiredSharedLite( &(F)->FcbNonpaged->FcbResource ))

#define ASSERT_EXCLUSIVE_FILE(F)                 ASSERT( ExIsResourceAcquiredExclusiveLite( (F)->Resource ))
#define ASSERT_SHARED_FILE(F)                    ASSERT( ExIsResourceAcquiredSharedLite( (F)->Resource ))

#define ASSERT_LOCKED_VCB(V)                     ASSERT( (V)->VcbLockThread == PsGetCurrentThread() )
#define ASSERT_NOT_LOCKED_VCB(V)                 ASSERT( (V)->VcbLockThread != PsGetCurrentThread() )

#define ASSERT_LOCKED_FCB(F)                     ASSERT( (F)->FcbLockThread == PsGetCurrentThread() )
#define ASSERT_NOT_LOCKED_FCB(F)                 ASSERT( (F)->FcbLockThread != PsGetCurrentThread() )

#define ASSERT_NOT_HELD_VMCB(V)                  ASSERT( !ExIsResourceAcquiredSharedLite(&(V)->VmcbMappingResource) && \
                                                         !ExIsResourceAcquiredExclusiveLite(&(V)->VmcbMappingResource) )
#else

#define DebugTrace(X)                            TRUE
#define DebugUnwind(X)                           { NOTHING; }
#define DebugBreakOnStatus(S)                    { NOTHING; }

#define ASSERT_NOT_HELD_VMCB(V)                  { NOTHING; }
#define ASSERT_STRUCT(S,T)                       { NOTHING; }
#define ASSERT_OPTIONAL_STRUCT(S,T)              { NOTHING; }
#define ASSERT_VCB(V)                            { NOTHING; }
#define ASSERT_OPTIONAL_VCB(V)                   { NOTHING; }
#define ASSERT_FCB(F)                            { NOTHING; }
#define ASSERT_OPTIONAL_FCB(F)                   { NOTHING; }
#define ASSERT_FCB_DATA                          { NOTHING; }
#define ASSERT_OPTIONAL_FCB_DATA(F)              { NOTHING; }
#define ASSERT_FCB_INDEX(F)                      { NOTHING; }
#define ASSERT_OPTIONAL_FCB_INDEX(F)             { NOTHING; }
#define ASSERT_FCB_NONPAGED(FN)                  { NOTHING; }
#define ASSERT_OPTIONAL_FCB_NONPAGED(FN)         { NOTHING; }
#define ASSERT_CCB(C)                            { NOTHING; }
#define ASSERT_OPTIONAL_CCB(C)                   { NOTHING; }
#define ASSERT_PCB(C)                            { NOTHING; }
#define ASSERT_OPTIONAL_PCB(C)                   { NOTHING; }
#define ASSERT_LCB(C)                            { NOTHING; }
#define ASSERT_OPTIONAL_LCB(C)                   { NOTHING; }
#define ASSERT_IRP_CONTEXT(IC)                   { NOTHING; }
#define ASSERT_OPTIONAL_IRP_CONTEXT(IC)          { NOTHING; }
#define ASSERT_IRP_CONTEXT_LITE(IC)              { NOTHING; }
#define ASSERT_OPTIONAL_IRP_CONTEXT_LITE(IC)     { NOTHING; }
#define ASSERT_IRP(I)                            { NOTHING; }
#define ASSERT_OPTIONAL_IRP(I)                   { NOTHING; }
#define ASSERT_FILE_OBJECT(FO)                   { NOTHING; }
#define ASSERT_OPTIONAL_FILE_OBJECT(FO)          { NOTHING; }
#define ASSERT_EXCLUSIVE_RESOURCE(R)             { NOTHING; }
#define ASSERT_SHARED_RESOURCE(R)                { NOTHING; }
#define ASSERT_RESOURCE_NOT_MINE(R)              { NOTHING; }
#define ASSERT_EXCLUSIVE_UDFDATA                 { NOTHING; }
#define ASSERT_EXCLUSIVE_VCB(V)                  { NOTHING; }
#define ASSERT_SHARED_VCB(V)                     { NOTHING; }
#define ASSERT_EXCLUSIVE_FCB_OR_VCB(F)           { NOTHING; }
#define ASSERT_EXCLUSIVE_FCB(F)                  { NOTHING; }
#define ASSERT_SHARED_FCB(F)                     { NOTHING; }
#define ASSERT_EXCLUSIVE_FILE(F)                 { NOTHING; }
#define ASSERT_SHARED_FILE(F)                    { NOTHING; }
#define ASSERT_LOCKED_VCB(V)                     { NOTHING; }
#define ASSERT_NOT_LOCKED_VCB(V)                 { NOTHING; }
#define ASSERT_LOCKED_FCB(F)                     { NOTHING; }
#define ASSERT_NOT_LOCKED_FCB(F)                 { NOTHING; }

#endif

#endif // _UDFDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\prefxsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Udfs Prefix support routines

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     8-Oct-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_PREFXSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_READ)

//
//  Local support routines.
//

PLCB
UdfFindNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    );

BOOLEAN
UdfInsertNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PLCB NameLink
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfFindNameLink)
#pragma alloc_text(PAGE, UdfFindPrefix)
#pragma alloc_text(PAGE, UdfInitializeLcbFromDirContext)
#pragma alloc_text(PAGE, UdfInsertNameLink)
#pragma alloc_text(PAGE, UdfInsertPrefix)
#pragma alloc_text(PAGE, UdfRemovePrefix)
#endif


PLCB
UdfInsertPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING Name,
    IN BOOLEAN ShortNameMatch,
    IN BOOLEAN IgnoreCase,
    IN PFCB ParentFcb
    )

/*++

Routine Description:

    This routine inserts an Lcb linking the two Fcbs together.

Arguments:

    Fcb - This is the Fcb whose name is being inserted into the tree.

    Name - This is the name for the component.
    
    ShortNameMatch - Indicates whether this name was found on an explicit 8.3 search

    IgnoreCase - Indicates if we should insert into the case-insensitive tree.

    ParentFcb - This is the ParentFcb.  The prefix tree is attached to this.

Return Value:

    PLCB - the Lcb inserted.

--*/

{
    PLCB Lcb;
    PRTL_SPLAY_LINKS *TreeRoot;
    PLIST_ENTRY ListLinks;
    ULONG Flags;

    PWCHAR NameBuffer;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    ASSERT_EXCLUSIVE_FCB( Fcb );
    ASSERT_EXCLUSIVE_FCB( ParentFcb );
    ASSERT_FCB_INDEX( ParentFcb );

    //
    //  It must be the case that an index Fcb is only referenced by a single index.  Now
    //  we walk the child's Lcb queue to insure that if any prefixes have already been
    //  inserted, they all refer to the index Fcb we are linking to.  This is the only way
    //  we can detect directory cross-linkage.
    //

    if (SafeNodeType( Fcb ) == UDFS_NTC_FCB_INDEX) {

        for (ListLinks = Fcb->ParentLcbQueue.Flink;
             ListLinks != &Fcb->ParentLcbQueue;
             ListLinks = ListLinks->Flink) {

            Lcb = CONTAINING_RECORD( ListLinks, LCB, ChildFcbLinks );

            if (Lcb->ParentFcb != ParentFcb) {

                UdfRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }
        }
    }
    
    //
    //  Capture the separate cases.
    //

    if (IgnoreCase) {

        TreeRoot = &ParentFcb->IgnoreCaseRoot;
        Flags = LCB_FLAG_IGNORE_CASE;

    } else {

        TreeRoot = &ParentFcb->ExactCaseRoot;
        Flags = 0;
    }

    if (ShortNameMatch) {

        SetFlag( Flags, LCB_FLAG_SHORT_NAME );
    }

    //
    //  Allocate space for the Lcb.
    //

    if ( sizeof( LCB ) + Name->Length > SIZEOF_LOOKASIDE_LCB ) {
    
        Lcb = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                        sizeof( LCB ) + Name->Length,
                                        TAG_LCB );

        SetFlag( Flags, LCB_FLAG_POOL_ALLOCATED );

    } else {

        Lcb = ExAllocateFromPagedLookasideList( &UdfLcbLookasideList );
    }

    //
    //  Set the type and size.
    //

    Lcb->NodeTypeCode = UDFS_NTC_LCB;
    Lcb->NodeByteSize = sizeof( LCB ) + Name->Length;

    //
    //  Initialize the name-based file attributes.
    //
    
    Lcb->FileAttributes = 0;
    
    //
    //  Set up the filename in the Lcb.
    //

    Lcb->FileName.Length =
    Lcb->FileName.MaximumLength = Name->Length;

    Lcb->FileName.Buffer = Add2Ptr( Lcb, sizeof( LCB ), PWCHAR );

    RtlCopyMemory( Lcb->FileName.Buffer,
                   Name->Buffer,
                   Name->Length );
    
    //
    //  Insert the Lcb into the prefix tree.
    //
    
    Lcb->Flags = Flags;
    
    if (!UdfInsertNameLink( IrpContext,
                            TreeRoot,
                            Lcb )) {

        //
        //  This will very rarely occur.
        //

        UdfFreePool( &Lcb );

        Lcb = UdfFindNameLink( IrpContext,
                               TreeRoot,
                               Name );

        if (Lcb == NULL) {

            //
            //  Even worse.
            //

            UdfRaiseStatus( IrpContext, STATUS_DRIVER_INTERNAL_ERROR );
        }

        return Lcb;
    }

    //
    //  Link the Fcbs together through the Lcb.
    //

    Lcb->ParentFcb = ParentFcb;
    Lcb->ChildFcb = Fcb;

    InsertHeadList( &ParentFcb->ChildLcbQueue, &Lcb->ParentFcbLinks );
    InsertHeadList( &Fcb->ParentLcbQueue, &Lcb->ChildFcbLinks );

    //
    //  Initialize the reference count.
    //

    Lcb->Reference = 0;
    
    return Lcb;
}


VOID
UdfRemovePrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb
    )

/*++

Routine Description:

    This routine is called to remove a given prefix of an Fcb.

Arguments:

    Lcb - the prefix being removed.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( Lcb );

    //
    //  Check the acquisition of the two Fcbs.
    //

    ASSERT_EXCLUSIVE_FCB_OR_VCB( Lcb->ParentFcb );
    ASSERT_EXCLUSIVE_FCB_OR_VCB( Lcb->ChildFcb );

    //
    //  Now remove the linkage and delete the Lcb.
    //
    
    RemoveEntryList( &Lcb->ParentFcbLinks );
    RemoveEntryList( &Lcb->ChildFcbLinks );

    if (FlagOn( Lcb->Flags, LCB_FLAG_IGNORE_CASE )) {

        Lcb->ParentFcb->IgnoreCaseRoot = RtlDelete( &Lcb->Links );
    
    } else {

        Lcb->ParentFcb->ExactCaseRoot = RtlDelete( &Lcb->Links );
    }

    if (FlagOn( Lcb->Flags, LCB_FLAG_POOL_ALLOCATED )) {

        ExFreePool( Lcb );

    } else {

        ExFreeToPagedLookasideList( &UdfLcbLookasideList, Lcb );
    }
    
    return;
}


PLCB
UdfFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *CurrentFcb,
    IN OUT PUNICODE_STRING RemainingName,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine begins from the given CurrentFcb and walks through all of
    components of the name looking for the longest match in the prefix
    splay trees.  The search is relative to the starting Fcb so the
    full name may not begin with a '\'.  On return this routine will
    update Current Fcb with the lowest point it has travelled in the
    tree.  It will also hold only that resource on return and it must
    hold that resource.

Arguments:

    CurrentFcb - Address to store the lowest Fcb we find on this search.
        On return we will have acquired this Fcb.  On entry this is the
        Fcb to examine.
        
    RemainingName - Supplies a buffer to store the exact case of the name being
        searched for.  Initially will contain the upcase name based on the
        IgnoreCase flag.

    IgnoreCase - Indicates if we are doing a case-insensitive compare.

Return Value:

    The Lcb used to find the current Fcb, NULL if we didn't find any prefix
    Fcbs.

--*/

{
    UNICODE_STRING LocalRemainingName;
    UNICODE_STRING FinalName;

    PLCB NameLink;
    PLCB CurrentLcb = NULL;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( *CurrentFcb );
    ASSERT_EXCLUSIVE_FCB( *CurrentFcb );

    //
    //  Make a local copy of the input strings.
    //

    LocalRemainingName = *RemainingName;

    //
    //  Loop until we find the longest matching prefix.
    //

    while (TRUE) {

        //
        //  If there are no characters left or we are not at an IndexFcb then
        //  return immediately.
        //

        if ((LocalRemainingName.Length == 0) ||
            (SafeNodeType( *CurrentFcb ) != UDFS_NTC_FCB_INDEX)) {

            return CurrentLcb;
        }

        //
        //  Split off the next component from the name.
        //

        UdfDissectName( IrpContext,
                        &LocalRemainingName,
                        &FinalName );

        //
        //  Check if this name is in the splay tree for this Scb.
        //

        if (IgnoreCase) {

            NameLink = UdfFindNameLink( IrpContext,
                                        &(*CurrentFcb)->IgnoreCaseRoot,
                                        &FinalName );

        } else {

            NameLink = UdfFindNameLink( IrpContext,
                                        &(*CurrentFcb)->ExactCaseRoot,
                                        &FinalName );
        }

        //
        //  If we didn't find a match then exit.
        //

        if (NameLink == NULL) { 

            break;
        }

        CurrentLcb = NameLink;

        //
        //  If this is a case-insensitive match then copy the exact case of the name into
        //  the input buffer.
        //

        if (IgnoreCase) {

            RtlCopyMemory( FinalName.Buffer,
                           NameLink->FileName.Buffer,
                           NameLink->FileName.Length );
        }

        //
        //  Update the caller's remaining name string to reflect the fact that we found
        //  a match.
        //

        *RemainingName = LocalRemainingName;

        //
        //  Move down to the next component in the tree.  Acquire without waiting.
        //  If this fails then lock the Fcb to reference this Fcb and then drop
        //  the parent and acquire the child.
        //

        ASSERT( NameLink->ParentFcb == *CurrentFcb );

        if (!UdfAcquireFcbExclusive( IrpContext, NameLink->ChildFcb, TRUE )) {

            //
            //  If we can't wait then raise CANT_WAIT.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            UdfLockVcb( IrpContext, IrpContext->Vcb );
            NameLink->ChildFcb->FcbReference += 1;
            NameLink->Reference += 1;
            UdfUnlockVcb( IrpContext, IrpContext->Vcb );

            UdfReleaseFcb( IrpContext, *CurrentFcb );
            UdfAcquireFcbExclusive( IrpContext, NameLink->ChildFcb, FALSE );

            UdfLockVcb( IrpContext, IrpContext->Vcb );
            NameLink->ChildFcb->FcbReference -= 1;
            NameLink->Reference -= 1;
            UdfUnlockVcb( IrpContext, IrpContext->Vcb );

        } else {

            UdfReleaseFcb( IrpContext, *CurrentFcb );
        }

        *CurrentFcb = NameLink->ChildFcb;
    }

    return CurrentLcb;
}



VOID            
UdfInitializeLcbFromDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine performs common initialization of Lcbs from found directory
    entries.

Arguments:

    Lcb - the Lcb to initialize.
    
    DirContext - the directory enumeration context, enumerated to the FID associated
        with this Lcb.
    
Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( Lcb );

    ASSERT( DirContext->Fid != NULL );

    //
    //  This is falling down trivial now.  Simply update the hidden flag in the Lcb.
    //

    if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_HIDDEN )) {

        SetFlag( Lcb->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
    }
}


//
//  Local support routine
//

PLCB
UdfFindNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine searches through a splay link tree looking for a match for the
    input name.  If we find the corresponding name we will rebalance the
    tree.

Arguments:

    RootNode - Supplies the parent to search.

    Name - This is the name to search for.  Note if we are doing a case
        insensitive search the name would have been upcased already.

Return Value:

    PLCB - The name link found or NULL if there is no match.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PLCB Node;
    PRTL_SPLAY_LINKS Links;

    PAGED_CODE();

    Links = *RootNode;

    while (Links != NULL) {

        Node = CONTAINING_RECORD( Links, LCB, Links );

        //
        //  Compare the prefix in the tree with the full name
        //

        Comparison = UdfFullCompareNames( IrpContext, &Node->FileName, Name );

        //
        //  See if they don't match
        //

        if (Comparison == GreaterThan) {

            //
            //  The prefix is greater than the full name
            //  so we go down the left child
            //

            Links = RtlLeftChild( Links );

            //
            //  And continue searching down this tree
            //

        } else if (Comparison == LessThan) {

            //
            //  The prefix is less than the full name
            //  so we go down the right child
            //

            Links = RtlRightChild( Links );

            //
            //  And continue searching down this tree
            //

        } else {

            //
            //  We found it.
            //
            //  Splay the tree and save the new root.
            //

            *RootNode = RtlSplay( Links );

            return Node;
        }
    }

    //
    //  We didn't find the Link.
    //

    return NULL;
}


//
//  Local support routine
//

BOOLEAN
UdfInsertNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PLCB NameLink
    )

/*++

Routine Description:

    This routine will insert a name in the splay tree pointed to
    by RootNode.

Arguments:

    RootNode - Supplies a pointer to the table.

    NameLink - Contains the new link to enter.

Return Value:

    BOOLEAN - TRUE if the name is inserted, FALSE otherwise.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PLCB Node;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    RtlInitializeSplayLinks( &NameLink->Links );

    //
    //  If we are the first entry in the tree, just become the root.
    //

    if (*RootNode == NULL) {

        *RootNode = &NameLink->Links;

        return TRUE;
    }

    Node = CONTAINING_RECORD( *RootNode, LCB, Links );

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert.
        //

        Comparison = UdfFullCompareNames( IrpContext, &Node->FileName, &NameLink->FileName );

        //
        //  If we found the entry, return immediately.
        //

        if (Comparison == EqualTo) { return FALSE; }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == GreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild( &Node->Links ) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                RtlInsertAsLeftChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild( &Node->Links ),
                                          LCB,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases as less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild( &Node->Links ) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                RtlInsertAsRightChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild( &Node->Links ),
                                          LCB,
                                          Links );
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\resrcsup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Udfs Resource acquisition routines

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	10-Jul-1996
    Tom Jolly       [tomjolly]  21-Jan-2000
    
Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_RESRCSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_RESRCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfAcquireForCache)
#pragma alloc_text(PAGE, UdfAcquireForCreateSection)
#pragma alloc_text(PAGE, UdfAcquireResource)
#pragma alloc_text(PAGE, UdfNoopAcquire)
#pragma alloc_text(PAGE, UdfNoopRelease)
#pragma alloc_text(PAGE, UdfReleaseForCreateSection)
#pragma alloc_text(PAGE, UdfReleaseFromCache)
#endif


BOOLEAN
UdfAcquireResource (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE Resource,
    IN BOOLEAN IgnoreWait,
    IN TYPE_OF_ACQUIRE Type
    )

/*++

Routine Description:

    This is the single routine used to acquire file system resources.  It
    looks at the IgnoreWait flag to determine whether to try to acquire the
    resource without waiting.  Returning TRUE/FALSE to indicate success or
    failure.  Otherwise it is driven by the WAIT flag in the IrpContext and
    will raise CANT_WAIT on a failure.

Arguments:

    Resource - This is the resource to try and acquire.

    IgnoreWait - If TRUE then this routine will not wait to acquire the
        resource and will return a boolean indicating whether the resource was
        acquired.  Otherwise we use the flag in the IrpContext and raise
        if the resource is not acquired.

    Type - Indicates how we should try to get the resource.

Return Value:

    BOOLEAN - TRUE if the resource is acquired.  FALSE if not acquired and
        IgnoreWait is specified.  Otherwise we raise CANT_WAIT.

--*/

{
    BOOLEAN Wait = FALSE;
    BOOLEAN Acquired;
    PAGED_CODE();

    //
    //  We look first at the IgnoreWait flag, next at the flag in the Irp
    //  Context to decide how to acquire this resource.
    //

    if (!IgnoreWait && FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        Wait = TRUE;
    }

    //
    //  Attempt to acquire the resource either shared or exclusively.
    //

    switch (Type) {
        case AcquireExclusive:
        
            Acquired = ExAcquireResourceExclusiveLite( Resource, Wait );
            break;

        case AcquireShared:
            
            Acquired = ExAcquireResourceSharedLite( Resource, Wait );
            break;

        case AcquireSharedStarveExclusive:
            
            Acquired = ExAcquireSharedStarveExclusive( Resource, Wait );
            break;

        default:
            ASSERT( FALSE );
            Acquired = FALSE;
    }

    //
    //  If not acquired and the user didn't specifiy IgnoreWait then
    //  raise CANT_WAIT.
    //

    if (!Acquired && !IgnoreWait) {

        UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    return Acquired;
}


BOOLEAN
UdfAcquireForCache (
    IN PFCB Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer for synchronization.

Arguments:

    Fcb -  The pointer supplied as context to the cache initialization
           routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IoGetTopLevelIrp() == NULL);
    IoSetTopLevelIrp((PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    return ExAcquireResourceSharedLite( Fcb->Resource, Wait );
}


VOID
UdfReleaseFromCache (
    IN PFCB Fcb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a virtual file.  It is subsequently called by the Lazy Writer to release
    a resource acquired above.

Arguments:

    Fcb -  The pointer supplied as context to the cache initialization
           routine.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);
    IoSetTopLevelIrp( NULL );

    ExReleaseResourceLite( Fcb->Resource );
}


BOOLEAN
UdfNoopAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Vcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    TRUE

--*/

{
    PAGED_CODE();
    return TRUE;
}


VOID
UdfNoopRelease (
    IN PVOID Fcb
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Vcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    PAGED_CODE();
}


VOID
UdfAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This is the callback routine for MM to use to acquire the file exclusively.

Arguments:

    FileObject - File object for a Udffs stream.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Get the Fcb resource exclusively.
    //

    ExAcquireResourceExclusiveLite( &((PFCB) FileObject->FsContext)->FcbNonpaged->FcbResource,
                                TRUE );

    //
    //  Take the File resource shared.  We need this later on when MM calls 
    //  QueryStandardInfo to get the file size.  
    //
    //  If we don't use StarveExclusive,  then we can get wedged behind an 
    //  exclusive waiter who is waiting on someone else holding it shared in the 
    //  read->initializecachemap path (which calls createsection) who is in turn 
    //  waiting on us to finish the create section.
    //

    ExAcquireSharedStarveExclusive( ((PFCB) FileObject->FsContext)->Resource,
                                     TRUE );
}


VOID
UdfReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This is the callback routine for MM to use to release a file acquired with
    the AcquireForCreateSection call above.

Arguments:

    FileObject - File object for a Udffs stream.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Release the resources.
    //

    ExReleaseResourceLite( &((PFCB) FileObject->FsContext)->FcbNonpaged->FcbResource );
    ExReleaseResourceLite( ((PFCB) FileObject->FsContext)->Resource );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\read.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Read called by the
    Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     22-Sep-1996
    Tom Jolly       [tomjolly]  21-Jan-2000

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_READ)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_READ)

//
//  VOID
//  SafeZeroMemory (
//      IN PUCHAR At,
//      IN ULONG ByteCount
//      );
//

//
//  This macro just puts a nice little try-except around RtlZeroMemory
//

#define SafeZeroMemory(IC,AT,BYTE_COUNT) {                  \
    try {                                                   \
        RtlZeroMemory( (AT), (BYTE_COUNT) );                \
    } except( EXCEPTION_EXECUTE_HANDLER ) {                 \
         UdfRaiseStatus( IC, STATUS_INVALID_USER_BUFFER );   \
    }                                                       \
}

//
// Read ahead amount used for normal data files
//

#define READ_AHEAD_GRANULARITY           (0x10000)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonRead)
#endif


NTSTATUS
UdfCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common entry point for NtReadFile calls.  For synchronous requests,
    CommonRead will complete the request in the current thread.  If not
    synchronous the request will be passed to the Fsp if there is a need to
    block.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The result of this operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;
    PVCB Vcb;

    BOOLEAN Wait;
    ULONG PagingIo;
    ULONG SynchronousIo;
    ULONG NonCachedIo;

    LONGLONG StartingOffset;
    LONGLONG ByteRange;
    ULONG ByteCount;
    ULONG ReadByteCount;
    ULONG OriginalByteCount;

    PVOID SystemBuffer, UserBuffer;

    BOOLEAN ReleaseFile = TRUE;
    BOOLEAN ReleaseVmcbMap = FALSE;

    PFILE_OBJECT MappingFileObject;

    UDF_IO_CONTEXT LocalIoContext;

    PAGED_CODE();

    //
    //  If this is a zero length read then return SUCCESS immediately.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Decode the file object and verify we support read on this.  It
    //  must be a user file, stream file or volume file (for a data disk).
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    if ((TypeOfOpen == UnopenedFileObject) || (TypeOfOpen == UserDirectoryOpen)) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    
    Vcb = Fcb->Vcb;

    //
    //  Examine our input parameters to determine if this is noncached and/or
    //  a paging io operation.
    //

    Wait = BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    PagingIo = FlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = FlagOn( Irp->Flags, IRP_NOCACHE );
    SynchronousIo = FlagOn( IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO );

    //
    //  Extract the range of the Io.
    //

    StartingOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    OriginalByteCount = ByteCount = IrpSp->Parameters.Read.Length;

    ByteRange = StartingOffset + ByteCount;

    //
    //  Make sure that Dasd access is always non-cached.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        NonCachedIo = TRUE;
    }

    //
    //  Acquire the file shared to perform the read.  If we are doing paging IO,
    //  it may be the case that we would have a deadlock imminent because we may
    //  block on shared access, so starve out any exclusive waiters.  This requires
    //  a degree of caution - we believe that any paging IO bursts will recede and
    //  allow the exclusive waiter in.
    //

    if (PagingIo) {

        UdfAcquireFileSharedStarveExclusive( IrpContext, Fcb );
    
    } else {
        
        UdfAcquireFileShared( IrpContext, Fcb );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Fcb. Allow reads if this is a DASD handle that is 
        //  dismounting the volume.
        //
        
        if ((TypeOfOpen != UserVolumeOpen) || (NULL == Ccb) ||
            !FlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE))  {

            UdfVerifyFcbOperation( IrpContext, Fcb );
        }

        //
        //  If this is a user request then verify the oplock and filelock state.
        //

        if (TypeOfOpen == UserFileOpen) {

            //
            //  We check whether we can proceed
            //  based on the state of the file oplocks.
            //

            Status = FsRtlCheckOplock( &Fcb->Oplock,
                                       Irp,
                                       IrpContext,
                                       UdfOplockComplete,
                                       UdfPrePostIrp );

            //
            //  If the result is not STATUS_SUCCESS then the Irp was completed
            //  elsewhere.
            //

            if (Status != STATUS_SUCCESS) {

                Irp = NULL;
                IrpContext = NULL;

                try_leave( Status );
            }

            if (!PagingIo &&
                (Fcb->FileLock != NULL) &&
                !FsRtlCheckLockForReadAccess( Fcb->FileLock, Irp )) {

                try_leave( Status = STATUS_FILE_LOCK_CONFLICT );
            }
        }



        if ((TypeOfOpen != UserVolumeOpen) || !FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO )) {

            //
            //  Complete the request if it begins beyond the end of file.
            //

            if (StartingOffset >= Fcb->FileSize.QuadPart) {

                try_leave( Status = STATUS_END_OF_FILE );
            }

            //
            //  Truncate the read if it extends beyond the end of the file.
            //

            if (ByteRange > Fcb->FileSize.QuadPart) {

                ByteCount = (ULONG) (Fcb->FileSize.QuadPart - StartingOffset);
                ByteRange = Fcb->FileSize.QuadPart;
            }

        }

        //
        //  Now if the data is embedded in the ICB, map through the metadata
        //  stream to retrieve the bytes.
        //
            
        if (FlagOn( Fcb->FcbState, FCB_STATE_EMBEDDED_DATA )) {

            //
            //  The metadata stream better be here by now.
            //

            ASSERT( Vcb->MetadataFcb->FileObject != NULL );

            //
            //  Bias our starting offset by the offset of the ICB in the metadata
            //  stream plus the offset of the data bytes in that ICB.  Obviously,
            //  we aren't doing non-cached IO here.
            //

            StartingOffset += (BytesFromSectors( Vcb, Fcb->EmbeddedVsn ) + Fcb->EmbeddedOffset);
            MappingFileObject = Vcb->MetadataFcb->FileObject;
            NonCachedIo = FALSE;

            //
            //  Ensure that we're mapping within the range of the metadata stream
            //

            ASSERT( (StartingOffset + ByteCount) <= Vcb->MetadataFcb->FileSize.QuadPart);
 
        } else {

            //
            //  We are mapping through the caller's fileobject
            //
            
            MappingFileObject = IrpSp->FileObject;
        }
        
        //
        //  Handle the non-cached read first.
        //

        if (NonCachedIo) {

            //
            //  If we have an unaligned transfer then post this request if
            //  we can't wait.  Unaligned means that the starting offset
            //  is not on a sector boundary or the read is not integral
            //  sectors.
            //

            ReadByteCount = SectorAlign( Vcb, ByteCount );

            if (SectorOffset( Vcb,  StartingOffset ) ||
                (ReadByteCount > OriginalByteCount)) {

                if (!Wait) {

                    UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
                }

                //
                //  Make sure we don't overwrite the buffer.
                //

                ReadByteCount = ByteCount;
            }

            //
            //  Initialize the IoContext for the read.
            //  If there is a context pointer, we need to make sure it was
            //  allocated and not a stale stack pointer.
            //

            if (IrpContext->IoContext == NULL ||
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

                //
                //  If we can wait, use the context on the stack.  Otherwise
                //  we need to allocate one.
                //

                if (Wait) {

                    IrpContext->IoContext = &LocalIoContext;
                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

                } else {

                    IrpContext->IoContext = UdfAllocateIoContext();
                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                }
            }

            RtlZeroMemory( IrpContext->IoContext, sizeof( UDF_IO_CONTEXT ));
    
            //
            //  Store whether we allocated this context structure in the structure
            //  itself.
            //
    
            IrpContext->IoContext->AllocatedContext =
                BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

            if (Wait) {

                KeInitializeEvent( &IrpContext->IoContext->SyncEvent,
                                   NotificationEvent,
                                   FALSE );

            } else {

                IrpContext->IoContext->ResourceThreadId = ExGetCurrentResourceThread();
                IrpContext->IoContext->Resource = Fcb->Resource;
                IrpContext->IoContext->RequestedByteCount = ByteCount;
            }
    
            Irp->IoStatus.Information = ReadByteCount;

            //
            //  Call the NonCacheIo routine to perform the actual read.
            //

            Status = UdfNonCachedRead( IrpContext, Fcb, Ccb, StartingOffset, ReadByteCount );

            //
            //  Don't complete this request now if STATUS_PENDING was returned.
            //

            if (Status == STATUS_PENDING) {

                Irp = NULL;
                ReleaseFile = FALSE;

            //
            //  Test is we should zero part of the buffer or update the
            //  synchronous file position.
            //

            } else {

                //
                //  Convert any unknown error code to IO_ERROR.
                //

                if (!NT_SUCCESS( Status )) {

                    //
                    //  Set the information field to zero.
                    //

                    Irp->IoStatus.Information = 0;

                    //
                    //  Raise if this is a user induced error.
                    //

                    if (IoIsErrorUserInduced( Status )) {

                        UdfRaiseStatus( IrpContext, Status );
                    }

                    Status = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR );

                //
                //  Check if there is any portion of the user's buffer to zero.
                //

                } else if (ReadByteCount != ByteCount) {

                    UdfMapUserBuffer( IrpContext, &UserBuffer );
                    
                    SafeZeroMemory( IrpContext,
                                    Add2Ptr( UserBuffer,
                                             ByteCount,
                                             PVOID ),
                                    ReadByteCount - ByteCount );

                    Irp->IoStatus.Information = ByteCount;
                }

                //
                //  Update the file position if this is a synchronous request.
                //

                if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

                    IrpSp->FileObject->CurrentByteOffset.QuadPart = ByteRange;
                }
            }

            try_leave( NOTHING );
        }

        //
        //  Handle the cached case.  Start by initializing the private
        //  cache map.
        //

        if (MappingFileObject->PrivateCacheMap == NULL) {

            //
            //  The metadata Fcb stream was fired up before any data read.  We should never
            //  see it here.
            //

            ASSERT( MappingFileObject != Vcb->MetadataFcb->FileObject );
            
            //
            //  Now initialize the cache map.
            //

            CcInitializeCacheMap( IrpSp->FileObject,
                                  (PCC_FILE_SIZES) &Fcb->AllocationSize,
                                  FALSE,
                                  &UdfData.CacheManagerCallbacks,
                                  Fcb );

            CcSetReadAheadGranularity( IrpSp->FileObject, READ_AHEAD_GRANULARITY );
        }

        //
        //  Read from the cache if this is not an Mdl read.
        //

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            //
            // If we are in the Fsp now because we had to wait earlier,
            // we must map the user buffer, otherwise we can use the
            // user's buffer directly.
            //

            UdfMapUserBuffer( IrpContext, &SystemBuffer);

            //
            // Now try to do the copy.
            //
            
            if (MappingFileObject == Vcb->MetadataFcb->FileObject)  {
            
                UdfAcquireVmcbForCcMap( IrpContext, Vcb);
                ReleaseVmcbMap = TRUE;
            }
            
            if (!CcCopyRead( MappingFileObject,
                             (PLARGE_INTEGER) &StartingOffset,
                             ByteCount,
                             Wait,
                             SystemBuffer,
                             &Irp->IoStatus )) {

                try_leave( Status = STATUS_CANT_WAIT );
            }

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                UdfNormalizeAndRaiseStatus( IrpContext, Irp->IoStatus.Status );
            }

            Status = Irp->IoStatus.Status;

        //
        //  Otherwise perform the MdlRead operation.
        //

        } else {

            CcMdlRead( MappingFileObject,
                       (PLARGE_INTEGER) &StartingOffset,
                       ByteCount,
                       &Irp->MdlAddress,
                       &Irp->IoStatus );

            Status = Irp->IoStatus.Status;
        }

        //
        //  Update the current file position in the user file object.
        //

        if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

            IrpSp->FileObject->CurrentByteOffset.QuadPart = ByteRange;
        }

    } finally {

        DebugUnwind( "UdfCommonRead" );

        //
        //  Release the Fcb / Vmcb mapping resource
        //

        if (ReleaseFile)        {   UdfReleaseFile( IrpContext, Fcb );  }

        if (ReleaseVmcbMap)     {   UdfReleaseVmcb( IrpContext, Vcb);   }
    }

    //
    //  Post the request if we got CANT_WAIT.
    //

    if (Status == STATUS_CANT_WAIT) {

        Status = UdfFsdPostRequest( IrpContext, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        UdfCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\strucsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Udfs in-memory data structure manipulation
    routines

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     19-Jun-1996
    Tom Jolly       [TomJolly]  24-Jan-2000

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_STRUCSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_STRUCSUP)

//
//  Define this to change the VAT search strategy to keep looking until
//  we get a read fail/invalid block,  and use the highest found.  Default
//  (undef) is to stop searching at the first valid VAT we find.
//

//#define SEARCH_FOR_HIGHEST_VALID_VAT

//
//  Local structures
//

typedef struct _FCB_TABLE_ELEMENT {

    FILE_ID FileId;
    PFCB Fcb;

} FCB_TABLE_ELEMENT, *PFCB_TABLE_ELEMENT;

//
//  Local macros
//

//
//  PFCB
//  UdfAllocateFcbData (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfDeallocateFcbData (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  PFCB
//  UdfAllocateFcbIndex (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfDeallocateFcbIndex (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  PFCB_NONPAGED
//  UdfAllocateFcbNonpaged (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfDeallocateFcbNonpaged (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB_NONPAGED FcbNonpaged
//      );
//
//  PCCB
//  UdfAllocateCcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfDeallocateCcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCCB Ccb
//      );
//

#define UdfAllocateFcbData(IC) \
    ExAllocateFromPagedLookasideList( &UdfFcbDataLookasideList );

#define UdfDeallocateFcbData(IC,F) \
    ExFreeToPagedLookasideList( &UdfFcbDataLookasideList, F );

#define UdfAllocateFcbIndex(IC) \
    ExAllocateFromPagedLookasideList( &UdfFcbIndexLookasideList );

#define UdfDeallocateFcbIndex(IC,F) \
    ExFreeToPagedLookasideList( &UdfFcbIndexLookasideList, F );

#define UdfAllocateFcbNonpaged(IC) \
    ExAllocateFromNPagedLookasideList( &UdfFcbNonPagedLookasideList );

#define UdfDeallocateFcbNonpaged(IC,FNP) \
    ExFreeToNPagedLookasideList( &UdfFcbNonPagedLookasideList, FNP );

#define UdfAllocateCcb(IC) \
    ExAllocateFromPagedLookasideList( &UdfCcbLookasideList );

#define UdfDeallocateCcb(IC,C) \
    ExFreeToPagedLookasideList( &UdfCcbLookasideList, C );

//
//  VOID
//  UdfInsertFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfDeleteFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//


#define UdfInsertFcbTable(IC,F) {                                   \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.Fcb = (F);                                                 \
    _Key.FileId = (F)->FileId;                                      \
    RtlInsertElementGenericTable( &(F)->Vcb->FcbTable,              \
                                  &_Key,                            \
                                  sizeof( FCB_TABLE_ELEMENT ),      \
                                  NULL );                           \
}

#define UdfDeleteFcbTable(IC,F) {                                   \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.FileId = (F)->FileId;                                      \
    RtlDeleteElementGenericTable( &(F)->Vcb->FcbTable, &_Key );     \
}

//
//  Discovers the partition the current allocation descriptor's referred extent
//  is on, either explicitly throuigh the descriptor or implicitly through the
//  mapped view.
//

INLINE
USHORT
UdfGetPartitionOfCurrentAllocation (
    IN PALLOC_ENUM_CONTEXT AllocContext
    )
{
    if (AllocContext->AllocType == ICBTAG_F_ALLOC_LONG) {

        return ((PLONGAD) AllocContext->Alloc)->Start.Partition;
    
    } else {

        return AllocContext->IcbContext->Active.Partition;
    }
}

//
//  Builds the Mcb in an Fcb.  Use this after knowing that an Mcb is required
//  for mapping information.
//

INLINE
VOID
UdfInitializeFcbMcb (
    IN PFCB Fcb
    )
{
    //
    //  In certain rare situations, we may get called more than once.
    //  Just reset the allocations.
    //
    
    if (FlagOn( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED )) {
    
        FsRtlResetLargeMcb( &Fcb->Mcb, TRUE );

    } else {
    
        FsRtlInitializeLargeMcb( &Fcb->Mcb, UdfPagedPool );
        SetFlag( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED );
    }
}

//
//  Teardown an Fcb's Mcb as required.
//

INLINE
VOID
UdfUninitializeFcbMcb (
    IN PFCB Fcb
    )
{
    if (FlagOn( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED )) {
    
        FsRtlUninitializeLargeMcb( &Fcb->Mcb );
        ClearFlag( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED );
    }
}

//
//  Local support routines
//

PVOID
UdfAllocateTable (
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    );

PFCB_NONPAGED
UdfCreateFcbNonPaged (
    IN PIRP_CONTEXT IrpContext
    );

VOID
UdfDeleteFcbNonpaged (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB_NONPAGED FcbNonpaged
    );

VOID
UdfDeallocateTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
UdfFcbTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID id1,
    IN PVOID id2
    );

VOID
UdfInitializeAllocationContext (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN BOOLEAN AllowSingleZeroLengthExtent
    );

BOOLEAN
UdfGetNextAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext
    );

BOOLEAN
UdfGetNextAllocationPostProcessing (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext
    );

VOID
UdfLookupActiveIcbInExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG Recurse,
    IN ULONG Length
    );

VOID
UdfInitializeEaContext (
    IN PIRP_CONTEXT IrpContext,
    IN PEA_SEARCH_CONTEXT EaContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG EAType,
    IN UCHAR EASubType
    );

BOOLEAN
UdfLookupEa (
    IN PIRP_CONTEXT IrpContext,
    IN PEA_SEARCH_CONTEXT EaContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfAllocateTable)
#pragma alloc_text(PAGE, UdfCleanupIcbContext)
#pragma alloc_text(PAGE, UdfCleanupIrpContext)
#pragma alloc_text(PAGE, UdfCreateCcb)
#pragma alloc_text(PAGE, UdfCreateFcb)
#pragma alloc_text(PAGE, UdfCreateFcbNonPaged)
#pragma alloc_text(PAGE, UdfCreateIrpContext)
#pragma alloc_text(PAGE, UdfDeallocateTable)
#pragma alloc_text(PAGE, UdfDeleteCcb)
#pragma alloc_text(PAGE, UdfDeleteFcb)
#pragma alloc_text(PAGE, UdfDeleteFcbNonpaged)
#pragma alloc_text(PAGE, UdfDeleteVcb)
#pragma alloc_text(PAGE, UdfFcbTableCompare)
#pragma alloc_text(PAGE, UdfFindInParseTable)
#pragma alloc_text(PAGE, UdfGetNextAllocation)
#pragma alloc_text(PAGE, UdfGetNextAllocationPostProcessing)
#pragma alloc_text(PAGE, UdfGetNextFcb)
#pragma alloc_text(PAGE, UdfInitializeAllocationContext)
#pragma alloc_text(PAGE, UdfInitializeAllocations)
#pragma alloc_text(PAGE, UdfInitializeEaContext)
#pragma alloc_text(PAGE, UdfInitializeFcbFromIcbContext)
#pragma alloc_text(PAGE, UdfInitializeIcbContext)
#pragma alloc_text(PAGE, UdfInitializeStackIrpContext)
#pragma alloc_text(PAGE, UdfInitializeVcb)
#pragma alloc_text(PAGE, UdfLookupActiveIcb)
#pragma alloc_text(PAGE, UdfLookupActiveIcbInExtent)
#pragma alloc_text(PAGE, UdfLookupEa)
#pragma alloc_text(PAGE, UdfLookupFcbTable)
#pragma alloc_text(PAGE, UdfTeardownStructures)
#pragma alloc_text(PAGE, UdfUpdateTimestampsFromIcbContext)
#pragma alloc_text(PAGE, UdfUpdateVcbPhase0)
#pragma alloc_text(PAGE, UdfUpdateVcbPhase1)
#pragma alloc_text(PAGE, UdfVerifyDescriptor)
#endif ALLOC_PRAGMA


BOOLEAN
UdfInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDISK_GEOMETRY DiskGeometry,
    IN ULONG MediaChangeCount
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

    MediaChangeCount - Initial media change count of the target device

Return Value:

    Boolean TRUE if the volume looks reasonable to continue mounting, FALSE
    otherwise.  This routine can raise on allocation failure.

--*/

{
    PAGED_CODE();

    //
    //  We start by first zeroing out all of the VCB, this will guarantee
    //  that any stale data is wiped clean.
    //

    RtlZeroMemory( Vcb, sizeof( VCB ));

    //
    //  Set the proper node type code and node byte size.
    //

    Vcb->NodeTypeCode = UDFS_NTC_VCB;
    Vcb->NodeByteSize = sizeof( VCB );

    //
    //  Initialize the DirNotify structs.  FsRtlNotifyInitializeSync can raise.
    //

    InitializeListHead( &Vcb->DirNotifyList );
    FsRtlNotifyInitializeSync( &Vcb->NotifySync );

    //
    //  Pick up a VPB right now so we know we can pull this filesystem stack
    //  off of the storage stack on demand.  This can raise - if it does,  
    //  uninitialize the notify structures before returning.
    //
    
    try {

        Vcb->SwapVpb = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                 sizeof( VPB ),
                                                 TAG_VPB );
    }
    finally {

        if (AbnormalTermination())  {

            FsRtlNotifyUninitializeSync( &Vcb->NotifySync);
        }
    }

    //
    //  Nothing beyond this point should raise.
    //

    RtlZeroMemory( Vcb->SwapVpb, sizeof( VPB ) );

    //
    //  Initialize the resource variable for the Vcb and files.
    //

    ExInitializeResourceLite( &Vcb->VcbResource );
    ExInitializeResourceLite( &Vcb->FileResource );
    ExInitializeResourceLite( &Vcb->VmcbMappingResource );
    ExInitializeFastMutex( &Vcb->VcbMutex );

    //
    //  Insert this Vcb record on the UdfData.VcbQueue.
    //

    InsertHeadList( &UdfData.VcbQueue, &Vcb->VcbLinks );

    //
    //  Set the Target Device Object and Vpb fields, referencing the
    //  target device.
    //

    ObReferenceObject( TargetDeviceObject );
    Vcb->TargetDeviceObject = TargetDeviceObject;
    Vcb->Vpb = Vpb;

    //
    //  Set the removable media flag based on the real device's
    //  characteristics
    //

    if (FlagOn( Vpb->RealDevice->Characteristics, FILE_REMOVABLE_MEDIA )) {

        SetFlag( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA );
    }

    //
    //  Initialize the generic Fcb Table.
    //

    RtlInitializeGenericTable( &Vcb->FcbTable,
                               (PRTL_GENERIC_COMPARE_ROUTINE) UdfFcbTableCompare,
                               (PRTL_GENERIC_ALLOCATE_ROUTINE) UdfAllocateTable,
                               (PRTL_GENERIC_FREE_ROUTINE) UdfDeallocateTable,
                               NULL );

    //
    //  Show that we have a mount in progress.
    //

    UdfSetVcbCondition( Vcb, VcbMountInProgress);

    //
    //  Refererence the Vcb for two reasons.  The first is a reference
    //  that prevents the Vcb from going away on the last close unless
    //  dismount has already occurred.  The second is to make sure
    //  we don't go into the dismount path on any error during mount
    //  until we get to the Mount cleanup.
    //

    Vcb->VcbResidualReference = UDFS_BASE_RESIDUAL_REFERENCE;
    Vcb->VcbResidualUserReference = UDFS_BASE_RESIDUAL_USER_REFERENCE;

    Vcb->VcbReference = 1 + Vcb->VcbResidualReference;

    //
    //  Set the sector size.
    //

    Vcb->SectorSize = DiskGeometry->BytesPerSector;

    //
    //  Set the sector shift amount.
    //

    Vcb->SectorShift = UdfHighBit( DiskGeometry->BytesPerSector );

    //
    //  Set the media change count on the device
    //

    UdfSetMediaChangeCount( Vcb, MediaChangeCount);

    return TRUE;
}

VOID
UdfCreateOrResetVatAndVmcbStreams( 
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Lbn,
    IN PICBFILE VatIcb,
    IN USHORT Reference
    )
/*++

Routine Description:

    This is pretty ugly, but we have to cobble this maybe-Icb into the metadata stream
    so that initialization/use is possible (embedded data!).  Normally regular Icb searches
    would have done this for us, but since we have to go through such an amusing search
    procedure that isn't possible.  So, add it as a single sector mapping.

    Since this lives in a partition, we can just do the "lookup" in the metadata stream.
    If we did not have this guarantee, we'd need to do a bit more of this by hand.

    As this is at mount time, we are very sure we are the only person messing with the
    metadata stream.

Arguments:

    VatIcb - pointer to memory containing VAT FE that we wish to set up VAT/Vmcb streams for.

    Reference - partition ref of virtual partition.
    
Return Value:

    None.  Raise on error.

--*/
{
    LONGLONG FileId = 0;
    ICB_SEARCH_CONTEXT IcbContext;
    ULONG Vsn;
   
    if (NULL != Vcb->VatFcb) {
    
        UdfResetVmcb( &Vcb->Vmcb );

        CcPurgeCacheSection( Vcb->MetadataFcb->FileObject->SectionObjectPointer,
                             NULL,
                             0,
                             FALSE );
        
        CcPurgeCacheSection( Vcb->VatFcb->FileObject->SectionObjectPointer,
                             NULL,
                             0,
                             FALSE );
    }
    else {
        
        //
        //  This is the first pass.  Stamp out the VAT stream Fcb.
        //

        UdfLockVcb( IrpContext, Vcb );

        try {
        
            Vcb->VatFcb = UdfCreateFcb( IrpContext,
                                        *((PFILE_ID) &FileId),
                                        UDFS_NTC_FCB_INDEX,
                                        NULL );

            UdfIncrementReferenceCounts( IrpContext, Vcb->VatFcb, 1, 1 );
        }
        finally {
        
            UdfUnlockVcb( IrpContext, Vcb );
        }
                    
        //
        //  Point to the file resource and set the flag that will cause mappings
        //  to go through the Vmcb
        //

        Vcb->VatFcb->Resource = &Vcb->FileResource;
    }
    
    //
    //  Establish a mapping for the candidate Vat Icb in the metadata stream 
    //  (we're currently looking at a local buffer filled by readsectors). Note
    //  that this operation uses the presence of Vcb->VatFcb to switch of rounding
    //  of extents to page sizes - a bad thing (tm) for packet written media.
    //

    Vsn = UdfLookupMetaVsnOfExtent( IrpContext,
                                    Vcb,
                                    Reference,
                                    Lbn,
                                    BlockSize( Vcb ),
                                    TRUE );
    //
    //  Now size and try to pick up all of the allocation descriptors for this guy.
    //  We're going to need to conjure an IcbContext for this.
    //

    Vcb->VatFcb->AllocationSize.QuadPart = LlSectorAlign( Vcb, VatIcb->InfoLength );

    Vcb->VatFcb->FileSize.QuadPart =
    Vcb->VatFcb->ValidDataLength.QuadPart = VatIcb->InfoLength;

    //
    //  Now construct the ICB search context we would have had
    //  made in the process of normal ICB discovery.  Since we
    //  were unable to do that, gotta do it by hand. NOTE that
    //  View / VatIcb is NOT a CcMapping,  but a pointer to buffer
    //  we allocated & filled with ReadSectors,  above.
    //
    
    RtlZeroMemory( &IcbContext, sizeof( ICB_SEARCH_CONTEXT ));

    IcbContext.Active.View = (PVOID) VatIcb;
    IcbContext.Active.Partition = Reference;
    IcbContext.Active.Lbn = Lbn;
    IcbContext.Active.Length = UdfRawReadSize( Vcb, BlockSize( Vcb ));
    IcbContext.Active.Vsn = Vsn;                

    try {
    
        UdfInitializeAllocations( IrpContext,
                                  Vcb->VatFcb,
                                  &IcbContext,
                                  FALSE);
    }
    finally {

        UdfCleanupIcbContext( IrpContext, &IcbContext );
    }
    
    //
    //  Create or resize the stream file for the VAT as appropriate.
    //

    if (!FlagOn( Vcb->VatFcb->FcbState, FCB_STATE_INITIALIZED )) {
    
        UdfCreateInternalStream( IrpContext, Vcb, Vcb->VatFcb );
        SetFlag( Vcb->VatFcb->FcbState, FCB_STATE_INITIALIZED );

    } else {

        CcSetFileSizes( Vcb->VatFcb->FileObject, (PCC_FILE_SIZES) &Vcb->VatFcb->AllocationSize );
    }
}



VOID
UdfUpdateVcbPhase0 (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to perform the initial spinup of the volume so that
    we can do reads into it.  Primarily, this is required since virtual partitions
    make us lift the remapping table, and the final sets of descriptors from the volume
    can be off in these virtual partitions.
    
    So, we need to get everything set up to read.

Arguments:

    Vcb - Vcb for the volume being mounted.  We have already set up and completed
        the Pcb.

Return Value:

    None

--*/

{
    LONGLONG FileId = 0;

    PICBFILE VatIcb = NULL;
    PREGID RegId;
    ULONG ThisPass;
    ULONG Psn;
    ULONG Lbn;
    ULONG SectorCount;
    USHORT Reference;

#ifdef SEARCH_FOR_HIGHEST_VALID_VAT
    ULONG LastValidVatLbn = 0;
    ULONG LastValidVatOffset;
    ULONG LastValidVatCount;
#endif

    BOOLEAN UnlockVcb = FALSE;

    PBCB Bcb = NULL;
    LARGE_INTEGER Offset;
    PVAT_HEADER VatHeader = NULL;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    DebugTrace(( +1, Dbg, "UdfUpdateVcbPhase0, Vcb %08x\n", Vcb ));

    try {
        
        //////////////////
        //
        //  Create the Metadata Fcb and refererence it and the Vcb.
        //
        //////////////////

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        Vcb->MetadataFcb = UdfCreateFcb( IrpContext,
                                         *((PFILE_ID) &FileId),
                                         UDFS_NTC_FCB_INDEX,
                                         NULL );

        UdfIncrementReferenceCounts( IrpContext, Vcb->MetadataFcb, 1, 1 );
        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        //
        //  The metadata stream is grown lazily as we reference disk structures.
        //

        Vcb->MetadataFcb->FileSize.QuadPart =
        Vcb->MetadataFcb->ValidDataLength.QuadPart = 
        Vcb->MetadataFcb->AllocationSize.QuadPart = 0;

        //
        //  Initialize the volume Vmcb
        //

        UdfLockFcb( IrpContext, Vcb->MetadataFcb );

        UdfInitializeVmcb( &Vcb->Vmcb,
                           UdfPagedPool,
                           MAXULONG,
                           SectorSize(Vcb) );

        SetFlag( Vcb->VcbState, VCB_STATE_VMCB_INIT);

        UdfUnlockFcb( IrpContext, Vcb->MetadataFcb );

        //
        //  Point to the file resource and set the flag that will cause mappings
        //  to go through the Vmcb
        //

        Vcb->MetadataFcb->Resource = &Vcb->FileResource;

        SetFlag( Vcb->MetadataFcb->FcbState, FCB_STATE_VMCB_MAPPING | FCB_STATE_INITIALIZED );

        //
        //  Create the stream file for this.
        //

        UdfCreateInternalStream( IrpContext, Vcb, Vcb->MetadataFcb );
        
        //////////////////
        //
        //  If this is a volume containing a virtual partition, set up the
        //  Virtual Allocation Table Fcb and adjust the residual reference
        //  counts comensurately.
        //
        //////////////////

        if (FlagOn( Vcb->Pcb->Flags, PCB_FLAG_VIRTUAL_PARTITION )) {

            DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, handling VAT setup\n" ));

            //
            //  Now if some dummy has stuck us in the situation of not giving us
            //  the tools to figure out where the end of the media is, tough luck.
            //

            if (!Vcb->BoundN || Vcb->BoundN < ANCHOR_SECTOR) {

                DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, no end bound was discoverable!\n" ));

                UdfRaiseStatus( IrpContext, STATUS_UNRECOGNIZED_VOLUME );
            }

            //
            //  We take care of this first since the residuals must be in place
            //  if we raise while finding the VAT, else we will get horribly
            //  confused when the in-progress references are seen.  We will think
            //  that the extra real referenes are indications that the volume can't
            //  be dismounted.
            //
            
            Vcb->VcbResidualReference += UDFS_CDUDF_RESIDUAL_REFERENCE;
            Vcb->VcbResidualUserReference += UDFS_CDUDF_RESIDUAL_USER_REFERENCE;

            Vcb->VcbReference += UDFS_CDUDF_RESIDUAL_REFERENCE;

            //
            //  Now, we need to hunt about for the VAT ICB.  This is defined, on
            //  closed media (meaning that the sessions have been finalized for use
            //  in CDROM drives), to be in the very last information sector on the
            //  media.  Complicating this simple picture is that CDROMs tell us the
            //  "last sector" by telling us where the start of the leadout area is,
            //  not where the end of the informational sectors are.  This is an
            //  important distinction because any combination of the following can
            //  be used in closing a CDROM session: 2 runout sectors, and/or 150
            //  sectors (2 seconds) of postgap, or nothing.  Immediately after these
            //  "closing" writes is where the leadout begins.
            //
            //  Runout is usually found on CD-E media and corresponds to the time it
            //  will take to turn the writing laser off.  Postgap is what is used to
            //  generate audio pauses.  It is easy to see that the kind of media and
            //  kind of mastering tool/system used will affect us here.  There is no
            //  way to know either ahead of time.
            //
            //  So, finally, these are the offsets from our previously discovered
            //  bounding information where we might find the last information sector:
            //
            //          -152    runout + postgap
            //          -150    postgap
            //          -2      runout
            //          0       nothing
            //
            //  We must search these from low to high since it is extrememly expensive
            //  to guess wrong - CDROMs will sit there for tens of seconds trying to
            //  read unwritten/unreadable sectors.  Hopefully we will find the VAT
            //  ICB beforehand.
            //
            //  This should all be highly disturbing.
            //

            VatIcb = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                               UdfRawBufferSize( Vcb, BlockSize( Vcb )),
                                               TAG_NSR_VDSD);

            for (ThisPass = 0; ThisPass < 4; ThisPass++) {

                //
                //  Lift the appropriate sector.  The discerning reader will be confused that
                //  this is done in sector terms, not block.  So is the implementor.
                //
                
                Psn = Vcb->BoundN - ( ThisPass == 0? 152 :
                                    ( ThisPass == 1? 150 :
                                    ( ThisPass == 2? 2 : 0 )));

                DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, looking at Psn 0x%08x\n", Psn ));

                //
                //  Now, try to figure out what physical partition this sector lives in so
                //  that we can eventually establish workable metadata mappings to it and
                //  dereference short allocation descriptors it may use.
                //

                for (Reference = 0;
                     Reference < Vcb->Pcb->Partitions;
                     Reference++) {
    
                    if (Vcb->Pcb->Partition[Reference].Type == Physical &&
                        Vcb->Pcb->Partition[Reference].Physical.Start <= Psn &&
                        Vcb->Pcb->Partition[Reference].Physical.Start +
                        Vcb->Pcb->Partition[Reference].Physical.Length > Psn) {
    
                        break;
                    }
                }
                
                //
                //  If this sector is not contained in a partition, we do not
                //  need to look at it.
                //
                
                if (Reference == Vcb->Pcb->Partitions) {
                    
                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but it isn't in a partition.\n" ));

                    continue;
                }
                
                DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... in partition Ref %u.\n",  Reference ));

                //
                //  We must locate the Lbn of this Psn by figuring out the offset of it
                //  in the partition we already know that it is recorded in.
                //
                
                Lbn = BlocksFromSectors( Vcb, Psn - Vcb->Pcb->Partition[Reference].Physical.Start );

                if (!NT_SUCCESS( UdfReadSectors( IrpContext,
                                                 LlBytesFromSectors( Vcb, Psn ),
                                                 UdfRawReadSize( Vcb, BlockSize( Vcb )),
                                                 TRUE,
                                                 VatIcb,
                                                 Vcb->TargetDeviceObject ))) {

                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but couldn't read it.\n" ));

                    continue;
                }

                //
                //  First make sure this looks vaguely like a file entry.
                //

                if (!( (((PDESTAG) VatIcb)->Ident == DESTAG_ID_NSR_FILE) || 
                       (((PDESTAG) VatIcb)->Ident == DESTAG_ID_NSR_EXT_FILE)) 
                    ||
                    !UdfVerifyDescriptor( IrpContext,
                                          (PDESTAG) VatIcb,
                                          ((PDESTAG) VatIcb)->Ident,
                                          BlockSize( Vcb ),
                                          Lbn,
                                          TRUE )) {

                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but it didn't verify.\n" ));

                    continue;
                }

                //
                //  Make sure this has filetype of NOTSPEC(1.50) or VAT(2.0x).  We can also presume 
                //  that a VAT isn't linked into any directory, so it would be surprising if the link 
                //  count was nonzero.
                //
                //  4.13.01 - Relaxed the linkcount check.  If it's the right type,  and it passed
                //            CRC/Checksum in verify above,  that's good enough.
                //

                if (UdfVATIcbFileTypeExpected( Vcb) != VatIcb->Icbtag.FileType)  {

                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but the type 0x%x is wrong.\n", VatIcb->Icbtag.FileType));

                    continue;
                }
                
#ifdef UDF_SANITY
                if (0 != VatIcb->LinkCount)  {

                    DebugTrace(( 0, Dbg, "WARNING: VAT linkcount (%d) unexpectedly non-zero\n", VatIcb->LinkCount ));
                }
#endif
                //
                //  The VAT must be at least large enough to contain the required information and
                //  be a multiple of 4byte elements in length.  We also have defined a sanity upper
                //  bound beyond which we never expect to see a VAT go.
                //

                ASSERT( !LongOffset( UdfMinLegalVATSize( Vcb) ));
            
                if (VatIcb->InfoLength < UdfMinLegalVATSize( Vcb) ||
                    VatIcb->InfoLength > UDF_CDUDF_MAXIMUM_VAT_SIZE ||
                    LongOffset( VatIcb->InfoLength )) {
                
                    DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... but the size (0x%X) looks pretty bogus.\n", VatIcb->InfoLength ));

                    continue;
                }

                //
                //  At this point we have to take a wild guess that this will be the guy.  Since the only
                //  way to be sure is to look at the very end of the file an look for the regid (1.50), or
                //  the beginning for the VAT header record (2.0x),  go map this thing.
                //
    
                //
                //  Zap any previous mapping and invalidate the metadata and VAT stream content.
                //
                
                UdfUnpinData( IrpContext, &Bcb );

                UdfCreateOrResetVatAndVmcbStreams( IrpContext,
                                                   Vcb,
                                                   Lbn,
                                                   VatIcb,
                                                   Reference);

                //
                //  To complete VAT discovery, we now look for the regid at the end of the stream
                //  (1.50) or a header at the beginning (2.0x) that will definitively tell us that 
                //  this is really a VAT.   We already know the stream is big enough by virtue of our
                //  preliminary sanity checks.
                //

                if (UdfVATHasHeaderRecord( Vcb))  {

                    //
                    //  UDF 2.0x style VAT.  Map the header record,  and ensure the size looks
                    //  sensible.  Store total header size (incl imp. use) in the Vcb so we know
                    //  the offset to the first VAT mapping entry.
                    //

                    Offset.QuadPart = 0;
                    
                    CcMapData( Vcb->VatFcb->FileObject,
                               &Offset,
                               sizeof(VAT_HEADER),
                               TRUE,
                               &Bcb,
                               &VatHeader );

                    if ( ( (sizeof( VAT_HEADER) + VatHeader->ImpUseLength) != VatHeader->Length) ||
                         ( VatHeader->ImpUseLength && ((VatHeader->ImpUseLength < 32) || ( VatHeader->ImpUseLength & 0x03)))
                       )  {

                        //
                        //  Header is wrong size,  or impl. use length is not dword aligned or is < 32 bytes
                        //  Oh well,  this isn't it....
                        //

                        DebugTrace((0, Dbg, "UdfUpdateVcbPhase0()  Invalid VAT header L 0x%X, IUL 0x%X\n", VatHeader->Length, VatHeader->ImpUseLength));
                        continue;
                    }
                    
                    Vcb->OffsetToFirstVATEntry = VatHeader->Length;
                    Vcb->VATEntryCount = (Vcb->VatFcb->FileSize.LowPart - Vcb->OffsetToFirstVATEntry) / sizeof(ULONG);
                    
                    DebugTrace((0, Dbg, "UdfUpdateVcbPhase0()  Successfully set up a 2.0x style VAT\n"));
                }
                else {
                
                    //
                    //  UDF 1.5 style VAT.  Bias from the back by the previous VAT pointer and the 
                    //  regid itself.
                    //

                    Offset.QuadPart = Vcb->VatFcb->FileSize.QuadPart - UDF_CDUDF_TRAILING_DATA_SIZE;

                    CcMapData( Vcb->VatFcb->FileObject,
                               &Offset,
                               sizeof(REGID),
                               TRUE,
                               &Bcb,
                               &RegId );

                    if (!UdfUdfIdentifierContained( RegId,
                                                    &UdfVatTableIdentifier,
                                                    UDF_VERSION_150,
                                                    UDF_VERSION_150,
                                                    OSCLASS_INVALID,
                                                    OSIDENTIFIER_INVALID )) {
                        //
                        //  Oh well, no go here.
                        //
                        
                        DebugTrace((0, Dbg, "UdfUpdateVcbPhase0() VAT Regid didn't verify\n"));                        
                        continue;
                    }
                    
                    Vcb->OffsetToFirstVATEntry = 0;
                    Vcb->VATEntryCount = (Vcb->VatFcb->FileSize.LowPart - UDF_CDUDF_TRAILING_DATA_SIZE) / sizeof(ULONG);
                    
                    DebugTrace((0, Dbg, "UdfUpdateVcbPhase0()  Successfully set up a 1.50 style VAT\n"));
                }

                //
                //  Found a valid one.
                //

#ifdef SEARCH_FOR_HIGHEST_VALID_VAT

                //
                //  But we must continue until a read fails,  and use the highest block
                //  containig a valid VAT that we find.  Otherwise we may pick up an old
                //  VAT by mistake.
                //
                
                LastValidVatLbn = Lbn;
                LastValidVatOffset = Vcb->OffsetToFirstVATEntry;
                LastValidVatCount = Vcb->VATEntryCount;
#else
                break;
#endif
            }

            //
            //  If we didn't find anything ...
            //

#ifdef SEARCH_FOR_HIGHEST_VALID_VAT
            if ((ThisPass == 4) || (0 == LastValidVatLbn))  {
#else            
            if (ThisPass == 4)  {
#endif
                DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... and so we didn't find a VAT!\n" ));

                UdfRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }

#ifdef SEARCH_FOR_HIGHEST_VALID_VAT

            //
            //  Switch back to the last valid VAT,  if we tried blocks following it.
            //
            
            if (Lbn != LastValidVatLbn)  {

                DebugTrace(( 0, Dbg,"Reverting to last valid VAT @ PSN 0x%x\n", LastValidVatLbn));

                Offset.QuadPart = LlBytesFromSectors( Vcb, LastValidVatLbn + Vcb->Pcb->Partition[Reference].Physical.Start);
                
                if (!NT_SUCCESS( UdfReadSectors( IrpContext,
                                                 Offset.QuadPart,
                                                 UdfRawReadSize( Vcb, BlockSize( Vcb )),
                                                 TRUE,
                                                 VatIcb,
                                                 Vcb->TargetDeviceObject ))) {
                    
                    DebugTrace(( 0, Dbg, "Failed to re-read previous valid VAT sector\n" ));

                    UdfRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
                }
                
                UdfUnpinData( IrpContext, &Bcb );

                UdfCreateOrResetVatAndVmcbStreams( IrpContext,
                                                   Vcb,
                                                   LastValidVatLbn,
                                                   VatIcb,
                                                   Reference);

                Vcb->OffsetToFirstVATEntry = LastValidVatOffset;
                Vcb->VATEntryCount = LastValidVatCount;
            }
#endif
            //
            //  Go find the virtual reference so we can further update the Pcb
            //  with information from the VAT.
            //

            for (Reference = 0;
                 Reference < Vcb->Pcb->Partitions;
                 Reference++) {

                if (Vcb->Pcb->Partition[Reference].Type == Virtual) {

                    break;
                }
            }

            ASSERT( Reference < Vcb->Pcb->Partitions );

            //
            //  We note the length so we can easily do bounds checking for
            //  virtual mappings.
            //
            
            Offset.QuadPart = (Vcb->VatFcb->FileSize.QuadPart -
                               UDF_CDUDF_TRAILING_DATA_SIZE) / sizeof(ULONG);

            ASSERT( Offset.HighPart == 0 );
            Vcb->Pcb->Partition[Reference].Virtual.Length = Offset.LowPart;

            DebugTrace(( 0, Dbg, "UdfUpdateVcbPhase0, ... got it!\n" ));
        }

    } 
    finally {

        DebugUnwind( "UdfUpdateVcbPhase0" );

        UdfUnpinData( IrpContext, &Bcb );
        if (UnlockVcb) { UdfUnlockVcb( IrpContext, Vcb ); }
        if (VatIcb) { ExFreePool( VatIcb ); }
    }

    DebugTrace(( -1, Dbg, "UdfUpdateVcbPhase0 -> VOID\n" ));
}


VOID
UdfUpdateVcbPhase1 (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PNSR_FSD Fsd
    )

/*++

Routine Description:

    This routine is called to perform the final initialization of a Vcb and Vpb
    from the volume descriptors on the disk.

Arguments:

    Vcb - Vcb for the volume being mounted.  We have already done phase 0.

    Fsd - The fileset descriptor for this volume.
    
Return Value:

    None

--*/

{
    ICB_SEARCH_CONTEXT IcbContext;

    LONGLONG FileId = 0;

    PFCB Fcb;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN UnlockFcb = FALSE;
    BOOLEAN CleanupIcbContext = FALSE;

    ULONG Reference;

    ULONG BoundSector = 0;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    DebugTrace(( +1, Dbg, "UdfUpdateVcbPhase1, Vcb %08x Fsd %08x\n", Vcb, Fsd ));

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Do the final internal Fcb's and other Vcb fields.
        //

        //////////////////
        //
        //  Create the root index and reference it in the Vcb.
        //
        //////////////////

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;
        
        Vcb->RootIndexFcb = UdfCreateFcb( IrpContext,
                                          *((PFILE_ID) &FileId),
                                          UDFS_NTC_FCB_INDEX,
                                          NULL );

        UdfIncrementReferenceCounts( IrpContext, Vcb->RootIndexFcb, 1, 1 );
        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        //
        //  Create the File id by hand for this Fcb.
        //

        UdfSetFidFromLbAddr( Vcb->RootIndexFcb->FileId, Fsd->IcbRoot.Start );
        UdfSetFidDirectory( Vcb->RootIndexFcb->FileId );
        Vcb->RootIndexFcb->RootExtentLength = Fsd->IcbRoot.Length.Length;

        //
        //  Get the direct entry for the root directory and initialize
        //  the Fcb from it.
        //

        UdfInitializeIcbContextFromFcb( IrpContext,
                                        &IcbContext,
                                        Vcb->RootIndexFcb );
        CleanupIcbContext = TRUE;

        UdfLookupActiveIcb( IrpContext, 
                            &IcbContext, 
                            Vcb->RootIndexFcb->RootExtentLength );
        //
        //  Note: the vcb lock here is just to satisfy sanity checks in function.
        //
        
        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;
        
        UdfInitializeFcbFromIcbContext( IrpContext,
                                        Vcb->RootIndexFcb,
                                        &IcbContext,
                                        NULL);
        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;
        
        UdfCleanupIcbContext( IrpContext, &IcbContext );
        CleanupIcbContext = FALSE;

        //
        //  Create the stream file for the root directory.
        //

        UdfCreateInternalStream( IrpContext, Vcb, Vcb->RootIndexFcb );

        //////////////////
        //
        //  Now do the volume dasd Fcb.  Create this and reference it in the
        //  Vcb.
        //
        //////////////////

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        Vcb->VolumeDasdFcb = UdfCreateFcb( IrpContext,
                                           *((PFILE_ID) &FileId),
                                           UDFS_NTC_FCB_DATA,
                                           NULL );

        UdfIncrementReferenceCounts( IrpContext, Vcb->VolumeDasdFcb, 1, 1 );
        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        Fcb = Vcb->VolumeDasdFcb;
        UdfLockFcb( IrpContext, Fcb );
        UnlockFcb = TRUE;

        //
        //  If we were unable to determine a last sector on the media, walk the Pcb and guess
        //  that it is probably OK to think of the last sector of the last partition as The
        //  Last Sector.  Note that we couldn't do this before since the notion of a last
        //  sector has significance at mount time, if it had been possible to find one.
        //

        for ( Reference = 0;
              Reference < Vcb->Pcb->Partitions;
              Reference++ ) {

            if (Vcb->Pcb->Partition[Reference].Type == Physical &&
                Vcb->Pcb->Partition[Reference].Physical.Start +
                Vcb->Pcb->Partition[Reference].Physical.Length > BoundSector) {

                BoundSector = Vcb->Pcb->Partition[Reference].Physical.Start +
                              Vcb->Pcb->Partition[Reference].Physical.Length;
            }
        }

        //
        //  Note that we cannot restrict the bound by the "physical" bound discovered
        //  eariler.  This is because the MSF format of the TOC request we send is only
        //  capable of representing about 2.3gb, and a lot of media we will be on that
        //  responds to TOCs will be quite a bit larger - ex: DVD.
        //
        //  This, of course, barring proper means of discovering media bounding, prohibits
        //  the possibility of having UDF virtual partitions on DVD-R.
        //

        //
        //  Build the mapping from [0, Bound).  We have to initialize the Mcb by hand since
        //  this is usually left to when we lift retrieval information from an Icb in
        //  UdfInitializeAllocations.
        //

        UdfInitializeFcbMcb( Fcb );

        FsRtlAddLargeMcbEntry( &Fcb->Mcb,
                               (LONGLONG) 0,
                               (LONGLONG) 0,
                               (LONGLONG) BoundSector );
                               
        Fcb->FileSize.QuadPart += LlBytesFromSectors( Vcb, BoundSector );

        Fcb->AllocationSize.QuadPart =
        Fcb->ValidDataLength.QuadPart = Fcb->FileSize.QuadPart;

        UdfUnlockFcb( IrpContext, Fcb );
        UnlockFcb = FALSE;

        SetFlag( Fcb->FcbState, FCB_STATE_INITIALIZED );

        //
        //  Point to the file resource.
        //

        Vcb->VolumeDasdFcb->Resource = &Vcb->FileResource;

        Vcb->VolumeDasdFcb->FileAttributes = FILE_ATTRIBUTE_READONLY;

    } finally {

        DebugUnwind( "UdfUpdateVcbPhase1" );

        if (CleanupIcbContext) { UdfCleanupIcbContext( IrpContext, &IcbContext ); }

        if (UnlockFcb) { UdfUnlockFcb( IrpContext, Fcb ); }
        if (UnlockVcb) { UdfUnlockVcb( IrpContext, Vcb ); }
    }

    DebugTrace(( -1, Dbg, "UdfUpdateVcbPhase1 -> VOID\n" ));

    return;
}


VOID
UdfDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to delete a Vcb which failed mount or has been
    dismounted.  The dismount code should have already removed all of the
    open Fcb's.  We do nothing here but clean up other auxilary structures.

Arguments:

    Vcb - Vcb to delete.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_EXCLUSIVE_UDFDATA;
    ASSERT_EXCLUSIVE_VCB( Vcb );

    //
    //  Chuck the backpocket Vpb we kept just in case.
    //

    if (Vcb->SwapVpb) {

        ExFreePool( Vcb->SwapVpb );
    }
    
    //
    //  If there is a Vpb then we must delete it ourselves.
    //

    if (Vcb->Vpb != NULL) {

        UdfFreePool( &Vcb->Vpb );
    }

    //
    //  Drop the Pcb.
    //

    if (Vcb->Pcb != NULL) {

        UdfDeletePcb( Vcb->Pcb );
    }

    //
    //  Dereference our target if we haven't already done so.
    //

    if (Vcb->TargetDeviceObject != NULL) {

        ObDereferenceObject( Vcb->TargetDeviceObject );
    }
    
    //
    //  Remove this entry from the global queue.
    //

    RemoveEntryList( &Vcb->VcbLinks );

    //
    //  Delete resources.
    //

    ExDeleteResourceLite( &Vcb->VcbResource );
    ExDeleteResourceLite( &Vcb->FileResource );
    ExDeleteResourceLite( &Vcb->VmcbMappingResource);

    //
    //  Uninitialize the notify structures.
    //

    if (Vcb->NotifySync != NULL) {

        FsRtlNotifyUninitializeSync( &Vcb->NotifySync );
    }

    //
    //  Now delete the volume device object.
    //

    IoDeleteDevice( (PDEVICE_OBJECT) CONTAINING_RECORD( Vcb,
                                                        VOLUME_DEVICE_OBJECT,
                                                        Vcb ));

    return;
}


PIRP_CONTEXT
UdfCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine is called to initialize an IrpContext for the current
    UDFS request.  We allocate the structure and then initialize it from
    the given Irp.

Arguments:

    Irp - Irp for this request.

    Wait - TRUE if this request is synchronous, FALSE otherwise.

Return Value:

    PIRP_CONTEXT - Allocated IrpContext.

--*/

{
    PIRP_CONTEXT NewIrpContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN IsFsDo = FALSE;

    PAGED_CODE();

    IsFsDo = UdfDeviceIsFsDo( IrpSp->DeviceObject);

    //
    //  The only operations a filesystem device object should ever receive
    //  are create/teardown of fsdo handles and operations which do not
    //  occur in the context of fileobjects (i.e., mount).
    //

    if (IsFsDo) {

        if (IrpSp->FileObject != NULL &&
            IrpSp->MajorFunction != IRP_MJ_CREATE &&
            IrpSp->MajorFunction != IRP_MJ_CLEANUP &&
            IrpSp->MajorFunction != IRP_MJ_CLOSE) {

            ExRaiseStatus( STATUS_INVALID_DEVICE_REQUEST );
        }

        ASSERT( IrpSp->FileObject != NULL ||
                
                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST &&
                 IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_INVALIDATE_VOLUMES) ||
                
                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME ) ||

                IrpSp->MajorFunction == IRP_MJ_SHUTDOWN );
    }
    
    NewIrpContext = ExAllocateFromNPagedLookasideList( &UdfIrpContextLookasideList );

    RtlZeroMemory( NewIrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    NewIrpContext->NodeTypeCode = UDFS_NTC_IRP_CONTEXT;
    NewIrpContext->NodeByteSize = sizeof( IRP_CONTEXT );

    //
    //  Set the originating Irp field
    //

    NewIrpContext->Irp = Irp;

    //
    //  Copy RealDevice for workque algorithms.  We will update this in the Mount or
    //  Verify since they have no file objects to use here.
    //

    if (IrpSp->FileObject != NULL) {

        NewIrpContext->RealDevice = IrpSp->FileObject->DeviceObject;
    }

    //
    //  This may be one of our filesystem device objects.  In that case don't
    //  initialize the Vcb field.
    //

    if (!IsFsDo) {
        
        NewIrpContext->Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;
    }

    //
    //  Major/Minor Function codes
    //

    NewIrpContext->MajorFunction = IrpSp->MajorFunction;
    NewIrpContext->MinorFunction = IrpSp->MinorFunction;

    //
    //  Set the wait parameter
    //

    if (Wait) {

        SetFlag( NewIrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    } else {

        SetFlag( NewIrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );
    }

    //
    //  return and tell the caller
    //

    return NewIrpContext;
}


VOID
UdfCleanupIrpContext (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Post
    )

/*++

Routine Description:

    This routine is called to cleanup and possibly deallocate the Irp Context.
    If the request is being posted or this Irp Context is possibly on the
    stack then we only cleanup any auxilary structures.

Arguments:

    Post - TRUE if we are posting this request, FALSE if we are deleting
        or retrying this in the current thread.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  If we aren't doing more processing then deallocate this as appropriate.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING)) {

        //
        //  If this context is the top level UDFS context then we need to
        //  restore the top level thread context.
        //

        if (IrpContext->ThreadContext != NULL) {

            UdfRestoreThreadContext( IrpContext );
        }
        
        //
        //  Deallocate the Io context if allocated.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

            UdfFreeIoContext( IrpContext->IoContext );
        }
        
        //
        //  Deallocate the IrpContext if not from the stack.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ON_STACK )) {

            ExFreeToNPagedLookasideList( &UdfIrpContextLookasideList, IrpContext );
        }

    //
    //  Clear the appropriate flags.
    //

    } else if (Post) {

        //
        //  If this context is the top level UDFS context then we need to
        //  restore the top level thread context.
        //

        if (IrpContext->ThreadContext != NULL) {

            UdfRestoreThreadContext( IrpContext );
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_POST );

    } else {

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY );
    }

    return;
}


VOID
UdfInitializeStackIrpContext (
    OUT PIRP_CONTEXT IrpContext,
    IN PIRP_CONTEXT_LITE IrpContextLite
    )

/*++

Routine Description:

    This routine is called to initialize an IrpContext for the current
    UDFS request.  The IrpContext is on the stack and we need to initialize
    it for the current request.  The request is a close operation.

Arguments:

    IrpContext - IrpContext to initialize.

    IrpContextLite - Structure containing the details of this request.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT_LITE( IrpContextLite );

    //
    //  Zero and then initialize the structure.
    //

    RtlZeroMemory( IrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    IrpContext->NodeTypeCode = UDFS_NTC_IRP_CONTEXT;
    IrpContext->NodeByteSize = sizeof( IRP_CONTEXT );

    //
    //  Note that this is from the stack.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ON_STACK );

    //
    //  Copy RealDevice for workque algorithms.
    //

    IrpContext->RealDevice = IrpContextLite->RealDevice;

    //
    //  The Vcb is found in the Fcb.
    //

    IrpContext->Vcb = IrpContextLite->Fcb->Vcb;

    //
    //  Major/Minor Function codes
    //

    IrpContext->MajorFunction = IRP_MJ_CLOSE;

    //
    //  Set the wait parameter
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    return;
}


VOID
UdfTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB StartingFcb,
    IN BOOLEAN Recursive,
    OUT PBOOLEAN RemovedStartingFcb
    )

/*++

Routine Description:

    This routine is used to walk from some starting point in the Fcb tree towards
    the root.  It will remove the Fcb and continue walking up the tree until
    it finds a point where we can't remove an Fcb.

    We look at the following fields in the Fcb to determine whether we can
    remove this.

        1 - Handle count must be zero.
        2 - If directory then only the only reference can be for a stream file.
        3 - Reference count must either be zero or go to zero here.

    We return immediately if we are recursively entering this routine.

Arguments:

    StartingFcb - This is the Fcb node in the tree to begin with.  This Fcb
        must currently be acquired exclusively.
        
    Recursive - Indicates if this call is an intentional recursion.

    RemovedStartingFcb - Address to store whether we removed the starting Fcb.

Return Value:

    None

--*/

{
    PVCB Vcb = StartingFcb->Vcb;
    PFCB CurrentFcb = StartingFcb;
    BOOLEAN AcquiredCurrentFcb = FALSE;
    PFCB ParentFcb = NULL;
    PLCB Lcb;

    PLIST_ENTRY ListLinks;
    BOOLEAN Abort = FALSE;
    BOOLEAN Removed;
    
    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( StartingFcb );

    *RemovedStartingFcb = FALSE;

    //
    //  If this is not an intentionally recursive call we need to check if this
    //  is a layered close and we're already in another instance of teardown.
    //

    DebugTrace(( +1, Dbg,
                 "UdfTeardownStructures, StartingFcb %08x %s\n",
                 StartingFcb,
                 ( Recursive? "Recursive" : "Flat" )));
    
    if (!Recursive) {
    
        //
        //  If this is a recursive call to TearDownStructures we return immediately
        //  doing no operation.
        //

        if (FlagOn( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN )) {

            return;
        }

        SetFlag( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN );
    }

    //
    //  Use a try-finally to safely clear the top-level field.
    //

    try {

        //
        //  Loop until we find an Fcb we can't remove.
        //

        do {

            //
            //  See if there is an internal stream we should delete.
            //  Only do this if it is the last reference on the Fcb.
            //

            if ((SafeNodeType( CurrentFcb ) != UDFS_NTC_FCB_DATA) &&
                (CurrentFcb->FcbUserReference == 0) &&
                (CurrentFcb->FileObject != NULL)) {

                //
                //  Go ahead and delete the stream file object.
                //

                UdfDeleteInternalStream( IrpContext, CurrentFcb );
            }

            //
            //  If the reference count is non-zero then break.
            //

            if (CurrentFcb->FcbReference != 0) {

                break;
            }

            //
            //  It looks like we have a candidate for removal here.  We
            //  will need to walk the list of prefixes and delete them
            //  from their parents.  If it turns out that we have multiple
            //  parents of this Fcb, we are going to recursively teardown
            //  on each of these.
            //

            for ( ListLinks = CurrentFcb->ParentLcbQueue.Flink;
                  ListLinks != &CurrentFcb->ParentLcbQueue; ) {

                Lcb = CONTAINING_RECORD( ListLinks, LCB, ChildFcbLinks );

                ASSERT_LCB( Lcb );

                //
                //  We advance the pointer now because we will be toasting this guy,
                //  invalidating whatever is here.
                //

                ListLinks = ListLinks->Flink;

                //
                //  We may have multiple parents through hard links.  If the previous parent we
                //  dealt with is not the parent of this new Lcb, lets do some work.
                //
                
                if (ParentFcb != Lcb->ParentFcb) {

                    //
                    //  We need to deal with the previous parent.  It may now be the case that
                    //  we deleted the last child reference and it wants to go away at this point.
                    //
                    
                    if (ParentFcb) {

                        //
                        //  It should never be the case that we have to recurse more than one level on
                        //  any teardown since no cross-linkage of directories is possible.
                        //
                    
                        ASSERT( !Recursive );
                          
                        UdfTeardownStructures( IrpContext, ParentFcb, TRUE, &Removed );

                        if (!Removed) {

                            UdfReleaseFcb( IrpContext, ParentFcb );
                        }
                    }

                    //
                    //  Get this new parent Fcb to work on.
                    //
                    
                    ParentFcb = Lcb->ParentFcb;
                    UdfAcquireFcbExclusive( IrpContext, ParentFcb, FALSE );
                }
                
                //
                //  Lock the Vcb so we can look at references.
                //

                UdfLockVcb( IrpContext, Vcb );

                //
                //  Now check that the reference counts on the Lcb are zero.
                //

                if ( Lcb->Reference != 0 ) {

                    //
                    //  A create is interested in getting in here, so we should
                    //  stop right now.
                    //

                    UdfUnlockVcb( IrpContext, Vcb );
                    UdfReleaseFcb( IrpContext, ParentFcb );
                    Abort = TRUE;

                    break;
                }

                //
                //  Now remove this prefix and drop the references to the parent.
                //

                ASSERT( Lcb->ChildFcb == CurrentFcb );
                ASSERT( Lcb->ParentFcb == ParentFcb );
                
                DebugTrace(( +0, Dbg,
                             "UdfTeardownStructures, Lcb %08x P %08x <-> C %08x Vcb %d/%d PFcb %d/%d CFcb %d/%d\n",
                             Lcb,
                             ParentFcb,
                             CurrentFcb,
                             Vcb->VcbReference,
                             Vcb->VcbUserReference,
                             ParentFcb->FcbReference,
                             ParentFcb->FcbUserReference,
                             CurrentFcb->FcbReference,
                             CurrentFcb->FcbUserReference ));

                UdfRemovePrefix( IrpContext, Lcb );
                UdfDecrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );

                DebugTrace(( +0, Dbg,
                             "UdfTeardownStructures, Vcb %d/%d PFcb %d/%d\n",
                             Vcb->VcbReference,
                             Vcb->VcbUserReference,
                             ParentFcb->FcbReference,
                             ParentFcb->FcbUserReference ));

                UdfUnlockVcb( IrpContext, Vcb );
            }

            //
            //  Now really leave if we have to.
            //
            
            if (Abort) {

                break;
            }

            //
            //  Now that we have removed all of the prefixes of this Fcb we can make the final check.
            //  Lock the Vcb again so we can inspect the child's references.
            //

            UdfLockVcb( IrpContext, Vcb );

            if (CurrentFcb->FcbReference != 0) {

                DebugTrace(( +0, Dbg,
                             "UdfTeardownStructures, saving Fcb %08x %d/%d\n",
                             CurrentFcb,
                             CurrentFcb->FcbReference,
                             CurrentFcb->FcbUserReference ));
                
                //
                //  Nope, nothing more to do.  Stop right now.
                //
                
                UdfUnlockVcb( IrpContext, Vcb );

                if (ParentFcb != NULL) {

                    UdfReleaseFcb( IrpContext, ParentFcb );
                }

                break;
            }

            //
            //  This Fcb is toast.  Remove it from the Fcb Table as appropriate and delete.
            //

            if (FlagOn( CurrentFcb->FcbState, FCB_STATE_IN_FCB_TABLE )) {

                UdfDeleteFcbTable( IrpContext, CurrentFcb );
                ClearFlag( CurrentFcb->FcbState, FCB_STATE_IN_FCB_TABLE );

            }

            //
            //  Unlock the Vcb but hold the parent in order to walk up
            //  the tree.
            //

            DebugTrace(( +0, Dbg,
                         "UdfTeardownStructures, toasting Fcb %08x %d/%d\n",
                         CurrentFcb,
                         CurrentFcb->FcbReference,
                         CurrentFcb->FcbUserReference ));

            UdfUnlockVcb( IrpContext, Vcb );
            UdfDeleteFcb( IrpContext, CurrentFcb );

            //
            //  Move to the parent Fcb.
            //

            CurrentFcb = ParentFcb;
            ParentFcb = NULL;
            AcquiredCurrentFcb = TRUE;

        } while (CurrentFcb != NULL);

    } finally {

        //
        //  Release the current Fcb if we have acquired it.
        //

        if (AcquiredCurrentFcb && (CurrentFcb != NULL)) {

            UdfReleaseFcb( IrpContext, CurrentFcb );
        }

        //
        //  Clear the teardown flag.
        //

        if (!Recursive) {
        
            ClearFlag( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN );
        }
    }

    *RemovedStartingFcb = (CurrentFcb != StartingFcb);

    DebugTrace(( -1, Dbg,
                 "UdfTeardownStructures, RemovedStartingFcb -> %c\n",
                 ( *RemovedStartingFcb? 'T' : 'F' )));

    return;
}


PFCB
UdfLookupFcbTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_ID FileId
    )

/*++

Routine Description:

    This routine will look through the Fcb table looking for a matching
    entry.

Arguments:

    Vcb - Vcb for this volume.

    FileId - This is the key value to use for the search.

Return Value:

    PFCB - A pointer to the matching entry or NULL otherwise.

--*/

{
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Hit;
    PFCB ReturnFcb = NULL;

    PAGED_CODE();

    Key.FileId = FileId;

    Hit = (PFCB_TABLE_ELEMENT) RtlLookupElementGenericTable( &Vcb->FcbTable, &Key );

    if (Hit != NULL) {

        ReturnFcb = Hit->Fcb;
    }

    return ReturnFcb;

    UNREFERENCED_PARAMETER( IrpContext );
}


PFCB
UdfGetNextFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    This routine will enumerate through all of the Fcb's in the Fcb table.

Arguments:

    Vcb - Vcb for this volume.

    RestartKey - This value is used by the table package to maintain
        its position in the enumeration.  It is initialized to NULL
        for the first search.

Return Value:

    PFCB - A pointer to the next fcb or NULL if the enumeration is
        completed

--*/

{
    PFCB Fcb;

    PAGED_CODE();

    Fcb = (PFCB) RtlEnumerateGenericTableWithoutSplaying( &Vcb->FcbTable, RestartKey );

    if (Fcb != NULL) {

        Fcb = ((PFCB_TABLE_ELEMENT)(Fcb))->Fcb;
    }

    return Fcb;
}


PFCB
UdfCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_ID FileId,
    IN NODE_TYPE_CODE NodeTypeCode,
    OUT PBOOLEAN FcbExisted OPTIONAL
    )

/*++

Routine Description:

    This routine is called to find the Fcb for the given FileId.  We will
    look this up first in the Fcb table and if not found we will create
    an Fcb.  We don't initialize it or insert it into the FcbTable in this
    routine.

    This routine is called while the Vcb is locked.

Arguments:

    FileId - This is the Id for the target Fcb.

    NodeTypeCode - Node type for this Fcb if we need to create.

    FcbExisted - If specified, we store whether the Fcb existed.

Return Value:

    PFCB - The Fcb found in the table or created if needed.

--*/

{
    PFCB NewFcb;
    BOOLEAN LocalFcbExisted;

    PAGED_CODE();

    //
    //  Use the local boolean if one was not passed in.
    //

    if (!ARGUMENT_PRESENT( FcbExisted )) {

        FcbExisted = &LocalFcbExisted;
    }

    //
    //  Maybe this is already in the table.
    //

    NewFcb = UdfLookupFcbTable( IrpContext, IrpContext->Vcb, FileId );

    //
    //  If not then create the Fcb is requested by our caller.
    //

    if (NewFcb == NULL) {

        //
        //  Use a try-finally for cleanup
        //

        try {

            //
            //  Allocate and initialize the structure depending on the
            //  type code.
            //
    
            switch (NodeTypeCode) {
    
            case UDFS_NTC_FCB_INDEX:
    
                NewFcb = UdfAllocateFcbIndex( IrpContext );
    
                RtlZeroMemory( NewFcb, SIZEOF_FCB_INDEX );
    
                NewFcb->NodeByteSize = SIZEOF_FCB_INDEX;
    
                break;
    
            case UDFS_NTC_FCB_DATA :
    
                NewFcb = UdfAllocateFcbData( IrpContext );
    
                RtlZeroMemory( NewFcb, SIZEOF_FCB_DATA );
    
                NewFcb->NodeByteSize = SIZEOF_FCB_DATA;
    
                break;
    
            default:
    
                UdfBugCheck( 0, 0, 0 );
            }
    
            //
            //  Now do the common initialization.
            //
    
            NewFcb->NodeTypeCode = NodeTypeCode;
    
            NewFcb->Vcb = IrpContext->Vcb;
            NewFcb->FileId = FileId;
    
            InitializeListHead( &NewFcb->ParentLcbQueue );
            InitializeListHead( &NewFcb->ChildLcbQueue );
    
            //
            //  Now create the non-paged section object.
            //
    
            NewFcb->FcbNonpaged = UdfCreateFcbNonPaged( IrpContext );
    
            //
            //  Initialize Advanced FCB Header fields
            //

            ExInitializeFastMutex( &NewFcb->FcbNonpaged->AdvancedFcbHeaderMutex );
            FsRtlSetupAdvancedHeader( &NewFcb->Header, 
                                      &NewFcb->FcbNonpaged->AdvancedFcbHeaderMutex );

            *FcbExisted = FALSE;

        } finally {

            DebugUnwind( "UdfCreateFcb" );
   
            if (AbnormalTermination()) {

                UdfFreePool( &NewFcb );
            }
        }

    } else {

        *FcbExisted = TRUE;
    }

    return NewFcb;
}


VOID
UdfDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to cleanup and deallocate an Fcb.  We know there
    are no references remaining.  We cleanup any auxilary structures and
    deallocate this Fcb.

Arguments:

    Fcb - This is the Fcb to deallcoate.

Return Value:

    None

--*/

{
    PVCB Vcb = NULL;
    
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Sanity check the counts and Lcb lists.
    //

    ASSERT( Fcb->FcbCleanup == 0 );
    ASSERT( Fcb->FcbReference == 0 );

    ASSERT( IsListEmpty( &Fcb->ChildLcbQueue ));
    ASSERT( IsListEmpty( &Fcb->ParentLcbQueue ));

    //
    //  Release any Filter Context structures associated with this FCB
    //

    FsRtlTeardownPerStreamContexts( &Fcb->Header );

    //
    //  Start with the common structures.
    //

    UdfUninitializeFcbMcb( Fcb );
    
    UdfDeleteFcbNonpaged( IrpContext, Fcb->FcbNonpaged );

    //
    //  Now do the type specific structures.
    //

    switch (Fcb->NodeTypeCode) {

    case UDFS_NTC_FCB_INDEX:

        ASSERT( Fcb->FileObject == NULL );

        if (Fcb == Fcb->Vcb->RootIndexFcb) {

            Vcb = Fcb->Vcb;
            Vcb->RootIndexFcb = NULL;
        
        } else if (Fcb == Fcb->Vcb->MetadataFcb) {

            Vcb = Fcb->Vcb;
            Vcb->MetadataFcb = NULL;

            if (FlagOn( Vcb->VcbState, VCB_STATE_VMCB_INIT))  {

                UdfUninitializeVmcb( &Vcb->Vmcb );
            }
        
        } else if (Fcb == Fcb->Vcb->VatFcb) {

            Vcb = Fcb->Vcb;
            Vcb->VatFcb = NULL;
        }

        UdfDeallocateFcbIndex( IrpContext, Fcb );
        break;

    case UDFS_NTC_FCB_DATA :

        if (Fcb->FileLock != NULL) {

            FsRtlFreeFileLock( Fcb->FileLock );
        }

        FsRtlUninitializeOplock( &Fcb->Oplock );

        if (Fcb == Fcb->Vcb->VolumeDasdFcb) {

            Vcb = Fcb->Vcb;
            Vcb->VolumeDasdFcb = NULL;
        }

        UdfDeallocateFcbData( IrpContext, Fcb );
        break;
    }

    //
    //  Decrement the Vcb reference count if this is a system
    //  Fcb.
    //

    if (Vcb != NULL) {

        InterlockedDecrement( &Vcb->VcbReference );
        InterlockedDecrement( &Vcb->VcbUserReference );
    }

    return;
}


VOID
UdfInitializeFcbFromIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PFCB ParentFcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to initialize an Fcb from a direct ICB.  It should
    only be called once in the lifetime of an Fcb and will fill in the Mcb
    from the chained allocation descriptors of the ICB.

Arguments:

    Fcb - The Fcb being initialized

    IcbOontext - An search context containing the active direct ICB for the object

Return Value:

    None.

--*/

{
    EA_SEARCH_CONTEXT EaContext;
    PICBFILE Icb;

    PVCB Vcb;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT( IcbContext->Active.View);

    //
    //  Vcb should be locked,  since we insert into the fcb table.  Note we 
    //  manipulate fcb fields with no lock here,  since it's during the init. path.
    //
    
    ASSERT_LOCKED_VCB( Fcb->Vcb);

    //
    //  Directly reference for convenience
    //

    Icb = IcbContext->Active.View;
    Vcb = Fcb->Vcb;

    ASSERT(IcbContext->IcbType == DESTAG_ID_NSR_FILE);
    ASSERT((Icb->Destag.Ident == DESTAG_ID_NSR_FILE) || ((Icb->Destag.Ident == DESTAG_ID_NSR_EXT_FILE) && UdfExtendedFEAllowed( IrpContext->Vcb)));
    
    //
    //  Check that the full indicated size of the direct entry is sane and
    //  that the length of the EA segment is correctly aligned.  A direct
    //  entry is less than a single logical block in size.
    //
    
    if (LongOffset( FeEALength( Icb)) ||
        ((FeEAsFieldOffset( Icb) + FeEALength( Icb) + FeAllocLength( Icb)) > BlockSize( IcbContext->Vcb ))
       )  {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  Verify that the types mesh and set state flags.
    //

    if (Fcb->NodeTypeCode == UDFS_NTC_FCB_INDEX && Icb->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY) {

        SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
    
    } else if (!( Fcb->NodeTypeCode == UDFS_NTC_FCB_DATA && 
                  ((ICBTAG_FILE_T_FILE == Icb->Icbtag.FileType) || (ICBTAG_FILE_T_REALTIME == Icb->Icbtag.FileType)))
              ) {

        //
        //  We don't allow access to anything except files or directores (no symlinks, devices...)
        //  Currently we treat realtime files as normal files.
        //
        
        UdfRaiseStatus( IrpContext, STATUS_ACCESS_DENIED );
    }

    SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_READONLY );
    
    //
    //  Store away the on disc UDF file type,  this may be useful later for symlinks etc.
    //
    
    Fcb->UdfIcbFileType = Icb->Icbtag.FileType;
    
    //
    //  Initialize the common header in the Fcb.
    //

    Fcb->Resource = &Fcb->Vcb->FileResource;

    //
    //  Size and lookup all allocations for this object.
    //

    Fcb->AllocationSize.QuadPart = LlBlockAlign( Vcb, Icb->InfoLength );

    Fcb->FileSize.QuadPart =
    Fcb->ValidDataLength.QuadPart = Icb->InfoLength;

    UdfInitializeAllocations( IrpContext,
                              Fcb,
                              IcbContext,
                              (ParentFcb && FlagOn( ParentFcb->FcbState, FCB_STATE_ALLOW_ONEGIG_WORKAROUND))
                                  ? TRUE : FALSE);
    //
    //  Re-reference (may have been unmapped/remapped)
    //
    
    Icb = IcbContext->Active.View;

    //
    //  Lift all of the timestamps for this guy.
    //

    try {
    
        UdfUpdateTimestampsFromIcbContext( IrpContext,
                                           IcbContext,
                                           &Fcb->Timestamps );
    }
    except (UdfQueryDirExceptionFilter( GetExceptionInformation()))  {

        //
        //  In the interest of allowing users maximum data access on dodgy media,
        //  we will ignore corruption within the Eas,  and just use a dummy
        //  timestamp for the create time.  This may change if we being using
        //  Eas for anything critical.
        //

        IrpContext->ExceptionStatus = STATUS_SUCCESS;
        
        Fcb->Timestamps.CreationTime = UdfCorruptFileTime;
    }

    //
    //  Pick up the link count.
    //

    Fcb->LinkCount = Icb->LinkCount;

    //
    //  Link into the Fcb table.  Someone else is responsible for the name linkage, which is
    //  all that remains.  We also note that the Fcb is fully initialized at this point.
    //

    UdfInsertFcbTable( IrpContext, Fcb );
    SetFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE | FCB_STATE_INITIALIZED );
}


PCCB
UdfCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLCB Lcb OPTIONAL,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine is called to allocate and initialize the Ccb structure.

Arguments:

    Fcb - This is the Fcb for the file being opened.
    
    Lcb - This is the Lcb the Fcb is opened by.

    Flags - User flags to set in this Ccb.

Return Value:

    PCCB - Pointer to the created Ccb.

--*/

{
    PCCB NewCcb;
    
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_OPTIONAL_LCB( Lcb );

    //
    //  Allocate and initialize the structure.
    //

    NewCcb = UdfAllocateCcb( IrpContext );

    //
    //  Set the proper node type code and node byte size
    //

    NewCcb->NodeTypeCode = UDFS_NTC_CCB;
    NewCcb->NodeByteSize = sizeof( CCB );

    //
    //  Set the initial value for the flags and Fcb/Lcb
    //

    NewCcb->Flags = Flags;
    NewCcb->Fcb = Fcb;
    NewCcb->Lcb = Lcb;

    //
    //  Initialize the directory enumeration context
    //
    
    NewCcb->CurrentFileIndex = 0;
    NewCcb->HighestReturnableFileIndex = 0;
    
    NewCcb->SearchExpression.Length = 
    NewCcb->SearchExpression.MaximumLength = 0;
    NewCcb->SearchExpression.Buffer = NULL;

    return NewCcb;
}


VOID
UdfDeleteCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine is called to cleanup and deallocate a Ccb structure.

Arguments:

    Ccb - This is the Ccb to delete.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );

    if (Ccb->SearchExpression.Buffer != NULL) {

        UdfFreePool( &Ccb->SearchExpression.Buffer );
    }

    UdfDeallocateCcb( IrpContext, Ccb );
    return;
}


ULONG
UdfFindInParseTable (
    IN PPARSE_KEYVALUE ParseTable,
    IN PCHAR Id,
    IN ULONG MaxIdLen
    )

/*++

Routine Description:

    This routine walks a table of string key/value information for a match of the
    input Id.  MaxIdLen can be set to get a prefix match.

Arguments:

    Table - This is the table being searched.

    Id - Key value.

    MaxIdLen - Maximum possible length of Id.

Return Value:

    Value of matching entry, or the terminating (NULL) entry's value.

--*/

{
    PAGED_CODE();

    while (ParseTable->Key != NULL) {

        if (RtlEqualMemory(ParseTable->Key, Id, MaxIdLen)) {

            break;
        }

        ParseTable++;
    }

    return ParseTable->Value;
}


#ifdef UDF_SANITY

//
//  Enumerate the reasons why a descriptor might be bad.
//

typedef enum _VERIFY_FAILURE {
    
    Nothing,
    BadLbn,
    BadTag,
    BadChecksum,
    BadCrcLength,
    BadCrc,
    BadDestagVersion

} VERIFY_FAILURE;

#endif

BOOLEAN
UdfVerifyDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PDESTAG Descriptor,
    IN USHORT Tag,
    IN ULONG Size,
    IN ULONG Lbn,
    IN BOOLEAN ReturnError
    )

/*++

Routine Description:

    This routine verifies that a descriptor using a Descriptor tag (3/7.2) is 
    consistent with itself and the descriptor data.

Arguments:

    Descriptor - This is the pointer to the descriptor tag, which is always
        at the front of a descriptor

    Tag - The Tag Identifier this descriptor should have

    Size - Size of this descriptor

    Lbn - The logical block number this descriptor should claim it is recorded at

    ReturnError - Whether this routine should return an error or raise

Return Value:

    Boolean TRUE if the descriptor is consistent, FALSE or a raised status of
    STATUS_DISK_CORRUPT_ERROR otherwise.

--*/

{
    UCHAR Checksum = 0;
    PCHAR CheckPtr;
    USHORT Crc;

#ifdef UDF_SANITY
    
    VERIFY_FAILURE FailReason = Nothing;

#endif
    
    //
    //  Check our inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

#ifdef UDF_SANITY

    if (UdfNoisyVerifyDescriptor) {

        goto BeNoisy;
    }

    RegularEntry:

#endif

    //
    //  The version of the Descriptor Tag specified in ISO 13346 and used in
    //  UDF is a particular value; presumeably, previous versions were used
    //  in some older revision of the standard.
    //

    if ( (DESTAG_VER_NSR02 == Descriptor->Version) || 
         ((DESTAG_VER_NSR03 == Descriptor->Version) && UdfExtendedFEAllowed(IrpContext->Vcb))  
       )  {

        //
        //  A descriptor is stamped in four ways. First, the Lbn of the sector
        //  containing the descriptor is written here. (3/7.2.8)
        //
        
        if (Descriptor->Lbn == Lbn)  {
        
            //
            //  Next, the descriptor tag itself has an identifier which should match
            //  the type we expect to find here (3/7.2.1)
            //
            
            if (Descriptor->Ident == Tag) {
        
                //
                //  Next, the descriptor tag itself is checksumed, minus the byte
                //  used to store the checksum. (3/7.2.3)
                //
            
                for (CheckPtr = (PCHAR) Descriptor;
                     CheckPtr < (PCHAR) Descriptor + FIELD_OFFSET( DESTAG, Checksum );
                     CheckPtr++) {
            
                    Checksum += *CheckPtr;
                }
        
                for (CheckPtr = (PCHAR) Descriptor + FIELD_OFFSET( DESTAG, Checksum ) + sizeof(UCHAR);
                     CheckPtr < (PCHAR) Descriptor + sizeof(DESTAG);
                     CheckPtr++) {
            
                    Checksum += *CheckPtr;
                }
        
                if (Descriptor->Checksum == Checksum) {
            
                    //
                    //  Now we check that the CRC in the Descriptor tag is sized sanely
                    //  and matches the Descriptor data. (3/7.2.6)
                    //
                    
                    if (Descriptor->CRCLen &&
                        Descriptor->CRCLen <= Size - sizeof(DESTAG))  {
    
                        Crc = UdfComputeCrc16( (PCHAR) Descriptor + sizeof(DESTAG),
                                               Descriptor->CRCLen );
                        
                        if (Descriptor->CRC == Crc)  {
                            
                            //
                            //  This descriptor checks out.
                            //
#ifdef UDF_SANITY
                            if (UdfNoisyVerifyDescriptor) {
                            
                                DebugTrace(( -1, Dbg, "UdfVerifyDescriptor -> TRUE\n" ));
                            }
#endif
                            return TRUE;
                    
                        } else {
#ifdef UDF_SANITY
                            FailReason = BadCrc;
                            goto ReportFailure;
#endif
                        }
    
                    } else {
#ifdef UDF_SANITY
                        FailReason = BadCrcLength;
                        goto ReportFailure;
#endif
                    }
            
                } else {
#ifdef UDF_SANITY
                    FailReason = BadChecksum;
                    goto ReportFailure;
#endif
                }
            
            } else {
#ifdef UDF_SANITY
                FailReason = BadTag;
                goto ReportFailure;
#endif
            }
        
        } else {
#ifdef UDF_SANITY
            FailReason = BadLbn;
            goto ReportFailure;
#endif
        }
    
    } else {
#ifdef UDF_SANITY
        FailReason = BadDestagVersion;
        goto ReportFailure;
#endif
    }

#ifdef UDF_SANITY

    BeNoisy:
    
    DebugTrace(( +1, Dbg,
                 "UdfVerifyDescriptor, Destag %08x, Tag %x, Size %x, Lbn %x\n",
                 Descriptor,
                 Tag,
                 Size,
                 Lbn ));

    if (FailReason == Nothing) {

        goto RegularEntry;
    
    } else if (!UdfNoisyVerifyDescriptor) {

        goto ReallyReportFailure;
    }

    ReportFailure:

    if (!UdfNoisyVerifyDescriptor) {

        goto BeNoisy;
    }

    ReallyReportFailure:

    switch (FailReason) {
        case BadLbn:
            DebugTrace(( 0, Dbg, 
                         "Lbn mismatch - Lbn %x != expected %x\n",
                         Descriptor->Lbn,
                         Lbn ));
            break;

        case BadTag:
            DebugTrace(( 0, Dbg,
                         "Tag mismatch - Ident %x != expected %x\n",
                         Descriptor->Ident,
                         Tag ));
            break;

        case BadChecksum:
            DebugTrace(( 0, Dbg,
                         "Checksum mismatch - Checksum %x != descriptor's %x\n",
                         Checksum,
                         Descriptor->Checksum ));
            break;

        case BadCrcLength:
            DebugTrace(( 0, Dbg,
                         "CRC'd size bad - CrcLen %x is 0 or > max %x\n",
                         Descriptor->CRCLen,
                         Size - sizeof(DESTAG) ));
            break;

        case BadCrc:
            DebugTrace(( 0, Dbg,
                         "CRC mismatch - Crc %x != descriptor's %x\n",
                         Crc,
                         Descriptor->CRC ));
            break;

        case BadDestagVersion:
            DebugTrace(( 0, Dbg,
                         "Bad Destag Verion %x - (Vcb->NsrVersion => max of %x)\n", Descriptor->Version, UdfExtendedFEAllowed( IrpContext->Vcb) ? 3 : 2));
            break;

        default:
            ASSERT( FALSE );
    }
    
    DebugTrace(( -1, Dbg, "UdfVerifyDescriptor -> FALSE\n" ));

#endif
    
    if (!ReturnError) {

        UdfRaiseStatus( IrpContext, STATUS_CRC_ERROR );
    }

    return FALSE;
}


VOID
UdfInitializeIcbContextFromFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to initialize a context to search the Icb hierarchy
    associated with an Fcb.

Arguments:

    Fcb - Fcb associated with the hierarchy to search.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check input parameters.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT( IrpContext->Vcb);

    RtlZeroMemory( IcbContext, sizeof( ICB_SEARCH_CONTEXT ));

    IcbContext->Vcb = Fcb->Vcb;
    IcbContext->IcbType = DESTAG_ID_NSR_FILE;

    //
    //  Map the first extent into the current slot.
    //

    UdfMapMetadataView( IrpContext,
                        &IcbContext->Current,
                        IcbContext->Vcb,
                        UdfGetFidPartition( Fcb->FileId ),
                        UdfGetFidLbn( Fcb->FileId ),
                        BlockSize( IcbContext->Vcb ),
                        METAMAPOP_INIT_AND_MAP);    

    //
    //  It is possible that we don't have an idea what the length of the root extent is.
    //  This will commonly happen in the OpenById case.
    //
    
    if (Fcb->RootExtentLength == 0) {

        PICBFILE Icb = IcbContext->Current.View;
        
        //
        //  We can only accomplish the guess if we have a descriptor which contains an ICB
        //  Tag, which contains a field that can tell us what we need to know.
        //
        
        if (Icb->Destag.Ident == DESTAG_ID_NSR_ICBIND ||
            Icb->Destag.Ident == DESTAG_ID_NSR_ICBTRM ||
            Icb->Destag.Ident == DESTAG_ID_NSR_FILE ||
            (UdfExtendedFEAllowed( IrpContext->Vcb) && (Icb->Destag.Ident == DESTAG_ID_NSR_EXT_FILE)) ||
            Icb->Destag.Ident == DESTAG_ID_NSR_UASE ||
            Icb->Destag.Ident == DESTAG_ID_NSR_PINTEG
           )  {
                
            UdfVerifyDescriptor( IrpContext,
                                 &Icb->Destag,
                                 Icb->Destag.Ident,
                                 BlockSize( IcbContext->Vcb ),
                                 UdfGetFidLbn( Fcb->FileId ),
                                 FALSE );
        } else {

            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Now the MaxEntries (4/14.6.4) field of the Icb Tag should tell us how big the extent
        //  should be.  The tail of this could be unrecorded.  We could even have landed in the middle
        //  of an extent.  This is only a guess.  For whatever reason we are having to guess this
        //  information, any results are expected to be coming with few guarantees.
        //

        Fcb->RootExtentLength = Icb->Icbtag.MaxEntries * BlockSize( IcbContext->Vcb );
    }
}


VOID
UdfInitializeIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PVCB Vcb,
    IN USHORT IcbType,
    IN USHORT Partition,
    IN ULONG Lbn,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is called to initialize a context to search an Icb hierarchy.

Arguments:

    Vcb - Vcb for the volume.
    
    IcbType - Type of direct entry we expect to find (DESTAG_ID...)
    
    Partition - partition of the hierarchy.
    
    Lbn - lbn of the hierarchy.
    
    Length - length of the root extent of the hierarchy.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check input parameters.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    RtlZeroMemory( IcbContext, sizeof( ICB_SEARCH_CONTEXT ));

    IcbContext->Vcb = Vcb;
    IcbContext->IcbType = IcbType;
    IcbContext->Active.Vsn = IcbContext->Current.Vsn = UDF_INVALID_VSN;
    
    //
    //  Map the first extent into the current slot.
    //

    UdfMapMetadataView( IrpContext,
                        &IcbContext->Current,
                        Vcb,
                        Partition,
                        Lbn,
                        Length,
                        METAMAPOP_INIT_AND_MAP);
    return;

}


VOID
UdfLookupActiveIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG IcbExtentLength
    )

/*++

Routine Description:

    This routine is called to cause the active Icb for an Icb hierarchy to be mapped.
    A context initialized by UdfInitializeIcbContext() is required.

Arguments:

    IcbContext - Context which has been initialized to point into an Icb hierarchy
                 (i.e. first block of current extent mapped in the Current entry).

Return Value:

    None.
    
    Raised status if the Icb hierarchy is invalid.

--*/

{
    PAGED_CODE();

    //
    //  Check input parameters.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Travel the Icb hierarchy.  Due to the design of ISO 13346, it is convenient to
    //  recursively descend the hierarchy.  Place a limit on this recursion which will
    //  allow traversal of most reasonable hierarchies (this will tail recurse off of
    //  the end of extents).
    //

    UdfLookupActiveIcbInExtent( IrpContext,
                                IcbContext,
                                UDF_ICB_RECURSION_LIMIT,
                                IcbExtentLength);

    //
    //  We must have found an active ICB.  We don't need to unmap/remap
    //  if the currently mapped Icb is the active one,  as it will be 99.99%
    //  of the time.  Other case should only occur on WORM.
    //

    if ((IcbContext->Current.Lbn == IcbContext->Active.Lbn)  &&
        (NULL != IcbContext->Current.View)) {

        //
        //  Just copy the mapping information over from current to active.
        //

        RtlCopyMemory( &IcbContext->Active,
                       &IcbContext->Current,
                       sizeof( MAPPED_PVIEW));

        RtlZeroMemory( &IcbContext->Current,
                       sizeof( MAPPED_PVIEW));

        IcbContext->Current.Vsn = UDF_INVALID_VSN;
    }
    else {

        //
        //  Drop the last mapped part of the enumeration at this point,  and release 
        //  the vmcb mapping resource before attempting to map the active icb.
        //
        
        UdfUnpinView( IrpContext, &IcbContext->Current );

        //
        //  Actually map in the active ICB.  ...LookupActiveIcb..() will have already 
        //  initialised the view record with the Icb location so we specify 'remap'.
        //
        
        UdfMapMetadataView( IrpContext,
                            &IcbContext->Active,
                            IrpContext->Vcb,
                            0,
                            0,
                            BlockSize( IrpContext->Vcb ),
                            METAMAPOP_REMAP_VIEW);
    }
    
    if (IcbContext->Active.View == NULL) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
}


VOID
UdfCleanupIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext
    )

/*++

Routine Description:

    This routine cleans an Icb search context for reuse/deletion.

Arguments:

    IcbContext - context to clean

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Check we didn't map both active and current simultaneously (...vmcb purge
    //  limitations).
    //
    
    ASSERT( (NULL == IcbContext->Active.Bcb) || (NULL == IcbContext->Current.Bcb));
    
    UdfUnpinView( IrpContext, &IcbContext->Active );
    UdfUnpinView( IrpContext, &IcbContext->Current );

    ASSERT_NOT_HELD_VMCB( IrpContext->Vcb);

    RtlZeroMemory( IcbContext, sizeof( ICB_SEARCH_CONTEXT ));
}


VOID
UdfInitializeEaContext (
    IN PIRP_CONTEXT IrpContext,
    IN PEA_SEARCH_CONTEXT EaContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG EAType,
    IN UCHAR EASubType
    )

/*++

Routine Description:

    This routine initializes a walk through the EA space of an Icb which has been
    previously discovered.
    
    Note: only the embedded EA space is supported now.

Arguments:

    EaContext - EA context to fill in
    
    IcbContext - Elaborated ICB search structure 

Return Value:

--*/

{
    PICBFILE Icb;

    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    ASSERT( IcbContext->Active.Bcb && IcbContext->Active.View );

    Icb = IcbContext->Active.View;

    EaContext->IcbContext = IcbContext;

    //
    //  Initialize to point at the first EA to return.
    //

    EaContext->Ea = FeEAs( Icb);
    EaContext->Remaining = FeEALength( Icb);

    EaContext->EAType = EAType;
    EaContext->EASubType = EASubType;
}


BOOLEAN
UdfLookupEa (
    IN PIRP_CONTEXT IrpContext,
    IN PEA_SEARCH_CONTEXT EaContext
    )

/*++

Routine Description:

    This routine finds an EA in the EA space of an ICB.

Arguments:

    EaContext - an initialized EA search context containing an elaborated
        ICB search context and a description of the EA to find.

Return Value:

    BOOLEAN True if such an EA was found and returned, False otherwise.

--*/
{
    PICBFILE Icb;
    PNSR_EA_GENERIC GenericEa;

    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Quickly terminate if the EA space is empty or not capable of containing
    //  the header descriptor.  A null EA space is perfectly legal.
    //

    if (EaContext->Remaining == 0) {

        return FALSE;
    
    } else if (EaContext->Remaining < sizeof( NSR_EAH )) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  Verify the integrity of the EA header.  This has a side effect of making
    //  very sure that we really have an EA sequence underneath us.
    //

    Icb = EaContext->IcbContext->Active.View;

    UdfVerifyDescriptor( IrpContext,
                         &((PNSR_EAH) EaContext->Ea)->Destag,
                         DESTAG_ID_NSR_EA,
                         sizeof( NSR_EAH ),
                         Icb->Destag.Lbn,
                         FALSE );
    
    //
    //  Push forward the start of the EA space and loop while we have more EAs to inspect.
    //  Since we only scan for ISO EA's right now, we don't need to open the EA header to
    //  jump forward to the Implementation Use or Application Use segments.
    //

    EaContext->Ea = Add2Ptr( EaContext->Ea, sizeof( NSR_EAH ), PVOID );
    EaContext->Remaining -= sizeof( NSR_EAH );
    
    while (EaContext->Remaining) {

        GenericEa = EaContext->Ea;

        //
        //  The EAs must appear on 4byte aligned boundaries, there must be room to find
        //  the generic EA preamble and the claimed length of the EA must fit in the
        //  remaining space.
        //
        
        if (LongOffsetPtr( EaContext->Ea ) ||
            EaContext->Remaining < FIELD_OFFSET( NSR_EA_GENERIC, EAData ) ||
            EaContext->Remaining < GenericEa->EALength ) {
        
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        if (GenericEa->EAType == EaContext->EAType && GenericEa->EASubType == EaContext->EASubType) {

            return TRUE;
        }

        EaContext->Ea = Add2Ptr( EaContext->Ea, GenericEa->EALength, PVOID );
        EaContext->Remaining -= GenericEa->EALength;
    }

    //
    //  If we failed to find the EA, we should have stopped at the precise end of the EA space.
    //
    
    if (EaContext->Remaining) {
        
        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    return FALSE;
}


VOID
UdfInitializeAllocations (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN BOOLEAN AllowOneGigWorkaround
    )

/*++

Routine Description:

    This routine fills in the data retrieval information for an Fcb.

Arguments:

    Fcb - Fcb to add retrieval information to.
    
    IcbContext - Elaborated ICB search context corresponding to this Fcb.

Return Value:

    None.

--*/

{
    PICBFILE Icb = IcbContext->Active.View;
    PAD_GENERIC GenericAd;
    
    ALLOC_ENUM_CONTEXT AllocContext;

    LONGLONG RunningOffset;
    ULONG Psn;

    PVCB Vcb = Fcb->Vcb;

    BOOLEAN Result;

    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Immediately return for objects with zero information space.  Note that
    //  passing this test does not indicate that the file has any recorded space.
    //

    if (Fcb->FileSize.QuadPart == 0) {

        return;
    }

    //
    //  Init the allocation search context.  Note that in the non-immediate
    //  data case this can cause the active view (icb) to be unmapped
    //

    UdfInitializeAllocationContext( IrpContext,
                                    &AllocContext,
                                    IcbContext,
                                    AllowOneGigWorkaround);
    //
    //  Handle the case of embedded data.
    //

    if (AllocContext.AllocType == ICBTAG_F_ALLOC_IMMEDIATE) {

        //
        //  Teardown any existing mcb.
        //

        UdfUninitializeFcbMcb( Fcb );
        
        //
        //  Establish a single block mapping to the Icb itself and mark the Fcb as
        //  having embedded data.  Mapping will occur through the Metadata stream.
        //  Note that by virtue of having an Icb here we know it has already had
        //  a mapping established in the Metadata stream, so just retrieve that 
        //

        SetFlag( Fcb->FcbState, FCB_STATE_EMBEDDED_DATA );

        Fcb->EmbeddedVsn = IcbContext->Active.Vsn;

        ASSERT( UDF_INVALID_VSN != Fcb->EmbeddedVsn );
        
        //
        //  Note the offset of the data in the Icb.
        //

        Fcb->EmbeddedOffset = FeEAsFieldOffset( Icb) + FeEALength( Icb);

        //
        //  Check that the information length agrees.
        //

        if (FeAllocLength(Icb) != Fcb->FileSize.LowPart)  {

            DebugTrace(( 0, Dbg, "UdfInitializeAllocations, embedded alloc %08x != filesize %08x\n",
                         FeAllocLength( Icb),
                         Fcb->FileSize.LowPart ));

            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        return;
    }

    //
    //  Now initialize the mapping structure for this Fcb.
    //

    UdfInitializeFcbMcb( Fcb );

    //
    //  Now walk the chain of allocation descriptors for the object, adding them into the
    //  mapping.
    //

    RunningOffset = 0;

    do {
        
        //
        //  Check to see if we've read all of the extents for the file body yet.  
        //  We could do file tail consistency checking (4/12.1),  however as a read only
        //  implementation we don't care about the file tail,  and since there is no easy way
        //  of detecting loops in the tail,  we'll just ignore it for the sake of simplicity.
        //
        
        if (RunningOffset >= Fcb->FileSize.QuadPart) {

            break;
        }
        
        //
        //  It is impermissible for an interior body extent of an object to not be
        //  an integral multiple of a logical block in size (note that the last
        //  will tend not to be).  Also check that the body didn't overshoot the 
        //  information length (this check will also catch looped AD extents)
        //
        
        GenericAd = AllocContext.Alloc;

        if (BlockOffset( Vcb, RunningOffset ) || (Fcb->FileSize.QuadPart < RunningOffset))  {

            DebugTrace(( 0, Dbg, "UdfInitializeAllocations, bad alloc\n"));
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }
            
        //
        //  Based on the descriptor type, pull it apart and add the mapping.
        //

        if (GenericAd->Length.Type == NSRLENGTH_TYPE_RECORDED) {

            //
            //  Grab the Psn this extent starts at and add the allocation.
            //

            Psn = UdfLookupPsnOfExtent( IrpContext,
                                        Vcb,
                                        UdfGetPartitionOfCurrentAllocation( &AllocContext ),
                                        GenericAd->Start,
                                        GenericAd->Length.Length );

            Result = FsRtlAddLargeMcbEntry( &Fcb->Mcb,
                                            LlSectorsFromBytes( Vcb, RunningOffset ),
                                            Psn,
                                            SectorsFromBytes( Vcb, SectorAlign( Vcb, GenericAd->Length.Length ) ));

            ASSERT( Result );
        }

        RunningOffset += GenericAd->Length.Length;
    
    } 
    while ( UdfGetNextAllocation( IrpContext, &AllocContext ));

    //
    //  If the running offset doesn't match the expected file size,  then
    //  see if this file is a candidate for the ">1Gb in single AD mastering
    //  error" workaround.  Sigh...
    //

    if ((Fcb->FileSize.QuadPart != RunningOffset) &&
        (Fcb->Header.NodeTypeCode == UDFS_NTC_FCB_DATA) &&
        AllowOneGigWorkaround &&
        ((Fcb->FileSize.QuadPart & 0x3fffffff) == RunningOffset) &&
        (NULL != AllocContext.IcbContext->Active.View))  {

        PICBFILE Icb = AllocContext.IcbContext->Active.View;
        PSHORTAD Ad = Add2Ptr( FeEAs( Icb), FeEALength( Icb), PVOID );

        //
        //  Plausable.  So now verify that there is only a single AD and it contains
        //  precisely the expected (wrong) value.  We've already checked that the 
        //  original FE is still mapped.  
        //
        
        if (((Icb->Icbtag.Flags & ICBTAG_F_ALLOC_MASK) == ICBTAG_F_ALLOC_SHORT) &&
            (FeAllocLength(Icb) == sizeof( SHORTAD)) &&
            (*((PULONG)(&Ad->Length)) == Fcb->FileSize.QuadPart))  {

            //
            //  Lookup the PSN for this extent.  This will also validate that our
            //  guestimated extent fits within partition bounds.
            //
            
            Psn = UdfLookupPsnOfExtent( IrpContext,
                                        Vcb,
                                        UdfGetPartitionOfCurrentAllocation( &AllocContext ),
                                        Ad->Start,
                                        Fcb->FileSize.LowPart );
            //
            //  So fix up the Mcb to represent this estimated extent
            //
                                       
            FsRtlTruncateLargeMcb( &Fcb->Mcb, 0);

            (void)FsRtlAddLargeMcbEntry( &Fcb->Mcb,
                                         0,
                                         Psn,
                                         SectorsFromBytes( Vcb, SectorAlign( Vcb, Fcb->FileSize.LowPart ) ));

            RunningOffset = Fcb->FileSize.QuadPart;

            DebugTrace(( 0, Dbg, "UdfInitializeAllocations -> 1 GIG AD workaround performed on Fcb 0x%p\n", Fcb));
        }
    }

    //
    //  Restore the ICB mapping if we unmapped it to traverse non embedded
    //  extent blocks.  Note that we key on Active->View here (rather than Bcb),  
    //  because during UdfInit...VcbPhase0 we are called with a phoney IcbContext 
    //  where View is a pointer to a buffer,  hence there was no bcb,  and 
    //  we don't want to create a mapping now.  Because the unmap operations 
    //  only act if NULL!=Bcb,  (not true in this case) view will still be 
    //  non-null here even after walking more allocation extents,  and we do nothing.
    //

    UdfUnpinView( IrpContext, &IcbContext->Current);
    
    if ( NULL == IcbContext->Active.View)  {
        
        UdfMapMetadataView( IrpContext, 
                            &IcbContext->Active,  
                            IrpContext->Vcb, 
                            0, 0, 0, 
                            METAMAPOP_REMAP_VIEW);
    }
    
    //
    //  We must have had body allocation descriptors for exactly the entire file
    //  information length.
    //

    if (Fcb->FileSize.QuadPart != RunningOffset) {

        DebugTrace(( 0, Dbg, "UdfInitializeAllocations, total descriptors != filesize\n" ));
        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
}


VOID
UdfUpdateTimestampsFromIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PTIMESTAMP_BUNDLE Timestamps
    )

/*++

Routine Description:

    This routine converts the set of timestamps associated with a given ICB into
    an NT native form.

Arguments:

    IcbOontext - An search context containing the active direct ICB for the object
    
    Timestamps - the bundle of timestamps to receive the converted times.

Return Value:

    None.

--*/

{
    EA_SEARCH_CONTEXT EaContext;
    PICBFILE Icb = IcbContext->Active.View;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    // *TEJ - following should probably be a permanent runtime check? (ext fe + nsr03)?
    
    ASSERT( (Icb->Destag.Ident == DESTAG_ID_NSR_FILE) || ((Icb->Destag.Ident == DESTAG_ID_NSR_EXT_FILE) && UdfExtendedFEAllowed( IrpContext->Vcb)));

    //
    //  Initialize the timestamps for this object.  Due to ISO 13346,
    //  we must gather EAs and figure out which of several timestamps is most valid.
    //  Pull the access & modification times from the ICB
    //

    UdfConvertUdfTimeToNtTime( IrpContext,
                               PFeModifyTime( Icb),
                               (PLARGE_INTEGER) &Timestamps->ModificationTime );

    UdfConvertUdfTimeToNtTime( IrpContext,
                               PFeAccessTime( Icb),
                               (PLARGE_INTEGER) &Timestamps->AccessTime );

    if (UdfFEIsExtended( Icb))  {
    
        //
        //  Creation time field is new in Extended FEs
        //
        
        UdfConvertUdfTimeToNtTime( IrpContext,
                                   PFeCreationTime( Icb),
                                   (PLARGE_INTEGER) &Timestamps->CreationTime );
    }
    else {

        //
        //  For a basic FileEntry,  look and see if a FileTimes EA has been recorded
        //  which contains a creation time.
        //
    
        UdfInitializeEaContext( IrpContext,
                                &EaContext,
                                IcbContext,
                                EA_TYPE_FILETIMES,
                                EA_SUBTYPE_BASE );

        if (UdfLookupEa( IrpContext, &EaContext )) {

            PNSR_EA_FILETIMES FileTimes = EaContext.Ea;
        
            if (FlagOn(FileTimes->Existence, EA_FILETIMES_E_CREATION)) {

                UdfConvertUdfTimeToNtTime( IrpContext,
                                           &FileTimes->Stamps[0],
                                           (PLARGE_INTEGER) &Timestamps->CreationTime );
            }
        }
        else {

            //
            //  No Timestamps EA recorded.  So we'll just use last mod time as creation
            //
            
            Timestamps->CreationTime = Timestamps->ModificationTime;
        }
    }
}


BOOLEAN
UdfCreateFileLock (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine is called when we want to attach a file lock structure to the
    given Fcb.  It is possible the file lock is already attached.

    This routine is sometimes called from the fast path and sometimes in the
    Irp-based path.  We don't want to raise in the fast path, just return FALSE.

Arguments:

    Fcb - This is the Fcb to create the file lock for.

    RaiseOnError - If TRUE, we will raise on an allocation failure.  Otherwise we
        return FALSE on an allocation failure.

Return Value:

    BOOLEAN - TRUE if the Fcb has a filelock, FALSE otherwise.

--*/

{
    BOOLEAN Result = TRUE;
    PFILE_LOCK FileLock;

    PAGED_CODE();

    //
    //  Lock the Fcb and check if there is really any work to do.
    //

    UdfLockFcb( IrpContext, Fcb );

    if (Fcb->FileLock != NULL) {

        UdfUnlockFcb( IrpContext, Fcb );
        return TRUE;
    }

    Fcb->FileLock = FileLock =
        FsRtlAllocateFileLock( NULL, NULL );

    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  Return or raise as appropriate.
    //

    if (FileLock == NULL) {
         
        if (RaiseOnError) {

            ASSERT( ARGUMENT_PRESENT( IrpContext ));

            UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        Result = FALSE;
    }

    return Result;
}


//
//  Local support routine
//

VOID
UdfLookupActiveIcbInExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG Recurse,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is called to traverse a single Icb hierarchy extent to discover
    an active Icb.  This is a recursive operation on indirect Icbs that may be
    found in the sequence.
    
Arguments:

    IcbContext - Context which has been initialized to point into an Icb hierarchy.
    
    Recurse - Recursion limit. 

    Length - Length of the extent currently described in IcbContext->Current (since
             we only map a block at a time the length in there will be 1 block...)

Return Value:

    None.
    
    Raised status if the Icb hierarchy is invalid.

--*/

{
    PVCB Vcb = IcbContext->Vcb;
    PFCB Fcb = Vcb->MetadataFcb;

    ULONG Lbn;
    USHORT Partition;

    ULONG Vsn;

    PICBIND Icb;

    PAGED_CODE();

    //
    //  Should only ever have a single view mapped.  We're using Current,  so...
    //
    
    ASSERT( NULL == IcbContext->Active.Bcb );
    ASSERT( NULL != IcbContext->Current.View );
    
    //
    //  Don't expect to see extended FE as search type (we just use basic FE and
    //  treat as potentially either).
    //
    
    ASSERT( DESTAG_ID_NSR_EXT_FILE != IcbContext->IcbType);
    
    //
    //  Decrement our recursion allowance.
    //
    
    Recurse--;

    //
    //  Grab our starting point
    //

    Partition = IcbContext->Current.Partition;
    Lbn = IcbContext->Current.Lbn;

    Icb = IcbContext->Current.View;

    //
    //  Walk across the extent
    //

    do {
        
        switch (Icb->Destag.Ident) {
                        
            case DESTAG_ID_NSR_ICBIND:

                UdfVerifyDescriptor( IrpContext,
                                     &Icb->Destag,
                                     DESTAG_ID_NSR_ICBIND,
                                     sizeof( ICBIND ),
                                     Lbn,
                                     FALSE );

                //
                //  Go to the next extent if this indirect Icb actually points to something.
                //

                if (Icb->Icb.Length.Type == NSRLENGTH_TYPE_RECORDED) {

                    //
                    //  If we are in the last entry of the Icb extent, we may tail recurse. This
                    //  is very important for strategy 4096, which is a linked list of extents
                    //  of depth equal to the number of times the direct Icb had to be re-recorded.
                    //
/*
                    //
                    //  THIS IS STRAT.4 SUPPORT CODE.  SINCE WE HAVE NO TEST MEDIA/PLAN
                    //  FOR THIS,  AND UDF ONLY ALLOWS STAT.4096 IN ANY CASE, I AM 
                    //  DISABLING IT FOR NOW.
                    //
                    
                    UdfMapMetadataView( IrpContext,
                                        &IcbContext->Current,
                                        Vcb,
                                        Icb->Icb.Start.Partition,
                                        Icb->Icb.Start.Lbn,
                                        BlockSize( Vcb),
                                        METAMAPOP_INIT_AND_MAP);

                    if (Length != BlockSize( Vcb )) {

                        //
                        //  We have to give up on this if we're going too deep.
                        //
                        
                        if (Recurse == 0) {
                            
                            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                        }

                        UdfLookupActiveIcbInExtent( IrpContext,
                                                    IcbContext,
                                                    Recurse,
                                                    Icb->Icb.Length.Length);

                        //
                        //  Need to remap the extent we were working on.
                        //
    
                        UdfMapMetadataView( IrpContext,
                                            &IcbContext->Current,
                                            Vcb,
                                            Partition,
                                            Lbn,
                                            BlockSize( Vcb),
                                            METAMAPOP_INIT_AND_MAP);

                        //
                        //  May have been remapped at different address
                        //
                        
                        Icb = IcbContext->Current.View;
                        
                    } else {

                        //
                        //  Tail recursion was possible so adjust our pointers and restart the scan.
                        //

                        Partition = IcbContext->Current.Partition;
                        Lbn = IcbContext->Current.Lbn;
                        Length = IcbContext->Current.Length;
                        
                        Icb = IcbContext->Current.View;

                        continue;
                    }
*/
                    //
                    //  We only expect to see an indirect block at the end of an  Icb
                    //  extent (4096),  so this should be the last block in the current
                    //  extent.  Anything else is corruption as far as we're concerned.
                    //
                    
                    if ((Length != BlockSize( Vcb)) || 
                        (Partition != Icb->Icb.Start.Partition))  {

                        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                    }

                    //
                    //  Update our pointers.  The next extent will be mapped further down
                    //  before the next pass of the loop.
                    //
                    
                    Lbn = Icb->Icb.Start.Lbn - 1,
                    Length = Icb->Icb.Length.Length + BlockSize( Vcb);
                }

                break;

            case DESTAG_ID_NSR_ICBTRM:

                UdfVerifyDescriptor( IrpContext,
                                     &Icb->Destag,
                                     DESTAG_ID_NSR_ICBTRM,
                                     sizeof( ICBTRM ),
                                     Lbn,
                                     FALSE );

                //
                //  Terminate the current extent.
                //

                return;
                break;

            case DESTAG_ID_NOTSPEC:

                //
                //  Perhaps this is an unrecorded sector.  Treat this as terminating
                //  the current extent.
                //

                return;
                break;

            default:

                //
                //  This is a data-full Icb.  It must be of the expected type.  We will
                //  accept EXT FEs here iff the search type was FE and the volume conforms to
                //  NSR03.
                //
                
                if ( (Icb->Destag.Ident != IcbContext->IcbType) && 
                     ( (DESTAG_ID_NSR_FILE != IcbContext->IcbType) || 
                       (!UdfExtendedFEAllowed( IrpContext->Vcb)) ||
                       (DESTAG_ID_NSR_EXT_FILE != Icb->Destag.Ident)
                     )
                   )  {
                    
                    UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                }

                //
                //  Since direct entries are of variable size, we must allow up to
                //  a block's worth of data.
                //

                UdfVerifyDescriptor( IrpContext,
                                     &Icb->Destag,
                                     Icb->Destag.Ident,
                                     BlockSize( Vcb ),
                                     Lbn,
                                     FALSE );
                //
                //  We perform an in-order traversal of the hierarchy.  This is important since
                //  it means no tricks are neccesary to figure out the rightmost direct Icb -
                //  always stash the last one we see.
                //
                //  Map this logical block into the active slot.  We know that a direct entry
                //  must fit in a single logical block.
                //
                //  Note that we don't actually do the mapping operation here,  just store
                //  the Icb location (we don't want two active mappings in the same thread
                //  because it complicates the vmcb purge synchronisation logic).  
                //  Also more effecient.
                //

                UdfMapMetadataView( IrpContext,
                                    &IcbContext->Active,
                                    Vcb,
                                    Partition,
                                    Lbn,
                                    BlockSize( Vcb ),
                                    METAMAPOP_INIT_VIEW_ONLY );
        }

        //
        //  Advance our pointer set.
        //

        Lbn++;
        Length -= BlockSize( Vcb );

        //
        //  If neccessary,  map the next block in this extent (strat 4096).
        //
        
        if (0 != Length)  {

            UdfMapMetadataView( IrpContext,
                                &IcbContext->Current,
                                Vcb,
                                Partition,
                                Lbn,
                                BlockSize( Vcb),
                                METAMAPOP_INIT_AND_MAP);

            Icb = IcbContext->Current.View;
        }
    } 
    while (Length);
}


//
//  Local support routine
//

VOID
UdfInitializeAllocationContext (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN BOOLEAN AllowSingleZeroLengthExtent
    )

/*++

Routine Description:

    Initializes a walk of the allocation descriptors for an ICB which has already
    been found.  The first allocation descriptor will be avaliable after the call.

    Can potentially exit with the AllocContext->IcbContext->Active view unmapped if
    there are no descriptors embedded in the Icb (so current will now be mapped to the
    next block of extents),  or the data is immediate.

Arguments:

    AllocContext - Allocation enumeration context to use
    
    IcbContext - Elaborated ICB search context for the ICB to enumerate

Return Value:

    None.

--*/

{
    PICBFILE Icb;

    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    ASSERT( IcbContext->Active.View );

    AllocContext->IcbContext = IcbContext;

    //
    //  Figure out what kind of descriptors will be here.
    //

    Icb = IcbContext->Active.View;
    AllocContext->AllocType = FlagOn( Icb->Icbtag.Flags, ICBTAG_F_ALLOC_MASK );

    //
    //  We are done if this is actually immediate data.
    //
    
    if (AllocContext->AllocType == ICBTAG_F_ALLOC_IMMEDIATE) {

        return;
    }
    
    //
    //  The initial chunk of allocation descriptors is inline with the ICB and
    //  does not contain an Allocation Extent Descriptor.
    //

    AllocContext->Alloc = Add2Ptr( FeEAs( Icb), FeEALength( Icb), PVOID );
    AllocContext->Remaining = FeAllocLength( Icb);

    ASSERT( LongOffsetPtr( AllocContext->Alloc ) == 0 );

    //
    //  Check that the specified amount of ADs/embedded data can actually fit 
    //  within the block.
    //
    
    if (AllocContext->Remaining > 
        (BlockSize( IrpContext->Vcb) - (FeEAsFieldOffset( Icb) + FeEALength( Icb))))  {

        DebugTrace(( 0, Dbg, "UdfInitializeAllocationContext(), AD_Len 0x%x for Icb > (Blocksize - (FE+EAs))\n", 
                    AllocContext->Remaining));
                    
        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
    
    //
    //  Check that an integral number of the appropriate allocation descriptors fit in
    //  this extent and that the extent is not composed of extended allocation descriptors,
    //  which are illegal on UDF.  
    //
    //  If the common post-processing fails, we probably did not find any allocation
    //  descriptors (case of nothing but continuation).  This is likewise bad.
    //

    if (AllocContext->Remaining == 0 ||
        AllocContext->Remaining % ISOAllocationDescriptorSize( AllocContext->AllocType ) ||
        AllocContext->AllocType == ICBTAG_F_ALLOC_EXTENDED ||
        !UdfGetNextAllocationPostProcessing( IrpContext, AllocContext )) {

        //
        //  Do some final verification/traversal of continuation extents.  We need to
        //  allow zero length extents here if we're allowing the 1Gb corrupt AD workaround,
        //  since a 1Gb extent will be encoded as type 1,  length 0...  Note that if someone
        //  has managed to record a 4Gb-1block extent,  the postprocess function above
        //  will raise (will see a continuation extent > 1 block).  We'll just hope that 
        //  noone's been that stupid.
        //
        //  This case is deliberately extremely specific.
        //

        if (!(AllowSingleZeroLengthExtent && 
             (AllocContext->AllocType == ICBTAG_F_ALLOC_SHORT) && 
             (AllocContext->Remaining == sizeof( SHORTAD)) &&
             (((PSHORTAD)AllocContext->Alloc)->Length.Length == 0) &&
             (((PSHORTAD)AllocContext->Alloc)->Length.Type != 0)))  {
            
            DebugTrace(( 0, Dbg, "UdfInitializeAllocationContext:  Failing - Rem %x Rem%%size %x Type %x\n", 
                        AllocContext->Remaining, 
                        AllocContext->Remaining % ISOAllocationDescriptorSize( AllocContext->AllocType ), 
                        AllocContext->AllocType));
                        
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }
        else {

            DebugTrace(( 0, Dbg, "UdfInitializeAllocationContext:  Ignoring zero length initial AD due to 1Gb workaround\n"));
        }
    }
}


//
//  Local support routine
//

BOOLEAN
UdfGetNextAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext
    )

/*++

Routine Description:

    This routine retrieves the next logical allocation descriptor given an enumeration
    context.

    Any ACTIVE view in the AllocContext->IcbContext will be unmapped.

Arguments:

    AllocContext - Context to advance to the next descriptor

Return Value:

    BOOLEAN - TRUE if one is found, FALSE if the enumeration is complete.
    
    This routine will raise if malformation is discovered.

--*/

{
    PAGED_CODE();

    //
    //  Check inputs
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );

    AllocContext->Remaining -= ISOAllocationDescriptorSize( AllocContext->AllocType );
    AllocContext->Alloc = Add2Ptr( AllocContext->Alloc, ISOAllocationDescriptorSize( AllocContext->AllocType ), PVOID );

    return UdfGetNextAllocationPostProcessing( IrpContext, AllocContext );
}
    

BOOLEAN
UdfGetNextAllocationPostProcessing (
    IN PIRP_CONTEXT IrpContext,
    IN PALLOC_ENUM_CONTEXT AllocContext
    )

/*++

Routine Description:

    This routine retrieves the next logical allocation descriptor given an enumeration
    context.

Arguments:

    AllocContext - Context to advance to the next descriptor

Return Value:

    BOOLEAN - TRUE if one is found, FALSE if the enumeration is complete.
    
    This routine will raise if malformation is discovered.

--*/

{
    PAD_GENERIC GenericAd;
    PNSR_ALLOC AllocDesc;
    ULONG Start;
    USHORT Partition;
    

    PVCB Vcb = AllocContext->IcbContext->Vcb;

    //
    //  There are three ways to reach the end of the current block of allocation
    //  descriptors, per ISO 13346 4/12:
    //
    //      reach the end of the field (kept track of in the Remaining bytes)
    //      reach an allocation descriptor with an extent length of zero
    //      reach a continuation extent descriptor
    //
    
    //
    //  We are done in the first two cases.
    //

    if (AllocContext->Remaining < ISOAllocationDescriptorSize( AllocContext->AllocType )) {
        
        return FALSE;
    }

    while (TRUE) {
        
        GenericAd = AllocContext->Alloc;
    
        if (GenericAd->Length.Length == 0) {
    
            return FALSE;
        }
        
        //
        //  Check if this descriptor is a pointer to another extent of descriptors.
        //
    
        if (GenericAd->Length.Type != NSRLENGTH_TYPE_CONTINUATION) {
            
            break;
        }
    
        //
        //  UDF allocation extents are restricted to a single logical block.
        //

        if (GenericAd->Length.Length > BlockSize( Vcb )) {
            
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Extract required values from the current block of extents,  which
        //  may be the active ICB mapping which we're about to throw away...
        //

        Start = GenericAd->Start;
        Partition = UdfGetPartitionOfCurrentAllocation( AllocContext );
        
        //
        //  Ensure that any active view is unmapped at this point,  and destroy
        //  pointers into it
        //
        
        UdfUnpinView( IrpContext, &AllocContext->IcbContext->Active);
        GenericAd = NULL;

        //
        //  Map the next block of extents
        //
        
        UdfMapMetadataView( IrpContext,
                            &AllocContext->IcbContext->Current,
                            Vcb,
                            Partition,
                            Start,
                            BlockSize( Vcb ),
                            METAMAPOP_INIT_AND_MAP);
        
        //
        //  Now check that the allocation descriptor is valid.
        //

        AllocDesc = (PNSR_ALLOC) AllocContext->IcbContext->Current.View;

        UdfVerifyDescriptor( IrpContext,
                             &AllocDesc->Destag,
                             DESTAG_ID_NSR_ALLOC,
                             BlockSize( Vcb ),
                             AllocContext->IcbContext->Current.Lbn,
                             FALSE );

        //
        //  Note that a full logical block is mapped, but only the claimed number of
        //  bytes are valid.
        //

        AllocContext->Remaining = AllocDesc->AllocLen;
        AllocContext->Alloc = Add2Ptr( AllocContext->IcbContext->Current.View, sizeof( NSR_ALLOC ), PVOID );

        //
        //  Check that the size is sane and that an integral number of the appropriate
        //  allocation descriptors fit in this extent.
        //

        if (AllocContext->Remaining == 0 ||
            AllocContext->Remaining > BlockSize( Vcb ) - sizeof( NSR_ALLOC ) ||
            AllocContext->Remaining % ISOAllocationDescriptorSize( AllocContext->AllocType )) {

            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }
    }
    
    return TRUE;
}


//
//  Local support routine
//

PFCB_NONPAGED
UdfCreateFcbNonPaged (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to create and initialize the non-paged portion
    of an Fcb.

Arguments:

Return Value:

    PFCB_NONPAGED - Pointer to the created nonpaged Fcb.  NULL if not created.

--*/

{
    PFCB_NONPAGED FcbNonpaged;

    PAGED_CODE();

    //
    //  Allocate the non-paged pool and initialize the various
    //  synchronization objects.
    //

    FcbNonpaged = UdfAllocateFcbNonpaged( IrpContext );

    RtlZeroMemory( FcbNonpaged, sizeof( FCB_NONPAGED ));

    FcbNonpaged->NodeTypeCode = UDFS_NTC_FCB_NONPAGED;
    FcbNonpaged->NodeByteSize = sizeof( FCB_NONPAGED );

    ExInitializeResourceLite( &FcbNonpaged->FcbResource );
    ExInitializeFastMutex( &FcbNonpaged->FcbMutex );

    return FcbNonpaged;
}


//
//  Local support routine
//

VOID
UdfDeleteFcbNonpaged (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB_NONPAGED FcbNonpaged
    )

/*++

Routine Description:

    This routine is called to cleanup the non-paged portion of an Fcb.

Arguments:

    FcbNonpaged - Structure to clean up.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ExDeleteResourceLite( &FcbNonpaged->FcbResource );

    UdfDeallocateFcbNonpaged( IrpContext, FcbNonpaged );

    return;
}


//
//  Local support routine
//

RTL_GENERIC_COMPARE_RESULTS
UdfFcbTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID id1,
    IN PVOID id2
    )

/*++

Routine Description:

    This routine is the Udfs compare routine called by the generic table package.
    If will compare the two File Id values and return a comparison result.

Arguments:

    Table - This is the table being searched.

    id1 - First key value.

    id2 - Second key value.

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/

{
    FILE_ID Id1, Id2;
    PAGED_CODE();

    Id1 = *((FILE_ID UNALIGNED *) id1);
    Id2 = *((FILE_ID UNALIGNED *) id2);

    if (Id1.QuadPart < Id2.QuadPart) {

        return GenericLessThan;

    } else if (Id1.QuadPart > Id2.QuadPart) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }

    UNREFERENCED_PARAMETER( Table );
}


//
//  Local support routine
//

PVOID
UdfAllocateTable (
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    Table - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    PAGED_CODE();

    return( FsRtlAllocatePoolWithTag( UdfPagedPool, ByteSize, TAG_GENERIC_TABLE ));
}


//
//  Local support routine
//

VOID
UdfDeallocateTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine that deallocates memory

Arguments:

    Table - Supplies the generic table being used

    Buffer - Supplies the buffer being deallocated

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool( Buffer );

    return;
    UNREFERENCED_PARAMETER( Table );
}
    

BOOLEAN
UdfDomainIdentifierContained (
    IN PREGID RegID,
    IN PSTRING Domain,
    IN USHORT RevisionMin,
    IN USHORT RevisionMax
    )
/*++

Routine Description:

    A Domain Identifier RegID is considered to be contained if the
    text string identifier matches and the revision is less than or
    equal.  This is the convenient way to check that a Domain ID
    indicates a set of structures will be intelligible to a given
    implementation level.

Arguments:

    RegID  - Registered ID structure to verify
    
    Domain - Domain to look for

    RevisionMin, RevisionMax - Revision range to accept.

Return Value:

    None.

--*/
{
    PUDF_SUFFIX_DOMAIN DomainSuffix = (PUDF_SUFFIX_DOMAIN) RegID->Suffix;
    BOOLEAN Contained;

    Contained = ((DomainSuffix->UdfRevision <= RevisionMax && DomainSuffix->UdfRevision >= RevisionMin) &&
                UdfEqualEntityId( RegID, Domain, NULL ));

#ifdef UDF_SANITY
    if (!Contained)  {
    
        UCHAR Want[24], Got[24];

        strncpy( Want, Domain->Buffer, Domain->Length);
        Want[Domain->Length] = '\0';
        
        strncpy( Got, RegID->Identifier, Domain->Length);
        Got[Domain->Length] = '\0';
    
        DebugTrace((0, Dbg, "UdfDomainIdentifierContained() FAILED - Expected %X<>%X '%s',  Found %X '%s'\n", RevisionMin, RevisionMax, Want, DomainSuffix->UdfRevision, Got));
    }
#endif

    return Contained;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\udfstruc.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    UdfStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    parts of the Udfs file system.

    In-Memory structures:

        The global data structures with the UdfDataRecord.  It contains a pointer
        to a File System Device object and a queue of Vcb's.  There is a Vcb for
        every currently or previously mounted volumes.  We may be in the process
        of tearing down the Vcb's which have been dismounted.  The Vcb's are
        allocated as an extension to a volume device object.

            +---------+
            | UdfData |     +--------+
            |         | --> |FilSysDo|
            |         |     |        |
            |         | <+  +--------+
            +---------+  |
                         |
                         |  +--------+     +--------+
                         |  |VolDo   |     |VolDo   |
                         |  |        |     |        |
                         |  +--------+     +--------+
                         +> |Vcb     | <-> |Vcb     | <-> ...
                            |        |     |        |
                            +--------+     +--------+


        Each Vcb contains a table of all the Fcbs for the volume indexed by
        their FileId.  Each Vcb contains a pointer to the root directory of
        the volume.  Each directory Fcb contains a queue of child Lcb's for
        its children.  Each Lcb is queued onto both its parent and child Fcb.
        There can also be detached subtrees due to open operations by Id where
        the Fcb's are not connected to the root.

        The following diagram shows the root structure.

            +--------+     +--------+
            |  Vcb   |---->| Fcb    |-------------------------------------------------------------------+
            |        |     |  Table |----------------------------------------------------------------+  |
            |        |--+  |        |-------------------------------------------------------------+  |  |
            +--------+  |  +--------+                                                             |  |  |
                        |    |  |  |                                                              |  |  |
                        |    |  |  +---------------------------------------------+                |  |  |
                        |    V  +-----------------------+                        |                |  |  |
                        |  +--------+                   |                        |                |  |  |
                        |  |RootFcb |                   V                        V                |  |  |
                        +->|        |    +-----+    +--------+               +--------+           |  |  |
                           |        |<-->| Lcb |<-->|Child   |    +-----+    |Child   |           |  |  |
                           +--------+    +-----+    | Fcb    |<-->| Lcb |<-->| Fcb    |<--> ...   |  |  |
                                                    |        |    +-----+    |        |           |  |  |
                                                    +--------+               +--------+           |  |  |
                                                                                                  |  |  |
                          (Freestanding sub-tree)                                                 |  |  |
                          +--------+                                                              |  |  |
                          |OpenById|<-------------------------------------------------------------+  |  |
                          | Dir    |    +--------+                                                   |  |
                          |        |--->|OpenById|<--------------------------------------------------+  |
                          +--------+    | Child  |    +--------+                                        |
                                        |  Dir   |--->|OpenById|<---------------------------------------+
                                        +--------+    | Child  |
                                                      |  File  |
                                                      +--------+

        Attached to each Directory Fcb is an prefix table containing the
        Lcbs pointing to children of this directory for which there is an Fcb.

            +--------+      +--------+
            |  Dir   |      | Prefix |
            |   Fcb  |----->|  Table |--------------------+
            |        |      |        |-------+            |
            +--------+      +--------+       |            |
                ^              |             |            |
                |              |             |            |
                |              V             V            V
                |           +--------+    +--------+    +--------+
                |           |  Lcb   |    |  Lcb   |    |  Lcb   |
                +---------->|        |<-->|        |<-->|        |
                            +--------+    +--------+    +--------+

        Each file object open on a UDF volume contains two context pointers.  The
        first will point back to the Fcb for the file object.  The second, if present,
        points to a Ccb (ContextControlBlock) which contains the per-handle information.
        This includes the state of any directory enumeration and the Lcb used to open
        this file object.

          +--------+       +--------+    +--------+
          |  Fcb   |<------| File   |    |  Ccb   |
          |        |       |  Object|--->|        |
          |        |       |        |    |        |
          +--------+       +--------+    +--------+
            ^    ^
            |    |         +--------+    +--------+
            |    |         | File   |    |  Ccb   |
            |    +---------|  Object|--->|        |
            |              |        |    |        |
            |              +--------+    +--------+
            |
            |              +--------+
            |              |Stream  |
            +--------------| File   |
                           |  Object|
                           +--------+


    Synchronization:

        1. A resource in the UdfData synchronizes access to the Vcb queue.  This
            is used during mount/verify/dismount operations.

        2. A resource in the Vcb is used to synchronize access to Vcb for
            open/close operations.  Typically acquired shared, it
            is acquired exclusively to lock out these operations.

        3. A second resource in the Vcb is used to synchronize all file operations.
            Typically acquired shared, it is acquired exclusively to lock
            out all file operations.  Acquiring both Vcb resources will lock
            the entire volume.

        4. A resource in the nonpaged Fcb will synchronize open/close operations
            on an Fcb.

        5. A fast mutex in the Vcb will protect access to the Fcb table and
            the open counts in the Vcb.  It is also used to modify the reference
            counts in all Fcbs/Lcbs.  This mutex cannot be acquired
            exclusely and is an end resource.

        6. A fast mutex in the Fcb will synchronize access to all Fcb fields
            which aren't synchronized in some other way.  A thread may acquire
            mutexes for multiple Fcb's as long as it works it way toward the
            root of the tree.  This mutex can also be acquired recursively.

        7. Normal locking order is UdfData/Vcb/Fcb starting at any point in this
            chain.  The Vcb is required prior to acquiring resources for multiple
            files.  Shared ownership of the Vcb is sufficient in this case.

        8. Normal locking order when acquiring multiple Fcb's is from some
            starting Fcb and walking towards the root of tree.  Create typically
            walks down the tree.  In this case we will attempt to acquire the
            next node optimistically and if that fails we will reference
            the current node in the tree, release it and acquire the next node.
            At that point it will be safe to reacquire the parent node.

        9. Locking order for the Fcb (via the fast mutex) will be from leaf of
            tree back towards the root.  No other resource may be acquired
            after locking the Vcb (other than in-page reads).

       10. Cleanup operations only lock the Vcb and Fcb long enough to change the
            critical counts and share access fields.  No reason to synchronize
            otherwise.  None of the structures can go away from beneath us
            in this case.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     31-May-1996
    
Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support
    
// @@END_DDKSPLIT

--*/

#ifndef _UDFSTRUC_
#define _UDFSTRUC_

typedef PVOID PBCB;


//
//  The following structure is used to encapsulate the converted timestamps for
//  straightforward referencing.
//

typedef struct _TIMESTAMP_BUNDLE {

    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   AccessTime;
    LARGE_INTEGER   ModificationTime;

} TIMESTAMP_BUNDLE, *PTIMESTAMP_BUNDLE;


//
//  The UDF_DATA record is the top record in the UDF file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

#define NUMBER_OF_FS_OBJECTS    2

typedef struct _UDF_DATA {

    //
    //  The type and size of this record (must be UDFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  Vcb queue.
    //

    LIST_ENTRY VcbQueue;

    //
    //  The following fields are used to allocate IRP context structures
    //  using a lookaside list, and other fixed sized structures from a
    //  small cache.  We use the CdData mutex to protext these structures.
    //

    ULONG IrpContextDepth;
    ULONG IrpContextMaxDepth;
    SINGLE_LIST_ENTRY IrpContextList;

    //
    //  Filesystem device objects for UDFS.
    //

    PDEVICE_OBJECT FileSystemDeviceObjects[NUMBER_OF_FS_OBJECTS];

    //
    //  Following are used to manage the async and delayed close queue.
    //
    //  FspCloseActive - Indicates whether there is a thread processing the
    //      two close queues.
    //  ReduceDelayedClose - Indicates that we have hit the upper threshold
    //      for the delayed close queue and need to reduce it to lower threshold.
    //
    //  AsyncCloseQueue - Queue of IrpContext waiting for async close operation.
    //  AsyncCloseCount - Number of entries on the async close queue.
    //
    //  DelayedCloseQueue - Queue of IrpContextLite waiting for delayed close
    //      operation.
    //  MaxDelayedCloseCount - Trigger delay close work at this threshold.
    //  MinDelayedCloseCount - Turn off delay close work at this threshold.
    //  DelayedCloseCount - Number of entries on the delayted close queue.
    //
    //  CloseItem - Workqueue item used to start FspClose thread.
    //

    LIST_ENTRY AsyncCloseQueue;
    ULONG AsyncCloseCount;
    BOOLEAN FspCloseActive;
    BOOLEAN ReduceDelayedClose;
    USHORT PadUshort;

    //
    //  The following fields describe the deferred close file objects.
    //

    LIST_ENTRY DelayedCloseQueue;
    ULONG DelayedCloseCount;
    ULONG MaxDelayedCloseCount;
    ULONG MinDelayedCloseCount;

    //
    //  Fast mutex used to lock the fields of this structure.
    //

    PVOID UdfDataLockThread;
    FAST_MUTEX UdfDataMutex;

    //
    //  A resource variable to control access to the global UDFS data record
    //

    ERESOURCE DataResource;

    //
    //  Cache manager call back structure, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerVolumeCallbacks;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    WORK_QUEUE_ITEM CloseItem;

} UDF_DATA, *PUDF_DATA;


//
//  A PARTITION will record the VSN/LSN -> PSN retrieval information for a
//  partition reference.  Since we do not support multi-volume 13346/UDF,
//  we will omit noting the volume sequence number that would tell us which
//  piece of media contained the partition.
//
//  There are currently three types of partitions used during operation: physical,
//  sparable and virtual.  However, since sparing merely adds another last layer
//  of quick indirection, we consider them as a minor extension of a physical
//  partition.
//

typedef enum _PARTITION_TYPE {
    Uninitialized,
    Physical,
    Virtual
} PARTITION_TYPE, *PPARTITION_TYPE;

//
//  A Physical partition corresponds to a single extent of the volume.
//

typedef struct _PARTITION_PHYSICAL {

    //
    //  Starting Psn and length in sectors
    //

    ULONG Start;
    ULONG Length;

    //
    //  The partition number is specified by the LVD, and refers to
    //  a specific partition descriptor on the media.  We use this
    //  in the second pass of partition discovery.
    //

    ULONG PartitionNumber;
    PNSR_PART PartitionDescriptor;

    //
    //  Spared partition map, saved temporarily between
    //  logical volume descriptor analysis and partition
    //  descriptor discover/pcb completion.
    //

    PPARTMAP_SPARABLE SparingMap;

} PARTITION_PHYSICAL, *PPARTITION_PHYSICAL;

//
//  A Virtual partition is a remapping from VSN to LSN on a given Physical
//  partition.  The remapping is done through the VAT FCB.
//

typedef struct _PARTITION_VIRTUAL{

    //
    //  The maximum Vbn in the virtual partition.
    //

    ULONG Length;
    
    //
    //  A virtual partition refers to its "host" physical partition by partition
    //  number, which we translate to a partition reference during the second pass
    //  of partition discovery.
    //
    //  Example: if the virtual partition is reference 1, hosted on partition 156
    //  (which is reference 0 for this logical volume), then NSRLBA 100/1 would
    //  refer to the block on partition ref 0 as mapped in the VAT at entry 100.
    //

    USHORT RelatedReference;

} PARTITION_VIRTUAL, *PPARTITION_VIRTUAL;
        
//
//  There is exactly one PARTITION per partition.  It is responsible for mapping
//  from some form of logical sector to a physical sector.
//

typedef struct _PARTITION {

    //
    //  This is the type of partition.
    //

    PARTITION_TYPE Type;

    union {

        PARTITION_PHYSICAL Physical;
        PARTITION_VIRTUAL Virtual;
    };

} PARTITION, *PPARTITION;

//
//  The Pcb (Partition control block) record corresponds to the partitions
//  which collectively form the mounted volume.  Exactly one of these is
//  linked off of the Vcb.
//

typedef struct _PCB {

    //
    //  The type and size of this record (must be UDFS_NTC_PCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  This is the number of partitions in the map
    //

    USHORT Partitions;

    //
    //  A bitmask of flags.
    //

    USHORT Flags;

    //
    //  Sparing Mcb, if this volume has sparing.
    //

    PLARGE_MCB SparingMcb;

    //
    //  This is the mapping table.  A PCB will be dynamically sized
    //  according to the number of partitions forming the volume.
    //

    PARTITION Partition[0];

} PCB, *PPCB;

//
//  Indicate what kinds of partitions are contained for quick checks.
//

#define PCB_FLAG_PHYSICAL_PARTITION     0x0001
#define PCB_FLAG_VIRTUAL_PARTITION      0x0002
#define PCB_FLAG_SPARABLE_PARTITION     0x0004


//
//  The Vmcb structure is a double mapped structure for mapping
//  between VBNs and LBNs using the MCB structures.  The whole structure
//  is also protected by a private mutex.  This record must be allocated
//  from non-paged pool.
//

//
//  We use an #if to snip out historical code in the Vmcb package that
//  dealt with write issues, leaving it for the future.
//

#define VMCB_WRITE_SUPPORT 0

typedef struct _VMCB {

    //
    //  The type and size of this record (must be UDFS_NTC_VMCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    ERESOURCE Resource;

    MCB VbnIndexed;     // maps VBNs to LBNs
    MCB LbnIndexed;     // maps LBNs to VBNs

    ULONG MaximumLbn;

    ULONG SectorSize;

} VMCB, *PVMCB;

#define UDF_INVALID_VSN -1

//
//  The Vcb (Volume control block) record corresponds to every
//  volume mounted by the file system.  They are ordered in a queue off
//  of UdfData.VcbQueue.
//
//  The Vcb will be in several conditions during its lifespan.
//
//      NotMounted - Disk is not currently mounted (i.e. removed
//          from system) but cleanup and close operations are
//          supported.
//
//      MountInProgress - State of the Vcb from the time it is
//          created until it is successfully mounted or the mount
//          fails.
//
//      Mounted - Volume is currently in the mounted state.
//
//      Invalid - User has invalidated the volume.  Only legal operations
//          are cleanup and close.
//
//      DismountInProgress - We have begun the process of tearing down the
//          Vcb.  It can be deleted when all the references to it
//          have gone away.
//

typedef enum _VCB_CONDITION {

    VcbNotMounted = 0,
    VcbMountInProgress,
    VcbMounted,
    VcbInvalid,
    VcbDismountInProgress

} VCB_CONDITION;

typedef struct _VCB {

    //
    //  The type and size of this record (must be UDFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Vpb for this volume.
    //

    PVPB Vpb;

    //
    //  Pcb for this volume.
    //

    PPCB Pcb;

    //
    //  Device object for the driver below us.
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  Link into queue of Vcb's in the UdfData structure.  We will create a union with
    //  a LONGLONG to force the Vcb to be quad-aligned.
    //

    union {

        LIST_ENTRY VcbLinks;
        LONGLONG Alignment;
    };

    //
    //  State flags and condition for the Vcb.
    //

    ULONG VcbState;
    VCB_CONDITION VcbCondition;

    //
    //  File object used to lock the volume.
    //

    PFILE_OBJECT VolumeLockFileObject;

    //
    //  Media change count from device driver for bulletproof detection
    //  of media movement
    //

    ULONG MediaChangeCount;

    //
    //  Logical block size for this volume.
    //

    ULONG SectorSize;

    //
    //  Associated shift size
    //

    ULONG SectorShift;

    //
    //  LSN of the bounds that CD-UDF defines.
    //
    //  S - start of the session that contains the AVD @ +256
    //  N - end of the disc, another chance to find AVD @ -256,
    //      and discovery of the VAT ICB.
    //
    //  N may be unset until late in the mount sequence for a volume, since
    //  the device may not respond to CD-style TOC requests, and only then
    //  be a guess based on the partitons we find. S will be zero except in
    //  the case of CD-UDF.  In a mounted system, S will correspond to where
    //  we started finding the volume descriptors that let us proceed.
    //

    ULONG BoundS;
    ULONG BoundN;

    //
    //  Various counts for this Vcb.
    //
    //      VcbCleanup - Open handles left on this system.
    //      VcbReference - Number of reasons this Vcb is still present.
    //      VcbUserReference - Number of user file objects still present.
    //

    ULONG VcbCleanup;
    ULONG VcbReference;
    ULONG VcbUserReference;

    //
    //  These are the number of times a mounted Vcb will be referenced on behalf
    //  of the system.  See commentary in udfdata.h.
    //

    ULONG VcbResidualReference;
    ULONG VcbResidualUserReference;

    //
    //  Fcb for the Volume Dasd file, root directory and the Vmcb-mapped Metadata stream.
    //  The VAT Fcb is only created on CD UDF media, for the Virtual Allocation Table.
    //

    struct _FCB *VolumeDasdFcb;
    struct _FCB *RootIndexFcb;
    struct _FCB *MetadataFcb;
    struct _FCB *VatFcb;

    //
    //  Offset from the beginning of the VAT stream to the first entry (UDF 2.0x has a header
    //  at the beginning of the VAT),  and number of entries in the VAT.
    //
    
    ULONG OffsetToFirstVATEntry;
    ULONG VATEntryCount;
    
    //
    //  Vmcb for the metadata stream
    //

    VMCB Vmcb;
    
    //
    //  Vmcb resource.  This is used to synchronize mapping/purge operations on
    //  the vmcb stream.  Must be acquired shared around any map/unpin or ccread 
    //  on the vmcb,  and exclusive for ccpurge.  All mappings made in the current
    //  thread must be dropped before attempting to acquire exclusive.
    //

    ERESOURCE VmcbMappingResource;
    
    //
    //  Vcb resource.  This is used to synchronize open/cleanup/close operations.
    //

    ERESOURCE VcbResource;

    //
    //  File resource.  This is used to synchronize all file operations except
    //  open/cleanup/close.
    //

    ERESOURCE FileResource;

    //
    //  Vcb fast mutex.  This is used to synchronize the fields in the Vcb
    //  when modified when the Vcb is not held exclusively.  Included here
    //  are the count fields and Fcb table.
    //
    //  We also use this to synchronize changes to the Fcb reference field.
    //

    FAST_MUTEX VcbMutex;
    PVOID VcbLockThread;

    //
    //  The following is used to synchronize the dir notify package.
    //

    PNOTIFY_SYNC NotifySync;

    //
    //  The following is the head of a list of notify Irps.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  Fcb table.  Synchronized with the Vcb fast mutex.
    //

    RTL_GENERIC_TABLE FcbTable;

    //
    //  Preallocated VPB for swapout, so we are not forced to consider
    //  must succeed pool.
    //

    PVPB SwapVpb;

    //
    //  Information telling us what version of UDF we expect this disc to
    //  conform to.  NsrVersion will be one of VsdIdentNSR02 or VsdIdentNSR03
    //  UdfXXXRead will be one of UDF_VERSION_XXX.
    //
    
    USHORT  NsrVersion;
    USHORT  UdfRevision;

} VCB, *PVCB;

#define VCB_STATE_LOCKED                            (0x00000001)
#define VCB_STATE_REMOVABLE_MEDIA                   (0x00000002)
#define VCB_STATE_NOTIFY_REMOUNT                    (0x00000004)
#define VCB_STATE_METHOD_2_FIXUP                    (0x00000008)
#define VCB_STATE_VMCB_INIT                         (0x00000010)
#define VCB_STATE_VPB_NOT_ON_DEVICE                 (0x00000020)

//
//  The Volume Device Object is an I/O system device object with a
//  workqueue and an VCB record appended to the end.  There are multiple
//  of these records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload
//  of work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT, *PVOLUME_DEVICE_OBJECT;


//
//  Udfs file id is a large integer. This corresponds to the FileInternalInformation
//  query type and is used for internal FCB indexing.
//

typedef LARGE_INTEGER                   FILE_ID, *PFILE_ID;


//
//  Lcb (Link Control Block), which corresponds to a link from a directory (or in
//  the future, other container objects) to a file (UDF File Identifier).  There is
//  one of these for each name tuple in a prefix table.
//

typedef struct _LCB {

    //
    //  Type and size of this record (must be UDFS_NTC_LCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Pointer to the Parent Fcb for this entry and queue for Parent to
    //  find all referencing Lcbs.  Corresponds to Fcb->ChildLcbQueue.
    //

    LIST_ENTRY ParentFcbLinks;
    struct _FCB *ParentFcb;

    //
    //  Pointer to Child (referenced) Fcb for this entry and queue for Child
    //  to find all referencing Lcbs.  Corresponds to Fcb->ParentLcbQueue.
    //

    LIST_ENTRY ChildFcbLinks;
    struct _FCB *ChildFcb;

    //
    //  Number of extra realtime references made to this Lcb.
    //

    ULONG Reference;

    //
    //  Flags indicating the state of this Lcb.
    //

    ULONG Flags;

    //
    //  File attributes to be merged with the child Fcb.  UDF seperates interesting
    //  information into the FID and FE so, properly, the name link (corresponding to
    //  a FID) must record some extra information.
    //

    ULONG FileAttributes;

    //
    //  Splay links in the prefix tree.
    //
    
    RTL_SPLAY_LINKS Links;

    //
    //  The name of this link.
    //

    UNICODE_STRING FileName;

} LCB, *PLCB;

#define LCB_FLAG_IGNORE_CASE        0x00000001
#define LCB_FLAG_SHORT_NAME         0x00000002
#define LCB_FLAG_POOL_ALLOCATED     0x00000004

//
//  We build a lookaside of Lcb capable of holding a reasonably sized name.
//

#define SIZEOF_LOOKASIDE_LCB        ( sizeof( LCB ) + ( sizeof( WCHAR ) * 16 ))


//
//  The following two structures are the separate union structures for
//  data and index Fcb's.
//

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

typedef struct _FCB_NONPAGED {

    //
    //  Type and size of this record must be UDFS_NTC_FCB_NONPAGED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to
    //  point to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  This is the resource structure for this Fcb.
    //

    ERESOURCE FcbResource;

    //
    //  This is the FastMutex for this Fcb.
    //

    FAST_MUTEX FcbMutex;

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

} FCB_NONPAGED;
typedef FCB_NONPAGED *PFCB_NONPAGED;

typedef struct _FCB_DATA {

    //
    //  The following field is used by the oplock module
    //  to maintain current oplock information.
    //

    OPLOCK Oplock;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //  A file lock is allocated as needed.
    //

    PFILE_LOCK FileLock;

} FCB_DATA, *PFCB_DATA;

typedef struct _FCB_INDEX {

    //
    //  Internal stream file for the directory.
    //

    PFILE_OBJECT FileObject;

    //
    //  Root of splay trees for exact and ignore case prefix trees.
    //

    PRTL_SPLAY_LINKS ExactCaseRoot;
    PRTL_SPLAY_LINKS IgnoreCaseRoot;

} FCB_INDEX, *PFCB_INDEX;

//
//  The Fcb/Dcb record corresponds to every open file and directory, and to
//  every directory on an opened path.
//

typedef struct _FCB_CORE {

    //
    //  The following field is used for fast I/O.  It contains the node
    //  type code and size, indicates if fast I/O is possible, contains
    //  allocation, file, and valid data size, a resource, and call back
    //  pointers for FastIoRead and FastMdlRead.
    //
    //
    //  Node type codes for the Fcb must be one of the following.
    //
    //      UDFS_NTC_FCB_INDEX
    //      UDFS_NTC_FCB_DATA
    //

    //
    //  Common Fsrtl Header.  The named header is for the fieldoff.c output.  We
    //  use the unnamed header internally.
    //

    union {

        FSRTL_ADVANCED_FCB_HEADER Header;
        FSRTL_ADVANCED_FCB_HEADER;
    };

    //
    //  Vcb for this Fcb.
    //

    PVCB Vcb;

    //
    //  Queues of Lcbs that are on this Fcb: Parent - edges that lead in
    //                                       Child  - edges that lead out
    //
    //  We anticipate supporting the streaming extension to UDF 2.0, so we
    //  leave the ChildLcbQueue here which in the case of a stream-rich file
    //  will contain a solitary Lcb leading to the stream directory.
    //

    LIST_ENTRY ParentLcbQueue;
    LIST_ENTRY ChildLcbQueue;

    //
    //  Length of Root ICB Extent for this object.  Coupled with the information
    //  in the FileId, this will allow discovery of the active File Entry for this
    //  Fcb at any time.
    //

    ULONG RootExtentLength;

    //
    //  FileId for this file.
    //

    FILE_ID FileId;

    //
    //  Counts on this Fcb.  Cleanup count represents the number of open handles
    //  on this Fcb.  Reference count represents the number of reasons this Fcb
    //  is still present.  It includes file objects, children Fcb and anyone
    //  who wants to prevent this Fcb from going away.  Cleanup count is synchronized
    //  with the FcbResource.  The reference count is synchronized with the
    //  VcbMutex.
    //

    ULONG FcbCleanup;
    ULONG FcbReference;
    ULONG FcbUserReference;

    //
    //  State flags for this Fcb.
    //

    ULONG FcbState;

    //
    //  NT style attributes for the Fcb.
    //

    ULONG FileAttributes;

    //
    //  This is the thread and count for the thread which has locked this
    //  Fcb.
    //

    PVOID FcbLockThread;
    ULONG FcbLockCount;

    //
    //  Information for Lsn->Psn mapping.  If the file data is embedded, we have a
    //  lookup into the metadata stream for the single logical block and an offset
    //  of the data within that block.  If the file data is is external, we have a
    //  regular Mapping Control Block.
    //
    //  Metadata structures are mapped through the volume-level Metadata Fcb which
    //  uses the volume's VMCB.
    //

    union {
        
        LARGE_MCB Mcb;

        struct EMBEDDED_MAPPING {
            
            ULONG EmbeddedVsn;
            ULONG EmbeddedOffset;
        };
    };

    //
    //  This is the nonpaged data for the Fcb
    //

    PFCB_NONPAGED FcbNonpaged;

    //
    //  Share access structure.
    //

    SHARE_ACCESS ShareAccess;

    //
    //  We cache a few fields from the FE so that various operations do not have to
    //  hit the disk (query, etc.).
    //
    
    //
    //  Time stamps for this file.
    //

    TIMESTAMP_BUNDLE Timestamps;

    //
    //  Link count on this file.
    //

    USHORT LinkCount;

    //
    //  Icb.Icbtag.Filetype
    //

    UCHAR UdfIcbFileType;
} FCB_CORE, *PFCB_CORE;


//
//  Split the Fcb into Core / Type specific structures,  for the benefit of debugger
//  extensions. which try and read the largest possible size of a union...
//

typedef struct _FCB  {

    FCB_CORE;

    union {

        ULONG FcbType;
        FCB_INDEX;
        FCB_DATA;
    };

} FCB, *PFCB;


#define FCB_STATE_INITIALIZED                   (0x00000001)
#define FCB_STATE_IN_FCB_TABLE                  (0x00000002)
#define FCB_STATE_VMCB_MAPPING                  (0x00000004)
#define FCB_STATE_EMBEDDED_DATA                 (0x00000008)
#define FCB_STATE_MCB_INITIALIZED               (0x00000010)
#define FCB_STATE_ALLOW_ONEGIG_WORKAROUND       (0x00000020)

#define SIZEOF_FCB_DATA              \
    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_DATA ))

#define SIZEOF_FCB_INDEX             \
    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_INDEX ))


//
//  The Ccb record is allocated for every user file object
//

typedef struct _CCB {

    //
    //  Type and size of this record (must be UDFS_NTC_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Flags.  Indicates flags to apply for the current open.
    //

    ULONG Flags;

    //
    //  Fcb for the file being opened.
    //

    PFCB Fcb;

    //
    //  Lcb for the file being opened.
    //

    PLCB Lcb;

    //
    //  We store state information in the Ccb for a directory
    //  enumeration on this handle.
    //

    //
    //  Offset in the virtual directory stream to base the next enumeration.
    //
    //  A small number (in fact, possibly one) of file indices are reserved for
    //  synthesized directory entries (like '.'). Past that point, CurrentFileIndex -
    //  UDF_MAX_SYNTHESIZED_FILEINDEX is a byte offset in the stream.
    //

    LONGLONG CurrentFileIndex;
    UNICODE_STRING SearchExpression;

    //
    //  Highest ULONG-representable FileIndex so far found in the directory stream.
    //  This corresponds to the highest FileIndex returnable in a query structure.
    //

    ULONG HighestReturnableFileIndex;

} CCB, *PCCB;

#define CCB_FLAG_OPEN_BY_ID                     (0x00000001)
#define CCB_FLAG_OPEN_RELATIVE_BY_ID            (0x00000002)
#define CCB_FLAG_IGNORE_CASE                    (0x00000004)
#define CCB_FLAG_DISMOUNT_ON_CLOSE              (0x00000008)
#define CCB_FLAG_ALLOW_EXTENDED_DASD_IO         (0x00000010)

//
//  Following flags refer to index enumeration.
//

#define CCB_FLAG_ENUM_NAME_EXP_HAS_WILD         (0x00010000)
#define CCB_FLAG_ENUM_MATCH_ALL                 (0x00020000)
#define CCB_FLAG_ENUM_RETURN_NEXT               (0x00040000)
#define CCB_FLAG_ENUM_INITIALIZED               (0x00080000)
#define CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY    (0x00100000)

//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the UdfComplete
//  request routine
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be UDFS_NTC_IRP_CONTEXT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Originating Irp for the request.
    //

    PIRP Irp;

    //
    //  Vcb for this operation.  When this is NULL it means we were called
    //  with our filesystem device object instead of a volume device object.
    //  (Mount will fill this in once the Vcb is created)
    //

    PVCB Vcb;

    //
    //  Exception encountered during the request.  Any error raised explicitly by
    //  the file system will be stored here.  Any other error raised by the system
    //  is stored here after normalizing it.
    //

    NTSTATUS ExceptionStatus;

    //
    //  Flags for this request.
    //

    ULONG Flags;

    //
    //  Real device object.  This represents the physical device closest to the media.
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  Io context for a read request.
    //  Address of Fcb for teardown oplock in create case.
    //

    union {

        struct _UDF_IO_CONTEXT *IoContext;
        PFCB *TeardownFcb;
    };

    //
    //  Top level irp context for this thread.
    //

    struct _IRP_CONTEXT *TopLevel;

    //
    //  Major and minor function codes.
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  Pointer to the top-level context if this IrpContext is responsible
    //  for cleaning it up.
    //

    struct _THREAD_CONTEXT *ThreadContext;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

} IRP_CONTEXT, *PIRP_CONTEXT;

#define IRP_CONTEXT_FLAG_ON_STACK               (0x00000001)
#define IRP_CONTEXT_FLAG_MORE_PROCESSING        (0x00000002)
#define IRP_CONTEXT_FLAG_WAIT                   (0x00000004)
#define IRP_CONTEXT_FLAG_FORCE_POST             (0x00000008)
#define IRP_CONTEXT_FLAG_TOP_LEVEL              (0x00000010)
#define IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS         (0x00000020)
#define IRP_CONTEXT_FLAG_IN_FSP                 (0x00000040)
#define IRP_CONTEXT_FLAG_IN_TEARDOWN            (0x00000080)
#define IRP_CONTEXT_FLAG_ALLOC_IO               (0x00000100)
#define IRP_CONTEXT_FLAG_DISABLE_POPUPS         (0x00000200)
#define IRP_CONTEXT_FLAG_FORCE_VERIFY           (0x00000400)

//
//  Flags used for create.
//

#define IRP_CONTEXT_FLAG_FULL_NAME              (0x10000000)
#define IRP_CONTEXT_FLAG_TRAIL_BACKSLASH        (0x20000000)

//
//  The following flags need to be cleared when a request is posted.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_POST (   \
    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \
    IRP_CONTEXT_FLAG_WAIT               |   \
    IRP_CONTEXT_FLAG_FORCE_POST         |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS     |   \
    IRP_CONTEXT_FLAG_IN_FSP             |   \
    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \
    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \
)

//
//  The following flags need to be cleared when a request is retried.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY (  \
    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \
    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \
    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \
)

//
//  The following flags are set each time through the Fsp loop.
//

#define IRP_CONTEXT_FSP_FLAGS (             \
    IRP_CONTEXT_FLAG_WAIT               |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS     |   \
    IRP_CONTEXT_FLAG_IN_FSP                 \
)


//
//  Following structure is used to queue a request to the delayed close queue.
//  This structure should be the minimum block allocation size.
//

typedef struct _IRP_CONTEXT_LITE {

    //
    //  Type and size of this record (must be UDFS_NTC_IRP_CONTEXT_LITE)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Fcb for the file object being closed.
    //

    PFCB Fcb;

    //
    //  List entry to attach to delayed close queue.
    //

    LIST_ENTRY DelayedCloseLinks;

    //
    //  User reference count for the file object being closed.
    //

    ULONG UserReference;

    //
    //  Real device object.  This represents the physical device closest to the media.
    //

    PDEVICE_OBJECT RealDevice;

} IRP_CONTEXT_LITE, *PIRP_CONTEXT_LITE;


//
//  Context structure for asynchronous I/O calls.  Most of these fields
//  are actually only required for the ReadMultiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _UDF_IO_CONTEXT {

    //
    //  These two fields are used for multiple run Io
    //

    LONG IrpCount;
    PIRP MasterIrp;
    NTSTATUS Status;
    BOOLEAN AllocatedContext;

    union {

        //
        //  This element handles the asynchronous non-cached Io
        //

        struct {

            PERESOURCE Resource;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;
        };

        //
        //  and this element handles the synchronous non-cached Io.
        //

        KEVENT SyncEvent;
    };

} UDF_IO_CONTEXT, *PUDF_IO_CONTEXT;


//
//  Following structure is used to track the top level request.  Each Udfs
//  Fsd and Fsp entry point will examine the top level irp location in the
//  thread local storage to determine if this request is top level and/or
//  top level Udfs.  The top level Udfs request will remember the previous
//  value and update that location with a stack location.  This location
//  can be accessed by recursive Udfs entry points.
//

typedef struct _THREAD_CONTEXT {

    //
    //  UDFS signature.  Used to confirm structure on stack is valid.
    //

    ULONG Udfs;

    //
    //  Previous value in top-level thread location.  We restore this
    //  when done.
    //

    PIRP SavedTopLevelIrp;

    //
    //  Top level Udfs IrpContext.  Initial Udfs entry point on stack
    //  will store the IrpContext for the request in this stack location.
    //

    PIRP_CONTEXT TopLevelIrpContext;

} THREAD_CONTEXT, *PTHREAD_CONTEXT;


//
//  Following structure is used to build up static data for parse tables
//

typedef struct _PARSE_KEYVALUE {
    PCHAR Key;
    ULONG Value;
} PARSE_KEYVALUE, *PPARSE_KEYVALUE;


//
//  Some macros for supporting the use of a Generic Table
//  containing all the FCB and indexed by their FileId.
//
//  The ISO 13346 lb_addr of the ICB hierarchy of the object
//
//      { ULONG BlockNo; USHORT PartitionId }
//
//  is encoded in the LowPart (BlockNo) and low 16 bits of the
//  HighPart (PartitionId). The top 16 bits are reserved and are
//  currently used to indicate the type of the object being referenced
//  (file or directory).
//
//  NOTE: this FileId prevents us from being able crack the name of
//  object since an ICB hierarchy's contained direct File Entrys do
//  not (and cannot) contain backpointers to the containing directory.
//  In order to be able to crack paths, we need to be able to do a
//  directory/dirent offset, which cannot fit in 64bits of FileId.
//  A FileId must be 64bits since we export this in the FileInternalInforation
//  query.
//
//  Also, even through we are restricted to a single partition in this
//  implementation, getting those "spare" 16bits isn't good enough to let us
//  point directly into a directory's File Identifier. Files and by extension
//  directories can exceed 2^32 bytes/entries.  Once we have pointed at the
//  parent dir, we are out of bits.
//
//  The Id field is a LARGE_INTEGER where the High and Low parts can be
//  accessed separately.
//
//  The following macros are used to access the Fid fields.
//
//      CdQueryFidDirentOffset      - Accesses the Dirent offset field
//      CdQueryFidPathTableNumber   - Accesses the PathTable offset field
//      CdSetFidDirentOffset        - Sets the Dirent offset field
//      CdSetFidPathTableNumber     - Sets the PathTable ordinal field
//      CdFidIsDirectory            - Queries if directory bit is set
//      CdFidSetDirectory           - Sets directory bit
//

#define FID_DIR_MASK  0x80000000        // high order bit means directory.

#define UdfSetFidFromLbAddr(I, LBA)     { (I).LowPart = (LBA).Lbn; \
                                          (I).HighPart = (ULONG) (LBA).Partition; }

#define UdfGetFidLbn(I)                 ((I).LowPart)
#define UdfGetFidPartition(I)           ((USHORT) (((I).HighPart & ~FID_DIR_MASK) & MAXUSHORT))
#define UdfGetFidReservedZero(I)        ((I).HighPart & ~(FID_DIR_MASK|MAXUSHORT))

#define UdfSetFidFile(I)                ClearFlag( (I).HighPart, FID_DIR_MASK )
#define UdfSetFidDirectory(I)           SetFlag( (I).HighPart, FID_DIR_MASK )

#define UdfIsFidFile(I)                 BooleanFlagOff( (I).HighPart, FID_DIR_MASK )
#define UdfIsFidDirectory(I)            BooleanFlagOn( (I).HighPart, FID_DIR_MASK )

#define UdfSetFidFromFidAndFe(I, FID, FE ) {                                                    \
        UdfSetFidFromLbAddr((I), (FID)->Icb.Start);                                             \
        if ((FE) && ((FE)->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY)) {                       \
            UdfSetFidDirectory((I));                                                            \
        }                                                                                       \
}


//
//  Context structures for browsing through structures
//

//
//  A mapped view is a useful bundle to hold information about a physical
//  view of the disk.
//

typedef struct _MAPPED_PVIEW {

    //
    //  A mapped extent and CC control block
    //

    PVOID View;
    PBCB Bcb;

    //
    //  Extent location
    //

    USHORT Partition;
    ULONG Lbn;
    ULONG Length;

    // 
    //  In the case of mappings through the metadata stream,  store the Vsn currently
    //  mapped to the Lbn
    //

    ULONG Vsn; 
    
} MAPPED_PVIEW, *PMAPPED_PVIEW;


//
//  Enumeration contexts for various operations.
//

//
//  The following is used for crawling ICB hierarchies searching
//  for some notion of an active entry.
//

typedef struct _ICB_SEARCH_CONTEXT {

    //
    //  Vcb the search is occuring on.
    //

    PVCB Vcb;

    //
    //  Type of Icb being searched for.
    //

    USHORT IcbType;

    //
    //  The Active is most prevailing ICB so far found.
    //

    MAPPED_PVIEW Active;
    
    //
    //  The current logical block extent being read from the disk.
    //

    MAPPED_PVIEW Current;

} ICB_SEARCH_CONTEXT, *PICB_SEARCH_CONTEXT;

//
//  The following is used for crawling Extended Attributes extending off of
//  a direct ICB
//

typedef enum _EA_SEARCH_TYPE {

    EaEnumBad = 0,
    EaEnumISO,
    EaEnumImplementation,
    EaEnumApplication

} EA_SEARCH_TYPE, *PEA_SEARCH_TYPE;

typedef struct _EA_SEARCH_CONTEXT {

    //
    //  Reference to an elaborated ICB_SEARCH_CONTEXT which gives us a handle
    //  onto a direct ICB to crawl.
    //

    PICB_SEARCH_CONTEXT IcbContext;

    //
    //  The current Ea being looked at.
    //

    PVOID Ea;

    //
    //  Bytes remaining in the EA view
    //

    ULONG Remaining;

    //
    //  EA being searched for.  We only support looking for ISO at this time.
    //

    ULONG EAType;
    USHORT EASubType;

} EA_SEARCH_CONTEXT, *PEA_SEARCH_CONTEXT;

//
//  The following is used to crawl the list of allocation extent descriptors attached
//  to an ICB.
//

typedef struct _ALLOC_ENUM_CONTEXT {

    //
    //  Reference to an elaborated ICB_ENUM_CONTEXT which gives us a handle
    //  onto a direct ICB to crawl.
    //

    PICB_SEARCH_CONTEXT IcbContext;

    //
    //  The current allocation descriptor being looked at.
    //

    PVOID Alloc;

    //
    //  Type of allocation descriptors in this enumeration
    //

    ULONG AllocType;

    //
    //  Bytes remaining in this view.
    //

    ULONG Remaining;

} ALLOC_ENUM_CONTEXT, *PALLOC_ENUM_CONTEXT;

//
//  The following is used to crawl a logical directory.
//

typedef struct _DIR_ENUM_CONTEXT {

    //
    //  The current view in the enumeration.
    //

    PVOID View;
    PBCB Bcb;

    //
    //  Offset of the view from the beginning of the directory.
    //
    
    LARGE_INTEGER BaseOffset;

    //
    //  Length of the view which is valid and the current
    //  offset in it.
    //

    ULONG ViewLength;
    ULONG ViewOffset;

    //
    //  Pointer to the current FID.
    //

    PNSR_FID Fid;

    //
    //  Offset to the next fid from the beginning of the view.
    //
    
    ULONG NextFidOffset;

    //
    //  Flags indicating the state of the enumeration.
    //

    ULONG Flags;

    //
    //  Converted names from the FID. Case name is "case appropriate" for
    //  the operation.
    //

    UNICODE_STRING ObjectName;
    UNICODE_STRING CaseObjectName;

    //
    //  Real object name in pure form (not rendered to NT legal form)
    //

    UNICODE_STRING PureObjectName;

    //
    //  Short name for the object.
    //

    UNICODE_STRING ShortObjectName;

    //
    //  Currently allocated space for the name.  The previous strings are
    //  carved out of this single buffer.
    //

    PVOID NameBuffer;

    //
    //  Size of currently allocated name buffer for the lfn names.
    //

    USHORT AllocLength;

} DIR_ENUM_CONTEXT, *PDIR_ENUM_CONTEXT;

//
//  Flags for noting where in the enumeration we are.
//

#define DIR_CONTEXT_FLAG_SEEN_NONCONSTANT       0x0001
#define DIR_CONTEXT_FLAG_SEEN_PARENT            0x0002

//
//  Flag indicating current Fid was buffered into pool.
//

#define DIR_CONTEXT_FLAG_FID_BUFFERED           0x0004

#endif // _CDSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\udfinit.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    UdfInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Udfs

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	24-May-1996
    Tom Jolly       [tomjolly]  21-Jan-2000
    
Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_UDFINIT)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_UDFINIT)

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
UdfInitializeGlobalData (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *FileSystemDeviceObjects
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, UdfInitializeGlobalData)
#endif


//
//  Local support routine
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the UDF file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT UdfsFileSystemDeviceObjects[NUMBER_OF_FS_OBJECTS];
    PDEVICE_OBJECT UdfsDiskFileSystemDeviceObject;

    //
    //  Create the device objects for both device "types".  Since
    //  UDF is a legitimate filesystem for media underlying device
    //  drivers claiming both DVD/CDROMs and disks, we must register
    //  this filesystem twice.
    //

    ASSERT( NUMBER_OF_FS_OBJECTS >= 2 );
    RtlZeroMemory( &UdfsFileSystemDeviceObjects, sizeof(PDEVICE_OBJECT) * NUMBER_OF_FS_OBJECTS );
    
    RtlInitUnicodeString( &UnicodeString, L"\\UdfsCdRom" );

    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                             0,
                             FALSE,
                             &UdfsFileSystemDeviceObjects[0] );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }
    
    RtlInitUnicodeString( &UnicodeString, L"\\UdfsDisk" );

    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &UdfsFileSystemDeviceObjects[1] );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( UdfsFileSystemDeviceObjects[0] );
        return Status;
    }
        
    try {

        Status = STATUS_SUCCESS;

        //
        //  Initialize the global data structures
        //

        UdfInitializeGlobalData( DriverObject, UdfsFileSystemDeviceObjects );

        //
        //  Note that because of the way data caching is done, we set neither
        //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
        //  data is not in the cache, or the request is not buffered, we may,
        //  set up for Direct I/O by hand.
        //

        //
        //  Initialize the driver object with this driver's entry points.
        //
        //  NOTE - Each entry in the dispatch table must have an entry in
        //  the Fsp/Fsd dispatch switch statements.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE]                  =
        DriverObject->MajorFunction[IRP_MJ_CLOSE]                   =
        DriverObject->MajorFunction[IRP_MJ_READ]                    =
        DriverObject->MajorFunction[IRP_MJ_WRITE]                   =
        DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]       =
        DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]         =
        DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION]=
        DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]       =
        DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]     =
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          =
        DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL]            =
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 =
        DriverObject->MajorFunction[IRP_MJ_PNP]                     = (PDRIVER_DISPATCH) UdfFsdDispatch;

        DriverObject->FastIoDispatch = &UdfFastIoDispatch;
        
        //
        //  Register the file system with the I/O system
        //

        IoRegisterFileSystem( UdfsFileSystemDeviceObjects[0] );
        IoRegisterFileSystem( UdfsFileSystemDeviceObjects[1] );

    }
    except (FsRtlIsNtstatusExpected(GetExceptionCode()) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        ObDereferenceObject( UdfsFileSystemDeviceObjects[0] );
        ObDereferenceObject( UdfsFileSystemDeviceObjects[1] );

        Status = GetExceptionCode();
    }
    
    //
    //  And return to our caller
    //

    return Status;
}


//
//  Local support routine
//

VOID
UdfInitializeGlobalData (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *UdfsFileSystemDeviceObjects
    )

/*++

Routine Description:

    This routine initializes the global Udfs data structures.

Arguments:

    DriverObject - Supplies the driver object for UDFS.

    FileSystemDeviceObjects - Supplies a vector of device objects for UDFS.

Return Value:

    None.

--*/

{
    USHORT CcbMaxDepth;
    USHORT FcbDataMaxDepth;
    USHORT FcbIndexMaxDepth;
    USHORT FcbNonPagedMaxDepth;
    USHORT IrpContextMaxDepth;
    USHORT LcbMaxDepth;
    TIMESTAMP UdfTime;

    //
    //  Initialize the CRC table. Per UDF 1.01, we use the seed 10041 octal (4129 dec).
    //  We do this first because it can raise (allocates memory)
    //

    UdfInitializeCrc16( 4129 );

    //
    //  Start by initializing the FastIoDispatch Table.
    //

    RtlZeroMemory( &UdfFastIoDispatch, sizeof( FAST_IO_DISPATCH ));

    UdfFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);

    UdfFastIoDispatch.AcquireFileForNtCreateSection =   UdfAcquireForCreateSection;
    UdfFastIoDispatch.ReleaseFileForNtCreateSection =   UdfReleaseForCreateSection;
    UdfFastIoDispatch.FastIoCheckIfPossible =           UdfFastIoCheckIfPossible;   //  CheckForFastIo
    UdfFastIoDispatch.FastIoRead =                      FsRtlCopyRead;              //  Read
    
    UdfFastIoDispatch.FastIoQueryBasicInfo =            NULL;                       //  QueryBasicInfo
    UdfFastIoDispatch.FastIoQueryStandardInfo =         NULL;                       //  QueryStandardInfo
    UdfFastIoDispatch.FastIoLock =                      NULL;                       //  Lock
    UdfFastIoDispatch.FastIoUnlockSingle =              NULL;                       //  UnlockSingle
    UdfFastIoDispatch.FastIoUnlockAll =                 NULL;                       //  UnlockAll
    UdfFastIoDispatch.FastIoUnlockAllByKey =            NULL;                       //  UnlockAllByKey
    UdfFastIoDispatch.FastIoQueryNetworkOpenInfo =      NULL;                       //  QueryNetworkInfo

    //
    //  Initialize the UdfData structure.
    //

    RtlZeroMemory( &UdfData, sizeof( UDF_DATA ));

    UdfData.NodeTypeCode = UDFS_NTC_DATA_HEADER;
    UdfData.NodeByteSize = sizeof( UDF_DATA );

    UdfData.DriverObject = DriverObject;
    RtlCopyMemory( &UdfData.FileSystemDeviceObjects,
                   UdfsFileSystemDeviceObjects,
                   sizeof(PDEVICE_OBJECT) * NUMBER_OF_FS_OBJECTS );

    InitializeListHead( &UdfData.VcbQueue );

    ExInitializeResourceLite( &UdfData.DataResource );

    //
    //  Initialize the cache manager callback routines
    //

    UdfData.CacheManagerCallbacks.AcquireForLazyWrite  = &UdfAcquireForCache;
    UdfData.CacheManagerCallbacks.ReleaseFromLazyWrite = &UdfReleaseFromCache;
    UdfData.CacheManagerCallbacks.AcquireForReadAhead  = &UdfAcquireForCache;
    UdfData.CacheManagerCallbacks.ReleaseFromReadAhead = &UdfReleaseFromCache;

    UdfData.CacheManagerVolumeCallbacks.AcquireForLazyWrite  = &UdfNoopAcquire;
    UdfData.CacheManagerVolumeCallbacks.ReleaseFromLazyWrite = &UdfNoopRelease;
    UdfData.CacheManagerVolumeCallbacks.AcquireForReadAhead  = &UdfNoopAcquire;
    UdfData.CacheManagerVolumeCallbacks.ReleaseFromReadAhead = &UdfNoopRelease;

    //
    //  Initialize the lock mutex and the async and delay close queues.
    //

    ExInitializeFastMutex( &UdfData.UdfDataMutex );
    InitializeListHead( &UdfData.AsyncCloseQueue );
    InitializeListHead( &UdfData.DelayedCloseQueue );

    ExInitializeWorkItem( &UdfData.CloseItem,
                          (PWORKER_THREAD_ROUTINE) UdfFspClose,
                          NULL );

    //
    //  Do the initialization based on the system size.
    //

    switch (MmQuerySystemSize()) {

    case MmSmallSystem:
        
        IrpContextMaxDepth = 4;
        UdfData.MaxDelayedCloseCount = 10;
        UdfData.MinDelayedCloseCount = 2;
        break;

    case MmLargeSystem:

        IrpContextMaxDepth = 24;
        UdfData.MaxDelayedCloseCount = 72;
        UdfData.MinDelayedCloseCount = 18;
        break;

    default:
    case MmMediumSystem:
    
        IrpContextMaxDepth = 8;
        UdfData.MaxDelayedCloseCount = 32;
        UdfData.MinDelayedCloseCount = 8;
        break;
    
    }

    //
    //  Size lookasides to match what will commonly be dumped into them when we
    //  run down the delayed close queues.
    //
    
    LcbMaxDepth =
    CcbMaxDepth =
    FcbDataMaxDepth =
    FcbNonPagedMaxDepth = (USHORT) (UdfData.MaxDelayedCloseCount - UdfData.MinDelayedCloseCount);

    //
    //  We should tend to have fewer indices than files.
    //
    
    FcbIndexMaxDepth = FcbNonPagedMaxDepth / 2;

#define NPagedInit(L,S,T,D) { ExInitializeNPagedLookasideList( (L), NULL, NULL, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#define PagedInit(L,S,T,D)  { ExInitializePagedLookasideList(  (L), NULL, NULL, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }

    NPagedInit( &UdfIrpContextLookasideList, sizeof( IRP_CONTEXT ), TAG_IRP_CONTEXT, IrpContextMaxDepth );
    NPagedInit( &UdfFcbNonPagedLookasideList, sizeof( FCB_NONPAGED ), TAG_FCB_NONPAGED, FcbNonPagedMaxDepth );

    PagedInit( &UdfCcbLookasideList, sizeof( CCB ), TAG_CCB, CcbMaxDepth );
    PagedInit( &UdfFcbIndexLookasideList, SIZEOF_FCB_INDEX, TAG_FCB_INDEX, FcbIndexMaxDepth );
    PagedInit( &UdfFcbDataLookasideList, SIZEOF_FCB_DATA, TAG_FCB_DATA, FcbDataMaxDepth );
    PagedInit( &UdfLcbLookasideList, SIZEOF_LOOKASIDE_LCB, TAG_LCB, LcbMaxDepth );

    //
    //  Initialize our default time which we use when enumerating FIDs whose
    //  associated FEs are toast.
    //

    RtlZeroMemory( &UdfTime, sizeof( TIMESTAMP));
    
    UdfTime.Day = 1;
    UdfTime.Month = 7;
    UdfTime.Year = 1974;
    
    UdfConvertUdfTimeToNtTime( NULL, 
                               &UdfTime, 
                               &UdfCorruptFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\verfysup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements the Udfs Verification routines.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     18-July-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_VERFYSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_VERFYSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfVerifyFcbOperation)
#pragma alloc_text(PAGE, UdfVerifyVcb)
#endif


NTSTATUS
UdfPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceToVerify
    )

/*++

Routine Description:

    This routines performs an IoVerifyVolume operation and takes the
    appropriate action.  If the verify is successful then we send the originating
    Irp off to an Ex Worker Thread.  This routine is called from the exception handler.

    No file system resources are held when this routine is called.

Arguments:

    Irp - The irp to send off after all is well and done.

    Device - The real device needing verification.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN AllowRawMount = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Check if this Irp has a status of Verify required and if it does
    //  then call the I/O system to do a verify.
    //
    //  Skip the IoVerifyVolume if this is a mount or verify request
    //  itself.  Trying a recursive mount will cause a deadlock with
    //  the DeviceObject->DeviceLock.
    //

    if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
        ((IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME) ||
         (IrpContext->MinorFunction == IRP_MN_VERIFY_VOLUME))) {

        return UdfFsdPostRequest( IrpContext, Irp );
    }

    //
    //  Extract a pointer to the Vcb from the VolumeDeviceObject.
    //  Note that since we have specifically excluded mount,
    //  requests, we know that IrpSp->DeviceObject is indeed a
    //  volume device object.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    Vcb = &CONTAINING_RECORD( IrpSp->DeviceObject,
                              VOLUME_DEVICE_OBJECT,
                              DeviceObject )->Vcb;

    //
    //  Check if the volume still thinks it needs to be verified,
    //  if it doesn't then we can skip doing a verify because someone
    //  else beat us to it. If this is a 'forced' verify then we 
    //  always go through the motions for mount sync. purposes.
    //

    try {

        //
        //  We will allow Raw to mount this volume if we were doing a
        //  an absolute DASD open.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
            (IrpSp->FileObject->FileName.Length == 0) &&
            (IrpSp->FileObject->RelatedFileObject == NULL)) {

            AllowRawMount = TRUE;
        }

        //
        //  Send down the verify FSCTL.  Note that this is sent to the
        //  currently mounted volume,  which may not be this one.
        //

        Status = IoVerifyVolume( DeviceToVerify, AllowRawMount );

        //
        //  Acquire the Vcb so we're working with a stable VcbCondition.
        //
        
        UdfAcquireVcbShared( IrpContext, Vcb, FALSE);

        //
        //  If the verify operation completed it will return
        //  either STATUS_SUCCESS or STATUS_WRONG_VOLUME, exactly.
        //
        //  If UdfVerifyVolume encountered an error during
        //  processing, it will return that error.  If we got
        //  STATUS_WRONG_VOLUME from the verify, and our volume
        //  is now mounted, commute the status to STATUS_SUCCESS.
        //

        if ((Status == STATUS_WRONG_VOLUME) &&
            (Vcb->VcbCondition == VcbMounted)) {

            Status = STATUS_SUCCESS;
        }
        else if ((STATUS_SUCCESS == Status) && (Vcb->VcbCondition != VcbMounted))  {

            //
            //  If the verify succeeded,  but our volume is not mounted,
            //  then some other volume is on the device. 
            //

            Status = STATUS_WRONG_VOLUME;
        } 

        //
        //  Do a quick unprotected check here.  The routine will do
        //  a safe check.  After here we can release the resource.
        //  Note that if the volume really went away, we will be taking
        //  the Reparse path.
        //

        //
        //  If the device might need to go away then call our dismount routine.
        //

        if (((Vcb->VcbCondition == VcbNotMounted) ||
             (Vcb->VcbCondition == VcbInvalid) ||
             (Vcb->VcbCondition == VcbDismountInProgress)) &&
            (Vcb->VcbReference <= Vcb->VcbResidualReference)) {

            UdfReleaseVcb( IrpContext, Vcb);
            
            UdfAcquireUdfData( IrpContext );
            UdfCheckForDismount( IrpContext, Vcb, FALSE );
            UdfReleaseUdfData( IrpContext );
        }
        else {

            UdfReleaseVcb( IrpContext, Vcb);
        }

        //
        //  If this is a create and the verify succeeded then complete the
        //  request with a REPARSE status.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
            (IrpSp->FileObject->RelatedFileObject == NULL) &&
            ((Status == STATUS_SUCCESS) || (Status == STATUS_WRONG_VOLUME))) {

            Irp->IoStatus.Information = IO_REMOUNT;

            UdfCompleteRequest( IrpContext, Irp, STATUS_REPARSE );
            Status = STATUS_REPARSE;
            Irp = NULL;
            IrpContext = NULL;

            DebugTrace(( 0, Dbg, "UdfPerformVerify, Reparsing create irp.\n"));

        //
        //  If there is still an error to process then call the Io system
        //  for a popup.
        //

        } else if ((Irp != NULL) && !NT_SUCCESS( Status )) {

            DebugTrace(( 0, Dbg, "UdfPerformVerify, Raising error %x (Op %x)\n", Status, 
                         IrpContext->MajorFunction));
            //
            //  Fill in the device object if required.
            //

            if (IoIsErrorUserInduced( Status ) ) {

                IoSetHardErrorOrVerifyDevice( Irp, DeviceToVerify );
            }

            //
            //  We should not be receiving this status from verify
            //  volume - we'll end up recursing out of stack.
            //
            
            ASSERT( STATUS_VERIFY_REQUIRED != Status);
           
            UdfNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  If there is still an Irp, send it off to an Ex Worker thread.
        //

        if (IrpContext != NULL) {

            DebugTrace(( 0, Dbg, "UdfPerformVerify, Posting IRP (Op %x)\n", IrpContext->MajorFunction));

            Status = UdfFsdPostRequest( IrpContext, Irp );
        }

    } except(UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the verify or raised
        //  an error ourselves.  So we'll abort the I/O request with
        //  the error status that we get back from the execption code.
        //

        Status = UdfProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    return Status;
}


BOOLEAN
UdfCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN Force
    )

/*++

Routine Description:

    This routine is called to check if a volume is ready for dismount.  This
    occurs when only file system references are left on the volume.

    If the dismount is not currently underway and the user reference count
    has gone to zero then we can begin the dismount.

    If the dismount is in progress and there are no references left on the
    volume (we check the Vpb for outstanding references as well to catch
    any create calls dispatched to the file system) then we can delete
    the Vcb.

Arguments:

    Vcb - Vcb for the volume to try to dismount.
    
    Force - Whether we will force this volume to be dismounted.

Return Value:

    BOOLEAN - True if the Vcb was not gone by the time this function finished,
        False if it was deleted.
        
    This is only a trustworthy indication to the caller if it had the vcb
    exclusive itself.

--*/

{
    BOOLEAN UnlockVcb = TRUE;
    BOOLEAN VcbPresent = TRUE;
    KIRQL SavedIrql;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    ASSERT_EXCLUSIVE_UDFDATA;

    //
    //  Acquire and lock this Vcb to check the dismount state.
    //

    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Lets get rid of any pending closes for this volume.
    //

    UdfFspClose( Vcb );

    UdfLockVcb( IrpContext, Vcb );

    //
    //  If the dismount is not already underway then check if the
    //  user reference count has gone to zero or we are being forced
    //  to disconnect.  If so start the teardown on the Vcb.
    //

    if (Vcb->VcbCondition != VcbDismountInProgress) {

        if (Vcb->VcbUserReference <= Vcb->VcbResidualUserReference || Force) {

            UdfUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;
            VcbPresent = UdfDismountVcb( IrpContext, Vcb );
        }

    //
    //  If the teardown is underway and there are absolutely no references
    //  remaining then delete the Vcb.  References here include the
    //  references in the Vcb and Vpb.
    //

    } else if (Vcb->VcbReference == 0) {

        IoAcquireVpbSpinLock( &SavedIrql );

        //
        //  If there are no file objects and no reference counts in the
        //  Vpb we can delete the Vcb.  Don't forget that we have the
        //  last reference in the Vpb.
        //

        if (Vcb->Vpb->ReferenceCount == 1) {

            IoReleaseVpbSpinLock( SavedIrql );
            UdfUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;
            UdfDeleteVcb( IrpContext, Vcb );
            VcbPresent = FALSE;

        } else {

            IoReleaseVpbSpinLock( SavedIrql );
        }
    }

    //
    //  Unlock the Vcb if still held.
    //

    if (UnlockVcb) {

        UdfUnlockVcb( IrpContext, Vcb );
    }

    //
    //  Release any resources still acquired.
    //

    if (VcbPresent) {

        UdfReleaseVcb( IrpContext, Vcb );
    }

    return VcbPresent;
}


BOOLEAN
UdfDismountVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called when all of the user references to a volume are
    gone.  We will initiate all of the teardown any system resources.

    If all of the references to this volume are gone at the end of this routine
    then we will complete the teardown of this Vcb and mark the current Vpb
    as not mounted.  Otherwise we will allocated a new Vpb for this device
    and keep the current Vpb attached to the Vcb.

Arguments:

    Vcb - Vcb for the volume to dismount.

Return Value:

    BOOLEAN - TRUE if we didn't delete the Vcb, FALSE otherwise.

--*/

{
    PVPB OldVpb;
    BOOLEAN VcbPresent = TRUE;
    KIRQL SavedIrql;

    BOOLEAN FinalReference;

    ASSERT_EXCLUSIVE_UDFDATA;
    ASSERT_EXCLUSIVE_VCB( Vcb );

    UdfLockVcb( IrpContext, Vcb );

    //
    //  We should only take this path once.
    //

    ASSERT( Vcb->VcbCondition != VcbDismountInProgress );

    //
    //  Mark the Vcb as DismountInProgress.
    //

    UdfSetVcbCondition( Vcb, VcbDismountInProgress);

    //
    //  Remove our reference to the internal Fcb's.  The Fcb's will then
    //  be removed in the purge path below.
    //

    if (Vcb->RootIndexFcb != NULL) {

        Vcb->RootIndexFcb->FcbReference -= 1;
        Vcb->RootIndexFcb->FcbUserReference -= 1;
    }

    if (Vcb->MetadataFcb != NULL) {

        Vcb->MetadataFcb->FcbReference -= 1;
        Vcb->MetadataFcb->FcbUserReference -= 1;
    }

    if (Vcb->VatFcb != NULL) {

        Vcb->VatFcb->FcbReference -= 1;
        Vcb->VatFcb->FcbUserReference -= 1;
    }

    if (Vcb->VolumeDasdFcb != NULL) {

        Vcb->VolumeDasdFcb->FcbReference -= 1;
        Vcb->VolumeDasdFcb->FcbUserReference -= 1;
    }

    UdfUnlockVcb( IrpContext, Vcb );

    //
    //  Purge the volume.
    //

    UdfPurgeVolume( IrpContext, Vcb, TRUE );

    //
    //  Empty the delayed and async close queues.
    //

    UdfFspClose( Vcb );

    OldVpb = Vcb->Vpb;

    //
    //  Remove the mount volume reference.
    //

    UdfLockVcb( IrpContext, Vcb );
    Vcb->VcbReference -= 1;

    //
    //  Acquire the Vpb spinlock to check for Vpb references.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    //
    //  Remember if this is the last reference on this Vcb.  We incremented
    //  the count on the Vpb earlier so we get one last crack it.  If our
    //  reference has gone to zero but the vpb reference count is greater
    //  than zero then the Io system will be responsible for deleting the
    //  Vpb.
    //

    FinalReference = (BOOLEAN) ((Vcb->VcbReference == 0) &&
                                (OldVpb->ReferenceCount == 1));

    //
    //  There is a reference count in the Vpb and in the Vcb.  We have
    //  incremented the reference count in the Vpb to make sure that
    //  we have last crack at it.  If this is a failed mount then we
    //  want to return the Vpb to the IO system to use for the next
    //  mount request.
    //

    if (OldVpb->RealDevice->Vpb == OldVpb) {

        //
        //  If not the final reference then swap out the Vpb.  We must
        //  preserve the REMOVE_PENDING flag so that the device is
        //  not remounted in the middle of a PnP remove operation.
        //

        if (!FinalReference) {

            ASSERT( Vcb->SwapVpb != NULL );

            Vcb->SwapVpb->Type = IO_TYPE_VPB;
            Vcb->SwapVpb->Size = sizeof( VPB );
            Vcb->SwapVpb->RealDevice = OldVpb->RealDevice;

            Vcb->SwapVpb->RealDevice->Vpb = Vcb->SwapVpb;

            Vcb->SwapVpb->Flags = FlagOn( OldVpb->Flags, VPB_REMOVE_PENDING );
            
            IoReleaseVpbSpinLock( SavedIrql );

            //
            //  Indicate we used up the swap.
            //

            Vcb->SwapVpb = NULL;

            UdfUnlockVcb( IrpContext, Vcb );

        //
        //  We want to leave the Vpb for the IO system.  Mark it
        //  as being not mounted.  Go ahead and delete the Vcb as
        //  well.
        //

        } else {

            //
            //  Make sure to remove the last reference on the Vpb.
            //

            OldVpb->ReferenceCount -= 1;

            OldVpb->DeviceObject = NULL;
            ClearFlag( Vcb->Vpb->Flags, VPB_MOUNTED );
            ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );

            //
            //  Clear the Vpb flag so we know not to delete it.
            //

            Vcb->Vpb = NULL;

            IoReleaseVpbSpinLock( SavedIrql );
            UdfUnlockVcb( IrpContext, Vcb );
            UdfDeleteVcb( IrpContext, Vcb );
            VcbPresent = FALSE;
        }

    //
    //  Someone has already swapped in a new Vpb.  If this is the final reference
    //  then the file system is responsible for deleting the Vpb.
    //

    } else if (FinalReference) {

        //
        //  Make sure to remove the last reference on the Vpb.
        //

        OldVpb->ReferenceCount -= 1;

        IoReleaseVpbSpinLock( SavedIrql );
        UdfUnlockVcb( IrpContext, Vcb );
        UdfDeleteVcb( IrpContext, Vcb );
        VcbPresent = FALSE;

    //
    //  The current Vpb is no longer the Vpb for the device (the IO system
    //  has already allocated a new one).  We leave our reference in the
    //  Vpb and will be responsible for deleting it at a later time.
    //

    } else {

        IoReleaseVpbSpinLock( SavedIrql );
        UdfUnlockVcb( IrpContext, Vcb );
    }

    //
    //  Let our caller know whether the Vcb is still present.
    //

    return VcbPresent;
}


BOOLEAN
UdfMarkDevForVerifyIfVcbMounted(
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks to see if the specified Vcb is currently mounted on
    the device or not.  If it is,  it sets the verify flag on the device, if
    not then the state is noted in the Vcb.

Arguments:

    Vcb - This is the volume to check.

Return Value:

    TRUE if the device has been marked for verify here,  FALSE otherwise.

--*/
{
    BOOLEAN Marked = FALSE;
    KIRQL SavedIrql;

    IoAcquireVpbSpinLock( &SavedIrql );
    
    if (Vcb->Vpb->RealDevice->Vpb == Vcb->Vpb)  {

        UdfMarkRealDevForVerify( Vcb->Vpb->RealDevice);
        Marked = TRUE;
    }
    else {

        //
        //  Flag this to avoid the VPB spinlock in future passes.
        //
        
        SetFlag( Vcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE);
    }
    
    IoReleaseVpbSpinLock( SavedIrql );

    return Marked;
}


VOID
UdfVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks that the current Vcb is valid and currently mounted
    on the device.  It will raise on an error condition.

    We check whether the volume needs verification and the current state
    of the Vcb.

Arguments:

    Vcb - This is the volume to verify.

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK Iosb;
    ULONG MediaChangeCount = 0;
    BOOLEAN ForceVerify = FALSE;
    BOOLEAN DevMarkedForVerify;
    KIRQL SavedIrql;

    PAGED_CODE();

    DebugTrace((0, Dbg, "UdfVerifyVcb %x (condition %d)\n", IrpContext->MajorFunction, 
                Vcb->VcbCondition));

    //
    //  Fail immediately if the volume is in the progress of being dismounted
    //  or has been marked invalid.
    //

    if ((Vcb->VcbCondition == VcbInvalid) ||
        ((Vcb->VcbCondition == VcbDismountInProgress) && 
         (IrpContext->MajorFunction != IRP_MJ_CREATE))) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_INVALID );
    }

    if (FlagOn( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA ))  {
        
        //
        //  Capture the real device verify state.
        //
        
        DevMarkedForVerify = UdfRealDevNeedsVerify( Vcb->Vpb->RealDevice);
        
        //
        //  If the verify volume flag in the device object is not set then we 
        //  want to ping the device to see if it needs to be verified.
        //

        if (Vcb->VcbCondition != VcbMountInProgress) {

            Status = UdfPerformDevIoCtrl( IrpContext,
                                          ( Vcb->Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                                            IOCTL_CDROM_CHECK_VERIFY :
                                            IOCTL_DISK_CHECK_VERIFY ),
                                          Vcb->TargetDeviceObject,
                                          NULL,
                                          0,
                                          &MediaChangeCount,
                                          sizeof(ULONG),
                                          FALSE,
                                          FALSE,
                                          &Iosb );

            if (Iosb.Information != sizeof(ULONG)) {
        
                //
                //  Be safe about the count in case the driver didn't fill it in
                //
        
                MediaChangeCount = 0;
            }

            //
            //  There are four cases when we want to do a verify.  These are the
            //  first three.
            //
            //  1. We are mounted,  and the device has become empty
            //  2. The device has returned verify required (=> DO_VERIFY_VOL flag is
            //     set, but could be due to hardware condition)
            //  3. Media change count doesn't match the one in the Vcb
            //

            if (((Vcb->VcbCondition == VcbMounted) &&
                  UdfIsRawDevice( IrpContext, Status ))
                ||
                (Status == STATUS_VERIFY_REQUIRED) 
                ||
                (NT_SUCCESS(Status) &&
                 (Vcb->MediaChangeCount != MediaChangeCount))) {

                //
                //  If we are currently the volume on the device then it is our
                //  responsibility to set the verify flag.  If we're not on the device,
                //  then we shouldn't touch the flag.   
                //

                if (!FlagOn( Vcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE) &&
                    !DevMarkedForVerify)  {

                    DevMarkedForVerify = UdfMarkDevForVerifyIfVcbMounted( Vcb);
                }

                ForceVerify = TRUE;

                DebugTrace((0, Dbg, "Force verify due to dev state.  CV %x Vcb->Mc %d Device->Mc %d\n", 
                            Status, Vcb->MediaChangeCount, MediaChangeCount));
                //
                //  Note that we no longer update the media change count here. We
                //  do so only when we've actually completed a verify at a 
                //  particular change count value.
                //
            }
        }

        //
        //  This is the 4th verify case.
        //
        //  We ALWAYS force CREATE requests on unmounted volumes through the 
        //  verify path.  These requests could have been in limbo between
        //  IoCheckMountedVpb and us when a verify/mount took place and caused
        //  a completely different fs/volume to be mounted.  In this case the
        //  checks above may not have caught the condition,  since we may already
        //  have verified (wrong volume) and decided that we have nothing to do.
        //  We want the requests to be re routed to the currently mounted volume,
        //  since they were directed at the 'drive',  not our volume.
        //

        if (NT_SUCCESS( Status) && !ForceVerify && 
            (IrpContext->MajorFunction == IRP_MJ_CREATE)) {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->Irp);

            ForceVerify = (IrpSp->FileObject->RelatedFileObject == NULL) &&
                          ((Vcb->VcbCondition == VcbDismountInProgress) ||
                           (Vcb->VcbCondition == VcbNotMounted));

            //
            //  Note that we don't touch the device verify flag here.  It required
            //  it would have been caught and set by the first set of checks.
            //
            
            if (ForceVerify)  {
                
                DebugTrace((0, Dbg, "Forcing verify on Create request\n"));                 
            }
        }

        //
        //  Raise any verify / error if neccessary.
        //
        
        if (ForceVerify || !NT_SUCCESS( Status)) {

            DebugTrace((0, Dbg, "Raising verify / status %x\n", Status));

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp,
                                          Vcb->Vpb->RealDevice );

            UdfRaiseStatus( IrpContext, ForceVerify ? STATUS_VERIFY_REQUIRED : Status);
        }
    }

    //
    //  Based on the condition of the Vcb we'll either return to our
    //  caller or raise an error condition
    //
    
    switch (Vcb->VcbCondition) {

    case VcbNotMounted:

        DebugTrace(( 0, Dbg, "Raising WRONG VOLUME\n"));
        
        IoSetHardErrorOrVerifyDevice( IrpContext->Irp, Vcb->Vpb->RealDevice );
        
        UdfRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );
        break;

    case VcbInvalid:
    case VcbDismountInProgress :

        UdfRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        break;
    }
}


BOOLEAN
UdfVerifyFcbOperation (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to verify that the state of the Fcb is valid
    to allow the current operation to continue.  We use the state of the
    Vcb, target device and type of operation to determine this.

Arguments:

    IrpContext - IrpContext for the request.  If not present then we
        were called from the fast IO path.

    Fcb - Fcb to perform the request on.

Return Value:

    BOOLEAN - TRUE if the request can continue, FALSE otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVCB Vcb = Fcb->Vcb;
    PDEVICE_OBJECT RealDevice = Vcb->Vpb->RealDevice;
    PIRP Irp;

    PAGED_CODE();
    
    //
    //  Check that the fileobject has not been cleaned up.
    //
    
    if ( ARGUMENT_PRESENT( IrpContext ))  {

        PFILE_OBJECT FileObject;

        Irp = IrpContext->Irp;
        FileObject = IoGetCurrentIrpStackLocation( Irp)->FileObject;
        
        if ( FileObject && FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE))  {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Following FAT,  we allow certain operations even on cleaned up
            //  file objects.  Everything else,  we fail.
            //
            
            if ( (FlagOn(Irp->Flags, IRP_PAGING_IO)) ||
                 (IrpSp->MajorFunction == IRP_MJ_CLOSE ) ||
                 (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
                 ( (IrpSp->MajorFunction == IRP_MJ_READ) &&
                   FlagOn(IrpSp->MinorFunction, IRP_MN_COMPLETE) ) ) {

                NOTHING;

            } else {

                UdfRaiseStatus( IrpContext, STATUS_FILE_CLOSED );
            }
        }
    }

    //
    //  Fail immediately if the volume is in the progress of being dismounted
    //  or has been marked invalid.
    //

    if ((Vcb->VcbCondition == VcbInvalid) ||
        (Vcb->VcbCondition == VcbDismountInProgress)) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            UdfRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        }

        return FALSE;
    }

    //
    //  Always fail if the volume needs to be verified.
    //

    if (UdfRealDevNeedsVerify( RealDevice)) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp,
                                          RealDevice );

            UdfRaiseStatus( IrpContext, STATUS_VERIFY_REQUIRED );
        }

        return FALSE;

    //
    //  All operations are allowed on mounted volumes.
    //

    } else if ((Vcb->VcbCondition == VcbMounted) ||
               (Vcb->VcbCondition == VcbMountInProgress)) {

        return TRUE;

    //
    //  Fail all requests for fast Io on other Vcb conditions.
    //

    } else if (!ARGUMENT_PRESENT( IrpContext )) {

        return FALSE;

    //
    //  The remaining case is VcbNotMounted - raise WRONG_VOLUME.
    //

    } else if (Vcb->VcbCondition == VcbNotMounted) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp, RealDevice );
            UdfRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );
        }

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\udfprocs.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    UdfProcs.h

Abstract:

    This module defines all of the globally used procedures in the Udfs
    file system.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	29-May-1996
    
Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support
    
// @@END_DDKSPLIT

--*/

#ifndef _UDFPROCS_
#define _UDFPROCS_

#include <ntifs.h>

#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <ntdddisk.h>

#ifndef INLINE
#define INLINE __inline
#endif

#include "nodetype.h"
#include "Udf.h"
#include "UdfStruc.h"
#include "UdfData.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_STRUCSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_STRUCSUP)


//
//  Miscellaneous support routines/macros
//

//
//  Yet another declaration of Min/Max
//

#ifndef Min
#define Min(a, b)   ((a) < (b) ? (a) : (b))
#endif

#ifndef Max
#define Max(a, b)   ((a) > (b) ? (a) : (b))
#endif

//
//  Yet another declaration of the basic bit fiddlers
//

#ifndef FlagMask
#define FlagMask(F,SF) (                \
    ((F) & (SF))                        \
)
#endif

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (           \
//    (BOOLEAN)(FlagOn(F, SF) != 0)       \
//)
//#endif

#ifndef BooleanFlagOff
#define BooleanFlagOff(F,SF) (          \
    (BOOLEAN)(FlagOn(F, SF)) == 0)      \
)
#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) (     \
//    (Flags) |= (SingleFlag)             \
//)
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) (   \
//    (Flags) &= ~(SingleFlag)            \
//)
//#endif

//
//      CAST
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          IN (CAST)
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define Add2Ptr(PTR,INC,CAST) ((CAST)((ULONG_PTR)(PTR) + (INC)))

#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG)(OFFSET) - (ULONG)(BASE)))

//
//  Generic truncation/align/offset/remainder macros for power-of-two units.
//
//  The offset and remainder functions range from zero to (unit - 1).  The
//  re-offset in the remainder performs this work.
//

#define GenericTruncate(B, U) (                                             \
    (B) & ~((U) - 1)                                                        \
)

#define GenericAlign(B, U) (                                                \
    GenericTruncate((B) + (U) - 1, U)                                       \
)

#define GenericOffset(B, U) (                                               \
    (B) & ((U) - 1)                                                         \
)

#define GenericRemainder(B, U) (                                            \
    GenericOffset( (U) - GenericOffset((B), (U)), (U) )                     \
)


#define GenericTruncatePtr(B, U) (                                          \
    (PVOID)(((ULONG_PTR)(B)) & ~((U) - 1))                                  \
)

#define GenericAlignPtr(B, U) (                                             \
    GenericTruncatePtr((B) + (U) - 1, (U))                                  \
)

#define GenericOffsetPtr(B, U) (                                            \
    (ULONG)(((ULONG_PTR)(B)) & ((U) - 1))                                   \
)

#define GenericRemainderPtr(B, U) (                                         \
    (ULONG)GenericOffset( (U) - GenericOffsetPtr((B), (U)), (U) )           \
)

//
//  Useful compositions of the defaults for common types.
//

#define WordAlign(B) GenericAlign((B), 2)

#define LongAlign(B) GenericAlign((B), 4)

#define QuadAlign(B) GenericAlign((B), 8)


#define WordOffset(B) GenericOffset((B), 2)

#define LongOffset(B) GenericOffset((B), 4)

#define QuadOffset(B) GenericOffset((B), 8)


#define WordAlignPtr(P) GenericAlignPtr((P), 2)

#define LongAlignPtr(P) GenericAlignPtr((P), 4)

#define QuadAlignPtr(P) GenericAlignPtr((P), 8)


#define WordOffsetPtr(P) GenericOffsetPtr((P), 2)

#define LongOffsetPtr(P) GenericOffsetPtr((P), 4)

#define QuadOffsetPtr(P) GenericOffsetPtr((P), 8)


//
//  Macros to round up and down on sector and logical block boundaries.  Although
//  UDF 1.01 specifies that a physical sector is the logical block size we will
//  be general and treat sectors and logical blocks as distinct.  Since UDF may
//  at some point relax the restriction, these definitions will be the only
//  acknowledgement outside of the mount path (which merely checks the volume's
//  conformance).
//

//
//  Sector
//

#define SectorAlignN(SECTORSIZE, L) (                                           \
    ((((ULONG)(L)) + ((SECTORSIZE) - 1)) & ~((SECTORSIZE) - 1))                 \
)

#define SectorAlign(V, L) (                                                     \
    ((((ULONG)(L)) + (((V)->SectorSize) - 1)) & ~(((V)->SectorSize) - 1))       \
)

#define LlSectorAlign(V, L) (                                                   \
    ((((LONGLONG)(L)) + (((V)->SectorSize) - 1)) & ~(((LONGLONG)(V)->SectorSize) - 1)) \
)

#define SectorTruncate(V, L) (                                                  \
    ((ULONG)(L)) & ~(((V)->SectorSize) - 1)                                     \
)

#define LlSectorTruncate(V, L) (                                                \
    ((LONGLONG)(L)) & ~(((LONGLONG)(V)->SectorSize) - 1)                        \
)

#define BytesFromSectors(V, L) (                                                \
    ((ULONG) (L)) << ((V)->SectorShift)                                         \
)

#define SectorsFromBytes(V, L) (                                                \
    ((ULONG) (L)) >> ((V)->SectorShift)                                         \
)

#define LlBytesFromSectors(V, L) (                                              \
    Int64ShllMod32( (ULONGLONG)(L), ((V)->SectorShift) )                        \
)

#define LlSectorsFromBytes(V, L) (                                              \
    Int64ShrlMod32( (ULONGLONG)(L), ((V)->SectorShift) )                        \
)

#define SectorsFromBlocks(V, B) (B)

#define SectorSize(V) ((V)->SectorSize)

#define SectorOffset(V, L) (                                                    \
    ((ULONG) (L)) & (((V)->SectorSize) - 1)                                     \
)

//
//  Logical Block
//

#define BlockAlignN(BLOCKSIZE, L) (                                             \
    SectorAlighN((BLOCKSIZE), (L))                                              \
)

#define BlockAlign(V, L) (                                                      \
    SectorAlign((V), (L))                                                       \
)

#define LlBlockAlign(V, L) (                                                    \
    LlSectorAlign((V), (L))                                                     \
)

#define BlockTruncate(V, L) (                                                   \
    SectorTruncate((V), (L))                                                    \
)

#define LlBlockTruncate(V, L) (                                                 \
    LlSectorTruncate((V), (L))                                                  \
)

#define BytesFromBlocks(V, L) (                                                 \
    BytesFromSectors((V), (L))                                                  \
)

#define BlocksFromBytes(V, L) (                                                 \
    SectorsFromBytes((V), (L))                                                  \
)

#define LlBytesFromBlocks(V, L) (                                               \
    LlBytesFromSectors((V), (L))                                                \
)

#define LlBlocksFromBytes(V, L) (                                               \
    LlSectorsFromBytes((V), (L))                                                \
)

#define BlocksFromSectors(V, S) (S)

#define BlockSize(V) (SectorSize(V))

#define BlockOffset(V, L) (                                                     \
    SectorOffset((V), (L))                                                      \
)

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in various structures.
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

typedef union _USHORT2 {
    USHORT Ushort[2];
    ULONG  ForceAlignment;
} USHORT2, *PUSHORT2;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                           \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src));  \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                           \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src));  \
    }
    
//
//  This macro copies an unaligned src word to a dst word,
//  performing an little/big endian swap.
//

#define SwapCopyUchar2(Dst,Src) {                                       \
    *((UNALIGNED UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src) + 1);    \
    *((UNALIGNED UCHAR1 *)(Dst) + 1) = *((UNALIGNED UCHAR1 *)(Src));    \
}

//
//  This macro copies an unaligned src longword to an aligned dst longword
//

#define CopyUchar4(Dst,Src) {                           \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src));  \
    }

//
//  This macro copies an unaligned src longword to a dst longword,
//  performing an little/big endian swap.
//

#define SwapCopyUchar4(Dst,Src) {                                        \
    *((UNALIGNED UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src) + 3);     \
    *((UNALIGNED UCHAR1 *)(Dst) + 1) = *((UNALIGNED UCHAR1 *)(Src) + 2); \
    *((UNALIGNED UCHAR1 *)(Dst) + 2) = *((UNALIGNED UCHAR1 *)(Src) + 1); \
    *((UNALIGNED UCHAR1 *)(Dst) + 3) = *((UNALIGNED UCHAR1 *)(Src));     \
}

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//  accessing the source on a word boundary.
//

#define CopyUshort2(Dst,Src) {                          \
    *((USHORT2 *)(Dst)) = *((UNALIGNED USHORT2 *)(Src));\
    }

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(I)   IoIsOperationSynchronous(I)

//
//  The following macro is used to set the fast i/o possible bits in the
//  FsRtl header.
//
//      FastIoIsNotPossible - If the Fcb is bad or there are oplocks on the file.
//
//      FastIoIsQuestionable - If there are file locks.
//
//      FastIoIsPossible - In all other cases.
//
//

#define UdfIsFastIoPossible(F) ((BOOLEAN)                                           \
    ((((F)->Vcb->VcbCondition != VcbMounted ) ||                                    \
      !FsRtlOplockIsFastIoPossible( &(F)->Oplock )) ?                               \
                                                                                    \
     FastIoIsNotPossible :                                                          \
                                                                                    \
     ((((F)->FileLock != NULL) && FsRtlAreThereCurrentFileLocks( (F)->FileLock )) ? \
                                                                                    \
        FastIoIsQuestionable :                                                      \
                                                                                    \
        FastIoIsPossible))                                                          \
)

//
//  The following macros encapsulate the common work of raising exceptions while storing
//  the exception in the IrpContext.
//

INLINE
DECLSPEC_NORETURN
VOID
UdfRaiseStatus (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status
    )
{
    IrpContext->ExceptionStatus = Status;
    DebugBreakOnStatus( Status );
    ExRaiseStatus( Status );
}

INLINE
VOID
UdfNormalizeAndRaiseStatus (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status
    )
{
    IrpContext->ExceptionStatus = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR );
    ExRaiseStatus( IrpContext->ExceptionStatus );
}

//
//  The following is a convenience macro to execute a little code before making
//  a shortcircuit out of a surrounding try-finally clause.  This is usually to
//  set a status value.
//
//  Note that our compilers support the leave keyword now and we don't have to
//  use the old try_exit: labels and goto.
//

#define try_leave(S) { S; leave; }

//
//  For debugging purposes we sometimes want to allocate our structures from nonpaged
//  pool so that in the kernel debugger we can walk all the structures.
//

#define UdfPagedPool                 PagedPool
#define UdfNonPagedPool              NonPagedPool
#define UdfNonPagedPoolCacheAligned  NonPagedPoolCacheAligned

//
//  Encapsulate safe pool freeing
//

INLINE
VOID
UdfFreePool(
    IN PVOID *Pool
    )
{
    if (*Pool != NULL) {

        ExFreePool(*Pool);
        *Pool = NULL;
    }
}

//
//  Encapsulate counted string compares with uncounted fields.  Thanks to a
//  very smart compiler, we have to carefully tell it that no matter what it
//  thinks, it *cannot* do anything other than a bytewise compare.
//

INLINE
BOOLEAN
UdfEqualCountedString(
    IN PSTRING String,
    IN PCHAR Field
    )
{
    return (RtlEqualMemory( (CHAR UNALIGNED *)String->Buffer,
                            (CHAR UNALIGNED *)Field,
                            String->Length )                    != 0);
}


//
//  Type of opens.  FilObSup.c depends on this order.
//

typedef enum _TYPE_OF_OPEN {

    UnopenedFileObject = 0,
    StreamFileOpen,
    UserVolumeOpen,
    UserDirectoryOpen,
    UserFileOpen,
    BeyondValidType

} TYPE_OF_OPEN, *PTYPE_OF_OPEN;


//
//  Following routines handle entry in and out of the filesystem.  They are
//  contained in UdfData.c.  We also get some very generic utility functions
//  here that aren't associated with any particular datastructure.
//

NTSTATUS
UdfFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

LONG
UdfExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

LONG
UdfQueryDirExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    );

NTSTATUS
UdfProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

VOID
UdfCompleteRequest (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    );

//
//  Following are the routines to handle the top level thread logic.
//

VOID
UdfSetThreadContext (
    IN PIRP_CONTEXT IrpContext,
    IN PTHREAD_CONTEXT ThreadContext
    );

INLINE
VOID
UdfRestoreThreadContext (
     IN PIRP_CONTEXT IrpContext
     )
{
    IrpContext->ThreadContext->Udfs = 0;
    IoSetTopLevelIrp( IrpContext->ThreadContext->SavedTopLevelIrp );
    IrpContext->ThreadContext = NULL;
}

//
//  Following are some generic utility functions we have to carry along for the ride
//

INLINE
BOOLEAN
UdfDeviceIsFsDo(
    IN PDEVICE_OBJECT Device
    )
{
#if (NUMBER_OF_FS_OBJECTS != 2)
#error "Size of fsdo array changed - fixme!"
#endif

    return (Device == UdfData.FileSystemDeviceObjects[0]) || 
           (Device == UdfData.FileSystemDeviceObjects[1]);
}


ULONG
UdfSerial32 (
    IN PCHAR Buffer,
    IN ULONG ByteCount
    );

VOID
UdfInitializeCrc16 (
    ULONG Polynomial
    );

USHORT
UdfComputeCrc16 (
	IN PUCHAR Buffer,
	IN ULONG ByteCount
    );

USHORT
UdfComputeCrc16Uni (
    PWCHAR Buffer,
    ULONG CharCount
    );

ULONG
UdfHighBit (
    ULONG Word
    );

//
//  Following are the fast entry points.
//

BOOLEAN
UdfFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastQueryNetworkInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UdfFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );


//
//  File access check routine, implemented in AcChkSup.c
//

INLINE
BOOLEAN
UdfIllegalFcbAccess (
    IN PIRP_CONTEXT IrpContext,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine simply asserts that the access is legal for a readonly filesystem.
    
Arguments:

    TypeOfOpen - type of open for the Fcb in question.
    
    DesiredAccess - mask of access the caller is trying for.

Return Value:

    BOOLEAN True if illegal access, false otherwise.

--*/

{
    return BooleanFlagOn( DesiredAccess,
                          (TypeOfOpen != UserVolumeOpen ?
                           (FILE_WRITE_ATTRIBUTES           |
                            FILE_WRITE_DATA                 |
                            FILE_WRITE_EA                   |
                            FILE_ADD_FILE                   |                     
                            FILE_ADD_SUBDIRECTORY           |
                            FILE_APPEND_DATA) : 0)          |
                          FILE_DELETE_CHILD                 |
                          DELETE                            |
                          WRITE_DAC );
}


//
//  Sector lookup routines, implemented in AllocSup.c
//

BOOLEAN
UdfLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN LONGLONG FileOffset,
    OUT PLONGLONG DiskOffset,
    OUT PULONG ByteCount
    );

VOID
UdfDeletePcb (
    IN PPCB Pcb
    );

NTSTATUS
UdfInitializePcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PPCB *Pcb,
    IN PNSR_LVOL LVD
    );

VOID
UdfAddToPcb (
    IN PPCB Pcb,
    IN PNSR_PART PartitionDescriptor
);

NTSTATUS
UdfCompletePcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PPCB Pcb );

BOOLEAN
UdfEquivalentPcb (
    IN PIRP_CONTEXT IrpContext,
    IN PPCB Pcb1,
    IN PPCB Pcb2
    );

ULONG
UdfLookupPsnOfExtent (
    IN PIRP_CONTEXT IrpContext,    
    IN PVCB Vcb,
    IN USHORT Reference,
    IN ULONG Lbn,
    IN ULONG Len
    );

ULONG
UdfLookupMetaVsnOfExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT Reference,
    IN ULONG Lbn,
    IN ULONG Len,
    IN BOOLEAN ExactEnd
    );


//
//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

VOID
UdfCreateInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    );

VOID
UdfDeleteInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );


NTSTATUS
UdfCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

typedef enum {
    METAMAPOP_INIT_VIEW_ONLY = 0,
    METAMAPOP_REMAP_VIEW,
    METAMAPOP_INIT_AND_MAP
} MAPMETAOP;

VOID
UdfMapMetadataView (
    IN PIRP_CONTEXT IrpContext,
    IN PMAPPED_PVIEW View,
    IN PVCB Vcb,
    IN USHORT Partition,
    IN ULONG Lbn,
    IN ULONG Length,
    IN MAPMETAOP Operation
    );

NTSTATUS
UdfPurgeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DismountUnderway
    );

//  VOID
//  UdfUnpinView (
//      IN PIRP_CONTEXT IrpContext,
//      IN PMAPPED_VIEW View
//      );
//
//
//  Also releases the Vcb->VmcbMappingResource if the view was actually CcMapped.

#define UdfUnpinView(IC,V)                                                          \
            if (((V)->Bcb) != NULL)  {                                              \
                CcUnpinData( ((V)->Bcb) );                                          \
                UdfReleaseVmcb( (IC), (IC)->Vcb);                                   \
                ((V)->Bcb) = NULL;                                                  \
                ((V)->View) = NULL;                                                 \
                ((V)->Vsn) = UDF_INVALID_VSN;                                       \
            }

//  VOID
//  UdfUnpinData (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PBCB *Bcb
//      );
//

#define UdfUnpinData(IC,B)   \
    if (*(B) != NULL) { CcUnpinData( *(B) ); *(B) = NULL; }


//
//  Device I/O routines, implemented in DevIoSup.c
//
//  These routines perform the actual device reads and other communcation.
//  They do not affect any data structures.
//

NTSTATUS
UdfPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    );

NTSTATUS
UdfReadSectors (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN BOOLEAN ReturnError,
    IN OUT PVOID Buffer,
    IN PDEVICE_OBJECT TargetDeviceObject
    );

NTSTATUS
UdfNonCachedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    );

NTSTATUS
UdfCreateUserMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BufferLength,
    IN BOOLEAN RaiseOnError,
    IN ULONG Operation
    );

VOID
UdfWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

VOID
UdfSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    );

//
//  VOID
//  UdfMapUserBuffer (
//      IN PIRP_CONTEXT IrpContext,
//      OUT PVOID Buffer
//      );
//
//  Will raise on failure.
//
//  VOID
//  UdfLockUserBuffer (
//      IN PIRP_CONTEXT IrpContext,
//      IN ULONG BufferLength
//      );
//

#define UdfMapUserBuffer(IC,UB) {                                                   \
            *(UB) = ((PVOID) (((IC)->Irp->MdlAddress == NULL) ?                     \
                             (IC)->Irp->UserBuffer :                                \
                             MmGetSystemAddressForMdlSafe( (IC)->Irp->MdlAddress, NormalPagePriority )));   \
            if (NULL == *(UB))  {                                                    \
                UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES);         \
            }                                                                       \
        }
        
#define UdfLockUserBuffer(IC,BL,OP) {                       \
    if ((IC)->Irp->MdlAddress == NULL) {                    \
        (VOID) UdfCreateUserMdl( (IC), (BL), TRUE, (OP) );  \
    }                                                       \
}

//
//  Udf*RawBufferSize and Udf*RawReadSize calculate how big a buffer must be
//  to do a direct read of a given sector aligned structure (UdfReadSectors)
//  and how much data the read must recover.  Reads must write into whole-page
//  sized buffers and be in whole-sector units.
//
//  Note that although all descriptors are constrained to fit in one logical
//  block, it is not always going to be neccesary to read the entire logical
//  block to get the descriptor.  The underlying restriction is the physical
//  sector.
//

INLINE
ULONG
UdfRawBufferSize (
    IN PVCB Vcb,
    IN ULONG StructureSize
    )
{
    return (ULONG)ROUND_TO_PAGES( SectorAlign( Vcb, StructureSize ));
}

INLINE
ULONG
UdfRawReadSize (
    IN PVCB Vcb,
    IN ULONG StructureSize
    )
{
    return SectorAlign( Vcb, StructureSize );
}

INLINE
ULONG
UdfRawBufferSizeN (
    IN ULONG SectorSize,
    IN ULONG StructureSize
    )
{
    return (ULONG)ROUND_TO_PAGES( SectorAlignN( SectorSize, StructureSize ));
}

INLINE
ULONG
UdfRawReadSizeN (
    IN ULONG SectorSize,
    IN ULONG StructureSize
    )
{
    return SectorAlignN( SectorSize, StructureSize );
}


//
//  The following routines are used to read on-disk directory structures, implemented
//  in DirSup.c
//

VOID
UdfInitializeDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext
    );

VOID
UdfCleanupDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext
    );

BOOLEAN
UdfLookupInitialDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN PLONGLONG InitialOffset OPTIONAL
    );

BOOLEAN
UdfLookupNextDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext
    );

VOID
UdfUpdateDirNames (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
UdfFindDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortName,
    IN PDIR_ENUM_CONTEXT DirContext
    );


//
//  The following routines are used to manipulate the fscontext fields
//  of the file object, implemented in FilObSup.c
//

VOID
UdfSetFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PFCB Fcb OPTIONAL,
    IN PCCB Ccb OPTIONAL
    );

TYPE_OF_OPEN
UdfDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PCCB *Ccb
    );

TYPE_OF_OPEN
UdfFastDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb
    );


//
//  FSCTL request support routines. Contained in FsCtrl.c
//

VOID
UdfStoreVolumeDescriptorIfPrevailing (
    IN OUT PNSR_VD_GENERIC *StoredVD,
    IN OUT PNSR_VD_GENERIC NewVD
    );


//
//  Name mangling routines.  Implemented in Namesup.c
//

VOID
UdfDissectName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PUNICODE_STRING FinalName
    );

BOOLEAN
UdfIs8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING FileName
    );

BOOLEAN
UdfCandidateShortName (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name
    );

VOID
UdfGenerate8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING FileName,
    OUT PUNICODE_STRING ShortFileName
    );

VOID
UdfConvertCS0DstringToUnicode (
    IN PIRP_CONTEXT IrpContext,
    IN PUCHAR Dstring,
    IN UCHAR Length OPTIONAL,
    IN UCHAR FieldLength OPTIONAL,
    IN OUT PUNICODE_STRING Name
    );

BOOLEAN
UdfCheckLegalCS0Dstring (
    PIRP_CONTEXT IrpContext,
    PUCHAR Dstring,
    UCHAR Length OPTIONAL,
    UCHAR FieldLength OPTIONAL,
    BOOLEAN ReturnOnError
    );

VOID
UdfRenderNameToLegalUnicode (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING RenderedName
    );

BOOLEAN
UdfIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING CurrentName,
    IN PUNICODE_STRING SearchExpression,
    IN BOOLEAN Wild
    );

FSRTL_COMPARISON_RESULT
UdfFullCompareNames (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    );

INLINE
VOID
UdfUpcaseName (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name,
    IN OUT PUNICODE_STRING UpcaseName
    )

/*++

Routine Description:

    This routine upcases a name with an assertion of success.
    
Arguments:

    Name - an name to upcase
    
    Length - a place to put the upcased name (can be the same as Name)
    
Return Value:

    None.
    
--*/

{
    NTSTATUS Status;

    //
    //  Upcase the string using the correct upcase routine.
    //

    Status = RtlUpcaseUnicodeString( UpcaseName,
                                     Name,
                                     FALSE );

    //
    //  This should never fail.
    //

    ASSERT( Status == STATUS_SUCCESS );

    return;
}

INLINE
USHORT
UdfCS0DstringUnicodeSize (
    PIRP_CONTEXT IrpContext,
    PCHAR Dstring,
    UCHAR Length
    )

/*++

Routine Description:

    This routine computes the number of bytes required for the UNICODE representation
    of a CS0 Dstring (1/7.2.12)
    
Arguments:

    Dstring - a dstring
    
    Length - length of the dstring
    
Return Value:

    ULONG number of bytes.
    
--*/

{
    return (16 / *Dstring) * (Length - 1);
}

INLINE
BOOLEAN
UdfIsCharacterLegal (
    IN WCHAR Character
    )

/*++

Routine Description:

    This routine checks that a given UNICODE character is legal.
    
Arguments:

    Character - a character to check
    
Return Value:

    BOOLEAN True if a legal character, False otherwise.
    
--*/

{
    if (Character < 0xff && !FsRtlIsAnsiCharacterLegalHpfs( Character, FALSE )) {

        return FALSE;
    }

    return TRUE;
}


INLINE
BOOLEAN
UdfCS0DstringIsLegalFileName(
    IN PCHAR Dstring,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine inspects a CS0 dstring for illegal characters,  and illegal
    trailing characters.  The assumption is made that the string is legal CS0.
    
Arguments:

    Name - a name to check
    
Return Value:

    BOOLEAN True if legal characters are found, False otherwise.
    
--*/

{
    ULONG Step;
    WCHAR Char;
    PCHAR Bound = Dstring + Length;
 
    //
    //  Determine how big a step we take in the string according to the
    //  "compression" applied.
    //
    
    if (*Dstring == 16) {

        Step = sizeof( WCHAR );
    
    } else {

        Step = sizeof( CHAR );
    }

    //
    //  Advance past the compression marker and loop over the string.
    //
    
    for (Dstring++; Dstring < Bound; Dstring += Step) {

        if ( sizeof(WCHAR) == Step)  {
        
            //
            //  Perform the endianess swapcopy to convert from UDF bigendian CS0 to our
            //  little endian wide characters.
            //
            
            SwapCopyUchar2( &Char, Dstring );  
        }
        else {
        
            Char = *Dstring;
        }

        if (!UdfIsCharacterLegal( Char )) {

            DebugTrace(( 0, Dbg, "UdfCS0DstringIsLegalFileName, Char %04x @ %08x\n", (WCHAR) Char, Dstring ));

            return FALSE;
        }
    }

    //
    //  Now check for illegal trailing characters (' ' or '.')  We know that Char
    //  will be the last character in the string.
    //

    if ((PERIOD == Char) || (SPACE == Char))  {
    
        DebugTrace(( 0, Dbg, "UdfCS0DstringIsLegalFileName, has trailing space or period\n"));
        
        return FALSE;
    }

    return TRUE;
}


//
//  Filesystem control operations.  Implemented in Fsctrl.c
//

NTSTATUS
UdfLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

NTSTATUS
UdfUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );


//
//  Routines to handle the prefix trees attached to directories, used to quickly travel common
//  bits of the hierarchy.  Implemented in PrefxSup.c
//

PLCB
UdfFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *CurrentFcb,
    IN OUT PUNICODE_STRING RemainingName,
    IN BOOLEAN IgnoreCase
    );

VOID            
UdfInitializeLcbFromDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PDIR_ENUM_CONTEXT DirContext
    );

PLCB
UdfInsertPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING Name,
    IN BOOLEAN ShortNameMatch,
    IN BOOLEAN IgnoreCase,
    IN PFCB ParentFcb
    );

VOID
UdfRemovePrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb
    );


//
//  Synchronization routines.  Implemented in Resrcsup.c
//
//  The following routines/macros are used to synchronize the in-memory structures.
//
//      Routine/Macro               Synchronizes                            Subsequent
//
//      UdfAcquireUdfData           Volume Mounts/Dismounts,Vcb Queue       UdfReleaseUdfData
//      UdfAcquireVcbExclusive      Vcb for open/close                      UdfReleaseVcb
//      UdfAcquireVcbShared         Vcb for open/close                      UdfReleaseVcb
//      UdfAcquireAllFiles          Locks out operations to all files       UdfReleaseAllFiles
//      UdfAcquireFileExclusive     Locks out file operations               UdfReleaseFile
//      UdfAcquireFileShared        Files for file operations               UdfReleaseFile
//      UdfAcquireFcbExclusive      Fcb for open/close                      UdfReleaseFcb
//      UdfAcquireFcbShared         Fcb for open/close                      UdfReleaseFcb
//      UdfLockUdfData              Fields in UdfData                       UdfUnlockUdfData
//      UdfLockVcb                  Vcb fields, FcbReference, FcbTable      UdfUnlockVcb
//      UdfLockFcb                  Fcb fields, prefix table, Mcb           UdfUnlockFcb
//

typedef enum _TYPE_OF_ACQUIRE {
    
    AcquireExclusive,
    AcquireShared,
    AcquireSharedStarveExclusive

} TYPE_OF_ACQUIRE, *PTYPE_OF_ACQUIRE;

BOOLEAN
UdfAcquireResource (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE Resource,
    IN BOOLEAN IgnoreWait,
    IN TYPE_OF_ACQUIRE Type
    );

//
//  BOOLEAN
//  UdfAcquireUdfData (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfReleaseUdfData (
//      IN PIRP_CONTEXT IrpContext
//    );
//
//  BOOLEAN
//  UdfAcquireVcbExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  UdfAcquireVcbShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  VOID
//  UdfReleaseVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  UdfAcquireAllFiles (
//      IN PIRP_CONTEXT,
//      IN PVCB Vcb
//      );
//
//  VOID
//  UdfReleaseAllFiles (
//      IN PIRP_CONTEXT,
//      IN PVCB Vcb
//      );
//
//  VOID
//  UdfAcquireFileExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      );
//
//  VOID
//  UdfAcquireFileShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfReleaseFile (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//    );
//
//  BOOLEAN
//  UdfAcquireFcbExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  UdfAcquireFcbShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  UdfReleaseFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfLockUdfData (
//      );
//
//  VOID
//  UdfUnlockUdfData (
//      );
//
//  VOID
//  UdfLockVcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfUnlockVcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfLockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfUnlockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define UdfAcquireUdfData(IC)                                                           \
    ExAcquireResourceExclusiveLite( &UdfData.DataResource, TRUE )

#define UdfReleaseUdfData(IC)                                                           \
    ExReleaseResourceLite( &UdfData.DataResource )

#define UdfAcquireVcbExclusive(IC,V,I)                                                  \
    UdfAcquireResource( (IC), &(V)->VcbResource, (I), AcquireExclusive )

#define UdfAcquireVcbShared(IC,V,I)                                                     \
    UdfAcquireResource( (IC), &(V)->VcbResource, (I), AcquireShared )

#define UdfReleaseVcb(IC,V)                                                             \
    ExReleaseResourceLite( &(V)->VcbResource )

#define UdfAcquireAllFiles(IC,V)                                                        \
    UdfAcquireResource( (IC), &(V)->FileResource, FALSE, AcquireExclusive )

#define UdfReleaseAllFiles(IC,V)                                                        \
    ExReleaseResourceLite( &(V)->FileResource )

#define UdfAcquireFileExclusive(IC,F)                                                   \
    UdfAcquireResource( (IC), (F)->Resource, FALSE, AcquireExclusive )

#define UdfAcquireFileShared(IC,F)                                                      \
    UdfAcquireResource( (IC), (F)->Resource, FALSE, AcquireShared )

#define UdfAcquireFileSharedStarveExclusive(IC,F)                                       \
    UdfAcquireResource( (IC), (F)->Resource, FALSE, AcquireSharedStarveExclusive )

#define UdfReleaseFile(IC,F)                                                            \
    ExReleaseResourceLite( (F)->Resource )

#define UdfAcquireVmcbForCcMap(IC,V)                                                   \
        UdfAcquireResource( (IC), &(V)->VmcbMappingResource, FALSE, AcquireShared)
    
#define UdfAcquireVmcbForCcPurge(IC,V)                                                 \
        UdfAcquireResource( (IC), &(V)->VmcbMappingResource, FALSE, AcquireExclusive)

#define UdfReleaseVmcb( IC, V)                                                         \
        ExReleaseResourceLite( &(V)->VmcbMappingResource)

#define UdfAcquireFcbExclusive(IC,F,I)                                                  \
    UdfAcquireResource( (IC), &(F)->FcbNonpaged->FcbResource, (I), AcquireExclusive )

#define UdfAcquireFcbShared(IC,F,I)                                                     \
    UdfAcquireResource( (IC), &(F)->FcbNonpaged->FcbResource, (I), AcquireShared )

#define UdfReleaseFcb(IC,F)                                                             \
    ExReleaseResourceLite( &(F)->FcbNonpaged->FcbResource )

#define UdfLockUdfData()                                                                \
    ExAcquireFastMutex( &UdfData.UdfDataMutex );                                        \
    UdfData.UdfDataLockThread = PsGetCurrentThread()

#define UdfUnlockUdfData()                                                              \
    UdfData.UdfDataLockThread = NULL;                                                   \
    ExReleaseFastMutex( &UdfData.UdfDataMutex )

#define UdfLockVcb(IC,V)                                                                \
    ASSERT(KeAreApcsDisabled());                                                        \
    ExAcquireFastMutexUnsafe( &(V)->VcbMutex );                                         \
    (V)->VcbLockThread = PsGetCurrentThread()

#define UdfUnlockVcb(IC,V)                                                              \
    (V)->VcbLockThread = NULL;                                                          \
    ExReleaseFastMutexUnsafe( &(V)->VcbMutex )

#define UdfLockFcb(IC,F) {                                                              \
    PVOID _CurrentThread = PsGetCurrentThread();                                        \
    if (_CurrentThread != (F)->FcbLockThread) {                                         \
        ASSERT(KeAreApcsDisabled());                                                    \
        ExAcquireFastMutexUnsafe( &(F)->FcbNonpaged->FcbMutex );                        \
        ASSERT( (F)->FcbLockCount == 0 );                                               \
        (F)->FcbLockThread = _CurrentThread;                                            \
    }                                                                                   \
    (F)->FcbLockCount += 1;                                                             \
}

#define UdfUnlockFcb(IC,F) {                                                            \
    ASSERT( PsGetCurrentThread() == (F)->FcbLockThread);                                \
    (F)->FcbLockCount -= 1;                                                             \
    if ((F)->FcbLockCount == 0) {                                                       \
        (F)->FcbLockThread = NULL;                                                      \
        ExReleaseFastMutexUnsafe( &(F)->FcbNonpaged->FcbMutex );                              \
    }                                                                                   \
}

BOOLEAN
UdfNoopAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
UdfNoopRelease (
    IN PVOID Fcb
    );

BOOLEAN
UdfAcquireForCache (
    IN PFCB Fcb,
    IN BOOLEAN Wait
    );

VOID
UdfReleaseFromCache (
    IN PFCB Fcb
    );

VOID
UdfAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
UdfReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    );


//
//  Structure support routines, implemented in StrucSup.c
//
//  These routines perform in-memory structure manipulations. They do *not* operate
//  on disk structures.
//

//
//  Encapsulate manipulation of the Vcb condition for tracing purposes.
//

#ifndef UDF_SANITY

#define UdfSetVcbCondition( V, C)       (V)->VcbCondition = (C)
#define UdfSetMediaChangeCount( V, C)   (V)->MediaChangeCount = (C)

#else

#define UdfSetVcbCondition( V, C)  { \
            DebugTrace(( 0, UDFS_DEBUG_LEVEL_VERFYSUP, "VcbCondition %p transitioning %d -> %d (%s : %d)\n", \
                         (V), (V)->VcbCondition, (C), __FILE__, __LINE__));                                  \
            (V)->VcbCondition = (C);                                                                         \
        }

#define UdfSetMediaChangeCount( V, C) { \
            DebugTrace(( 0, UDFS_DEBUG_LEVEL_VERFYSUP, "Vcb MCT %p transitioning %d -> %d (%s : %d)\n", \
                         (V), (V)->MediaChangeCount, (C), __FILE__, __LINE__));                         \
            (V)->MediaChangeCount = (C);                                                                \
        }
#endif

BOOLEAN
UdfInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDISK_GEOMETRY DiskGeometry,
    IN ULONG MediaChangeCount
    );

VOID
UdfUpdateVcbPhase0 (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    );

VOID
UdfUpdateVcbPhase1 (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PNSR_FSD Fsd
    );

VOID
UdfDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    );

PIRP_CONTEXT
UdfCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

VOID
UdfCleanupIrpContext (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Post
    );

VOID
UdfInitializeStackIrpContext (
    OUT PIRP_CONTEXT IrpContext,
    IN PIRP_CONTEXT_LITE IrpContextLite
    );

//
//  PIRP_CONTEXT_LITE
//  UdfCreateIrpContextLite (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  UdfFreeIrpContextLite (
//      IN PIRP_CONTEXT_LITE IrpContextLite
//      );
//

#define UdfCreateIrpContextLite(IC)  \
    ExAllocatePoolWithTag( UdfNonPagedPool, sizeof( IRP_CONTEXT_LITE ), TAG_IRP_CONTEXT_LITE )

#define UdfFreeIrpContextLite(ICL)  \
    ExFreePool( ICL )

//
//  PUDF_IO_CONTEXT
//  UdfAllocateIoContext (
//      );
//
//  VOID
//  UdfFreeIoContext (
//      PUDF_IO_CONTEXT IoContext
//      );
//

#define UdfAllocateIoContext()                           \
    FsRtlAllocatePoolWithTag( UdfNonPagedPool,           \
                              sizeof( UDF_IO_CONTEXT ),  \
                              TAG_IO_CONTEXT )

#define UdfFreeIoContext(IO)     ExFreePool( IO )

//
//  VOID
//  UdfIncrementCleanupCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfDecrementCleanupCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfIncrementReferenceCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ULONG ReferenceCount
//      IN ULONG UserReferenceCount
//      );
//
//  VOID
//  UdfDecrementReferenceCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ULONG ReferenceCount
//      IN ULONG UserReferenceCount
//      );
//
//  VOID
//  UdfIncrementFcbReference (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  UdfDecrementFcbReference (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define UdfIncrementCleanupCounts(IC,F) {        \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbCleanup += 1;                       \
    (F)->Vcb->VcbCleanup += 1;                  \
}

#define UdfDecrementCleanupCounts(IC,F) {        \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbCleanup -= 1;                       \
    (F)->Vcb->VcbCleanup -= 1;                  \
}

#define UdfIncrementReferenceCounts(IC,F,C,UC) { \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbReference += (C);                   \
    (F)->FcbUserReference += (UC);              \
    (F)->Vcb->VcbReference += (C);              \
    (F)->Vcb->VcbUserReference += (UC);         \
}

#define UdfDecrementReferenceCounts(IC,F,C,UC) { \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbReference -= (C);                   \
    (F)->FcbUserReference -= (UC);              \
    (F)->Vcb->VcbReference -= (C);              \
    (F)->Vcb->VcbUserReference -= (UC);         \
}

VOID
UdfTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB StartingFcb,
    IN BOOLEAN Recursive,
    OUT PBOOLEAN RemovedStartingFcb
    );

PFCB
UdfLookupFcbTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_ID FileId
    );

PFCB
UdfGetNextFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID *RestartKey
    );

PFCB
UdfCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_ID FileId,
    IN NODE_TYPE_CODE NodeTypeCode,
    OUT PBOOLEAN FcbExisted OPTIONAL
    );

VOID
UdfDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
UdfInitializeFcbFromIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PFCB ParentFcb OPTIONAL
    );

PCCB
UdfCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLCB Lcb OPTIONAL,
    IN ULONG Flags
    );

VOID
UdfDeleteCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    );

ULONG
UdfFindInParseTable (
    IN PPARSE_KEYVALUE ParseTable,
    IN PCHAR Id,
    IN ULONG MaxIdLen
    );

BOOLEAN
UdfVerifyDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PDESTAG Descriptor,
    IN USHORT Tag,
    IN ULONG Size,
    IN ULONG Lbn,
    IN BOOLEAN ReturnError
    );

VOID
UdfInitializeIcbContextFromFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PFCB Fcb
    );

VOID
UdfInitializeIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PVCB Vcb,
    IN USHORT IcbType,
    IN USHORT Partition,
    IN ULONG Lbn,
    IN ULONG Length
    );

INLINE
VOID
UdfFastInitializeIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext
    )
{

    RtlZeroMemory( IcbContext, sizeof( ICB_SEARCH_CONTEXT ));
}

VOID
UdfLookupActiveIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN ULONG IcbExtentLength
    );


VOID
UdfCleanupIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext
    );

VOID
UdfInitializeAllocations (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN BOOLEAN AllowOneGigWorkaround
    );

VOID
UdfUpdateTimestampsFromIcbContext (
    IN PIRP_CONTEXT IrpContext,
    IN PICB_SEARCH_CONTEXT IcbContext,
    IN PTIMESTAMP_BUNDLE Timestamps
    );

BOOLEAN
UdfCreateFileLock (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN BOOLEAN RaiseOnError
    );

//
//  The following macro converts from UDF time to NT time.
//

INLINE
VOID
UdfConvertUdfTimeToNtTime (
    IN PIRP_CONTEXT IrpContext,
    IN PTIMESTAMP UdfTime,
    OUT PLARGE_INTEGER NtTime
    )
{
    TIME_FIELDS TimeField;
    
    TimeField.Year = UdfTime->Year;
    TimeField.Month = UdfTime->Month;
    TimeField.Day = UdfTime->Day;
    TimeField.Hour = UdfTime->Hour;
    TimeField.Minute = UdfTime->Minute;
    TimeField.Second = UdfTime->Second;
    
    //
    //  This is where it gets hairy.  For some unholy reason, ISO 13346 timestamps
    //  carve the right of the decimal point up into three fields of precision
    //  10-2, 10-4, and 10-6, each ranging from 0-99. Lawdy.
    //
    //  To make it easier, since they cannot cause a wrap into the next second,
    //  just save it all up and add it in after the conversion.
    //
    
    TimeField.Milliseconds = 0; 
    
    if (UdfTime->Type <= 1 &&
        ((UdfTime->Zone >= TIMESTAMP_Z_MIN && UdfTime->Zone <= TIMESTAMP_Z_MAX) ||
         UdfTime->Zone == TIMESTAMP_Z_NONE) &&
        RtlTimeFieldsToTime( &TimeField, NtTime )) {

        //
        //  Now fold in the remaining sub-second "precision".  Read as coversions
        //  through the 10-3 units, then into our 10-7 base. (centi->milli->micro,
        //  etc).
        //
    
        NtTime->QuadPart += ((UdfTime->CentiSecond * (10 * 1000)) +
                             (UdfTime->Usec100 * 100) +
                             UdfTime->Usec) * 10;

        //
        //  Perform TZ normalization if this is a local time with
        //  specified timezone.
        //

        if (UdfTime->Type == 1 && UdfTime->Zone != TIMESTAMP_Z_NONE) {
            
            NtTime->QuadPart += Int32x32To64( -UdfTime->Zone, (60 * 10 * 1000 * 1000) );
        }
    
    } else {

        //
        //  Epoch.  Malformed timestamp.
        //

        NtTime->QuadPart = 0;
    }
}

//
//  An equivalence test for Entity IDs.
//

INLINE
BOOLEAN
UdfEqualEntityId (
    IN PREGID RegID,
    IN PSTRING Id,
    IN OPTIONAL PSTRING Suffix
    )
{

    return (UdfEqualCountedString( Id, RegID->Identifier ) &&

#ifndef UDF_SUPPORT_NONSTANDARD_ENTITY_STRINGTERM
            
            //
            //  Allow disabling of the check that the identifier
            //  seems to be padded with zero.
            //
            //  Reason: a couple samples that are otherwise useful
            //      padded some identifiers with junk.
            //

            ((Id->Length == sizeof(RegID->Identifier) ||
              RegID->Identifier[Id->Length] == '\0') ||
             
             !DebugTrace(( 0, Dbg,
                           "UdfEqualEntityId, RegID seems to be terminated with junk!\n" ))) &&
#endif

            ((Suffix == NULL) || UdfEqualCountedString( Suffix, RegID->Suffix )));
}

BOOLEAN
UdfDomainIdentifierContained (
    IN PREGID RegID,
    IN PSTRING Domain,
    IN USHORT RevisionMin,
    IN USHORT RevisionMax
    );

//
//  In like fashion, we define containment for a UDF Identifier RegID.
//

INLINE
BOOLEAN
UdfUdfIdentifierContained (
    IN PREGID RegID,
    IN PSTRING Type,
    IN USHORT RevisionMin,
    IN USHORT RevisionMax,
    IN UCHAR OSClass,
    IN UCHAR OSIdentifier
    )
{
    PUDF_SUFFIX_UDF UdfSuffix = (PUDF_SUFFIX_UDF) RegID->Suffix;

    return ((UdfSuffix->UdfRevision <= RevisionMax && UdfSuffix->UdfRevision >= RevisionMin) &&
            (OSClass == OSCLASS_INVALID || UdfSuffix->OSClass == OSClass) &&
            (OSIdentifier == OSIDENTIFIER_INVALID || UdfSuffix->OSIdentifier == OSIdentifier) &&
            UdfEqualEntityId( RegID, Type, NULL ));
}


//
//  Verification support routines.  Contained in verfysup.c
//

BOOLEAN
UdfCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN Force
    );

BOOLEAN
UdfDismountVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
UdfVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
UdfVerifyFcbOperation (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    );

//
//  BOOLEAN
//  UdfIsRawDevice (
//      IN PIRP_CONTEXT IrpContext,
//      IN NTSTATUS Status
//      );
//

#define UdfIsRawDevice(IC,S) (           \
    ((S) == STATUS_DEVICE_NOT_READY) ||  \
    ((S) == STATUS_NO_MEDIA_IN_DEVICE)   \
)


//
//  Volume Mapped Control Blocks routines, implemented in VmcbSup.c
//

VOID
UdfInitializeVmcb (
    IN PVMCB Vmcb,
    IN POOL_TYPE PoolType,
    IN ULONG MaximumLbn,
    IN ULONG LbSize
    );

VOID
UdfUninitializeVmcb (
    IN PVMCB Vmcb
    );

VOID
UdfResetVmcb (
    IN PVMCB Vmcb
    );

VOID
UdfSetMaximumLbnVmcb (
    IN PVMCB Vmcb,
    IN ULONG MaximumLbn
    );

BOOLEAN
UdfVmcbVbnToLbn (
    IN PVMCB Vmcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL
    );

BOOLEAN
UdfVmcbLbnToVbn (
    IN PVMCB Vmcb,
    IN LBN Lbn,
    OUT PVBN Vbn,
    OUT PULONG SectorCount OPTIONAL
    );

BOOLEAN
UdfAddVmcbMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVMCB Vmcb,
    IN LBN Lbn,
    IN ULONG SectorCount,
    IN BOOLEAN ExactEnd,
    OUT PVBN Vbn,
    OUT PULONG AlignedSectorCount
    );

VOID
UdfRemoveVmcbMapping (
    IN PVMCB Vmcb,
    IN LBN Lbn,
    IN ULONG SectorCount
    );


//
//  Routines to verify the correspondance of the underlying media, implemented in
//  verfysup.c
//

NTSTATUS
UdfPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceToVerify
    );

//
//  Some macros for hiding/tracing the device object verify flag.
//

#ifndef UDF_SANITY

#define UdfMarkRealDevForVerify( DO)  SetFlag( (DO)->Flags, DO_VERIFY_VOLUME)
#define UdfMarkRealDevVerifyOk( DO)   ClearFlag( (DO)->Flags, DO_VERIFY_VOLUME)
 
#else

#define UdfMarkRealDevForVerify( DO)  {                                                 \
            DebugTrace((0,UDFS_DEBUG_LEVEL_VERFYSUP,"Mark for verify %p (at %s %d)\n",  \
                        (DO), __FILE__, __LINE__));                                     \
            SetFlag( (DO)->Flags, DO_VERIFY_VOLUME);                                    \
        }

#define UdfMarkRealDevVerifyOk( DO)   {                                                 \
            DebugTrace((0,UDFS_DEBUG_LEVEL_VERFYSUP,"Clear verify %p (at %s %d)\n",     \
                        (DO), __FILE__, __LINE__));                                     \
            ClearFlag( (DO)->Flags, DO_VERIFY_VOLUME);                                  \
        }
#endif

#define UdfRealDevNeedsVerify( DO)   BooleanFlagOn( (DO)->Flags, DO_VERIFY_VOLUME)

//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

NTSTATUS
UdfFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
UdfPrePostIrp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
UdfOplockComplete (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  Charspecs are small containers that specify a CS<N> type and a text
//  string specifying a version, etc.  This is a convenient way of bottling
//  up equivalence checks of a charspec.
//

INLINE
BOOLEAN
UdfEqualCharspec (
    IN PCHARSPEC Charspec,
    IN PSTRING Identifier,
    IN UCHAR Type
    )
{
    return ((Charspec->Type == Type) && UdfEqualCountedString( Identifier, Charspec->Info));
}


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
UdfFspDispatch (                            //  implemented in FspDisp.c
    IN PIRP_CONTEXT IrpContext
    );

VOID
UdfFspClose (                               //  Implemented in Close.c
    IN PVCB Vcb OPTIONAL
    );

//
//  The following routines are the entry points for the different operations
//  based on the IrpSp major functions.
//

NTSTATUS
UdfCommonCleanup (                          //  Implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfCommonClose (                            //  Implemented in Close.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfCommonCreate (                           //  Implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in DevCtrl.c
UdfCommonDevControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in DirCtrl.c
UdfCommonDirControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfCommonFsControl (                        //  Implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in LockCtrl.c
UdfCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in Pnp.c
UdfCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in FileInfo.c
UdfCommonQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in VolInfo.c
UdfCommonQueryVolInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in Read.c
UdfCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );
    
NTSTATUS
UdfCommonWrite (
    IN PIRP_CONTEXT IrpContext,             //  write.c
    IN PIRP Irp
    );

NTSTATUS                                    //  Implemented in FileInfo.c
UdfCommonSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfHijackIrpAndFlushDevice (                // flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetDeviceObject
    );


//  BOOLEAN
//  UdfExtendedFEAllowed(
//      PVCB Vcb
//  )
//
//  Decides,  based on the NSR revision encountered on the volume,  whether or not the 
//  extended FE is legal and expected on this volume

#define UdfExtendedFEAllowed( V)    (VsdIdentNSR03 == (V)->NsrVersion)


//  BOOLEAN
//  UdfMinLegalVATSize(
//      PVCB Vcb
//  )
//
//  Decides based on the NSR revision encountered on the volume

#define UdfMinLegalVATSize( V)  ((VsdIdentNSR03 == (V)->NsrVersion) ? UDF_CDUDF_MINIMUM_20x_VAT_SIZE : UDF_CDUDF_MINIMUM_150_VAT_SIZE)


//  BOOLEAN
//  UdfVATIcbFileTypeExpected(
//      PVCB Vcb
//  )
//
//  Decides, based on the NSR revision encountered on the volume, what value we
//  expect the FileType field in the VAT Icb to have

#define UdfVATIcbFileTypeExpected( V)  ((VsdIdentNSR03 == (V)->NsrVersion) ? ICBTAG_FILE_T_VAT : ICBTAG_FILE_T_NOTSPEC)


//  BOOLEAN
//  UdfVATHasHeaderRecord(
//      PVCB Vcb
//  )
//
//  Decides, based on the NSR revision encountered on the volume, if the VAT should have
//  the header (2.00) record,  or the 1.5 style trailing regid.

#define UdfVATHasHeaderRecord( V)   (VsdIdentNSR03 == (V)->NsrVersion)


//
//  Clean up our internal-to-the-header definitions so they do not leak out.
//

#undef BugCheckFileId
#undef Dbg


#endif // _UDFPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\workque.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    WorkQue.c

Abstract:

    This module implements the Work queue routines for the Udfs File
    system.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Sep-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_WORKQUE)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_WORKQUE)

//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (2)

//
//  Local support routines
//

VOID
UdfAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfFsdPostRequest)
#pragma alloc_text(PAGE, UdfOplockComplete)
#pragma alloc_text(PAGE, UdfPrePostIrp)
#endif


NTSTATUS
UdfFsdPostRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enqueues the request packet specified by IrpContext to the
    work queue associated with the FileSystemDeviceObject.  This is a FSD
    routine.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp.

    Irp - I/O Request Packet.

Return Value:

    STATUS_PENDING

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Posting is a three step operation.  First lock down any buffers
    //  in the Irp.  Next cleanup the IrpContext for the post and finally
    //  add this to a workque.
    //

    UdfPrePostIrp( IrpContext, Irp );

    UdfAddToWorkque( IrpContext, Irp );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}


VOID
UdfPrePostIrp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Case on the type of the operation.
    //

    switch (IrpContext->MajorFunction) {

    case IRP_MJ_CREATE :

        //
        //  If called from the oplock package then there is an
        //  Fcb to possibly teardown.  We will call the teardown
        //  routine and release the Fcb if still present.  The cleanup
        //  code in create will know not to release this Fcb because
        //  we will clear the pointer.
        //

        if ((IrpContext->TeardownFcb != NULL) &&
            *(IrpContext->TeardownFcb) != NULL) {

            UdfTeardownStructures( IrpContext, *(IrpContext->TeardownFcb), FALSE, &RemovedFcb );

            if (!RemovedFcb) {

                UdfReleaseFcb( IrpContext, *(IrpContext->TeardownFcb) );
            }

            *(IrpContext->TeardownFcb) = NULL;
            IrpContext->TeardownFcb = NULL;
        }

        break;

    //
    //  We need to lock the user's buffer, unless this is an MDL-read,
    //  in which case there is no user buffer.
    //

    case IRP_MJ_READ :

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            UdfLockUserBuffer( IrpContext, IrpSp->Parameters.Read.Length, IoWriteAccess );
        }

        break;
        
    case IRP_MJ_WRITE :

        UdfLockUserBuffer( IrpContext, IrpSp->Parameters.Write.Length, IoReadAccess );
        break;

    //
    //  We also need to check whether this is a query file operation.
    //
    
    case IRP_MJ_DIRECTORY_CONTROL :

        if (IrpContext->MinorFunction == IRP_MN_QUERY_DIRECTORY) {

            UdfLockUserBuffer( IrpContext, IrpSp->Parameters.QueryDirectory.Length, IoWriteAccess );
        }

        break;
    }
    //
    //  Cleanup the IrpContext for the post.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
    UdfCleanupIrpContext( IrpContext, TRUE );

    //
    //  Mark the Irp to show that we've already returned pending to the user.
    //

    IoMarkIrpPending( Irp );

    return;
}


VOID
UdfOplockComplete (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the oplock package when an oplock break has
    completed, allowing an Irp to resume execution.  If the status in
    the Irp is STATUS_SUCCESS, then we queue the Irp to the Fsp queue.
    Otherwise we complete the Irp with the status in the Irp.

    If we are completing due to an error then check if there is any
    cleanup to do.

Arguments:

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    //
    //  Check on the return value in the Irp.  If success then we
    //  are to post this request.
    //

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        //
        //  Check if there is any cleanup work to do.
        //

        switch (IrpContext->MajorFunction) {

        case IRP_MJ_CREATE :

            //
            //  If called from the oplock package then there is an
            //  Fcb to possibly teardown.  We will call the teardown
            //  routine and release the Fcb if still present.  The cleanup
            //  code in create will know not to release this Fcb because
            //  we will clear the pointer.
            //

            if (IrpContext->TeardownFcb != NULL) {

                UdfTeardownStructures( IrpContext, *(IrpContext->TeardownFcb), FALSE, &RemovedFcb );

                if (!RemovedFcb) {

                    UdfReleaseFcb( IrpContext, *(IrpContext->TeardownFcb) );
                }

                *(IrpContext->TeardownFcb) = NULL;
                IrpContext->TeardownFcb = NULL;
            }

            break;
        }
        //
        //  Insert the Irp context in the workqueue.
        //

        UdfAddToWorkque( IrpContext, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        UdfCompleteRequest( IrpContext, Irp, Irp->IoStatus.Status );
    }

    return;
}


//
//  Local support routine
//

VOID
UdfAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PVOLUME_DEVICE_OBJECT Vdo;
    KIRQL SavedIrql;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Check if this request has an associated file object, and thus volume
    //  device object.
    //

    if (IrpSp->FileObject != NULL) {


        Vdo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                 VOLUME_DEVICE_OBJECT,
                                 DeviceObject );

        //
        //  Check to see if this request should be sent to the overflow
        //  queue.  If not, then send it off to an exworker thread.
        //

        KeAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );

        if (Vdo->PostedRequestCount > FSP_PER_DEVICE_THRESHOLD) {

            //
            //  We cannot currently respond to this IRP so we'll just enqueue it
            //  to the overflow queue on the volume.
            //

            InsertTailList( &Vdo->OverflowQueue,
                            &IrpContext->WorkQueueItem.List );

            Vdo->OverflowQueueCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

            return;

        } else {

            //
            //  We are going to send this Irp to an ex worker thread so up
            //  the count.
            //

            Vdo->PostedRequestCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );
        }
    }

    //
    //  Send it off.....
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          UdfFspDispatch,
                          IrpContext );

    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\write.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for Write called by the
    Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Tom Jolly       [tomjolly]  8-Aug-2000

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_WRITE)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_WRITE)



NTSTATUS
UdfCommonWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;
    
    BOOLEAN Wait;
    BOOLEAN PagingIo;
    BOOLEAN SynchronousIo;
    BOOLEAN WriteToEof;

    LONGLONG StartingOffset;
    LONGLONG ByteCount;

    NTSTATUS Status = STATUS_SUCCESS;

    UDF_IO_CONTEXT LocalIoContext;

    //
    // Get current Irp stack location and file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    DebugTrace((+1, Dbg, "UdfCommonWrite\n"));
    DebugTrace(( 0, Dbg, "Irp                 = %8lx\n", Irp));
    DebugTrace(( 0, Dbg, "ByteCount           = %8lx\n", IrpSp->Parameters.Write.Length));
    DebugTrace(( 0, Dbg, "ByteOffset.LowPart  = %8lx\n", IrpSp->Parameters.Write.ByteOffset.LowPart));
    DebugTrace(( 0, Dbg, "ByteOffset.HighPart = %8lx\n", IrpSp->Parameters.Write.ByteOffset.HighPart));
    
    //
    //  Extract the nature of the write from the file object, and case on it
    //

    TypeOfOpen = UdfDecodeFileObject( FileObject, &Fcb, &Ccb);

    //
    //  We only support write to the volume file
    //

    if (TypeOfOpen != UserVolumeOpen) {

        Irp->IoStatus.Information = 0;
        UdfCompleteRequest( IrpContext, Irp, STATUS_NOT_IMPLEMENTED );
        return STATUS_NOT_IMPLEMENTED;    
    }

    ASSERT( Fcb == IrpContext->Vcb->VolumeDasdFcb);
    
    //
    // Initialize the appropriate local variables.
    //

    Wait          = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    PagingIo      = BooleanFlagOn(Irp->Flags, IRP_PAGING_IO);
    SynchronousIo = BooleanFlagOn(FileObject->Flags, FO_SYNCHRONOUS_IO);

    //
    //  Extract the bytecount and starting offset
    //

    ByteCount = IrpSp->Parameters.Write.Length;
    StartingOffset = IrpSp->Parameters.Write.ByteOffset.QuadPart;
    WriteToEof = (StartingOffset == -1);

    Irp->IoStatus.Information = 0;

    //
    //  If there is nothing to write, return immediately
    //

    if (ByteCount == 0) {
    
        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Watch for overflow
    //
    
    if ((MAXLONGLONG - StartingOffset) < ByteCount)  {
    
        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Not sure what we're synchronising against,  but....
    //
    
    UdfAcquireFileShared( IrpContext, Fcb );

    try {
    
        //
        //  Verify the Fcb.  Allow writes if this handle is dismounting
        //  the volume.
        //

        if ((NULL == Ccb) || !FlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE))  {
        
            UdfVerifyFcbOperation( IrpContext, Fcb );
        }

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO )) {

            //
            //  Clamp to volume size
            //

            if ( StartingOffset >= Fcb->FileSize.QuadPart) {
            
                try_leave( NOTHING);
            }
            
            if ( ByteCount > (Fcb->FileSize.QuadPart - StartingOffset))  {
            
                ByteCount = Fcb->FileSize.QuadPart - StartingOffset;
                
                if (0 == ByteCount)  {
                
                    try_leave( NOTHING);
                }
            }
        }
        else {
        
            //
            //  This has a peculiar interpretation, but just adjust the starting
            //  byte to the end of the visible volume.
            //

            if (WriteToEof)  {
            
                StartingOffset = Fcb->FileSize.QuadPart;
            }
        }

        //
        //  Initialize the IoContext for the write.
        //  If there is a context pointer, we need to make sure it was
        //  allocated and not a stale stack pointer.
        //

        if (IrpContext->IoContext == NULL ||
            !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

            //
            //  If we can wait, use the context on the stack.  Otherwise
            //  we need to allocate one.
            //

            if (Wait) {

                IrpContext->IoContext = &LocalIoContext;
                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

            } else {

                IrpContext->IoContext = UdfAllocateIoContext();
                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
            }
        }

        RtlZeroMemory( IrpContext->IoContext, sizeof( UDF_IO_CONTEXT ));

        //
        //  Store whether we allocated this context structure in the structure
        //  itself.
        //

        IrpContext->IoContext->AllocatedContext =
            BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

        if (Wait) {

            KeInitializeEvent( &IrpContext->IoContext->SyncEvent,
                               NotificationEvent,
                               FALSE );

        } else {

            IrpContext->IoContext->ResourceThreadId = ExGetCurrentResourceThread();
            IrpContext->IoContext->Resource = Fcb->Resource;
            IrpContext->IoContext->RequestedByteCount = (ULONG)ByteCount;
        }

        //
        // For DASD we have to probe and lock the user's buffer
        //

        UdfLockUserBuffer( IrpContext, (ULONG)ByteCount, IoReadAccess );

        //
        //  Set the FO_MODIFIED flag here to trigger a verify when this
        //  handle is closed.  Note that we can err on the conservative
        //  side with no problem, i.e. if we accidently do an extra
        //  verify there is no problem.
        //

        SetFlag( FileObject->Flags, FO_FILE_MODIFIED );

        //
        //  Write the data and wait for the results
        //
        
        Irp->IoStatus.Information = (ULONG)ByteCount;

        UdfSingleAsync( IrpContext,
                        StartingOffset,
                        (ULONG)ByteCount);

        if (!Wait) {

            //
            //  We, nor anybody else, need the IrpContext any more.
            //

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO);

            UdfCleanupIrpContext( IrpContext, TRUE);

            DebugTrace((-1, Dbg, "UdfCommonWrite -> STATUS_PENDING\n"));
            
            try_leave( Status = STATUS_PENDING);
        }

        UdfWaitSync( IrpContext );

        //
        //  If the call didn't succeed, raise the error status
        //

        Status = Irp->IoStatus.Status;
        
        if (!NT_SUCCESS( Status)) {

            UdfNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  Update the current file position.  We assume that
        //  open/create zeros out the CurrentByteOffset field.
        //

        if (SynchronousIo && !PagingIo) {
            FileObject->CurrentByteOffset.QuadPart =
                StartingOffset + Irp->IoStatus.Information;
        }
    }
    finally {

        UdfReleaseFile( IrpContext, Fcb);
        
        DebugTrace((-1, Dbg, "UdfCommonWrite -> %08lx\n", Status ));
    }

    if (STATUS_PENDING != Status)  {

        UdfCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\vmcbsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VmcbSup.c

Abstract:

    Historical note: this package was originally written for HPFS (pinball)
    and is now resurrected for UDFS.  Since UDFS is readonly in initial
    versions we will snip by #ifdef the write support, leaving it visible
    for the future - this code has not been changed (nearly) whatsoever and
    is left named as Pb (pinball) code.

    The VMCB routines provide support for maintaining a mapping between
    LBNs and VBNs for a virtual volume file.  The volume file is all
    of the sectors that make up the on-disk structures.  A file system
    uses this package to map LBNs for on-disk structure to VBNs in a volume
    file.  This when used in conjunction with Memory Management and the
    Cache Manager will treat the volume file as a simple mapped file.  A
    variable of type VMCB is used to store the mapping information and one
    is needed for every mounted volume.

    The main idea behind this package is to allow the user to dynamically
    read in new disk structure sectors (e.g., File Entries).  The user assigns
    the new sector a VBN in the Volume file and has memory management fault
    the page containing the sector into memory.  To do this Memory management
    will call back into the file system to read the page from the volume file
    passing in the appropriate VBN.  Now the file system takes the VBN and
    maps it back to its LBN and does the read.

    The granularity of mapping is one a per page basis.  That is if
    a mapping for LBN 8 is added to the VMCB structure and the page size
    is 8 sectors then the VMCB routines will actually assign a mapping for
    LBNS 8 through 15, and they will be assigned to a page aligned set of
    VBNS.  This function is needed to allow us to work efficiently with
    memory management.  This means that some sectors in some pages might
    actually contain regular file data and not volume information, and so
    when writing the page out we must only write the sectors that are really
    in use by the volume file.  To help with this we provide a set
    of routines to keep track of dirty volume file sectors.
    That way, when the file system is called to write a page to the volume
    file, it will only write the sectors that are dirty.

    Concurrent access the VMCB structure is control by this package.

    The functions provided in this package are as follows:

      o  UdfInitializeVmcb - Initialize a new VMCB structure.

      o  UdfUninitializeVmcb - Uninitialize an existing VMCB structure.

      o  UdfSetMaximumLbnVmcb - Sets/Resets the maximum allowed LBN
         for the specified VMCB structure.

      o  UdfAddVmcbMapping - This routine takes an LBN and assigns to it
         a VBN.  If the LBN already was assigned to an VBN it simply returns
         the old VBN and does not do a new assignemnt.

      o  UdfRemoveVmcbMapping - This routine takes an LBN and removes its
         mapping from the VMCB structure.

      o  UdfVmcbVbnToLbn - This routine takes a VBN and returns the
         LBN it maps to.

      o  UdfVmcbLbnToVbn - This routine takes an LBN and returns the
         VBN its maps to.

Authors:

    Gary Kimura     [GaryKi]    4-Apr-1990
    Dan Lovinger    [DanLo]     10-Sep-1996

Revision History:

    Tom Jolly       [tomjolly]  21-Jan-2000     CcPurge and extend at end of stream
    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_VMCBSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_VMCBSUP)

//
//  The following macro is used to calculate the number of pages (in terms of
//  sectors) needed to contain a given sector count.  For example (assuming 
//  1kb sector size,  8kb page size)
//
//      PadSectorCountToPage( 0 Sectors ) = 0 Pages = 0 Sectors
//      PadSectorCountToPage( 1 Sectors ) = 1 Page  = 8 Sectors
//      PadSectorCountToPage( 2 Sectors ) = 1 Page  = 8 Sectors
//      PadSectorCountToPage( 8 ..      ) = 2 Pages = 16 sectors
//
//  Evaluates to the number of 
//

#define PadSectorCountToPage(V, L) ( ( ((L)+((PAGE_SIZE/(V)->SectorSize)-1)) / (PAGE_SIZE/(V)->SectorSize) ) * (PAGE_SIZE/(V)->SectorSize) )

//
//  Evaluates to first page aligned LBN <= Supplied LBN
//

#define AlignToPageBase( V, L) ((L) & ~((PAGE_SIZE / (V)->SectorSize)-1))

//
//  Evaluates to TRUE if the LBN is page aligned,  FALSE otherwise
//

#define IsPageAligned( V, L)   (0 == ((L) & ((PAGE_SIZE / (V)->SectorSize)-1)) )

//
//  Macros for VMCB synchronisation
//

#define VmcbLockForRead( V)  (VOID)ExAcquireResourceSharedLite( &((V)->Resource), TRUE )

#define VmcbLockForModify( V)  (VOID)ExAcquireResourceExclusiveLite( &((V)->Resource), TRUE )

#define VmcbRelease( V)  ExReleaseResourceLite( &((V)->Resource))

//
//  Local Routines.
//

BOOLEAN
UdfVmcbLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfAddVmcbMapping)
#pragma alloc_text(PAGE, UdfInitializeVmcb)
#pragma alloc_text(PAGE, UdfRemoveVmcbMapping)
#pragma alloc_text(PAGE, UdfResetVmcb)
#pragma alloc_text(PAGE, UdfSetMaximumLbnVmcb)
#pragma alloc_text(PAGE, UdfUninitializeVmcb)
#pragma alloc_text(PAGE, UdfVmcbLbnToVbn)
#pragma alloc_text(PAGE, UdfVmcbLookupMcbEntry)
#pragma alloc_text(PAGE, UdfVmcbVbnToLbn)
#endif


VOID
UdfInitializeVmcb (
    IN PVMCB Vmcb,
    IN POOL_TYPE PoolType,
    IN ULONG MaximumLbn,
    IN ULONG SectorSize
    )

/*++

Routine Description:

    This routine initializes a new Vmcb Structure.  The caller must
    supply the memory for the structure.  This must precede all other calls
    that set/query the volume file mapping.

    If pool is not available this routine will raise a status value
    indicating insufficient resources.

Arguments:

    Vmcb - Supplies a pointer to the volume file structure to initialize.

    PoolType - Supplies the pool type to use when allocating additional
        internal structures.

    MaximumLbn - Supplies the maximum Lbn value that is valid for this
        volume.

    LbSize - Size of a sector on this volume

Return Value:

    None

--*/

{
    BOOLEAN VbnInitialized;
    BOOLEAN LbnInitialized;

    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfInitializeVmcb, Vmcb = %08x\n", Vmcb ));

    VbnInitialized = FALSE;
    LbnInitialized = FALSE;

    try {

        //
        //  Initialize the fields in the vmcb structure
        //
        
        FsRtlInitializeMcb( &Vmcb->VbnIndexed, PoolType );
        VbnInitialized = TRUE;

        FsRtlInitializeMcb( &Vmcb->LbnIndexed, PoolType );
        LbnInitialized = TRUE;

        Vmcb->MaximumLbn = MaximumLbn;

        Vmcb->SectorSize = SectorSize;

        Vmcb->NodeTypeCode = UDFS_NTC_VMCB;
        Vmcb->NodeByteSize = sizeof( VMCB);

        ExInitializeResourceLite( &Vmcb->Resource );

    } finally {

        //
        //  If this is an abnormal termination then check if we need to
        //  uninitialize the mcb structures
        //

        if (AbnormalTermination()) {
            
            if (VbnInitialized) { FsRtlUninitializeMcb( &Vmcb->VbnIndexed ); }
            if (LbnInitialized) { FsRtlUninitializeMcb( &Vmcb->LbnIndexed ); }
        }

        DebugUnwind("UdfInitializeVmcb");
        DebugTrace(( -1, Dbg, "UdfInitializeVmcb -> VOID\n" ));
    }
}


VOID
UdfUninitializeVmcb (
    IN PVMCB Vmcb
    )

/*++

Routine Description:

    This routine uninitializes an existing VMCB structure.  After calling
    this routine the input VMCB structure must be re-initialized before
    being used again.

Arguments:

    Vmcb - Supplies a pointer to the VMCB structure to uninitialize.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfUninitializeVmcb, Vmcb = %08x\n", Vmcb ));

    //
    //  Unitialize the fields in the Vmcb structure
    //

    FsRtlUninitializeMcb( &Vmcb->VbnIndexed );
    FsRtlUninitializeMcb( &Vmcb->LbnIndexed );

    ExDeleteResourceLite( &Vmcb->Resource);

    //
    //  And return to our caller
    //

    DebugTrace(( -1, Dbg, "UdfUninitializeVmcb -> VOID\n" ));

    return;
}


VOID
UdfResetVmcb (
    IN PVMCB Vmcb
    )

/*++

Routine Description:

    This routine resets the mappings in an existing VMCB structure.

Arguments:

    Vmcb - Supplies a pointer to the VMCB structure to reset.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfResetVmcb, Vmcb = %08x\n", Vmcb ));

    //
    //  Unitialize the fields in the Vmcb structure
    //

    FsRtlResetLargeMcb( (PLARGE_MCB) &Vmcb->VbnIndexed, TRUE );
    FsRtlResetLargeMcb( (PLARGE_MCB) &Vmcb->LbnIndexed, TRUE );

    //
    //  And return to our caller
    //

    DebugTrace(( -1, Dbg, "UdfResetVmcb -> VOID\n" ));

    return;
}


VOID
UdfSetMaximumLbnVmcb (
    IN PVMCB Vmcb,
    IN ULONG MaximumLbn
    )

/*++

Routine Description:

    This routine sets/resets the maximum allowed LBN for the specified
    Vmcb structure.  The Vmcb structure must already have been initialized
    by calling UdfInitializeVmcb.

Arguments:

    Vmcb - Supplies a pointer to the volume file structure to initialize.

    MaximumLbn - Supplies the maximum Lbn value that is valid for this
        volume.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfSetMaximumLbnVmcb, Vmcb = %08x\n", Vmcb ));

    //
    //  Set the field
    //

    Vmcb->MaximumLbn = MaximumLbn;

    //
    //  And return to our caller
    //

    DebugTrace(( -1, Dbg, "UdfSetMaximumLbnVmcb -> VOID\n" ));

    return;
}


BOOLEAN
UdfVmcbVbnToLbn (
    IN PVMCB Vmcb,
    IN VBN Vbn,
    IN PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL
    )

/*++

Routine Description:

    This routine translates a VBN to an LBN.

Arguments:

    Vmcb - Supplies the VMCB structure being queried.

    Vbn - Supplies the VBN to translate from.

    Lbn - Receives the LBN mapped by the input Vbn.  This value is only valid
        if the function result is TRUE.

    SectorCount - Optionally receives the number of sectors corresponding
        to the run.

Return Value:

    BOOLEAN - TRUE if he Vbn has a valid mapping and FALSE otherwise.

--*/

{
    BOOLEAN Result;

    DebugTrace(( +1, Dbg, "UdfVmcbVbnToLbn, Vbn = %08x\n", Vbn ));

    //
    //  Now grab the resource
    //

    VmcbLockForRead( Vmcb);
    
    try {

        Result = UdfVmcbLookupMcbEntry( &Vmcb->VbnIndexed,
                                        Vbn,
                                        Lbn,
                                        SectorCount,
                                        NULL );

        DebugTrace(( 0, Dbg, "*Lbn = %08x\n", *Lbn ));

        //
        //  If the returned Lbn is greater than the maximum allowed Lbn
        //  then return FALSE
        //

        if (Result && (*Lbn > Vmcb->MaximumLbn)) {

            try_leave( Result = FALSE );
        }

        //
        //  If the last returned Lbn is greater than the maximum allowed Lbn
        //  then bring in the sector count
        //

        if (Result &&
            ARGUMENT_PRESENT(SectorCount) &&
            (*Lbn+*SectorCount-1 > Vmcb->MaximumLbn)) {

            *SectorCount = (Vmcb->MaximumLbn - *Lbn + 1);
        }

    } finally {

        VmcbRelease( Vmcb);

        DebugUnwind("UdfVmcbVbnToLbn");
        DebugTrace(( -1, Dbg, "UdfVmcbVbnToLbn -> Result = %08x\n", Result ));
    }


    return Result;
}


BOOLEAN
UdfVmcbLbnToVbn (
    IN PVMCB Vmcb,
    IN LBN Lbn,
    OUT PVBN Vbn,
    OUT PULONG SectorCount OPTIONAL
    )

/*++

Routine Description:

    This routine translates an LBN to a VBN.

Arguments:

    Vmcb - Supplies the VMCB structure being queried.

    Lbn - Supplies the LBN to translate from.

    Vbn - Recieves the VBN mapped by the input LBN.  This value is
        only valid if the function result is TRUE.

    SectorCount - Optionally receives the number of sectors corresponding
        to the run.

Return Value:

    BOOLEAN - TRUE if the mapping is valid and FALSE otherwise.

--*/

{
    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfVmcbLbnToVbn, Lbn = %08x\n", Lbn ));

    //
    //  If the requested Lbn is greater than the maximum allowed Lbn
    //  then the result is FALSE
    //

    if (Lbn > Vmcb->MaximumLbn) {

        DebugTrace(( -1, Dbg, "Lbn too large, UdfVmcbLbnToVbn -> FALSE\n" ));

        return FALSE;
    }

    //
    //  Now grab the resource
    //

    VmcbLockForRead( Vmcb);
    
    try {

        Result = UdfVmcbLookupMcbEntry( &Vmcb->LbnIndexed,
                                        Lbn,
                                        Vbn,
                                        SectorCount,
                                        NULL );

        if (Result)  {
        
            DebugTrace(( 0, Dbg, "*Vbn = %08x\n", *Vbn ));
        }

    } finally {

        VmcbRelease( Vmcb);

        DebugUnwind("UdfVmcbLbnToVbn");
        DebugTrace(( -1, Dbg, "UdfVmcbLbnToVbn -> Result = %08x\n", Result ));
    }

    return Result;
}


BOOLEAN
UdfAddVmcbMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVMCB Vmcb,
    IN LBN Lbn,
    IN ULONG SectorCount,
    IN BOOLEAN ExactEnd,
    OUT PVBN Vbn,
    OUT PULONG AlignedSectorCount
    )

/*++

Routine Description:

    This routine adds a new LBN to VBN mapping to the VMCB structure.  When
    a new LBN is added to the structure it does it only on page aligned
    boundaries.

    If pool is not available to store the information this routine will
    raise a status value indicating insufficient resources.

    May acquire Vcb->VmcbMappingResource EXCLUSIVE if an existing mapping can
    be extended (and hence a purge is necessary),  released before return.  
    
    Caller must have NO active mappings through Vmcb stream before calling this 
    function.

Arguments:

    Vmcb - Supplies the VMCB being updated.

    Lbn - Supplies the starting LBN to add to VMCB.

    SectorCount - Supplies the number of Sectors in the run.  We're only currently expecting 
                  single sector mappings.
    
    ExactEnd - Indicates that instead of aligning to map sectors beyond
        the end of the request, use a hole.  Implies trying to look at 
        these sectors could be undesireable.

    Vbn - Receives the assigned VBN
    
    AlignedSectorCount - Receives the actual sector count created in the
        Vmcb for page alignment purposes. Vbn+AlignedSectorCount-1 == LastVbn.

Return Value:

    BOOLEAN - TRUE if this is a new mapping and FALSE if the mapping
        for the LBN already exists.  If it already exists then the
        sector count for this new addition must already be in the
        VMCB structure

--*/

{

    BOOLEAN Result;

    BOOLEAN VbnMcbAdded = FALSE;
    BOOLEAN LbnMcbAdded = FALSE;
    BOOLEAN AllowRoundToPage;

    LBN LocalLbn;
    VBN LocalVbn;
    ULONG LocalCount;
    LARGE_INTEGER Offset;
    PVCB Vcb;

    PAGED_CODE();

    DebugTrace(( +1, Dbg, "UdfAddVmcbMapping, Lbn = %08x\n", Lbn ));
    DebugTrace(( 0, Dbg, " SectorCount = %08x\n", SectorCount ));

    ASSERT( SectorCount == 1 );
    ASSERT_IRP_CONTEXT( IrpContext);

    Vcb = IrpContext->Vcb;
    
    //
    //  Now grab the resource exclusive
    //

    VmcbLockForModify( Vmcb);

    try {

        //
        //  Check if the Lbn is already mapped, which means we find an entry
        //  with a non zero mapping Vbn value.
        //

        if (UdfVmcbLookupMcbEntry( &Vmcb->LbnIndexed,
                                   Lbn,
                                   Vbn,
                                   &LocalCount,
                                   NULL )) {

            //
            //  It is already mapped so now the sector count must not exceed
            //  the count already in the run
            //

            if (SectorCount <= LocalCount) {

                DebugTrace(( 0, Dbg, "Already mapped (Vbn == 0x%08x)\n", *Vbn));
                
                *AlignedSectorCount = LocalCount;
                try_leave( Result = FALSE );
            }
            
            //
            //  Trying to add overlapping extents indicates overlapping structures...
            //
            
            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR);
        }

        //
        //  If there is a VAT in use,  then we treat the media as CDR style, and don't
        //  round/align extents to page boundries, since this could include (unreadable) 
        //  packet leadin/out sectors.
        //
        
        AllowRoundToPage = (NULL == Vcb->VatFcb);

        //
        //  At this point, we did not find a full existing mapping for the
        //  Lbn and count.  But there might be some overlapping runs that we'll
        //  need to now remove from the vmcb structure.  So for each Lbn in
        //  the range we're after, check to see if it is mapped and remove the
        //  mapping.  We only need to do this test if the sector count is less
        //  than or equal to a page size.  Because those are the only
        //  structures that we know we'll try an remove/overwrite.
        //

        if (SectorCount <= PadSectorCountToPage(Vmcb, 1)) {

            if (UdfVmcbLookupMcbEntry( &Vmcb->LbnIndexed,
                                       Lbn,
                                       Vbn,
                                       &LocalCount,
                                       NULL )) {

                UdfRemoveVmcbMapping( Vmcb, *Vbn, PadSectorCountToPage(Vmcb, 1) );
            }            
        }

        //
        //  We need to add this new run at the end of the Vbns
        //

        if (!FsRtlLookupLastMcbEntry( &Vmcb->VbnIndexed, &LocalVbn, &LocalLbn ))  {

            //
            //  Vmcb is currently empty.
            //
            
            LocalVbn = -1;
        }

        if (!AllowRoundToPage)  {

            //
            //  So this volume may have unreadable sectors on it (eg CDR packet written) 
            //  and so we extend the vmcb one sector at a time,  only including sectors
            //  which we're specifically asked for,  and hence know that we should be 
            //  able to read.  
            //
            //  We simply use the next available VSN,  purging the last vmcb page if 
            //  neccessary (we're adding sectors to it),  and don't page align the lbn
            //  or sectorcount.
            //

            ASSERT( 1 == SectorCount);
            
            LocalVbn += 1;
            LocalLbn = Lbn;
            LocalCount = SectorCount;

            if (!IsPageAligned( Vmcb, LocalVbn))  {
            
                //
                //  The next VSN is not at the beginning of a page (ie: the last page 
                //  in the vmcb has space in it for more sectors),  so purge this
                //  page in the metadata stream before updating the mapping information.
                //
                
                ASSERT( Vcb && Vcb->MetadataFcb );

                Offset.QuadPart = (ULONGLONG) BytesFromSectors( IrpContext->Vcb,  AlignToPageBase( Vmcb, LocalVbn) );

                //
                //  Block until all mappings through the vmcb stream have been dropped
                //  before attempting the purge
                //
                
                UdfAcquireVmcbForCcPurge( IrpContext, IrpContext->Vcb);

                CcPurgeCacheSection( IrpContext->Vcb->MetadataFcb->FileObject->SectionObjectPointer,
                                     &Offset,
                                     PAGE_SIZE,
                                     FALSE );
                
                UdfReleaseVmcb( IrpContext, IrpContext->Vcb);
            }
        }
        else {
        
            //
            //  All sectors on this volume should be readable,  so we always extend the 
            //  vmcb a page at a time,  hoping that metadata will be packed sensibly. 
            //  Because we always extend in page chunks,  LocalVbn will be the last VSN 
            //  in a page aligned block,  so +1 lands on the next page (aligned VSN) in 
            //  the VMCB stream.
            //

            LocalVbn += 1;
            LocalLbn = AlignToPageBase( Vmcb, Lbn);
            LocalCount = PadSectorCountToPage( Vmcb, SectorCount + (Lbn - LocalLbn));

            ASSERT( IsPageAligned( Vmcb, LocalVbn));
        }

        //
        //  Add the double mapping
        //
        
        if (!FsRtlAddMcbEntry( &Vmcb->VbnIndexed,
                               LocalVbn,
                               LocalLbn,
                               LocalCount ))  {

            UdfRaiseStatus( IrpContext, STATUS_INTERNAL_ERROR);
        }

        VbnMcbAdded = TRUE;

        if (!FsRtlAddMcbEntry( &Vmcb->LbnIndexed,
                               LocalLbn,
                               LocalVbn,
                               LocalCount ))  {

            UdfRaiseStatus( IrpContext, STATUS_INTERNAL_ERROR);
        }
        
        LbnMcbAdded = TRUE;

        *Vbn = LocalVbn + (Lbn - LocalLbn);
        *AlignedSectorCount = LocalCount - (Lbn - LocalLbn);

        Result = TRUE;

    } finally {

        //
        //  If this is an abnormal termination then clean up any mcb's that we
        //  might have modified.
        //

        if (AbnormalTermination()) {

            if (VbnMcbAdded) { FsRtlRemoveMcbEntry( &Vmcb->VbnIndexed, LocalVbn, LocalCount ); }
            if (LbnMcbAdded) { FsRtlRemoveMcbEntry( &Vmcb->LbnIndexed, LocalLbn, LocalCount ); }
        }

        VmcbRelease( Vmcb);

        DebugUnwind("UdfAddVmcbMapping");

        if (Result)  {
        
            DebugTrace(( 0, Dbg, " LocalVbn   = %08x\n", LocalVbn ));
            DebugTrace(( 0, Dbg, " LocalLbn   = %08x\n", LocalLbn ));
            DebugTrace(( 0, Dbg, " LocalCount = %08x\n", LocalCount ));
            DebugTrace(( 0, Dbg, " *Vbn                = %08x\n", *Vbn ));
            DebugTrace(( 0, Dbg, " *AlignedSectorCount = %08x\n", *AlignedSectorCount ));
        }
        
        DebugTrace((-1, Dbg, "UdfAddVmcbMapping -> %08x\n", Result ));
    }

    return Result;
}


VOID
UdfRemoveVmcbMapping (
    IN PVMCB Vmcb,
    IN VBN Vbn,
    IN ULONG SectorCount
    )

/*++

Routine Description:

    This routine removes a Vmcb mapping.

    If pool is not available to store the information this routine will
    raise a status value indicating insufficient resources.

Arguments:

    Vmcb - Supplies the Vmcb being updated.

    Vbn - Supplies the VBN to remove

    SectorCount - Supplies the number of sectors to remove.

Return Value:

    None.

--*/

{
    LBN Lbn;
    ULONG LocalCount;
    ULONG i;

    PAGED_CODE();

    DebugTrace((+1, Dbg, "UdfRemoveVmcbMapping, Vbn = %08x\n", Vbn ));
    DebugTrace(( 0, Dbg, " SectorCount = %08x\n", SectorCount ));

    //
    //  Now grab the resource exclusive
    //

    VmcbLockForModify( Vmcb);

    try {

        for (i = 0; i < SectorCount; i += 1) {

            //
            //  Lookup the Vbn so we can get its current Lbn mapping
            //

            if (!UdfVmcbLookupMcbEntry( &Vmcb->VbnIndexed,
                                        Vbn + i,
                                        &Lbn,
                                        &LocalCount,
                                        NULL )) {

                UdfBugCheck( 0, 0, 0 );
            }

            FsRtlRemoveMcbEntry( &Vmcb->VbnIndexed,
                                 Vbn + i,
                                 1 );

            FsRtlRemoveMcbEntry( &Vmcb->LbnIndexed,
                                 Lbn,
                                 1 );
        }

        {
            DebugTrace(( 0, Dbg, "VbnIndex:\n", 0 ));
            DebugTrace(( 0, Dbg, "LbnIndex:\n", 0 ));
        }

    } finally {

        VmcbRelease( Vmcb);

        DebugUnwind( "UdfRemoveVmcbMapping" );
        DebugTrace(( -1, Dbg, "UdfRemoveVmcbMapping -> VOID\n" ));
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
UdfVmcbLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.
    It indicates if the mapping exists and the size of the run.
    
    The only difference betweent this and the regular FsRtlLookupMcbEntry
    is that we undo the behavior of returning TRUE in holes in the allocation.
    This is because we don't want to avoid mapping at Lbn 0, which is how the
    emulated behavior of the small Mcb package tells callers that there is no
    mapping at that location in a hole.  We have holes all over our Vbn space
    in the VbnIndexed map.
    
    The small Mcb package was able to get away with this because Lbn 0 was the
    boot sector (or similar magic location) on the disc.  In our metadata stream,
    we wish to use Vbn 0 (remember this is a double map).

Arguments:

    Mcb - Supplies the Mcb being examined.

    Vbn - Supplies the Vbn to lookup.

    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is
        returned if the Vbn does not have a corresponding Lbn.

    SectorCount - Receives the number of sectors that map from the Vbn to
        contiguous Lbn values beginning with the input Vbn.

    Index - Receives the index of the run found.

Return Value:

    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the
        MCB (not if it corresponds to a hole in the mapping), and FALSE
        if the Vbn is beyond the range of the MCB's mapping.

        For example, if an MCB has a mapping for VBNs 5 and 7 but not for
        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector
        count of 1.  A lookup for Vbn 6 will return FALSE with an Lbn value of
        0, and lookup for Vbn 8 or above will return FALSE.

--*/

{
    BOOLEAN Results;
    LONGLONG LiLbn = 0;
    LONGLONG LiSectorCount = 0;

    Results = FsRtlLookupLargeMcbEntry( (PLARGE_MCB)Mcb,
                                        (LONGLONG)(Vbn),
                                        &LiLbn,
                                        ARGUMENT_PRESENT(SectorCount) ? &LiSectorCount : NULL,
                                        NULL,
                                        NULL,
                                        Index );

    if ((ULONG)LiLbn == -1) {

        *Lbn = 0;
        Results = FALSE;
    
    } else {

        *Lbn = (ULONG)LiLbn;
    }

    if (ARGUMENT_PRESENT(SectorCount)) { *SectorCount = ((ULONG)LiSectorCount); }

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\udfs\volinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Udfs called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     20-Jan-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_VOLINFO)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_VOLINFO)

//
//  Local support routines
//

NTSTATUS
UdfQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonQueryVolInfo)
#pragma alloc_text(PAGE, UdfQueryFsAttributeInfo)
#pragma alloc_text(PAGE, UdfQueryFsDeviceInfo)
#pragma alloc_text(PAGE, UdfQueryFsSizeInfo)
#pragma alloc_text(PAGE, UdfQueryFsVolumeInfo)
#endif


NTSTATUS
UdfCommonQueryVolInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG Length;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;

    //
    //  Decode the file object and fail if this an unopened file object.
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    if (TypeOfOpen == UnopenedFileObject) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the Vcb for this volume.
    //

    UdfAcquireVcbShared( IrpContext, Fcb->Vcb, FALSE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Vcb.
        //

        UdfVerifyVcb( IrpContext, Fcb->Vcb );

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling fills up the output buffer
        //  if possible and returns true if it successfully filled the buffer
        //  and false if it couldn't wait for any I/O to complete.
        //

        switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsSizeInformation:

            Status = UdfQueryFsSizeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsVolumeInformation:

            Status = UdfQueryFsVolumeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsDeviceInformation:

            Status = UdfQueryFsDeviceInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsAttributeInformation:

            Status = UdfQueryFsAttributeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

    } finally {

        //
        //  Release the Vcb.
        //

        UdfReleaseVcb( IrpContext, Fcb->Vcb );
    }

    //
    //  Complete the request if we didn't raise.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Fill in the data from the Vcb.
    //

    Buffer->VolumeCreationTime = Vcb->VolumeDasdFcb->Timestamps.CreationTime;
    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;

    Buffer->SupportsObjects = FALSE;

    *Length -= FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] );

    //
    //  Check if the buffer we're given is long enough
    //

    if (*Length >= (ULONG) Vcb->Vpb->VolumeLabelLength) {

        BytesToCopy = Vcb->Vpb->VolumeLabelLength;

    } else {

        BytesToCopy = *Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = BytesToCopy;

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->VolumeLabel[0],
                       &Vcb->Vpb->VolumeLabel[0],
                       BytesToCopy );
    }

    *Length -= BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume size call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Fill in the output buffer.
    //

    Buffer->TotalAllocationUnits.QuadPart = LlBlocksFromBytes( Vcb, Vcb->VolumeDasdFcb->AllocationSize.QuadPart );

    Buffer->AvailableAllocationUnits.QuadPart = 0;
    Buffer->SectorsPerAllocationUnit = SectorsFromBytes( Vcb, BlockSize( Vcb ));
    Buffer->BytesPerSector = SectorSize( Vcb );

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Update the output buffer.
    //

    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;
    Buffer->DeviceType = FILE_DEVICE_CD_ROM;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_DEVICE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Fill out the fixed portion of the buffer.
    //

    Buffer->FileSystemAttributes = FILE_CASE_SENSITIVE_SEARCH |
                                   FILE_UNICODE_ON_DISK |
                                   FILE_READ_ONLY_VOLUME;

    Buffer->MaximumComponentNameLength = 255;

    *Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName );

    //
    //  Make sure we can copy full unicode characters.
    //

    ClearFlag( *Length, 1 );

    //
    //  Determine how much of the file system name will fit.
    //

    if (*Length >= 6) {

        BytesToCopy = 6;

    } else {

        BytesToCopy = *Length;
        Status = STATUS_BUFFER_OVERFLOW;
    }

    *Length -= BytesToCopy;

    //
    //  Do the file system name.  We explicitly share this designation with all
    //  Microsoft implementations of the UDF filesystem - DO NOT CHANGE!
    //

    Buffer->FileSystemNameLength = BytesToCopy;

    RtlCopyMemory( &Buffer->FileSystemName[0], L"UDF", BytesToCopy );

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\aclconv\aclconv.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    aclconv.cxx

Abstract:

    This module contains function definitions for the ACLCONV class,
    which implements conversion of Lanman 2.x ACLs into NT ACLs.

Author:

    Bill McJohn (billmc) 29-Jan-1992

Revision History:


Environment:

        ULIB, User Mode

--*/


#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "ulibcl.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "arg.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "system.hxx"
#include "aclconv.hxx"
#include "file.hxx"
#include "filestrm.hxx"

#include "logfile.hxx"


BOOLEAN
QueryFileSystemName(
    IN  PCWSTRING   RootName,
    OUT PDSTRING    FileSystemName
    )
/*++

Routine Description:

    Determines the name of the file system on the specified volume.

Arguments:

    RootName        --  Supplies the name of the volume's root directory.
    FileSystemName  --  Receives the file system name.

Return Value:

    TRUE upon successful completion.

--*/
{
    WCHAR NameBuffer[8];

    if( !GetVolumeInformation( RootName->GetWSTR(),
                               NULL,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               NameBuffer,
                               8 ) ) {

        return FALSE;
    }

    return( FileSystemName->Initialize( NameBuffer ) );
}


BOOLEAN
EnablePrivilege(
    PWSTR   Privilege
    )
/*++

Routine Description:

    This routine tries to adjust the priviliege of the current process.


Arguments:

    Privilege - String with the name of the privilege to be adjusted.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        DebugPrint( "OpenProcessToken failed" );
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               Privilege,
                               &( LuidAndAttributes.Luid ) ) ) {
        DebugPrintTrace(( "LookupPrivilegeValue failed, Error = %#d \n", GetLastError() ));
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        DebugPrintTrace(( "AdjustTokenPrivileges failed, Error = %#x \n", GetLastError() ));
        return( FALSE );
    }

    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }
    return( TRUE );
}


INT __cdecl
main(
    )
/*++

Routine Description:

    Entry point for the ACL conversion utility.

Arguments:

    None.

Return Value:

    An error level--0 indicates success.

--*/
{
    INT ExitCode = 0;

    if( !DEFINE_CLASS_DESCRIPTOR( ACLCONV ) ||
        !DEFINE_CLASS_DESCRIPTOR( SID_CACHE ) ||
        !DEFINE_CLASS_DESCRIPTOR( ACL_CONVERT_NODE ) ) {

        return 1;
    }

    {
        ACLCONV Aclconv;

        if( Aclconv.Initialize( &ExitCode ) ) {

            if( Aclconv.IsInListMode() ) {

                ExitCode = Aclconv.ListLogFile();

            } else {

                ExitCode = Aclconv.ConvertAcls();
            }
        }
    }

    return ExitCode;
}


DEFINE_CONSTRUCTOR( ACLCONV, PROGRAM );

ACLCONV::~ACLCONV(
    )
{
    Destroy();
}

VOID
ACLCONV::Construct(
    )
/*++

Routine Description:

    Helper method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataFileRevision = DataFileRevisionUnknown;

    _DataFile = NULL;
    _DataFileStream = NULL;
    _LogFile = NULL;
    _LogFileStream = NULL;

    _AclWorkFile = NULL;
    _AclWorkStream = NULL;

    _NewDrive = NULL;

    _RootNode = NULL;
    _DriveName = NULL;
    _DomainName = NULL;
    _SidLookupTableName = NULL;

}

VOID
ACLCONV::Destroy(
    )
/*++

Routine Description:

    Helper function for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataFileRevision = DataFileRevisionUnknown;
    _NextReadOffset = 0;
    _BytesRemainingInCurrentGroup = 0;

    DELETE( _DataFile );
    DELETE( _DataFileStream );
    DELETE( _LogFile );
    DELETE( _LogFileStream );

    DELETE( _AclWorkFile );
    DELETE( _AclWorkStream );
    DELETE( _NewDrive );
    DELETE( _RootNode );
    DELETE( _DriveName );
    DELETE( _DomainName );
    DELETE( _SidLookupTableName );
}



BOOLEAN
ACLCONV::Initialize(
    OUT PINT ExitCode
    )
/*++

Routine Description:

    Initialize the ACLCONV object.

Arguments:

    ExitCode    --  Receives an error level if this method fails.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    if( !PROGRAM::Initialize( ) ) {

        Destroy();
        *ExitCode = 1;
        return FALSE;
    }

    return ParseArguments( ExitCode );
}


INT
ACLCONV::ListLogFile(
    )
/*++

Routine Description:

    This method reads a log file produced by a previous run of
    ACLCONV and displays the errors logged to that file.

Arguments:

    None.

Return Value:

    An error level--zero indicates success.

--*/
{
    LM_ACCESS_LIST AccessEntries[ MAX_ACCESS_ENTRIES ];
    ULONG AceConversionCodes[ MAX_ACCESS_ENTRIES ];

    ACLCONV_LOGFILE_HEADER LogFileHeader;
    DSTRING ResourceName;
    ULONG AccessEntryCount, BytesRead, ConversionCode, i;
    INT ExitCode = 0;
    USHORT AuditInfo;

    // Open the log file and reset the seek pointer to the beginning
    // of the file.
    //
    if( (_LogFile = SYSTEM::QueryFile( &_LogFilePath )) == NULL ||
        (_LogFileStream = _LogFile->QueryStream( READ_ACCESS )) == NULL ) {

        // Cannot create log file.

        DisplayMessage( MSG_ACLCONV_CANT_OPEN_FILE,
                        ERROR_MESSAGE,
                        "%W",
                        _LogFilePath.GetPathString() );
        return 1;
    }

    // Check the log file signature:
    //
    if( !_LogFileStream->MovePointerPosition( 0, STREAM_BEGINNING ) ||
        !_LogFileStream->Read( (PBYTE)&LogFileHeader,
                               sizeof( ACLCONV_LOGFILE_HEADER ),
                               &BytesRead ) ||
        BytesRead != sizeof( ACLCONV_LOGFILE_HEADER ) ||
        LogFileHeader.Signature != AclconvLogFileSignature ) {

        DisplayMessage( MSG_ACLCONV_INVALID_LOG_FILE,
                        ERROR_MESSAGE );

        return 1;
    }

    _NextReadOffset = sizeof( ACLCONV_LOGFILE_HEADER );

    while( ReadNextLogRecord( &ExitCode,
                              &ResourceName,
                              &ConversionCode,
                              &AuditInfo,
                              MAX_ACCESS_ENTRIES,
                              &AccessEntryCount,
                              AccessEntries,
                              AceConversionCodes ) ) {

        // Scan to see if there are any entries to display
        //
        if( AccessEntryCount != 0 ) {

            DisplayMessage( MSG_ACLCONV_RESOURCE_NAME,
                            NORMAL_MESSAGE,
                            "%W",
                            &ResourceName );

            for( i = 0; i < AccessEntryCount; i++ ) {

                DisplayAce( (ACL_CONVERT_CODE)ConversionCode,
                            (ACE_CONVERT_CODE)AceConversionCodes[i],
                            AccessEntries + i );
            }
        }
    }

    if( ExitCode ) {

        DisplayMessage( MSG_ACLCONV_LOGFILE_READ_ERROR, ERROR_MESSAGE );
    }

    return ExitCode;
}



NONVIRTUAL
BOOLEAN
ACLCONV::DisplayAce(
    IN ACL_CONVERT_CODE AclConvertCode,
    IN ACE_CONVERT_CODE AceConvertCode,
    IN PLM_ACCESS_LIST  Ace
    )
/*++

Routine Description:

    This method displays the conversion result for a single ACE.

Arguments:

    AclConvertCode  --  Supplies the overall conversion code for
                        the resource to which this ACE is attached.
    AceConvertCode  --  Supplies the conversion result for this
                        particular ACE.  Note that if the AclConvertCode
                        is not ACL_CONVERT_SUCCESS, it takes priority
                        over AceConvertCode.
    Ace             --  Supplies the ACE in question.

Return Value:

    TRUE upon successful completion.

--*/
{
    WCHAR WideNameBuffer[ UNLEN + 1 ];
    DSTRING Temp;
    DSTRING Name;

    memset( WideNameBuffer, 0, sizeof( WideNameBuffer ) );

    // Display the user's name.  If it's a group, prepend an
    // asterisk.
    //
    if( !MultiByteToWideChar( _SourceCodepage,
                              0,
                              Ace->acl_ugname,
                              strlen( Ace->acl_ugname ),
                              WideNameBuffer,
                              UNLEN + 1 ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        return FALSE;
    }

    if( !Temp.Initialize( WideNameBuffer ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        return FALSE;
    }

    if( Ace->acl_access & LM_ACCESS_GROUP ) {

        if( !Name.Initialize( "*" ) ||
            !Name.Strcat( &Temp ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return FALSE;
        }

    } else {

        if( !Name.Initialize( &Temp ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return FALSE;
        }
    }

    DisplayMessage( MSG_ACLCONV_USERNAME, NORMAL_MESSAGE, "%W", &Name );


    // Display the permissions:
    //
    if( (Ace->acl_access & ~LM_ACCESS_GROUP) == 0 ) {

        // This is a no-access ACE.
        //
        DisplayMessage( MSG_ACLCONV_NONE_PERM );

    } else {

        // This ACE grants some sort of access--check each type
        // of access in turn, displaying all we find.
        //
        if( Ace->acl_access & LM_ACCESS_READ ) {

            DisplayMessage( MSG_ACLCONV_READ_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_WRITE ) {

            DisplayMessage( MSG_ACLCONV_WRITE_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_CREATE ) {

            DisplayMessage( MSG_ACLCONV_CREATE_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_EXEC ) {

            DisplayMessage( MSG_ACLCONV_EXECUTE_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_DELETE ) {

            DisplayMessage( MSG_ACLCONV_DELETE_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_ATRIB ) {

            DisplayMessage( MSG_ACLCONV_ATTR_PERM );
        }

        if( Ace->acl_access & LM_ACCESS_PERM ) {

            DisplayMessage( MSG_ACLCONV_PERM_PERM );
        }
    }


    // Display the cause of failure:
    //
    if( AclConvertCode != ACL_CONVERT_SUCCESS ) {

        // The failure is associated with the resource.
        //
        switch( AclConvertCode ) {

        case ACL_CONVERT_RESOURCE_NOT_FOUND :
            DisplayMessage( MSG_ACLCONV_FILE_NOT_FOUND );
            break;

        case ACL_CONVERT_ERROR :
        default :
            DisplayMessage( MSG_ACLCONV_ERROR_IN_CONVERSION );
            break;
        }

    } else {

        // Display the ACE conversion result.
        //
        switch( AceConvertCode ) {

        case ACL_CONVERT_SUCCESS :
            DisplayMessage( MSG_ACLCONV_ACE_CONVERTED );
            break;

        case ACE_CONVERT_DROPPED :
            DisplayMessage( MSG_ACLCONV_ACE_DROPPED );
            break;

        case ACE_CONVERT_SID_NOT_FOUND :
            DisplayMessage( MSG_ACLCONV_SID_NOT_FOUND );
            break;

        case ACE_CONVERT_ERROR :
        default:
            DisplayMessage( MSG_ACLCONV_ERROR_IN_CONVERSION );
            break;
        }
    }


    return TRUE;
}


NONVIRTUAL
BOOLEAN
ACLCONV::ReadNextLogRecord(
    OUT PINT            ExitCode,
    OUT PWSTRING        ResourceString,
    OUT PULONG          ConversionCode,
    OUT PUSHORT         AuditInfo,
    IN  ULONG           MaxEntries,
    OUT PULONG          AccessEntryCount,
    OUT PLM_ACCESS_LIST AccessEntries,
    OUT PULONG          AceConversionCodes
    )
/*++

Routine Description:

    This method reads the next log entry from the log file.

Arguments:

    ExitCode            --  receives an exit code if an error occurs.
    ResourceString      --  receives the name of the resource
    ConversionCode      --  receives the conversion result for this resource.
    AuditInfo           --  receives the audit information for this resource.
    MaxEntries          --  supplies the maximum number of ACE's that can
                            be written to the output buffers.
    AccessEntryCount    --  receives the number of ACE's written to
                            the output buffers.
    AccessEntries       --  receives the logged ACE's
    AceConversionCodes  --  receives the conversion results for the
                            individual ACE's.

Return Value:

    TRUE upon successful completion (in which case ExitCode may
    be ignored).  FALSE if there are no more entries (in which
    case ExitCode is zero) or if an error occurs (in which case
    ExitCode is non-zero).

--*/
{
    ACLCONV_LOG_RECORD_HEADER Header;
    ULONG BytesRead;

    if( _LogFileStream->IsAtEnd() ) {

        // No more entries to read.

        *ExitCode = 0;
        return FALSE;
    }

    // Read the log record header
    //
    if( !_LogFileStream->Read( (PBYTE)&Header,
                               sizeof( ACLCONV_LOG_RECORD_HEADER ),
                               &BytesRead ) ||
        BytesRead != sizeof( ACLCONV_LOG_RECORD_HEADER ) ) {

        *ExitCode = 1;
        return FALSE;
    }

    *ConversionCode = Header.ConversionResult;
    *AuditInfo = Header.LmAuditMask;
    *AccessEntryCount = Header.AccessEntryCount;

    // Make sure that the name is not longer than the maximum
    // name length (plus room for trailing NULL) and then read
    // it into the name workspace and use it to initialize the
    // client's resource name string.
    //
    if( Header.ResourceNameLength > MAX_RESOURCE_NAME_LENGTH + 1 ||
        !_LogFileStream->Read( (PBYTE)_NameBuffer,
                               Header.ResourceNameLength * sizeof( WCHAR ),
                               &BytesRead ) ||
        BytesRead != Header.ResourceNameLength * sizeof( WCHAR ) ||
        !ResourceString->Initialize( _NameBuffer ) ) {

        *ExitCode = 1;
        return FALSE;
    }

    // Make sure the ACE's and their associated convert codes will
    // fit in the supplied buffers:
    //
    if( Header.AccessEntryCount > MaxEntries ) {

        *ExitCode = 1;
        return FALSE;
    }

    // Read the ACE conversion codes and the ACE's themselves:
    //
    if( Header.AccessEntryCount != 0 &&
        ( !_LogFileStream->Read( (PBYTE)AceConversionCodes,
                                 Header.AccessEntryCount * sizeof( ULONG ),
                                 &BytesRead ) ||
          BytesRead != Header.AccessEntryCount * sizeof( ULONG ) ) ||

        ( !_LogFileStream->Read( (PBYTE)AccessEntries,
                                 Header.AccessEntryCount *
                                        sizeof( LM_ACCESS_LIST ),
                                 &BytesRead ) ||
          BytesRead != Header.AccessEntryCount * sizeof( LM_ACCESS_LIST ) ) ) {

        *ExitCode = 1;
        return FALSE;
    }

    return TRUE;
}



INT
ACLCONV::ConvertAcls(
    )
/*++

Routine Description:

    This method reads the ACL's from the data file into a tree
    of ACL Convert Nodes, and then converts the ACL's to NT
    security descriptors and applies them to the files and
    directories in question.

Arguments:

    None.

Return Value:

    An error level--zero indicates success.

--*/
{

    LM_ACCESS_LIST AccessEntries[MAX_ACCESS_ENTRIES];
    INHERITANCE_BUFFER Inheritance;

    FSTRING NtfsString;
    DSTRING FsName;
    DSTRING CurrentResource;
    PATH    CurrentResourcePath;

    ACLCONV_LOGFILE_HEADER LogfileHeader;

    PARRAY Components = NULL;
    PARRAY_ITERATOR ComponentIterator = NULL;
    PACL_CONVERT_NODE CurrentNode, NextNode;
    PWSTRING CurrentComponent;

    ULONG AccessEntryCount, BytesWritten;
    USHORT LmAuditInfo;

    INT ExitCode = 0;

    DSTRING AclWorkString;

    // Open aclwork.dat and read the contents into a special
    // sid cache.

    if (!AclWorkString.Initialize(L"aclwork.dat")) {
        return 1;
    }
    if (!_AclWorkPath.Initialize(&AclWorkString)) {
        return 1;
    }

    if (NULL == (_AclWorkFile = SYSTEM::QueryFile(&_AclWorkPath))) {

        // try to open aclwork.dat in the same directory as the
        // data file.

        if (!_AclWorkPath.Initialize(&_DataFilePath)) {
            return 1;
        }
        if (!_AclWorkPath.SetName(&AclWorkString)) {
            return 1;
        }

        _AclWorkFile = SYSTEM::QueryFile(&_AclWorkPath);
    }
    if (NULL != _AclWorkFile &&
        NULL != (_AclWorkStream = _AclWorkFile->QueryStream(READ_ACCESS))) {

        // DisplayMessage( MSG_ACLCONV_USING_ACLWORK, NORMAL_MESSAGE );

        if (!ReadAclWorkSids()) {
            return 1;
        }
    }

    // Open the data file and determine its format (ie. what
    // revision of BackAcc produced it).

    if( (_DataFile = SYSTEM::QueryFile( &_DataFilePath )) == NULL ||
        (_DataFileStream = _DataFile->QueryStream( READ_ACCESS )) == NULL ) {

        DisplayMessage( MSG_ACLCONV_CANT_OPEN_FILE,
                        ERROR_MESSAGE,
                        "%W",
                        _DataFilePath.GetPathString() );
        return 1;
    }

    // Note that DetermineDataFileRevision sets _DataFileRevision.

    if( !DetermineDataFileRevision( ) ||
        _DataFileRevision == DataFileRevisionUnknown ) {

        DisplayMessage( MSG_ACLCONV_DATAFILE_BAD_FORMAT,
                        ERROR_MESSAGE,
                        "%W",
                        _DataFilePath.GetPathString() );
        return 1;
    }


    // Create the log file.

    LogfileHeader.Signature = AclconvLogFileSignature;

    if( (_LogFile = SYSTEM::MakeFile( &_LogFilePath )) == NULL ||
        (_LogFileStream = _LogFile->QueryStream( WRITE_ACCESS )) == NULL ||
        !_LogFileStream->Write( (PBYTE)&LogfileHeader,
                                sizeof( ACLCONV_LOGFILE_HEADER ),
                                &BytesWritten ) ||
        BytesWritten != sizeof( ACLCONV_LOGFILE_HEADER ) ) {

        // Cannot create log file.

        DisplayMessage( MSG_ACLCONV_CANT_OPEN_FILE,
                        ERROR_MESSAGE,
                        "%W",
                        _LogFilePath.GetPathString() );
        return 1;
    }


    while( ReadNextAcl( &ExitCode,
                        &CurrentResource,
                        MAX_ACCESS_ENTRIES,
                        &AccessEntryCount,
                        (PVOID)AccessEntries,
                        &LmAuditInfo ) ) {

        if( CurrentResource.QueryChCount() == 0 ) {

            // This resource has no name; ignore it.
            //
            continue;
        }

        if( !CurrentResourcePath.Initialize( &CurrentResource ) ) {

            DisplayMessage( MSG_ACLCONV_DATAFILE_ERROR, ERROR_MESSAGE );
            return 1;
        }

        // If the user specified a substitute drive, use it.
        //
        if( _NewDrive != NULL &&
            !CurrentResourcePath.SetDevice( _NewDrive ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return 1;
        }

        if( _RootNode == NULL ) {

            // This is the first ACL--create the root of the tree
            // and determine the name of the drive.

            if( !(_DriveName = CurrentResourcePath.QueryRoot()) ||
                !(_RootNode = NEW ACL_CONVERT_NODE) ||
                !_RootNode->Initialize( _DriveName ) ) {

                DELETE( _RootNode );
                DELETE( _DriveName );

                DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                return 1;
            }
        }

        // Fetch the component array for this resource.

        DELETE( ComponentIterator );

        if( Components != NULL ) {

            Components->DeleteAllMembers();
        }

        DELETE( Components );

        if( !(Components = CurrentResourcePath.QueryComponentArray()) ||
            !(ComponentIterator = (PARRAY_ITERATOR)
                                  Components->QueryIterator()) ) {

            DELETE( ComponentIterator );

            if( Components != NULL ) {

                Components->DeleteAllMembers();
            }

            DELETE( Components );

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return 1;
        }

        CurrentNode = _RootNode;

        ComponentIterator->Reset();

        // The first component is the drive & root directory, which
        // isn't interesting.

        CurrentComponent = (PWSTRING)ComponentIterator->GetNext();

        // Traverse the tree down to the end of the path, creating
        // new nodes as needed.

        while( (CurrentComponent = (PWSTRING)ComponentIterator->GetNext())
                    != NULL ) {

            if( !(NextNode = CurrentNode->GetChild( CurrentComponent )) &&
                !(NextNode = CurrentNode->AddChild( CurrentComponent )) ) {

                DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                return 1;
            }

            CurrentNode = NextNode;
        }

        // Add the Lanman ACL to the node which represents the end of
        // the path.

        if( !CurrentNode->AddLanmanAcl( AccessEntryCount,
                                        AccessEntries,
                                        LmAuditInfo ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return 1;
        }
    }


    if( ExitCode != 0 ) {

        DisplayMessage( MSG_ACLCONV_DATAFILE_ERROR, ERROR_MESSAGE );
        return 1;
    }

    // Traverse the tree and convert all the ACE's, propagating
    // as we go.
    //

    // Adjust this process' privileges so that it can twiddle
    // System ACL's.
    //
    if( !EnablePrivilege( (LPWSTR)SE_SECURITY_NAME ) ) {

        DisplayMessage( MSG_ACLCONV_CONVERSION_ERROR, ERROR_MESSAGE );
        ExitCode = 1;
    }

    if( ExitCode == 0 &&
        _RootNode != NULL ) {

        // Make sure the target drive is NTFS.
        //
        if( !NtfsString.Initialize( (PWSTR)L"NTFS" ) ||
            !QueryFileSystemName( _RootNode->GetName(), &FsName ) ) {

            DisplayMessage( MSG_ACLCONV_CANT_DETERMINE_FILESYSTEM, ERROR_MESSAGE );
            ExitCode = 1;

        } else if( FsName.Stricmp( &NtfsString ) != 0 ) {

            DisplayMessage( MSG_ACLCONV_TARGET_NOT_NTFS, ERROR_MESSAGE );
            ExitCode = 1;

        } else {

            // Set up an empty inheritance buffer to pass
            // to the root.
            //
            Inheritance.RecessiveDeniedAces = NULL;
            Inheritance.RecessiveAllowedAces = NULL;
            Inheritance.DominantDeniedAces = NULL;
            Inheritance.DominantAllowedAces = NULL;

            Inheritance.RecessiveDeniedMaxLength = 0;
            Inheritance.RecessiveAllowedMaxLength = 0;
            Inheritance.DominantDeniedMaxLength = 0;
            Inheritance.DominantAllowedMaxLength = 0;

            Inheritance.RecessiveDeniedLength = 0;
            Inheritance.RecessiveAllowedLength = 0;
            Inheritance.DominantDeniedLength = 0;
            Inheritance.DominantAllowedLength = 0;

            if( !_RootNode->Convert( NULL,
                                     &Inheritance,
                                     this ) ) {

                DisplayMessage( MSG_ACLCONV_CONVERSION_ERROR, ERROR_MESSAGE );
                ExitCode = 1;
            }
        }
    }


    if( ExitCode == 0 ) {

        DisplayMessage( MSG_ACLCONV_CONVERT_COMPLETE );
    }

    return ExitCode;
}


BOOLEAN
ACLCONV::LogConversion(
    IN PPATH            Resource,
    IN ULONG            ConversionCode,
    IN ULONG            LmAuditInfo,
    IN ULONG            AccessEntryCount,
    IN PCULONG          AceConversionCodes,
    IN PCLM_ACCESS_LIST AccessEntries
    )
/*+

Routine Description:

    This method writes information about the conversion of a resource
    to the log file.

Arguments:

    Resource            --  Supplies the path to the resource
    ConversionCode      --  Supplies the conversion result for the
                            resource.
    LmAuditInfo         --  Supplies the Lanman 2.x audit information
                            associated with the resource.
    AccessEntryCount    --  Supplies the number of Lanman 2.x access
                            entries associated with the resource.
    AceConversionCodes  --  Supplies the conversion results of the
                            individual ACE's
    AccessEntries       --  Supplies the Lanman 2.x access control
                            entries.

Return Value:

    TRUE upon successful completion.

--*/
{
    ACLCONV_LOG_RECORD_HEADER Header;
    PCWSTRING PathString;

    ULONG NameLength, BytesWritten;

    DebugPtrAssert( Resource );
    DebugPtrAssert( _LogFileStream );

    if( (PathString = Resource->GetPathString()) == NULL ||
        (NameLength = PathString->QueryChCount()) > MAX_RESOURCE_NAME_LENGTH ||
        !PathString->QueryWSTR( 0,
                                TO_END,
                                _NameBuffer,
                                MAX_RESOURCE_NAME_LENGTH + 1 ) ){

        return FALSE;
    }

    Header.ResourceNameLength = NameLength + 1;
    Header.ConversionResult = ConversionCode;
    Header.LmAuditMask = (USHORT)LmAuditInfo;
    Header.AccessEntryCount = (USHORT)AccessEntryCount;

    if(!_LogFileStream->Write( (PBYTE)&Header,
                               sizeof( ACLCONV_LOG_RECORD_HEADER ),
                               &BytesWritten )                      ||
       BytesWritten != sizeof( ACLCONV_LOG_RECORD_HEADER )          ||
       !_LogFileStream->Write( (PBYTE)_NameBuffer,
                                (NameLength + 1) * sizeof( WCHAR ),
                                &BytesWritten )                     ||
        BytesWritten != (NameLength + 1) * sizeof( WCHAR )) {

        DisplayMessage( MSG_ACLCONV_LOGFILE_ERROR, ERROR_MESSAGE );
        return FALSE;
    }

    if( AccessEntryCount != 0 &&
        ( !_LogFileStream->Write( (PBYTE)AceConversionCodes,
                                  AccessEntryCount * sizeof(ULONG),
                                  &BytesWritten )                   ||
          BytesWritten != AccessEntryCount * sizeof(ULONG)          ||
          !_LogFileStream->Write( (PBYTE)AccessEntries,
                                  AccessEntryCount * sizeof( LM_ACCESS_LIST ),
                                  &BytesWritten )                   ||
          BytesWritten != AccessEntryCount * sizeof( LM_ACCESS_LIST ) ) ) {

        DisplayMessage( MSG_ACLCONV_LOGFILE_ERROR, ERROR_MESSAGE );
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
ACLCONV::ParseArguments(
    OUT PINT ExitCode
    )
/*++

Routine Description:

    This method parses the arguments given to ACLCONV and sets the
    state of the object appropriately.

    The accepted syntax is:

        ACLCONV [/?] [/V] /DATA:datafile /LOG:logfile

Arguments:

    ExitCode    --  Receives an exit code if the method fails.

Return Value:

    TRUE upon successful completion.

    Note that this method will fail, but return an exit-code
    of zero (success) if the user specifies the /? argument.

--*/
{
    ARRAY               ArgArray;               //  Array of arguments
    ARRAY               LexArray;               //  Array of lexemes
    ARGUMENT_LEXEMIZER  ArgLex;                 //  Argument Lexemizer
    STRING_ARGUMENT     ProgramNameArgument;    //  Program name argument
    PATH_ARGUMENT       DataFileArgument;       //  Path to data file
    PATH_ARGUMENT       LogFileArgument;        //  Path to log file
    PATH_ARGUMENT       DriveArgument;          //  New drive to use
    FLAG_ARGUMENT       ListArgument;           //  List flag argument
    FLAG_ARGUMENT       HelpArgument;           //  Help flag argument
    STRING_ARGUMENT     DomainArgument;         //  Domain name argument
    LONG_ARGUMENT       CodepageArgument;       //  Source Codepage argument
    STRING_ARGUMENT     SidLookupArgument;      //  Filename of lookup table
    PWSTRING            InvalidArg;             //  Invalid argument catcher
    DSTRING             Backslash;              //  Backslash
    DSTRING             RootDir;                //  Root directory of the new drive
    UINT                DriveType;


    DebugPtrAssert( ExitCode );

        //
        //      Initialize all the argument parsing machinery.
        //
    if( !ArgArray.Initialize( 5, 1 )                ||
        !LexArray.Initialize( 5, 1 )                ||
        !ArgLex.Initialize( &LexArray )             ||
        !HelpArgument.Initialize( "/?" )            ||
        !ListArgument.Initialize( "/LIST" )         ||
        !ProgramNameArgument.Initialize( "*" )      ||
        !DataFileArgument.Initialize( "/DATA:*" )   ||
        !LogFileArgument.Initialize( "/LOG:*" )     ||
        !DriveArgument.Initialize( "/NEWDRIVE:*" )  ||
        !DomainArgument.Initialize( "/DOMAIN:*" )   ||
        !CodepageArgument.Initialize( "/CODEPAGE:*" ) ||
        !SidLookupArgument.Initialize( "/SIDLOOKUP:*" ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );

        *ExitCode = 1;
        return FALSE;
    }

    //
    //  The ACL conversion utility is case-insensitive
    //
    ArgLex.SetCaseSensitive( FALSE );

    //  Put the arguments into the argument array

    if( !ArgArray.Put( &HelpArgument )          ||
        !ArgArray.Put( &ListArgument )          ||
        !ArgArray.Put( &DataFileArgument )      ||
        !ArgArray.Put( &LogFileArgument )       ||
        !ArgArray.Put( &DriveArgument )         ||
        !ArgArray.Put( &DomainArgument )        ||
        !ArgArray.Put( &CodepageArgument )      ||
        !ArgArray.Put( &ProgramNameArgument ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );

        *ExitCode = 1;
        return FALSE;
    }

    //
    //  Lexemize the command line.
    //
    if ( !ArgLex.PrepareToParse() ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );

        *ExitCode = 1;
        return FALSE;
    }

    //
    //      Parse the arguments.
    //
    if( !ArgLex.DoParsing( &ArgArray ) ) {


        DisplayMessage( MSG_CONV_INVALID_PARAMETER, ERROR_MESSAGE, "%W", InvalidArg = ArgLex.QueryInvalidArgument() );
        DELETE( InvalidArg );

        *ExitCode = 1;
        return FALSE;
    }


    //
    //      If the user requested help, give it.
    //
    if( HelpArgument.QueryFlag() ) {

        DisplayMessage( MSG_ACLCONV_USAGE );

        *ExitCode = 0;
        return FALSE;
    }

    //  The log file must be specified, and either the data
    //  file or the list argument (but not both) must be
    //  provided.
    //
    if( !LogFileArgument.IsValueSet()           ||
        ( !DataFileArgument.IsValueSet() &&
          !ListArgument.IsValueSet() )          ||
        ( DataFileArgument.IsValueSet() &&
          ListArgument.IsValueSet() ) ) {

        DisplayMessage( MSG_ACLCONV_USAGE );

        *ExitCode = 1;
        return FALSE;
    }

    // If the drive argument has been supplied, record it:
    //
    if( DriveArgument.IsValueSet() ) {

        _NewDrive = DriveArgument.GetPath()->QueryDevice();

        if( _NewDrive == NULL ) {

            DisplayMessage( MSG_INVALID_PARAMETER,
                            ERROR_MESSAGE,
                            "%W",
                            DriveArgument.GetPath()->GetPathString() );
            *ExitCode = 1;
            return FALSE;
        }

        // Validate the drive.
        //
        if( !RootDir.Initialize( _NewDrive ) ||
            !Backslash.Initialize( "\\" ) ||
            !RootDir.Strcat( &Backslash ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }

        DriveType = GetDriveTypeW( RootDir.GetWSTR() );

        switch ( DriveType ) {

        case DRIVE_FIXED:
        case DRIVE_REMOVABLE:

            // The drive type is acceptable.
            //
            break;

        case 0:
        case 1:
        case DRIVE_CDROM:
        case DRIVE_REMOTE:
        case DRIVE_RAMDISK:
        default:

            // The drive type is invalid.
            //
            DisplayMessage( MSG_ACLCONV_INVALID_DRIVE, ERROR_MESSAGE, "%W", _NewDrive );
            *ExitCode = 1;
            return FALSE;
        }
    }

    // If a domain name has been specified, remember it:
    //
    if( DomainArgument.IsValueSet() ) {

        if( (_DomainName = NEW DSTRING) == NULL ||
            !_DomainName->Initialize( DomainArgument.GetString() ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }
    }

    // If a source codepage has been specified, use it; otherwise,
    // use CP_OEMCP as default.
    //
    if( !CodepageArgument.IsValueSet() ) {

        _SourceCodepage = CP_OEMCP;

    } else {

        _SourceCodepage = CodepageArgument.QueryLong();

        if( !IsValidCodePage( _SourceCodepage ) ) {

            DisplayMessage( MSG_ACLCONV_BAD_CODEPAGE, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }
    }

    if( SidLookupArgument.IsValueSet() ) {

        _SidLookupTableName = SidLookupArgument.GetString()->QueryWSTR();
    }

    _IsInListMode = ListArgument.IsValueSet();

    if( _IsInListMode ) {

        // In list mode, only the Log File path need be present.
        //
        if( !_LogFilePath.Initialize( LogFileArgument.GetPath() ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }
    } else {

        // The object is not in list mode, so both the Data File
        // and Log File paths must be present.
        //
        if( !_DataFilePath.Initialize( DataFileArgument.GetPath() ) ||
            !_LogFilePath.Initialize( LogFileArgument.GetPath() ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = 1;
            return FALSE;
        }
    }


    if( !_SidCache.Initialize( 100 ) ) {

        return FALSE;
    }

    if (!_AclWorkSids.Initialize(1)) {

        return FALSE;
    }

    return TRUE;
}




BOOLEAN
ACLCONV::DetermineDataFileRevision(
    )
/*++

Routine Description:

    This method examines the data file to determine what revision
    of the Lanman BackAcc utility produced it.  It sets the private
    member variable _DataFileRevision.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.  _DataFileRevision is set
    appropriately.

--*/
{
    CHAR Buffer[RecognitionSize];
    ULONG BytesRead;

    // If the first four bytes of the file are the LM2.0 backacc signature,
    // assume the data file was produced by LM2.0 backacc.  LM2.1 backacc
    // data files are recognizable by the string "LM210 BACKACC" at
    // byte offset 4.


    _DataFileRevision = DataFileRevisionUnknown;

    if( _DataFileStream == NULL ||
        !_DataFileStream->ReadAt( (PBYTE)Buffer,
                                  RecognitionSize,
                                  0,
                                  STREAM_BEGINNING,
                                  &BytesRead ) ||
        BytesRead != RecognitionSize ) {

        return FALSE;
    }


    if( strncmp( Buffer, (PCHAR)&Lm20BackaccSignature, 4) == 0 ) {

        _DataFileRevision = DataFileRevisionLanman20;
        return TRUE;
    }

    if( strncmp( Buffer+Lm21BackaccSignatureOffset,
                 Lm21BackaccSignature,
                 Lm21BackaccSignatureLength ) == 0 ) {

        _DataFileRevision = DataFileRevisionLanman21;
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
ACLCONV::UpdateAndQueryCurrentLM21Name(
    IN  ULONG       DirectoryLevel,
    IN  PCSTR       NewComponent,
    OUT PWSTRING    CurrentName
    )
/*++

Routine Description:

    This function updates the current resource name while
    traversing the LM21 BackAcc data file.

Arguments:

    DirectoryLevel  --  Supplies the directory level of the
                        most-recently-encountered component.
                        (0 is the drive, 1 is the root directory,
                        2 is an element in the root directory, and
                        so forth.)
    NewComponent    --  Supplies the name of the most-recently-
                        encountered component.
    CurrentName     --  Receives the updated current resource name.

Return Value:

    TRUE upon successful completion.

--*/
{
    STATIC PDSTRING Components[256];
    STATIC PDSTRING BackSlash;
    STATIC ULONG CurrentLevel = 0;

    WCHAR ComponentBuffer[ MAX_RESOURCE_NAME_LENGTH ];
    ULONG i;

    // If BackSlash hasn't been initialized yet,
    // initialize it.
    //
    if( BackSlash == NULL ) {

        if( (BackSlash = NEW DSTRING) == NULL ||
            !BackSlash->Initialize( "\\" ) ) {

            return FALSE;
        }
    }

    if( DirectoryLevel == 0 ) {

        return( CurrentName->Initialize( "" ) );
    }

    while( CurrentLevel >= DirectoryLevel ) {

        // Trim off the last component of the path.
        //
        CurrentLevel--;
        DELETE( Components[CurrentLevel] );
    }


    // Now we're ready to add a new component to the end of the
    // current path.
    //
    if( DirectoryLevel != CurrentLevel + 1 ) {

        DebugPrint( "ACLCONV: skipped a level in name tree.\n" );
        return FALSE;
    }

    memset( ComponentBuffer, 0, sizeof( ComponentBuffer ) );

    if( (Components[CurrentLevel] = NEW DSTRING) == NULL ||
        !MultiByteToWideChar( _SourceCodepage,
                              0,
                              NewComponent,
                              strlen( NewComponent ),
                              ComponentBuffer,
                              MAX_RESOURCE_NAME_LENGTH ) ||
        !Components[CurrentLevel]->Initialize( ComponentBuffer ) ) {

        return FALSE;
    }

    CurrentLevel++;

    // Now copy the current path to the output string.
    //
    if( !CurrentName->Initialize( "" ) ) {

        return FALSE;
    }

    for( i = 0; i < CurrentLevel; i++ ) {

        // There's no backslash before the first component (the drive);
        // if the prefix ends in a backslash, don't add one.  Otherwise,
        // add a backslash.
        //
        if( i > 0 &&
            CurrentName->QueryChAt( CurrentName->QueryChCount() - 1 ) != '\\' &&
            !CurrentName->Strcat( BackSlash ) ) {

            return FALSE;
        }

        // Add the next component
        //
        if( !CurrentName->Strcat( Components[i] ) ) {

            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
ACLCONV::ReadNextAcl(
    OUT PINT        ExitCode,
    OUT PWSTRING    ResourceString,
    IN  ULONG       MaxEntries,
    OUT PULONG      AccessEntryCount,
    OUT PVOID       AccessEntries,
    OUT PUSHORT     AuditInfo
    )
/*++

Routine Description:

    This method reads the next ACL record from the data file.  The
    ACL record describes the resource and its associated Access Control
    Entries.

Arguments:

    ExitCode                --  Receives an error level if an error occurs.
    ResourceString          --  Receives the name of the resource.
    MaxEntries              --  Supplies the maximum number of entries
                                that will fit in the supplied buffer.
    AccessEntryCount        --  Receives the number of access entries read.
    AccessEntries           --  Receives the access entries.
    AuditInfo               --  Receives the Lanman 2.x audit information
                                for the resource.



Return Value:

    TRUE upon successful completion.  If the end of the file is
    reached without error, this method returns FALSE, with *ExitCode
    equal to zero.

--*/
{
    CHAR ResourceName[ MAX_RESOURCE_NAME_LENGTH ];
    WCHAR WideResourceName[ MAX_RESOURCE_NAME_LENGTH ];

    lm20_resource_info ResourceInfo;
    lm21_aclhdr Lm21Header;
    lm21_aclrec Lm21AclRec;
    ULONG BytesRead, TotalBytesRead;

    if( _DataFileStream == NULL ) {

        DebugAbort( "Data stream not set up.\n" );
        return FALSE;
    }


    switch( _DataFileRevision ) {

    case DataFileRevisionUnknown :

        DebugAbort( "Trying to read from unknown data file revision.\n" );
        *ExitCode = 1;
        return FALSE;

    case DataFileRevisionLanman20 :

        if( _NextReadOffset == 0 ) {

            // This is the first read, so we skip over the header
            // information.

            _NextReadOffset = LM20_BACKACC_HEADER_SIZE +
                                LM20_INDEX_SIZE * LM20_NINDEX;

        }

        if( !_DataFileStream->MovePointerPosition( _NextReadOffset,
                                                   STREAM_BEGINNING ) ) {

            *ExitCode = 1;
            return FALSE;
        }

        if( _DataFileStream->IsAtEnd() ) {

            // No more entries to read.

            *ExitCode = 0;
            return FALSE;
        }

        // Read the resource header information.

        if( !_DataFileStream->Read( (PBYTE)&ResourceInfo,
                                    LM20_RESOURCE_INFO_HEADER_SIZE,
                                    &BytesRead ) ||
            BytesRead != LM20_RESOURCE_INFO_HEADER_SIZE ) {

            *ExitCode = 1;
            return FALSE;
        }


        // Read the name and initialize ResourceString
        //
        memset( WideResourceName, 0, sizeof( WideResourceName ) );

        if( ResourceInfo.namelen > MAX_RESOURCE_NAME_LENGTH ||
            !_DataFileStream->Read( (PBYTE)ResourceName,
                                    ResourceInfo.namelen,
                                    &BytesRead ) ||
            BytesRead != ResourceInfo.namelen ||
            !MultiByteToWideChar( _SourceCodepage,
                                  0,
                                  ResourceName,
                                  strlen( ResourceName ),
                                  WideResourceName,
                                  MAX_RESOURCE_NAME_LENGTH ) ||
            !ResourceString->Initialize( WideResourceName ) ) {

            *ExitCode = 1;
            return FALSE;
        }

        // Read the access entries

        if( (ULONG)ResourceInfo.acc1_count > MaxEntries ||
            !_DataFileStream->Read( (PBYTE)AccessEntries,
                                    ResourceInfo.acc1_count *
                                        LM_ACCESS_LIST_SIZE,
                                    &BytesRead ) ||
            BytesRead != (ULONG)( ResourceInfo.acc1_count * LM_ACCESS_LIST_SIZE ) ) {

            *ExitCode = 1;
            return FALSE;
        }

        *AccessEntryCount = ResourceInfo.acc1_count;
        *AuditInfo = ResourceInfo.acc1_attr;

        _NextReadOffset += LM20_RESOURCE_INFO_HEADER_SIZE +
                            ResourceInfo.namelen +
                            ResourceInfo.acc1_count * LM_ACCESS_LIST_SIZE;

        return TRUE;

    case DataFileRevisionLanman21 :

        while( _NextReadOffset == 0 || _BytesRemainingInCurrentGroup == 0 ) {

            // The current offset is at the beginning of a group.  If
            // this also the end of the file, there are no more records
            // to read; otherwise, read the header of this group.

            if( !_DataFileStream->MovePointerPosition( _NextReadOffset,
                                                       STREAM_BEGINNING ) ) {

                *ExitCode = 1;
                return FALSE;
            }

            if( _DataFileStream->IsAtEnd() ) {

                // No more entries to read.

                *ExitCode = 0;
                return FALSE;
            }

            if( !_DataFileStream->Read( (PBYTE)&Lm21Header,
                                        LM21_ACLHDR_SIZE,
                                        &BytesRead ) ||
                BytesRead != LM21_ACLHDR_SIZE ) {

                *ExitCode = 1;
                return FALSE;
            }

            _NextReadOffset += LM21_ACLHDR_SIZE;
            _BytesRemainingInCurrentGroup = Lm21Header.NxtHdr -
                                            _NextReadOffset;
        }

        // Read the ACL Record

        if( !_DataFileStream->Read( (PBYTE)&Lm21AclRec,
                                    LM21_ACLREC_SIZE,
                                    &BytesRead ) ||
            BytesRead != LM21_ACLREC_SIZE ) {

            *ExitCode = 1;
            return FALSE;
        }

        TotalBytesRead = BytesRead;

        // Read the name and initialize ResourceString

        if( Lm21AclRec.NameBytes > MAX_RESOURCE_NAME_LENGTH ||
            !_DataFileStream->Read( (PBYTE)ResourceName,
                                    Lm21AclRec.NameBytes,
                                    &BytesRead ) ||
            BytesRead != (ULONG)Lm21AclRec.NameBytes ) {

            *ExitCode = 1;
            return FALSE;
        }

        if( !UpdateAndQueryCurrentLM21Name( Lm21AclRec.DirLvl,
                                            ResourceName,
                                            ResourceString ) ) {

            *ExitCode = 1;
            return FALSE;
        }


        TotalBytesRead += BytesRead;

        // Read the access entries:
        //
        if( Lm21AclRec.AclCnt == -1 ) {

            *AccessEntryCount = 0;
            *AuditInfo = 0;

        } else {

            if( (ULONG)Lm21AclRec.AclCnt > MaxEntries ||
                !_DataFileStream->Read( (PBYTE)AccessEntries,
                                         Lm21AclRec.AclCnt *
                                            LM_ACCESS_LIST_SIZE,
                                        &BytesRead ) ||
                BytesRead != (ULONG)( Lm21AclRec.AclCnt * LM_ACCESS_LIST_SIZE ) ) {

                *ExitCode = 1;
                return FALSE;
            }

            TotalBytesRead += BytesRead;

            *AccessEntryCount = Lm21AclRec.AclCnt;
            *AuditInfo = Lm21AclRec.AuditAttrib;
        }


        // Check that this read didn't overflow the current group--if
        // it did, the file format is not as expected.

        if( TotalBytesRead > _BytesRemainingInCurrentGroup )  {

            *ExitCode = 1;
            return FALSE;
        }

        _NextReadOffset += TotalBytesRead;
        _BytesRemainingInCurrentGroup -= TotalBytesRead;


        return TRUE;

    default:

        *ExitCode = 1;
        return FALSE;

    }
}

BOOLEAN
ACLCONV::ReadAclWorkSids(
    )
{
    WORD n_entries;
    ULONG n_read;
    ULONG i;
    USHORT name_len;
    WCHAR name[64];
    DSTRING Name;
    PSID pSid;
    ULONG sid_len;

    DSTRING Domain;

    if (!Domain.Initialize("UserConv")) {
        DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
        return FALSE;
    }

    if (!_AclWorkStream->Read((PUCHAR)&n_entries, sizeof(WORD), &n_read) ||
        n_read != sizeof(WORD)) {
        DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
            "%W", _AclWorkPath.GetPathString());
        return FALSE;
    }

    if (!_AclWorkSids.Initialize(n_entries)) {
        DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
        return FALSE;
    }

    //
    // Read each entry from the aclwork.dat file and add it to this
    // sid cache.
    //

    for (i = 0; i < n_entries; ++i) {

        // read the length of the name

        if (!_AclWorkStream->Read((PUCHAR)&name_len, sizeof(name_len),
            &n_read) || n_read != sizeof(name_len)) {

            DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
                "%W", _AclWorkPath.GetPathString());

            return FALSE;
        }

        // read the name

        if (!_AclWorkStream->Read((PUCHAR)name, name_len, &n_read) ||
            n_read != name_len) {

            DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
                "%W", _AclWorkPath.GetPathString());

            return FALSE;
        }
        name[name_len / sizeof(WCHAR)] = UNICODE_NULL;

        if (!Name.Initialize(name)) {
            DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
            return FALSE;
        }

        if (!_AclWorkStream->Read((PUCHAR)&sid_len, sizeof(sid_len), &n_read) ||
            n_read != sizeof(sid_len)) {

            DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
                "%W", _AclWorkPath.GetPathString());

            return FALSE;
        }

        pSid = (PSID)MALLOC(sid_len);
        if (NULL == pSid) {
            DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);

            return FALSE;
        }

        if (!_AclWorkStream->Read((PUCHAR)pSid, sid_len, &n_read) ||
            n_read != sid_len) {

            DisplayMessage(MSG_ACLCONV_DATAFILE_BAD_FORMAT, ERROR_MESSAGE,
                "%W", _AclWorkPath.GetPathString());

            return FALSE;
        }

        DebugAssert(RtlValidSid(pSid));

        if (!_AclWorkSids.CacheSid( &Domain, &Name, pSid, sid_len)) {
            DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
            return FALSE;
        }

        FREE(pSid);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\asrsfgen\log.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    log.cpp

Abstract:
    
    This module contains routines to log errors, warnings and info in the asr 
    log file at %systemroot%\repair\asr.log

Author:

    Guhan Suriyanarayanan   (guhans)    10-Jul-2000

Environment:

    User-mode only.

Revision History:

    10-Jul-2000 guhans
        Initial creation

--*/

#include <stdio.h>
#include <windows.h>
#include <assert.h>
#include "log.h"

#define ASRSFGEN_ASR_ERROR_FILE_PATH  L"%SystemRoot%\\repair\\asr.err"
#define ASRSFGEN_ASR_LOG_FILE_PATH    L"%SystemRoot%\\repair\\asr.log"


//
// ----
// Data global to this module
// ----
//
BOOL Gbl_IsAsrEnabled = FALSE;
PWSTR Gbl_AsrErrorFilePath = NULL;
HANDLE Gbl_AsrLogFileHandle = NULL;


//
// ----
// Function implementations
// ----
//
VOID
AsrpLogMessage(
    IN CONST _MesgLevel Level,
    IN CONST PCSTR Message
    ) 

/*++

Routine Description:
    
    Logs the message to the asr log file, and the asr error file if needed. 

    Note that AsrpInitialiseLogFile must have been called once before this 
    routine is used.

Arguments:

    Level - An enum specifying the level of the message being logged.  If 
            Level is set to s_Warning or s_Error, the Message is logged to the
            asr error file in addition to the asr log file.

    Message - The Message being logged.  This routine will add in the time-
            stamp at the beginning of each message.

Return Values:

    None.  If the log file couldn't be found, the message isn't logged.

--*/

{
    SYSTEMTIME Time;
    DWORD bytesWritten = 0;
    char buffer[4196];
    GetLocalTime(&Time);

    //
    // This needs to be fixed by the year 2100.
    //
    sprintf(buffer, "[%02hu%02hu%02hu %02hu%02hu%02hu sfgen] %s%s\r\n",
        Time.wYear % 2000, Time.wMonth, Time.wDay, 
        Time.wHour, Time.wMinute, Time.wSecond,
        ((s_Error == Level) ? "(ERROR) " :
            (s_Warning == Level ? "(warning) " : "")),
        Message
        );

    OutputDebugStringA(buffer);

    if (Gbl_AsrLogFileHandle) {
        WriteFile(Gbl_AsrLogFileHandle,
            buffer,
            (strlen(buffer) * sizeof(char)),
            &bytesWritten,
            NULL
            );
    }

    //
    // If this is a fatal error, we need to add to the error log.
    //
    if (((s_Error == Level) || (s_Warning == Level)) && 
        (Gbl_AsrErrorFilePath)
        ) {

        WCHAR buffer2[4196];

        HANDLE hFile = NULL;

        //
        // Open the error log
        //
        hFile = CreateFileW(
            Gbl_AsrErrorFilePath,           // lpFileName
            GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,                           // lpSecurityAttributes
            OPEN_ALWAYS,                  // dwCreationFlags
            FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes
            NULL                            // hTemplateFile
            );
        if ((!hFile) || (INVALID_HANDLE_VALUE == hFile)) {
            return;
        }

        wsprintf(buffer2, L"\r\n[%04hu/%02hu/%02hu %02hu:%02hu:%02hu AsrSFGen] %ws%S\r\n",
            Time.wYear, Time.wMonth, Time.wDay, 
            Time.wHour, Time.wMinute, Time.wSecond,
            ((s_Error == Level) ? L"(ERROR) " :
                (s_Warning == Level ? L"(warning) " : L"")),
            Message
            );
        //
        // Move to the end of file
        //
        SetFilePointer(hFile, 0L, NULL, FILE_END);

        //
        // Add our error string
        //
        WriteFile(hFile,
            buffer2,
            (wcslen(buffer2) * sizeof(WCHAR)),
            &bytesWritten,
            NULL
            );

        //
        // And we're done
        // 
        CloseHandle(hFile);
    }
}


VOID
AsrpPrintDbgMsg(
    IN CONST _MesgLevel Level,
    IN CONST PCSTR FormatString,
    ...
    )

/*++

Description:

    This prints a debug message AND makes the appropriate entries in the log 
    and error files.

Arguments:

    Level - Message Level (info, warning or error)

    FormatString - Formatted Message String to be printed.  The expanded 
            string should fit in a buffer of 4096 characters (including the
            terminating null character).

Return Values:
    
    None

--*/

{
    char str[4096];     // the message better fit in this
    va_list arglist;

    va_start(arglist, FormatString);
    wvsprintfA(str, FormatString, arglist);
    va_end(arglist);

    AsrpLogMessage(Level, str);
}


PWSTR   // must be freed by caller
AsrpExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    )

/*++

Routine Description:

    Expands any environment variables in the original string, replacing them
    with their defined values, and returns a pointer to a buffer containing 
    the result.

Arguments:

    OriginalString - Pointer to a null-terminated string that contains 
            environment variables of the form %variableName%.  For each such 
            reference, the %variableName% portion is replaced with the current
            value of that environment variable.  
            
            The replacement rules are the same as those used by the command 
            interpreter.  Case is ignored when looking up the environment-
            variable name.  If the name is not found, the %variableName% 
            portion is left undisturbed. 

Return Values:

    If this routine succeeds, the return value is a pointer to a buffer 
            containing a copy of OriginalString after all environment-variable
            name substitutions have been performed.  The caller is responsible
            for de-allocating this memory using HeapFree(GetProcessHeap(),...)
            when it is no longer needed.

    If the function fails, the return value is NULL. To get extended error 
            information, call GetLastError. 

--*/

{
    BOOL result = FALSE;

    UINT cchRequiredSize = 0,
        cchSize = MAX_PATH + 1;    // start with a reasonable default

    PWSTR expandedString = NULL;
    
    DWORD status = ERROR_SUCCESS;
    
    HANDLE hHeap = GetProcessHeap();

    //
    // Allocate some memory for the destination string
    // 
    expandedString = (PWSTR) HeapAlloc(
        hHeap, 
        HEAP_ZERO_MEMORY, 
        (cchSize * sizeof(WCHAR))
        );
    ErrExitCode(!expandedString, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Try expanding.  If the buffer isn't big enough, we'll re-allocate.
    //
    cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
        expandedString,
        cchSize 
        );

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        HeapFree(hHeap, 0L, expandedString);
        cchSize = cchRequiredSize + 1;

        expandedString = (PWSTR) HeapAlloc(
            hHeap, 
            HEAP_ZERO_MEMORY, 
            (cchSize * sizeof(WCHAR))
            );
        ErrExitCode(!expandedString, status, ERROR_NOT_ENOUGH_MEMORY);

        cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
            expandedString, 
            cchSize 
            );

        if (cchRequiredSize > cchSize) {
            SetLastError(ERROR_BAD_ENVIRONMENT);
        }

    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough 
        // even on the second try.  
        //
        if (expandedString) {
            HeapFree(hHeap, 0L, expandedString);
            expandedString = NULL;
        }
    }

EXIT:

    return expandedString;
}


VOID
AsrpInitialiseErrorFile(
    VOID
    ) 

/*++

Description:

    Creates an empty ASR error file at %systemroot%\repair\asr.err, and 
    initialises Gbl_AsrErrorFilePath with the full path to asr.err.  This 
    routine must be called once before AsrPrintDbgMsg is used.

Arguments:

    None

Return Values:
    
    None

--*/

{
    HANDLE errorFileHandle = NULL;

    //
    // Get full path to the error file.
    //
    Gbl_AsrErrorFilePath = AsrpExpandEnvStrings(ASRSFGEN_ASR_ERROR_FILE_PATH);
    if (!Gbl_AsrErrorFilePath) {
        return;
    }

    //
    // Create an empty file (append to it if it already exists), and close it
    // immediately
    //
    errorFileHandle = CreateFileW(
        Gbl_AsrErrorFilePath,           // lpFileName
        GENERIC_WRITE,                  // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                           // lpSecurityAttributes
        OPEN_ALWAYS,                  // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );
    if ((errorFileHandle) && (INVALID_HANDLE_VALUE != errorFileHandle)) {
        CloseHandle(errorFileHandle);
    }
}


VOID
AsrpInitialiseLogFiles(
    VOID
    )

/*++

Description:

    This creates an ASR log file at %systemroot%\repair\asr.log, and 
    initialises Gbl_AsrLogFileHandle.  It also initialises the ASR error file 
    by calling AsrInitialiseErrorFile().
    
    This routine must be called once before AsrPrintDbgMsg is used.

Arguments:

    None

Return Values:
    
    None

--*/

{
    PWSTR asrLogFilePath = NULL;
    HANDLE hHeap = GetProcessHeap();
    DWORD bytesWritten;

    AsrpInitialiseErrorFile();

    Gbl_AsrLogFileHandle = NULL;
    //
    // Get full path to the error file.
    //
    asrLogFilePath = AsrpExpandEnvStrings(ASRSFGEN_ASR_LOG_FILE_PATH);
    if (!asrLogFilePath) {
        return;
    }

    //
    // Create an empty file (over-write it if it already exists).
    //
    Gbl_AsrLogFileHandle = CreateFileW(
        asrLogFilePath,           // lpFileName
        GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode: nobody else should write to the log file while we are
        NULL,                           // lpSecurityAttributes
        OPEN_ALWAYS,                    // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes: write through so we flush
        NULL                            // hTemplateFile
        );

    if ((Gbl_AsrLogFileHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrLogFileHandle)) {
        //
        // Move to the end of file
        //
        SetFilePointer(Gbl_AsrLogFileHandle, 0L, NULL, FILE_END);
        WriteFile(Gbl_AsrLogFileHandle, "\r\n",
            (strlen("\r\n") * sizeof(char)), &bytesWritten,NULL);
        AsrpPrintDbgMsg(s_Info, "****** Entering asrsfgen.exe.  ASR log at %ws", asrLogFilePath);
    }
    else {
        AsrpPrintDbgMsg(s_Error, 
            "******* Unable to create/open ASR log file at %ws (0x%x)",
            asrLogFilePath, GetLastError()
           );
    }

    if (asrLogFilePath) {
        HeapFree(hHeap, 0L, asrLogFilePath);
        asrLogFilePath = NULL;
    }
}


VOID
AsrpCloseLogFiles(
    VOID
    ) 

/*++

Description:

    This closes the ASR error and log file at %systemroot%\repair\, and 
    frees the global variables associated with them.  

    This must be called during clean-up.  AsrpPrintDbgMesg() will have no 
    effect after this routine is called.


Arguments:

    None

Return Values:
    
    None

--*/

{
    AsrpPrintDbgMsg(s_Info, "****** Exiting asrsfgen.exe.");

    //
    // Clean up global values
    // 
    if (Gbl_AsrErrorFilePath) {
        HeapFree(GetProcessHeap(), 0L, Gbl_AsrErrorFilePath);
        Gbl_AsrErrorFilePath = NULL;
    }

    if ((Gbl_AsrLogFileHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrLogFileHandle)) {
        CloseHandle(Gbl_AsrLogFileHandle);
        Gbl_AsrLogFileHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\asrsfgen\critdrv.h ===
//-------------------------------------------------------------------
//
// critical drivers suppot
//

typedef struct _WSTRING_DATA_LINK
	{
	struct _WSTRING_DATA_LINK *m_psdlNext;
	WCHAR rgwc[2040];
	} WSTRING_DATA_LINK;


// class string data
class CWStringData
	{
public:
	// @cmember constructor
	CWStringData();

	// @cmember destructor
	~CWStringData();

	// @cmember allocate a string
	LPWSTR AllocateString(unsigned cwc);

	// @cmember copy a string
	LPWSTR CopyString(LPCWSTR wsz);

private:
	// @cmember allocate a new string data link
	void AllocateNewLink();

	// @cmember	current link
	WSTRING_DATA_LINK *m_psdlCur;

	// @cmember offset in current link for next string
	unsigned m_ulNextString;

	// @cmember first link
	WSTRING_DATA_LINK *m_psdlFirst;
	};



// list of critical volumes
class CVolumeList
	{
public:
	// constructor
	CVolumeList();

	// destructor
	~CVolumeList();

	// add a path to the volume list
	void AddPath(LPWSTR wszPath);

	// @cmember add a file to the volume list
	void AddFile(LPWSTR wszFile);

	// @cmember obtain list of volumes
	LPWSTR GetVolumeList();

private:
	enum
		{
		// amount to grow paths array by
		x_cwszPathsInc = 8,

		// amount to grow volumes array by
		x_cwszVolumesInc = 4
		};

	// determine if a path is a volume
	BOOL TryAddVolumeToList(LPCWSTR wszPath, BOOL fVolumeRoot);

	// determine if path is in the list; if not add it to list
	BOOL AddPathToList(LPWSTR wszPath);

	// @cmember determine if a volume is in the list; if not add it to the list
	BOOL AddVolumeToList(LPCWSTR wszVolume);

	// @cmember get volume from the path
	void GetVolumeFromPath(LPCWSTR wsz, LPWSTR wszVolumeName);

	// @cmember cached strings
	CWStringData m_sd;

	// volumes encountered so far
	LPCWSTR *m_rgwszVolumes;

	// # of volumes allocate
	unsigned m_cwszVolumes;

	// max # of volumes in array
	unsigned m_cwszVolumesMax;

	// paths encountered so far
	LPCWSTR *m_rgwszPaths;

	// # of paths encountered so far
	unsigned m_cwszPaths;

	// @cmember max # of paths in array
	unsigned m_cwszPathsMax;
	};


// FRS entry points
typedef DWORD ( WINAPI *PF_FRS_ERR_CALLBACK )( CHAR *, DWORD );
typedef DWORD ( WINAPI *PF_FRS_INIT )( PF_FRS_ERR_CALLBACK, DWORD, PVOID * );
typedef DWORD ( WINAPI *PF_FRS_DESTROY )( PVOID *, DWORD, HKEY *, LPDWORD, CHAR *) ;
typedef DWORD ( WINAPI *PF_FRS_GET_SETS )( PVOID );
typedef DWORD ( WINAPI *PF_FRS_ENUM_SETS )( PVOID, DWORD, PVOID * );
typedef DWORD ( WINAPI *PF_FRS_IS_SYSVOL )( PVOID, PVOID, BOOL * );
typedef DWORD ( WINAPI *PF_FRS_GET_PATH )( PVOID, PVOID, DWORD *, WCHAR * ) ;
typedef DWORD ( WINAPI *PF_FRS_GET_OTHER_PATHS)(PVOID, PVOID, DWORD *, WCHAR *, DWORD *, WCHAR *);

// iterate over frs drives
class CFRSIter
	{
public:
	// constructor
	CFRSIter();

	// destructor
	~CFRSIter();

	// initialization routine
	void Init();

	// initialize iterator
	BOOL BeginIteration();

	// end iteration
	void EndIteration();

	// obtain path to next replication set
	LPWSTR GetNextSet(BOOL fSkipToSysVol, LPWSTR *pwszPaths);

private:
	// cleanup frs backup restore context
	void CleanupIteration();

	enum
		{
		x_IterNotStarted,
		x_IterStarted,
		x_IterComplete
		};

	// is this initialized
	BOOL m_fInitialized;
	HINSTANCE  m_hLib;
	DWORD ( WINAPI *m_pfnFrsInitBuRest )( PF_FRS_ERR_CALLBACK, DWORD, PVOID * );
	DWORD ( WINAPI *m_pfnFrsEndBuRest )( PVOID *, DWORD, HKEY *, LPDWORD, CHAR *) ;
	DWORD ( WINAPI *m_pfnFrsGetSets )( PVOID );
	DWORD ( WINAPI *m_pfnFrsEnumSets )( PVOID, DWORD, PVOID * );
	DWORD ( WINAPI *m_pfnFrsIsSetSysVol )( PVOID, PVOID, BOOL * );
	DWORD ( WINAPI *m_pfnFrsGetPath )( PVOID, PVOID, DWORD *, WCHAR * ) ;
	DWORD ( WINAPI *m_pfnFrsGetOtherPaths) ( PVOID, PVOID, DWORD *, WCHAR *, DWORD *, WCHAR * );

	// has iteration been started
	int m_stateIteration;

	// current set iterated
	unsigned m_iset;

	// context for iteration
	PVOID m_frs_context;
	};



LPWSTR pFindCriticalVolumes();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\asrsfgen\log.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    log.h

Abstract:
    
    Header file for routines to log errors, warnings and info in the asr 
    log file at %systemroot%\repair\asr.log

Author:

    Guhan Suriyanarayanan   (guhans)    10-Jul-2000

Environment:

    User-mode only.

Revision History:

    10-Jul-2000 guhans
        Initial creation

--*/

#ifndef _INC_ASR_SF_GEN__LOG_H_
#define _INC_ASR_SF_GEN__LOG_H_

typedef enum __MesgLevel {
    s_Info = 0,
    s_Warning,
    s_Error
} _MesgLevel;


//
// Functions for logging error messages
//

VOID
AsrpInitialiseLogFiles(
    VOID
    );

VOID
AsrpCloseLogFiles(
    VOID
    );

VOID
AsrpPrintDbgMsg(
    IN CONST _MesgLevel Level,
    IN CONST PCSTR FormatString,
    ...
    );


//
//  Macro Description:
//      This macro wraps calls that are expected to return SUCCESS (retcode).
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Result of some function call or conditional expression.
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // An ErrorCode specific to the error and calling function
//
#define ErrExitCode(ErrorCondition, LocalStatus, ErrorCode) {           \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        if ((BOOL) ErrorCode) {                                         \
            AsrpPrintDbgMsg(s_Error, "%S(%lu): ErrorCode: %lu, GetLastError:%lu\n", \
                __FILE__, __LINE__, ErrorCode, GetLastError());         \
        }                                                               \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}


#endif // _INC_ASR_SF_GEN__LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\asrsfgen\asrsfgen.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asrsfgen.cpp

Abstract:

    Utility program to generate an ASR state-file (asr.sif)

Author:

    Guhan Suriyanarayanan   (guhans)    10-Jul-2000

Environment:

    User-mode only.

Revision History:

    10-Jul-2000 guhans
        Initial creation

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <winasr.h>
#include "critdrv.h"
#include "log.h"


BOOL
pAcquirePrivilege(
    IN CONST PCWSTR szPrivilegeName
    )
{
    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );

    if (!bResult) {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL, szPrivilegeName, &luid);
    if (!bResult) {
        CloseHandle(hToken);
        return FALSE;
    }

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );

    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    if (!bResult) {
        AsrpPrintDbgMsg(s_Warning, "AdjustTokenPrivileges for %ws failed (%lu)", 
            szPrivilegeName, 
            GetLastError()
            );
     }


    CloseHandle(hToken);
    return bResult;
}


int __cdecl
wmain(
    int       argc,
    WCHAR   *argv[],
    WCHAR   *envp[]
    )

/*++

Routine Description:
    
    Entry point to asrsfgen.exe.  Generates an asr.sif file using the ASR API.

    Takes an optional command-line parameter to specify the location where the
    asr.sif is to be generated.  The default location is 
    %systemroot%\repair\asr.sif.

Arguments:

    argc - Number of command-line parameters used to invoke the app

    argv - The command-line parameters as an array of strings

    envp - The process environment block, not currently used

Return Values:

    If the function succeeds, the exit code is zero.

    If the function fails, the exit code is a win-32 error code.

--*/

{

    DWORD_PTR asrContext = 0;
    
    LPWSTR szCriticalVolumes = NULL;
    
    BOOL bResult = FALSE;

    int iReturn = 0;

    AsrpInitialiseLogFiles();

    AsrpPrintDbgMsg(s_Info, "Creating ASR state file at %ws",
        (argc > 1 ? argv[1] : L"default location (%systemroot%\\repair\\asr.sif)")
        );

    //
    // We need to acquire the backup privileges to create asr.sif
    //
    if (!pAcquirePrivilege(SE_BACKUP_NAME)) {
        AsrpPrintDbgMsg(s_Error, "Could not get backup privilege (%lu)", GetLastError());
        return ERROR_PRIVILEGE_NOT_HELD;
    }
    

    //
    // Get the critical volume list
    //
    szCriticalVolumes = pFindCriticalVolumes();

    if (!szCriticalVolumes) {
        AsrpPrintDbgMsg(s_Warning, "Critical Volume List is NULL");
    }

    //
    // Create the state file
    //
    bResult = AsrCreateStateFile(
        (argc > 1 ? argv[1] : NULL),    // sif path
        L"ASR Sif Generation Test Application v 0.1",    // Provider name
        TRUE,                           // auto-extend
        szCriticalVolumes,              // list of critical volumes
        &asrContext
        );

    if (!bResult) {
        AsrpPrintDbgMsg(s_Error, "Could not create state file (%lu == 0x%x)", GetLastError(), GetLastError());
        iReturn = 1;
    }
    else {
        AsrpPrintDbgMsg(s_Info, "ASR state file successfully created");
    }


    //
    // We're done with these, clean them up
    //
    if (szCriticalVolumes) {
      delete szCriticalVolumes;
      szCriticalVolumes = NULL;
    }
 
    AsrFreeContext(&asrContext);
    AsrpCloseLogFiles();

   return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\asrsfgen\critdrv.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    critdrv.cpp

Abstract:
    
    This module contains routines create a list of the critical volumes on a 
    system.  This is lifted directly from base\fs\utils\ntback50\ui.

Author:

    Brian Berkowitz   (brianb)    10-Mar-2000

Environment:

    User-mode only.

Revision History:

    10-Mar-2000 brianb
        Initial creation

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <objbase.h>
#include <initguid.h>
#include <frsapip.h>
#include <critdrv.h>



// FRS iteration class.  Used to iterate through replica sets to
// determine the paths for these replica sets
// constructor
CFRSIter::CFRSIter() :
    m_fInitialized(FALSE),
    m_hLib(NULL),
    m_pfnFrsInitBuRest(NULL),
    m_pfnFrsEndBuRest(NULL),
    m_pfnFrsGetSets(NULL),
    m_pfnFrsEnumSets(NULL),
    m_pfnFrsIsSetSysVol(NULL),
    m_pfnFrsGetPath(NULL),
    m_pfnFrsGetOtherPaths(NULL),
    m_stateIteration(x_IterNotStarted)
    {
    }

// destructor
CFRSIter::~CFRSIter()
    {
    if (m_stateIteration == x_IterStarted)
        CleanupIteration();

    if (m_hLib)
        FreeLibrary(m_hLib);
    }

// initialize entry points and load library
void CFRSIter::Init()
    {
    if (m_fInitialized)
        return;

    // load library
    m_hLib = LoadLibrary(L"ntfrsapi.dll");
    if (m_hLib)
        {
        // assign etntry points
        m_pfnFrsInitBuRest = (PF_FRS_INIT) GetProcAddress(m_hLib, "NtFrsApiInitializeBackupRestore");
        m_pfnFrsEndBuRest = (PF_FRS_DESTROY) GetProcAddress(m_hLib, "NtFrsApiDestroyBackupRestore");
        m_pfnFrsGetSets = (PF_FRS_GET_SETS) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSets");
        m_pfnFrsEnumSets = (PF_FRS_ENUM_SETS) GetProcAddress(m_hLib, "NtFrsApiEnumBackupRestoreSets");
        m_pfnFrsIsSetSysVol = (PF_FRS_IS_SYSVOL) GetProcAddress(m_hLib, "NtFrsApiIsBackupRestoreSetASysvol");
        m_pfnFrsGetPath = (PF_FRS_GET_PATH) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSetDirectory");
        m_pfnFrsGetOtherPaths = (PF_FRS_GET_OTHER_PATHS) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSetPaths");
        if (m_pfnFrsInitBuRest == NULL ||
            m_pfnFrsEndBuRest == NULL ||
            m_pfnFrsGetSets == NULL ||
            m_pfnFrsEnumSets == NULL ||
            m_pfnFrsIsSetSysVol == NULL ||
            m_pfnFrsGetOtherPaths == NULL ||
            m_pfnFrsGetPath == NULL)
            {
            // if we can't get to any entry point, free library and
            // fail operation
            FreeLibrary(m_hLib);
            m_hLib = NULL;
            }
        }

    // indicate that operation is successful
    m_fInitialized = TRUE;
    }


// initialize the iterator.  Return FALSE if iterator is known to be empty
//
BOOL CFRSIter::BeginIteration()
    {
    ASSERT(m_stateIteration == x_IterNotStarted);
    DWORD status;
    if (m_hLib == NULL)
        {
        // if we are not initialized, then there is nothing to iterate
        // over
        m_stateIteration = x_IterComplete;
        return FALSE;
        }

    // initialize FRS backup restore apis
    status = m_pfnFrsInitBuRest
                    (
                    NULL,
                    NTFRSAPI_BUR_FLAGS_NORMAL|NTFRSAPI_BUR_FLAGS_BACKUP,
                    &m_frs_context
                    );

    if (status != ERROR_SUCCESS)
        {
        // if this fails then we are done
        m_stateIteration = x_IterComplete;
        return FALSE;
        }

    // indicate that we started the iteration
    m_stateIteration = x_IterStarted;
    status = m_pfnFrsGetSets(m_frs_context);
    if (status != ERROR_SUCCESS)
        {
        // if there are no sets, then indicate we are done
        CleanupIteration();
        return FALSE;
        }

    // start at first set
    m_iset = 0;
    return TRUE;
    }

// cleanup iteration after scanning the last element
void CFRSIter::CleanupIteration()
    {
    m_pfnFrsEndBuRest(&m_frs_context, NTFRSAPI_BUR_FLAGS_NONE, NULL, NULL, NULL);
    m_stateIteration = x_IterComplete;
    }


// get next iteration set returning the path to the set
// NULL indicates end of iteration
// If fSkipToSysVol is TRUE then ignore non SysVol replication sets
LPWSTR CFRSIter::GetNextSet(BOOL fSkipToSysVol, LPWSTR *pwszPaths)
    {
    ASSERT(pwszPaths);
    ASSERT(m_stateIteration != x_IterNotStarted);
    if (m_stateIteration == x_IterComplete)
        // if iteration is complete, then we are done
        return NULL;

    PVOID frs_set;

    while(TRUE)
        {
        // get a set
        DWORD status = m_pfnFrsEnumSets(m_frs_context, m_iset, &frs_set);
        if (status != ERROR_SUCCESS)
            {
            // if this fails, then we are done
            CleanupIteration();
            return NULL;
            }

        if (fSkipToSysVol)
            {
            // we are looking for system volumes
            BOOL fSysVol;

            // test whether this is a system volume
            status = m_pfnFrsIsSetSysVol(m_frs_context, frs_set, &fSysVol);
            if (status != ERROR_SUCCESS)
                {
                // if this operation fails, terminate iteration
                CleanupIteration();
                return NULL;
                }

            if (!fSysVol)
                {
                // if not a system volume, then skip to the next
                // replica set
                m_iset++;
                continue;
                }
            }


        // scratch pad for path
        WCHAR wsz[MAX_PATH];
        DWORD cbPath = MAX_PATH * sizeof(WCHAR);

        // get path to root of the replica set
        status = m_pfnFrsGetPath
            (
            m_frs_context,
            frs_set,
            &cbPath,
            wsz
            );

        WCHAR *wszNew = NULL;
        // allocate memory for root
        if (status == ERROR_SUCCESS || status == ERROR_INSUFFICIENT_BUFFER)
            {
            wszNew = new WCHAR[cbPath/sizeof(WCHAR)];

            // if allocation fails, then throw OOM
            if (wszNew == NULL)
                throw E_OUTOFMEMORY;

            if (status == ERROR_SUCCESS)
                // if the operation was successful, then copy
                // path into memory
                memcpy(wszNew, wsz, cbPath);
            else
                {
                // otherwise redo the operation
                status = m_pfnFrsGetPath
                    (
                    m_frs_context,
                    frs_set,
                    &cbPath,
                    wszNew
                    );

                if (status != ERROR_SUCCESS)
                    {
                    // if operation failed then second time, then
                    // delete allocated memory and terminate iteration
                    delete wszNew;
                    CleanupIteration();
                    return NULL;
                    }
                }
            }
        else
            {
            // if operation failed due to any error other than
            // insufficient buffer, then terminate the iteration
            CleanupIteration();
            return NULL;
            }


        // scratch pad for filters
        WCHAR wszFilter[MAX_PATH];
        DWORD cbFilter = MAX_PATH * sizeof(WCHAR);

        // length of scratch pad for paths
        cbPath = MAX_PATH * sizeof(WCHAR);

        // obtain other paths
        status = m_pfnFrsGetOtherPaths
            (
            m_frs_context,
            frs_set,
            &cbPath,
            wsz,
            &cbFilter,
            wszFilter
            );

        WCHAR *wszNewPaths = NULL;
        WCHAR *wszNewFilter = NULL;
        if (status == ERROR_SUCCESS || status == ERROR_INSUFFICIENT_BUFFER)
            {
            // allocate space for paths
            wszNewPaths = new WCHAR[cbPath/sizeof(WCHAR)];

            // allocate space for filters
            wszNewFilter = new WCHAR[cbFilter/sizeof(WCHAR)];
            if (wszNew == NULL || wszFilter == NULL)
                {
                // if any allocation fails, then throw OOM
                delete wszNew;
                throw E_OUTOFMEMORY;
                }

            if (status == ERROR_SUCCESS)
                {
                // if operation was successful, then copy
                // in allocated paths
                memcpy(wszNewPaths, wsz, cbPath);
                memcpy(wszNewFilter, wszFilter, cbFilter);
                }
            else
                {
                status = m_pfnFrsGetOtherPaths
                    (
                    m_frs_context,
                    frs_set,
                    &cbPath,
                    wszNew,
                    &cbFilter,
                    wszNewFilter
                    );

                if (status != ERROR_SUCCESS)
                    {
                    delete wszNew;
                    delete wszNewFilter;
                    CleanupIteration();
                    return NULL;
                    }
                }
            }
        else
            {
            // if any error other than success or INSUFFICENT_BUFFER
            // then terminate iteration
            CleanupIteration();
            return NULL;
            }

        // delete allocated filter
        delete wszNewFilter;

        // set iteration to next set
        m_iset++;

        // return pointer to paths
        *pwszPaths = wszNewPaths;

        // return path of root of replicated set
        return wszNew;
        }
    }


// terminate iteration, cleaning up anything that needs to be
// cleaned up
//
void CFRSIter::EndIteration()
    {
    ASSERT(m_stateIteration != x_IterNotStarted);
    if (m_stateIteration == x_IterStarted)
        CleanupIteration();

    // indicate that iteration is no longer in progress
    m_stateIteration = x_IterNotStarted;
    }

// constructor for string data structure
CWStringData::CWStringData()
    {
    m_psdlFirst = NULL;
    m_psdlCur = NULL;
    }

// destructor
CWStringData::~CWStringData()
    {
    while(m_psdlFirst)
        {
        WSTRING_DATA_LINK *psdl = m_psdlFirst;
        m_psdlFirst = m_psdlFirst->m_psdlNext;
        delete psdl;
        }
    }

// allocate a new link
void CWStringData::AllocateNewLink()
    {
    WSTRING_DATA_LINK *psdl = new WSTRING_DATA_LINK;
    if (psdl == NULL)
        throw E_OUTOFMEMORY;

    psdl->m_psdlNext = NULL;
    if (m_psdlCur)
        {
        ASSERT(m_psdlFirst);
        m_psdlCur->m_psdlNext = psdl;
        m_psdlCur = psdl;
        }
    else
        {
        ASSERT(m_psdlFirst == NULL);
        m_psdlFirst = m_psdlCur = psdl;
        }

    m_ulNextString = 0;
    }

// allocate a string
LPWSTR CWStringData::AllocateString(unsigned cwc)
    {
    ASSERT(cwc <= sizeof(m_psdlCur->rgwc));

    if (m_psdlCur == NULL)
        AllocateNewLink();

    if (sizeof(m_psdlCur->rgwc) <= (cwc + 1 + m_ulNextString) * sizeof(WCHAR))
        AllocateNewLink();

    unsigned ulOff = m_ulNextString;
    m_ulNextString += cwc + 1;
    return m_psdlCur->rgwc + ulOff;
    }

// copy a string
LPWSTR CWStringData::CopyString(LPCWSTR wsz)
    {
    unsigned cwc = (wsz == NULL) ? 0 : wcslen(wsz);
    LPWSTR wszNew = AllocateString(cwc);
    memcpy(wszNew, wsz, cwc * sizeof(WCHAR));
    wszNew[cwc] = '\0';
    return wszNew;
    }


// constructor for volume list
CVolumeList::CVolumeList() :
    m_rgwszVolumes(NULL),       // array of volumes
    m_cwszVolumes(0),           // # of volumes in array
    m_cwszVolumesMax(0),        // size of array
    m_rgwszPaths(NULL),         // array of paths
    m_cwszPaths(0),             // # of paths in array
    m_cwszPathsMax(0)           // size of array
    {
    }

// destructor
CVolumeList::~CVolumeList()
    {
    delete m_rgwszPaths;        // delete paths array
    delete m_rgwszVolumes;      // delete volumes array
    }

// add a path to the list if it is not already there
// return TRUE if it is a new path
// return FALSE if path is already in list
//
BOOL CVolumeList::AddPathToList(LPWSTR wszPath)
    {
    // look for path in list.  If found, then return FALSE
    for(unsigned iwsz = 0; iwsz < m_cwszPaths; iwsz++)
        {
        if (_wcsicmp(wszPath, m_rgwszPaths[iwsz]) == 0)
            return FALSE;
        }

    // grow pat array if needed
    if (m_cwszPaths == m_cwszPathsMax)
        {
        // grow path array
        LPCWSTR *rgwsz = new LPCWSTR[m_cwszPaths + x_cwszPathsInc];

        // throw OOM if memory allocation fails
        if (rgwsz == NULL)
            throw(E_OUTOFMEMORY);

        memcpy(rgwsz, m_rgwszPaths, m_cwszPaths * sizeof(LPCWSTR));
        delete m_rgwszPaths;
        m_rgwszPaths = rgwsz;
        m_cwszPathsMax += x_cwszPathsInc;
        }

    // add path to array
    m_rgwszPaths[m_cwszPaths++] = m_sd.CopyString(wszPath);
    return TRUE;
    }

// add a volume to the list if it is not already there
// return TRUE if it is added
// return FALSE if it is already on the list
//
BOOL CVolumeList::AddVolumeToList(LPCWSTR wszVolume)
    {
    // look for volume in array.  If found then return FALSE
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        {
        if (_wcsicmp(wszVolume, m_rgwszVolumes[iwsz]) == 0)
            return FALSE;
        }

    // grow volume array if necessary
    if (m_cwszVolumes == m_cwszVolumesMax)
        {
        // grow volume array
        LPCWSTR *rgwsz = new LPCWSTR[m_cwszVolumes + x_cwszVolumesInc];
        if (rgwsz == NULL)
            throw(E_OUTOFMEMORY);

        memcpy(rgwsz, m_rgwszVolumes, m_cwszVolumes * sizeof(LPCWSTR));
        delete m_rgwszVolumes;
        m_rgwszVolumes = rgwsz;
        m_cwszVolumesMax += x_cwszVolumesInc;
        }

    // add volume name to array
    m_rgwszVolumes[m_cwszVolumes++] = m_sd.CopyString(wszVolume);
    return TRUE;
    }


const WCHAR x_wszVolumeRootName[] = L"\\\\?\\GlobalRoot\\Device\\";
const unsigned x_cwcVolumeRootName = sizeof(x_wszVolumeRootName)/sizeof(WCHAR) - 1;

// add a path to our tracking list.  If the path is new add it to the
// paths list.  If it is a mount point or the root of a volume, then
// determine the volume and add the volume to the list of volumes
//
// can throw E_OUTOFMEMORY
//
void CVolumeList::AddPath(LPWSTR wszTop)
    {
    // if path is known about then return
    if (!AddPathToList(wszTop))
        return;

    // length of path
    unsigned cwc = wcslen(wszTop);

    // copy path so that we can add backslash to the end of the path
    LPWSTR wszCopy = new WCHAR[cwc + 2];

    // if fails, then throw OOM
    if (wszCopy == NULL)
        throw E_OUTOFMEMORY;

    // copyh in original path
    memcpy(wszCopy, wszTop, cwc * sizeof(WCHAR));

    // append backslash
    wszCopy[cwc] = L'\\';
    wszCopy[cwc + 1] = L'\0';
    while(TRUE)
        {
        // check for a device root
        unsigned cwc = wcslen(wszCopy);
        if ((cwc == 3 && wszCopy[1] == ':') ||
            (cwc > x_cwcVolumeRootName &&
             memcmp(wszCopy, x_wszVolumeRootName, x_cwcVolumeRootName * sizeof(WCHAR)) == 0))
            {
            // call TryAddVolume with TRUE indicating this is a volume root
            TryAddVolumeToList(wszCopy, TRUE);
            break;
            }

        // call TryAddVolume indicating this is not a known device root
        if (TryAddVolumeToList(wszCopy, FALSE))
            break;

        // move back to previous backslash
        WCHAR *pch = wszCopy + cwc - 2;
        while(--pch > wszTop)
            {
            if (pch[1] == L'\\')
                {
                pch[2] = L'\0';
                break;
                }
            }

        if (pch == wszTop)
            break;

        // if path is known about then return
        if (!AddPathToList(wszCopy))
            break;
        }
    }



// determine if a path is a volume.  If so then add it to the volume
// list and return TRUE.  If not, then return FALSE.  fVolumeRoot indicates
// that the path is of the form x:\.  Otherwise the path is potentially
// an mount point.  Validate that it is a reparse point and then try
// finding its volume guid.  If this fails, then assume that it is not
// a volume root.  If it succeeds, then add the volume guid to the volumes
// list and return TRUE.
//
BOOL CVolumeList::TryAddVolumeToList(LPCWSTR wszPath, BOOL fVolumeRoot)
    {
    WCHAR wszVolume[256];

    if (fVolumeRoot)
        {
        if (!GetVolumeNameForVolumeMountPoint(wszPath, wszVolume, sizeof(wszVolume)/sizeof(WCHAR)))
            // might be the EFI system partition, just pass in the path as the volume string.
            wcscpy( wszVolume, wszPath );            
            //throw E_UNEXPECTED;
        }
    else
        {
        DWORD dw = GetFileAttributes(wszPath);
        if (dw == -1)
            return FALSE;

        if ((dw & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
            return FALSE;

        if (!GetVolumeNameForVolumeMountPoint(wszPath, wszVolume, sizeof(wszVolume)/sizeof(WCHAR)))
            return FALSE;
        }

    AddVolumeToList(wszVolume);
    return TRUE;
    }


// add a file to the volume list.  Simply finds the parent path and adds it
//
void CVolumeList::AddFile(LPWSTR wsz)
    {
    unsigned cwc = wcslen(wsz);
    WCHAR *pwc = wsz + cwc - 1;
    while(pwc[1] != L'\\' && pwc != wsz)
        continue;

    pwc[1] = '\0';
    AddPath(wsz);
    }

// obtain list of volumes as a MULTI_SZ,  caller is responsible for freeing
// the string
//
LPWSTR CVolumeList::GetVolumeList()
    {
    unsigned cwc = 1;

    // compute length of volume list it is length of each string +
    // null character + null charactor for last double NULL
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        cwc += wcslen(m_rgwszVolumes[iwsz]) + 1;

    // allocate string
    LPWSTR wsz = new WCHAR[cwc];

    // throw OOM if memory allocation failed
    if (wsz == NULL)
        throw E_OUTOFMEMORY;

    // copy in strings
    WCHAR *pwc = wsz;
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        {
        cwc = wcslen(m_rgwszVolumes[iwsz]) + 1;
        memcpy(pwc, m_rgwszVolumes[iwsz], cwc * sizeof(WCHAR));
		/* replace \\?\ with \??\ */
		memcpy(pwc, L"\\??", sizeof(WCHAR) * 3);

		// delete trailing backslash if it exists
		if (pwc[cwc - 2] == L'\\')
			{
			pwc[cwc-2] = L'\0';
			cwc--;
			}

        pwc += cwc;
        }

    // last null termination
    *pwc = L'\0';

    return wsz;
    }


// path to volume of boot device is
// HKEY_LOCAL_MACHINE\System\Setup
//with Value of SystemPartition parametr
LPCWSTR x_SetupRoot = L"System\\Setup";

// magic perfix for volume devices
WCHAR x_wszWin32VolumePrefix[] = L"\\\\?\\GlobalRoot";
const unsigned x_cwcWin32VolumePrefix = sizeof(x_wszWin32VolumePrefix)/sizeof(WCHAR) - 1;

// structure representing a path from
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
// and a value to look up
typedef struct _SVCPARM
    {
    LPCWSTR wszPath;
    LPCWSTR wszValue;
    } SVCPARM;


const SVCPARM x_rgdbparms[] =
    {
        {L"CertSvc\\Configuration", L"DBDirectory"},
        {L"CertSvc\\Configuration", L"DBLogDirectory"},
        {L"CertSvc\\Configuration", L"DBSystemDirectory"},
        {L"CertSvc\\Configuration", L"DBTempDirectory"},
        {L"DHCPServer\\Parameters", L"DatabasePath"},
        {L"DHCPServer\\Parameters", L"DatabaseName"},
        {L"DHCPServer\\Parameters", L"BackupDatabasePath"},
        {L"NTDS\\Parameters", L"Database backup path"},
        {L"NTDS\\Parameters", L"Databases log files path"},
        {L"Ntfrs\\Parameters\\Replica Sets", L"Database Directory"}
    };

const unsigned x_cdbparms = sizeof(x_rgdbparms)/sizeof(SVCPARM);

LPCWSTR x_wszSvcRoot = L"System\\CurrentControlSet\\Services";

// add roots for various services
BOOL AddServiceRoots(CVolumeList &vl)
    {
    HKEY hkeyRoot;
    // open HKLM\System\CurrentControlSet\Services
    if (RegOpenKey(HKEY_LOCAL_MACHINE, x_wszSvcRoot, &hkeyRoot) != ERROR_SUCCESS)
        return FALSE;

    // loop through individual paths
    for(unsigned i = 0; i < x_cdbparms; i++)
        {
        WCHAR wsz[MAX_PATH*4];
        LPCWSTR wszPath = x_rgdbparms[i].wszPath;
        LPCWSTR wszValue = x_rgdbparms[i].wszValue;

        HKEY hkey;
        DWORD cb = sizeof(wsz);
        DWORD type;

        // open path, skip if open fails
        if (RegOpenKey(hkeyRoot, wszPath, &hkey) != ERROR_SUCCESS)
            continue;

        // add path to volume list if query succeeds
        if (RegQueryValueEx
                (
                hkey,
                wszValue,
                NULL,
                &type,
                (BYTE *) wsz,
                &cb
                ) == ERROR_SUCCESS)
            vl.AddPath(wsz);

        // close key
        RegCloseKey(hkey);
        }

    // close root key
    RegCloseKey(hkeyRoot);
    return TRUE;
    }


// add volume root of SystemDrive (drive wee boot off of
BOOL AddSystemPartitionRoot(CVolumeList &vl)
    {
    HKEY hkeySetup;
    WCHAR wsz[MAX_PATH];

    // open HKLM\System\Setup
    if (RegOpenKey(HKEY_LOCAL_MACHINE, x_SetupRoot, &hkeySetup) != ERROR_SUCCESS)
        return FALSE;

    DWORD cb = sizeof(wsz);
    DWORD type;

    // query SystemPartition value
    if (RegQueryValueEx
            (
            hkeySetup,
            L"SystemPartition",
            NULL,
            &type,
            (BYTE *) wsz,
            &cb
            ) != ERROR_SUCCESS)
        {
        // if fails, return FALSE
        RegCloseKey(hkeySetup);
        return FALSE;
        }

    // compute size of needed buffer
    unsigned cwc = wcslen(wsz);
    unsigned cwcNew = x_cwcWin32VolumePrefix + cwc + 1;
    LPWSTR wszNew = new WCHAR[cwcNew];

    // return failure if memory allocation fials
    if (wszNew == NULL)
        return FALSE;

    // append \\?\GlobalRoot\ to device name
    memcpy(wszNew, x_wszWin32VolumePrefix, x_cwcWin32VolumePrefix * sizeof(WCHAR));
    memcpy(wszNew + x_cwcWin32VolumePrefix, wsz, cwc * sizeof(WCHAR));
    RegCloseKey(hkeySetup);
    wszNew[cwcNew-1] = L'\0';
    try {        
        // add path based on device root
        vl.AddPath(wszNew);
    } catch(...)
        {
        delete wszNew;
        return FALSE;
        }

    // delete allocated memory
    delete wszNew;
    return TRUE;
    }

// find critical volumes.  Return multistring of volume names
// using guid naming convention
LPWSTR pFindCriticalVolumes()
    {
    WCHAR wsz[MAX_PATH * 4];

    // find location of system root
    if (!ExpandEnvironmentStrings(L"%systemroot%", wsz, sizeof(wsz)/sizeof(WCHAR)))
        {
        wprintf(L"ExpandEnvironmentStrings failed for reason %d", GetLastError());
        return NULL;
        }

    CVolumeList vl;
    LPWSTR wszPathsT = NULL;
    LPWSTR wszT = NULL;

    try
        {
        // add boot drive
        if (!AddSystemPartitionRoot(vl))
            return NULL;

        // add roots for various services
        if (!AddServiceRoots(vl))
            return NULL;

        // add systemroot drive
        vl.AddPath(wsz);

            {
            // add roots for SYSVOL
            CFRSIter fiter;
            fiter.Init();
            fiter.BeginIteration();
            while(TRUE)
                {
                wszT = fiter.GetNextSet(TRUE, &wszPathsT);
                if (wszT == NULL)
                    break;

                vl.AddPath(wszT);
                LPWSTR wszPathT = wszPathsT;
                while(*wszPathT != NULL)
                    {
                    vl.AddPath(wszPathT);
                    wszPathT += wcslen(wszPathT);
                    }

                delete wszT;
                delete wszPathsT;
                wszT = NULL;
                wszPathsT = NULL;
                }

            fiter.EndIteration();
            }
        }
    catch(...)
        {
        delete wszT;
        delete wszPathsT;
        }

    // return volume list
    return vl.GetVolumeList();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\confdisk\critdrv.h ===
//-------------------------------------------------------------------
//
// critical drivers suppot
//

typedef struct _WSTRING_DATA_LINK
	{
	struct _WSTRING_DATA_LINK *m_psdlNext;
	WCHAR rgwc[2040];
	} WSTRING_DATA_LINK;


// class string data
class CWStringData
	{
public:
	// @cmember constructor
	CWStringData();

	// @cmember destructor
	~CWStringData();

	// @cmember allocate a string
	LPWSTR AllocateString(unsigned cwc);

	// @cmember copy a string
	LPWSTR CopyString(LPCWSTR wsz);

private:
	// @cmember allocate a new string data link
	void AllocateNewLink();

	// @cmember	current link
	WSTRING_DATA_LINK *m_psdlCur;

	// @cmember offset in current link for next string
	unsigned m_ulNextString;

	// @cmember first link
	WSTRING_DATA_LINK *m_psdlFirst;
	};



// list of critical volumes
class CVolumeList
	{
public:
	// constructor
	CVolumeList();

	// destructor
	~CVolumeList();

	// add a path to the volume list
	void AddPath(LPWSTR wszPath);

	// @cmember add a file to the volume list
	void AddFile(LPWSTR wszFile);

	// @cmember obtain list of volumes
	LPWSTR GetVolumeList();

private:
	enum
		{
		// amount to grow paths array by
		x_cwszPathsInc = 8,

		// amount to grow volumes array by
		x_cwszVolumesInc = 4
		};

	// determine if a path is a volume
	BOOL TryAddVolumeToList(LPCWSTR wszPath, BOOL fVolumeRoot);

	// determine if path is in the list; if not add it to list
	BOOL AddPathToList(LPWSTR wszPath);

	// @cmember determine if a volume is in the list; if not add it to the list
	BOOL AddVolumeToList(LPCWSTR wszVolume);

	// @cmember get volume from the path
	void GetVolumeFromPath(LPCWSTR wsz, LPWSTR wszVolumeName);

	// @cmember cached strings
	CWStringData m_sd;

	// volumes encountered so far
	LPCWSTR *m_rgwszVolumes;

	// # of volumes allocate
	unsigned m_cwszVolumes;

	// max # of volumes in array
	unsigned m_cwszVolumesMax;

	// paths encountered so far
	LPCWSTR *m_rgwszPaths;

	// # of paths encountered so far
	unsigned m_cwszPaths;

	// @cmember max # of paths in array
	unsigned m_cwszPathsMax;
	};


// FRS entry points
typedef DWORD ( WINAPI *PF_FRS_ERR_CALLBACK )( CHAR *, DWORD );
typedef DWORD ( WINAPI *PF_FRS_INIT )( PF_FRS_ERR_CALLBACK, DWORD, PVOID * );
typedef DWORD ( WINAPI *PF_FRS_DESTROY )( PVOID *, DWORD, HKEY *, LPDWORD, CHAR *) ;
typedef DWORD ( WINAPI *PF_FRS_GET_SETS )( PVOID );
typedef DWORD ( WINAPI *PF_FRS_ENUM_SETS )( PVOID, DWORD, PVOID * );
typedef DWORD ( WINAPI *PF_FRS_IS_SYSVOL )( PVOID, PVOID, BOOL * );
typedef DWORD ( WINAPI *PF_FRS_GET_PATH )( PVOID, PVOID, DWORD *, WCHAR * ) ;
typedef DWORD ( WINAPI *PF_FRS_GET_OTHER_PATHS)(PVOID, PVOID, DWORD *, WCHAR *, DWORD *, WCHAR *);

// iterate over frs drives
class CFRSIter
	{
public:
	// constructor
	CFRSIter();

	// destructor
	~CFRSIter();

	// initialization routine
	void Init();

	// initialize iterator
	BOOL BeginIteration();

	// end iteration
	void EndIteration();

	// obtain path to next replication set
	LPWSTR GetNextSet(BOOL fSkipToSysVol, LPWSTR *pwszPaths);

private:
	// cleanup frs backup restore context
	void CleanupIteration();

	enum
		{
		x_IterNotStarted,
		x_IterStarted,
		x_IterComplete
		};

	// is this initialized
	BOOL m_fInitialized;
	HINSTANCE  m_hLib;
	DWORD ( WINAPI *m_pfnFrsInitBuRest )( PF_FRS_ERR_CALLBACK, DWORD, PVOID * );
	DWORD ( WINAPI *m_pfnFrsEndBuRest )( PVOID *, DWORD, HKEY *, LPDWORD, CHAR *) ;
	DWORD ( WINAPI *m_pfnFrsGetSets )( PVOID );
	DWORD ( WINAPI *m_pfnFrsEnumSets )( PVOID, DWORD, PVOID * );
	DWORD ( WINAPI *m_pfnFrsIsSetSysVol )( PVOID, PVOID, BOOL * );
	DWORD ( WINAPI *m_pfnFrsGetPath )( PVOID, PVOID, DWORD *, WCHAR * ) ;
	DWORD ( WINAPI *m_pfnFrsGetOtherPaths) ( PVOID, PVOID, DWORD *, WCHAR *, DWORD *, WCHAR * );

	// has iteration been started
	int m_stateIteration;

	// current set iterated
	unsigned m_iset;

	// context for iteration
	PVOID m_frs_context;
	};



LPWSTR pFindCriticalVolumes();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\confdisk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by confdisk.rc
//
#define IDS_GENERIC_ERROR               1
#define IDS_ERROR_USAGE                 2
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\asr_app\asr_app.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asr_app.c

Abstract:

    Sample third party ASR recovery application.

Authors:

    Guhan Suriyanarayanan   (guhans)    07-Oct-1999

Revision History:

    07-Oct-2000 guhans      
      Initial creation

--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winasr.h>
#include <setupapi.h>

//
//  Macro Description:
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Expression to be tested
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // ErrorCode 
//
#define pErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {   \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        wprintf(L"Error %lu (0x%x), line %lu", ErrorCode, ErrorCode, __LINE__);    \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}


//
// Constants local to this module
//
const WCHAR BACKUP_OPTION[]     = L"/backup";
const WCHAR RESTORE_OPTION[]    = L"/restore";
const WCHAR REGISTER_OPTION[]    = L"/register";

const WCHAR SIF_PATH_FORMAT[]   = L"/sifpath=%ws";
const WCHAR ERROR_FILE_PATH[]   = L"%systemroot%\\repair\\asr.err";

const WCHAR MY_SIF_SECTION[]        = L"[ASR_APP.APPDATA]";
const WCHAR MY_SIF_SECTION_NAME[]   = L"ASR_APP.APPDATA";


const WCHAR GENERIC_ERROR_MESSAGE[] = L"asr_app could not complete successfully (error %lu 0x%x)\n\nusage: asr_app {/backup | /restore /sifpath=<path to asr.sif> | /register <path to asr_app>}";
const WCHAR GENERIC_ERROR_TITLE[] = L"asr_app error";

#ifdef _IA64_
const WCHAR CONTEXT_FORMAT[]       = L"/context=%I64u";
#else
const WCHAR CONTEXT_FORMAT[]       = L"/context=%lu";
#endif


#define ASR_REG_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\Commands"
#define MY_REG_KEY_VALUE_NAME   L"ASR Sample Application"

typedef enum _AsrAppOption {
    AsrAppNone = 0,
    AsrAppRegister,
    AsrAppBackup,
    AsrAppRestore
} AsrAppOption;

HANDLE Gbl_hErrorFile = NULL;


PWSTR   // must be freed by caller
ExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    )
{
    PWSTR expandedString = NULL;
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;
    BOOL result = FALSE;

    DWORD status = ERROR_SUCCESS;
    HANDLE heapHandle = GetProcessHeap();

    expandedString = (PWSTR) HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, (cchSize * sizeof(WCHAR)));
    if (!expandedString) {
        return NULL;
    }
        
    cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
        expandedString,
        cchSize 
        );

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        HeapFree(heapHandle, 0L, expandedString);
        cchSize = cchRequiredSize + 1;

        expandedString = (PWSTR) HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, (cchSize * sizeof(WCHAR)));
        if (!expandedString) {
            return NULL;
        }
        
        cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
            expandedString, 
            cchSize 
            );
    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough 
        // even on the second try
        //
        HeapFree(heapHandle, 0L, expandedString);
        expandedString = NULL;
    }

    return expandedString;
}


VOID
OpenErrorFile() 
{
    PWSTR szErrorFilePath = NULL;

    //
    // Get full path to the error file  (%systemroot%\repair\asr.err)
    //
    szErrorFilePath = ExpandEnvStrings(ERROR_FILE_PATH);
    if (!szErrorFilePath) {
        return;
    }

    //
    // Open the error file
    //
    Gbl_hErrorFile = CreateFileW(
        szErrorFilePath,            // lpFileName
        GENERIC_WRITE | GENERIC_READ,       // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                       // lpSecurityAttributes
        OPEN_ALWAYS,                // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,    // dwFlagsAndAttributes
        NULL                        // hTemplateFile
        );

    HeapFree(GetProcessHeap(), 0L, szErrorFilePath);
    szErrorFilePath = NULL;

    if ((!Gbl_hErrorFile) || (INVALID_HANDLE_VALUE == Gbl_hErrorFile)) {
        return;
    }

    //
    // Move to the end of file
    //
    SetFilePointer(Gbl_hErrorFile, 0L, NULL, FILE_END);
}


VOID
CloseErrorFile(
    VOID
    ) 
{

    if ((Gbl_hErrorFile) && (INVALID_HANDLE_VALUE != Gbl_hErrorFile)) {
        CloseHandle(Gbl_hErrorFile);
        Gbl_hErrorFile = NULL;
    }
}


VOID
LogErrorMessage(
    IN CONST PCWSTR Message
    ) 
{
    SYSTEMTIME currentTime;
    DWORD bytesWritten = 0;
    WCHAR buffer[4196];

    if ((!Gbl_hErrorFile) || (INVALID_HANDLE_VALUE == Gbl_hErrorFile)) {
        //
        // We haven't been initialised, or the error file couldn't be
        // created for some reason.
        //
        return;
    }

    //
    // In case someone else wrote to this file since our last write
    //
    SetFilePointer(Gbl_hErrorFile, 0L, NULL, FILE_END);

    //
    // Create our string, and write it out
    //
    GetLocalTime(&currentTime);
    swprintf(buffer,
        L"\r\n[%04hu/%02hu/%02hu %02hu:%02hu:%02hu ASR_APP] (ERROR) %s\r\n",
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        Message
        );

    WriteFile(Gbl_hErrorFile,
        buffer,
        (wcslen(buffer) * sizeof(WCHAR)),
        &bytesWritten,
        NULL
        );
}


BOOL
BackupState(
    IN CONST DWORD_PTR AsrContext
    )
{
    //
    // Gather our state to backup
    //
    HMODULE hSyssetup = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = FALSE;

    //     
    // BOOL
    // AsrAddSifEntryW(
    //     IN  DWORD_PTR   AsrContext,
    //     IN  PCWSTR      lpSectionName,
    //     IN  PCWSTR      lpSifEntry
    //     );
    // 
    BOOL (*pfnAddSifEntry)(DWORD_PTR, PCWSTR, PCWSTR);

    // 
    // Load syssetup.dll
    //
    hSyssetup = LoadLibraryW(L"syssetup.dll");
    pErrExitCode(
        (!hSyssetup || INVALID_HANDLE_VALUE == hSyssetup),
        dwStatus, 
        GetLastError()
        );

    // 
    // Get the RestoreNonCriticalDisksW API exported by syssetup.dll
    //
    pfnAddSifEntry = (BOOL (*)(DWORD_PTR, PCWSTR, PCWSTR))
        GetProcAddress(hSyssetup, "AsrAddSifEntryW");
    pErrExitCode((!pfnAddSifEntry), dwStatus,  GetLastError());


    //
    // Add the state to asr.sif
    //
    bResult = pfnAddSifEntry(
        AsrContext,
        MY_SIF_SECTION,
        L"1=\"asr_app sample application data\",100,200,300"
        );
    pErrExitCode(!bResult, dwStatus, GetLastError());

    //
    // Also add to the commands and installfiles section, so that we get
    // called during the ASR recovery.
    //

    // 
    // INSTALLFILES section entry format:
    // system-key,source-media-label,source-device,
    //    source-file-path,destination-file-path,vendor-name
    // system-key must be 1
    //
    bResult = pfnAddSifEntry(
        AsrContext,
        ASR_SIF_SECTION_INSTALLFILES,
        L"1,\"ASR Sample App Disk 1\",\"%FLOPPY%\",\"i386\\asr_app.exe\",\"%temp%\\asr_app.exe\",\"ASR Sample App Company\""
        //L"1,\"Application Disk 1\",\"\\device\\cdrom0\",\"application.exe\",\"%TEMP%\\application.exe\",\"Company Name\""
        );
    pErrExitCode(!bResult, dwStatus, GetLastError());

//    CString cmd =L"1,\"ASRDisk1\",\"\\Device\\Floppy0\\edmbackup.exe\",\"%TEMP%\\edmbackup.exe\",\"EMC\"";

/*    bResult = pfnAddSifEntry(AsrContext, 
        ASR_SIF_SECTION_INSTALLFILES, 
        (LPCTSTR) L"1,\"ASRDisk1\",\"\\Device\\Floppy0\\edmbackup.exe\",\"%TEMP%\\edmbackup.exe\",\"EMC\"" );
    pErrExitCode(!bResult, dwStatus, GetLastError());
*/


    //
    // COMMANDS section entry format:
    // system-key,sequence-number,action-on-completion,"command","parameters"
    // system-key must be 1
    // 1000 <= sequence-number <= 4999
    // 0 <= action-on-completion <= 1
    //
    bResult = pfnAddSifEntry(
        AsrContext,
        ASR_SIF_SECTION_COMMANDS,
        L"1,3500,1,\"%temp%\\asr_app.exe\",\"/restore\""
        );
    pErrExitCode(!bResult, dwStatus, GetLastError());

EXIT:
    //
    // Cleanup
    //
    if (hSyssetup) {
        FreeLibrary(hSyssetup);
        hSyssetup = NULL;
    }
    
    return (ERROR_SUCCESS == dwStatus);
}


BOOL
RestoreState(
    IN CONST PCWSTR szAsrSifPath
    )
{
    HINF hSif = NULL;
    INFCONTEXT infContext;
    BOOL bResult = FALSE;

    WCHAR szErrorString[1024];

    int iValue1 = 0, 
        iValue2 = 0, 
        iValue3 = 0;

    WCHAR szBuffer[1024];

    //
    // Open the asr.sif
    //
    hSif = SetupOpenInfFile(szAsrSifPath, NULL, INF_STYLE_WIN4, NULL);
    if ((!hSif) || (INVALID_HANDLE_VALUE == hSif)) {

        wsprintf(szErrorString, L"Unable to open the ASR state file at %ws (0x%x)",
            szAsrSifPath,
            GetLastError()
            );
        LogErrorMessage(szErrorString);

        return FALSE;
    }

    //
    // Find the section
    //
    bResult = SetupFindFirstLineW(hSif, MY_SIF_SECTION_NAME, NULL, &infContext);
    if (bResult) {

        //
        // Read in the information.  We had one string followed by three numbers.
        //
        bResult = SetupGetStringField(&infContext, 1, szBuffer, 1024, NULL)
            && SetupGetIntField(&infContext, 2, &iValue1)
            && SetupGetIntField(&infContext, 3, &iValue2)
            && SetupGetIntField(&infContext, 4, &iValue3);

        if (bResult) {
            //
            // Now restore our state.  Let's just pretend we're doing something.
            //
            wprintf(L"Values read:  %ws  %lu %lu %lu\n\n", szBuffer, iValue1, iValue2, iValue3);
            wprintf(L"Restoring sample system state, please wait ... ");

            Sleep(5000);
            wprintf(L"done\n");

        }
        else {

            wsprintf(szErrorString, 
                L"Some values in the asr_app section of the ASR state file %ws could not be read (0x%x).  "
                L"This may indicate a corrupt or an incompatible version of the ASR state file",
                szAsrSifPath,
                GetLastError()
                );
            LogErrorMessage(szErrorString);
        }
    }
    else {

        wsprintf(szErrorString, 
            L"Unable to locate asr_app section in ASR state file %ws (0x%x).  "
            L"This may indicate a corrupt or an incompatible version of the ASR state file",
            szAsrSifPath,
            GetLastError()
            );
        LogErrorMessage(szErrorString);
    }

    SetupCloseInfFile(hSif);
    return bResult;
}


DWORD
RegisterForAsrBackup(
    IN CONST PCWSTR szApplicationName
    ) 
{

    DWORD dwResult = ERROR_SUCCESS;
    HKEY hKeyAsr = NULL;

    WCHAR szData[1024];

    if (wcslen(szApplicationName) > 1000) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    wsprintf(szData, L"%ws %ws", szApplicationName, BACKUP_OPTION);

    // 
    // Open the registry key
    //
    dwResult = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,     // hKey
        ASR_REG_KEY,  // lpSubKey
        0,                      // ulOptions--Reserved, must be 0
        MAXIMUM_ALLOWED,        // samDesired
        &hKeyAsr              // phkbResult    
        );
    if (ERROR_SUCCESS != dwResult) {
        return dwResult;
    }

    dwResult = RegSetValueExW(
        hKeyAsr,                                // hKey
        MY_REG_KEY_VALUE_NAME,                  // lpValueName
        0,                                      // dwReserved, must be 0
        REG_SZ,                                  // dwType
        (LPBYTE)szData,  // lpData
        ((wcslen(szData) + 1)* (sizeof(WCHAR))) // cbData
        );

    return dwResult;
}


int 
__cdecl     // var arg
wmain (
    int     argc,
    wchar_t *argv[],
    wchar_t *envp[]
    ) 
{

    AsrAppOption    option  = AsrAppNone;
    DWORD           dwStatus = ERROR_SUCCESS;

    if (argc >= 3) {
        if (!_wcsicmp(argv[1], BACKUP_OPTION)) {
            //
            // asr_app /backup /context=nnn
            //
            option = AsrAppBackup;
        } 
        else if (!_wcsicmp(argv[1], RESTORE_OPTION)) {
            //
            // asr_app /restore /sifpath="c:\winnt\repair\asr.sif"
            //
            option = AsrAppRestore;
        }
        else if (!_wcsicmp(argv[1], REGISTER_OPTION)) {
            //
            // asr_app /register "c:\apps\asr_app\asr_app.exe"
            //
            option = AsrAppRegister;
        }
    }

    switch (option) {

    case AsrAppRegister: {                   // This App is being installed

        dwStatus = RegisterForAsrBackup(argv[2]);
        
        break;

    }

    case AsrAppBackup: {                    // An ASR Backup is in progress
        DWORD_PTR  AsrContext = 0;

        //
        // Extract the asr context from the commandline
        //
        swscanf(argv[2], CONTEXT_FORMAT, &AsrContext);

        //
        // Create our spooge and write to the asr.sif
        //
        if (!BackupState(AsrContext)) {
            dwStatus = GetLastError();
        }
//        AsrFreeContext(&AsrContext);

        //
        // And we're done
        //
        break;
    }

    case AsrAppRestore: {                   // An ASR Restore is in progress
        WCHAR   szAsrFilePath[MAX_PATH +1];

        //
        // Get the path to the asr.sif
        //
        swscanf(argv[2], SIF_PATH_FORMAT, szAsrFilePath);
        OpenErrorFile();
        
        //
        // Read our spooge from asr.sif, and recreate the state.  Be sure to 
        // write out the error to %systemroot%\repair\asr.err in case of
        // error.
        //
        if (!RestoreState(szAsrFilePath)) {
            dwStatus = GetLastError();
        }
        CloseErrorFile();

        //
        // And we're done
        //
        break;
    }

    case AsrAppNone:
    default: {

        // 
        // Command-line parameters were incorrect, display usage message
        //
        dwStatus = ERROR_INVALID_PARAMETER;
        break;
    }
    }
    
    if (ERROR_SUCCESS != dwStatus) {
        //
        // We hit an error
        //
        WCHAR szErrorMessage[1024];

        swprintf(szErrorMessage, GENERIC_ERROR_MESSAGE, dwStatus, dwStatus);
        MessageBoxW(NULL, szErrorMessage, GENERIC_ERROR_TITLE, MB_OK | MB_ICONSTOP);
    }

    SetLastError(dwStatus);
    return (int) dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\wipedisk\wipedisk.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wipedisk.cpp

Abstract:

    Utility program to zero out the partition-tables and first/last
    few sectors of disks

Author:

    Guhan Suriyanarayanan   (guhans)    30-Sep-2000

Environment:

    User-mode only.

Revision History:

    30-Sep-2000 guhans
        Initial creation

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <ntdddisk.h>

BOOL g_bPrompt = TRUE;

//
// write in 64K chunks.
//
#define BUFFER_SIZE_BYTES (64 * 1024)


BOOL
pSetSignature(
    IN CONST ULONG ulDiskNumber,
    IN CONST DWORD dwNewSignature
    )
{
    DWORD dwStatus = ERROR_SUCCESS,
        dwBytesReturned = 0,
        dwBufferSize = 0;

    PDRIVE_LAYOUT_INFORMATION_EX driveLayoutEx;

    int i = 0, loopTimes = 0;

    BOOL bResult = FALSE;

    HANDLE hDisk = NULL,
        hHeap = NULL;

    WCHAR szFriendlyName[100];  // For display  "Disk 2"
    WCHAR szDiskPath[100];      // For CreateFile   "\\.\PhysicalDrive2"

    wsprintf(szFriendlyName, L"Disk %lu", ulDiskNumber);
    wsprintf(szDiskPath, L"\\\\.\\PhysicalDrive%lu", ulDiskNumber);
    hHeap = GetProcessHeap();

    hDisk = CreateFile(
        szDiskPath,                     // lpFileName
        GENERIC_READ | GENERIC_WRITE,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode
        NULL,                           // lpSecurityAttributes
        OPEN_EXISTING,                  // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,          // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );

    if ((INVALID_HANDLE_VALUE == hDisk) || (NULL == hDisk)) {
        //
        // Couldn't open a handle.
        //
        wprintf(L"Unable to open a handle to %ws (%lu)\n", szDiskPath, GetLastError());
        return FALSE;
    }

    dwBufferSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + 
        (sizeof(PARTITION_INFORMATION_EX) * 3);

    driveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        dwBufferSize
        );
    if (!driveLayoutEx) {
        wprintf(L"Could not allocate memory\n");
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto EXIT;
    }

    bResult = FALSE;
    while (!bResult) {

        bResult = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
            NULL,
            0L,
            driveLayoutEx,
            dwBufferSize,
            &dwBytesReturned,
            NULL
            );

        if (!bResult) {
            dwStatus = GetLastError();
            HeapFree(hHeap, 0L, driveLayoutEx);
            driveLayoutEx = NULL;

            // 
            // If the buffer is of insufficient size, resize the buffer.  
            // Note that get-drive-layout-ex could return error-insufficient-
            // buffer (instead of? in addition to? error-more-data)
            //
            if ((ERROR_MORE_DATA == dwStatus) || 
                (ERROR_INSUFFICIENT_BUFFER == dwStatus)
                ) {
                dwStatus = ERROR_SUCCESS;
                dwBufferSize += sizeof(PARTITION_INFORMATION_EX) * 4;

                driveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                    hHeap,
                    HEAP_ZERO_MEMORY,
                    dwBufferSize
                    );
                if (!driveLayoutEx) {
                    wprintf(L"Could not allocate memory\n");
                    dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto EXIT;
                }
            }
            else {
                // 
                // some other error occurred, EXIT, and go to the next drive.
                //
                wprintf(L"Could not get the drive layout for %ws (%lu)\n", szDiskPath, dwStatus);
                goto EXIT;
            }
        }
    }


    //
    // Now modify the signature, and set the layout again
    //
    driveLayoutEx->Mbr.Signature = dwNewSignature;

    bResult = DeviceIoControl(
        hDisk,
        IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
        driveLayoutEx,
        dwBufferSize,
        NULL,
        0L,
        &dwBytesReturned,
        NULL
        );

    if (!bResult) {
        //
        // SET_DRIVE_LAYOUT failed
        //
        dwStatus = GetLastError();
        wprintf(L"Could not SET the drive layout for %ws (%lu)\n", szDiskPath, dwStatus);
        goto EXIT;
    }


EXIT:

    if (driveLayoutEx) {
        HeapFree(hHeap, 0L, driveLayoutEx);
        driveLayoutEx = NULL;
    }

    if ((hDisk)  && (INVALID_HANDLE_VALUE != hDisk)) {
        CloseHandle(hDisk);
        hDisk = NULL;
    }

    SetLastError(dwStatus);
    return bResult;
}

BOOL
pConfirmWipe(
    IN CONST PCWSTR szDiskDisplayName
    )
{

    WCHAR   szInput[10];

    wprintf(L"\nWARNING.  This will delete all partitions from %ws\n", szDiskDisplayName);
    wprintf(L"Are you sure you want to continue [y/n]? ");
    wscanf(L"%ws", szInput);

    wprintf(L"\n");
    return ((L'Y' == szInput[0]) || (L'y' == szInput[0]));
}


BOOL
pWipeDisk(
    IN CONST ULONG ulDiskNumber,
    IN CONST ULONG ulFirstMB,
    IN CONST ULONG ulLastMB
    )

/*++

Routine Description:

    Deletes the drive layout for disk, and writes 0's at the start and end of the disk.

Arguments:

    ulDiskNumber - DiskNumber to wipe

    ulFirstMB - Number of MB to erase at the beginning of the disk

    ulLastMB - Number of MB to erase at the end of the disk

Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD dwStatus = ERROR_SUCCESS,
        dwBytes = 0;

    BYTE Buffer[BUFFER_SIZE_BYTES];
    int i = 0, loopTimes = 0;

    BOOL bResult = FALSE;

    HANDLE hDisk = NULL;
    WCHAR szFriendlyName[100];  // For display  "Disk 2"
    WCHAR szDiskPath[100];      // For CreateFile   "\\.\PhysicalDrive2"

    PARTITION_INFORMATION_EX ptnInfo;
    
    wsprintf(szFriendlyName, L"Disk %lu", ulDiskNumber);
    wsprintf(szDiskPath, L"\\\\.\\PhysicalDrive%lu", ulDiskNumber);

    ZeroMemory(Buffer, BUFFER_SIZE_BYTES);


    if (g_bPrompt && !pConfirmWipe(szFriendlyName)) {
        //
        // User didn't want to continue
        //
        SetLastError(ERROR_CANCELLED);
        return FALSE;
    }

    //
    // Set the signature to something random.  We need to do this before
    // deleting the layout for the boot disk.
    //
    pSetSignature(ulDiskNumber, 0);


    hDisk = CreateFile(
        szDiskPath,                     // lpFileName
        GENERIC_READ | GENERIC_WRITE,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode
        NULL,                           // lpSecurityAttributes
        OPEN_EXISTING,                  // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,          // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );

    if ((INVALID_HANDLE_VALUE == hDisk) || (NULL == hDisk)) {
        //
        // Couldn't open a handle.
        //
        wprintf(L"Unable to open a handle to %ws (%lu)\n", szDiskPath, GetLastError());
        return FALSE;
    }

    //
    // Zero out the first two sectors of each partition?
    //



    //
    // Delete the drive layout
    //
    wprintf(L"Deleting partitions on %ws ...\n", szFriendlyName);
    bResult = DeviceIoControl(
        hDisk,
        IOCTL_DISK_DELETE_DRIVE_LAYOUT,
        NULL,
        0L,
        NULL,
        0L,
        &dwBytes,
        NULL
        );

    bResult = TRUE;
    if (!bResult) {
        wprintf(L"Unable to delete partitions on %ws (%lu)\n", szDiskPath, GetLastError());

        CloseHandle(hDisk);
        return FALSE;
    }


    //
    // Erase MB at the start of the disk
    //
    if (ulFirstMB > 0) {

        wprintf(L"Erasing first %lu MB on %ws ...\n", ulFirstMB, szFriendlyName);
        
        //
        // Write 0's to disk in BUFFER_SIZE chunks
        //
        loopTimes = (ulFirstMB * 1024 * 1024 / BUFFER_SIZE_BYTES);
        for (i = 0; i < loopTimes; i++) {
            bResult = WriteFile(
                hDisk,
                &Buffer,
                BUFFER_SIZE_BYTES,
                &dwBytes,
                NULL
                );

            if (!bResult) {
                wprintf(L"Error while writing to %ws (%d, %lu)\n", szDiskPath, i, GetLastError());
                break;
            }        
        }
        if (!bResult) {
            CloseHandle(hDisk);
            return FALSE;
        }
    }


    //
    // Erase MB at the end of the disk
    //
    if (ulLastMB > 0) {

        wprintf(L"Erasing last %lu MB on %ws ...\n", ulLastMB, szFriendlyName);

        //
        // Find the end of the disk
        //
        bResult = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO_EX,
            NULL,
            0,
            &ptnInfo,
            sizeof(PARTITION_INFORMATION_EX),
            &dwBytes,
            NULL
            );
        if (!bResult) {
           wprintf(L"Could not find size of disk %ws (%lu)\n", szDiskPath, GetLastError());
           CloseHandle(hDisk);
           return FALSE;
        }

        // 
        // Find offset we'd like to start zero-ing out from
        // (end of disk - bytes to zero out)
        //
        ptnInfo.PartitionLength.QuadPart -= (ulLastMB * 1024 * 1024);

        dwBytes = SetFilePointer(hDisk, (ptnInfo.PartitionLength.LowPart), &(ptnInfo.PartitionLength.HighPart), FILE_BEGIN);
        if ((INVALID_SET_FILE_POINTER == dwBytes) && (NO_ERROR != GetLastError())) {
            wprintf(L"Could not move to end of disk for %ws (%lu)\n", szDiskPath, GetLastError());
        }

        //
        // Write 0's to disk in BUFFER_SIZE chunks
        //
        loopTimes = (ulLastMB * 1024 * 1024 / BUFFER_SIZE_BYTES);
        for (i = 0; i < loopTimes; i++) {
            bResult = WriteFile(
                hDisk,
                &Buffer,
                BUFFER_SIZE_BYTES,
                &dwBytes,
                NULL
                );

            if (!bResult) {
                wprintf(L"Error while writing to %ws (%d, %lu)\n", szDiskPath, i, GetLastError());
                break;
            }        
        }
        if (!bResult) {
            CloseHandle(hDisk);
            return FALSE;
        }
    }

    CloseHandle(hDisk);
    return TRUE;
}



VOID
pPrintUsage(
    IN CONST PCWSTR szArgV0
    ) {

    wprintf(L"usage:  %ws [/f] disk-number [mb-at-start [mb-at-end]]\n"
            L"        %ws /s new-signature disk-number\n"
            L"\n"
            L"  /f:            Suppress the prompt to confirm action\n"
            L"\n"
            L"  disk-number:   The NT disk-number of the disk that\n"
            L"                 the operation is to be performed\n"
            L"\n"
            L"  mb-at-start:   The number of MB to zero-out at\n"
            L"                 the start of the disk.  Default is 1\n"
            L"\n"
            L"  mb-at-end:     The number of MB to zero-out at\n"
            L"                 the end of the disk.  Default is 4\n"
            L"\n",
            L"  /s:            Set the signature of disk\n"
            L"\n"
            L"  new-signature: Value to set the disk signature to.\n"
            L"                 Specify 0 to use a randomly generated\n"
            L"                 value\n"
            L"\n",
            szArgV0,
            szArgV0
            );
}


int __cdecl
wmain(
    int       argc,
    WCHAR   *argv[],
    WCHAR   *envp[]
    )

/*++

Routine Description:
    
    Entry point to wipedisk.exe.  

Arguments:

    argc - Number of command-line parameters used to invoke the app

    argv - The command-line parameters as an array of strings.  
            argv[1] (required) is expected to be the disk number
            argv[2] (optional) is the initial MB to erase, default 1
            argv[3] (optional) is the last MB to erase, default 4

    envp - The process environment block, not currently used

Return Values:

    If the function succeeds, the exit code is zero.

    If the function fails, the exit code is a win-32 error code.

--*/

{
    BOOL bResult = TRUE,
        bSetSignature = FALSE;

    ULONG ulDiskNumber = 0,
        ulInitialMB = 1,
        ulFinalMB = 4;

    DWORD dwNewSignature = 0L;

    int shift = 0;

    SetLastError(ERROR_CAN_NOT_COMPLETE);   // for unexpected failures

    if (argc >= 2) {
        if ((L'-' == argv[1][0]) || (L'/' == argv[1][0])) {
            //
            // Parse the options
            //

            switch (argv[1][1]) {
            case L'f':
            case L'F': {

                g_bPrompt = FALSE;
                shift = 1;  // account for /f
                break;
            }

            case L's':
            case L'S': {

                bSetSignature = TRUE;
                shift = 2;  // account for /s <New Signature>
                break;
            }
            }
        }
    }

    if (argc >= shift + 2) {
        swscanf(argv[shift + 1], L"%lu", &ulDiskNumber);
    }
    else {
        //
        // We need at least one argument--the disk number
        //
        pPrintUsage(argv[0]);
        return ERROR_INVALID_PARAMETER;
    }

    if (bSetSignature) {

        //
        // Set the signature of the disk to a new value
        //
        swscanf(argv[shift], L"%lu", &dwNewSignature);
        bResult = pSetSignature(ulDiskNumber, dwNewSignature);

    }
    else {
        //
        // Wipe the disk.  Get the amount to zero-out at the start
        // and end of disk
        //
        if (argc >= shift + 3) {
            swscanf(argv[shift + 2], L"%lu", &ulInitialMB);

            if (argc >= shift + 4) {
                swscanf(argv[shift + 3], L"%lu", &ulFinalMB);
            }
        }


        bResult = pWipeDisk(ulDiskNumber, ulInitialMB, ulFinalMB);
    }

    if (bResult) {
        wprintf(L"Done.\n");
    }

    return (bResult ? 0 : GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\confdisk\confdisk.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    confdisk.h

Abstract:

    Utility program to create an ASR state-file (asr.sif), or restore 
    non-critical disk layout based on a previously created asr.sif.

Author:

    Guhan Suriyanarayanan   (guhans)    15-April-2001

Environment:

    User-mode only.

Revision History:

    15-Apr-2001 guhans
        Initial creation

--*/

//
// --------
// typedefs and constants 
// --------
//
#define BUFFER_LENGTH 1024

//
// Indices for fields in the [COMMANDS] section.  This is from 
// base\ntsetup\syssetup\setupasr.c.
//
typedef enum _SIF_COMMANDS_FIELD_INDEX {
    CmdKey = 0,
    SystemKey,            // Must always be "1"
    SequenceNumber,
    CriticalApp,
    CmdString,
    CmdParams,         // May be NULL
    CmdNumFields       // Must always be last
} SIF_SYSTEM_FIELD_INDEX;


//
// One ASR_RECOVERY_APP_NODE struct is created for each entry
// in the [COMMANDS] section of asr.sif.
//
typedef struct _ASR_RECOVERY_APP_NODE {
    struct _ASR_RECOVERY_APP_NODE *Next;

    //
    // Expect this to always be 1
    //
    INT SystemKey;

    //
    // The sequence number according to which the apps are run.  If
    // two apps have the same sequence number, the app that appears 
    // first in the sif file is run.
    //
    INT SequenceNumber;

    //
    // The "actionOnCompletion" field for the app.  If CriticalApp is
    // non-zero, and the app returns an non-zero exit-code, we shall
    // consider it a fatal failure and quit out of ASR.
    //
    INT CriticalApp;

    //
    // The app to be launched
    //
    PWSTR RecoveryAppCommand;

    //
    // The paramaters for the app.  This is just concatenated to the
    // string above.  May be NULL.
    //
    PWSTR RecoveryAppParams;

} ASR_RECOVERY_APP_NODE, *PASR_RECOVERY_APP_NODE;


//
// This contains our list of entries in the COMMANDS section,
// sorted in order of sequence numbers.
//
typedef struct _ASR_RECOVERY_APP_LIST {
    PASR_RECOVERY_APP_NODE  First;      // Head
    PASR_RECOVERY_APP_NODE  Last;       // Tail
    LONG AppCount;                      // NumEntries
} ASR_RECOVERY_APP_LIST, *PASR_RECOVERY_APP_LIST;




//
// --------
// function declarations
// --------
//
VOID
AsrpPrintError(
    IN CONST DWORD dwLineNumber,
    IN CONST DWORD dwErrorCode
    );


//
// --------
// macro declarations
// --------
//

/*++

Macro Description:

    This macro wraps calls that are expected to return ERROR_SUCCESS.
    If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
    passed in, calls SetLastError() to set the Last Error to ErrorCode,
    and jumps to the EXIT label in the calling function

Arguments:

    ErrorCondition - Expression to be tested

    LocalStatus - Status variable in the calling function

    ErrorCode - Win 32 error code

--*/
#define ErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {        \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        if (!g_fErrorMessageDone) {                                     \
                                                                        \
            AsrpPrintError(__LINE__, ErrorCode);                        \
                                                                        \
            g_fErrorMessageDone = TRUE;                                 \
                                                                        \
        }                                                               \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}



// 
// Simple macro to allocate and set memory to zero
// 
#define Alloc( p, t, cb ) \
    p = (t) HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY,  cb)


// 
// Simple macro to check a pointer, free it if non-NULL, and set it to NULL.
// 
#define Free( p )                               \
    if ( p ) {                                  \
        HeapFree(g_hHeap, 0L, p);               \
        p = NULL;                               \
    }


//
// Simple macro to check if a handle is valid and close it
//
#define _AsrpCloseHandle( h )                   \
    if ((h) && (INVALID_HANDLE_VALUE != h)) {   \
        CloseHandle(h);                         \
        h = NULL;                               \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\asr_pfu\asr_pfu.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asr_pfu.c

Abstract:

    Application to deal with the recovery of certain special system files 
    that the normal backup/recovery applications are unable to deal with.

    The special file list below has the list of these files.  This is for
    RAID bug 612411.

Author:

    Guhan Suriyanarayanan   (guhans)    01-May-2002

Revision History:

    01-May-2002 guhans      
      Initial creation.  File list contains ntdll.dll and smss.exe.

--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winasr.h>
#include <setupapi.h>

//
//  Macro Description:
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Expression to be tested
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // ErrorCode 
//
#ifdef PRERELEASE
#define pErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {   \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        wprintf(L"Error %lu (0x%x), line %lu\r\n", ErrorCode, ErrorCode, __LINE__);    \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}
#else
#define pErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {   \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}

#endif


//
// This is the hard-coded global list of files that are special
//
const DWORD PFU_NUM_SPECIAL_FILES = 2;

const WCHAR *PFU_SPECIAL_FILE_SOURCES[] = {
    L"%systemroot%\\system32\\ntdll.dll",
    L"%systemroot%\\system32\\smss.exe"
};

const WCHAR *PFU_SPECIAL_FILE_DESTINATIONS[] = {
    L"%systemroot%\\repair\\ntdll.ASR",
    L"%systemroot%\\repair\\smss.ASR"
};

const WCHAR *PFU_SPECIAL_FILE_TEMPFILES[] = {
    L"%systemroot%\\system32\\ntdll.TMP",
    L"%systemroot%\\system32\\smss.TMP"
};


//
// Copy 1MB chunks
//
#define CB_COPY_BUFFER (1024 * 1024)

//
// Constants local to this module
//
const WCHAR PFU_BACKUP_OPTION[]     = L"/backup";
const WCHAR PFU_RESTORE_OPTION[]    = L"/restore";
const WCHAR PFU_REGISTER_OPTION[]   = L"/register";

const WCHAR PFU_ERROR_FILE_PATH[]   = L"%systemroot%\\repair\\asr.err";

const WCHAR PFU_ASR_REGISTER_KEY[]  = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\Commands";
const WCHAR PFU_ASR_REGISTER_NAME[] = L"ASR protected file utility";

#ifdef _IA64_
const WCHAR PFU_CONTEXT_FORMAT[]       = L"/context=%I64u";
#else
const WCHAR PFU_CONTEXT_FORMAT[]       = L"/context=%lu";
#endif


BOOL
PfuAcquirePrivilege(
    IN CONST PCWSTR szPrivilegeName
    )
{
    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );

    if (!bResult) {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL, szPrivilegeName, &luid);
    if (!bResult) {
        CloseHandle(hToken);
        return FALSE;
    }

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );

    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    CloseHandle(hToken);
    return bResult;
}




PWSTR
PfuExpandEnvStrings(
    IN CONST PCWSTR lpOriginalString
    )
/*++

Routine Description:

    Expands the environment-variable strings and replaces them with their 
    defined values. 

Arguments:

    lpOriginalString - Supplies a null-terminated string that contains 
            environment-variable strings of the form: %variableName%.  For each 
            such reference, the %variableName% portion is replaced with the 
            current value of that environment variable. 

            The replacement rules are the same as those used by the command 
            interpreter.  Case is ignored when looking up the 
            environment-variable name. If the name is not found, the 
            %variableName% portion is left undisturbed. 
        
Return Values:
   
    Pointer to memory containing a null-terminated string with the
            environment-variable strings in lpOriginalString replaced with 
            their defined values.  It is the caller's responsibility to free 
            this string using HeapFree(GetProcessHeap(),...).

    NULL on failure.
    
--*/
{
    PWSTR lpExpandedString = NULL;
    
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;

    HANDLE hHeap = GetProcessHeap();

    lpExpandedString = (PWSTR) HeapAlloc(hHeap, 
        HEAP_ZERO_MEMORY, 
        (cchSize * sizeof(WCHAR))
        );
    
    if (lpExpandedString) {
        //
        // Expand the variables using the relevant system call.
        //
        cchRequiredSize = ExpandEnvironmentStringsW(lpOriginalString, 
            lpExpandedString,
            cchSize 
            );

        if (cchRequiredSize > cchSize) {
            //
            // Buffer wasn't big enough; free and re-allocate as needed
            //
            HeapFree(hHeap, 0L, lpExpandedString);
            cchSize = cchRequiredSize + 1;

            lpExpandedString = (PWSTR) HeapAlloc(hHeap, 
                HEAP_ZERO_MEMORY, 
                (cchSize * sizeof(WCHAR))
                );
            
            if (lpExpandedString) {
                cchRequiredSize = ExpandEnvironmentStringsW(lpOriginalString, 
                    lpExpandedString, 
                    cchSize 
                    );
            }
        }

        if ((lpExpandedString) &&
            ((0 == cchRequiredSize) || (cchRequiredSize > cchSize))) {
            //
            // Either the function failed, or the buffer wasn't big enough 
            // even on the second try
            //
            HeapFree(hHeap, 0L, lpExpandedString);
            lpExpandedString = NULL;
        }
    }

    return lpExpandedString;
}


HANDLE
PfuOpenErrorFile(
    VOID
    ) 
/*++

Routine Description:

    Opens the well-known ASR error file for read/write access, moves the file 
    pointer to the end of the file.
    
Arguments:

    None.

Return Values:

    A handle to the well-defined ASR error file.  The caller is responsible for
            closing this handle with CloseHandle() when he is done.

    INVALID_HANDLE_VALUE on errors.

    
--*/
{
    PWSTR szErrorFilePath = NULL;
    HANDLE hErrorFile = INVALID_HANDLE_VALUE;

    //
    // Get full path to the error file.
    //
    szErrorFilePath = PfuExpandEnvStrings(PFU_ERROR_FILE_PATH);

    //
    // Open the error file
    //
    if (szErrorFilePath) {
        
        hErrorFile = CreateFileW(
            szErrorFilePath,            // lpFileName
            GENERIC_WRITE | GENERIC_READ,       // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,                       // lpSecurityAttributes
            OPEN_ALWAYS,                // dwCreationFlags
            FILE_FLAG_WRITE_THROUGH,    // dwFlagsAndAttributes
            NULL                        // hTemplateFile
            );

        //
        // Free memory once we're done with it
        //
        HeapFree(GetProcessHeap(), 0L, szErrorFilePath);
        szErrorFilePath = NULL;

        if (INVALID_HANDLE_VALUE != hErrorFile) {
            //
            // Move to the end of file
            //
            SetFilePointer(hErrorFile, 0L, NULL, FILE_END);
        }
    }

    return hErrorFile;
}


BOOL
PfuLogErrorMessage(
    IN CONST PCWSTR lpErrorMessage
    ) 
/*++

Routine Description:

    Logs an error message to the well-known ASR error file.
    
Arguments:

    lpErrorMessage - Supplies a null-terminated string to be logged to the
            ASR error file.

            This argument must be non-NULL.

Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    DWORD dwBytes = 0;
    WCHAR szBuffer[1024];
    BOOL bResult = FALSE;
    SYSTEMTIME currentTime;
    HANDLE hErrorFile = INVALID_HANDLE_VALUE;

    hErrorFile = PfuOpenErrorFile();
    
    if (INVALID_HANDLE_VALUE != hErrorFile) {
        //
        // Create our string, and write it out
        //
        GetLocalTime(&currentTime);
        
        swprintf(szBuffer,
            L"\r\n[%04hu/%02hu/%02hu %02hu:%02hu:%02hu ASR_PFU] (ERROR) ",
            currentTime.wYear,
            currentTime.wMonth,
            currentTime.wDay,
            currentTime.wHour,
            currentTime.wMinute,
            currentTime.wSecond
            );
        wcsncat(szBuffer, lpErrorMessage, 964);
        szBuffer[1023] = L'\0';

        bResult = WriteFile(hErrorFile,
            szBuffer,
            (wcslen(szBuffer) * sizeof(WCHAR)),
            &dwBytes,
            NULL
            );

    }

    if (INVALID_HANDLE_VALUE != hErrorFile) {
        CloseHandle(hErrorFile);
    }

    return bResult;
}


BOOL 
PfuCopyFilesDuringBackup(
    VOID
    )
/*++

Routine Description:

    Copies the special protected files to the special location that we'll
    expect to find them during the restore.
    
Arguments:

    None.
    
Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    BOOL bResult = FALSE,
        bDone = FALSE;

    DWORD dwCount = 0,
        cbRead = 0,
        cbWritten = 0;

    DWORD dwStatus = ERROR_SUCCESS;

    PWSTR lpSource = NULL,
        lpDestination = NULL;

    HANDLE hSource = INVALID_HANDLE_VALUE,
        hDestination = INVALID_HANDLE_VALUE;

    LPBYTE lpBuffer = NULL;

    LPVOID pvReadContext = NULL,
        pvWriteContext = NULL;

    HANDLE hHeap = GetProcessHeap();

    lpBuffer = (LPBYTE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, CB_COPY_BUFFER);
    pErrExitCode((NULL == lpBuffer), dwStatus, GetLastError());

    for (dwCount = 0; dwCount < PFU_NUM_SPECIAL_FILES; dwCount++) {
        //
        // Get the full source and destination strings
        //
        lpSource = PfuExpandEnvStrings(PFU_SPECIAL_FILE_SOURCES[dwCount]);
        pErrExitCode(!lpSource, dwStatus, GetLastError());

        lpDestination = PfuExpandEnvStrings(PFU_SPECIAL_FILE_DESTINATIONS[dwCount]);
        pErrExitCode(!lpDestination, dwStatus, GetLastError());


        //
        // We can't just use CopyFile since it doesn't seem to be able to write
        // to the repair folder, despite the backup and restore privileges 
        // being enabled.  So we get the pleasure of using BackupRead and 
        // BackupWrite instead.
        //

        //
        // Open handles to the source and destination files
        //
        hSource = CreateFile(lpSource, 
            GENERIC_READ, 
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS,
            INVALID_HANDLE_VALUE
            );
        pErrExitCode((INVALID_HANDLE_VALUE == hSource), dwStatus, GetLastError());

        hDestination = CreateFile(lpDestination,         
            GENERIC_WRITE | WRITE_DAC | WRITE_OWNER, 
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
            INVALID_HANDLE_VALUE
            );
        pErrExitCode((INVALID_HANDLE_VALUE == hDestination), dwStatus, GetLastError());

        bDone = FALSE;
        pvReadContext = NULL;
        pvWriteContext = NULL;

        while (!bDone) {
            
            bResult = BackupRead(
                hSource,                // hFile
                lpBuffer,               // lpBuffer
                CB_COPY_BUFFER,         // nNumberOfBytesToWrite
                &cbRead,                // lpNumberOfBytesWritten
                FALSE,                  // bAbort
                TRUE,                   // bProcessSecurity
                &pvReadContext          // lpContext
                );
            pErrExitCode((!bResult), dwStatus, GetLastError());
            
            if (cbRead > 0) {
                //
                // Write to the destination file
                //
                bResult = BackupWrite(
                    hDestination,       // hFile
                    lpBuffer,           // lpBuffer
                    cbRead,             // nNumberOfBytesToWrite
                    &cbWritten,         // lpNumberOfBytesWritten
                    FALSE,              // bAbort
                    TRUE,               // bProcessSecurity
                    &pvWriteContext     // *lpContext
                    );
                pErrExitCode((!bResult), dwStatus, GetLastError());
            }
            else {
                // 
                // We're done with this file
                //
                bResult = BackupRead(
                    hSource,              
                    lpBuffer,             
                    CB_COPY_BUFFER,       
                    &cbRead,              
                    TRUE,               // bAbort
                    TRUE,                 
                    &pvReadContext      // lpContext
                    );

                pvReadContext = NULL;
                
                bResult = BackupWrite(
                    hDestination,       
                    lpBuffer,           
                    cbRead,             
                    &cbWritten,         
                    TRUE,               // bAbort
                    TRUE,               
                    &pvWriteContext     // lpContext
                    );

                pvWriteContext = NULL;

                bDone = TRUE;
            }
                
        }


        HeapFree(hHeap, 0L, lpSource);
        lpSource = NULL;

        HeapFree(hHeap, 0L, lpDestination);
        lpDestination = NULL;
    }

EXIT:
    if (lpBuffer) {
        HeapFree(hHeap, 0L, lpBuffer);
        lpBuffer = NULL;
    }
        
    if (lpSource) {
        HeapFree(hHeap, 0L, lpSource);
        lpSource = NULL;
    }

    if (lpDestination) {
        HeapFree(hHeap, 0L, lpDestination);
        lpDestination = NULL;
    }

    return (ERROR_SUCCESS == dwStatus);
}


BOOL
PfuBackupState(
    IN CONST DWORD_PTR AsrContext
    )
/*++

Routine Description:

    Does the special handling necessary during an ASR backup.  This essentially
    involves two steps: copying the special protected files we care about
    to a special location, and adding an entry in asr.sif to allow us to 
    be called during the recovery.
    
Arguments:

    AsrContext - Supplies a AsrContext that is to be passed to the ASR API
            for adding entries to the ASR state file.

            This argument must be non-NULL.

Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    BOOL bResult = FALSE;
    HMODULE hSyssetup = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL (*pfnAddSifEntry)(DWORD_PTR, PCWSTR, PCWSTR);

    bResult = PfuAcquirePrivilege(SE_BACKUP_NAME);
    pErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);
    
    bResult = PfuAcquirePrivilege(SE_RESTORE_NAME);
    pErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);

    // 
    // Load syssetup.dll for the AsrAddSifEntry call
    //
    hSyssetup = LoadLibraryW(L"syssetup.dll");
    pErrExitCode((NULL == hSyssetup), dwStatus, GetLastError());

    // 
    // Get the AsrAddSifEntryW API exported by syssetup.dll
    //
    
    //     
    // BOOL
    // AsrAddSifEntryW(
    //     IN  DWORD_PTR   AsrContext,
    //     IN  PCWSTR      lpSectionName,
    //     IN  PCWSTR      lpSifEntry
    //     );
    // 
    pfnAddSifEntry = (BOOL (*) (DWORD_PTR, PCWSTR, PCWSTR)) GetProcAddress(
        hSyssetup, 
        "AsrAddSifEntryW"
        );
    pErrExitCode((!pfnAddSifEntry), dwStatus,  GetLastError());

    //
    // Copy the special protected files of interest.
    //
    bResult = PfuCopyFilesDuringBackup();
    pErrExitCode(!bResult, dwStatus, GetLastError());

    //
    // Add an entry to the commands section, so that we get called during the 
    // ASR recovery.
    //
    
    //
    // COMMANDS section entry format:
    // system-key,sequence-number,action-on-completion,"command","parameters"
    // system-key must be 1
    // 1000 <= sequence-number <= 4999
    // 0 <= action-on-completion <= 1
    //
    bResult = pfnAddSifEntry(
        AsrContext,
        ASR_SIF_SECTION_COMMANDS,
        L"1,4990,1,\"%SystemRoot%\\system32\\asr_pfu.exe\",\"/restore\""
        );
    pErrExitCode(!bResult, dwStatus, GetLastError());

EXIT:
    //
    // Cleanup
    //
    if (NULL != hSyssetup) {
        FreeLibrary(hSyssetup);
        hSyssetup = NULL;
    }

    SetLastError(dwStatus);
    
    return (ERROR_SUCCESS == dwStatus);
}


BOOL
PfuRestoreState(
    VOID
    )
/*++

Routine Description:

    Does the special handling necessary during an ASR restore.  This essentially
    involves copying the special protected files we care about back from the 
    special location (that we copied them to while doing the backup).
    
Arguments:

    None.
    
Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    BOOL bResult = FALSE;

    DWORD dwCount = 0;

    DWORD dwStatus = ERROR_SUCCESS;

    PWSTR lpSource = NULL,
        lpDestination = NULL,
        lpTempFile = NULL;

    HANDLE hHeap = GetProcessHeap();
    
    bResult = PfuAcquirePrivilege(SE_BACKUP_NAME);
    pErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);
    
    bResult = PfuAcquirePrivilege(SE_RESTORE_NAME);
    pErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);


    for (dwCount = 0; dwCount < PFU_NUM_SPECIAL_FILES; dwCount++) {
        //
        // Get the full source and destination strings--they are reversed
        // at the time of the restore!
        //
        lpSource = PfuExpandEnvStrings(PFU_SPECIAL_FILE_DESTINATIONS[dwCount]);
        pErrExitCode(!lpSource, dwStatus, GetLastError());

        lpDestination = PfuExpandEnvStrings(PFU_SPECIAL_FILE_SOURCES[dwCount]);
        pErrExitCode(!lpDestination, dwStatus, GetLastError());

        lpTempFile = PfuExpandEnvStrings(PFU_SPECIAL_FILE_TEMPFILES[dwCount]);
        pErrExitCode(!lpDestination, dwStatus, GetLastError());

        //
        // Rename the destination if it already exists, and copy the file back
        //
        bResult = MoveFileEx(lpDestination, lpTempFile, MOVEFILE_REPLACE_EXISTING);

        bResult = CopyFile(lpSource, lpDestination, FALSE);
        pErrExitCode(!bResult, dwStatus, GetLastError());

        HeapFree(hHeap, 0L, lpSource);
        lpSource = NULL;

        HeapFree(hHeap, 0L, lpDestination);
        lpDestination = NULL;
        
        HeapFree(hHeap, 0L, lpTempFile);
        lpTempFile = NULL;
    }

EXIT:    
    if (lpSource) {
        HeapFree(hHeap, 0L, lpSource);
        lpSource = NULL;
    }

    if (lpDestination) {
        HeapFree(hHeap, 0L, lpDestination);
        lpDestination = NULL;
    }

    if (lpTempFile) {
        HeapFree(hHeap, 0L, lpTempFile);
        lpTempFile = NULL;
    }

    return (ERROR_SUCCESS == dwStatus);
}


BOOL
PfuRegisterApp(
    IN CONST PCWSTR lpApplicationName
    ) 
/*++

Routine Description:

    Adds the registry keys necessary to let ASR know that we wish to be
    run at ASR backup time.
    
Arguments:

    lpApplicationName - Supplies a null-terminated string representing the 
            full path to the application being registered.
    
Return Values:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    WCHAR szData[1024];
    HKEY hKeyAsr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    if (wcslen(lpApplicationName) > 1000) {
        dwStatus = ERROR_INSUFFICIENT_BUFFER;
    }

    // 
    // Open the registry key
    //
    if (ERROR_SUCCESS == dwStatus) {
        
        dwStatus = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,         // hKey
            PFU_ASR_REGISTER_KEY,       // lpSubKey
            0,                          // ulOptions--Reserved, must be 0
            MAXIMUM_ALLOWED,            // samDesired
            &hKeyAsr                    // phkbResult    
            );
    }

    //
    // And set the value
    //
    if (ERROR_SUCCESS == dwStatus) {
        
        wsprintf(szData, L"%ws %ws", lpApplicationName, PFU_BACKUP_OPTION);
        
        dwStatus = RegSetValueExW(
            hKeyAsr,                    // hKey
            PFU_ASR_REGISTER_NAME,      // lpValueName
            0,                          // dwReserved, must be 0
            REG_EXPAND_SZ,              // dwType
            (LPBYTE)szData,             // lpData
            ((wcslen(szData) + 1)* (sizeof(WCHAR))) // cbData
            );
    }

    SetLastError(dwStatus);
    return (ERROR_SUCCESS == dwStatus);
}


int 
__cdecl     // var arg
wmain (
    int     argc,
    wchar_t *argv[],
    wchar_t *envp[]
    ) 
{
    BOOL bResult = FALSE;
    
    DWORD dwStatus = ERROR_INVALID_PARAMETER;
    SetLastError(ERROR_INVALID_PARAMETER);

    if (argc >= 3) {
        
        if (!_wcsicmp(argv[1], PFU_BACKUP_OPTION)) {
            //
            // asr_pfu /backup /context=nnn
            //
            DWORD_PTR  AsrContext = 0;

            //
            // Extract the asr context from the commandline
            //
            int i = swscanf(argv[2], PFU_CONTEXT_FORMAT, &AsrContext);

            if (EOF != i) {
                //
                // Create our spooge and write to the asr.sif
                //
                bResult = PfuBackupState(AsrContext);
            }

            
        } 
        else if (!_wcsicmp(argv[1], PFU_RESTORE_OPTION)) {
            //
            // asr_pfu /restore /sifpath="c:\winnt\repair\asr.sif"
            //
            bResult = PfuRestoreState();
            
        }
        else if (!_wcsicmp(argv[1], PFU_REGISTER_OPTION)) {
            //
            // asr_pfu /register "c:\windows\system32\asr_pfu.exe"
            //
            bResult = PfuRegisterApp(argv[2]);
        }

        if (bResult) {
            dwStatus = ERROR_SUCCESS;
        }
        else {
            dwStatus = GetLastError();
        }
    }

    if (!bResult) {
        //
        // ?
        //
    }

    SetLastError(dwStatus);
    return (int) dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\confdisk\critdrv.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    critdrv.cpp

Abstract:
    
    This module contains routines create a list of the critical volumes on a 
    system.  This is lifted directly from base\fs\utils\ntback50\ui.

Author:

    Brian Berkowitz   (brianb)    10-Mar-2000

Environment:

    User-mode only.

Revision History:

    10-Mar-2000 brianb
        Initial creation

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <objbase.h>
#include <initguid.h>
#include <frsapip.h>
#include <critdrv.h>



// FRS iteration class.  Used to iterate through replica sets to
// determine the paths for these replica sets
// constructor
CFRSIter::CFRSIter() :
    m_fInitialized(FALSE),
    m_hLib(NULL),
    m_pfnFrsInitBuRest(NULL),
    m_pfnFrsEndBuRest(NULL),
    m_pfnFrsGetSets(NULL),
    m_pfnFrsEnumSets(NULL),
    m_pfnFrsIsSetSysVol(NULL),
    m_pfnFrsGetPath(NULL),
    m_pfnFrsGetOtherPaths(NULL),
    m_stateIteration(x_IterNotStarted)
    {
    }

// destructor
CFRSIter::~CFRSIter()
    {
    if (m_stateIteration == x_IterStarted)
        CleanupIteration();

    if (m_hLib)
        FreeLibrary(m_hLib);
    }

// initialize entry points and load library
void CFRSIter::Init()
    {
    if (m_fInitialized)
        return;

    // load library
    m_hLib = LoadLibrary(L"ntfrsapi.dll");
    if (m_hLib)
        {
        // assign etntry points
        m_pfnFrsInitBuRest = (PF_FRS_INIT) GetProcAddress(m_hLib, "NtFrsApiInitializeBackupRestore");
        m_pfnFrsEndBuRest = (PF_FRS_DESTROY) GetProcAddress(m_hLib, "NtFrsApiDestroyBackupRestore");
        m_pfnFrsGetSets = (PF_FRS_GET_SETS) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSets");
        m_pfnFrsEnumSets = (PF_FRS_ENUM_SETS) GetProcAddress(m_hLib, "NtFrsApiEnumBackupRestoreSets");
        m_pfnFrsIsSetSysVol = (PF_FRS_IS_SYSVOL) GetProcAddress(m_hLib, "NtFrsApiIsBackupRestoreSetASysvol");
        m_pfnFrsGetPath = (PF_FRS_GET_PATH) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSetDirectory");
        m_pfnFrsGetOtherPaths = (PF_FRS_GET_OTHER_PATHS) GetProcAddress(m_hLib, "NtFrsApiGetBackupRestoreSetPaths");
        if (m_pfnFrsInitBuRest == NULL ||
            m_pfnFrsEndBuRest == NULL ||
            m_pfnFrsGetSets == NULL ||
            m_pfnFrsEnumSets == NULL ||
            m_pfnFrsIsSetSysVol == NULL ||
            m_pfnFrsGetOtherPaths == NULL ||
            m_pfnFrsGetPath == NULL)
            {
            // if we can't get to any entry point, free library and
            // fail operation
            FreeLibrary(m_hLib);
            m_hLib = NULL;
            }
        }

    // indicate that operation is successful
    m_fInitialized = TRUE;
    }


// initialize the iterator.  Return FALSE if iterator is known to be empty
//
BOOL CFRSIter::BeginIteration()
    {
    ASSERT(m_stateIteration == x_IterNotStarted);
    DWORD status;
    if (m_hLib == NULL)
        {
        // if we are not initialized, then there is nothing to iterate
        // over
        m_stateIteration = x_IterComplete;
        return FALSE;
        }

    // initialize FRS backup restore apis
    status = m_pfnFrsInitBuRest
                    (
                    NULL,
                    NTFRSAPI_BUR_FLAGS_NORMAL|NTFRSAPI_BUR_FLAGS_BACKUP,
                    &m_frs_context
                    );

    if (status != ERROR_SUCCESS)
        {
        // if this fails then we are done
        m_stateIteration = x_IterComplete;
        return FALSE;
        }

    // indicate that we started the iteration
    m_stateIteration = x_IterStarted;
    status = m_pfnFrsGetSets(m_frs_context);
    if (status != ERROR_SUCCESS)
        {
        // if there are no sets, then indicate we are done
        CleanupIteration();
        return FALSE;
        }

    // start at first set
    m_iset = 0;
    return TRUE;
    }

// cleanup iteration after scanning the last element
void CFRSIter::CleanupIteration()
    {
    m_pfnFrsEndBuRest(&m_frs_context, NTFRSAPI_BUR_FLAGS_NONE, NULL, NULL, NULL);
    m_stateIteration = x_IterComplete;
    }


// get next iteration set returning the path to the set
// NULL indicates end of iteration
// If fSkipToSysVol is TRUE then ignore non SysVol replication sets
LPWSTR CFRSIter::GetNextSet(BOOL fSkipToSysVol, LPWSTR *pwszPaths)
    {
    ASSERT(pwszPaths);
    ASSERT(m_stateIteration != x_IterNotStarted);
    if (m_stateIteration == x_IterComplete)
        // if iteration is complete, then we are done
        return NULL;

    PVOID frs_set;

    while(TRUE)
        {
        // get a set
        DWORD status = m_pfnFrsEnumSets(m_frs_context, m_iset, &frs_set);
        if (status != ERROR_SUCCESS)
            {
            // if this fails, then we are done
            CleanupIteration();
            return NULL;
            }

        if (fSkipToSysVol)
            {
            // we are looking for system volumes
            BOOL fSysVol;

            // test whether this is a system volume
            status = m_pfnFrsIsSetSysVol(m_frs_context, frs_set, &fSysVol);
            if (status != ERROR_SUCCESS)
                {
                // if this operation fails, terminate iteration
                CleanupIteration();
                return NULL;
                }

            if (!fSysVol)
                {
                // if not a system volume, then skip to the next
                // replica set
                m_iset++;
                continue;
                }
            }


        // scratch pad for path
        WCHAR wsz[MAX_PATH];
        DWORD cbPath = MAX_PATH * sizeof(WCHAR);

        // get path to root of the replica set
        status = m_pfnFrsGetPath
            (
            m_frs_context,
            frs_set,
            &cbPath,
            wsz
            );

        WCHAR *wszNew = NULL;
        // allocate memory for root
        if (status == ERROR_SUCCESS || status == ERROR_INSUFFICIENT_BUFFER)
            {
            wszNew = new WCHAR[cbPath/sizeof(WCHAR)];

            // if allocation fails, then throw OOM
            if (wszNew == NULL)
                throw E_OUTOFMEMORY;

            if (status == ERROR_SUCCESS)
                // if the operation was successful, then copy
                // path into memory
                memcpy(wszNew, wsz, cbPath);
            else
                {
                // otherwise redo the operation
                status = m_pfnFrsGetPath
                    (
                    m_frs_context,
                    frs_set,
                    &cbPath,
                    wszNew
                    );

                if (status != ERROR_SUCCESS)
                    {
                    // if operation failed then second time, then
                    // delete allocated memory and terminate iteration
                    delete wszNew;
                    CleanupIteration();
                    return NULL;
                    }
                }
            }
        else
            {
            // if operation failed due to any error other than
            // insufficient buffer, then terminate the iteration
            CleanupIteration();
            return NULL;
            }


        // scratch pad for filters
        WCHAR wszFilter[MAX_PATH];
        DWORD cbFilter = MAX_PATH * sizeof(WCHAR);

        // length of scratch pad for paths
        cbPath = MAX_PATH * sizeof(WCHAR);

        // obtain other paths
        status = m_pfnFrsGetOtherPaths
            (
            m_frs_context,
            frs_set,
            &cbPath,
            wsz,
            &cbFilter,
            wszFilter
            );

        WCHAR *wszNewPaths = NULL;
        WCHAR *wszNewFilter = NULL;
        if (status == ERROR_SUCCESS || status == ERROR_INSUFFICIENT_BUFFER)
            {
            // allocate space for paths
            wszNewPaths = new WCHAR[cbPath/sizeof(WCHAR)];

            // allocate space for filters
            wszNewFilter = new WCHAR[cbFilter/sizeof(WCHAR)];
            if (wszNew == NULL || wszFilter == NULL)
                {
                // if any allocation fails, then throw OOM
                delete wszNew;
                throw E_OUTOFMEMORY;
                }

            if (status == ERROR_SUCCESS)
                {
                // if operation was successful, then copy
                // in allocated paths
                memcpy(wszNewPaths, wsz, cbPath);
                memcpy(wszNewFilter, wszFilter, cbFilter);
                }
            else
                {
                status = m_pfnFrsGetOtherPaths
                    (
                    m_frs_context,
                    frs_set,
                    &cbPath,
                    wszNew,
                    &cbFilter,
                    wszNewFilter
                    );

                if (status != ERROR_SUCCESS)
                    {
                    delete wszNew;
                    delete wszNewFilter;
                    CleanupIteration();
                    return NULL;
                    }
                }
            }
        else
            {
            // if any error other than success or INSUFFICENT_BUFFER
            // then terminate iteration
            CleanupIteration();
            return NULL;
            }

        // delete allocated filter
        delete wszNewFilter;

        // set iteration to next set
        m_iset++;

        // return pointer to paths
        *pwszPaths = wszNewPaths;

        // return path of root of replicated set
        return wszNew;
        }
    }


// terminate iteration, cleaning up anything that needs to be
// cleaned up
//
void CFRSIter::EndIteration()
    {
    ASSERT(m_stateIteration != x_IterNotStarted);
    if (m_stateIteration == x_IterStarted)
        CleanupIteration();

    // indicate that iteration is no longer in progress
    m_stateIteration = x_IterNotStarted;
    }

// constructor for string data structure
CWStringData::CWStringData()
    {
    m_psdlFirst = NULL;
    m_psdlCur = NULL;
    }

// destructor
CWStringData::~CWStringData()
    {
    while(m_psdlFirst)
        {
        WSTRING_DATA_LINK *psdl = m_psdlFirst;
        m_psdlFirst = m_psdlFirst->m_psdlNext;
        delete psdl;
        }
    }

// allocate a new link
void CWStringData::AllocateNewLink()
    {
    WSTRING_DATA_LINK *psdl = new WSTRING_DATA_LINK;
    if (psdl == NULL)
        throw E_OUTOFMEMORY;

    psdl->m_psdlNext = NULL;
    if (m_psdlCur)
        {
        ASSERT(m_psdlFirst);
        m_psdlCur->m_psdlNext = psdl;
        m_psdlCur = psdl;
        }
    else
        {
        ASSERT(m_psdlFirst == NULL);
        m_psdlFirst = m_psdlCur = psdl;
        }

    m_ulNextString = 0;
    }

// allocate a string
LPWSTR CWStringData::AllocateString(unsigned cwc)
    {
    ASSERT(cwc <= sizeof(m_psdlCur->rgwc));

    if (m_psdlCur == NULL)
        AllocateNewLink();

    if (sizeof(m_psdlCur->rgwc) <= (cwc + 1 + m_ulNextString) * sizeof(WCHAR))
        AllocateNewLink();

    unsigned ulOff = m_ulNextString;
    m_ulNextString += cwc + 1;
    return m_psdlCur->rgwc + ulOff;
    }

// copy a string
LPWSTR CWStringData::CopyString(LPCWSTR wsz)
    {
    unsigned cwc = (wsz == NULL) ? 0 : wcslen(wsz);
    LPWSTR wszNew = AllocateString(cwc);
    memcpy(wszNew, wsz, cwc * sizeof(WCHAR));
    wszNew[cwc] = '\0';
    return wszNew;
    }


// constructor for volume list
CVolumeList::CVolumeList() :
    m_rgwszVolumes(NULL),       // array of volumes
    m_cwszVolumes(0),           // # of volumes in array
    m_cwszVolumesMax(0),        // size of array
    m_rgwszPaths(NULL),         // array of paths
    m_cwszPaths(0),             // # of paths in array
    m_cwszPathsMax(0)           // size of array
    {
    }

// destructor
CVolumeList::~CVolumeList()
    {
    delete m_rgwszPaths;        // delete paths array
    delete m_rgwszVolumes;      // delete volumes array
    }

// add a path to the list if it is not already there
// return TRUE if it is a new path
// return FALSE if path is already in list
//
BOOL CVolumeList::AddPathToList(LPWSTR wszPath)
    {
    // look for path in list.  If found, then return FALSE
    for(unsigned iwsz = 0; iwsz < m_cwszPaths; iwsz++)
        {
        if (_wcsicmp(wszPath, m_rgwszPaths[iwsz]) == 0)
            return FALSE;
        }

    // grow pat array if needed
    if (m_cwszPaths == m_cwszPathsMax)
        {
        // grow path array
        LPCWSTR *rgwsz = new LPCWSTR[m_cwszPaths + x_cwszPathsInc];

        // throw OOM if memory allocation fails
        if (rgwsz == NULL)
            throw(E_OUTOFMEMORY);

        memcpy(rgwsz, m_rgwszPaths, m_cwszPaths * sizeof(LPCWSTR));
        delete m_rgwszPaths;
        m_rgwszPaths = rgwsz;
        m_cwszPathsMax += x_cwszPathsInc;
        }

    // add path to array
    m_rgwszPaths[m_cwszPaths++] = m_sd.CopyString(wszPath);
    return TRUE;
    }

// add a volume to the list if it is not already there
// return TRUE if it is added
// return FALSE if it is already on the list
//
BOOL CVolumeList::AddVolumeToList(LPCWSTR wszVolume)
    {
    // look for volume in array.  If found then return FALSE
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        {
        if (_wcsicmp(wszVolume, m_rgwszVolumes[iwsz]) == 0)
            return FALSE;
        }

    // grow volume array if necessary
    if (m_cwszVolumes == m_cwszVolumesMax)
        {
        // grow volume array
        LPCWSTR *rgwsz = new LPCWSTR[m_cwszVolumes + x_cwszVolumesInc];
        if (rgwsz == NULL)
            throw(E_OUTOFMEMORY);

        memcpy(rgwsz, m_rgwszVolumes, m_cwszVolumes * sizeof(LPCWSTR));
        delete m_rgwszVolumes;
        m_rgwszVolumes = rgwsz;
        m_cwszVolumesMax += x_cwszVolumesInc;
        }

    // add volume name to array
    m_rgwszVolumes[m_cwszVolumes++] = m_sd.CopyString(wszVolume);
    return TRUE;
    }


const WCHAR x_wszVolumeRootName[] = L"\\\\?\\GlobalRoot\\Device\\";
const unsigned x_cwcVolumeRootName = sizeof(x_wszVolumeRootName)/sizeof(WCHAR) - 1;

// add a path to our tracking list.  If the path is new add it to the
// paths list.  If it is a mount point or the root of a volume, then
// determine the volume and add the volume to the list of volumes
//
// can throw E_OUTOFMEMORY
//
void CVolumeList::AddPath(LPWSTR wszTop)
    {
    // if path is known about then return
    if (!AddPathToList(wszTop))
        return;

    // length of path
    unsigned cwc = wcslen(wszTop);

    // copy path so that we can add backslash to the end of the path
    LPWSTR wszCopy = new WCHAR[cwc + 2];

    // if fails, then throw OOM
    if (wszCopy == NULL)
        throw E_OUTOFMEMORY;

    // copyh in original path
    memcpy(wszCopy, wszTop, cwc * sizeof(WCHAR));

    // append backslash
    wszCopy[cwc] = L'\\';
    wszCopy[cwc + 1] = L'\0';
    while(TRUE)
        {
        // check for a device root
        unsigned cwc = wcslen(wszCopy);
        if ((cwc == 3 && wszCopy[1] == ':') ||
            (cwc > x_cwcVolumeRootName &&
             memcmp(wszCopy, x_wszVolumeRootName, x_cwcVolumeRootName * sizeof(WCHAR)) == 0))
            {
            // call TryAddVolume with TRUE indicating this is a volume root
            TryAddVolumeToList(wszCopy, TRUE);
            break;
            }

        // call TryAddVolume indicating this is not a known device root
        if (TryAddVolumeToList(wszCopy, FALSE))
            break;

        // move back to previous backslash
        WCHAR *pch = wszCopy + cwc - 2;
        while(--pch > wszTop)
            {
            if (pch[1] == L'\\')
                {
                pch[2] = L'\0';
                break;
                }
            }

        if (pch == wszTop)
            break;

        // if path is known about then return
        if (!AddPathToList(wszCopy))
            break;
        }
    }



// determine if a path is a volume.  If so then add it to the volume
// list and return TRUE.  If not, then return FALSE.  fVolumeRoot indicates
// that the path is of the form x:\.  Otherwise the path is potentially
// an mount point.  Validate that it is a reparse point and then try
// finding its volume guid.  If this fails, then assume that it is not
// a volume root.  If it succeeds, then add the volume guid to the volumes
// list and return TRUE.
//
BOOL CVolumeList::TryAddVolumeToList(LPCWSTR wszPath, BOOL fVolumeRoot)
    {
    WCHAR wszVolume[256];

    if (fVolumeRoot)
        {
        if (!GetVolumeNameForVolumeMountPoint(wszPath, wszVolume, sizeof(wszVolume)/sizeof(WCHAR)))
            // might be the EFI system partition, just pass in the path as the volume string.
            wcscpy( wszVolume, wszPath );            
            //throw E_UNEXPECTED;
        }
    else
        {
        DWORD dw = GetFileAttributes(wszPath);
        if (dw == -1)
            return FALSE;

        if ((dw & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
            return FALSE;

        if (!GetVolumeNameForVolumeMountPoint(wszPath, wszVolume, sizeof(wszVolume)/sizeof(WCHAR)))
            return FALSE;
        }

    AddVolumeToList(wszVolume);
    return TRUE;
    }


// add a file to the volume list.  Simply finds the parent path and adds it
//
void CVolumeList::AddFile(LPWSTR wsz)
    {
    unsigned cwc = wcslen(wsz);
    WCHAR *pwc = wsz + cwc - 1;
    while(pwc[1] != L'\\' && pwc != wsz)
        continue;

    pwc[1] = '\0';
    AddPath(wsz);
    }

// obtain list of volumes as a MULTI_SZ,  caller is responsible for freeing
// the string
//
LPWSTR CVolumeList::GetVolumeList()
    {
    unsigned cwc = 1;

    // compute length of volume list it is length of each string +
    // null character + null charactor for last double NULL
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        cwc += wcslen(m_rgwszVolumes[iwsz]) + 1;

    // allocate string
    LPWSTR wsz = new WCHAR[cwc];

    // throw OOM if memory allocation failed
    if (wsz == NULL)
        throw E_OUTOFMEMORY;

    // copy in strings
    WCHAR *pwc = wsz;
    for(unsigned iwsz = 0; iwsz < m_cwszVolumes; iwsz++)
        {
        cwc = wcslen(m_rgwszVolumes[iwsz]) + 1;
        memcpy(pwc, m_rgwszVolumes[iwsz], cwc * sizeof(WCHAR));
		/* replace \\?\ with \??\ */
		memcpy(pwc, L"\\??", sizeof(WCHAR) * 3);

		// delete trailing backslash if it exists
		if (pwc[cwc - 2] == L'\\')
			{
			pwc[cwc-2] = L'\0';
			cwc--;
			}

        pwc += cwc;
        }

    // last null termination
    *pwc = L'\0';

    return wsz;
    }


// path to volume of boot device is
// HKEY_LOCAL_MACHINE\System\Setup
//with Value of SystemPartition parametr
LPCWSTR x_SetupRoot = L"System\\Setup";

// magic perfix for volume devices
WCHAR x_wszWin32VolumePrefix[] = L"\\\\?\\GlobalRoot";
const unsigned x_cwcWin32VolumePrefix = sizeof(x_wszWin32VolumePrefix)/sizeof(WCHAR) - 1;

// structure representing a path from
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
// and a value to look up
typedef struct _SVCPARM
    {
    LPCWSTR wszPath;
    LPCWSTR wszValue;
    } SVCPARM;


const SVCPARM x_rgdbparms[] =
    {
        {L"CertSvc\\Configuration", L"DBDirectory"},
        {L"CertSvc\\Configuration", L"DBLogDirectory"},
        {L"CertSvc\\Configuration", L"DBSystemDirectory"},
        {L"CertSvc\\Configuration", L"DBTempDirectory"},
        {L"DHCPServer\\Parameters", L"DatabasePath"},
        {L"DHCPServer\\Parameters", L"DatabaseName"},
        {L"DHCPServer\\Parameters", L"BackupDatabasePath"},
        {L"NTDS\\Parameters", L"Database backup path"},
        {L"NTDS\\Parameters", L"Databases log files path"},
        {L"Ntfrs\\Parameters\\Replica Sets", L"Database Directory"}
    };

const unsigned x_cdbparms = sizeof(x_rgdbparms)/sizeof(SVCPARM);

LPCWSTR x_wszSvcRoot = L"System\\CurrentControlSet\\Services";

// add roots for various services
BOOL AddServiceRoots(CVolumeList &vl)
    {
    HKEY hkeyRoot;
    // open HKLM\System\CurrentControlSet\Services
    if (RegOpenKey(HKEY_LOCAL_MACHINE, x_wszSvcRoot, &hkeyRoot) != ERROR_SUCCESS)
        return FALSE;

    // loop through individual paths
    for(unsigned i = 0; i < x_cdbparms; i++)
        {
        WCHAR wsz[MAX_PATH*4];
        LPCWSTR wszPath = x_rgdbparms[i].wszPath;
        LPCWSTR wszValue = x_rgdbparms[i].wszValue;

        HKEY hkey;
        DWORD cb = sizeof(wsz);
        DWORD type;

        // open path, skip if open fails
        if (RegOpenKey(hkeyRoot, wszPath, &hkey) != ERROR_SUCCESS)
            continue;

        // add path to volume list if query succeeds
        if (RegQueryValueEx
                (
                hkey,
                wszValue,
                NULL,
                &type,
                (BYTE *) wsz,
                &cb
                ) == ERROR_SUCCESS)
            vl.AddPath(wsz);

        // close key
        RegCloseKey(hkey);
        }

    // close root key
    RegCloseKey(hkeyRoot);
    return TRUE;
    }


// add volume root of SystemDrive (drive wee boot off of
BOOL AddSystemPartitionRoot(CVolumeList &vl)
    {
    HKEY hkeySetup;
    WCHAR wsz[MAX_PATH];

    // open HKLM\System\Setup
    if (RegOpenKey(HKEY_LOCAL_MACHINE, x_SetupRoot, &hkeySetup) != ERROR_SUCCESS)
        return FALSE;

    DWORD cb = sizeof(wsz);
    DWORD type;

    // query SystemPartition value
    if (RegQueryValueEx
            (
            hkeySetup,
            L"SystemPartition",
            NULL,
            &type,
            (BYTE *) wsz,
            &cb
            ) != ERROR_SUCCESS)
        {
        // if fails, return FALSE
        RegCloseKey(hkeySetup);
        return FALSE;
        }

    // compute size of needed buffer
    unsigned cwc = wcslen(wsz);
    unsigned cwcNew = x_cwcWin32VolumePrefix + cwc + 1;
    LPWSTR wszNew = new WCHAR[cwcNew];

    // return failure if memory allocation fials
    if (wszNew == NULL)
        return FALSE;

    // append \\?\GlobalRoot\ to device name
    memcpy(wszNew, x_wszWin32VolumePrefix, x_cwcWin32VolumePrefix * sizeof(WCHAR));
    memcpy(wszNew + x_cwcWin32VolumePrefix, wsz, cwc * sizeof(WCHAR));
    RegCloseKey(hkeySetup);
    wszNew[cwcNew-1] = L'\0';
    try {        
        // add path based on device root
        vl.AddPath(wszNew);
    } catch(...)
        {
        delete wszNew;
        return FALSE;
        }

    // delete allocated memory
    delete wszNew;
    return TRUE;
    }

// find critical volumes.  Return multistring of volume names
// using guid naming convention
LPWSTR pFindCriticalVolumes()
    {
    WCHAR wsz[MAX_PATH * 4];

    // find location of system root
    if (!ExpandEnvironmentStrings(L"%systemroot%", wsz, sizeof(wsz)/sizeof(WCHAR)))
        {
        wprintf(L"ExpandEnvironmentStrings failed for reason %d", GetLastError());
        return NULL;
        }

    CVolumeList vl;
    LPWSTR wszPathsT = NULL;
    LPWSTR wszT = NULL;

    try
        {
        // add boot drive
        if (!AddSystemPartitionRoot(vl))
            return NULL;

        // add roots for various services
        if (!AddServiceRoots(vl))
            return NULL;

        // add systemroot drive
        vl.AddPath(wsz);

            {
            // add roots for SYSVOL
            CFRSIter fiter;
            fiter.Init();
            fiter.BeginIteration();
            while(TRUE)
                {
                wszT = fiter.GetNextSet(TRUE, &wszPathsT);
                if (wszT == NULL)
                    break;

                vl.AddPath(wszT);
                LPWSTR wszPathT = wszPathsT;
                while(*wszPathT != NULL)
                    {
                    vl.AddPath(wszPathT);
                    wszPathT += wcslen(wszPathT);
                    }

                delete wszT;
                delete wszPathsT;
                wszT = NULL;
                wszPathsT = NULL;
                }

            fiter.EndIteration();
            }
        }
    catch(...)
        {
        delete wszT;
        delete wszPathsT;
        }

    // return volume list
    return vl.GetVolumeList();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\asr_dlg.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asr_dlg.cpp

Abstract:

    Top level code to backup and restore information about the volumes on 
    a system.  This module handles the main application dialogue, including 
    parsing the command-line, and updating the progress bar and UI status
    text.


Authors:

    Steve DeVos (Veritas)   (v-stevde)  15-May-1998
    Guhan Suriyanarayanan   (guhans)    21-Aug-1999

Environment:

    User-mode only.

Revision History:

    15-May-1998 v-stevde    Initial creation
    21-Aug-1999 guhans      Cleaned up and re-wrote this module.

--*/

#include "stdafx.h"
#include "asr_fmt.h"
#include "asr_dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOLEAN g_bQuickFormat = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtDlg dialog

CAsr_fmtDlg::CAsr_fmtDlg(CWnd* pParent /*=NULL*/)
     : CDialog(CAsr_fmtDlg::IDD, pParent)
{
     //{{AFX_DATA_INIT(CAsr_fmtDlg)
     //}}AFX_DATA_INIT
}

void CAsr_fmtDlg::DoDataExchange(CDataExchange* pDX)
{
     CDialog::DoDataExchange(pDX);
     //{{AFX_DATA_MAP(CAsr_fmtDlg)
     DDX_Control(pDX, IDC_PROGRESS, m_Progress);
     //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAsr_fmtDlg, CDialog)
     //{{AFX_MSG_MAP(CAsr_fmtDlg)
     //}}AFX_MSG_MAP

    // manually added message handlers (for user-defined messages) should be added OUTSIDE
    // the AFX_MSG_MAP part above

    ON_MESSAGE(WM_WORKER_THREAD_DONE, OnWorkerThreadDone)
    ON_MESSAGE(WM_UPDATE_STATUS_TEXT, OnUpdateStatusText)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtDlg message handlers
//     ON_BN_CLICKED(IDOK, OnWorkerThreadDone)

BOOL CAsr_fmtDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // initialize the progress range and start posiiton
    m_Progress.SetRange(0, 100);
    m_Progress.SetPos(0);
    m_ProgressPosition = 0;

    // Launch the worker thread.
    CreateThread(NULL,     // no sid
        0,     // no initial stack size
        (LPTHREAD_START_ROUTINE) CAsr_fmtDlg::DoWork,
        this,  // parameter
        0,     // no flags
        NULL   // no thread ID
    );

    return TRUE;  // return TRUE unless you set the focus to a control
}

LRESULT 
CAsr_fmtDlg::OnWorkerThreadDone(
    WPARAM wparam, 
    LPARAM lparam
   )
{
    EndDialog(m_dwEndStatus);
    return 0;
}


LRESULT 
CAsr_fmtDlg::OnUpdateStatusText(
    WPARAM wparam, 
    LPARAM lparam 
   )
{
    SetDlgItemText(IDC_STATUS_TEXT, m_strStatusText);
    m_Progress.SetPos(m_ProgressPosition);

    return 0;
}


/**

     Name:         DoWork()

     Description:  This function runs as a thread launched form the Init
       of the dialog.  This function determines what needs to be done, then
       calls the appropraite function to do the work.

     Modified:     8/31/1998

     Returns:      TRUE

     Notes:        If an error occurs EndDialog will be called with the 
                exit status.

     Declaration:

**/
long 
CAsr_fmtDlg::DoWork(
    CAsr_fmtDlg *_this
    )
{
    ASRFMT_CMD_OPTION cmdOption = cmdUndefined;

    cmdOption = _this->ParseCommandLine();
    ((CAsr_fmtDlg *)_this)->m_AsrState = NULL;

    _this->m_dwEndStatus = ERROR_SUCCESS;

    switch (cmdOption) {

    case cmdBackup: {

        if (!(_this->BackupState())) {
            _this->m_dwEndStatus = GetLastError();
        }

        break;
    }

    case cmdRestore: {
        if (!(_this->RestoreState())) {
            _this->m_dwEndStatus = GetLastError();
        }
        break;
    }

    case cmdDisplayHelp: {
        _this->m_dwEndStatus = ERROR_INVALID_FUNCTION;      // display help ...
        break;
    }
 
    }

    if (ERROR_INVALID_FUNCTION != _this->m_dwEndStatus) {      // display help ...
        _this->PostMessage(WM_WORKER_THREAD_DONE, 0, 0);
    }

    return 0;           
}


/**

     Name:         BackupState()

     Description:  This function reads the current state file to get
       the current data for the sections to modify.  It then updates
       [VOLUMES], [REMOVABLEMEDIA] and [COMMANDS] sections.


     Notes:        If an error occurs an Error message popup is provided to
                the user.

     Declaration:

**/

BOOL
CAsr_fmtDlg::BackupState()
{
    BOOL result = FALSE;
    HANDLE hHeap = GetProcessHeap();
    int i = 0;

    CString strPleaseWait;
    strPleaseWait.LoadString(IDS_PLEASE_WAIT_BACKUP);
    SetDlgItemText(IDC_PROGRESS_TEXT, strPleaseWait);

    m_AsrState = (PASRFMT_STATE_INFO) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof (ASRFMT_STATE_INFO)
       );


    //
    // The only purpose of the for loops below are to slow down the 
    // UI and make the progress bar proceed smoothly, so that the user
    // can read the dialogue box on screen.
    //
    m_strStatusText.LoadString(IDS_QUERY_SYS_FOR_INFO);
    for (i = 3; i < 15; i++) {

        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);

    }

    if (m_AsrState) {
        result = BuildStateInfo(m_AsrState);
    }
    if (!result) {
        goto EXIT;
    }

    //
    // The only purpose of the for loops below are to slow down the 
    // UI and make the progress bar proceed smoothly, so that the user
    // can read the dialogue box on screen.
    //
    m_strStatusText.LoadString(IDS_QUERY_SYS_FOR_INFO);
    for (i = 15; i < 45; i++) {

        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);

    }

    //
    // Pretend we're doing something else (change UI text)
    //
    m_strStatusText.LoadString(IDS_BUILDING_VOL_LIST);
    for (i = 45; i < 80; i++) {

        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);

    }

    m_strStatusText.LoadString(IDS_WRITING_TO_SIF);
    for (i = 80; i < 90; i++) {
        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);
    }


    result = WriteStateInfo(m_dwpAsrContext, m_AsrState);

    if (!result) {
        goto EXIT;
    }
    m_strStatusText.LoadString(IDS_WRITING_TO_SIF);

    for (i = 90; i < 101; i++) {
        m_ProgressPosition = i;
        PostMessage(WM_UPDATE_STATUS_TEXT); 
        Sleep(50);
    }

EXIT:
    FreeStateInfo(&m_AsrState);
    return result;
}



/**

     Name:         RestoreState()

     Description:  This function restores the state found in the [VOLUMES] 
       section of the asr.sif file.   The state restored includs:
           the drive letter.
           If drive is inaccessible it is formated.
           the volume label.

     Notes:        If an error occurs an Error message popup is provided to
                the user.


**/
BOOL
CAsr_fmtDlg::RestoreState()
{

    BOOL bErrorsEncountered = FALSE,
        result = TRUE;

    CString strPleaseWait;
    strPleaseWait.LoadString(IDS_PLEASE_WAIT_RESTORE);

    
    SetDlgItemText(IDC_PROGRESS_TEXT, strPleaseWait);

    m_ProgressPosition = 0;
    m_strStatusText.LoadString(IDS_READING_SIF);
    PostMessage(WM_UPDATE_STATUS_TEXT);

    AsrfmtpInitialiseErrorFile();   // in case we need to log error messages

    //
    // 1.  Read the state file
    //
    result = ReadStateInfo( (LPCTSTR)m_strSifPath, &m_AsrState);
    if (!result || !m_AsrState) {
        DWORD status = GetLastError();

        CString strErrorTitle;
        CString strErrorMessage;
        CString strErrorFormat;

        strErrorTitle.LoadString(IDS_ERROR_TITLE);
        strErrorFormat.LoadString(IDS_ERROR_NO_DRSTATE);

        strErrorMessage.Format(strErrorFormat, (LPCTSTR)m_strSifPath, status);

        AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);
        AsrfmtpCloseErrorFile();
        
        return FALSE;
    }

    //
    // 2.  Loop through all the volumes listed in the state file.
    //
    PASRFMT_VOLUME_INFO pVolume = m_AsrState->pVolume;
    PASRFMT_REMOVABLE_MEDIA_INFO pMedia = m_AsrState->pRemovableMedia;
    UINT driveType = DRIVE_UNKNOWN;
    PWSTR lpDrive = NULL;  // Display string, of the form \DosDevices\C: or \??\Volume{Guid}
    DWORD cchVolumeGuid = 0;
    WCHAR szVolumeGuid[MAX_PATH + 1];
    int sizeIncrement = 0, i = 0;
    BOOL first = TRUE, isIntact = FALSE, isLabelIntact = TRUE;

    //
    // We need to first set all the guids a volume has, then try setting the drive
    // letters.  Also, we need to go through the guid loop twice, to handle this case:
    //
    // Consider a sif where we had the entries 
    // ... \vol1, \vol2
    // ... \vol1, \x:
    // ... \vol1, \vol3
    //
    // where vol1, vol2 and vol3 are volume guids (\??\Volume{Guid}), 
    // and x: is the drive letter (\DosDevices\X:)
    //
    // Now, our list will contain three nodes:
    // -->(vol1, vol3)-->(vol1, x:)-->(vol1, vol2)-->/
    //
    // The problem is, the partition could currently have the guid vol2.  (since
    // it is free to have any one of the three guids).
    // 
    // If we only went through the loop once, we'll try to map vol1 to vol3, or 
    // vice-versa if vol1 doesn't exist.  Since neither exist yet, we would've 
    // complained to the user.
    //
    // The advantage to doing it twice is this:  the first time, since neither vol1 
    // nor vol3 exist yet, we'll skip that node.  Then we'll skip the drive letter for
    // now (since we're only doing guids), and eventually we'll map vol2 to vol1.
    // 
    // The second time, we'll find vol1 exists (mapped to vol2), and we'll be 
    // able to map vol1 to vol3.  In a later loop, vol1 will also get the drive 
    // letter X, and all's well.
    //
    // By the way, we could optimise this by creating a better data structure,
    // but it's too late in the game now for that.  If the performance is
    // really bad, we could come back to this.
    //

    if (m_AsrState->countVolume > 1) {
        sizeIncrement = 50 / (m_AsrState->countVolume - 1);
    }
    else {
        sizeIncrement = 100;
    }

    m_ProgressPosition = 0;
    
    for (i = 0; i < 2; i++) {

        pVolume = m_AsrState->pVolume;

        while (pVolume) {

            m_ProgressPosition += sizeIncrement;
            m_strStatusText.Format(IDS_REST_SYM_LINKS, pVolume->szGuid);
            PostMessage(WM_UPDATE_STATUS_TEXT);

            if ((!pVolume->IsDosPathAssigned) &&
                ASRFMT_LOOKS_LIKE_VOLUME_GUID(pVolume->szDosPath, (wcslen(pVolume->szDosPath) * sizeof(WCHAR)))
                ) {
                pVolume->IsDosPathAssigned = SetDosName(pVolume->szGuid, pVolume->szDosPath);

                if (!pVolume->IsDosPathAssigned) {
                    pVolume->IsDosPathAssigned = SetDosName(pVolume->szDosPath, pVolume->szGuid);
                }
            }

            pVolume = pVolume->pNext;
        }
    }

    pVolume = m_AsrState->pVolume;
    FormatInitialise();
    while (pVolume) {
        lpDrive = ((wcslen(pVolume->szDosPath) > 0) ? pVolume->szDosPath : pVolume->szGuid);
        //
        // Check if the drive is accessible.  If not, we log an error message 
        // and continue.  GetDriveType requires the name in the DOS name space, so we
        // convert our GUID (NT name space) to the required format first
        //
        cchVolumeGuid = wcslen(pVolume->szGuid);
        wcscpy(szVolumeGuid, pVolume->szGuid);

        szVolumeGuid[1] = L'\\';
        szVolumeGuid[cchVolumeGuid] = L'\\';    // Trailing back-slash
        szVolumeGuid[cchVolumeGuid+1] = L'\0';

        driveType = GetDriveType(szVolumeGuid);

        if (DRIVE_NO_ROOT_DIR == driveType) {
            CString strErrorTitle;
            CString strErrorMessage;
            CString strErrorFormat;

            strErrorTitle.LoadString(IDS_ERROR_TITLE);
            strErrorFormat.LoadString(IDS_ERROR_MISSING_VOL);

            strErrorMessage.Format(strErrorFormat, (PWSTR) pVolume->szGuid);
            AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);

            bErrorsEncountered = TRUE;
        }

        if (DRIVE_FIXED != driveType) {
            //
            // Strange.  The volumes section should have only listed the drives that
            // were fixed (At backup time).  This could probably mean that a volume that
            // used to be on a fixed drive is now on a removable drive?!
            //
            pVolume = pVolume->pNext;
            continue;
        }

        //
        // Set the drive letter of the volume
        //
        result = TRUE;
        if (!pVolume->IsDosPathAssigned){
            m_ProgressPosition = 0;
            m_strStatusText.Format(IDS_REST_DRIVE_LETTER, lpDrive);
            PostMessage(WM_UPDATE_STATUS_TEXT);

            result = SetDosName(pVolume->szGuid, pVolume->szDosPath);
        }

        if (!result) {
            CString strErrorTitle;
            CString strErrorMessage;
            CString strErrorFormat;

            strErrorTitle.LoadString(IDS_ERROR_TITLE);
            strErrorFormat.LoadString(IDS_ERROR_MOUNTING);

            strErrorMessage.Format(strErrorFormat, (PWSTR) pVolume->szDosPath, (PWSTR) pVolume->szGuid);
            AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);
            
            bErrorsEncountered = TRUE;

            pVolume = pVolume->pNext;
            continue;
        }

        //
        // Check if the volume needs to be formatted
        //
        m_ProgressPosition = 0;
        m_strStatusText.Format(IDS_CHECKING_VOLUME, lpDrive);
        PostMessage(WM_UPDATE_STATUS_TEXT);

        isIntact = IsFsTypeOkay(pVolume, &isLabelIntact);
        if (isIntact) {
            isIntact = IsVolumeIntact(pVolume);
        }

        //
        // Format the volume if needed
        //
        if (!isIntact && FormatVolume(pVolume)) {
            isLabelIntact = FALSE;
            m_ProgressPosition = 0;
            m_strStatusText.Format(IDS_FORMATTING_VOLUME, lpDrive);
            PostMessage(WM_UPDATE_STATUS_TEXT);
            //
            // FormatVolume is asynchronous.
            //
            first = TRUE;
            while (g_bFormatInProgress) {

                if (g_iFormatPercentComplete >= 100) {
                    if (first) {
                        m_ProgressPosition = 100;
                        m_strStatusText.Format(IDS_CREATING_FS_STRUCT, lpDrive);
                        PostMessage(WM_UPDATE_STATUS_TEXT);
                        first = FALSE;
                    }
                }
                else {
                    m_Progress.SetPos(g_iFormatPercentComplete);
                }

                Sleep(100);
            }

            if (!g_bFormatSuccessful) {
                CString strErrorTitle;
                CString strErrorMessage;
                CString strErrorFormat;

                strErrorTitle.LoadString(IDS_ERROR_TITLE);
                strErrorFormat.LoadString(IDS_ERROR_FORMATTING);

                strErrorMessage.Format(strErrorFormat, (PWSTR) lpDrive);
                AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);

                bErrorsEncountered = TRUE;
                pVolume = pVolume->pNext;
                continue;
            }

            // 
            // Force the file-system to be mounted
            // 
            MountFileSystem(pVolume);

        }

        //
        // Set the volume label if it isn't intact
        //
        if (!isLabelIntact) {
            m_ProgressPosition = 0;
            m_strStatusText.Format(IDS_REST_VOL_LABEL, lpDrive);
            PostMessage(WM_UPDATE_STATUS_TEXT);

            if ((wcslen(pVolume->szFsName) > 0) &&
               !SetVolumeLabel(szVolumeGuid, pVolume->szLabel)) {

                bErrorsEncountered = TRUE;
            
                pVolume = pVolume->pNext;
                continue;
            }
        }

        pVolume = pVolume->pNext;
    }
    FormatCleanup();


    while (pMedia) {
        lpDrive = ((wcslen(pMedia->szDosPath) > 0) ? pMedia->szDosPath : pMedia->szVolumeGuid);

        // 
        // set the drive letter
        // 
        m_ProgressPosition = 0;
        m_strStatusText.Format(IDS_REST_DRIVE_LETTER, lpDrive);
        PostMessage(WM_UPDATE_STATUS_TEXT);

        result = SetRemovableMediaGuid(pMedia->szDevicePath, pMedia->szVolumeGuid);
        if (result) {
            result = SetDosName(pMedia->szVolumeGuid, pMedia->szDosPath);
        }

        if (!result) {
            CString strErrorTitle;
            CString strErrorMessage;
            CString strErrorFormat;

            strErrorTitle.LoadString(IDS_ERROR_TITLE);
            strErrorFormat.LoadString(IDS_ERROR_MOUNTING);

            strErrorMessage.Format(IDS_ERROR_MOUNTING, (PWSTR) pMedia->szDosPath, (PWSTR) pMedia->szVolumeGuid);
            AsrfmtpLogErrorMessage(_SeverityWarning, (LPCTSTR)strErrorMessage);

            // ignore failures setting drive letter on CD.
            // bErrorsEncountered = TRUE;
        }

        pMedia = pMedia->pNext;
    }

    AsrfmtpCloseErrorFile();
    return (bErrorsEncountered ? FALSE : TRUE);
}


inline 
BOOL
IsGuiModeAsr()
{
    WCHAR szAsrFlag[20];

    //
    // If (and only if) this is GUI-mode ASR, the ASR_C_CONTEXT 
    // environment variable is set to "AsrInProgress"
    //
    return (GetEnvironmentVariable(L"ASR_C_CONTEXT", szAsrFlag, 20) &&
        !wcscmp(szAsrFlag, L"AsrInProgress"));
}

/**

     Name:         ParseCommandLine()

     Description:  This function reads the comand line and looks for the
                   "backup" or "restore" options.  

     Modified:     8/31/1998

     Returns:      cmdBackup, cmdRestore, or cmdDisplayHelp.

     Notes:        If neither backup or restore are found, then the usage
                   is displayed in the error box.

     Declaration:

**/
ASRFMT_CMD_OPTION
CAsr_fmtDlg::ParseCommandLine() 
{
     CString cmd;
     m_dwpAsrContext = 0;

     cmd = GetCommandLine();
     cmd.MakeLower();
     if (cmd.Find(TEXT("/backup")) != -1) {

         int pos = cmd.Find(TEXT("/context="));
         if (pos > -1) {
#ifdef _IA64_
             _stscanf(cmd.Mid(pos, cmd.GetLength() - pos + 1), TEXT("/context=%I64u"), &m_dwpAsrContext);
#else
             _stscanf(cmd.Mid(pos, cmd.GetLength() - pos + 1), TEXT("/context=%lu"), &m_dwpAsrContext);
#endif
             return cmdBackup;
         }


    } else if (cmd.Find(TEXT("/restore")) != -1) {

        if (cmd.Find(TEXT("/full")) != -1) {
            g_bQuickFormat = FALSE;
        }
        else if (cmd.Find(TEXT("/quick")) != -1) {
            g_bQuickFormat = TRUE;
        }
        else if (IsGuiModeAsr()) {
            g_bQuickFormat = FALSE;
        }
        else {
            g_bQuickFormat = TRUE;
        }


        int pos = cmd.Find(TEXT("/sifpath="));
        if (pos > -1) {
            _stscanf(cmd.Mid(pos, cmd.GetLength() - pos + 1), TEXT("/sifpath=%ws"), m_strSifPath.GetBuffer(1024));
            m_strSifPath.ReleaseBuffer();
            return cmdRestore;
        }
    }

    CString strErrorTitle;
    CString strErrorMessage;
    INT space_offset;

    strErrorTitle.LoadString(IDS_ERROR_TITLE);
    strErrorMessage.LoadString(IDS_ERROR_USAGE);

    space_offset = cmd.Find(' ');
    if (space_offset >0) {
       cmd = cmd.Left(cmd.Find(' '));
    }

    SetDlgItemText(IDC_PROGRESS_TEXT, strErrorMessage);

    CWnd *pText = GetDlgItem(IDC_STATUS_TEXT);
    pText->ShowWindow(SW_HIDE);

    CButton *pButton = (CButton*)GetDlgItem(IDOK);
    pButton->ShowWindow(SW_SHOW);
    pButton->SetState(TRUE);
    pButton->SetCheck(TRUE);

    CWnd *pBar = GetDlgItem(IDC_PROGRESS);
    pBar->ShowWindow(SW_HIDE);

    return cmdDisplayHelp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asrtools\confdisk\confdisk.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    confdisk.cpp

Abstract:

    Utility program to create an ASR state-file (asr.sif), or restore 
    non-critical disk layout based on a previously created asr.sif.

Author:

    Guhan Suriyanarayanan   (guhans)    15-April-2001

Environment:

    User-mode only.

Revision History:

    15-Apr-2001 guhans
        Initial creation

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <setupapi.h>
#include <winasr.h>

#include "resource.h"
#include "critdrv.h"
#include "confdisk.h"


//
// --------
// global variables used in this module
// --------
//
WCHAR   g_szTempBuffer[BUFFER_LENGTH];
HMODULE g_hModule = NULL;
HANDLE  g_hHeap = NULL;
BOOL    g_fErrorMessageDone = FALSE;


//
// --------
// function implementations
// --------
//
VOID
AsrpPrintError(
    IN CONST DWORD dwLineNumber,
    IN CONST DWORD dwErrorCode
    )
/*++

Routine Description:

    Loads an error message based on dwErrorCode from the resources, and 
    prints it out to screen.  There are some error codes that are of 
    particular interest (that have specific error messages), others 
    get a generic error message.

Arguments:

    dwLineNumber - The line at which the error occured, pass in __LINE__

    dwErrorCode - The win-32 error that occured.

Return Value:
    
    None.

--*/
{

    //
    // Handle the error codes we know and care about
    //

    switch (dwErrorCode) {


    case 0:
        break;

    default:
        //
        // Unexpected error, print out generic error message
        //
        LoadString(g_hModule, IDS_GENERIC_ERROR, g_szTempBuffer, BUFFER_LENGTH);
        wprintf(g_szTempBuffer, dwErrorCode, dwLineNumber);

        if ((ERROR_SUCCESS != dwErrorCode) &&
            (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 
            NULL,
            dwErrorCode,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language
            g_szTempBuffer,
            BUFFER_LENGTH,
            NULL
            ))) {
        
            wprintf(L" %ws", g_szTempBuffer);
        }
        wprintf(L"\n");

    }

}


PWSTR   // must be freed by caller
AsrpExpandEnvStrings(
    IN CONST PCWSTR lpOriginalString
    )
/*++

Routine Description:

    Allocates and returns a pointer to a new string containing a copy of the
    original string in which environment-variables replaced by their defined
    values.

    Uses the Win-32 API ExpandEnvironmentStrings.

    The caller must free the returned string using HeapFree(LocalProcessHeap).

Arguments:

    lpOriginalString - Pointer to a null-terminated string that contains 
            environment-variable strings of the form: %variableName%. For 
            each such reference, the %variableName% portion is replaced 
            with the current value of that environment variable. 

            The replacement rules are the same as those used by the command 
            interpreter. Case is ignored when looking up the environment-
            variable name. If the name is not found, the %variableName% 
            portion is left undisturbed. 

Return Value:
    
    If the function succeeds, the return value is a pointer to the destination 
        string containing the result of the expansion.  The caller must free 
        this memory using HeapFree for the current process heap.

    If the function fails, the return value is NULL.  To get extended error 
        information, call GetLastError().

--*/
{
    PWSTR lpszResult = NULL;
    
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;

    BOOL bResult = FALSE;

    Alloc(lpszResult, PWSTR, cchSize * sizeof(WCHAR));
    if (!lpszResult) {
        return NULL;
    }

    cchRequiredSize = ExpandEnvironmentStringsW(lpOriginalString, 
        lpszResult, cchSize);

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        Free(lpszResult);
        cchSize = cchRequiredSize + 1;

        Alloc(lpszResult, PWSTR, cchSize * sizeof(WCHAR));
        if (!lpszResult) {
            return NULL;
        }

        cchRequiredSize = ExpandEnvironmentStringsW(lpOriginalString, 
            lpszResult, cchSize);
    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough 
        // even on the second try
        //
        Free(lpszResult);   // sets it to NULL
    }

    return lpszResult;
}


DWORD
AsrpPrintUsage()
/*++

Routine Description:
    
    Loads and prints the incorrect-usage error string.

Arguments:

    None

Return Values:

    None

--*/
{
    wcscpy(g_szTempBuffer, L"");

    LoadString(g_hModule, IDS_ERROR_USAGE, g_szTempBuffer, BUFFER_LENGTH);

    wprintf(g_szTempBuffer, L"confdisk /save   ", L"confdisk /restore",  L"confdisk /save c:\\asr.sif");    

    return ERROR_INVALID_PARAMETER;
}


//
// --------
// functions used by /save
// --------
//
BOOL
AsrpAcquirePrivilege(
    IN CONST PCWSTR lpPrivilegeName
    )
/*++

Routine Description:

    Acquires the requested privilege (such as the backup privilege).

Arguments:

    lpPrivilegeName - The required privilege (such as SE_BACKUP_NAME)

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/
{

    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;
    DWORD dwStatus = ERROR_SUCCESS;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &hToken);
    ErrExitCode(!bResult, dwStatus, GetLastError());

    bResult = LookupPrivilegeValue(NULL, lpPrivilegeName, &luid);
    ErrExitCode(!bResult, dwStatus, GetLastError());

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );
    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    ErrExitCode(!bResult, dwStatus, GetLastError());

EXIT:
    _AsrpCloseHandle(hToken);

    SetLastError(dwStatus);
    return bResult;
}


DWORD
AsrpCreateSif(
    IN CONST PCWSTR lpSifPath   OPTIONAL
    )
/*++

Routine Description:

    Creates an ASR state file (asr.sif) at the requested location, using the
    ASR API from syssetup.dll.

Arguments:

    lpSifPath - A null terminated UNICODE string containing the full path and 
            file-name of the ASR state file to be created.  
            
            This parameter may contain unexpanded environment variables 
            between "%" signs (such as %systemroot%\repair\asr.sif),

            This parameter can be NULL.  If it is NULL, the ASR state-file is 
            created at the default location (%systemroot%\repair\asr.sif). 

Return Value:

    If the function succeeds, the return value is zero.

    If the function fails, the return value is a Win-32 error code.

--*/
{
    HMODULE hDll = NULL;
    BOOL bResult = FALSE;
    DWORD_PTR asrContext = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    PWSTR lpProvider = NULL,
        lpCriticalVolumes = NULL;

    BOOL (*pfnCreateSif)(PCWSTR, PCWSTR, CONST BOOL, PCWSTR, DWORD_PTR*);
    BOOL (*pfnFreeContext)(DWORD_PTR* );

    pfnCreateSif = NULL;
    pfnFreeContext = NULL;

    //
    // We need to acquire the backup privileges to create asr.sif
    //
    bResult = AsrpAcquirePrivilege(SE_BACKUP_NAME);
    ErrExitCode(!bResult, dwStatus, ERROR_PRIVILEGE_NOT_HELD);

    //
    // Get the critical volume list
    //
    lpCriticalVolumes = pFindCriticalVolumes();
    ErrExitCode(!lpCriticalVolumes, dwStatus, ERROR_PRIVILEGE_NOT_HELD);

    //
    // Load syssetup, and find the routines to call
    //
    hDll = LoadLibraryW(L"syssetup.dll");
    ErrExitCode(!hDll, dwStatus, GetLastError());

    pfnCreateSif = (BOOL (*)(PCWSTR, PCWSTR, CONST BOOL, PCWSTR, DWORD_PTR*)) 
        GetProcAddress(hDll, "AsrCreateStateFileW");
    ErrExitCode(!pfnCreateSif, dwStatus, GetLastError());


    pfnFreeContext = (BOOL (*)(DWORD_PTR *)) 
        GetProcAddress(hDll, "AsrFreeContext");
    ErrExitCode(!pfnFreeContext, dwStatus, GetLastError());

    //
    // Finally, call the routine to create the state file:
    //
    bResult = pfnCreateSif(lpSifPath,   // lpFilePath,
        lpProvider,                     // lpProviderName
        TRUE,                           // bEnableAutoExtend
        lpCriticalVolumes,              // mszCriticalVolumes
        &asrContext                     // lpAsrContext
        );
    ErrExitCode(!bResult, dwStatus, GetLastError());

EXIT:
    //
    // Cleanup
    //
    if (lpCriticalVolumes) {
      delete lpCriticalVolumes;
      lpCriticalVolumes = NULL;
    }
 
    if (pfnFreeContext && asrContext) {
        pfnFreeContext(&asrContext);
    }

    if (hDll) {
        FreeLibrary(hDll);
        hDll = NULL;
    }

   return dwStatus;
}


//
// --------
// functions used by /restore
// --------
//
PWSTR
AsrpReadField(
    PINFCONTEXT pInfContext,
    DWORD dwFieldIndex
   )
/*++

Routine Description:

    Reads and returns a pointer to string at the specified index from a sif.

    The caller must free the returned string using HeapFree(LocalProcessHeap).

Arguments:

    pInfContext - The Inf Context to use to read the value, obtained from
            SetupGetLineByIndexW.

    dwFieldIndex - The 1 based field index of the string value to read.

Return Value:
    
    If the function succeeds, the return value is a pointer to the destination 
        string.  The caller must free this memory using HeapFree for the 
        current process heap.

    If the function fails, the return value is NULL.  To get extended error 
        information, call GetLastError().

--*/
{
    DWORD cchReqdSize = 0;
    BOOL bResult = FALSE;
    PWSTR lpszData = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    //  Allocate memory and read the data
    //
    Alloc(lpszData, PWSTR, MAX_PATH * sizeof(WCHAR));
    ErrExitCode(!lpszData, dwStatus, GetLastError());

    bResult = SetupGetStringFieldW(pInfContext, dwFieldIndex, lpszData,
        MAX_PATH, &cchReqdSize);

    if (!bResult) {
        dwStatus = GetLastError();

        //
        // If our buffer was too small, allocate a larger buffer
        // and try again
        //
        if (ERROR_INSUFFICIENT_BUFFER == dwStatus) {
            dwStatus = ERROR_SUCCESS;

            Free(lpszData);
            Alloc(lpszData, PWSTR, (cchReqdSize * sizeof(WCHAR)));

            bResult = SetupGetStringFieldW(pInfContext, dwFieldIndex,
                lpszData, cchReqdSize, NULL);
        }
    }

    if (!bResult) {
        Free(lpszData);
    }

EXIT:
    return lpszData;
}


VOID
AsrpInsertNodeToList(
    IN OUT PASR_RECOVERY_APP_LIST pList,
    IN OUT PASR_RECOVERY_APP_NODE pNode 
   )
/*++

Routine Description:

    Does an insertion sort using the SequenceNumber as the key, to insert a 
    Node to a List.

Arguments:

    pList - The List in which to insert the node.

    pNode - The Node to insert.

Return Value:

    None

--*/
{

    PASR_RECOVERY_APP_NODE pPrev = NULL,
        pCurr = NULL;

    if (pList->AppCount == 0) {
        //
        // First node being added
        //
        pNode->Next = NULL;
        pList->First = pNode;

    } 
    else {
        //
        // Find the slot to insert this in, based on the SequenceNumber
        //
        pCurr = pList->First;
        pPrev = NULL;

        while ((pCurr) && (pCurr->SequenceNumber < pNode->SequenceNumber)) {
            pPrev = pCurr;
            pCurr = pCurr->Next;
        }

        if (pPrev) {
            pPrev->Next = pNode;
        }
        else {
            pList->First = pNode;            // Head of the list
        }

        pNode->Next = pCurr;
    }

    pList->AppCount += 1;
}


PASR_RECOVERY_APP_NODE
AsrpGetNextRecoveryApp(
    IN OUT PASR_RECOVERY_APP_LIST pList
    )
/*++

Routine Description:

    Removes and returns the first Node in a List.

Arguments:

    pList - The List from which to remove

Return Value:

    A pointer to the first Node in the List.  Note that this Node is removed
            from the list.  

    NULL if the List is empty.

--*/
{
    PASR_RECOVERY_APP_NODE pNode = NULL;

    if (pList->AppCount > 0) {
        pNode = pList->First;
        pList->First = pNode->Next;
        pList->AppCount -= 1;
    }

    return pNode;
}


DWORD 
AsrpBuildRecoveryAppList(
    IN  CONST PCWSTR lpSifPath,
    OUT PASR_RECOVERY_APP_LIST pList
    )
/*++

Routine Description:

    Parses the COMMANDS section of asr.sif, and builds a list of recovery 
    apps (that have SequenceNumber < 4000) to be launched.  It skips apps
    with SequenceNumbers >= 4000 so that we don't launch the actual 
    backup-and-restore (supposed to use sequence numbers >= 4000) listed.

Arguments:

    lpSifPath - A null terminated UNICODE string containing the full path and 
            file-name of the ASR state file to be used for the recovery.  
            
    pList - Pointer to a struct that will receive the list recovery apps to 
            be launched.

Return Value:

    If the function succeeds, the return value is zero.

    If the function fails, the return value is a Win-32 error code.

--*/
{
    INFCONTEXT inf;
    HINF hSif = NULL;
    LONG line = 0,
        lLineCount = 0;
    BOOL bResult = FALSE;
    INT iSequenceNumber = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    PASR_RECOVERY_APP_NODE pNode = NULL;

    //
    // Open asr.sif and build the list of commands to be launched.
    //
    hSif = SetupOpenInfFileW(lpSifPath, NULL, INF_STYLE_WIN4, NULL);
    ErrExitCode((!hSif || (INVALID_HANDLE_VALUE == hSif)), 
        dwStatus, GetLastError());

    //
    // Read the COMMANDS section, and add each command to our list
    //
    lLineCount = SetupGetLineCountW(hSif, L"COMMANDS");
    for (line = 0; line < lLineCount; line++) {
        //
        //  Get the inf context for the line in asr.sif.  This will be used
        //  to read the fields on that line
        //
        bResult = SetupGetLineByIndexW(hSif, L"COMMANDS", line, &inf);
        ErrExitCode(!bResult, dwStatus, ERROR_INVALID_DATA);

        //
        // Read in the int fields.  First, check the SequenceNumber, and skip
        // this record if the SequenceNumber is >= 4000
        //
        bResult = SetupGetIntField(&inf, SequenceNumber, &iSequenceNumber);
        ErrExitCode(!bResult, dwStatus, ERROR_INVALID_DATA);

        if (iSequenceNumber >= 4000) {
            continue;
        }

        //
        // Create a new node
        //
        Alloc(pNode, PASR_RECOVERY_APP_NODE, sizeof(ASR_RECOVERY_APP_NODE));
        ErrExitCode(!pNode, dwStatus, GetLastError());
        
        pNode->SequenceNumber = iSequenceNumber;

        bResult = SetupGetIntField(&inf, SystemKey, &(pNode->SystemKey));
        ErrExitCode(!bResult, dwStatus, ERROR_INVALID_DATA);

        bResult = SetupGetIntField(&inf, CriticalApp, &(pNode->CriticalApp));
        ErrExitCode(!bResult, dwStatus, ERROR_INVALID_DATA);

        //
        // Read in the string fields
        //
        pNode->RecoveryAppCommand = AsrpReadField(&inf, CmdString);
        ErrExitCode((!pNode->RecoveryAppCommand), dwStatus, ERROR_INVALID_DATA);

        pNode->RecoveryAppParams = AsrpReadField(&inf, CmdParams);
        // null okay

        //
        // Add this node to our list, and move on to next
        //
        AsrpInsertNodeToList(pList, pNode);     
    }

EXIT:
    if (hSif && (INVALID_HANDLE_VALUE != hSif)) {
        SetupCloseInfFile(hSif);
    }

    return dwStatus;
}


PWSTR
AsrpBuildInvocationString(
    IN PASR_RECOVERY_APP_NODE pNode,
    IN CONST PCWSTR lpSifPath
   )
/*

Routine Description:

    Builds the invocation string, as the name suggests.  It expands out the 
    environment variables in the recovery app path, and adds in 
    /sifpath=<path to the sif file> at the end of the command.  So for an 
    entry in the COMMANDS section of the form:
    4=1,3500,0,"%TEMP%\app.exe","/param1 /param2"

    the invocation string would be of the form:
    c:\temp\app.exe /param1 /param2 /sifpath=c:\windows\repair\asr.sif

Arguments:

    pNode - The node from which to build the invocation string.

    lpSifPath - A null terminated UNICODE string containing the full path and 
            file-name of the ASR state file to be used for the recovery.  
            
            This parameter may contain unexpanded environment variables 
            between "%" signs (such as %systemroot%\repair\asr.sif),

Return Value:

    If the function succeeds, the return value is a pointer to the destination 
        string containing the result of the expansion.  The caller must free 
        this memory using HeapFree for the current process heap.

    If the function fails, the return value is NULL.  To get extended error 
        information, call GetLastError().

*/
{
    PWSTR lpszApp   = pNode->RecoveryAppCommand,
        lpszArgs    = pNode->RecoveryAppParams,
        lpszCmd     = NULL,
        lpszFullcmd = NULL;
    DWORD dwSize    = 0;

    //
    // Build an command line that looks like...
    //
    //      "%TEMP%\ntbackup recover /1 /sifpath=%systemroot%\repair\asr.sif"
    //
    // The /sifpath parameter is added to all apps being launched
    //

    //
    //  Allocate memory for the cmd line
    //
    dwSize = sizeof(WCHAR) * (
        wcslen(lpszApp) +                   // app name     %TEMP%\ntbackup
        (lpszArgs ? wcslen(lpszArgs) : 0) + // arguments    recover /1
        wcslen(lpSifPath) +         // path to sif  c:\windows\repair\asr.sif
        25                          // spaces, null, "/sifpath=", etc
        );
    Alloc(lpszCmd, PWSTR, dwSize); // won't return if alloc fails

    //
    // Build the string
    //
    swprintf(lpszCmd, L"%ws %ws /sifpath=%ws", lpszApp, 
        (lpszArgs? lpszArgs: L""), lpSifPath);

    //
    // Expand the %% stuff, to build the full path
    //
    lpszFullcmd = AsrpExpandEnvStrings(lpszCmd);
    
    Free(lpszCmd);
    return lpszFullcmd;
}


VOID
AsrpSetEnvironmentVariables()
/*++

Routine Description:

    Set some environment variables of interest.

Arguments:

    None

Return Value:

    None

--*/
{
    PWSTR TempPath = AsrpExpandEnvStrings(L"%systemdrive%\\TEMP");

    //
    // Set the TEMP and TMP variables to the same as GUI-mode recovery
    //
    SetEnvironmentVariableW(L"TEMP", TempPath);
    SetEnvironmentVariableW(L"TMP", TempPath);
    Free(TempPath);

    //
    // Clear this variable (it shouldn't exist anyway), since this is
    // meant to be set only if this is a full GUI-mode ASR
    //
    SetEnvironmentVariableW(L"ASR_C_CONTEXT", NULL);

}


DWORD
AsrpRestoreSif(
    IN CONST PCWSTR lpSifPath
    )
/*++

Routine Description:

    Restores the disk layout specified in the ASR state file (asr.sif), using 
    the ASR API in syssetup.dll.  Then launches the recovery apps specified
    in the COMMANDS section of asr.sif, with sequence numbers less than 4000.

Arguments:

    lpSifPath - A null terminated UNICODE string containing the full path and 
            file-name of the ASR state file to be used for the recovery.  
            
            This parameter may contain unexpanded environment variables 
            between "%" signs (such as %systemroot%\repair\asr.sif),

Return Value:

    If the function succeeds, the return value is zero.

    If the function fails, the return value is a Win-32 error code.

--*/
{
    BOOL bResult = TRUE;
    HMODULE hDll = NULL;
    STARTUPINFOW startUpInfo;
    PWSTR lpFullSifPath = NULL,
          lpszAppCmdLine = NULL;
    ASR_RECOVERY_APP_LIST AppList;
    DWORD dwStatus = ERROR_SUCCESS;
    PROCESS_INFORMATION processInfo;
    PASR_RECOVERY_APP_NODE pNode = NULL;

    BOOL (*pfnRestoreDisks)(PCWSTR, BOOL);

    pfnRestoreDisks = NULL;
    ZeroMemory(&AppList, sizeof(ASR_RECOVERY_APP_LIST));
    ZeroMemory(&startUpInfo, sizeof(STARTUPINFOW));
    ZeroMemory(&processInfo, sizeof(PROCESS_INFORMATION));

    lpFullSifPath = AsrpExpandEnvStrings(lpSifPath);
    ErrExitCode(!lpFullSifPath, dwStatus, GetLastError());

    //
    // To restore the disks, load syssetup and get the routine of interest
    //
    hDll = LoadLibraryW(L"syssetup.dll");
    ErrExitCode(!hDll, dwStatus, GetLastError());

    pfnRestoreDisks = (BOOL (*)(PCWSTR, BOOL)) 
        GetProcAddress(hDll, "AsrpRestoreNonCriticalDisksW");
    ErrExitCode(!pfnRestoreDisks, dwStatus, GetLastError());

    AsrpSetEnvironmentVariables();

    //
    // Recreate the disks.  We don't need the AllOrNothing granularity--it's 
    // okay if some disks come back but others don't,
    //
    bResult = pfnRestoreDisks(lpFullSifPath, FALSE); 
    ErrExitCode(!bResult, dwStatus, GetLastError());

    //
    // Now, we need to launch the recovery apps in the COMMANDS section.
    // Note that we'll only launch apps with a sequence number below 4000,
    // so that we don't launch the actual backup-and-restore app listed.
    // Backup-and-restore apps are supposed to use sequence numbers >= 4000.
    //

    //
    // Parse the sif to obtain list of apps to run
    //
    dwStatus = AsrpBuildRecoveryAppList(lpFullSifPath, &AppList);
    ErrExitCode((ERROR_SUCCESS != dwStatus), dwStatus, dwStatus);

    //
    // And launch them synchronously.  
    //
    pNode = AsrpGetNextRecoveryApp(&AppList);
    while (pNode) {

        lpszAppCmdLine = AsrpBuildInvocationString(pNode, lpFullSifPath);
        //
        // We don't need pNode any more
        //
        Free(pNode->RecoveryAppParams);
        Free(pNode->RecoveryAppCommand);
        Free(pNode);

        if (!lpszAppCmdLine) {
            //
            // Silently fail   !TODO: May need error message
            //
            continue;
        }

        // !TODO: May need status message
        wprintf(L"[%ws]\n", lpszAppCmdLine);
        
        bResult = CreateProcessW(
            NULL,           // lpApplicationName
            lpszAppCmdLine, // lpCommandLine
            NULL,           // lpProcessAttributes
            NULL,           // lpThreadAttributes
            FALSE,          // bInheritHandles
            0,              // dwCreationFlags
            NULL,           // pEnvironment 
            NULL,           // lpCurrentDirectory (null=current dir)
            &startUpInfo,   // statup information
            &processInfo    // process information
            );
        
        if (bResult) {
            WaitForSingleObject(processInfo.hProcess, INFINITE);
        }
        // else silently fail   !TODO: May need error message

        Free(lpszAppCmdLine);
        pNode = AsrpGetNextRecoveryApp(&AppList);
    }


EXIT:
    if (hDll && (INVALID_HANDLE_VALUE != hDll)) {
        FreeLibrary(hDll);
        hDll = NULL;
    }

    return dwStatus;
}


int __cdecl
wmain(
    int       argc,
    WCHAR   *argv[],
    WCHAR   *envp[]
    )
/*++

Routine Description:
    
    Entry point to the application.

Arguments:

    argc - Number of command-line parameters used to invoke the app

    argv - The command-line parameters as an array of strings.  See the top
            of this module for the list of valid parameters.

    envp - The process environment block, not currently used

Return Values:

    If the function succeeds, the exit code is zero.

    If the function fails, the exit code is a win-32 error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Initialise globals
    //
    g_hModule = GetModuleHandle(NULL);
    g_hHeap = GetProcessHeap();
    g_fErrorMessageDone = FALSE;

    //
    // Check and switch on the basis of the command line arguments
    //
    if ((argc >= 2) && (
        !_wcsicmp(argv[1], L"/save") ||
        !_wcsicmp(argv[1], L"-save") ||
        !_wcsicmp(argv[1], L"save")
        )) {
        //
        // confdisk /save [c:\windows\asr.sif]
        //
        dwStatus = AsrpCreateSif(argv[2]);
    }
    else if ((argc >= 3) && (
        !_wcsicmp(argv[1], L"/restore") ||
        !_wcsicmp(argv[1], L"-restore") ||
        !_wcsicmp(argv[1], L"restore")
        )) {
        //
        // confdisk /restore c:\windows\repair\asr.sif
        //
        dwStatus = AsrpRestoreSif(argv[2]);
    }
    else {
        //
        // Unknown parameter
        //
        dwStatus = AsrpPrintUsage();
    }

    //
    // We're all done.  Return the error-code, for interested parties.
    // 
    return (int) dwStatus;

    UNREFERENCED_PARAMETER(envp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_)
#define AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
//#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A507D04B_3854_11D2_87D7_006008A71E8F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\asr_fmt.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    asr_fmt.cpp

Abstract:

    Main entry point for asr_fmt.  

Authors:

    Steve DeVos (Veritas)   (v-stevde)  15-May-1998
    Guhan Suriyanarayanan   (guhans)    21-Aug-1999

Environment:

    User-mode only.

Revision History:

    15-May-1998 v-stevde    Initial creation
    21-Aug-1999 guhans      Minor clean up.

--*/

#include "stdafx.h"
#include "asr_fmt.h"
#include "asr_dlg.h"


/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtApp

BEGIN_MESSAGE_MAP(CAsr_fmtApp, CWinApp)
     //{{AFX_MSG_MAP(CAsr_fmtApp)
     //}}AFX_MSG
     ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtApp construction

CAsr_fmtApp::CAsr_fmtApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CAsr_fmtApp object

CAsr_fmtApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtApp initialization

BOOL CAsr_fmtApp::InitInstance()
{
    int returnValue = ERROR_SUCCESS;
     AfxEnableControlContainer();

     // Standard initialization

#ifdef _AFXDLL
     Enable3dControls();               // Call this when using MFC in a shared DLL
#else
     Enable3dControlsStatic();     // Call this when linking to MFC statically
#endif

     CAsr_fmtDlg dlg;
     m_pMainWnd = &dlg;
     returnValue = (int) dlg.DoModal();

     // for now never fail
     exit((BOOL) returnValue);

     return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CProgress

CProgress::CProgress()
{
}

CProgress::~CProgress()
{
}


BEGIN_MESSAGE_MAP(CProgress, CProgressCtrl)
	//{{AFX_MSG_MAP(CProgress)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgress message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\format.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    format.cpp

Abstract:

    Routines to format volumes, using file-system information passed
    in.  Uses undocumented fmifs calls.


Authors:

    Steve DeVos (Veritas)   (v-stevde)  15-May-1998
    Guhan Suriyanarayanan   (guhans)    21-Aug-1999

Environment:

    User-mode only.

Revision History:

    15-May-1998 v-stevde    Initial creation
    21-Aug-1999 guhans      Cleaned up and re-wrote this module.

--*/

#include "stdafx.h"
#include <winioctl.h>
#include "fmifs.h"
#include "asr_fmt.h"
#include "asr_dlg.h"

BOOL g_bFormatInProgress = FALSE;
BOOL g_bFormatSuccessful = FALSE;
INT  g_iFormatPercentComplete = 0;

HINSTANCE g_hIfsDll = NULL;

INT FormatVolumeThread(PASRFMT_VOLUME_INFO pVolume);

PFMIFS_FORMATEX_ROUTINE g_FormatRoutineEx = NULL;


BOOL
FormatInitialise() {
    //
    // Loadlib if needed
    //
    if (!g_hIfsDll) {
        g_hIfsDll = LoadLibrary(L"fmifs.dll");
        if (!g_hIfsDll) {
            //
            // FMIFS not available
            //
            return FALSE;
        }

        g_FormatRoutineEx = (PFMIFS_FORMATEX_ROUTINE)GetProcAddress(g_hIfsDll, "FormatEx");
        if (!g_FormatRoutineEx) {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
IsFsTypeOkay(
    IN PASRFMT_VOLUME_INFO pVolume,
    OUT PBOOL pIsLabelIntact
    )
{
    WCHAR currentFSName[ASRFMT_CCH_FS_NAME];
    WCHAR szVolumeGuid[ASRFMT_CCH_VOLUME_GUID];
    WCHAR currentLabel[ASRFMT_CCH_VOLUME_LABEL];

    DWORD cchGuid = 0;
    BOOL fsOkay = TRUE, 
        result = TRUE;
    
    ASSERT(pIsLabelIntact);

    ZeroMemory(currentFSName, sizeof(WCHAR) * ASRFMT_CCH_FS_NAME);
    *pIsLabelIntact = TRUE;

    if (wcslen(pVolume->szGuid) >= ASRFMT_CCH_VOLUME_GUID) {
        return TRUE;   // something's wrong with this GUID
    }

    if ((wcslen(pVolume->szFsName) <= 0)) {
        return TRUE;    // no check for RAW volumes
    }

    //
    // We don't want the "please insert floppy in drive A" messages ...
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    //
    // GetVolumeInformation needs the volume guid in the dos-name-space, while the
    // the sif file has the volume guid in the nt-name-space.  Convert
    // the name by changing the \??\ at the beginning to \\?\, and adding 
    // a back-slash at the end.
    //
    cchGuid = wcslen(pVolume->szGuid);
    wcsncpy(szVolumeGuid, pVolume->szGuid, cchGuid);
    szVolumeGuid[1] = L'\\';
    szVolumeGuid[cchGuid] = L'\\';    // Trailing back-slash
    szVolumeGuid[cchGuid+1] = L'\0';

    fsOkay = TRUE;
    //
    // Call GetVolumeInfo to see if the FS is the same
    //
    result = GetVolumeInformation(szVolumeGuid,
        currentLabel,   // lpVolumeNameBuffer
        ASRFMT_CCH_VOLUME_LABEL,      // nVolumeNameSize
        NULL,   // lpVolumeSerialNumber
        NULL,   // lpMaximumComponentLength
        NULL,   // lpFileSystemFlags
        currentFSName,
        ASRFMT_CCH_FS_NAME
        );

    if ((!result) || 
        wcscmp(currentFSName, pVolume->szFsName)
        ) {
        fsOkay = FALSE;
        *pIsLabelIntact = FALSE;
    }

    if (wcscmp(currentLabel, pVolume->szLabel)) {
        *pIsLabelIntact = FALSE;
    }


/*    if (fsOkay) {
        //
        //
        // Call FindFirst in root to see if drive is readable.  
        // guhans: If drive is empty but formatted, this will still 
        // say fsOkay = FALSE;
        //
        hFindData = FindFirstFile(szPath, &win32FindData);

        if (!hFindData || (INVALID_HANDLE_VALUE == hFindData)) {
            fsOkay = FALSE;
        }
    }
*/

    return fsOkay;

}


BOOL
IsVolumeIntact(
    IN PASRFMT_VOLUME_INFO pVolume
    ){


    //
    // Call autochk to see if the FS is intact
    //


    return TRUE;
}



///
// Asynchronous function to launch the format routine.  
//
BOOL
FormatVolume(
    IN PASRFMT_VOLUME_INFO pVolume
    )
{
    HANDLE hThread = NULL;

    //
    // Set the global flags
    //
    g_bFormatInProgress = TRUE;
    g_bFormatSuccessful = TRUE;
    g_iFormatPercentComplete = 0;

    //
    // Loadlib if needed
    //
    if (!g_hIfsDll && !FormatInitialise()) {
        g_bFormatSuccessful = FALSE;
        g_bFormatInProgress = FALSE;
        return FALSE;
    }

    hThread = CreateThread(
        NULL,
        0, 
        (LPTHREAD_START_ROUTINE) FormatVolumeThread, 
        pVolume,
        0,
        NULL
    );
    if (!hThread || (INVALID_HANDLE_VALUE == hThread)) {
        g_bFormatSuccessful = FALSE;
        g_bFormatInProgress = FALSE;
        return FALSE;
    }

    return TRUE;
}


BOOL
FormatCleanup() {

    if (g_hIfsDll) {
        FreeLibrary(g_hIfsDll);
        g_hIfsDll = NULL;
        g_FormatRoutineEx = NULL;
    }

    return TRUE;
}


FmIfsCallback(
    IN FMIFS_PACKET_TYPE PacketType,
    IN DWORD PacketLength,
    IN PVOID PacketData
    )
{

    switch (PacketType) {
    case FmIfsPercentCompleted:
        g_iFormatPercentComplete = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)PacketData)->PercentCompleted ;
        break;

    case FmIfsFormattingDestination:
    case FmIfsInsertDisk:
    case FmIfsFormatReport:
    case FmIfsHiddenStatus:
    default:
         break;

    case FmIfsFinished:
         g_bFormatSuccessful = g_bFormatSuccessful &&
             ((PFMIFS_FINISHED_INFORMATION) PacketData)->Success;
         g_iFormatPercentComplete = 101;
         g_bFormatInProgress = FALSE;
         break;

    case FmIfsIncompatibleFileSystem:
    case FmIfsIncompatibleMedia:
    case FmIfsAccessDenied:
    case FmIfsMediaWriteProtected:
    case FmIfsCantLock:
    case FmIfsBadLabel:
    case FmIfsCantQuickFormat:
    case FmIfsIoError:
    case FmIfsVolumeTooSmall:
    case FmIfsVolumeTooBig:
    case FmIfsClusterSizeTooSmall:
    case FmIfsClusterSizeTooBig:
         g_bFormatSuccessful = FALSE;
        break;
    }
    return TRUE;
}



INT FormatVolumeThread(PASRFMT_VOLUME_INFO pVolume) 
{
    WCHAR  szPath[ASRFMT_CCH_DEVICE_PATH + 1];

    swprintf(szPath, TEXT("\\\\?%s"), pVolume->szGuid+3);

    (g_FormatRoutineEx)(szPath,
        FmMediaUnknown,
        pVolume->szFsName,
        pVolume->szLabel,
#if 0
        TRUE,       // Quick Format for testing
#else
        g_bQuickFormat,      
#endif
        pVolume->dwClusterSize,
        (FMIFS_CALLBACK) &FmIfsCallback
        );

     return TRUE;
}


VOID
MountFileSystem(
    IN PASRFMT_VOLUME_INFO pVolume
    )
/*++

  (based on code in base\fs\utils\hsm\wsb\wsbfmt.cpp)

Routine Description:


  Ensures a filesystem  is mounted at the given root:
  a) Opens the mount point and closes it.
  b) Does a FindFirstFile on the mount point
 
  The latter may sound redundant but is not because if we create the first
  FAT32 filesystem then just opening and closing is not enough
 

Arguments:


Return Value:
        
    none

--*/
{
    WCHAR  szPath[ASRFMT_CCH_DEVICE_PATH + 1];
    HANDLE handle = NULL;
    WIN32_FIND_DATA win32FindData;

    if (!pVolume) {
        ASSERT(0 && L"pVolume is NULL");
        return;
    }

    if (!memcmp(pVolume->szDosPath, ASRFMT_WSZ_DOS_DEVICES_PREFIX, ASRFMT_CB_DOS_DEVICES_PREFIX)) {
        swprintf(szPath, L"\\\\?\\%ws", pVolume->szDosPath + wcslen(ASRFMT_WSZ_DOS_DEVICES_PREFIX));
    }
    else {
        swprintf(szPath, L"\\\\%ws", pVolume->szDosPath + 2);
    }
    handle = CreateFile(
        szPath, 
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0, 
        OPEN_EXISTING, 
        0, 
        0
        );
    if ((handle) && (INVALID_HANDLE_VALUE != handle)) {
        CloseHandle(handle);
    }

    //
    // Try to find the first file, this will make sure that
    //  the file system is mounted
    //    
    if (!memcmp(pVolume->szDosPath, ASRFMT_WSZ_DOS_DEVICES_PREFIX, ASRFMT_CB_DOS_DEVICES_PREFIX)) {
        swprintf(szPath, L"\\\\?\\%ws\\*", pVolume->szDosPath + wcslen(ASRFMT_WSZ_DOS_DEVICES_PREFIX));
    }
    else {
        swprintf(szPath, L"\\\\%ws\\*", pVolume->szDosPath + 2);
    }

    handle = FindFirstFile(szPath, &win32FindData);
    if ((handle) && (INVALID_HANDLE_VALUE != handle)) {
        FindClose(handle);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\inc\dr_state.h ===
#ifndef _INC_ASR_FMT__DR_STATE_H_
#define _INC_ASR_FMT__DR_STATE_H_

#define ASRFMT_WSZ_DOS_DEVICES_PREFIX L"\\DosDevices\\"
#define ASRFMT_CB_DOS_DEVICES_PREFIX 24
#define ASRFMT_LOOKS_LIKE_DOS_DEVICE(name, length) \
               ((length > ASRFMT_CB_DOS_DEVICES_PREFIX) && \
               (!memcmp(name, ASRFMT_WSZ_DOS_DEVICES_PREFIX, ASRFMT_CB_DOS_DEVICES_PREFIX)))

#define ASRFMT_WSZ_VOLUME_GUID_PREFIX L"\\??\\Volume{"
#define ASRFMT_CB_VOLUME_GUID_PREFIX 22
#define ASRFMT_LOOKS_LIKE_VOLUME_GUID(name, length) \
              ((length > ASRFMT_CB_VOLUME_GUID_PREFIX) && \
              (!memcmp(name, ASRFMT_WSZ_VOLUME_GUID_PREFIX, ASRFMT_CB_VOLUME_GUID_PREFIX)))

#define ASRFMT_CCH_VOLUME_GUID 64
#define ASRFMT_CCH_DOS_PATH 1024
#define ASRFMT_CCH_FS_NAME 16
#define ASRFMT_CCH_VOLUME_LABEL 256
#define ASRFMT_CCH_DEVICE_PATH 1024

      
typedef struct _ASRFMT_VOLUME_INFO {

    struct _ASRFMT_VOLUME_INFO *pNext;

    DWORD   dwIndex;

    WCHAR   szGuid[ASRFMT_CCH_VOLUME_GUID];

    WCHAR   szDosPath[ASRFMT_CCH_DOS_PATH];

    WCHAR   szFsName[ASRFMT_CCH_FS_NAME];

    WCHAR   szLabel[ASRFMT_CCH_VOLUME_LABEL];

    DWORD   dwClusterSize;

    BOOL    IsDosPathAssigned;  

} ASRFMT_VOLUME_INFO, *PASRFMT_VOLUME_INFO;



typedef struct _ASRFMT_REMOVABLE_MEDIA_INFO {

    struct _ASRFMT_REMOVABLE_MEDIA_INFO *pNext;

    DWORD   dwIndex;

    WCHAR   szDevicePath[ASRFMT_CCH_DEVICE_PATH];

    WCHAR   szVolumeGuid[ASRFMT_CCH_VOLUME_GUID];

    WCHAR   szDosPath[ASRFMT_CCH_DOS_PATH];

} ASRFMT_REMOVABLE_MEDIA_INFO, *PASRFMT_REMOVABLE_MEDIA_INFO;


typedef struct _ASRFMT_STATE_INFO {

    PASRFMT_VOLUME_INFO pVolume;

    DWORD   countVolume;

    PASRFMT_REMOVABLE_MEDIA_INFO pRemovableMedia;

    DWORD   countMedia;

} ASRFMT_STATE_INFO, *PASRFMT_STATE_INFO;



typedef enum __AsrfmtpMessageSeverity {
    _SeverityInfo = 0,
    _SeverityWarning,
    _SeverityError
} _AsrfmtpMessageSeverity;

// Public functions

//
// From format.cpp
//

extern BOOL g_bFormatInProgress;
extern BOOL g_bFormatSuccessful;
extern INT  g_iFormatPercentComplete;


BOOL
FormatInitialise();

BOOL
IsFsTypeOkay(
    IN PASRFMT_VOLUME_INFO pVolume,
    OUT PBOOL pIsLabelIntact
    );

BOOL
IsVolumeIntact(
    IN PASRFMT_VOLUME_INFO pVolume
    );

BOOL
FormatVolume(
    PASRFMT_VOLUME_INFO pVolume
    );

BOOL
FormatCleanup();

VOID
MountFileSystem(
    IN PASRFMT_VOLUME_INFO pVolume
    );

//
// dr_state.cpp
//
BOOL
BuildStateInfo(
    IN PASRFMT_STATE_INFO pState
    );

VOID
FreeStateInfo(
    IN OUT PASRFMT_STATE_INFO *ppState
    );

BOOL
ReadStateInfo( 
    IN PCWSTR lpwszFilePath,
    OUT PASRFMT_STATE_INFO *ppState
    );

BOOL
SetDosName(
    IN PWSTR lpVolumeGuid,
    IN PWSTR lpDosPath
    );

BOOL
SetRemovableMediaGuid(
    IN PWSTR lpDeviceName,
    IN PWSTR lpGuid
    );

BOOL
WriteStateInfo( 
    IN DWORD_PTR AsrContext,        // AsrContext to pass in to AsrAddSifEntry
    IN PASRFMT_STATE_INFO pState    // data to write.
    );


//
// Functions for logging error messages
//
VOID
AsrfmtpInitialiseErrorFile();

VOID
AsrfmtpCloseErrorFile();

VOID
AsrfmtpLogErrorMessage(
    IN _AsrfmtpMessageSeverity Severity,
    IN const LPCTSTR Message
    );



#endif // ifndef _INC_ASR_FMT__DR_STATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Used by Z:\nt\base\fs\utils\asr_fmt\asr_fmt.rc

//
// Strings 
//
#define IDS_PLEASE_WAIT_BACKUP          1001
#define IDS_QUERY_SYS_FOR_INFO          1002
#define IDS_BUILDING_VOL_LIST           1003
#define IDS_WRITING_TO_SIF              1004

#define IDS_PLEASE_WAIT_RESTORE         1011
#define IDS_READING_SIF                 1012

#define IDS_REST_DRIVE_LETTER           1021
#define IDS_REST_VOL_LABEL              1022
#define IDS_REST_SYM_LINKS              1023

#define IDS_FORMATTING_VOLUME           1031
#define IDS_CHECKING_VOLUME             1032
#define IDS_CREATING_FS_STRUCT          1033

#define IDS_ERROR_TITLE                 1101
#define IDS_ERROR_USAGE                 1102
#define IDS_ERROR_FORMATTING            1103
#define IDS_ERROR_MOUNTING              1104
#define IDS_ERROR_MISSING_VOL           1105
#define IDS_ERROR_NO_DRSTATE            1106

#define IDS_LOG_ERROR_FORMAT            1110
#define IDS_LOG_WARNING_FORMAT          1111

//
// Dialog
//
#define IDD_ASR_FMT_DIALOG              2001
#define IDR_MAINFRAME                   2011

//
// Controls
//
#define IDC_PROGRESS                    3001
#define IDC_PROGRESS_TEXT               3002
#define IDC_STATUS_TEXT                 3003

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2012
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         3004
#define _APS_NEXT_SYMED_VALUE           2002
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\inc\asr_fmt.h ===
// asr_fmt.h : main header file for the ASR_FMT application
//

#ifndef _INC_ASR_FMT__ASR_FMT_H_
#define _INC_ASR_FMT__ASR_FMT_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtApp:
// See asr_fmt.cpp for the implementation of this class
//

class CAsr_fmtApp : public CWinApp
{
public:
	CAsr_fmtApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsr_fmtApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CAsr_fmtApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _INC_ASR_FMT__ASR_FMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\inc\asr_dlg.h ===
// asr_fmtDlg.h : header file
//

#ifndef _INC_ASR_FMT__ASR_DLG_H_
#define _INC_ASR_FMT__ASR_DLG_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "dr_state.h"

typedef enum {
    cmdUndefined = 0,
    cmdDisplayHelp,
    cmdBackup,
    cmdRestore
} ASRFMT_CMD_OPTION;


extern BOOLEAN g_bQuickFormat;

/////////////////////////////////////////////////////////////////////////////
// CAsr_fmtDlg dialog

class CAsr_fmtDlg:public CDialog
{

    enum {
        WM_WORKER_THREAD_DONE = WM_USER + 1,
        WM_UPDATE_STATUS_TEXT,
    };

public:
	CAsr_fmtDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAsr_fmtDlg)
	enum { IDD = IDD_ASR_FMT_DIALOG };
	CProgressCtrl	m_Progress;
    PASRFMT_STATE_INFO m_AsrState;

	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsr_fmtDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAsr_fmtDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	static long       DoWork(CAsr_fmtDlg *_this);
	BOOL              BackupState();
	BOOL              RestoreState();
    ASRFMT_CMD_OPTION ParseCommandLine();


    DWORD_PTR   m_dwpAsrContext;
    DWORD       m_dwEndStatus;

    CString     m_strStatusText;
    CString     m_strSifPath;
    
    int         m_ProgressPosition;

	DECLARE_MESSAGE_MAP()

    // manually added message-handler 
    afx_msg LRESULT OnWorkerThreadDone(WPARAM wparam, LPARAM lparam);
    afx_msg LRESULT OnUpdateStatusText(WPARAM wparam, LPARAM lparam);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.



/////////////////////////////////////////////////////////////////////////////
// CProgress window

class CProgress : public CProgressCtrl
{
// Construction
public:
	CProgress();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgress)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CProgress();

	// Generated message map functions
protected:
	//{{AFX_MSG(CProgress)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _INC_ASR_FMT__ASR_DLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\asr_fmt\dr_state.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dr_state.cpp

Abstract:

    This module contains routines to query the symbolic names and file system
    information of all the volumes on a system, and save them out to an 
    ASR state file using the ASR api.

    Also contains routines to read in the volume information stored in an
    ASR state file, and recreate them using appropriate mountmgr calls.


Authors:

    Steve DeVos (Veritas)   (v-stevde)  15-May-1998
    Guhan Suriyanarayanan   (guhans)    21-Aug-1999

Environment:

    User-mode only.

Revision History:

    15-May-1998 v-stevde    Initial creation
    21-Aug-1999 guhans      Cleaned up and re-wrote this module.

--*/

#include "stdafx.h"
#include <setupapi.h>
#include <winioctl.h>
#include <mountmgr.h>
#include <winasr.h>
#include "dr_state.h"
#include "resource.h"

#include <clusstor.h>   // Cluster API's
#include <resapi.h>     // Cluster ResUtilEnumResources

#define ASRFMT_VOLUMES_SECTION                  L"[ASRFMT.FIXEDVOLUMES]"
#define ASRFMT_VOLUMES_SECTION_NAME             L"ASRFMT.FIXEDVOLUMES"

#define ASRFMT_REMOVABLE_MEDIA_SECTION          L"[ASRFMT.REMOVABLEMEDIA]"
#define ASRFMT_REMOVABLE_MEDIA_SECTION_NAME     L"ASRFMT.REMOVABLEMEDIA"

#define ASRFMT_COMMANDS_ENTRY                   L"1,3000,0,\"%SystemRoot%\\system32\\asr_fmt.exe\",\"/restore\""

const WCHAR ASRFMT_DEVICEPATH_FORMAT[]     = L"\\Device\\Harddisk%d\\Partition%d";
#define ASRFMT_DEVICEPATH_FORMAT_LENGTH    36

const WCHAR ASRFMT_CLUSTER_PHYSICAL_DISK[] = L"Physical Disk";

const WCHAR ASRFMT_ASR_ERROR_FILE_PATH[] = L"%SystemRoot%\\repair\\asr.err";


//
// The following must be Ansi strings
//
const char ASRFMT_CLUSTER_DLL_MODULE_NAME[] = "%SystemRoot%\\system32\\syssetup.dll";
const char ASRFMT_CLUSTER_DLL_PROC_NAME[]   = "AsrpGetLocalVolumeInfo";

typedef enum {
    mmfUndefined = 0,
    mmfGetDeviceName,
    mmfDeleteDosName,
    mmfDeleteVolumeGuid,
    mmfCreateSymbolicLinkName
} ASRFMT_MM_FUNCTION;

HANDLE Gbl_hErrorFile = NULL;

//
//  Macro Description:
//      This macro wraps calls that are expected to return SUCCESS (retcode).
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Result of some function call or conditional expression.
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // An ErrorCode specific to the error and calling function
//
#define ErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {        \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        wprintf(L"Line %lu, ErrorCode: %lu, GetLastError:%lu\n",        \
                __LINE__, ErrorCode, GetLastError());                   \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}

//
//
// Forward declarations
//
BOOL
DoMountMgrWork(
    IN HANDLE hMountMgr,               
    IN ASRFMT_MM_FUNCTION mmfFunction,
    IN PWSTR lpSymbolicName,
    IN PWSTR lpDeviceName
    );

PMOUNTMGR_MOUNT_POINTS  // Must be freed by caller
GetMountPoints();


//
//
//
VOID
FreeVolumeInfo(
    IN OUT PASRFMT_VOLUME_INFO *ppVolume
    )
{
    PASRFMT_VOLUME_INFO pTemp = NULL;
    HANDLE hHeap = GetProcessHeap();

    if (ppVolume && *ppVolume) {

        pTemp = *ppVolume;
        while (*ppVolume) {
            pTemp = ((*ppVolume)->pNext);
            HeapFree(hHeap, 0L, *ppVolume);
            *ppVolume = pTemp;
        }
    }
}


VOID
FreeRemovableMediaInfo(
    IN OUT PASRFMT_REMOVABLE_MEDIA_INFO *ppMedia
    )
{
    PASRFMT_REMOVABLE_MEDIA_INFO pTemp = NULL;
    HANDLE hHeap = GetProcessHeap();

    if (ppMedia && *ppMedia) {

        pTemp = *ppMedia;
        while (*ppMedia) {
            pTemp = (*ppMedia)->pNext;
            HeapFree(hHeap, 0L, *ppMedia);
            *ppMedia = pTemp;
        }
    }
}


VOID
FreeStateInfo(
    IN OUT PASRFMT_STATE_INFO *ppState
    )
{
    if (ppState && *ppState) {

        FreeVolumeInfo(&((*ppState)->pVolume));
        FreeRemovableMediaInfo(&((*ppState)->pRemovableMedia));

        HeapFree(GetProcessHeap(), 0L, (*ppState));
        *ppState = NULL;
    }
}


/**********************

   NAME : ReadStateInfo

**********************/
BOOL
ReadStateInfo( 
    IN PCWSTR lpwszFilePath,
    OUT PASRFMT_STATE_INFO *ppState
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HINF hSif = NULL;
    BOOL bResult = TRUE;
    HANDLE hHeap = NULL;

    PASRFMT_VOLUME_INFO pNewVolume = NULL;
    PASRFMT_REMOVABLE_MEDIA_INFO pNewMedia = NULL;

    INFCONTEXT infVolumeContext,
        infMediaContext;

    hHeap = GetProcessHeap();

    //
    // Release the ppState if necessary, and allocate memory.
    //
    if (*ppState) {
        FreeStateInfo(ppState);
    }

    *ppState = (PASRFMT_STATE_INFO) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof(ASRFMT_STATE_INFO)
        );
    ErrExitCode(!(*ppState), dwStatus, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Open asr.sif
    //
    hSif = SetupOpenInfFile(
        lpwszFilePath, 
        NULL, 
        INF_STYLE_WIN4, 
        NULL 
        );
    ErrExitCode((!hSif || INVALID_HANDLE_VALUE == hSif), dwStatus, GetLastError());

    //
    // Read in the [VOLUMES] section
    //
    bResult = SetupFindFirstLineW(hSif, ASRFMT_VOLUMES_SECTION_NAME, NULL, &infVolumeContext);
    while (bResult) {
        // 
        // Create a new volumeInfo struct
        //
        pNewVolume = (PASRFMT_VOLUME_INFO) HeapAlloc(
            hHeap,
            HEAP_ZERO_MEMORY,
            sizeof(ASRFMT_VOLUME_INFO)
            );
        ErrExitCode(!pNewVolume, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

        //
        // Read in the information.  The VOLUMES section contains:
        // [VOLUMES]
        // 0.volume-key = 1.system-key, 2."volume-guid", 3."dos-drive-letter", 
        //             4."FS-Type", 5."volume-label", 6."fs-cluster-size"
        //
        SetupGetIntField(&infVolumeContext, 0, (PINT) (&pNewVolume->dwIndex));

        SetupGetStringField(&infVolumeContext, 2, pNewVolume->szGuid, sizeof(pNewVolume->szGuid), NULL);
        SetupGetStringField(&infVolumeContext, 3, pNewVolume->szDosPath, sizeof(pNewVolume->szDosPath), NULL);

        SetupGetStringField(&infVolumeContext, 4, pNewVolume->szFsName, sizeof(pNewVolume->szFsName), NULL);
        SetupGetStringField(&infVolumeContext, 5, pNewVolume->szLabel, sizeof(pNewVolume->szLabel), NULL);

        SetupGetIntField(&infVolumeContext, 6, (PINT) (&pNewVolume->dwClusterSize));

        //
        // Add this to our list
        //
        pNewVolume->pNext = (*ppState)->pVolume;
        (*ppState)->pVolume = pNewVolume;
        (*ppState)->countVolume += 1;

        bResult = SetupFindNextLine(&infVolumeContext, &infVolumeContext);
    }


    //
    // Read in the [REMOVABLEMEDIA] section
    //
    bResult = SetupFindFirstLineW(hSif, ASRFMT_REMOVABLE_MEDIA_SECTION_NAME, NULL, &infMediaContext);
    while (bResult) {
        // 
        // Create a new REMOVALBLE_MEDIA struct
        //
        pNewMedia = (PASRFMT_REMOVABLE_MEDIA_INFO) HeapAlloc(
            hHeap,
            HEAP_ZERO_MEMORY,
            sizeof(ASRFMT_REMOVABLE_MEDIA_INFO)
            );
        ErrExitCode(!pNewMedia, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

        //
        // Read in the information.  The REMOVABLEMEDIA section contains:
        //
        // [REMOVABLEMEDIA]
        // 0.rm-key = 1.system-key, 2."device-path", 3."volume-guid", 
        //             4."dos-drive-letter"
        //
        SetupGetIntField(&infMediaContext, 0, (PINT)(&pNewMedia->dwIndex));

        SetupGetStringField(&infMediaContext, 2, pNewMedia->szDevicePath, sizeof(pNewMedia->szDevicePath), NULL);
        SetupGetStringField(&infMediaContext, 3, pNewMedia->szVolumeGuid, sizeof(pNewMedia->szVolumeGuid), NULL);
        SetupGetStringField(&infMediaContext, 4, pNewMedia->szDosPath, sizeof(pNewMedia->szDosPath), NULL);

        //
        // Add this to our list
        //
        pNewMedia->pNext = (*ppState)->pRemovableMedia;
        (*ppState)->pRemovableMedia = pNewMedia;
        (*ppState)->countMedia += 1;

        bResult = SetupFindNextLine(&infMediaContext, &infMediaContext);
    }

EXIT:
    //
    //  Set the state pointer to null on failure
    //
    if (dwStatus != ERROR_SUCCESS) {
        if (ppState && *ppState) {
          FreeStateInfo(ppState);
        }
    }

    if (hSif && (INVALID_HANDLE_VALUE != hSif)) {
        SetupCloseInfFile(hSif);
    }

    return (BOOL) (ERROR_SUCCESS == dwStatus);
}


//
// WriteStateInfo
//
// This writes out the volumes and removablemedia sections, using 
// AsrAddSifEntry.  If the write is successful, or there's nothing 
// to write, it returns TRUE.
//
BOOL
WriteStateInfo( 
    IN DWORD_PTR AsrContext,        // AsrContext to pass in to AsrAddSifEntry
    IN PASRFMT_STATE_INFO pState    // data to write.
    )
{
    WCHAR szSifEntry[ASR_SIF_ENTRY_MAX_CHARS + 1];
    DWORD dwIndex = 1;
    BOOL bResult = TRUE;

    PASRFMT_VOLUME_INFO pVolume = NULL;
    PASRFMT_REMOVABLE_MEDIA_INFO pMedia = NULL;

    if (!pState) {
        //
        // Nothing to write
        //
        return TRUE;
    }

    bResult = AsrAddSifEntry(
         AsrContext,
         L"[COMMANDS]", // ASR_SIF_COMMANDS_SECTION_NAME,
         ASRFMT_COMMANDS_ENTRY
         );

    if (!bResult) {
        GetLastError(); // for debug
        return FALSE;
    }

    //
    // The [ASRFMT.FIXEDVOLUMES] section
    //
    pVolume = pState->pVolume;
    dwIndex = 1;
    while (pVolume) {

        //
        // Write out the information.  The VOLUMES section contains:
        // [ASRFMT.FIXEDVOLUMES]
        // 0.volume-key = 1.system-key, 2."volume-guid", 3."dos-drive-letter", 
        //             4.FS-Type, 5."volume-label", 6."fs-cluster-size"
        //

        // form the string
        swprintf(
            szSifEntry, 
            (PCWSTR) L"%d=1,\"%ws\",\"%ws\",%ws,\"%ws\",0x%x",
            dwIndex,
            pVolume->szGuid,
            (pVolume->szDosPath ? pVolume->szDosPath : L""),
            pVolume->szFsName,
            pVolume->szLabel,
            pVolume->dwClusterSize
            );

        bResult = AsrAddSifEntry(
             AsrContext,
             ASRFMT_VOLUMES_SECTION,
             szSifEntry
             );

        if (!bResult) {
            GetLastError(); // for debug
            return FALSE;
        }

        ++dwIndex;
        pVolume = pVolume->pNext;
    }

    //
    // The [REMOVABLEMEDIA] section
    //
    pMedia = pState->pRemovableMedia;
    dwIndex = 1;
    while (pMedia) {

        //
        // Write out the information.  The REMOVABLEMEDIA section contains:
        //
        // [ASRFMT.REMOVABLEMEDIA]
        // 0.rm-key = 1.system-key, 2."device-path", 3."volume-guid", 
        //             4."dos-drive-letter"
        //

        // form the string
        swprintf(
            szSifEntry, 
            (PCWSTR) L"%d=1,\"%ws\",\"%ws\",\"%ws\"",
            dwIndex,
            pMedia->szDevicePath,
            pMedia->szVolumeGuid,
            (pMedia->szDosPath ? pMedia->szDosPath : L"")
            );

        bResult = AsrAddSifEntry(
             AsrContext,
             ASRFMT_REMOVABLE_MEDIA_SECTION,
             szSifEntry
             );

        if (!bResult) {
            GetLastError(); // for debug
            return FALSE;
        }

        ++dwIndex;
        pMedia = pMedia->pNext;
    }

    return TRUE;
}


BOOL
GetVolumeDetails(
    IN  PWSTR lpVolumeGuid,
    OUT PWSTR lpFsName,
    IN  DWORD cchFsName,
    OUT PWSTR lpVolumeLabel,
    IN  DWORD cchVolumeLabel,
    OUT LPDWORD lpClusterSize
    )
{
    DWORD dwFSFlags = 0,
        dwSectorsPerCluster = 0,
        dwBytesPerSector = 0,
        dwNumFreeClusters = 0,
        dwTotalNumClusters = 0;

    BOOL result1 = TRUE,
        result2 = TRUE;

    *lpFsName = 0;
    *lpVolumeLabel = 0;
    *lpClusterSize = 0;

    SetErrorMode(SEM_FAILCRITICALERRORS);

    result1 = GetVolumeInformation(lpVolumeGuid,
        lpVolumeLabel,
        cchVolumeLabel,
        NULL,   // no need for serial number
        NULL,   // max file name length
        &dwFSFlags, // !! we might need to store some of this ...
        lpFsName,
        cchFsName
        );

    result2 = GetDiskFreeSpace(lpVolumeGuid,
        &dwSectorsPerCluster,
        &dwBytesPerSector,
        &dwNumFreeClusters,
        &dwTotalNumClusters
        );

    *lpClusterSize = dwSectorsPerCluster * dwBytesPerSector;

    return (result1 && result2);
}


BOOL
AddSortedVolumeInfo(
    IN OUT PASRFMT_VOLUME_INFO *ppHead,
    IN PASRFMT_VOLUME_INFO pNew
    )
{

    if (!pNew) {
        ASSERT(0 && L"Trying to add a null volume");
        return TRUE;
    }

    pNew->pNext = *ppHead;
    (*ppHead) = pNew;

    return TRUE;
}



BOOL
AddSortedRemovableMediaInfo(
    IN OUT PASRFMT_REMOVABLE_MEDIA_INFO *ppHead,
    IN PASRFMT_REMOVABLE_MEDIA_INFO pNew
    )
{

    if (!pNew) {
        ASSERT(0 && L"Trying to add a null Removable Media");
        return TRUE;
    }

    pNew->pNext = *ppHead;
    (*ppHead) = pNew;

    return TRUE;
}

typedef struct _ASRFMT_MP_LINK {

    PWSTR   pLink;
    USHORT  cchLink;

    struct _ASRFMT_MP_LINK *pNext;

} ASRFMT_MP_LINK, *PASRFMT_MP_LINK;


typedef struct _ASRFMT_MOUNT_POINTS_INFO {

    struct _ASRFMT_MOUNT_POINTS_INFO *pNext;

    //
    // Device Path, of the form \Device\HarddiskVolume1
    //
    PWSTR   pDeviceName;

    //
    // VolumeGuid for this volume  (\??\Volume{GUID})
    //
    PWSTR   pVolumeGuid;

    //
    // Additional symbolic links to this volume: including
    // DOS Drive letter (\DosDevices\C:) and additional Volume 
    // Guids (\??\Volume{GUID})
    //
    PASRFMT_MP_LINK pSymbolicLinks;

    PVOID   lpBufferToFree;

    DWORD   dwClusterSize;

    USHORT  cchDeviceName;
    USHORT  cchVolumeGuid;

    BOOL    IsClusterShared;
    
    WCHAR   szFsName[MAX_PATH + 1];
    WCHAR   szLabel[MAX_PATH + 1];

} ASRFMT_MOUNT_POINTS_INFO, *PASRFMT_MOUNT_POINTS_INFO;


VOID
FreeLink(
    IN PASRFMT_MP_LINK *ppLink
    )
{
    PASRFMT_MP_LINK pTemp = NULL,
        pCurrent = (*ppLink);
    HANDLE hHeap = GetProcessHeap();

    while (pCurrent) {
        pTemp = pCurrent->pNext;
        HeapFree(hHeap, 0L, pCurrent);
        pCurrent = pTemp;
    }

    *ppLink = NULL;
}

VOID
FreeMpInfo(
    IN PASRFMT_MOUNT_POINTS_INFO *ppMpInfo
    ) 
{
    PASRFMT_MOUNT_POINTS_INFO pTemp = NULL,
        pCurrent = (*ppMpInfo);
    HANDLE hHeap = GetProcessHeap();

    while (pCurrent) {
        if (pCurrent->pSymbolicLinks) {
            FreeLink(&(pCurrent->pSymbolicLinks));
        }

        if (pCurrent->lpBufferToFree) {
            HeapFree(hHeap, 0L, (pCurrent->lpBufferToFree));
            pCurrent->lpBufferToFree = NULL;
        }

        pTemp = pCurrent->pNext;
        HeapFree(hHeap, 0L, pCurrent);
        pCurrent = pTemp;
    }

    *ppMpInfo = NULL;
}



BOOL
AddSymbolicLink(
    IN PASRFMT_MOUNT_POINTS_INFO pMpInfoList, 
    IN PWSTR lpDeviceName, 
    IN USHORT cchDeviceName, 
    IN PWSTR lpSymbolicLink, 
    IN USHORT cchSymbolicLink,
    IN PVOID lpBufferToFree
    ) 
{
    BOOL foundAMatch = FALSE;
    HANDLE hHeap = GetProcessHeap();
    PASRFMT_MOUNT_POINTS_INFO pMp = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    if (!pMpInfoList) {
        return FALSE;
    }

    pMp = pMpInfoList;
    while (pMp && !foundAMatch) {

        if ((pMp->pDeviceName) &&                       // Node has a device name
            (cchDeviceName == pMp->cchDeviceName) &&    // lengths are equal
            !wcsncmp(pMp->pDeviceName, lpDeviceName, cchDeviceName)) {      // strings match
            //
            // We already have a node for this device name.
            //
            if (!wcsncmp(ASRFMT_WSZ_VOLUME_GUID_PREFIX, lpSymbolicLink, ASRFMT_CB_VOLUME_GUID_PREFIX/sizeof(WCHAR))
                && !(pMp->pVolumeGuid)
                ) {
                //
                // This symbolic link looks like a volume GUID, and this node 
                // doesn't already have a pVolumeGuid set.
                //
                pMp->pVolumeGuid = lpSymbolicLink;
                pMp->cchVolumeGuid = cchSymbolicLink;
            }
            else {
                //
                // Either the node already has a pVolumeGuid set, or the
                // symbolic link doesn't look like a volume Guid.  So it
                // must be a new symbolic link.
                //
                PASRFMT_MP_LINK pNewLink = (PASRFMT_MP_LINK) HeapAlloc(
                    hHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(ASRFMT_MP_LINK)
                    );
                ErrExitCode(!pNewLink, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                pNewLink->pNext = pMp->pSymbolicLinks;
                pMp->pSymbolicLinks = pNewLink;

                pNewLink->pLink = lpSymbolicLink;
                pNewLink->cchLink = cchSymbolicLink;
            }
            foundAMatch = TRUE;
        }

        pMp = pMp->pNext;
    }

    if (!foundAMatch) {

        if (pMpInfoList->pDeviceName) {
            //
            // pMpInfoList is already taken
            //
            pMp = (PASRFMT_MOUNT_POINTS_INFO) HeapAlloc(
                hHeap,
                HEAP_ZERO_MEMORY,
                sizeof(ASRFMT_MOUNT_POINTS_INFO)
                );
            ErrExitCode(!pMp, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

            pMp->pNext = pMpInfoList->pNext;
            pMpInfoList->pNext = pMp;
        }
        else {
            pMp = pMpInfoList;
        }

        pMp->pDeviceName = lpDeviceName;
        pMp->cchDeviceName = cchDeviceName;
        pMp->lpBufferToFree = lpBufferToFree;

        //
        // Add the symbolic link to this new device
        //
        AddSymbolicLink(pMp, lpDeviceName, cchDeviceName, lpSymbolicLink, cchSymbolicLink, lpBufferToFree);
    }

EXIT:

    
    return (BOOL)(ERROR_SUCCESS == dwStatus);
}



//
// The following two definitions are also in syssetup:asrclus.cpp.  This MUST be
// kept in sync.
//
typedef struct _ASRFMT_CLUSTER_VOLUME_INFO {

    UINT driveType;

    DWORD PartitionNumber;

    ULONG FsNameOffset;
    USHORT FsNameLength;
    
    ULONG LabelOffset;
    USHORT LabelLength;

    ULONG SymbolicNamesOffset;
    USHORT SymbolicNamesLength;
    
    DWORD dwClusterSize;

} ASRFMT_CLUSTER_VOLUME_INFO, *PASRFMT_CLUSTER_VOLUME_INFO;


typedef struct _ASRFMT_CLUSTER_VOLUMES_TABLE {

    DWORD DiskSignature;

    DWORD NumberOfEntries;

    ASRFMT_CLUSTER_VOLUME_INFO VolumeInfoEntry[1];

} ASRFMT_CLUSTER_VOLUMES_TABLE, *PASRFMT_CLUSTER_VOLUMES_TABLE;



BOOL
GetVolumeDevicePath(
    IN PCWSTR lpPartitionDevicePath,
    IN CONST  cbPartitionDevicePath,
    OUT PWSTR *lpVolumeDevicePath
    )
{

    PMOUNTMGR_MOUNT_POINT   mountPointIn    = NULL;
    PMOUNTMGR_MOUNT_POINTS  mountPointsOut  = NULL;
    MOUNTMGR_MOUNT_POINTS   mountPointsTemp;
    DWORD   mountPointsSize                 = 0;

    HANDLE  mpHandle                        = NULL;
    HANDLE  heapHandle                      = NULL;

    ULONG   index                           = 0;
    LONG    status                          = ERROR_SUCCESS;
    BOOL    result                          = FALSE;

    memset(&mountPointsTemp, 0L, sizeof(MOUNTMGR_MOUNT_POINTS));

    //
    // set OUT variables to known values.
    //
    *lpVolumeDevicePath = NULL;

    heapHandle = GetProcessHeap();
    ASSERT(heapHandle);

    //
    // Open the mount manager, and get the devicepath for this partition
    //

    // allocate memory for the mount point input structure
    mountPointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (MOUNTMGR_MOUNT_POINT) + cbPartitionDevicePath
        );
    ErrExitCode(!mountPointIn, status, ERROR_NOT_ENOUGH_MEMORY);

    // get a handle to the mount manager
    mpHandle = CreateFileW(
        (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE
        );
    ErrExitCode((!mpHandle || INVALID_HANDLE_VALUE == mpHandle), status, GetLastError());

     // put the DeviceName right after struct mountPointIn
    wcsncpy((PWSTR) (mountPointIn + 1), lpPartitionDevicePath, (cbPartitionDevicePath / sizeof(WCHAR)) - 1);
    mountPointIn->DeviceNameOffset = sizeof(*mountPointIn);
    mountPointIn->DeviceNameLength = (USHORT) (cbPartitionDevicePath - sizeof(WCHAR));

    // this call should fail with ERROR_MORE_DATA
    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        mountPointIn,
        sizeof(*mountPointIn) + mountPointIn->DeviceNameLength,
        &mountPointsTemp,
        sizeof(mountPointsTemp),
        &mountPointsSize,
        NULL
        );

    if (!result) {
        status = GetLastError();

        // if buffer is of insufficient size, resize the buffer.
        if (ERROR_MORE_DATA             == status ||
            ERROR_INSUFFICIENT_BUFFER   == status ||
            ERROR_BAD_LENGTH            == status
            ) {

            status = ERROR_SUCCESS;

            mountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                mountPointsTemp.Size
                );
            ErrExitCode(!mountPointsOut, status, ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            //
            // If some other error occurred, EXIT.
            // This is not a fatal error in the case of removable storage media
            //
            ErrExitCode(status, status, ERROR_SUCCESS);
        }
    }
    else {
        //
        // the call succeeded when we expected it to fail--something's wrong.
        // This is not a fatal error in the case of removable storage media.
        //
        ErrExitCode(result, status, ERROR_SUCCESS);
    }

    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        mountPointIn,
        sizeof(*mountPointIn) + mountPointIn->DeviceNameLength,
        mountPointsOut,
        mountPointsTemp.Size,
        &mountPointsSize,
        NULL
        );
    ErrExitCode((!mountPointsSize || !result), status, GetLastError());

    (*lpVolumeDevicePath) = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        mountPointsOut->MountPoints[0].DeviceNameLength + sizeof(WCHAR)
        );
    ErrExitCode(!(*lpVolumeDevicePath), status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Get the Device Path returned
    //
    CopyMemory((*lpVolumeDevicePath), 
        (PWSTR) (((LPBYTE) mountPointsOut) + mountPointsOut->MountPoints[index].SymbolicLinkNameOffset),
        mountPointsOut->MountPoints[0].DeviceNameLength
        );

EXIT:

    //
    // Free up locally allocated data
    //
    if (mountPointIn) {
       HeapFree(heapHandle, 0L, mountPointIn);
       mountPointIn = NULL;
    }

    if (mountPointsOut) {
       HeapFree(heapHandle, 0L, mountPointsOut);
       mountPointsOut = NULL;
    }

    if (status != ERROR_SUCCESS) {
        if (*lpVolumeDevicePath) {
            HeapFree(heapHandle, 0L, (*lpVolumeDevicePath));
        }
        
    }

    if ((mpHandle) && (INVALID_HANDLE_VALUE != mpHandle)) {
        CloseHandle(mpHandle);
    }

    return (BOOL) (status == ERROR_SUCCESS);
}


BOOL
AddClusterInfoToMountPoints(
    IN PASRFMT_MOUNT_POINTS_INFO pMpInfoList, 
    IN PCWSTR   lpDeviceName,
    IN BOOL     bIsClusterShared,
    IN PCWSTR   lpFsName,
    IN DWORD    cchFsName,
    IN PCWSTR   lpLabel,
    IN DWORD    cchLabel,
    IN DWORD    dwClusterSize
    ) 
{

    BOOL foundAMatch = FALSE;
    PASRFMT_MOUNT_POINTS_INFO pMp = NULL;

    if (!pMpInfoList) {
        return FALSE;
    }

    pMp = pMpInfoList;
    while (pMp && !foundAMatch) {

        if ((pMp->pDeviceName) && 
            (pMp->cchDeviceName == wcslen(lpDeviceName)) && 
            !(wcsncmp(pMp->pDeviceName, lpDeviceName, pMp->cchDeviceName))) {
            
            //
            // This is the correct node, copy over the info .
            //
            pMp->IsClusterShared = bIsClusterShared;
            wcsncpy(pMp->szFsName, lpFsName, cchFsName);
            wcsncpy(pMp->szLabel, lpLabel, cchLabel);
            pMp->dwClusterSize = dwClusterSize;

            foundAMatch = TRUE;
        }

        pMp = pMp->pNext;
    }

    return foundAMatch;
}


//
// Enums the cluster disks, and for each disk,
// calls across to syssetup!XYZ on the owner node.
// 
// Which then goes through all the partitions on the disk,
// gets the volume info for each partition on the disk,
// and passes back the signature and other relevant
// volume info for each partition.
// 
// This struct then gets the local disk number for the
// disk, gets the volume guid for that partition, and
// adds in volume nodes for the partition.
//
DWORD 
ResourceCallBack(
    IN HRESOURCE hOriginal,   
    IN HRESOURCE hResource,  
    IN PVOID lpParams   
    )
{

    DISK_DLL_EXTENSION_INFO inBuffer;
    
    PBYTE outBuffer = NULL;
    
    DWORD sizeOutBuffer = 0,
        bytesReturned = 0;

    DWORD status = ERROR_SUCCESS;

    PASRFMT_MOUNT_POINTS_INFO pMountPoints = NULL;

    PASRFMT_CLUSTER_VOLUMES_TABLE pClusterVolTable = NULL;

    WCHAR szPartitionDevicePath[ASRFMT_DEVICEPATH_FORMAT_LENGTH];
    
    HANDLE heapHandle = NULL;

    BOOL done = FALSE,
        result = TRUE;

    DWORD iCount = 0;
    
    PWSTR lpDevicePath = NULL,
        symbolicLink = NULL,
        lpFsName = NULL,
        lpLabel = NULL;

    USHORT cchFsName = 0,
        cchLabel = 0,
        cchDevicePath = 0,
        cchSymbolicLink = 0;

    DWORD dwClusterSize = 0;

    if (!lpParams) {
        //
        // The system must have at least one mount point that has been enumerated
        // already (the system volume, at least!), so our mount point list shouldn't be NULL.
        //
        ASSERT(0);
        return ERROR_INVALID_PARAMETER;
    }

    memset(szPartitionDevicePath, 0L, (ASRFMT_DEVICEPATH_FORMAT_LENGTH)*sizeof(WCHAR));
    heapHandle = GetProcessHeap();
    pMountPoints = (PASRFMT_MOUNT_POINTS_INFO) lpParams;

    //
    // Allocate a reasonably-sized memory for the out buffer.  If this isn't 
    // big enough, we'll re-allocate.
    //
    sizeOutBuffer = 4096;
    outBuffer = (PBYTE) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeOutBuffer
        );
    ErrExitCode(!outBuffer, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Call AsrGetVolumeInfo on the node owning this disk resource
    // 
    ZeroMemory(&inBuffer, sizeof(inBuffer));
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy(inBuffer.DllModuleName, ASRFMT_CLUSTER_DLL_MODULE_NAME);
    strcpy(inBuffer.DllProcName, ASRFMT_CLUSTER_DLL_PROC_NAME);
    
    status = ClusterResourceControl(
        hResource,
        NULL,
        CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
        &inBuffer,
        sizeof(DISK_DLL_EXTENSION_INFO),
        (PVOID) outBuffer,
        sizeOutBuffer,
        &bytesReturned 
        );

    if (ERROR_INSUFFICIENT_BUFFER == status) {
        //
        // The buffer wasn't big enough, re-allocate as needed
        //
        HeapFree(heapHandle, 0L, outBuffer);

        sizeOutBuffer = bytesReturned;
        outBuffer = (PBYTE) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeOutBuffer
            );
        ErrExitCode(!outBuffer, status, ERROR_NOT_ENOUGH_MEMORY);

        status = ClusterResourceControl( 
            hResource,
            NULL,
            CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
            &inBuffer,
            sizeof(DISK_DLL_EXTENSION_INFO),
            (PVOID) outBuffer,
            sizeOutBuffer,
            &bytesReturned 
            );
    }
    ErrExitCode((ERROR_SUCCESS != status), status, status);

    pClusterVolTable = (PASRFMT_CLUSTER_VOLUMES_TABLE) outBuffer;


    //
    // Go through the Volume info entries for each partition, and copy over the 
    // info to the appropriate MpInfo node
    //
    for (iCount = 0; iCount < pClusterVolTable->NumberOfEntries; iCount++) {

        lpFsName = (PWSTR) (((LPBYTE)pClusterVolTable) + pClusterVolTable->VolumeInfoEntry[iCount].FsNameOffset);
        cchFsName = pClusterVolTable->VolumeInfoEntry[iCount].FsNameLength / sizeof (WCHAR);

        lpLabel = (PWSTR) (((LPBYTE)pClusterVolTable) + pClusterVolTable->VolumeInfoEntry[iCount].LabelOffset);
        cchLabel = pClusterVolTable->VolumeInfoEntry[iCount].LabelLength / sizeof (WCHAR);

        dwClusterSize = (DWORD) (pClusterVolTable->VolumeInfoEntry[iCount].dwClusterSize);

        if (!(pClusterVolTable->VolumeInfoEntry[iCount].SymbolicNamesOffset)) {
            continue;
        }

        //
        // This is a "fake" device path (that is actually the first symbolic link), since 
        // absolute device paths for volumes on remote nodes are not relevant on local node.
        //
        lpDevicePath = (PWSTR) (((LPBYTE)pClusterVolTable) + pClusterVolTable->VolumeInfoEntry[iCount].SymbolicNamesOffset);
        cchDevicePath = (USHORT) wcslen(lpDevicePath);

        AddSymbolicLink(pMountPoints, lpDevicePath, cchDevicePath, lpDevicePath, cchDevicePath, (LPVOID)outBuffer);

        //
        // Add VolumeInfo to pMountPoints DevicePath;
        //
        result = AddClusterInfoToMountPoints(
            pMountPoints, 
            lpDevicePath,
            TRUE,                               // IsClusterShared
            lpFsName,
            cchFsName,
            lpLabel,
            cchLabel,
            dwClusterSize
            );
        ASSERT(result);

        symbolicLink = (PWSTR) ((LPBYTE)lpDevicePath + (sizeof(WCHAR) * (cchDevicePath + 1)));
        while (*symbolicLink) {

            cchSymbolicLink = (USHORT) wcslen(symbolicLink);
            AddSymbolicLink(pMountPoints, lpDevicePath, cchDevicePath, symbolicLink, cchSymbolicLink, (LPVOID)outBuffer);

            symbolicLink = (PWSTR) ((LPBYTE)symbolicLink + (sizeof(WCHAR) * (cchSymbolicLink + 1)));
        }
    }

EXIT:

/*    if (outBuffer) {
        HeapFree(heapHandle, 0L, outBuffer);
    }
*/
    return status;
}


BOOL
HandleClusterVolumes(
    IN PASRFMT_MOUNT_POINTS_INFO pMountPoints
    )
{
    if (!pMountPoints) {
        ASSERT(0 && "pMountPoints is NULL");
        return FALSE;
    }

    ResUtilEnumResources(NULL,
        ASRFMT_CLUSTER_PHYSICAL_DISK,
        ResourceCallBack,
        pMountPoints
        );

    return TRUE;
}


BOOL
pAcquirePrivilege(
    IN CONST PCWSTR szPrivilegeName
    )
{
    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );

    if (!bResult) {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL, szPrivilegeName, &luid);
    if (!bResult) {
        CloseHandle(hToken);
        return FALSE;
    }

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );

    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    CloseHandle(hToken);
    return bResult;
}


BOOL
BuildStateInfo(
    IN PASRFMT_STATE_INFO pState
    )
{
    UINT driveType = DRIVE_UNKNOWN;
    WCHAR szVolumeGuid[MAX_PATH + 1];

    PWSTR lpDevName = NULL,
        lpSymbolicLink = NULL;
    
    USHORT cchDevName = 0,
        cchSymbolicLink = 0;

    DWORD iCount = 0;
    
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = FALSE;
    PMOUNTMGR_MOUNT_POINTS pMountPoints = NULL;
    HANDLE hHeap = NULL;

    PASRFMT_MOUNT_POINTS_INFO pMpInfoList = NULL,
        pMp = NULL;

    hHeap = GetProcessHeap();

    //
    // We need to acquire the backup and restore privileges to write to asr.sif
    //
    if (!pAcquirePrivilege(SE_BACKUP_NAME)) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    if (!pAcquirePrivilege(SE_RESTORE_NAME)) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    pMountPoints = GetMountPoints();
    if (!pMountPoints) {
        //
        // No volumes exist (!)
        //
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    pMpInfoList = (PASRFMT_MOUNT_POINTS_INFO) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof(ASRFMT_MOUNT_POINTS_INFO)
        );
    ErrExitCode(!pMpInfoList, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Now, we go through the mountpoint table returned, and
    // create the appropriate structs that we'll need to save.
    //
    // The mount point table consists of entries of the form:
    //   device name                symbolic link
    // ----------------------------------------------
    // \device\harddiskvolume1      \??\volume{guid1}
    // \device\harddiskvolume1      \dosdevices\c:
    // \device\harddiskvolume1      \??\volume{guid2}
    // \device\harddiskvolume2      \??\volume{guid3}
    // \device\harddiskvolume2      \dosdevices\d:
    // \device\floppy0              \dosdevices\a:
    // \device\floppy0              \??\volume{guid4}
    // \device\cdrom0               \dosdevices\e:
    // \device\cdrom0               \??\volume{guid5}
    //
    // ... etc
    //
    // For fixed disks, we don't care about the device name, and we
    // store the following in asr.sif:
    //
    // [VOLUMES]
    // \??\volume{guid1}, \dosdevices\c:
    // \??\volume{guid1}, \??\volume{guid2}
    // \??\volume{guid3}, \dosdevices\d:
    //
    //
    // For removable devices, we care about the device name as well, 
    // and store this in asr.sif:
    //
    // [RemovableMedia]
    // \device\floppy0, \??\volume{guid4}, \dosdevices\a:
    // \device\cdrom0, \??\volume{guid5}, \dosdevices\e:
    //
    //
    // First, we build up our structure containing the info
    //
    for (iCount = 0; iCount < pMountPoints->NumberOfMountPoints; iCount++) {

        lpDevName = (PWSTR) (((LPBYTE)pMountPoints) + pMountPoints->MountPoints[iCount].DeviceNameOffset);
        cchDevName = pMountPoints->MountPoints[iCount].DeviceNameLength / sizeof (WCHAR);

        lpSymbolicLink = (PWSTR) (((LPBYTE)pMountPoints) + pMountPoints->MountPoints[iCount].SymbolicLinkNameOffset);
        cchSymbolicLink = pMountPoints->MountPoints[iCount].SymbolicLinkNameLength / sizeof (WCHAR);


        AddSymbolicLink(pMpInfoList, lpDevName, cchDevName, lpSymbolicLink, cchSymbolicLink, (LPVOID)NULL);

    }

    //
    // Add the volume info for any cluster volumes, since we cannot access them 
    // directly if the disk is owned by another node.  This function will fail
    // if we're not running on a cluster--so we don't care about the return value.
    //
    HandleClusterVolumes(pMpInfoList);

    //
    // Now, we go through the list, and build the pVolume and pRemovableMedia
    // structs
    //
    pMp = pMpInfoList;
    while (pMp) {

        if (!(pMp->pDeviceName && pMp->pVolumeGuid)) {
            pMp = pMp->pNext;
            continue;
        }

        DWORD cchGuid = pMp->cchVolumeGuid;

        WCHAR szFsName[ASRFMT_CCH_FS_NAME];
        WCHAR szLabel[ASRFMT_CCH_VOLUME_LABEL];
        DWORD dwClusterSize;

        //
        // GetDriveType needs the volume guid in the dos-name-space, while the
        // mount manager gives the volume guid in the nt-name-space.  Convert
        // the name by changing the \??\ at the beginning to \\?\, and adding 
        // a back-slash at the end.
        //
        wcsncpy(szVolumeGuid, pMp->pVolumeGuid, cchGuid);
        szVolumeGuid[1] = L'\\';
        szVolumeGuid[cchGuid] = L'\\';    // Trailing back-slash
        szVolumeGuid[cchGuid+1] = L'\0';

        driveType = DRIVE_UNKNOWN;
        if (!pMp->IsClusterShared) {
            driveType = GetDriveType(szVolumeGuid);
        }

        if ((pMp->IsClusterShared) || (DRIVE_FIXED == driveType)) {

            if (!pMp->IsClusterShared) {
                //
                // Get the FS Label, cluster size, and so on.
                //
                bResult = GetVolumeDetails(szVolumeGuid, 
                    szFsName, 
                    ASRFMT_CCH_FS_NAME, 
                    szLabel, 
                    ASRFMT_CCH_VOLUME_LABEL,
                    &dwClusterSize
                    );
                // ErrExitCode(!bResult, dwStatus, GetLastError());
            }
            else {
                //
                // If it's a cluster shared disk, then we already
                // got the relavant info earlier
                //
                wcscpy(szFsName, pMp->szFsName);
                wcscpy(szLabel, pMp->szLabel);
                dwClusterSize = pMp->dwClusterSize;
            }

            //
            // Now, create a VolumeInfo structure for each symbolic link.
            //
            PASRFMT_MP_LINK pCurrentLink = pMp->pSymbolicLinks;
            if (!pCurrentLink) {
                //
                // This volume does not have any symbolic links attached to it
                //
                PASRFMT_VOLUME_INFO pNewVolume = (PASRFMT_VOLUME_INFO) HeapAlloc(
                    hHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(ASRFMT_VOLUME_INFO)
                    );
                ErrExitCode(!pNewVolume, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                wcsncpy(pNewVolume->szGuid, pMp->pVolumeGuid, pMp->cchVolumeGuid);

                wcscpy(pNewVolume->szFsName, szFsName);
                wcscpy(pNewVolume->szLabel, szLabel);
                pNewVolume->dwClusterSize = dwClusterSize;

                bResult = AddSortedVolumeInfo(&(pState->pVolume), pNewVolume);
                ErrExitCode(!bResult, dwStatus, GetLastError());
            }
            else {
                while (pCurrentLink) {

                    PASRFMT_VOLUME_INFO pNewVolume = (PASRFMT_VOLUME_INFO) HeapAlloc(
                        hHeap,
                        HEAP_ZERO_MEMORY,
                        sizeof(ASRFMT_VOLUME_INFO)
                        );
                    ErrExitCode(!pNewVolume, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                    wcsncpy(pNewVolume->szGuid, pMp->pVolumeGuid, pMp->cchVolumeGuid);
                    wcsncpy(pNewVolume->szDosPath, pCurrentLink->pLink, pCurrentLink->cchLink);

                    wcscpy(pNewVolume->szFsName, szFsName);
                    wcscpy(pNewVolume->szLabel, szLabel);
                    pNewVolume->dwClusterSize = dwClusterSize;

                    bResult = AddSortedVolumeInfo(&(pState->pVolume), pNewVolume);
                    ErrExitCode(!bResult, dwStatus, GetLastError());

                    pCurrentLink = pCurrentLink->pNext;
                }
            }

        }
        else if (DRIVE_UNKNOWN != driveType) {

            PASRFMT_MP_LINK pCurrentLink = pMp->pSymbolicLinks;
            if (!pCurrentLink) {
                //
                // This volume has no symbolic links at all (ie no drive
                // letter or mountpoint)
                //
                PASRFMT_REMOVABLE_MEDIA_INFO pNewMedia = (PASRFMT_REMOVABLE_MEDIA_INFO) HeapAlloc(
                    hHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(ASRFMT_REMOVABLE_MEDIA_INFO)
                    );
                ErrExitCode(!pNewMedia, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                wcsncpy(pNewMedia->szVolumeGuid, pMp->pVolumeGuid, pMp->cchVolumeGuid);
                wcsncpy(pNewMedia->szDevicePath, pMp->pDeviceName, pMp->cchDeviceName);

                bResult = AddSortedRemovableMediaInfo(&(pState->pRemovableMedia), pNewMedia);
                ErrExitCode(!bResult, dwStatus, GetLastError());
            }
            else {

                while (pCurrentLink) {

                    PASRFMT_REMOVABLE_MEDIA_INFO pNewMedia = (PASRFMT_REMOVABLE_MEDIA_INFO) HeapAlloc(
                        hHeap,
                        HEAP_ZERO_MEMORY,
                        sizeof(ASRFMT_REMOVABLE_MEDIA_INFO)
                        );
                    ErrExitCode(!pNewMedia, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

                    wcsncpy(pNewMedia->szVolumeGuid, pMp->pVolumeGuid, pMp->cchVolumeGuid);
                    wcsncpy(pNewMedia->szDosPath, pCurrentLink->pLink, pCurrentLink->cchLink);
                    wcsncpy(pNewMedia->szDevicePath, pMp->pDeviceName, pMp->cchDeviceName);

                    bResult = AddSortedRemovableMediaInfo(&(pState->pRemovableMedia), pNewMedia);
                    ErrExitCode(!bResult, dwStatus, GetLastError());

                    pCurrentLink = pCurrentLink->pNext;
                }
            }
        }

        pMp = pMp->pNext;
     }

EXIT:
    if (pMountPoints) {
        HeapFree(hHeap, 0L, pMountPoints);
        pMountPoints = NULL;
    }

    if (pMpInfoList) {
        FreeMpInfo(&pMpInfoList);
    }

    return (ERROR_SUCCESS == dwStatus);
}


//
// Sets the dosdevices (of the form "\DosDevices\X:") for the 
// volume with the GUID passed in (of the form "\??\Volume{Guid}")
//
BOOL
SetDosName(
    IN PWSTR lpVolumeGuid,
    IN PWSTR lpDosPath
    )
{
    HANDLE hMountMgr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = TRUE;

    WCHAR szDeviceNameForGuid[MAX_PATH + 1],
        szDeviceNameForDosPath[MAX_PATH + 1];

    if (!lpVolumeGuid || !lpDosPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Open the mount manager
    //
    hMountMgr = CreateFileW(
        (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,
        GENERIC_READ    | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE
        );
    ErrExitCode((!hMountMgr || INVALID_HANDLE_VALUE == hMountMgr), dwStatus, GetLastError());

    //
    // Get the Device Paths from the GUID and Dos Path
    //
    bResult = DoMountMgrWork(hMountMgr, mmfGetDeviceName, lpVolumeGuid, szDeviceNameForGuid);
    ErrExitCode(!bResult, dwStatus, GetLastError());

    bResult = DoMountMgrWork(hMountMgr, mmfGetDeviceName, lpDosPath, szDeviceNameForDosPath);
    if (bResult && !wcscmp(szDeviceNameForGuid, szDeviceNameForDosPath)) {
        //
        // The Guid already has the Dos Path.  We're done.
        //
        ErrExitCode(TRUE, dwStatus, ERROR_SUCCESS);
    }

    //
    // Delete the dos path if it is currently being used by another volume
    //
    if (wcslen(lpDosPath) > 0) {
        bResult = DoMountMgrWork(hMountMgr, mmfDeleteDosName, lpDosPath, NULL);
    }

    //
    // If we're trying to set the drive letter, then delete any other dos path 
    // currently being used by this volume.
    //
    if (ASRFMT_LOOKS_LIKE_DOS_DEVICE(lpDosPath, (wcslen(lpDosPath) * sizeof(WCHAR)))
        || (0 == wcslen(lpDosPath))
        ) {
        bResult = DoMountMgrWork(hMountMgr, mmfDeleteDosName, NULL, szDeviceNameForGuid);
        ErrExitCode(!bResult, dwStatus, GetLastError());
    }

    //
    // Assign the Dos Path to this VolumeGuid
    //
    if (wcslen(lpDosPath) > 0) {
        bResult = DoMountMgrWork(hMountMgr, mmfCreateSymbolicLinkName, lpDosPath, lpVolumeGuid);
        ErrExitCode(!bResult, dwStatus, GetLastError());
    }

EXIT:
    if (hMountMgr && INVALID_HANDLE_VALUE != hMountMgr) {
        CloseHandle(hMountMgr);
    }

    return (BOOL) (ERROR_SUCCESS == dwStatus);
}


BOOL
SetRemovableMediaGuid(
    IN PWSTR lpDeviceName,
    IN PWSTR lpGuid
    )
{
    static LONG s_LastCdIndex = 0;
    static LONG s_LastFloppyIndex = 0;
    static LONG s_LastJazIndex = 0;

    static PMOUNTMGR_MOUNT_POINTS s_pMountPoints = NULL;
    static HANDLE s_hMountMgr = NULL;

    WCHAR szNewDeviceName[MAX_PATH + 1];
    ZeroMemory(szNewDeviceName, (MAX_PATH+1) * sizeof(WCHAR));

    LONG index = 0;

    if ((!lpDeviceName) && (!lpGuid)) {
        //
        // Both parameters are NULL, we free the mount points and reset Indices.
        //
        s_LastCdIndex =  (LONG) s_pMountPoints->NumberOfMountPoints - 1;
        s_LastFloppyIndex = (LONG) s_pMountPoints->NumberOfMountPoints - 1;
        s_LastJazIndex = (LONG) s_pMountPoints->NumberOfMountPoints - 1;

        if (s_pMountPoints) {
            HeapFree(GetProcessHeap(), 0L, s_pMountPoints);
            s_pMountPoints = NULL;
        }
        
        if (s_hMountMgr && INVALID_HANDLE_VALUE != s_hMountMgr) {
            CloseHandle(s_hMountMgr);
            s_hMountMgr = NULL;
        }
        
        return TRUE;
    } 

    if ((!lpDeviceName) || (!lpGuid)) {
        return FALSE;
    }

    if (!s_pMountPoints) {
        //
        // This is the first time this function is being called (after a 
        // clean-up), we get a list of mount points on the current machine
        // and store it.
        //
        s_pMountPoints = GetMountPoints();
        if (!s_pMountPoints) {
            return FALSE;
        }
        s_LastCdIndex =  (LONG) s_pMountPoints->NumberOfMountPoints - 1;
        s_LastFloppyIndex = (LONG) s_pMountPoints->NumberOfMountPoints - 1;
        s_LastJazIndex = (LONG) s_pMountPoints->NumberOfMountPoints - 1;
    }

    if ((!s_hMountMgr) || (INVALID_HANDLE_VALUE == s_hMountMgr)) {
        s_hMountMgr = CreateFileW(
            (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            INVALID_HANDLE_VALUE
            );

        if ((!s_hMountMgr) || (INVALID_HANDLE_VALUE == s_hMountMgr)) {
            return FALSE;
        }
    }

    index = s_pMountPoints->NumberOfMountPoints;

    if (wcsstr(lpDeviceName, L"\\Device\\CdRom")) {
        //
        // We're trying to set the GUID for a CD-ROM device  We go through the list of
        // the MountPoints, till we find the next \Device\CdRomX to use
        //
        for (index = s_LastCdIndex; index >= 0; index--) {
            //
            // Copy the device name from the MountPoint over to a temporary string
            //
            wcsncpy(szNewDeviceName,
                (PWSTR)(((LPBYTE)s_pMountPoints) + s_pMountPoints->MountPoints[index].DeviceNameOffset),
                s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)
                );
            szNewDeviceName[s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)] = L'\0';

            //
            // Check if this is a CD-ROM device
            //
            if (wcsstr(szNewDeviceName, L"\\Device\\CdRom")) {
                s_LastCdIndex = index - 1;
                //
                // Forward till we skip past any other mount points that are 
                // also pointing to this device
                //
                while ((s_LastCdIndex >= 0) && 
                    (s_pMountPoints->MountPoints[s_LastCdIndex].UniqueIdOffset == s_pMountPoints->MountPoints[index].UniqueIdOffset) &&
                    (s_pMountPoints->MountPoints[s_LastCdIndex].UniqueIdLength == s_pMountPoints->MountPoints[index].UniqueIdLength)
                    ) {
                    --s_LastCdIndex;
                }
                break;
            }
        }
    } 
    else if (wcsstr(lpDeviceName, L"\\Device\\Floppy")) {
        //
        // We're trying to set the GUID for a floppy device  We go through the list of
        // the MountPoints, till we find the next \Device\FloppyX to use
        //
        for (index = s_LastFloppyIndex; index >= 0; index--) {
            //
            // Copy the device name from the MountPoint over to a temporary string
            //
            wcsncpy(szNewDeviceName,
                (PWSTR)(((LPBYTE)s_pMountPoints) + s_pMountPoints->MountPoints[index].DeviceNameOffset),
                s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)
                );

            szNewDeviceName[s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)] = L'\0';

            //
            // Check if this is a Floppy device
            //
            if (wcsstr(szNewDeviceName, L"\\Device\\Floppy")) {
                s_LastFloppyIndex = index - 1;
                //
                // Forward till we skip past any other mount points that are 
                // also pointing to this device
                //
                while ((s_LastFloppyIndex >= 0) && 
                    (s_pMountPoints->MountPoints[s_LastFloppyIndex].UniqueIdOffset == s_pMountPoints->MountPoints[index].UniqueIdOffset) &&
                    (s_pMountPoints->MountPoints[s_LastFloppyIndex].UniqueIdLength == s_pMountPoints->MountPoints[index].UniqueIdLength)
                    ) {
                    --s_LastFloppyIndex;
                }
                break;
            }
        }
    } 
    else if (wcsstr(lpDeviceName, L"\\Device\\Harddisk") &&
        wcsstr(lpDeviceName, L"DP(") &&
        !wcsstr(lpDeviceName, L"Partition")
        ){
        //
        // This is most likely a JAZ or ZIP drive.  We can't do much to identify the 
        // JAZ/ZIP drives uniquely, so this may end up in the wrong drive getting the
        // wrong drive letter.
        // 
        for (index = s_LastJazIndex; index >= 0; index--) {
            //
            // Copy the device name from the MountPoint over to a temporary string
            //
            wcsncpy(szNewDeviceName,
                (PWSTR)(((LPBYTE)s_pMountPoints) + s_pMountPoints->MountPoints[index].DeviceNameOffset),
                s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)
                );

            szNewDeviceName[s_pMountPoints->MountPoints[index].DeviceNameLength/sizeof(WCHAR)] = L'\0';

            //
            // Check if this is a JAZ or ZIP device
            //
            if (wcsstr(szNewDeviceName, L"\\Device\\Harddisk") &&
                wcsstr(szNewDeviceName, L"DP(") &&
                !wcsstr(szNewDeviceName, L"Partition")
                ) {
                s_LastJazIndex = index - 1;
                //
                // Forward till we skip past any other mount points that are 
                // also pointing to this device
                //
                while ((s_LastJazIndex >= 0) && 
                    (s_pMountPoints->MountPoints[s_LastJazIndex].UniqueIdOffset == s_pMountPoints->MountPoints[index].UniqueIdOffset) &&
                    (s_pMountPoints->MountPoints[s_LastJazIndex].UniqueIdLength == s_pMountPoints->MountPoints[index].UniqueIdLength)
                    ) {
                    --s_LastJazIndex;
                }
                break;
            }
        }
    }
    else {
        //
        // We don't recognise this Device
        //
        index = -1;
    }

    if (index < 0) {
        return FALSE;
    }

    if (!DoMountMgrWork(s_hMountMgr, mmfDeleteVolumeGuid, NULL, szNewDeviceName)) {
        return FALSE;
    }

    if (!DoMountMgrWork(s_hMountMgr, mmfCreateSymbolicLinkName, lpGuid, szNewDeviceName)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
DoMountMgrWork(
    IN HANDLE hMountMgr,               
    IN ASRFMT_MM_FUNCTION mmfFunction,
    IN PWSTR lpSymbolicName,
    IN PWSTR lpDeviceName
    )
{
    
    PMOUNTMGR_MOUNT_POINT pMountPointIn = NULL,
        pDeletePointIn = NULL;
    PMOUNTMGR_MOUNT_POINTS pMountPointsOut = NULL;
    PMOUNTMGR_CREATE_POINT_INPUT pCreatePointIn = NULL;
    MOUNTMGR_MOUNT_POINTS MountPointsTemp;

    DWORD cbSymbolicName = 0,
        cbDeviceName = 0,
        cbMountPoints = 0;

    DWORD index = 0;

    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = TRUE;

    HANDLE hHeap = NULL;

    if (lpSymbolicName && !wcslen(lpSymbolicName)) {
        return TRUE;
    }

    hHeap = GetProcessHeap();

    if (lpSymbolicName) {
        cbSymbolicName = wcslen(lpSymbolicName) * sizeof(WCHAR);
    }

    if (lpDeviceName) {
        cbDeviceName = wcslen(lpDeviceName) * sizeof(WCHAR);
    }

    pMountPointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof(MOUNTMGR_MOUNT_POINT) + cbSymbolicName + cbDeviceName
        );
    ErrExitCode(!pMountPointIn, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

    if (mmfCreateSymbolicLinkName != mmfFunction) {
        //
        // Query for the Unique Id
        //
        if (cbSymbolicName) {
            pMountPointIn->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
            pMountPointIn->SymbolicLinkNameLength = (USHORT) cbSymbolicName;

            CopyMemory(((LPBYTE)pMountPointIn) + pMountPointIn->SymbolicLinkNameOffset,
                       lpSymbolicName, pMountPointIn->SymbolicLinkNameLength);
        }
        else  {
            pMountPointIn->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
            pMountPointIn->DeviceNameLength = (USHORT) cbDeviceName;

            CopyMemory((LPBYTE)pMountPointIn + pMountPointIn->DeviceNameOffset,
                       lpDeviceName, pMountPointIn->DeviceNameLength);
        } 

        // this call should fail with ERROR_MORE_DATA
        bResult = DeviceIoControl(
            hMountMgr,
            IOCTL_MOUNTMGR_QUERY_POINTS,
            pMountPointIn,
            (sizeof(*pMountPointIn) + pMountPointIn->DeviceNameLength + pMountPointIn->SymbolicLinkNameLength),
            &MountPointsTemp,
            sizeof(MountPointsTemp),
            &cbMountPoints,
            NULL
            );

        if (!bResult) {
            dwStatus = GetLastError();

            // if buffer is of insufficient size, resize the buffer.
            if (ERROR_MORE_DATA             == dwStatus || 
                ERROR_INSUFFICIENT_BUFFER   == dwStatus || 
                ERROR_BAD_LENGTH            == dwStatus 
                ) {

                dwStatus = ERROR_SUCCESS;

                pMountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
                    hHeap, 
                    HEAP_ZERO_MEMORY, 
                    MountPointsTemp.Size
                    );
                ErrExitCode(!pMountPointsOut, dwStatus, ERROR_NOT_ENOUGH_MEMORY);
            }
            else {
                //
                // If some other error occurred, EXIT.
                // This is not a fatal error in the case of removable storage media
                //
                ErrExitCode(bResult, dwStatus, ERROR_SUCCESS);
            }
        }
        else {
            //
            // the call succeeded when we expected it to fail--something's wrong.
            // This is not a fatal error in the case of removable storage media.
            //
            ErrExitCode(bResult, dwStatus, ERROR_SUCCESS);
        }

        bResult = DeviceIoControl(
            hMountMgr,
            IOCTL_MOUNTMGR_QUERY_POINTS,
            pMountPointIn,
            sizeof(*pMountPointIn) + pMountPointIn->DeviceNameLength + pMountPointIn->SymbolicLinkNameLength,
            pMountPointsOut,
            MountPointsTemp.Size,
            &cbMountPoints,
            NULL
            );
        ErrExitCode((!cbMountPoints || !bResult), dwStatus, GetLastError());
    }

    switch (mmfFunction) {
    case mmfGetDeviceName: {
        //
        //  Copy the device name to lpDeviceName, and we're done
        //
        CopyMemory(lpDeviceName, 
            ((LPBYTE) pMountPointsOut) + pMountPointsOut->MountPoints[0].DeviceNameOffset,
            pMountPointsOut->MountPoints[0].DeviceNameLength
            );

        // Null-terminate the string
        lpDeviceName[pMountPointsOut->MountPoints[0].DeviceNameLength / sizeof(WCHAR)] = L'\0';
        
        break;
    }
    
    case mmfDeleteDosName:
    case mmfDeleteVolumeGuid: {

        DWORD cbName = 0;
        PWSTR lpName = NULL;
        DWORD cbDeletePoint = 0;

        //
        // Go through the list of mount points returned, and delete the appropriate
        // entries.
        //
        for (index = 0; index < pMountPointsOut->NumberOfMountPoints; index++) {
            lpName = (PWSTR) (((LPBYTE)pMountPointsOut) + pMountPointsOut->MountPoints[index].SymbolicLinkNameOffset);
            cbName = (DWORD) pMountPointsOut->MountPoints[index].SymbolicLinkNameLength;

            if ((mmfDeleteDosName == mmfFunction) &&
               (ASRFMT_LOOKS_LIKE_DOS_DEVICE(lpName, cbName))
               ) {
               break;
            }

            if ((mmfDeleteVolumeGuid == mmfFunction) &&
                (ASRFMT_LOOKS_LIKE_VOLUME_GUID(lpName, cbName))
                ) {
               break;
            }
        }


        if (index == pMountPointsOut->NumberOfMountPoints) {
            //
            // No matching entries were found
            //
            break;
        }

        cbDeletePoint = sizeof(MOUNTMGR_MOUNT_POINT) +
            pMountPointsOut->MountPoints[index].SymbolicLinkNameLength +
            pMountPointsOut->MountPoints[index].UniqueIdLength +
            pMountPointsOut->MountPoints[index].DeviceNameLength;

        pDeletePointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
            hHeap,
            HEAP_ZERO_MEMORY,
            cbDeletePoint
            );
        ErrExitCode(!pDeletePointIn, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

        pDeletePointIn->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
        pDeletePointIn->SymbolicLinkNameLength = pMountPointsOut->MountPoints[index].SymbolicLinkNameLength;
        CopyMemory(((LPBYTE)pDeletePointIn) + pDeletePointIn->SymbolicLinkNameOffset,
            ((LPBYTE)pMountPointsOut) + pMountPointsOut->MountPoints[index].SymbolicLinkNameOffset,
            pDeletePointIn->SymbolicLinkNameLength);

        pDeletePointIn->UniqueIdOffset = pDeletePointIn->SymbolicLinkNameOffset +
                                        pDeletePointIn->SymbolicLinkNameLength;
        pDeletePointIn->UniqueIdLength = pMountPointsOut->MountPoints[index].UniqueIdLength;
        CopyMemory(((LPBYTE)pDeletePointIn) + pDeletePointIn->UniqueIdOffset,
            ((LPBYTE)pMountPointsOut) + pMountPointsOut->MountPoints[index].UniqueIdOffset,
            pDeletePointIn->UniqueIdLength);

        pDeletePointIn->DeviceNameOffset = pDeletePointIn->UniqueIdOffset +
                                          pDeletePointIn->UniqueIdLength;
        pDeletePointIn->DeviceNameLength = pMountPointsOut->MountPoints[index].DeviceNameLength;
        CopyMemory(((LPBYTE)pDeletePointIn) + pDeletePointIn->DeviceNameOffset,
            ((LPBYTE)pMountPointsOut) + pMountPointsOut->MountPoints[index].DeviceNameOffset,
            pDeletePointIn->DeviceNameLength);

        bResult = DeviceIoControl(hMountMgr,
            IOCTL_MOUNTMGR_DELETE_POINTS,
            pDeletePointIn,
            cbDeletePoint,
            pMountPointsOut,
            MountPointsTemp.Size,
            &cbMountPoints,
            NULL
            );
        ErrExitCode(!bResult, dwStatus, GetLastError());

        break;
    }

    case mmfCreateSymbolicLinkName: {

        pCreatePointIn = (PMOUNTMGR_CREATE_POINT_INPUT) HeapAlloc(
            hHeap,
            HEAP_ZERO_MEMORY,
            sizeof (MOUNTMGR_CREATE_POINT_INPUT) + cbDeviceName + cbSymbolicName 
            );
        ErrExitCode(!pCreatePointIn, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

        pCreatePointIn->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
        pCreatePointIn->SymbolicLinkNameLength = (USHORT) cbSymbolicName;

        pCreatePointIn->DeviceNameOffset = pCreatePointIn->SymbolicLinkNameOffset + pCreatePointIn->SymbolicLinkNameLength;
        pCreatePointIn->DeviceNameLength = (USHORT) cbDeviceName;

        CopyMemory(((LPBYTE)pCreatePointIn) + pCreatePointIn->SymbolicLinkNameOffset,
                   (LPBYTE)lpSymbolicName, pCreatePointIn->SymbolicLinkNameLength);

        CopyMemory(((LPBYTE)pCreatePointIn) + pCreatePointIn->DeviceNameOffset,
                   (LPBYTE)lpDeviceName, pCreatePointIn->DeviceNameLength);

        bResult = DeviceIoControl(
            hMountMgr, 
            IOCTL_MOUNTMGR_CREATE_POINT, 
            pCreatePointIn,
            sizeof(MOUNTMGR_CREATE_POINT_INPUT) + pCreatePointIn->SymbolicLinkNameLength + pCreatePointIn->DeviceNameLength, 
            NULL, 
            0, 
            &cbMountPoints, 
            NULL
            );
        ErrExitCode(!bResult, dwStatus, GetLastError());
    }

    }

EXIT:

    if (pCreatePointIn) {
        HeapFree(hHeap, 0L, pCreatePointIn);
        pCreatePointIn = NULL;
    }

    if (pDeletePointIn) {
        HeapFree(hHeap, 0L, pDeletePointIn);
        pDeletePointIn = NULL;
    }

    if (pMountPointIn) {
        HeapFree(hHeap, 0L, pMountPointIn);
        pMountPointIn = NULL;
    }

    if (pMountPointsOut) {
        HeapFree(hHeap, 0L, pMountPointsOut);
        pMountPointsOut = NULL;
    }

    return (BOOL) (ERROR_SUCCESS == dwStatus);
}


PMOUNTMGR_MOUNT_POINTS  // Must be freed by caller
GetMountPoints()
{
    PMOUNTMGR_MOUNT_POINTS pMountPointsOut = NULL;
    PMOUNTMGR_MOUNT_POINT pMountPointIn = NULL;
    MOUNTMGR_MOUNT_POINTS MountPointsTemp;
    HANDLE hMountMgr = NULL,
        hHeap = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bResult = TRUE;

    DWORD cbMountPoints = 0;


    hHeap = GetProcessHeap();

    pMountPointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        hHeap,
        HEAP_ZERO_MEMORY,
        sizeof(MOUNTMGR_MOUNT_POINT) + sizeof(WCHAR)
        );
    ErrExitCode(!pMountPointIn, dwStatus, ERROR_NOT_ENOUGH_MEMORY);

    // put the DeviceName ("") right after struct pMountPointIn
    wcsncpy((PWSTR) (pMountPointIn + 1), L"", 1);
    pMountPointIn->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    pMountPointIn->DeviceNameLength = 0;

    // get a handle to the mount manager
    hMountMgr = CreateFileW(
        (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE
        );
    ErrExitCode((!hMountMgr || INVALID_HANDLE_VALUE == hMountMgr), dwStatus, GetLastError());
     
    // this call should fail with ERROR_MORE_DATA
    bResult = DeviceIoControl(
        hMountMgr,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        pMountPointIn,
        sizeof(*pMountPointIn) + pMountPointIn->DeviceNameLength,
        &MountPointsTemp,
        sizeof(MountPointsTemp),
        &cbMountPoints,
        NULL
        );

    if (!bResult) {
        dwStatus = GetLastError();

        // if buffer is of insufficient size, resize the buffer.
        if (ERROR_MORE_DATA             == dwStatus || 
            ERROR_INSUFFICIENT_BUFFER   == dwStatus || 
            ERROR_BAD_LENGTH            == dwStatus 
            ) {

            dwStatus = ERROR_SUCCESS;

            pMountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
                hHeap, 
                HEAP_ZERO_MEMORY, 
                MountPointsTemp.Size
                );
            ErrExitCode(!pMountPointsOut, dwStatus, ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            //
            // If some other error occurred, EXIT.
            // This is not a fatal error in the case of removable storage media
            //
            ErrExitCode(bResult, dwStatus, ERROR_SUCCESS);
        }
    }
    else {
        //
        // the call succeeded when we expected it to fail--something's wrong.
        // This is not a fatal error in the case of removable storage media.
        //
        ErrExitCode(bResult, dwStatus, ERROR_SUCCESS);
    }

    bResult = DeviceIoControl(
        hMountMgr,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        pMountPointIn,
        sizeof(*pMountPointIn) + pMountPointIn->DeviceNameLength,
        pMountPointsOut,
        MountPointsTemp.Size,
        &cbMountPoints,
        NULL
        );
    ErrExitCode((!cbMountPoints || !bResult), dwStatus, GetLastError());

EXIT:
    if (ERROR_SUCCESS != dwStatus) {
        if (pMountPointsOut) {
            HeapFree(hHeap, 0L, pMountPointsOut);
            pMountPointsOut = NULL;
        }
    }

    if (hMountMgr && INVALID_HANDLE_VALUE != hMountMgr) {
        CloseHandle(hMountMgr);
    }

    return pMountPointsOut;
}

//
// Based on AsrpExpandEnvStrings in syssetup\setupasr.c
//
PWSTR   // must be freed by caller
AsrfmtpExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    )
{
    PWSTR expandedString = NULL;
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;
    BOOL result = FALSE;

    DWORD status = ERROR_SUCCESS;
    HANDLE heapHandle = GetProcessHeap();

    expandedString = (PWSTR) HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, (cchSize * sizeof(WCHAR)));
    ErrExitCode((!expandedString), status, ERROR_NOT_ENOUGH_MEMORY);
        
    cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
        expandedString,
        cchSize 
        );

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        HeapFree(heapHandle, 0L, expandedString);
        cchSize = cchRequiredSize + 1;

        expandedString = (PWSTR) HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, (cchSize * sizeof(WCHAR)));
        ErrExitCode((!expandedString), status, ERROR_NOT_ENOUGH_MEMORY);
        
        cchRequiredSize = ExpandEnvironmentStringsW(OriginalString, 
            expandedString, 
            cchSize 
            );
    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough 
        // even on the second try
        //
        HeapFree(heapHandle, 0L, expandedString);
        expandedString = NULL;
    }

EXIT:
    return expandedString;
}


VOID
AsrfmtpInitialiseErrorFile() 
{
    PWSTR szErrorFilePath = NULL;

    //
    // Get full path to the error file.
    //
    szErrorFilePath = AsrfmtpExpandEnvStrings(ASRFMT_ASR_ERROR_FILE_PATH);
    if (!szErrorFilePath) {
        return;
    }

    //
    // Open the error log
    //
    Gbl_hErrorFile = CreateFileW(
        szErrorFilePath,            // lpFileName
        GENERIC_WRITE | GENERIC_READ,       // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                       // lpSecurityAttributes
        OPEN_ALWAYS,                // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,    // dwFlagsAndAttributes
        NULL                        // hTemplateFile
        );
    HeapFree(GetProcessHeap(), 0L, szErrorFilePath);
    szErrorFilePath = NULL;

    if ((!Gbl_hErrorFile) || (INVALID_HANDLE_VALUE == Gbl_hErrorFile)) {
        return;
    }

    //
    // Move to the end of file
    //
    SetFilePointer(Gbl_hErrorFile, 0L, NULL, FILE_END);

}

VOID
AsrfmtpCloseErrorFile() {

    if ((Gbl_hErrorFile) && (INVALID_HANDLE_VALUE != Gbl_hErrorFile)) {
        CloseHandle(Gbl_hErrorFile);
        Gbl_hErrorFile = NULL;
    }
}



VOID
AsrfmtpLogErrorMessage(
    IN _AsrfmtpMessageSeverity Severity,
    IN const LPCTSTR Message
    ) 
{
    SYSTEMTIME currentTime;
    DWORD bytesWritten = 0;
    WCHAR buffer[4196];
    BOOL formatLoaded = FALSE;
    int res = 0;
    CString strFormat;

    if ((!Gbl_hErrorFile) || (INVALID_HANDLE_VALUE == Gbl_hErrorFile)) {
        return;
    }

    //
    // Load the format of the error string to be logged
    //
    if (_SeverityError == Severity) {
        res =  strFormat.LoadString(IDS_LOG_ERROR_FORMAT);
        if (res != 0) {
            formatLoaded = TRUE;
        }
    }
    else if (_SeverityWarning == Severity) {
        res = strFormat.LoadString(IDS_LOG_WARNING_FORMAT);
        if (res != 0) {
            formatLoaded = TRUE;
        }
    }
    else {
        //
        // We should only log error or warning messages to the error file
        //
        return;
    }

    //
    // In case someone else wrote to this file since our last write
    //
    SetFilePointer(Gbl_hErrorFile, 0L, NULL, FILE_END);

    //
    // Create our string, and write it out
    //
    GetLocalTime(&currentTime);
    swprintf(buffer,
        (LPCTSTR) (formatLoaded? strFormat :  L"\r\n[%04hu/%02hu/%02hu %02hu:%02hu:%02hu] %s\r\n"),
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        Message
        );

    WriteFile(Gbl_hErrorFile,
        buffer,
        (wcslen(buffer) * sizeof(WCHAR)),
        &bytesWritten,
        NULL
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\attrib\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

MAJORCOMP=utils
MINORCOMP=attrib

TARGETNAME=attrib
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\attrib.cxx ..\attrib.rc

INCLUDES=..\.;..\..\ulib\inc;

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

UMLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\attrib\attrib.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    attrib.cxx

Abstract:

    This utility allows the user to change file attributes.
    It is functionaly compatible with DOS 5 attrib utility.

Author:

    Jaime F. Sasson

Environment:

    ULIB, User Mode

--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "substrng.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "system.hxx"
#include "arrayit.hxx"
#include "stream.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "attrib.hxx"

PSTREAM Get_Standard_Input_Stream();
PSTREAM Get_Standard_Output_Stream();


extern "C" {
#include <stdio.h>
}

DEFINE_CONSTRUCTOR( ATTRIB, PROGRAM );


BOOLEAN
ATTRIB::Initialize(
    )

/*++

Routine Description:

    Initializes an ATTRIB class.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    PWSTRING DynSubDirectory;
    PWSTRING DynSubFileName;

    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;

    ARRAY               ArgumentArray;

    STRING_ARGUMENT     ProgramNameArgument;
//  STRING_ARGUMENT     FileNameArgument;
    PCWSTRING           FullFileNameString;
    PATH                DirectoryNamePath;
    PCWSTRING           InvalidName;
    PCWSTRING           TempPathString;
    DSTRING             TempPathStringDrive;
    PATH                PathDrive;
    DSTRING             BackSlashString;
    STRING_ARGUMENT     InvalidSwitch;
    STRING_ARGUMENT     InvalidSwitchPlus;
    STRING_ARGUMENT     InvalidSwitchMinus;
    PWSTRING            InvalidArgument;
    DSTRING             InvalidSwitchString;
    BOOLEAN             ActOnDirectory;


    _InitialDirectory = NULL;
    //
    //  Initialize MESSAGE object
    //
    _OutStream = Get_Standard_Output_Stream();
    if (_OutStream == NULL) {
        DebugPrintTrace(("ATTRIB: Output stream is NULL\n"));
        return FALSE;
    }
    _Message.Initialize( _OutStream, Get_Standard_Input_Stream() );

    //
    // Initialize string that contains End-Of-Line characters
    //
    if( !_EndOfLineString.Initialize( (LPWSTR)L"\r\n" ) ) {
        DebugPrint( "_EndOfLineString.Initialize() failed" );
        return( FALSE );
    }


    //
    //  Parse command line
    //
    if ( !LexArray.Initialize( ) ) {
        DebugPrint( "LexArray.Initialize() failed \n" );
        return( FALSE );
    }
    if ( !ArgLex.Initialize( &LexArray ) ) {
        DebugPrint( "ArgLex.Initialize() failed \n" );
        return( FALSE );
    }

    ArgLex.PutSwitches( "/" );
    ArgLex.SetCaseSensitive( FALSE );
    ArgLex.PutStartQuotes( "\"");
    ArgLex.PutEndQuotes( "\"");
    ArgLex.PutSeparators( " \t" );

    if( !ArgLex.PrepareToParse() ) {
        DebugPrint( "ArgLex.PrepareToParse() failed \n" );
        _Message.Set( MSG_ATTRIB_PARAMETER_NOT_CORRECT );
        _Message.Display( " " );
        return( FALSE );
    }

    if ( !ArgumentArray.Initialize() ) {
        DebugPrint( "ArgumentArray.Initialize() failed \n" );
        return( FALSE );
    }
    if( !ProgramNameArgument.Initialize("*") ||
        !_FlagRemoveSystemAttribute.Initialize( "-S" ) ||
        !_FlagAddSystemAttribute.Initialize( "+S" ) ||
        !_FlagRemoveHiddenAttribute.Initialize( "-H" ) ||
        !_FlagAddHiddenAttribute.Initialize( "+H" ) ||
        !_FlagRemoveReadOnlyAttribute.Initialize( "-R" ) ||
        !_FlagAddReadOnlyAttribute.Initialize( "+R" ) ||
        !_FlagRemoveArchiveAttribute.Initialize( "-A" ) ||
        !_FlagAddArchiveAttribute.Initialize( "+A" ) ||
        !_FlagRecurseDirectories.Initialize( "/S" ) ||
        !_FlagActOnDirectories.Initialize( "/D" ) ||
        !_FlagDisplayHelp.Initialize( "/?" ) ||
        !InvalidSwitch.Initialize( "/*" ) ||
        !InvalidSwitchPlus.Initialize( "+*" ) ||
        !InvalidSwitchMinus.Initialize( "-*" ) ||
        !_FileNameArgument.Initialize( "*" ) ) {
        DebugPrint( "Unable to initialize flag or string arguments \n" );
        return( FALSE );
    }
    if( !ArgumentArray.Put( &ProgramNameArgument ) ||
        !ArgumentArray.Put( &_FlagRemoveSystemAttribute ) ||
        !ArgumentArray.Put( &_FlagAddSystemAttribute ) ||
        !ArgumentArray.Put( &_FlagRemoveHiddenAttribute ) ||
        !ArgumentArray.Put( &_FlagAddHiddenAttribute ) ||
        !ArgumentArray.Put( &_FlagRemoveReadOnlyAttribute ) ||
        !ArgumentArray.Put( &_FlagAddReadOnlyAttribute ) ||
        !ArgumentArray.Put( &_FlagRemoveArchiveAttribute ) ||
        !ArgumentArray.Put( &_FlagAddArchiveAttribute ) ||
        !ArgumentArray.Put( &_FlagRecurseDirectories ) ||
        !ArgumentArray.Put( &_FlagActOnDirectories ) ||
        !ArgumentArray.Put( &_FlagDisplayHelp ) ||
        !ArgumentArray.Put( &InvalidSwitch ) ||
        !ArgumentArray.Put( &InvalidSwitchPlus ) ||
        !ArgumentArray.Put( &InvalidSwitchMinus ) ||
        !ArgumentArray.Put( &_FileNameArgument ) ) {
        DebugPrint( "ArgumentArray.Put() failed \n" );
        return( FALSE );
    }
    if( !ArgLex.DoParsing( &ArgumentArray ) ) {
        _Message.Set( MSG_ATTRIB_PARAMETER_NOT_CORRECT );
        _Message.Display( " " );
        return( FALSE );
    }

    //
    // Check the existance of an invalid switch
    //
    if( InvalidSwitch.IsValueSet() ||
        InvalidSwitchPlus.IsValueSet() ||
        InvalidSwitchMinus.IsValueSet() ) {

        if( InvalidSwitch.IsValueSet() ) {
            //
            // The invalid switch starts with '/'
            //
            if( !InvalidSwitchString.Initialize( "/" ) ) {
                DebugPrint( "InvalidSwitchString.Initialize( / ) failed \n" );
                return( FALSE );
            }
            InvalidArgument = InvalidSwitch.GetString();
            DebugPtrAssert( InvalidArgument );
        } else if ( InvalidSwitchPlus.IsValueSet() ) {
            //
            // The invalid switch starts with '+'
            //
            if( !InvalidSwitchString.Initialize( "+" ) ) {
                DebugPrint( "InvalidSwitchString.Initialize( + ) failed \n" );
                return( FALSE );
            }
            InvalidArgument = InvalidSwitchPlus.GetString();
            DebugPtrAssert( InvalidArgument );
        } else {
            //
            // The invalid switch starts with '-'
            //
            if( !InvalidSwitchString.Initialize( "-" ) ) {
                DebugPrint( "InvalidSwitchString.Initialize( - ) failed \n" );
                return( FALSE );
            }
            InvalidArgument = InvalidSwitchMinus.GetString();
            DebugPtrAssert( InvalidArgument );
        }
        //
        // Display the error message followed by the invalid switch
        //
        if( !InvalidSwitchString.Strcat( InvalidArgument ) ) {
            DebugPrint( "InvalidSwitchString.Strcat( InvalidArgument ) failed \n" );
            return( FALSE );
        }
        _Message.Set( MSG_ATTRIB_INVALID_SWITCH );
        _Message.Display( "%W", &InvalidSwitchString );
        return( FALSE );
    }

    if ( _FlagActOnDirectories.QueryFlag() &&
         !_FlagRecurseDirectories.QueryFlag() ) {
        _Message.Set( MSG_ATTRIB_INVALID_COMBINATION );
        _Message.Display();
        return( FALSE );
    }
    //
    // +S -S or +H -H or +R -R or +A -A are not valid
    // combination of arguments
    //
    if( ( _FlagRemoveSystemAttribute.QueryFlag() &&
          _FlagAddSystemAttribute.QueryFlag() ) ||
        ( _FlagRemoveHiddenAttribute.QueryFlag() &&
          _FlagAddHiddenAttribute.QueryFlag() ) ||
        ( _FlagRemoveReadOnlyAttribute.QueryFlag() &&
          _FlagAddReadOnlyAttribute.QueryFlag() ) ||
        ( _FlagRemoveArchiveAttribute.QueryFlag() &&
          _FlagAddArchiveAttribute.QueryFlag() ) ) {

        _Message.Set( MSG_ATTRIB_PARAMETER_NOT_CORRECT );
        _Message.Display( " " );
        return( FALSE );
    }

    if(  _FlagRemoveSystemAttribute.QueryFlag() ||
         _FlagAddSystemAttribute.QueryFlag() ||
         _FlagRemoveHiddenAttribute.QueryFlag() ||
         _FlagAddHiddenAttribute.QueryFlag() ||
         _FlagRemoveReadOnlyAttribute.QueryFlag() ||
         _FlagAddReadOnlyAttribute.QueryFlag() ||
         _FlagRemoveArchiveAttribute.QueryFlag() ||
         _FlagAddArchiveAttribute.QueryFlag() ) {
         _PrintAttribInfo = FALSE;
         _ResetMask = (FSN_ATTRIBUTE)0xffffffff;
         if( _FlagRemoveSystemAttribute.QueryFlag() ) {
            _ResetMask &= ~FSN_ATTRIBUTE_SYSTEM;
         }
         if( _FlagRemoveHiddenAttribute.QueryFlag() ) {
            _ResetMask &= ~FSN_ATTRIBUTE_HIDDEN;
         }
         if( _FlagRemoveReadOnlyAttribute.QueryFlag() ) {
            _ResetMask &= ~FSN_ATTRIBUTE_READONLY;
         }
         if( _FlagRemoveArchiveAttribute.QueryFlag() ) {
            _ResetMask &= ~FSN_ATTRIBUTE_ARCHIVE;
         }

         _MakeMask = 0;
         if( _FlagAddSystemAttribute.QueryFlag() ) {
            _MakeMask |= FSN_ATTRIBUTE_SYSTEM;
         }
         if( _FlagAddHiddenAttribute.QueryFlag() ) {
            _MakeMask |= FSN_ATTRIBUTE_HIDDEN;
         }
         if( _FlagAddReadOnlyAttribute.QueryFlag() ) {
            _MakeMask |= FSN_ATTRIBUTE_READONLY;
         }
         if( _FlagAddArchiveAttribute.QueryFlag() ) {
            _MakeMask |= FSN_ATTRIBUTE_ARCHIVE;
         }
    } else {
        _PrintAttribInfo = TRUE;
    }

    //
    //  Get filename
    //
    if( !_FileNameArgument.IsValueSet() ) {
        //
        // User didn't specify file name. Use *.* as default
        //
        FullFileNameString = NULL;
        if( !_FullFileNamePath.Initialize( (LPWSTR)L"*.*", TRUE ) ) {
            DebugPrint( "_FullFileNamePath.Initialize() failed \n" );
            return( FALSE );
        }
    } else {
        //
        // Get name specified in the command line
        //
        FullFileNameString = _FileNameArgument.GetPath()->GetPathString();
        DebugPtrAssert( FullFileNameString );
        if( !_FullFileNamePath.Initialize( FullFileNameString, TRUE ) ) {
            DebugPrint( "_FullFileNamePath.Initialize() failed \n" );
            return( FALSE );
        }
    }

    //
    // Get prefix and verify that it exists
    //
    if( ( DynSubDirectory = _FullFileNamePath.QueryPrefix() ) == NULL ) {
        DebugPrint( "_FullFileNamePath.QueryPrefix() failed \n" );
        return( FALSE );
    }
    if( !DirectoryNamePath.Initialize( DynSubDirectory ) ) {
        DELETE( DynSubDirectory );
        DebugPrint( "DirectoryNamePath.Initialize() failed \n" );
        return( FALSE );
    }
    DELETE( DynSubDirectory );
    //
    //  Have to test if DirectoryNamePath is a drive, and if it is
    //  add \ to it otherwise it won't be able to find a file that is
    //  in the root directory, if the current directory is not the root.
    //
    if( DirectoryNamePath.IsDrive() ) {
        if( !BackSlashString.Initialize( "\\" ) ) {
            DebugPrint( "BackSlashString.Initialize() failed \n" );
            return( FALSE );
        }
        TempPathString = DirectoryNamePath.GetPathString();
        DebugPtrAssert( TempPathString );
        if( !TempPathStringDrive.Initialize( TempPathString ) ) {
            DebugPrint( "TempPathStringDrive.Initialize() failed \n" );
            return( FALSE );
        }
        TempPathStringDrive.Strcat( &BackSlashString );
        if( !PathDrive.Initialize( &TempPathStringDrive ) ) {
            DebugPrint( "PathDrive.Initialize() failed \n" );
            return( FALSE );
        }
        if( !DirectoryNamePath.Initialize( &PathDrive ) ) {
            DebugPrint( "DirectoryNamePath.Initialize() failed \n" );
            return( FALSE );
        }
    }

    if( ( _InitialDirectory = SYSTEM::QueryDirectory( &DirectoryNamePath ) ) == NULL ) {
        InvalidName = DirectoryNamePath.GetPathString();
        DebugPtrAssert( InvalidName );
        _Message.Set( MSG_ATTRIB_PATH_NOT_FOUND );
        _Message.Display( "%W", InvalidName );
        return( FALSE );
    }

    //
    // Initialize filter for directories
    //
    if( !_FsnFilterDirectory.Initialize() ) {
        DELETE( _InitialDirectory );
        DebugPrint( "_FsnFilterDirectory.Initialize() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterDirectory.SetFileName( "*.*" ) ) {
        DELETE( _InitialDirectory );
        DebugPrint( "_FsnFilterDirectory.SetFilename() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterDirectory.SetAttributes( FSN_ATTRIBUTE_DIRECTORY ) ) {
        DELETE( _InitialDirectory );
        DebugPrint( "_FsnFilterDirectory.SetAttributes() failed \n" );
        return( FALSE );
    }

    //
    // Get file name and initialize filter for files
    //
    if( ( DynSubFileName = _FullFileNamePath.QueryName() ) == NULL ) {
        if( _FileNameArgument.IsValueSet() ) {
            InvalidName = _FileNameArgument.GetPath()->GetPathString();
        } else {
            InvalidName = DirectoryNamePath.GetPathString();
        }
        DebugPtrAssert( InvalidName );

        _Message.Set( MSG_ATTRIB_FILE_NOT_FOUND );
        _Message.Display( "%W", InvalidName );
        DELETE( _InitialDirectory );
        return( FALSE );
    }

    //
    //  Determine whether attrib should act on a directory.
    //  It will do so only if the user specify a directory name that does
    //  not contain the characters '*' or '?'.
    //  Also, attrib will not act on directories if the switch /S is specified.
    //
    if( _FlagRecurseDirectories.QueryFlag() ||
        ( FullFileNameString == NULL ) ||
        ( FullFileNameString->Strchr( ( WCHAR )'*' ) != INVALID_CHNUM ) ||
        ( FullFileNameString->Strchr( ( WCHAR )'?' ) != INVALID_CHNUM ) ) {
        ActOnDirectory = _FlagActOnDirectories.QueryFlag();
    } else {
        ActOnDirectory = TRUE;
    }


    if( !_FsnFilterFile.Initialize() ) {
        DELETE( _InitialDirectory );
        DELETE( DynSubFileName );
        DebugPrint( "FsnFilter.Initialize() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterFile.SetFileName( DynSubFileName ) ) {
        DELETE( _InitialDirectory );
        DELETE( DynSubFileName );
        DebugPrint( "FsnFilter.SetFilename() failed \n" );
        return( FALSE );
    }
    if( !ActOnDirectory ) {
        if( !_FsnFilterFile.SetAttributes( 0, 0, FSN_ATTRIBUTE_DIRECTORY ) ) {
            DELETE( _InitialDirectory );
            DELETE( DynSubFileName );
            DebugPrint( "FsnFilter.SetAttributes() failed \n" );
            return( FALSE );
        }
    } else {
        if( !_FsnFilterFile.SetAttributes( 0, 0, 0 ) ) {
            DELETE( _InitialDirectory );
            DELETE( DynSubFileName );
            DebugPrint( "FsnFilter.SetAttributes() failed \n" );
            return( FALSE );
        }
    }
    DELETE( DynSubFileName );
    if( _FlagDisplayHelp.QueryFlag() ) {
        _Message.Set( MSG_ATTRIB_HELP_MESSAGE );
        _Message.Display( " " );
        return( FALSE );
    }

    _FoundFile = FALSE;
   LexArray.DeleteAllMembers();

   return( TRUE );
}



VOID
ATTRIB::Terminate(
    )

/*++

Routine Description:

    Deletes objects created during initialization.

Arguments:

    None.

Return Value:

    None.


--*/

{
    if( _InitialDirectory != NULL ) {
        DELETE( _InitialDirectory );
    }
}



VOID
ATTRIB::DisplayFileNotFoundMessage(
    )

/*++

Routine Description:

    Displays a message indicating that no file that meets the file filter
    criteria was found.

Arguments:

    None.

Return Value:

    None.


--*/

{
    PCWSTRING   FileName;

    if( !_FoundFile ) {
        if( _FileNameArgument.IsValueSet() ) {
            FileName = _FileNameArgument.GetPath()->GetPathString();
        } else {
            FileName = _FullFileNamePath.GetPathString();
        }
        DebugPtrAssert( FileName );

        _Message.Set( MSG_ATTRIB_FILE_NOT_FOUND );
        _Message.Display( "%W", FileName );
    }
}



VOID
ATTRIB::DisplayFileAttribute (
    IN PCFSNODE Fsn
    )

/*++

Routine Description:

    Displays a filename and its attributes

Arguments:

    Fsn - A pointer to an FSNODE that contains the information
          about the file.

Return Value:

    None.

--*/


{
//  PCWC_STRING pcWcString;
    PCWSTRING   pcWcString;

    WCHAR       Buffer[ 12 ];
    DSTRING     String;

    DebugPtrAssert( Fsn );
    DebugPtrAssert( Fsn->GetPath( ));
    pcWcString = ( Fsn->GetPath( ))->GetPathString( );
    DebugPtrAssert( pcWcString );


    swprintf( Buffer,
              ( LPWSTR )L"%lc  %lc%lc%lc     ",
              Fsn->IsArchived() ? ( WCHAR )'A' : ( WCHAR )' ',
              Fsn->IsSystem()   ? ( WCHAR )'S' : ( WCHAR )' ',
              Fsn->IsHidden()   ? ( WCHAR )'H' : ( WCHAR )' ',
              Fsn->IsReadOnly() ? ( WCHAR )'R' : ( WCHAR )' ' );

    if( !String.Initialize( Buffer ) ||
        !String.Strcat( pcWcString ) ||
        !String.Strcat( &_EndOfLineString ) ||
        !_OutStream->WriteString( &String ) ) {
        DebugPrint( "Unable to display message" );
    }
}


BOOLEAN
ATTRIB::ChangeFileAttributes(
    IN PFSNODE FsnFile
    )

/*++

Routine Description:

    Changes the file attributes. The attributes will be changed depending
    on the argumets specified in the command line, and on the current
    attributes of the file.
    The algorithm for changing attributes is presented below:

    if( ( -s and -h were specified as arguments ) or
        ( -s and +h were specified as arguments ) or
        ( +s and -h were specified as arguments ) or
        ( +s and +h were specified as arguments ) ) {
        Change file attributes;
    } else if ( ( -h and +h were not specified as arguments ) and
                ( file has hidden attribute ) ) {
        print( "Not resetting hidden file: <filename> " );
    } else if ( ( -s and +s were not specified as arguments ) and
                ( file has system attribute ) ) {
        print( "Not resetting system file: <filename> " );
    } else {
        Change file attributes;
    }


Arguments:

    FsnFile - A pointer to an FSNODE that contains the information
              about the file.

Return Value:

    BOOLEAN - Returns FALSE if this function fails due to a failure
              in an API call.


--*/


{
//    BOOLEAN     Result;
    BOOLEAN     Change;
    DWORD       Win32Error;

//  PCWC_STRING pcWcString;
    PCWSTRING   pcWcString;

    FSN_ATTRIBUTE       Attributes;

    DebugPtrAssert( FsnFile->GetPath( ));
    pcWcString = ( FsnFile->GetPath( ))->GetPathString( );
    DebugPtrAssert( pcWcString );

    if( ( ( _FlagAddSystemAttribute.QueryFlag() ||
            _FlagRemoveSystemAttribute.QueryFlag() ) &&
          ( _FlagAddHiddenAttribute.QueryFlag() ||
            _FlagRemoveHiddenAttribute.QueryFlag() ) ) ) {
            Change = TRUE;
    } else if( !_FlagAddHiddenAttribute.QueryFlag() &&
               !_FlagRemoveHiddenAttribute.QueryFlag() &&
               FsnFile->IsHidden() ) {
//        DebugPtrAssert( FsnFile->GetPath( ));
//        pcWcString = ( FsnFile->GetPath( ))->GetPathString( );
//        DebugPtrAssert( pcWcString );
        _Message.Set( MSG_ATTRIB_NOT_RESETTING_HIDDEN_FILE );
        _Message.Display( "%W", pcWcString );
        Change = FALSE;
    } else if( !_FlagAddSystemAttribute.QueryFlag() &&
               !_FlagRemoveSystemAttribute.QueryFlag() &&
               FsnFile->IsSystem() ) {
//        DebugPtrAssert( FsnFile->GetPath( ));
//        pcWcString = ( FsnFile->GetPath( ))->GetPathString( );
//        DebugPtrAssert( pcWcString );
        _Message.Set( MSG_ATTRIB_NOT_RESETTING_SYS_FILE );
        _Message.Display( "%W", pcWcString );
        Change = FALSE;
    } else {
        Change = TRUE;
    }

//    Result = TRUE;
    if( Change ) {
        Attributes = FsnFile->QueryAttributes();
        if( !FsnFile->SetAttributes( ( Attributes & _ResetMask ) | _MakeMask,
                                     &Win32Error ) ) {
            if( Win32Error == ERROR_ACCESS_DENIED ) {
                _Message.Set( MSG_ATTRIB_ACCESS_DENIED );
            } else {
                _Message.Set( MSG_ATTRIB_UNABLE_TO_CHANGE_ATTRIBUTE );
            }
            _Message.Display( "%W", pcWcString );
            DebugPrint( "Unable to change file attribute \n" );
            return( FALSE );
        }
    }
    return( TRUE );
}



BOOLEAN
ATTRIB::ExamineFiles(
    IN  PFSN_DIRECTORY  Directory
    )

/*++

Routine Description:

    Builds an array of files in the specified directory, and
    tries to change the attributes of each of these files.
    Does the same thing in all subdirectories, if the "recurse"
    flag was specified in the command line.

Arguments:

    Directory - Pointer to an FSN_DIRECTORY that describes the
                directory to be examined

Return Value:

    Boolean: TRUE if Successful.

--*/

{
    PARRAY              DirectoryArray;
    PFSN_DIRECTORY      FsnDirectory;
    PARRAY_ITERATOR     DirectoryArrayIterator;
    PARRAY              FileArray;
    PARRAY_ITERATOR     FileArrayIterator;
    PFSNODE             FsnFile;


    DebugPtrAssert( Directory );
    //
    //  If /S was specified as argument in the command line, builds
    //  an array of PFSN_DIRECTORY of all sub-directories in the current
    //  directory and examines the files in each sub-directory
    //
    if( _FlagRecurseDirectories.QueryFlag() ) {
        if( ( DirectoryArray = Directory->QueryFsnodeArray( &_FsnFilterDirectory ) ) == NULL ) {
            DebugPrint( "Directory->QueryFsnodeArray( &_FsnFilterDirectory ) failed \n" );
            return( FALSE );
        }
        if( ( DirectoryArrayIterator =
                ( PARRAY_ITERATOR )( DirectoryArray->QueryIterator() ) ) == NULL ) {
            DebugPrint( "DirectoryArray->QueryIterator() failed \n" );
            return( FALSE );
        }

        while( ( FsnDirectory = ( PFSN_DIRECTORY )( DirectoryArrayIterator->GetNext( ) ) ) != NULL ) {
                ExamineFiles( FsnDirectory );
                DELETE( FsnDirectory );
        }

        DELETE( DirectoryArrayIterator );
        DELETE( DirectoryArray );
    }

    //
    // Builds an array of FSNODEs of the files tha meet the 'filter'
    // criteria, and change or display the attributes of these files
    //
    if( ( FileArray = Directory->QueryFsnodeArray( &_FsnFilterFile ) ) == NULL ) {
        DebugPrint( "Directory->QueryFsnodeArray( &_FsnFilterFile ) failed \n" );
        return( FALSE );
    }
    if( ( FileArrayIterator =
            ( PARRAY_ITERATOR )( FileArray->QueryIterator() ) ) == NULL ) {
        DebugPrint( "FileArray->QueryIterator() failed \n" );
        return( FALSE );
    }

    while( ( FsnFile = ( PFSNODE )( FileArrayIterator->GetNext( ) ) ) != NULL ) {
        if( _PrintAttribInfo ) {
            DisplayFileAttribute( FsnFile );
        } else {
            ChangeFileAttributes( FsnFile );
        }

        _FoundFile = TRUE;

        DELETE( FsnFile );
    }
    DELETE( FileArrayIterator );
    DELETE( FileArray );
    return( TRUE );
}



ULONG __cdecl
main()

{
    DEFINE_CLASS_DESCRIPTOR( ATTRIB );

    {
        ATTRIB  Attrib;

        if( Attrib.Initialize() ) {
            Attrib.ExamineFiles( Attrib.GetInitialDirectory() );
            Attrib.DisplayFileNotFoundMessage();
        }
        Attrib.Terminate();
    }
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\autochk\sources.inc ===
!IF 0

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

NT_UP=0

MAJORCOMP=utils
MINORCOMP=autochk

TARGETNAME=autochk
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    ..\autochk.cxx \
    ..\autochk.rc

INCLUDES=\
    $(PROJECT_ROOT)\fs\utils\ntlib\src;\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT);\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    $(PROJECT_ROOT)\fs\utils\untfs\inc

C_DEFINES=-DCONDITION_HANDLING=1 -D_AUTOCHECK_ -DUNICODE=1

!IF defined(CHKDSK_PRE_RELEASE_NOTICE)
C_DEFINES=$(C_DEFINES) /DPRE_RELEASE_NOTICE
!ENDIF

TARGETLIBS=\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O)\ntlib.lib   \
    $(PROJECT_LIB_PATH)\patchbc.lib

UMTYPE=nt
USE_NTDLL=1
W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\autochk\autochk.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    autochk.cxx

Abstract:

    This is the main program for the autocheck version of chkdsk.

Author:

    Norbert P. Kusters (norbertk) 31-May-91

--*/

#include "ulib.hxx"
#include "wstring.hxx"
#include "fatvol.hxx"
#include "untfs.hxx"
#include "ntfsvol.hxx"
#include "spackmsg.hxx"
#include "tmackmsg.hxx"
#include "error.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#include "rcache.hxx"
#include "autoreg.hxx"
#include "ifsserv.hxx"
#include "mpmap.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif

#define CONTROL_NAME        \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control"
#define VALUE_NAME          L"SystemStartOptions"
#define VALUE_BUFFER_SIZE   \
    (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256 * sizeof(WCHAR))

BOOLEAN
RegistrySosOption(
    );

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeUntfs(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

USHORT
InvokeAutoChk (
    IN     PWSTRING         DriveLetter,
    IN     PWSTRING         VolumeName,
    IN     ULONG            ChkdskFlags,
    IN     BOOLEAN          RemoveRegistry,
    IN     BOOLEAN          SetupMode,
    IN     BOOLEAN          Extend,
    IN     ULONG            LogfileSize,
    IN     USHORT           Algorithm,
    IN     INT              ArgCount,
    IN     CHAR             **ArgArray,
    IN     PARRAY           SkipList,
    IN OUT PMESSAGE         Msg,
       OUT PULONG           ExitStatus
    );

BOOLEAN
ExtendNtfsVolume(
    PCWSTRING   DriveName,
    PMESSAGE    Message
    );

BOOLEAN
DeregisterAutochk(
    int     argc,
    char**  argv
    );

BOOLEAN
QueryAllHardDrives(
    PMOUNT_POINT_MAP    MountPointMap
    );

BOOLEAN
IsGuidVolName (
    PWSTRING    VolName
    );


int __cdecl
main(
    int     argc,
    char**  argv,
    char**  envp,
    ULONG   DebugParameter
    )
/*++

Routine Description:

    This routine is the main program for autocheck FAT chkdsk.

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                    the drive to check.

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    if (!InitializeUlib( NULL, ! DLL_PROCESS_DETACH, NULL ) ||
        !InitializeIfsUtil(NULL,0,NULL) ||
        !InitializeUfat(NULL,0,NULL) ||
        !InitializeUntfs(NULL,0,NULL)) {
        return 1;
    }

#if defined(FE_SB) && defined(_X86_)
    InitializeMachineId();
#endif

    //
    // The declarations must come after these initialization functions.
    //
    DSTRING             dos_drive_name;
    DSTRING             volume_name;
    DSTRING             drive_letter;

    ARRAY               skip_list;

    AUTOCHECK_MESSAGE   *msg = NULL;

    BOOLEAN             onlyifdirty = TRUE;
    BOOLEAN             recover = FALSE;
    BOOLEAN             extend = FALSE;
    BOOLEAN             remove_registry = FALSE;

    ULONG               ArgOffset = 1;

    BOOLEAN             SetupOutput = FALSE;
    BOOLEAN             SetupTextMode = FALSE;
    BOOLEAN             SetupSpecialFixLevel = FALSE;

    ULONG               exit_status = 0;

    BOOLEAN             SuppressOutput = TRUE;      // dots only by default

    BOOLEAN             all_drives = FALSE;
    BOOLEAN             resize_logfile = FALSE;
    BOOLEAN             skip_index_scan = FALSE;
    BOOLEAN             skip_cycle_scan = FALSE;
    LONG                logfile_size = 0;
    LONG                algorithm = 0;
    BOOLEAN             algorithm_specified = FALSE;

    MOUNT_POINT_MAP     mount_point_map;
    ULONG               i;
    USHORT              rtncode;
    ULONG               chkdsk_flags;

    DSTRING             nt_name_prefix;
    DSTRING             dos_guidname_prefix;

    if (!drive_letter.Initialize() ||
        !volume_name.Initialize() ||
        !nt_name_prefix.Initialize(NT_NAME_PREFIX) ||
        !dos_guidname_prefix.Initialize(DOS_GUIDNAME_PREFIX) ||
        !skip_list.Initialize()) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Out of memory.\n"));
        return 1;
    }

    // Parse the arguments--the accepted arguments are:
    //
    //      autochk [/s] [/dx:] [/p] [/r] [/m] [/i[:chunks]] [/c] nt-drive-name
    //      autochk      [/dx:] [/p] [/r] [/m] [/i[:chunks]] [/c] [/l:size] nt-drive-name
    //      autochk [/s] /x dos-drive-name (obsolete in NT 5.0)
    //      autochk [/k:drives] [/k:volname] ... *
    //
    //      /t - setup text mode: selectively output messages thru Ioctl
    //      /s - setup: no output
    //      /d - the drive letter is x: (obsolete)
    //      /p - check even if not dirty
    //      /r - recover; implies /p
    //      /l - resize log file to <size> kilobytes.  May not be combined with
    //              /s because /s explicitly inhibits logfile resizing.
    //      /x - extend volume; obsolete in NT 5.0
    //      /k - a list of drive letters or a guid volume name to skip
    //      /m - remove registry entry after running
    //      /e - turn on the volume upgrade bit; obsolete in NT 5.0
    //      /i - include index entries checking; implies /p
    //      /c - include checking of cycles within the directory tree; implies /p
    //      /i:chunks
    //         - does the index scan in <chunks> chunks; implies /p
    //

    //*****
    // Delete the following if when building a normal CONSOLE version for test
    //
    if (argc < 2) {
        // Not enough arguments.
        return 1;
    }

    for (ArgOffset = 1; ArgOffset < (ULONG)argc; ++ArgOffset) {

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 't' || argv[ArgOffset][1] == 'T') &&
            (argv[ArgOffset][2] == 0) ) {
            //
            // Then we're in silent mode plus I/O to setup
            //
            SetupTextMode = TRUE;
            continue;
        }

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 's' || argv[ArgOffset][1] == 'S') &&
            (argv[ArgOffset][2] == 0) ) {
            //
            // Then we're in silent mode
            //
            SetupOutput = TRUE;
            continue;
        }

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'p' || argv[ArgOffset][1] == 'P') &&
            (argv[ArgOffset][2] == 0) ) {

            // argv[ArgOffset] is the /p parameter, so argv[ArgOffset+1]
            // must be the drive.

            onlyifdirty = FALSE;

            continue;
        }
        if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'r' || argv[ArgOffset][1] == 'R') &&
            (argv[ArgOffset][2] == 0) ) {

            // Note that /r implies /p.
            //
            recover = TRUE;
            onlyifdirty = FALSE;
            continue;

        }
        if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'x' || argv[ArgOffset][1] == 'X') &&
            (argv[ArgOffset][2] == 0) ) {

           // when the /x parameter is specified, we accept a
           // DOS name and do a complete check.
           //
           onlyifdirty = FALSE;
           extend = TRUE;

           if( !dos_drive_name.Initialize( argv[ArgOffset + 1] ) ||
               !IFS_SYSTEM::DosDriveNameToNtDriveName( &dos_drive_name,
                                                       &volume_name ) ) {

               return 1;
           }

           ArgOffset++;
           continue;

        }
#if 0
        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'd' || argv[ArgOffset][1] == 'D')) {

            //
            // A parameter of the form "/dX:" indicates that we are checking
            // the volume whose drive letter is X:.
            //

            if (!drive_letter.Initialize(&argv[ArgOffset][2])) {
                return 1;
            }

            continue;

        }
#endif
        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'l' || argv[ArgOffset][1] == 'L')) {

            DSTRING number;

            // The /l parameter indicates that we're to resize the log file.
            // The size should always be specified, and it is in kilobytes.
            //

            resize_logfile = TRUE;

            if (!number.Initialize(&argv[ArgOffset][3]) ||
                !number.QueryNumber(&logfile_size) ||
                logfile_size < 0) {
                return 1;
            }

            logfile_size *= 1024;

            continue;

        }
        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'k' || argv[ArgOffset][1] == 'K')) {

            // Skip.

            PWSTRING    s;
            DSTRING     drive;
            DSTRING     colon;


            if (!drive.Initialize(&argv[ArgOffset][3]) ||
                !colon.Initialize(L":")) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Out of memory\n"));
                return 1;
            }

            if (drive.Stricmp(&dos_guidname_prefix,
                              0,
                              dos_guidname_prefix.QueryChCount()) == 0) {

                // just a dos guid volume name, so store it

                s = drive.QueryString();

                if (!s ||
                    !skip_list.Put(s)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory\n"));

                    return 1;
                }
#if 0
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_INFO_LEVEL,
                           "AUTOCHK: guid name /k:%S\n",
                           s->GetWSTR()));
#endif
                continue;
            }

            // handle a list of dos drive names by inserting them
            // individually into the skip list

            while (drive.QueryChCount() != 0) {

                s = drive.QueryString(0, 1);

                if (!s ||
                    !s->Strcat(&colon) ||
                    !skip_list.Put(s)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory\n"));

                    return 1;
                }
#if 0
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_INFO_LEVEL,
                           "AUTOCHK: drive letter /k:%S\n",
                           s->GetWSTR()));
#endif
                drive.DeleteChAt(0);
            }
            continue;
        }
        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'm' || argv[ArgOffset][1] == 'M')) {

            remove_registry = TRUE;
            continue;
        }

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'i' || argv[ArgOffset][1] == 'I')) {

            DSTRING     number;

            if (argv[ArgOffset][2] == ':') {
                if (skip_index_scan || algorithm_specified ||
                    !number.Initialize(&argv[ArgOffset][3]) ||
                    !number.QueryNumber(&algorithm) ||
                    algorithm < 0 || algorithm > CHKDSK_MAX_ALGORITHM_VALUE) {
                    return 1;
                }
                algorithm_specified = TRUE;
                onlyifdirty = FALSE;
            } else if (algorithm_specified) {
                return 1;
            } else {
                skip_index_scan = TRUE;
                onlyifdirty = FALSE;
            }

            continue;
        }

        if ((argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'c' || argv[ArgOffset][1] == 'C')) {

            skip_cycle_scan = TRUE;
            onlyifdirty = FALSE;
            continue;
        }

        if ((argv[ArgOffset][0] != '/' && argv[ArgOffset][0] != '-')) {

            //  We've run off the options into the arguments.

            break;
        }
    }

    // argv[ArgOffset] is the drive;

    if (NULL != argv[ArgOffset]) {
        if ('*' == argv[ArgOffset][0]) {

            all_drives = TRUE;

        } else {

            all_drives = FALSE;

            //*****
            //
            // Substitute the following 3 lines for the next line to enable going
            //    AUTOCHK C: like for CHKDSK (when building a normal CONSOLE version for test)
            //
            // if ( !dos_drive_name.Initialize( argv[ArgOffset] ) ||
            //      !IFS_SYSTEM::DosDriveNameToNtDriveName( &dos_drive_name,
            //                                              &volume_name ) ) {
            //******
            if (!volume_name.Initialize(argv[ArgOffset])) {
            //******
                return 1;
            }
        }
    }

    //
    // Determine whether to suppress output or not.  If compiled with
    // DBG==1, print normal output.  Otherwise look in the registry to
    // see if the machine has "SOS" in the NTLOADOPTIONS.
    //
#if defined(_AUTOCHECK_DBG_)

    SuppressOutput = FALSE;

#else /* _AUTOCHECK_DBG */

    if (RegistrySosOption()) {
        SuppressOutput = FALSE;
    }

#endif /* _AUTOCHECK_DBG_ */

    //
    // If this is autochk /r, /l, /i, /c, we've been started from an explicit
    // registry entry and the dirty bit may not be set.  We want to
    // deliver interesting output regardless.
    //

    if (recover || resize_logfile || algorithm_specified ||
        skip_index_scan || skip_cycle_scan) {
        SuppressOutput = FALSE;
    }

    if (extend) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Option /x is no longer supported.\n"));
        return 1;
    }

    if (all_drives && (extend || SetupTextMode || SetupOutput)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Conflicting options that * and [xst] cannot be used at the same time.\n"));
        return 1;
    }

    if (SetupTextMode) {
        msg = NEW TM_AUTOCHECK_MESSAGE;
    } else if (SetupOutput) {
        msg = NEW SP_AUTOCHECK_MESSAGE;
    } else {
        msg = NEW AUTOCHECK_MESSAGE;
    }

    if (NULL == msg || !msg->Initialize(SuppressOutput)) {
        return 1;
    }

#if defined(PRE_RELEASE_NOTICE)
    msg->Set(MSG_CHK_PRE_RELEASE_NOTICE);
    msg->Display();
#endif

#if defined(_AUTOCHECK_DBG_)
    for(ArgOffset=1; ArgOffset < (ULONG)argc; ArgOffset++) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Argument: %s\n",
                   argv[ArgOffset]));
    }

    if (all_drives)
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: All drives\n"));
    else
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Not all drives\n"));
#endif

    if (!QueryAllHardDrives(&mount_point_map)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Unable to query all hard drives\n"));

        return 1;
    }

    if (skip_list.QueryMemberCount() > 0) {

        // convert all drive names to nt guid volume names

        DSTRING         drive_name;
        PWSTRING        drive;
        PARRAY_ITERATOR iter;

#if 0
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Skip list has %d elements.\n",
                   skip_list.QueryMemberCount()));
#endif
        iter = (PARRAY_ITERATOR)skip_list.QueryIterator();

        if (iter == NULL)
            return 1;

        while (drive = (PWSTRING)iter->GetNext()) {
#if 0
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_INFO_LEVEL,
                       "AUTOCHK: Skip list input: %S.\n",
                       drive->GetWSTR()));
#endif
            if (drive->QueryChCount() == 2) {
                if (!mount_point_map.QueryVolumeName(drive, &drive_name)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "AUTOCHK: Drive %S not recognized.\n",
                               drive->GetWSTR()));

                    continue;
                }
            } else {
                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(drive, &drive_name)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "AUTOCHK: Drive %S not recognized.\n",
                               drive->GetWSTR()));

                    continue;
                }
            }
#if 0
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_INFO_LEVEL,
                       "AUTOCHK: Skip list: %S.\n",
                       drive_name.GetWSTR()));
#endif
            if (!drive->Initialize(&drive_name)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Out of memory.\n"));

                DELETE(iter);
                return 1;
            }
        }
        DELETE(iter);
    }

    if (!all_drives &&
        drive_letter.QueryChCount() == 0) {

        // if drive letter is not specified

        if (volume_name.QueryChCount() == (nt_name_prefix.QueryChCount()+2) &&
            volume_name.Strcmp(&nt_name_prefix,
                               0,
                               nt_name_prefix.QueryChCount()) == 0) {

            // looks like \??\<drive letter>: format
            // so, exact drive letter from volume_name

            if (!IFS_SYSTEM::NtDriveNameToDosDriveName(&volume_name, &drive_letter)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Out of memory.\n"));
                return 1;
            }
            DebugAssert(drive_letter.QueryChCount() == 2  &&
                        drive_letter.QueryChAt(1) == (WCHAR)':');
            if (!mount_point_map.QueryVolumeName(&drive_letter, &volume_name)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: Drive %S not found.\n",
                           drive_letter.GetWSTR()));

                return 1;
            }
        } else if (IsGuidVolName(&volume_name)) {

            // looks like a guid volume name
            // so look it up from the mount point map

            if (!mount_point_map.QueryDriveName(&volume_name, &drive_letter)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: Drive %S not found.\n",
                           volume_name.GetWSTR()));

                return 1;
            }
            // drive_letter may still be empty
            // treat it as if there is no drive letter
            // during the "autocheck autochk *" case
        } else {
            // the volume name does not fit into any format
            // make drive letter the same as volume name
            if (!drive_letter.Initialize(&volume_name))
                return 1;
        }
    }

    // at this point, volume_name should contain an nt guid volume name

    chkdsk_flags = (onlyifdirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    chkdsk_flags |= ((recover || extend) ? CHKDSK_RECOVER_FREE_SPACE : 0);
    chkdsk_flags |= (recover ? CHKDSK_RECOVER_ALLOC_SPACE : 0);
    chkdsk_flags |= (resize_logfile ? CHKDSK_RESIZE_LOGFILE : 0);
    chkdsk_flags |= (skip_index_scan ? CHKDSK_SKIP_INDEX_SCAN : 0);
    chkdsk_flags |= (skip_cycle_scan ? CHKDSK_SKIP_CYCLE_SCAN : 0);
    chkdsk_flags |= (algorithm_specified ? CHKDSK_ALGORITHM_SPECIFIED : 0);

    for (i = 0;;) {

        if (all_drives && !mount_point_map.GetAt(i++, &drive_letter, &volume_name))
            break;

        __try {
            rtncode = InvokeAutoChk(&drive_letter,
                                    &volume_name,
                                    chkdsk_flags,
                                    remove_registry,
                                    SetupOutput || SetupTextMode,
                                    extend,
                                    logfile_size,
                                    (USHORT)algorithm,
                                    argc,
                                    argv,
                                    &skip_list,
                                    msg,
                                    &exit_status);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rtncode = 2;
            exit_status = CHKDSK_EXIT_COULD_NOT_FIX;
        }

        if (all_drives) {
            if (rtncode == 1) {
                // serious error return immediately
                return 1;
            } else if (rtncode == 2 || rtncode == 0) {
                // volume specific error or no error
                // re-initialize and continue
                if (!msg->Initialize(SuppressOutput))
                    return 1;
                continue;
            } else {
                // illegal return code
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: Illegal return code %d\n",
                           (ULONG)rtncode));

                return 1;
            }
        } else {
            if (SetupOutput || SetupTextMode) {
                SetupSpecialFixLevel = TRUE;
            }
            if (rtncode == 1) {
                // serious error return immediately
                return SetupSpecialFixLevel ? CHKDSK_EXIT_COULD_NOT_FIX : 1;
            } else if (rtncode == 2 || rtncode == 0) {
                // volume specific error or no error
                // leave anyway
                break;
            } else {
                // illegal return code
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: Illegal return code %d\n",
                           (ULONG)rtncode));

                return SetupSpecialFixLevel ? CHKDSK_EXIT_COULD_NOT_FIX : 1;
            }
        }
    }

    msg->Set(MSG_CHK_AUTOCHK_COMPLETE);
    msg->Display();

    DELETE(msg);

    // If the /x switch was supplied, remove the
    // forcing entry from the registry, since Chkdsk
    // has completed successfully.
    //

    if (extend) {
        DeregisterAutochk( argc, argv );
    }

    if (SetupSpecialFixLevel) {
#if defined(_AUTOCHECK_DBG_)
        if (exit_status != CHKDSK_EXIT_SUCCESS) {
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_INFO_LEVEL,
                       "AUTOCHK: Exit Status %d\n",
                       exit_status));
        }
#endif
        return exit_status;
    } else {
        return 0;
    }
}

USHORT
InvokeAutoChk (
    IN     PWSTRING         DriveLetter,
    IN     PWSTRING         VolumeName,
    IN     ULONG            ChkdskFlags,
    IN     BOOLEAN          RemoveRegistry,
    IN     BOOLEAN          SetupMode,
    IN     BOOLEAN          Extend,
    IN     ULONG            LogfileSize,
    IN     USHORT           Algorithm,
    IN     INT              ArgCount,
    IN     CHAR             **ArgArray,
    IN     PARRAY           SkipList,
    IN OUT PMESSAGE         Msg,
       OUT PULONG           ExitStatus
    )
/*++

Routine Description:

    This is the core of autochk.  It checks the specified drive.

Arguments:

    DriveLetter     - Supplies the drive letter of the drive
                      (can be empty string)
    VolumeName      - Supplies the guid volume name of the drive
    ChkdskFlags     - Supplies the chkdsk control flags
    RemoveRegistry  - Supplies TRUE if registry entry is to be removed
    SetupMode       - Supplies TRUE if invoked through setup
    Extend          - Supplies TRUE if extending the volume (obsolete)
    LogfileSize     - Supplies the size of the logfile
    Algorithm       - Supplies the algorithm to use
    ArgCount        - Supplies the number of arguments given to autochk.
    ArgArray        - Supplies the arguments given to autochk.
    SkipList        - Supplies the list of drives to skip checking
    Msg             - Supplies the outlet of messages
    ExitStatus      - Retrieves the exit status of chkdsk

Return Value:

    0   - Success
    1   - Fatal error
    2   - Volume specific error

--*/
{
    DSTRING             fsname;
    DSTRING             fsNameAndVersion;

    PFAT_VOL            fatvol = NULL;
    PNTFS_VOL           ntfsvol = NULL;
    PVOL_LIODPDRV       vol = NULL;

    BOOLEAN             SetupSpecialFixLevel = FALSE;

    PREAD_CACHE         read_cache;

    DSTRING             boot_execute_log_file_name;
    FSTRING             boot_ex_temp;
    HMEM                logged_message_mem;
    ULONG               packed_log_length;

    DSTRING             fatname;
    DSTRING             fat32name;
    DSTRING             ntfsname;
    DSTRING             nt_name_prefix;
    DSTRING             dos_guidname_prefix;

    BOOLEAN             isDirty;
    BOOLEAN             skip_autochk = FALSE;

    *ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

    if (!fatname.Initialize("FAT") ||
        !fat32name.Initialize("FAT32") ||
        !ntfsname.Initialize("NTFS") ||
        !nt_name_prefix.Initialize(NT_NAME_PREFIX) ||
        !dos_guidname_prefix.Initialize(DOS_GUIDNAME_PREFIX)) {
        return 1;
    }

    if (VolumeName->QueryChCount() == 0) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Volume name is missing.\n"));

        return 2;   // continue if all_drives are enabled
    }

    if (DriveLetter->QueryChCount() == 0) {
        // unable to map VolumeName to a drive letter so do the default
        if (!IFS_SYSTEM::NtDriveNameToDosDriveName(VolumeName, DriveLetter)) {
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_WARNING_LEVEL,
                       "Out of memory.\n"));

            return 1;
        }
    }

    // at this point DriveLetter and VolumeName should be well defined

#if 0
    Msg->Set(MSG_CHK_NTFS_MESSAGE);
    Msg->Display("%s%W", "Drive Name: ", VolumeName);
    Msg->Display("%s%W", "Drive Letter: ", DriveLetter);
#endif

    if (SkipList->QueryMemberCount() > 0) {

        PARRAY_ITERATOR iter = (PARRAY_ITERATOR)SkipList->QueryIterator();
        PWSTRING        skip_item;

        if (iter == NULL)
            return 1;

        // skip drives that should not be checked

        while (skip_item = (PWSTRING)iter->GetNext()) {
            if (skip_item->Stricmp(VolumeName) == 0) {
                DELETE(iter);
#if 0
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_INFO_LEVEL,
                           "AUTOCHK: Skipping: %S.\n",
                           VolumeName->GetWSTR()));
#endif
                return 0;
            }
        }
        DELETE(iter);
    }

    if ((ChkdskFlags & CHKDSK_CHECK_IF_DIRTY) &&
        !(ChkdskFlags & CHKDSK_RESIZE_LOGFILE) &&
        IFS_SYSTEM::IsVolumeDirty(VolumeName,&isDirty) &&
        !isDirty) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Skipping %S because it's not dirty.\n",
                   VolumeName->GetWSTR()));
        *ExitStatus = CHKDSK_EXIT_SUCCESS;
        skip_autochk = TRUE;
    }

    if (!skip_autochk) {
        if (!IFS_SYSTEM::QueryFileSystemName(VolumeName, &fsname,
                                             NULL, &fsNameAndVersion)) {
            Msg->Set( MSG_FS_NOT_DETERMINED );
            Msg->Display( "%W", VolumeName );

            return 2;
        }
    }

    Msg->SetLoggingEnabled();

    Msg->Set(MSG_CHK_RUNNING);
    Msg->Display("%W", DriveLetter);

    if (!skip_autochk) {
        Msg->Set(MSG_FILE_SYSTEM_TYPE);
        Msg->Display("%W", &fsname);


        if (fsname == fatname || fsname == fat32name) {

            if (!(fatvol = NEW FAT_VOL)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Out of memory.\n"));

                return 1;
            }

            if (NoError != fatvol->Initialize(Msg,
                                              VolumeName,
                                              (BOOLEAN)(ChkdskFlags & CHKDSK_CHECK_IF_DIRTY))) {
                DELETE(fatvol);
                return 2;
            }

            if ((read_cache = NEW READ_CACHE) &&
                read_cache->Initialize(fatvol, 75)) {
                fatvol->SetCache(read_cache);
            } else {
                DELETE(read_cache);
            }

            vol = fatvol;

        } else if (fsname == ntfsname) {

            if( Extend ) {

                // NOTE: this roundabout method is necessary to
                // convince NTFS to allow us to access the new
                // sectors on the volume.
                //
                if( !ExtendNtfsVolume( VolumeName, Msg ) ) {
                    return 1;
                }

                if (!(ntfsvol = NEW NTFS_VOL)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory.\n"));

                    return 1;
                }

                if (NoError != ntfsvol->Initialize( VolumeName, Msg ))
                    return 1;

                if (!ntfsvol->Lock()) {
                    Msg->Set( MSG_CANT_LOCK_THE_DRIVE );
                    Msg->Display( "" );
                }

            } else {

                if (!(ntfsvol = NEW NTFS_VOL)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory.\n"));

                    return 1;
                }

                if (NoError != ntfsvol->Initialize(VolumeName, Msg, TRUE)) {
                    DELETE(ntfsvol);
                    return 2;
                }

                if (SetupMode) {

                    //
                    // SetupSpecialFixLevel will be used for NTFS... it means
                    // to refrain from resizing the log file.
                    //

                    SetupSpecialFixLevel = TRUE;
                }
            }

            // The read cache for NTFS CHKDSK gets set in VerifyAndFix.

            vol = ntfsvol;

        } else {
            Msg->Set( MSG_FS_NOT_SUPPORTED );
            Msg->Display( "%s%W", "AUTOCHK", &fsname );
            return 2;
        }
    } else {
        Msg->SetLoggingEnabled(FALSE);  // no need to log anything if volume is clean
        Msg->DisplayMsg(MSG_CHK_VOLUME_CLEAN);
    }

    // If the /r, /l, /m, /i, /p, or /c switch is specified, remove the forcing
    // entry from the registry before calling Chkdsk, since
    // Chkdsk may reboot the system if we are checking the
    // boot partition.
    //

    if ((ChkdskFlags & (CHKDSK_RECOVER_ALLOC_SPACE |
                        CHKDSK_RESIZE_LOGFILE |
                        CHKDSK_ALGORITHM_SPECIFIED |
                        CHKDSK_SKIP_INDEX_SCAN |
                        CHKDSK_SKIP_CYCLE_SCAN)) ||
        !(ChkdskFlags & CHKDSK_CHECK_IF_DIRTY) ||
        RemoveRegistry) {

        DeregisterAutochk( ArgCount, ArgArray );
    }

    // Invoke chkdsk.  Note that if the /r parameter is supplied,
    // we recover both free and allocated space, but if the /x
    // parameter is supplied, we only recover free space.
    //

    if (!skip_autochk &&
        !vol->ChkDsk(SetupSpecialFixLevel ? SetupSpecial : TotalFix,
                     Msg,
                     ChkdskFlags,
                     LogfileSize,
                     Algorithm,
                     ExitStatus,
                     DriveLetter)) {

        DELETE(vol);

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: ChkDsk failure\n"));

        return 2;
    }

    DELETE(vol);


    // Dump the message retained by the message object into a file.
    //

    if( (!Msg->IsInSetup() ||
         (*ExitStatus == CHKDSK_EXIT_ERRS_FIXED ||
          *ExitStatus == CHKDSK_EXIT_COULD_NOT_FIX))         &&
        Msg->IsLoggingEnabled()                              &&
        boot_execute_log_file_name.Initialize( VolumeName )  &&
        boot_ex_temp.Initialize( L"\\BOOTEX.LOG" )           &&
        boot_execute_log_file_name.Strcat( &boot_ex_temp )   &&
        logged_message_mem.Initialize()                      &&
        Msg->QueryPackedLog( &logged_message_mem, &packed_log_length ) ) {

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: Dumping messages to bootex.log\n"));

        if (!IFS_SYSTEM::WriteToFile( &boot_execute_log_file_name,
                                      logged_message_mem.GetBuf(),
                                      packed_log_length,
                                      TRUE )) {
            Msg->Set(MSG_CHK_OUTPUT_LOG_ERROR);
            Msg->Display();
            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_WARNING_LEVEL,
                       "AUTOCHK: Error writing messages to BOOTEX.LOG\n"));
        }

    }

    return 0;
}


BOOLEAN
RegistrySosOption(
    )
/*++

Routine Description:

    This function examines the registry to determine whether the
    user's NTLOADOPTIONS boot environment variable contains the string
    "SOS" or not.

    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control:SystemStartOptions

Arguments:

    None.

Return Value:

    TRUE if "SOS" was set.  Otherwise FALSE.

--*/
{
    NTSTATUS st;
    UNICODE_STRING uKeyName, uValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey;
    WCHAR ValueBuf[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
        (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuf;
    ULONG ValueLength;

    RtlInitUnicodeString(&uKeyName, CONTROL_NAME);
    InitializeObjectAttributes(&ObjectAttributes, &uKeyName,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    st = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(st)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: can't open control key: 0x%x\n",
                   st));

        return FALSE;
    }

    RtlInitUnicodeString(&uValueName, VALUE_NAME);

    st = NtQueryValueKey(hKey, &uValueName, KeyValuePartialInformation,
        (PVOID)pKeyValueInfo, VALUE_BUFFER_SIZE, &ValueLength);

    DebugAssert(ValueLength < VALUE_BUFFER_SIZE);

    NtClose(hKey);

    if (!NT_SUCCESS(st)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: can't query value key: 0x%x\n",
                   st));

        return FALSE;
    }

    // uValue.Buffer = (PVOID)&pKeyValueInfo->Data;
    // uValue.Length = uValue.MaximumLength = (USHORT)pKeyValueInfo->DataLength;

    if (NULL != wcsstr((PWCHAR)&pKeyValueInfo->Data, L"SOS") ||
        NULL != wcsstr((PWCHAR)&pKeyValueInfo->Data, L"sos")) {
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
ExtendNtfsVolume(
    PCWSTRING   DriveName,
    PMESSAGE    Message
    )
/*++

Routine Description:

    This function changes the count of sectors in sector
    zero to agree with the drive object.  This is useful
    when extending volume sets.  Note that it requires that
    we be able to lock the volume, and that it should only
    be called if we know that the drive in question in an
    NTFS volume.  This function also copies the boot sector
    to the end of the partition, where it's kept as a backup.

Arguments:

    DriveName   --  Supplies the name of the volume.
    Message     --  Supplies an output channel for messages.

Return Value:

    TRUE upon completion.

--*/
{
    LOG_IO_DP_DRIVE Drive;
    SECRUN          Secrun;
    HMEM            Mem;

    PPACKED_BOOT_SECTOR BootSector;

    if( !Drive.Initialize( DriveName, Message ) ||
        !Drive.Lock() ||
        !Mem.Initialize() ||
        !Secrun.Initialize( &Mem, &Drive, 0, 1 ) ||
        !Secrun.Read() ) {

        return FALSE;
    }

    BootSector = (PPACKED_BOOT_SECTOR)Secrun.GetBuf();

    //
    // We leave an extra sector at the end of the volume to contain
    // the new replica boot sector.
    //

    BootSector->NumberSectors.LowPart = Drive.QuerySectors().GetLowPart() - 1;
    BootSector->NumberSectors.HighPart = Drive.QuerySectors().GetHighPart();

    if (!Secrun.Write()) {

        return FALSE;
    }

    Secrun.Relocate( Drive.QuerySectors() - 2 );

    if (!Secrun.Write()) {

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Error: %x\n",
                   Drive.QueryLastNtStatus()));

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
DeregisterAutochk(
    int     argc,
    char**  argv
    )
/*++

Routine Description:

    This function removes the registry entry which triggered
    autochk.

Arguments:

    argc    --  Supplies the number of arguments given to autochk.
    argv    --  supplies the arguments given to autochk.

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CommandLineString,
            CurrentArgString,
            OneSpace;
    int     i;

    // Reconstruct the command line and remove it from
    // the registry.  First, reconstruct the primary
    // string, which is "autochk arg1 arg2...".
    //
    if( !CommandLineString.Initialize( "autocheck autochk" ) ||
        !OneSpace.Initialize( " " ) ) {

        return FALSE;
    }

    for( i = 1; i < argc; i++ ) {

        if( !CurrentArgString.Initialize(argv[i] ) ||
            !CommandLineString.Strcat( &OneSpace ) ||
            !CommandLineString.Strcat( &CurrentArgString ) ) {

            return FALSE;
        }
    }

    return( AUTOREG::DeleteEntry( &CommandLineString ) );
}


BOOLEAN
QueryAllHardDrives(
    PMOUNT_POINT_MAP    MountPointMap
    )
{
    static BOOLEAN      first_time = TRUE;
    static HANDLE       dos_devices_object_dir;
    static ULONG        context = 0;

    WCHAR               link_target_buffer[MAXIMUM_FILENAME_LENGTH];
    POBJECT_DIRECTORY_INFORMATION
                        dir_info;
    OBJECT_ATTRIBUTES   object_attributes;
    CHAR                dir_info_buffer[1024];
    ULONG               length;
    HANDLE              handle;
    BOOLEAN             restart_scan;
    NTSTATUS            status;

    UNICODE_STRING      link_target;
    UNICODE_STRING      link_type_name;
    UNICODE_STRING      link_name;
    UNICODE_STRING      link_target_prefix1;
    UNICODE_STRING      link_target_prefix2;
    UNICODE_STRING      u;

    DSTRING             device_name;
    DSTRING             name;
    DSTRING             nt_name;
    DSTRING             dos_guidname_prefix;

    BOOLEAN             is_guidname;

    DebugPtrAssert(MountPointMap);

    if (!dos_guidname_prefix.Initialize(DOS_GUIDNAME_PREFIX)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Out of memory.\n"));

        return FALSE;
    }

    if (!MountPointMap->Initialize()) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Unable to initialize mount point map.\n"));

        return FALSE;
    }

    link_target.Buffer = link_target_buffer;
    dir_info = (POBJECT_DIRECTORY_INFORMATION)dir_info_buffer;

    RtlInitUnicodeString(&link_type_name, L"SymbolicLink");
    RtlInitUnicodeString(&link_target_prefix1, L"\\Device\\Volume");
    RtlInitUnicodeString(&link_target_prefix2, L"\\Device\\Harddisk");
    RtlInitUnicodeString(&link_name, GUID_VOLNAME_PREFIX);

    restart_scan = TRUE;

    RtlInitUnicodeString(&u, L"\\??");

    InitializeObjectAttributes(&object_attributes, &u,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenDirectoryObject(&dos_devices_object_dir,
                                   DIRECTORY_ALL_ACCESS,
                                   &object_attributes);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "AUTOCHK: Unable to open %wZ directory - Status == %lx\n",
                   &u,
                   status));

        return FALSE;
    }

    for (;;) {

        status = NtQueryDirectoryObject(dos_devices_object_dir,
                                        (PVOID)dir_info,
                                        sizeof(dir_info_buffer),
                                        TRUE,
                                        restart_scan,
                                        &context,
                                        &length);

        if (status == STATUS_NO_MORE_ENTRIES) {

            return TRUE;
        }

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_AUTOCHK_ID,
                       DPFLTR_WARNING_LEVEL,
                       "AUTOCHK: NtQueryDirectoryObject failed with %d\n",
                       status));

            return FALSE;
        }

#if 0
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: dir_info->TypeName: %wZ\n",
                   &(dir_info->TypeName)));

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: dir_info->Name: %wZ\n",
                   &(dir_info->Name)));
#endif

        if (RtlEqualUnicodeString(&dir_info->TypeName, &link_type_name, TRUE) &&
            ((is_guidname = RtlPrefixUnicodeString(&link_name, &dir_info->Name, TRUE)) ||
             dir_info->Name.Buffer[(dir_info->Name.Length>>1)-1] == L':')) {

#if 0
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: dir_info->TypeName: %wZ\n",
                   &(dir_info->TypeName)));

        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_INFO_LEVEL,
                   "AUTOCHK: dir_info->Name: %wZ\n",
                   &(dir_info->Name)));
#endif

            InitializeObjectAttributes(&object_attributes,
                                       &dir_info->Name,
                                       OBJ_CASE_INSENSITIVE,
                                       dos_devices_object_dir,
                                       NULL);

            status = NtOpenSymbolicLinkObject(&handle,
                                              SYMBOLIC_LINK_ALL_ACCESS,
                                              &object_attributes);

            if (!NT_SUCCESS(status)) {

                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: NtOpenSymbolicLinkObject failed with %d\n",
                           status));

                return FALSE;
            }

            link_target.Length = 0;
            link_target.MaximumLength = sizeof(link_target_buffer);

            status = NtQuerySymbolicLinkObject(handle,
                                               &link_target,
                                               NULL);
            NtClose(handle);

            if (NT_SUCCESS(status) &&
                (RtlPrefixUnicodeString(&link_target_prefix1, &link_target, TRUE) ||
                 RtlPrefixUnicodeString(&link_target_prefix2, &link_target, TRUE))) {

                if (!device_name.Initialize(link_target.Buffer,
                                            link_target.Length / 2) ||
                    !name.Initialize(dir_info->Name.Buffer,
                                     dir_info->Name.Length / 2)) {
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_WARNING_LEVEL,
                               "Out of memory.\n"));

                    return FALSE;
                }

#if 0
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_INFO_LEVEL,
                           "AUTOCHK: Device Name: %S\n",
                           device_name.GetWSTR()));
#endif

                if (is_guidname) {
                    if (!name.InsertString(0, &dos_guidname_prefix)) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "Out of memory.\n"));

                        return FALSE;
                    }
                    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&name, &nt_name)) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "Unable to translate dos drive name to nt drive name.\n"));

                        return FALSE;
                    }
#if 0
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_INFO_LEVEL,
                               "AUTOCHK: Volume Name: %S\n",
                               nt_name.GetWSTR()));
#endif
                    if (!MountPointMap->AddVolumeName(&device_name, &nt_name)) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "Unable to add volume name into mount point map.\n"));

                        return FALSE;
                    }
                } else {
                    DebugAssert(name.QueryChCount() == 2);
#if 0
                    KdPrintEx((DPFLTR_AUTOCHK_ID,
                               DPFLTR_INFO_LEVEL,
                               "AUTOCHK: Drive Name: %S\n",
                               name.GetWSTR()));
#endif
                    if (!MountPointMap->AddDriveName(&device_name, &name)) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "Unable to add drive name into mount point map.\n"));

                        return FALSE;
                    }
                }

            } else if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_AUTOCHK_ID,
                           DPFLTR_WARNING_LEVEL,
                           "AUTOCHK: NtQuerySymbolicLinkObject failed with %d\n",
                           status));
            }
        }
        restart_scan = FALSE;
    }

    //NOTREACHED
    return FALSE;
}

BOOLEAN
IsGuidVolName (
    PWSTRING    VolName
    )
{
    DSTRING             nt_name_prefix;
    DSTRING             guid_volname_prefix;

    if (!nt_name_prefix.Initialize(NT_NAME_PREFIX) ||
        !guid_volname_prefix.Initialize(GUID_VOLNAME_PREFIX)) {
        KdPrintEx((DPFLTR_AUTOCHK_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Out of memory.\n"));

        return FALSE;
    }

    if (VolName->QueryChCount() <= nt_name_prefix.QueryChCount())
        return FALSE;

    if (VolName->Stricmp(&nt_name_prefix,
                         0,
                         nt_name_prefix.QueryChCount()) != 0)
        return FALSE;
    if (VolName->Stricmp(&guid_volname_prefix,
                         nt_name_prefix.QueryChCount(),
                         guid_volname_prefix.QueryChCount()) != 0)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\autofmt\autofmt.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    autofmt.cxx

Abstract:

    This is the main program for the autofmt version of format.

Author:

    Matthew Bradburn (mattbr) 13-Dec-94

--*/

#include "ulib.hxx"
#include "wstring.hxx"
#include "achkmsg.hxx"
#include "spackmsg.hxx"
#include "tmackmsg.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#include "ifsentry.hxx"
#include "fatvol.hxx"
#include "ntfsvol.hxx"
#include "autoreg.hxx"
#include "autoentr.hxx"
#include "arg.hxx"

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeUhpfs(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeUntfs(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

BOOLEAN
DeRegister(
    int     argc,
    char**  argv
    );

BOOLEAN
SavemessageLog(
    IN OUT  PMESSAGE    message,
    IN      PCWSTRING   drive_name
    );

int __cdecl
main(
    int     argc,
    char**  argv,
    char**  envp,
    ULONG DebugParameter
    )
/*++

Routine Description:

    This routine is the main program for AutoFmt

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                  the drive to check.  The syntax of the autofmt
                  command line is:

    AUTOFMT drive-name /FS:target-file-system [/V:label] [/Q] [/A:size] [/C]
            [/S]

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    if (!InitializeUlib( NULL, ! DLL_PROCESS_DETACH, NULL )     ||
        !InitializeIfsUtil(NULL, ! DLL_PROCESS_DETACH, NULL)    ||
        !InitializeUfat(NULL, ! DLL_PROCESS_DETACH, NULL)       ||
        !InitializeUntfs(NULL, ! DLL_PROCESS_DETACH, NULL)
       ) {
        return 1;
    }

    PFAT_VOL            fat_volume;
    PNTFS_VOL           ntfs_volume;
    PDP_DRIVE            dp_drive;

    PAUTOCHECK_MESSAGE  message;
    DSTRING             drive_name;
    DSTRING             file_system_name;
    DSTRING             label;
    DSTRING             fat_name;
    DSTRING             ntfs_name;
    DSTRING             fat32_name;
    BOOLEAN             quick = FALSE;
    BOOLEAN             compress = FALSE;
    BOOLEAN             error;
    FORMAT_ERROR_CODE   success;
    BOOLEAN             setup_output = FALSE;
    BOOLEAN             textmode_output = FALSE;
    BIG_INT             bigint;
    ULONG               cluster_size = 0;
    int                 i;

    LARGE_INTEGER       delay_interval;

    if (!file_system_name.Initialize()) {
        return 1;
    }
    if (!label.Initialize() || NULL == (dp_drive = NEW DP_DRIVE)) {
        return 1;
    }

    //
    //  Parse the arguments.
    //

    if ( argc < 2 ) {
        return 1;
    }

    //
    //  First argument is drive
    //
    if ( !drive_name.Initialize( argv[1] ) ) {
        return 1;
    }
    DebugPrintTrace(("drive name: %ws\n", drive_name.GetWSTR()));

    //
    //  The rest of the arguments are flags.
    //
    for (i = 2; i < argc; i++) {

        if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'f' || argv[i][1] == 'F')    &&
            (argv[i][2] == 's' || argv[i][2] == 'S')    &&
            (argv[i][3] == ':')) {

            if (!file_system_name.Initialize(&argv[i][4])) {
                return 1;
            }
            DebugPrintTrace(("fsname: %ws\n", file_system_name.GetWSTR()));
            continue;
        }
        if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'v' || argv[i][1] == 'V')    &&
            (argv[i][2] == ':')) {

            if (!label.Initialize(&argv[i][3])) {
                return 1;
            }
            continue;
        }
        if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'a' || argv[i][1] == 'A')    &&
            (argv[i][2] == ':')) {

            cluster_size = atoi(&argv[i][3]);
            continue;
        }
        if (0 == _stricmp(argv[i], "/Q") || 0 == _stricmp(argv[i], "-Q")) {
            quick = TRUE;
            continue;
        }
        if (0 == _stricmp(argv[i], "/C") || 0 == _stricmp(argv[i], "-C")) {
            compress = TRUE;
            continue;
        }
        if (0 == _stricmp(argv[i], "/S") || 0 == _stricmp(argv[i], "-S")) {
            setup_output = TRUE;
        }
        if (0 == _stricmp(argv[i], "/T") || 0 == _stricmp(argv[i], "-T")) {
            textmode_output = TRUE;
        }
    }

    if (textmode_output) {
        message = NEW TM_AUTOCHECK_MESSAGE;
    } else if (setup_output) {
        message = NEW SP_AUTOCHECK_MESSAGE;
        DebugPrintTrace(("Using setup output\n"));
    } else {
        DebugPrintTrace(("Not using setup output\n"));
        message = NEW AUTOCHECK_MESSAGE;
    }
    if (NULL == message || !message->Initialize()) {
        return 1;
    }

#if 0 // Shouldn't limit the cluster size as long as it is reasonable.
    if (cluster_size != 0 && cluster_size != 512 && cluster_size != 1024 &&
        cluster_size != 2048 && cluster_size != 4096) {

        message->Set(MSG_UNSUPPORTED_PARAMETER);
        message->Display();

        DeRegister( argc, argv );

        return 1;
    }
#endif
    if (0 == file_system_name.QueryChCount()) {

        // attempt to get the current filesystem type from disk

        if (!IFS_SYSTEM::QueryFileSystemName(&drive_name, &file_system_name)) {

            message->Set( MSG_FS_NOT_DETERMINED );
            message->Display( "%W", &drive_name );

            DeRegister( argc, argv );
            return 1;
        }
        file_system_name.Strupr();
    }

    if (!fat_name.Initialize("FAT") ||
        !ntfs_name.Initialize("NTFS") ||
        !fat32_name.Initialize("FAT32")) {

        return 1;
    }

    file_system_name.Strupr();

    //
    // If compression is requested, make sure it's available.
    //

    if (compress && file_system_name != ntfs_name) {

        message->Set(MSG_COMPRESSION_NOT_AVAILABLE);
        message->Display("%W", &file_system_name);
        DeRegister( argc, argv );
        return 1;
    }

    //  Since autoformat will often be put in place by Setup
    //  to run after AutoSetp, delay for 3 seconds to give the
    //  file system time to clean up detritus of deleted files.
    //
    delay_interval = RtlConvertLongToLargeInteger( -30000000 );

    NtDelayExecution( TRUE, &delay_interval );

    if (!dp_drive->Initialize(&drive_name, message)) {
        DeRegister( argc, argv );
        return 1;
    }

    if (dp_drive->IsFloppy()) {
        // MJB: refuse to format
        DeRegister( argc, argv );
        return 1;
    }

    switch (dp_drive->QueryDriveType()) {
        case UnknownDrive:
            message->Set(MSG_NONEXISTENT_DRIVE);
            message->Display("");
            DeRegister( argc, argv );
            return 1;

        case RemoteDrive:   // it probably won't get that far
            message->Set(MSG_FORMAT_NO_NETWORK);
            message->Display("");
            DeRegister( argc, argv );
            return 1;

        case RamDiskDrive:  // it probably won't get that far
            message->Set(MSG_FORMAT_NO_RAMDISK);
            message->Display("");
            DeRegister( argc, argv );
            return 1;

        default:
            break;
    }

    //
    // Print the "formatting <size>" message.
    //

    if (quick) {
        message->Set(MSG_QUICKFORMATTING_MB);
    } else {
        message->Set(MSG_FORMATTING_MB);
    }

    bigint = dp_drive->QuerySectors() * dp_drive->QuerySectorSize() /
        1048576;

    DebugAssert(bigint.GetHighPart() == 0);

    message->Display("%d", bigint.GetLowPart());

    if (file_system_name == fat_name || file_system_name == fat32_name) {


        BOOLEAN old_fat_vol = TRUE;

        if( file_system_name == fat32_name ) {
            old_fat_vol = FALSE;
        }

        if( !(fat_volume = NEW FAT_VOL) ||
            NoError != fat_volume->Initialize( &drive_name, message, FALSE, !quick,
                Unknown )) {

            DeRegister( argc, argv );
            return 1;
        }

        success = fat_volume->Format(&label,
                                     message,
                                     old_fat_vol ? FORMAT_BACKWARD_COMPATIBLE : 0,
                                     cluster_size);

        DebugPrintTrace(("Format return code: %d\n", success));

        DELETE( fat_volume );

    } else if (file_system_name == ntfs_name) {

        if (dp_drive->QueryDriveType() == CdRomDrive) {
            message->Set(MSG_FMT_NO_NTFS_ALLOWED);
            message->Display();
            DeRegister( argc, argv );
            return 1;
        }

        if( !(ntfs_volume = NEW NTFS_VOL) ||
            NoError != ntfs_volume->Initialize( &drive_name, message, FALSE, !quick,
                Unknown )) {

            DeRegister( argc, argv );
            return 1;
        }

        success = ntfs_volume->Format(&label,
                                      message,
                                      0,
                                      cluster_size);

        DebugPrintTrace(("Format return code: %d\n", success));

        DELETE( ntfs_volume );

    } else {

        message->Set( MSG_FS_NOT_SUPPORTED );
        message->Display( "%s%W", "AUTOFMT", &file_system_name);

        DeRegister( argc, argv );
        return 1;
    }

    // Truncate "fat32" back to "fat"...yuck..
    if (file_system_name == fat32_name) {
       if (!file_system_name.Initialize("FAT")) {
          DeRegister( argc, argv );
          return 1;
       }
    }


    // Make sure the file system is installed.

    if (!IFS_SYSTEM::IsFileSystemEnabled(&file_system_name)) {
        message->Set(MSG_FMT_INSTALL_FILE_SYSTEM);
        message->Display("%W", &file_system_name);

        if (!IFS_SYSTEM::EnableFileSystem(&file_system_name)) {
            message->Set(MSG_FMT_CANT_INSTALL_FILE_SYSTEM);
            message->Display();
            return 1;
        }

        message->Set(MSG_FMT_FILE_SYSTEM_INSTALLED);
        message->Display();
    }

    if (compress && !IFS_SYSTEM::EnableVolumeCompression(&drive_name)) {
        message->Set(MSG_CANNOT_ENABLE_COMPRESSION);
        message->Display();

        DeRegister( argc, argv );

        return 1;
    }

    DeRegister( argc, argv );

    return (success != NoError);
}




BOOLEAN
DeRegister(
    int     argc,
    char**  argv
    )
/*++

Routine Description:

    This function removes the registry entry which triggered
    autoconvert.

Arguments:

    argc    --  Supplies the number of arguments given to autoconv
    argv    --  supplies the arguments given to autoconv

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CommandLineString1,
            CommandLineString2,
            CurrentArgString,
            OneSpace;

    int i;

    // Reconstruct the command line and remove it from
    // the registry.  First, reconstruct the primary
    // string, which is "autoconv arg1 arg2...".
    //
    if( !CommandLineString1.Initialize( L"autofmt" ) ||
        !OneSpace.Initialize( L" " ) ) {

        return FALSE;
    }

    for( i = 1; i < argc; i++ ) {

        if( !CurrentArgString.Initialize( argv[i] ) ||
            !CommandLineString1.Strcat( &OneSpace ) ||
            !CommandLineString1.Strcat( &CurrentArgString ) ) {

            return FALSE;
        }
    }

    // Now construct the secondary string, which is
    // "autocheck arg0 arg1 arg2..."
    //
    if( !CommandLineString2.Initialize( "autocheck " )  ||
        !CommandLineString2.Strcat( &CommandLineString1 ) ) {

        return FALSE;
    }

    return( AUTOREG::DeleteEntry( &CommandLineString1 ) &&
            AUTOREG::DeleteEntry( &CommandLineString2 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\autoconv\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=utils
MINORCOMP=autoconv

TARGETNAME=autoconv
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    ..\autoconv.cxx \
    ..\autoconv.rc

INCLUDES=\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\cufat\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc; \
    $(PROJECT_ROOT)\fs\utils\untfs\inc;

C_DEFINES=-DCONDITION_HANDLING=1 -D_AUTOCHECK_ -DUNICODE=1
TARGETLIBS=\
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O)\ntlib.lib   \
    $(PROJECT_LIB_PATH)\patchbc.lib

UMTYPE=nt
USE_NTDLL=1

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\autoconv\autoconv.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    autoconv.cxx

Abstract:

    This is the main program for the autoconv version of convert.

Author:

    Ramon J. San Andres (ramonsa) 04-Dec-91

--*/

#include "ulib.hxx"
#include "wstring.hxx"
#include "achkmsg.hxx"
#include "spackmsg.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "ifsentry.hxx"
#include "convfat.hxx"
#include "fatvol.hxx"
#include "autoreg.hxx"
#include "autoentr.hxx"
#include "arg.hxx"
#include "rcache.hxx"

#if INCLUDE_OFS==1
#include "fatofs.hxx"
//#include "initexcp.hxx"
#endif  // INCLUDE_OFS

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeUntfs(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );


BOOLEAN
DeRegister(
    int     argc,
    char**  argv
    );

BOOLEAN
SaveMessageLog(
    IN OUT  PMESSAGE    Message,
    IN      PCWSTRING   DriveName
    );

BOOLEAN
FileDelete(
    IN  PCWSTRING DriveName,
    IN  PCWSTRING FileName
    );

#if INCLUDE_OFS==1

BOOLEAN
IsRestartFatToOfs( WSTRING const & DriveName,
                   WSTRING const & CurrentFsName,
                   WSTRING const & TargetFileSystem )
{

    DSTRING OfsName;
    DSTRING FatName;


    if ( !OfsName.Initialize( L"OFS" ) )
        return FALSE;

    if ( CurrentFsName != OfsName || TargetFileSystem != OfsName )
        return FALSE;

    PWSTR pwszDriveName = DriveName.QueryWSTR();

    BOOLEAN fIsRestart = IsFatToOfsRestart( pwszDriveName );
    DELETE( pwszDriveName );

    return fIsRestart;
}

BOOLEAN
IsFatToOfs( WSTRING const & CurrentFsName, WSTRING const & TargetFsName )
{
    DSTRING  FatName;
    DSTRING  OfsName;

    if ( !FatName.Initialize( L"FAT" ) )
        return FALSE;

    if ( !OfsName.Initialize( L"OFS" ) )
        return FALSE;

    return  0 == CurrentFsName.Stricmp(&FatName) &&
            0 == TargetFsName.Stricmp(&OfsName);
}

BOOLEAN
FatToOfs(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Verbose,
    IN      BOOLEAN             fInSetup,
    OUT     PCONVERT_STATUS     Status )
{

    PWSTR pwszNtDriveName = NtDriveName->QueryWSTR();
    FAT_OFS_CONVERT_STATUS cnvStatus;
    BOOLEAN fResult= ConvertFatToOfs(
                            pwszNtDriveName,
                            Message,
                            Verbose,
                            fInSetup,
                            &cnvStatus );

    DELETE( pwszNtDriveName );

    if ( FAT_OFS_CONVERT_SUCCESS == cnvStatus )
    {
        *Status = CONVERT_STATUS_CONVERTED;
    }
    else
    {
        *Status = CONVERT_STATUS_ERROR;
    }

    return fResult;
}

#else

BOOLEAN
IsRestartFatToOfs( WSTRING const & DriveName, WSTRING const & CurrentFsName,
                   WSTRING const & TargetFileSystem )
{
    return FALSE;
}

BOOLEAN
IsFatToOfs( WSTRING const & CurrentFsName, WSTRING const & TargetFsName )
{
    return FALSE;
}

BOOLEAN
FatToOfs(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Verbose,
    IN      BOOLEAN             fInSetup,
    OUT     PCONVERT_STATUS     Status )
{
    *Status = CONVERT_STATUS_CONVERSION_NOT_AVAILABLE;
    return FALSE;
}

#endif  // INCLUDE_OFS

int __cdecl
main(
    int     argc,
    char**  argv,
    char**  envp,
    ULONG DebugParameter
    )
/*++

Routine Description:

    This routine is the main program for AutoConv

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                  the drive to check.  The syntax of the autoconv
                  command line is:

    AUTOCONV drive-name /FS:target-file-system [/v] [/s] [/o] [/cvtarea:filename]

        /v -- verbose output
        /s -- run from setup
        /o -- pause before the final reboot (oem setup)
        /cvtarea:filename
           -- convert zone file name
        /nochkdsk
           -- skips chkdsk and go straight to conversion


Return Value:

    0   - Success.
    1   - Failure.

--*/
{

#if INCLUDE_OFS==1
    InitExceptionSystem();
#endif  // INCLUDE_OFS==1

    if (!InitializeUlib( NULL, ! DLL_PROCESS_DETACH, NULL )     ||
        !InitializeIfsUtil(NULL, ! DLL_PROCESS_DETACH, NULL)    ||
        !InitializeUfat(NULL, ! DLL_PROCESS_DETACH, NULL)       ||
        !InitializeUntfs(NULL, ! DLL_PROCESS_DETACH, NULL)
       ) {
        DebugPrintTrace(( "Failed to initialize U* Dlls" ));
        return 1;
    }

#if defined(FE_SB) && defined(_X86_)
    InitializeMachineId();
#endif

    PAUTOCHECK_MESSAGE  message;
    DSTRING             DriveName;
    DSTRING             FileSystemName;
    DSTRING             CvtZoneFileName;
    DSTRING             CurrentFsName;
    DSTRING             FatName;
    DSTRING             Fat32Name;
    DSTRING             QualifiedName;
    FSTRING             Backslash;
    BOOLEAN             Converted;
    BOOLEAN             Verbose = FALSE;
    BOOLEAN             NoChkdsk = FALSE;
    BOOLEAN             NoSecurity = FALSE;
    BOOLEAN             Error;
    CONVERT_STATUS      Status;
    int                 i;
    BOOLEAN             fInSetup = FALSE;
    BOOLEAN             Pause = FALSE;

    LARGE_INTEGER       DelayInterval;

    DSTRING             StrippedDriveName;
    BOOLEAN             enabled;
    NTSTATUS            status;
    UNICODE_STRING      driverName;
    ULONG               flags;

    status = RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &enabled);

    RtlInitUnicodeString( &driverName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Ntfs" );
    status = NtLoadDriver( &driverName );

    status = RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, enabled, FALSE, &enabled);

    DebugPrintTrace(( "Entering autoconv argc=%ld\n", argc ));
    for ( i = 0; i < argc; i++ )
    {
        DebugPrintTrace((" argv[%d] = %s\n", i, argv[i] ));
    }

    //
    //  Parse the arguments. The accepted arguments are:
    //
    //  autoconv NtDrive /fs:<filesystem> [/v]
    //

    if ( argc < 3 ) {
        return 1;
    }

    //
    //  First argument is drive
    //
    if ( !DriveName.Initialize( argv[1] ) ||
         !StrippedDriveName.Initialize( argv[1] ) ) {
        DebugPrintTrace(( "Failed to intialize DriveName \n" ));
        return 1;
    }

    if (!IFS_SYSTEM::NtDriveNameToDosDriveName(&DriveName, &StrippedDriveName)) {
        if (!StrippedDriveName.Initialize(&DriveName)) {
            DebugPrint( "Out of memory.\n" );
            return 1;
        }
    }

    DebugPrintTrace(("drive name: %ws\n", StrippedDriveName.GetWSTR()));

    //
    //  The rest of the arguments are flags.
    //
    for ( i = 2; i < argc; i++ ) {

        if ( (strlen(argv[i]) >= 5)                         &&
             (argv[i][0] == '/' || argv[i][0] == '-')       &&
             (argv[i][1] == 'f' || argv[i][1] == 'F')       &&
             (argv[i][2] == 's' || argv[i][2] == 'S')       &&
             (argv[i][3] == ':') ) {

            if ( 0 != FileSystemName.QueryChCount() ||
                 !FileSystemName.Initialize( &(argv[i][4]) ) )
            {
                DebugPrintTrace(( "Failed to initialize FileSystemName \n" ));
                return 1;
            }
        }

        if (0 == _stricmp( argv[i], "/V" ) || 0 == _stricmp( argv[i], "-V" )) {
            Verbose = TRUE;
        }

        if (0 == _stricmp(argv[i], "/S") || 0 == _stricmp(argv[i], "-S")) {
            DebugPrintTrace(("Found /s option\n"));
            fInSetup = TRUE;
        }

        if (0 == _stricmp(argv[i], "/O") || 0 == _stricmp(argv[i], "-O")) {
            DebugPrintTrace(("Found /o option\n"));
            Pause = TRUE;
        }

        if ( (strlen(argv[i]) >= 10)                        &&
             (argv[i][0] == '/' || argv[i][0] == '-')       &&
             (argv[i][1] == 'c' || argv[i][1] == 'C')       &&
             (argv[i][2] == 'v' || argv[i][2] == 'V')       &&
             (argv[i][3] == 't' || argv[i][3] == 'T')       &&
             (argv[i][4] == 'a' || argv[i][4] == 'A')       &&
             (argv[i][5] == 'r' || argv[i][5] == 'R')       &&
             (argv[i][6] == 'e' || argv[i][6] == 'E')       &&
             (argv[i][7] == 'a' || argv[i][7] == 'A')       &&
             (argv[i][8] == ':') ) {

            if ( 0 != CvtZoneFileName.QueryChCount() ||
                 !CvtZoneFileName.Initialize( &(argv[i][9]) ) )
            {
                DebugPrintTrace(( "Failed to initialize CvtZoneFileName \n" ));
                return 1;
            }
        }

        if ( (strlen(argv[i]) >= 9)                        &&
             (argv[i][0] == '/' || argv[i][0] == '-')       &&
             (argv[i][1] == 'n' || argv[i][1] == 'N')       &&
             (argv[i][2] == 'o' || argv[i][2] == 'O')       &&
             (argv[i][3] == 'c' || argv[i][3] == 'C')       &&
             (argv[i][4] == 'h' || argv[i][4] == 'H')       &&
             (argv[i][5] == 'k' || argv[i][5] == 'K')       &&
             (argv[i][6] == 'd' || argv[i][6] == 'D')       &&
             (argv[i][7] == 's' || argv[i][7] == 'S')       &&
             (argv[i][8] == 'k' || argv[i][8] == 'K')
           ) {
            NoChkdsk = TRUE;
        }

        if ( (strlen(argv[i]) >= 11)                        &&
             (argv[i][0] == '/' || argv[i][0] == '-')       &&
             (argv[i][1] == 'n' || argv[i][1] == 'N')       &&
             (argv[i][2] == 'o' || argv[i][2] == 'O')       &&
             (argv[i][3] == 's' || argv[i][3] == 'S')       &&
             (argv[i][4] == 'e' || argv[i][4] == 'E')       &&
             (argv[i][5] == 'c' || argv[i][5] == 'C')       &&
             (argv[i][6] == 'u' || argv[i][6] == 'U')       &&
             (argv[i][7] == 'r' || argv[i][7] == 'R')       &&
             (argv[i][8] == 'i' || argv[i][8] == 'I')       &&
             (argv[i][9] == 't' || argv[i][9] == 'T')       &&
             (argv[i][10] == 'y' || argv[i][10] == 'Y')
           ) {
            NoSecurity = TRUE;
        }
    }

    if ( 0 == FileSystemName.QueryChCount() )
    {
        DebugPrintTrace(( "No FileSystem name specified\n" ));
        return 1;
    }

    DebugPrintTrace(("AUTOCONV: TargetFileSystem=%ws\n", FileSystemName.GetWSTR() ));

    if (fInSetup) {
        message = NEW SP_AUTOCHECK_MESSAGE;
        DebugPrintTrace(("Using setup output\n"));
    } else {
        DebugPrintTrace(("Not using setup output\n"));
        message = NEW AUTOCHECK_MESSAGE;
    }

    if (NULL == message || !message->Initialize()) {
        DebugPrintTrace(( "Failed to intitialize message structure\n" ));
        return 1;
    }

    message->SetLoggingEnabled(TRUE);

    if (!FatName.Initialize("FAT") ||
        !Fat32Name.Initialize("FAT32")) {
        message->Set(MSG_CONV_NO_MEMORY);
        message->Display();
        SaveMessageLog( message, &DriveName );
        return 1;
    }

    // If this is the System Partition of an ARC machine, don't
    // convert it.
    //
    if( IFS_SYSTEM::IsArcSystemPartition( &DriveName, &Error ) ) {

        message->Set( MSG_CONV_ARC_SYSTEM_PARTITION );
        message->Display( );

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return 1;
    }

    if (!IFS_SYSTEM::QueryFileSystemName( &DriveName, &CurrentFsName )) {

        message->Set( MSG_FS_NOT_DETERMINED );
        message->Display( "%W", &StrippedDriveName );

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return 1;
    }

#if defined(FE_SB) && defined(_X86_)
    if( IsPC98_N() ) {
        DP_DRIVE    dpdrive2;
        if( !dpdrive2.Initialize(&DriveName, message) ) {

            message->Set( MSG_CONV_CANNOT_AUTOCHK );
            message->Display( "%W%W", &DriveName, &FileSystemName );

            SaveMessageLog( message, &DriveName );
            DeRegister( argc, argv );
            return 1;
        }
        if( CurrentFsName == FatName ) { //***FAT***
            if((dpdrive2.QuerySectorSize() != dpdrive2.QueryPhysicalSectorSize())||
               (dpdrive2.QueryPhysicalSectorSize() == 2048)) {

                message->Set( MSG_CONV_CONVERSION_FAILED );
                message->Display( "%W%W", &DriveName, &FileSystemName );

                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }
        } else {     //***HPFS/NTFS**
            if( dpdrive2.QueryPhysicalSectorSize() == 2048 ) {

                message->Set( MSG_CONV_CONVERSION_FAILED );
                message->Display( "%W%W", &DriveName, &FileSystemName );
                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }
        }
    }
#endif

    CurrentFsName.Strupr();
    FileSystemName.Strupr();

    if ( CurrentFsName == FileSystemName ) {

        int iReturn = 0;

        if ( IsRestartFatToOfs( DriveName, CurrentFsName, FileSystemName ) ) {

            if ( !FatToOfs( &DriveName, message, Verbose, fInSetup, &Status ) ) {
                iReturn = 1;
            }
        }
        else {
            //
            //  The drive is already in the desired file system, our
            //  job is done.  Delete the name conversion table (if
            //  specified) and take ourselves out of the registry.
            //  Do not save the message log--there's nothing interesting
            //  in it.
            //
            //  If we're doing oem pre-install (Pause is TRUE) we don't
            //  want to print this "already converted" message.
            //

            message->SetLoggingEnabled(FALSE);
        }

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return iReturn;
    }

    message->Set( MSG_FILE_SYSTEM_TYPE );
    message->Display( "%W", &CurrentFsName );

    //  Determine whether the target file-system is enabled
    //  in the registry.  If it is not, refuse to convert
    //  the drive.
    //
    if( !IFS_SYSTEM::IsFileSystemEnabled( &FileSystemName ) ) {

        message->Set( MSG_CONVERT_FILE_SYSTEM_NOT_ENABLED );
        message->Display( "%W", &FileSystemName );

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return 1;
    }

    //  Since autoconvert will often be put in place by Setup
    //  to run after AutoSetp, delay for 3 seconds to give the
    //  file system time to clean up detritus of deleted files.
    //
    DelayInterval = RtlConvertLongToLargeInteger( -30000000 );

    NtDelayExecution( TRUE, &DelayInterval );

    //  Open a volume of the appropriate type.  The volume is
    //  opened for exclusive write access.
    //
    if( CurrentFsName == FatName || CurrentFsName == Fat32Name) {

        if (IsConversionAvailable(&FileSystemName)) {
            message->Set( MSG_CONV_CONVERSION_NOT_AVAILABLE );
            message->Display( "%W%W", &CurrentFsName, &FileSystemName );
            SaveMessageLog( message, &DriveName );
            DeRegister( argc, argv );
            return 1;
        }

        {
            DP_DRIVE    dpdrive;

            if( !dpdrive.Initialize(&DriveName, message) ) {
                message->Set( MSG_CONV_CONVERSION_FAILED );
                message->Display( "%W%W", &DriveName, &FileSystemName );
                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }

            switch (dpdrive.QueryDriveType()) {
                case UnknownDrive:  // it probably won't get this far
                    message->Set( MSG_CONV_INVALID_DRIVE_SPEC );
                    message->Display();
                    SaveMessageLog( message, &DriveName );
                    DeRegister( argc, argv );
                    return 1;

                case CdRomDrive:
                    message->Set( MSG_CONV_CANT_CDROM );
                    message->Display();
                    SaveMessageLog( message, &DriveName );
                    DeRegister( argc, argv );
                    return 1;

                case RemoteDrive:   // it probably won't get this far
                    message->Set( MSG_CONV_CANT_NETWORK );
                    message->Display();
                    SaveMessageLog( message, &DriveName );
                    DeRegister( argc, argv );
                    return 1;

                default:
                    break;
            }
        }

        if (!NoChkdsk) {

            PFAT_VOL            FatVolume;

            if( !(FatVolume = NEW FAT_VOL) ||
                !FatVolume->Initialize( message, &DriveName) ||
                !FatVolume->ChkDsk( TotalFix, message, 0, 0 ) ) {

                DELETE (FatVolume);

                message->Set( MSG_CONV_CANNOT_AUTOCHK );
                message->Display( "%W%W", &StrippedDriveName, &FileSystemName );

                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }

            DELETE (FatVolume);
        }

        message->Set( MSG_BLANK_LINE );
        message->Display();

        if ( IsFatToOfs( CurrentFsName, FileSystemName ) ) {

            message->Set( MSG_CONV_CONVERTING );
            message->Display( "%W%W", &StrippedDriveName, &FileSystemName );

            Converted = FatToOfs( &DriveName,
                                  message,
                                  Verbose,
                                  fInSetup,
                                  &Status );
        } else {

            PLOG_IO_DP_DRIVE pDrive;

            pDrive = NEW LOG_IO_DP_DRIVE;

            if (pDrive == NULL) {
                message->Set(MSG_CONV_NO_MEMORY);
                message->Display();
                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                return 1;
            }

            if ( !pDrive->Initialize(&DriveName, message) ) {
                message->Set( MSG_CONV_CONVERSION_FAILED );
                message->Display( "%W%W", &DriveName, &FileSystemName );
                SaveMessageLog( message, &DriveName );
                DeRegister( argc, argv );
                DELETE( pDrive );
                return 1;
            }

            message->Set( MSG_CONV_CONVERTING );
            message->Display( "%W%W", &StrippedDriveName, &FileSystemName );

            //
            // there is no need to pass in /NoChkdsk
            //
            flags = Verbose ? CONVERT_VERBOSE_FLAG : 0;
            flags |= Pause ? CONVERT_PAUSE_FLAG : 0;
            flags |= NoSecurity ? CONVERT_NOSECURITY_FLAG : 0;

            Converted = ConvertFATVolume( pDrive,
                                          &FileSystemName,
                                          &CvtZoneFileName,
                                          message,
                                          flags,
                                          &Status );

            DELETE( pDrive );
        }

    } else {

        message->Set( MSG_FS_NOT_SUPPORTED );
        message->Display( "%s%W", "AUTOCONV", &CurrentFsName );

        SaveMessageLog( message, &DriveName );
        DeRegister( argc, argv );
        return 1;
    }

    if ( Converted ) {

        message->Set( MSG_CONV_CONVERSION_COMPLETE );
        message->Display();

    } else {

        //
        //  The conversion was not successful. Determine what the problem was
        //  and return the appropriate CONVERT exit code.
        //
        switch ( Status ) {

          case CONVERT_STATUS_CONVERTED:
            //
            //  This is an inconsistent state, Convert should return
            //  TRUE if the conversion was successful!
            //
            message->Set( MSG_CONV_CONVERSION_MAYHAVE_FAILED );
            message->Display( "%W%W", &StrippedDriveName, &FileSystemName );
            break;

          case CONVERT_STATUS_INVALID_FILESYSTEM:
            //
            //  The conversion DLL does not recognize the target file system.
            //
            message->Set( MSG_CONV_INVALID_FILESYSTEM );
            message->Display( "%W", &FileSystemName );
            break;

          case CONVERT_STATUS_CONVERSION_NOT_AVAILABLE:
            //
            //  The target file system is valid, but the conversion is not
            //  available.
            //
            message->Set( MSG_CONV_CONVERSION_NOT_AVAILABLE );
            message->Display( "%W%W", &CurrentFsName, &FileSystemName );
            break;

          case CONVERT_STATUS_NTFS_RESERVED_NAMES:
            message->Set( MSG_CONV_NTFS_RESERVED_NAMES );
            message->Display( "%W", &StrippedDriveName );
            break;

          case CONVERT_STATUS_WRITE_PROTECTED:
            message->Set( MSG_CONV_WRITE_PROTECTED );
            message->Display( "%W", &StrippedDriveName );
            break;

          case CONVERT_STATUS_INSUFFICIENT_FREE_SPACE:
          case CONVERT_STATUS_CANNOT_LOCK_DRIVE:
          case CONVERT_STATUS_DRIVE_IS_DIRTY:
          case CONVERT_STATUS_ERROR:
            //
            //  The conversion failed.
            //
          default:
            //
            //  Invalid status code
            //
            message->Set( MSG_CONV_CONVERSION_FAILED );
            message->Display( "%W%W", &StrippedDriveName, &FileSystemName );
            DebugPrintTrace(("AUTOCONV: Failed %x\n", Status));
            break;
        }
    }

    SaveMessageLog( message, &DriveName );
    DeRegister( argc, argv );

#if INCLUDE_OFS==1
    CleanupExceptionSystem();
#endif  // INCLUDE_OFS==1

    return ( Converted ? 0 : 1 );
}




BOOLEAN
DeRegister(
    int     argc,
    char**  argv
    )
/*++

Routine Description:

    This function removes the registry entry which triggered
    autoconvert.

Arguments:

    argc    --  Supplies the number of arguments given to autoconv
    argv    --  supplies the arguments given to autoconv

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CommandLineString1,
            CommandLineString2,
            CurrentArgString,
            OneSpace;

    int i;

    // Reconstruct the command line and remove it from
    // the registry.  First, reconstruct the primary
    // string, which is "autoconv arg1 arg2...".
    //
    if( !CommandLineString1.Initialize( L"autoconv" ) ||
        !OneSpace.Initialize( L" " ) ) {

        return FALSE;
    }

    for( i = 1; i < argc; i++ ) {

        if( !CurrentArgString.Initialize( argv[i] ) ||
            !CommandLineString1.Strcat( &OneSpace ) ||
            !CommandLineString1.Strcat( &CurrentArgString ) ) {

            return FALSE;
        }
    }

    // Now construct the secondary string, which is
    // "autocheck arg0 arg1 arg2..."
    //
    if( !CommandLineString2.Initialize( "autocheck " )  ||
        !CommandLineString2.Strcat( &CommandLineString1 ) ) {

        return FALSE;
    }

    return( AUTOREG::DeleteEntry( &CommandLineString1 ) &&
            AUTOREG::DeleteEntry( &CommandLineString2 ) );

}


BOOLEAN
SaveMessageLog(
    IN OUT  PMESSAGE    Message,
    IN      PCWSTRING   DriveName
    )
/*++

Routine Description:

    This function writes the logged messages from the supplied
    message object to the file "BOOTEX.LOG" in the root of the
    specified drive.

Arguments:

    Message     --  Supplies the message object.
    DriveName   --  Supplies the name of the drive.

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING QualifiedName;
    FSTRING BootExString;
    HMEM    Mem;
    ULONG   Length;

    if( !Message->IsLoggingEnabled() ) {

        return TRUE;
    }

    return( QualifiedName.Initialize( DriveName )       &&
            BootExString.Initialize( L"\\BOOTEX.LOG" )  &&
            QualifiedName.Strcat( &BootExString )       &&
            Mem.Initialize()                            &&
            Message->QueryPackedLog( &Mem, &Length )    &&
            IFS_SYSTEM::WriteToFile( &QualifiedName,
                                     Mem.GetBuf(),
                                     Length,
                                     TRUE ) );
}

BOOLEAN
FileDelete(
    IN  PCWSTRING DriveName,
    IN  PCWSTRING FileName
    )
/*++

Routine Description:

    This function deletes a file.  It is used to clean up the
    name translation table.

Arguments:

    DriveName   --  Supplies the drive on which the file resides.
    FileName    --  Supplies the file name.  Note that the file
                    should be in the root directory.

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING QualifiedName;
    FSTRING Backslash;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    FILE_DISPOSITION_INFORMATION DispositionInfo;
    HANDLE FileHandle;
    NTSTATUS Status;

    if( !Backslash.Initialize( L"\\" )          ||
        !QualifiedName.Initialize( DriveName )  ||
        !QualifiedName.Strcat( &Backslash )     ||
        !QualifiedName.Strcat( FileName ) ) {

        return FALSE;
    }

    UnicodeString.Buffer = (PWSTR)QualifiedName.GetWSTR();
    UnicodeString.Length = (USHORT)( QualifiedName.QueryChCount() * sizeof( WCHAR ) );
    UnicodeString.MaximumLength = UnicodeString.Length;

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    Status = NtOpenFile( &FileHandle,
                         FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE,
                         FILE_NON_DIRECTORY_FILE );

    if( NT_SUCCESS( Status ) ) {

        DispositionInfo.DeleteFile = TRUE;

        Status = NtSetInformationFile( FileHandle,
                                       &IoStatusBlock,
                                       &DispositionInfo,
                                       sizeof( DispositionInfo ),
                                       FileDispositionInformation );
    }

    if( !NT_SUCCESS( Status ) ) {

        return FALSE;
    }

    NtClose( FileHandle );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\autofmt\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=utils
MINORCOMP=autofmt

TARGETNAME=autofmt
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES=..\autofmt.cxx ..\autofmt.rc

INCLUDES=\
    $(PROJECT_ROOT)\fs\utils\ulib\inc;\
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc;\
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    $(PROJECT_ROOT)\fs\utils\untfs\inc;

C_DEFINES=-DCONDITION_HANDLING=1 -D_AUTOCHECK_ -DUNICODE=1

TARGETLIBS= \
    $(PROJECT_ROOT)\fs\utils\ntlib\src\$(ALT_PROJECT)\$(O)\ntlib.lib \
    $(PROJECT_LIB_PATH)\patchbc.lib

UMTYPE=nt

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\chcp\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=chcp
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\chcp.cxx ..\chcp.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

CXXFLAGS=+d
TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\chcp\chcp.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    Chcp

Abstract:

    Chcpo is a DOS5-Compatible codepage utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Revision History:

--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "stream.hxx"
#include "smsg.hxx"
#include "wstring.hxx"
#include "rtmsg.h"
#include "chcp.hxx"


VOID __cdecl
main (
        )

/*++

Routine Description:

    Main function of the Chcp utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Initialize stuff
        //
    DEFINE_CLASS_DESCRIPTOR( CHCP );

    {
        CHCP Chcp;

        if ( Chcp.Initialize() ) {

            Chcp.Chcp();
        }
    }
}



DEFINE_CONSTRUCTOR( CHCP,  PROGRAM );



CHCP::~CHCP (
        )

/*++

Routine Description:

    Destructs a CHCP object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
}




BOOLEAN
CHCP::Initialize (
        )

/*++

Routine Description:

    Initializes a CHCP object

Arguments:

    None.

Return Value:

    TRUE if initialized.

Notes:

--*/

{
    //
        //      Initialize program object
        //
    if ( PROGRAM::Initialize( MSG_CHCP_USAGE ) &&
         _Screen.Initialize( )

       ) {

        _SetCodePage = FALSE;
        _CodePage    = 0;

        return TRUE;

    }

    return FALSE;
}



BOOLEAN
CHCP::Chcp (
        )

/*++

Routine Description:

    Does the Chcp thing.

Arguments:

    None.

Return Value:

    TRUE.

Notes:

--*/

{
    ValidateVersion();

    if ( ParseArguments() ) {


        if ( _SetCodePage ) {

            //
            //  Set the code page
            //
            if ( !SetCodePage() ) {
                ExitProgram( EXIT_ERROR );
            }

        } else {

            //
            //  Display current code page
            //
            if ( !DisplayCodePage() ) {
                ExitProgram( EXIT_ERROR );
            }
        }

        ExitProgram( EXIT_NORMAL );

    } else {

        ExitProgram( EXIT_ERROR );

    }

    return TRUE;
}




BOOLEAN
CHCP::DisplayCodePage (
        )

/*++

Routine Description:

    Displays the active code page

Arguments:

    None.

Return Value:

    TRUE if success, FALSE if syntax error.

Notes:

--*/

{

    DisplayMessage(
        MSG_CHCP_ACTIVE_CODEPAGE,
        NORMAL_MESSAGE, "%d",
        _Screen.QueryCodePage( )
        );

    return TRUE;
}


BOOLEAN
CHCP::ParseArguments (
        )

/*++

Routine Description:

    Parses arguments

Arguments:

    None.

Return Value:

    TRUE if success, FALSE if syntax error.

Notes:

--*/

{

    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;
    ARRAY               ArgArray;

    STRING_ARGUMENT     ProgramNameArgument;
    LONG_ARGUMENT       CodePageArgument;
    FLAG_ARGUMENT       UsageArgument;


    if ( !ArgArray.Initialize()             ||
         !LexArray.Initialize()             ||
         !ArgLex.Initialize( &LexArray )
       ) {

        DisplayMessage( MSG_CHCP_INTERNAL_ERROR, ERROR_MESSAGE );
        ExitProgram( EXIT_ERROR );
    }

    if ( !ProgramNameArgument.Initialize( "*" ) ||
         !UsageArgument.Initialize( "/?" )      ||
         !CodePageArgument.Initialize( "*" )
       ) {

        DisplayMessage( MSG_CHCP_INTERNAL_ERROR, ERROR_MESSAGE );
        ExitProgram( EXIT_ERROR );
    }

    if ( !ArgArray.Put( &ProgramNameArgument ) ||
         !ArgArray.Put( &UsageArgument )       ||
         !ArgArray.Put( &CodePageArgument )
       ) {

        DisplayMessage( MSG_CHCP_INTERNAL_ERROR, ERROR_MESSAGE );
        ExitProgram( EXIT_ERROR );
    }


    //
    // Set up the defaults
        //
    ArgLex.PutSwitches( "/" );
    ArgLex.SetCaseSensitive( FALSE );


    if ( !ArgLex.PrepareToParse() ) {

        DisplayMessage( MSG_CHCP_INTERNAL_ERROR, ERROR_MESSAGE );
        ExitProgram( EXIT_ERROR );
    }

    if ( !ArgLex.DoParsing( &ArgArray ) ) {

        DisplayMessage( MSG_CHCP_INVALID_PARAMETER, ERROR_MESSAGE, "%W", ArgLex.QueryInvalidArgument() );
        ExitProgram( EXIT_ERROR );

    }


    //
    //  Display Help if requested
    //
    if ( UsageArgument.IsValueSet() ) {

        DisplayMessage( MSG_CHCP_USAGE, NORMAL_MESSAGE );
        ExitProgram( EXIT_NORMAL );

    }

    if ( CodePageArgument.IsValueSet() ) {

        _SetCodePage = TRUE;
        _CodePage    = (DWORD)CodePageArgument.QueryLong();

    } else {

        _SetCodePage = FALSE;
    }

    return TRUE;
}


inline bool IsFarEastCodePage(UINT cp)
{
    return cp == 932 || cp == 949 || cp == 936 || cp == 950;
}

inline bool IsFarEastLocale(LANGID langid)
{
    // Accepts primay langid only
    return langid == LANG_JAPANESE || langid == LANG_KOREAN || langid == LANG_CHINESE;
}

inline bool IsFarEastSystemLocale()
{
    return IsFarEastLocale(PRIMARYLANGID(GetSystemDefaultLangID()));
}

BOOLEAN
CHCP::SetCodePage (
        )

/*++

Routine Description:

    Sets the active code page

Arguments:

    None.

Return Value:

    TRUE if success, FALSE if syntax error.

Notes:

--*/

{
    UINT OldCP = _Screen.QueryCodePage( );

    if (IsFarEastSystemLocale() &&
            (IsFarEastCodePage(_CodePage) || IsFarEastCodePage(OldCP)) &&
            _CodePage != OldCP) {
        /*
         * This CLS function is needed only if it's FE.
         */
        _Screen.MoveCursorTo(0, 0);
        _Screen.EraseScreenAndResetAttribute();
    }


    if ( _Screen.SetOutputCodePage( _CodePage ) ) {
        if (_Screen.SetCodePage( _CodePage ) ) {

            // Comment from NT4J:
            // Since FormatMessage checks the current TEB's locale, and the Locale for
            // CHCP is initialized when the message class is initialized, the TEB has to
            // be updated after the code page is changed successfully.  All other code
            // pages other than JP and US are ignored.

            if (IsFarEastSystemLocale()) {
                LANGID LangId;

                switch (_CodePage) {
                case 932:
                    LangId = MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);
                    break;
                case 949:
                    LangId = MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN);
                    break;
                case 936:
                    LangId = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
                    break;
                case 950:
                    LangId = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
                    break;
                default:
                    LangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                    break;
                }

                SetThreadLocale(MAKELCID(LangId, SORT_DEFAULT));
            }

            return DisplayCodePage( );
        } else {
            // SetOutputCodePage failed.
            // Restore the privous input code page
            _Screen.SetOutputCodePage( OldCP );
        }
    }

    // Was unable to set the given code page
    DisplayMessage( MSG_CHCP_INVALID_CODEPAGE, ERROR_MESSAGE );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\chcp\t_chcp.c ===
#include <stdio.h>
#include <conio.h>

int cdecl main(int argc, char **argv)
{
    int i;
    int j;
    
    printf(
"|    |0- |1- |2- |3- |4- |5- |6- |7- |8- |9- |A- |B- |C- |D- |E- |F- |\n");
    printf(
"|----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n");
    for (i = 0; i < 0x10; i++) {
        printf(
"|    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n");
        printf("| -%.1X |", i);
        for (j = 0; j < 0x10; j++) {
            unsigned char ch = (unsigned char)(j * 0x10 + i);
            if (((7 <= ch) && (ch <= 0xA)) || (ch == 0xD)) {
                printf("   |");
            } else {
                printf(" %.1c |", ch);
            }
        }
        printf("\n");
    }
    printf(
"|    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n");
    printf(
"|____|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\chkntfs\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

MAJORCOMP=utils
MINORCOMP=chkntfs

TARGETNAME=chkntfs
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\chkntfs.cxx \
        ..\chkntfs.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\chkntfs\chkntfs.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    chkntfs.cxx


Abstract:

    This utility allows the users to find the state of the dirty bit
    on NTFS volumes, to schedule autochk for specific drives, and to
    mofidy the default autochk action for a drive.


    SYNTAX:

        chkntfs drive: [...]            -- tells if a drive is dirty or chkdsk has been scheduled
        chkntfs /d                      -- restore default autochk behavior
        chkntfs /x drive: [...]         -- exclude drives from default autochk
        chkntfs /c drive: [...]         -- schedule autochk to run on drives
        chkntfs /e drive: [...]         -- enable automatic volume upgrades on drives
        chkntfs /t[:countdowntime]      -- display or set autochk countdown time


    EXIT:

        0   -- OK, dirty bit not set on drive or bit not checked
        1   -- OK, and dirty bit set on at least one drive
        2   -- Error

Author:

    Matthew Bradburn (MattBr)  19-Aug-1996


--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "ifssys.hxx"
#include "system.hxx"
#include "arrayit.hxx"
#include "autoreg.hxx"
#include "chkntfs.hxx"
#include "mpmap.hxx"
#include "volume.hxx"

DEFINE_CONSTRUCTOR(CHKNTFS, PROGRAM);

BOOLEAN
CHKNTFS::Initialize(
    )

/*++

Routine Description:

    Initializes an object of class CHKNTFS.  Called once when the program
    starts.


Arguments:

    None.

Return Value:

    BOOLEAN - Indicates whether the initialization succeeded.

--*/

{
    ARGUMENT_LEXEMIZER  arg_lex;
    ARRAY               lex_array;
    ARRAY               argument_array;
    STRING_ARGUMENT     program_name_argument;

    FLAG_ARGUMENT       flag_restore_default;
    FLAG_ARGUMENT       flag_exclude;
    FLAG_ARGUMENT       flag_schedule_check;
    FLAG_ARGUMENT       flag_invalid;
    FLAG_ARGUMENT       flag_display_help;
    FLAG_ARGUMENT       flag_count_down_time;
    LONG_ARGUMENT       arg_count_down_time;

    ExitStatus = 0;

    PROGRAM::Initialize();

    if (!argument_array.Initialize()) {
        return FALSE;
    }

    if (!program_name_argument.Initialize("*")  ||
        !flag_restore_default.Initialize("/D")  ||
        !flag_exclude.Initialize("/X")          ||
        !flag_schedule_check.Initialize("/C")   ||
        !flag_count_down_time.Initialize("/T")  ||
        !arg_count_down_time.Initialize("/T:*") ||
        !flag_display_help.Initialize("/?")     ||
        !flag_invalid.Initialize("/*")          ||      // close comment */
        !_drive_arguments.Initialize("*", FALSE, TRUE)) {

        return FALSE;
    }

    if (!argument_array.Put(&program_name_argument) ||
        !argument_array.Put(&flag_display_help)     ||
        !argument_array.Put(&flag_restore_default)  ||
        !argument_array.Put(&flag_exclude)          ||
        !argument_array.Put(&flag_schedule_check)   ||
        !argument_array.Put(&flag_count_down_time)   ||
        !argument_array.Put(&arg_count_down_time)   ||
        !argument_array.Put(&flag_invalid)          ||
        !argument_array.Put(&_drive_arguments)) {

        return FALSE;
    }

    if (!lex_array.Initialize() ||
        !arg_lex.Initialize(&lex_array)) {

        return FALSE;
    }

    arg_lex.PutSwitches("/");
    arg_lex.PutStartQuotes("\"");
    arg_lex.PutEndQuotes("\"");
    arg_lex.PutSeparators(" \"\t");
    arg_lex.SetCaseSensitive(FALSE);

    if (!arg_lex.PrepareToParse()) {

        DisplayMessage(MSG_CHKNTFS_INVALID_FORMAT);

        return FALSE;
    }

    if (!arg_lex.DoParsing(&argument_array)) {

        if (flag_invalid.QueryFlag()) {

            DisplayMessage(MSG_CHKNTFS_INVALID_SWITCH, NORMAL_MESSAGE,
                           "%W", flag_invalid.GetLexeme());

        } else {

            DisplayMessage(MSG_CHKNTFS_INVALID_FORMAT);
        }

        return FALSE;

    } else if (_drive_arguments.WildCardExpansionFailed()) {

        DisplayMessage(MSG_CHKNTFS_NO_WILDCARDS);
        return FALSE;
    }

    if (flag_invalid.QueryFlag()) {

        DisplayMessage(MSG_CHKNTFS_INVALID_SWITCH);
        return FALSE;
    }

    if (flag_display_help.QueryFlag()) {

        DisplayMessage(MSG_CHKNTFS_USAGE);
        return FALSE;
    }

    _restore_default = flag_restore_default.QueryFlag();
    _exclude = flag_exclude.QueryFlag();
    _schedule_check = flag_schedule_check.QueryFlag();
    _display_count_down_time = flag_count_down_time.IsValueSet();
    _set_count_down_time = arg_count_down_time.IsValueSet() ?
                            arg_count_down_time.QueryLong() : -1;
    _count_down_time = _display_count_down_time || arg_count_down_time.IsValueSet();

    if (_restore_default + _exclude + _schedule_check + _count_down_time > 1) {

        DisplayMessage(MSG_CHKNTFS_ARGS_CONFLICT);
        return FALSE;
    }

    if (0 == _drive_arguments.QueryPathCount() &&
        !(_restore_default || _count_down_time)) {

        DisplayMessage(MSG_CHKNTFS_REQUIRES_DRIVE);
        return FALSE;
    }

    if ((_restore_default || _count_down_time)
        && _drive_arguments.QueryPathCount() > 0) {

        DisplayMessage(MSG_CHKNTFS_INVALID_FORMAT);
        return FALSE;
    }

    if (_count_down_time && arg_count_down_time.IsValueSet() &&
        (arg_count_down_time.QueryLong() > MAX_AUTOCHK_TIMEOUT_VALUE ||
         arg_count_down_time.QueryLong() < 0)) {

        DisplayMessage(MSG_CHKNTFS_INVALID_AUTOCHK_COUNT_DOWN_TIME,
                       NORMAL_MESSAGE, "%d%d",
                       MAX_AUTOCHK_TIMEOUT_VALUE, AUTOCHK_TIMEOUT);
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
CHKNTFS::CheckNtfs(
    )
/*++

Routine Description:

    Look at the arguments specified by the user and do what
    he wants.

Arguments:

    None.

Return Value:

    BOOLEAN -- success or failure.

--*/
{
    DSTRING             volume_name;
    PATH                fullpath;
    DSTRING             drive_path_string;
    PATH_ANALYZE_CODE   rst;

    MOUNT_POINT_MAP     drive_array_map;
    PMOUNT_POINT_TUPLE  mptuple;

    PARRAY              drive_array;
    PARRAY_ITERATOR     iterator;
    PPATH               current_drive;
    PCWSTRING           display_drive_string;
    PCWSTRING           dos_volume_name;
    PCWSTRING           dos_drive_name;
    DSTRING             nt_drive_name;
    DSTRING             ntfs_str;
    DSTRING             fat_str;
    DSTRING             fat32_str;
    DSTRING             fs_name;
    DSTRING             fs_name_and_version;
    BOOLEAN             is_dirty = 0;
    DSTRING             cmd_line;
    ULONG               old_error_mode;
    DRIVE_TYPE          drive_type;
    DP_DRIVE            dpdrive;

    if (_restore_default) {

        //  Remove all autochk commands and insert the
        //  default entry into the registry.

        if (!cmd_line.Initialize("autocheck autochk") ||
            !AUTOREG::DeleteEntry(&cmd_line, TRUE)) {

            return FALSE;
        }
        if (!cmd_line.Initialize("autocheck autochk *") ||
            !AUTOREG::AddEntry(&cmd_line)) {

            return FALSE;
        }

        return TRUE;
    }

    if (_count_down_time) {

        ULONG   timeout;

        if (_display_count_down_time) {
            if (!VOL_LIODPDRV::QueryAutochkTimeOut(&timeout)) {
                timeout = AUTOCHK_TIMEOUT;
            }
            DisplayMessage(MSG_CHKNTFS_AUTOCHK_COUNT_DOWN_TIME,
                           NORMAL_MESSAGE, "%d", timeout);
            return TRUE;

        } else if (_set_count_down_time >= 0) {

            if (!VOL_LIODPDRV::SetAutochkTimeOut(_set_count_down_time)) {
                DisplayMessage(MSG_CHKNTFS_AUTOCHK_SET_COUNT_DOWN_TIME_FAILED,
                               NORMAL_MESSAGE, "%d", _set_count_down_time);
            }

            return TRUE;
        }

        DebugAssert(FALSE);
        return FALSE;
    }

    if (!ntfs_str.Initialize("NTFS") ||
        !fat_str.Initialize("FAT") ||
        !fat32_str.Initialize("FAT32"))
        return FALSE;

    if (!drive_array_map.Initialize()) {
        DebugPrint("Unable to initialize drive_array_map.\n");
        return FALSE;
    }

    drive_array = _drive_arguments.GetPathArray();
    iterator = (PARRAY_ITERATOR)drive_array->QueryIterator();
    iterator->Reset();

    //
    //  Run through the arguments here and translate each of
    //  them into their ultimate volume names, and mount points.
    //  Build an array of tuple consists of the mount point,
    //  volume name, and original drive specification tuple.

    while (NULL != (current_drive = (PPATH)iterator->GetNext())) {

        display_drive_string = current_drive->GetPathString();

        rst = current_drive->AnalyzePath(&volume_name,
                                         &fullpath,
                                         &drive_path_string);

        switch (rst) {
            case PATH_OK:
            case PATH_COULD_BE_FLOPPY:
                if (drive_path_string.QueryChCount() != 0) {
                    DisplayMessage(MSG_CHKNTFS_BAD_ARG, NORMAL_MESSAGE,
                                   "%W", display_drive_string);
                    DELETE(iterator);
                    return FALSE;
                }

                mptuple = (PMOUNT_POINT_TUPLE)NEW MOUNT_POINT_TUPLE;
                if (mptuple == NULL ||
                    !mptuple->_DeviceName.Initialize(display_drive_string) ||
                    !mptuple->_VolumeName.Initialize(&volume_name) ||
                    !mptuple->_DriveName.Initialize(fullpath.GetPathString())) {
                    DebugPrint("Out of memory.\n");
                    DELETE(mptuple);
                    DELETE(iterator);
                    return FALSE;
                }
                if (!drive_array_map.Put(mptuple)) {
                    DebugPrint("Unable to put away an object.\n");
                    DELETE(mptuple);
                    DELETE(iterator);
                    return FALSE;
                }
                break;

            case PATH_OUT_OF_MEMORY:
                DebugPrint("Out of memory.\n");
                DELETE(iterator);
                return FALSE;

            case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
                DisplayMessage(MSG_CHKNTFS_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH,
                               NORMAL_MESSAGE, "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;

            default:
                DisplayMessage(MSG_CHKNTFS_BAD_ARG, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;
        }
    }
    DELETE(iterator);

    iterator = (PARRAY_ITERATOR)drive_array_map.QueryIterator();
    iterator->Reset();

    //
    //  Run through the tuples here and make sure they're all
    //  valid drive names.
    //

    while (NULL != (mptuple = (PMOUNT_POINT_TUPLE)iterator->GetNext())) {

        display_drive_string = &(mptuple->_DeviceName);
        dos_volume_name = &(mptuple->_VolumeName);

        old_error_mode = SetErrorMode(SEM_FAILCRITICALERRORS);

        drive_type = SYSTEM::QueryDriveType(dos_volume_name);

        SetErrorMode(old_error_mode);

        switch (drive_type) {
            case UnknownDrive:
                DisplayMessage(MSG_CHKNTFS_NONEXISTENT_DRIVE, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;

            case RemoteDrive:
                DisplayMessage(MSG_CHKNTFS_NO_NETWORK, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;

            case RamDiskDrive:
                DisplayMessage(MSG_CHKNTFS_NO_RAMDISK, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;

            case RemovableDrive:

                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_volume_name,
                                                           &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }

                old_error_mode = SetErrorMode(SEM_FAILCRITICALERRORS);

                if (!dpdrive.Initialize(&nt_drive_name)) {

                    SetErrorMode(old_error_mode);

                    DisplayMessage(MSG_CHKNTFS_CANNOT_CHECK, NORMAL_MESSAGE,
                                   "%W", display_drive_string);
                    DELETE(iterator);
                    return FALSE;
                }

                SetErrorMode(old_error_mode);

                if (dpdrive.IsFloppy()) {
                    DisplayMessage(MSG_CHKNTFS_FLOPPY_DRIVE, NORMAL_MESSAGE, "%W",
                                   display_drive_string);
                    DELETE(iterator);
                    return FALSE;
                }

            default:
                break;
        }
    }

    iterator->Reset();

    if (_exclude) {

        DSTRING     cmd_line2;
        DSTRING     option;

        //  Remove all previous autochk commands, if any.

        if (!cmd_line.Initialize("autocheck autochk *") ||
            !AUTOREG::DeleteEntry(&cmd_line, TRUE)) {
            DELETE(iterator);
            return FALSE;
        }

        if (!cmd_line.Initialize("autocheck autochk /k:") ||
            !AUTOREG::DeleteEntry(&cmd_line, TRUE)) {
            DELETE(iterator);
            return FALSE;
        }

        if (!cmd_line.Initialize("autocheck autochk") ||
            !option.Initialize(" /k:") ||
            !cmd_line2.Initialize("autocheck autochk")) {
            DELETE(iterator);
            return FALSE;
        }

        //
        //  Collect a list of drives to be excluded and add them to the
        //  command line
        //

        while (NULL != (mptuple = (PMOUNT_POINT_TUPLE)iterator->GetNext())) {

            display_drive_string = &(mptuple->_DeviceName);
            dos_volume_name = &(mptuple->_VolumeName);
            dos_drive_name = &(mptuple->_DriveName);

            //  Warn the user if the filesystem is not NTFS.

            if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_volume_name,
                                                       &nt_drive_name)) {
                DELETE(iterator);
                return FALSE;
            }

            if (IFS_SYSTEM::QueryFileSystemName(&nt_drive_name, &fs_name,
                                                NULL, &fs_name_and_version)) {

                DisplayMessage(MSG_FILE_SYSTEM_TYPE, NORMAL_MESSAGE,
                               "%W", &fs_name);
            }

            if (!AUTOREG::DeleteEntry(&cmd_line2, &nt_drive_name)) {
                DELETE(iterator);
                return FALSE;
            }

            if (dos_drive_name->QueryChCount() == 2) {
                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_drive_name,
                                                           &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }
                if (!AUTOREG::DeleteEntry(&cmd_line2, &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }
                if (!cmd_line.Strcat(&option) ||
                    !cmd_line.Strcat(dos_drive_name->QueryString(0, 1))) {
                    DELETE(iterator);
                    return FALSE;
                }
            } else {
                if (!cmd_line.Strcat(&option) ||
                    !cmd_line.Strcat(dos_volume_name)) {
                    DELETE(iterator);
                    return FALSE;
                }
            }
        }

        DELETE(iterator);

        DSTRING star;

        if (!star.Initialize(" *") ||
            !cmd_line.Strcat(&star)) {
            return FALSE;
        }

        //  Add the new command line.

        return AUTOREG::AddEntry(&cmd_line);
    }

    //
    //  This loop handles the "schedule check" and default actions.
    //


    while (NULL != (mptuple = (PMOUNT_POINT_TUPLE)iterator->GetNext())) {

        display_drive_string = &(mptuple->_DeviceName);
        dos_volume_name = &(mptuple->_VolumeName);
        dos_drive_name = &(mptuple->_DriveName);

        if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_volume_name,
                                                   &nt_drive_name)) {
            DELETE(iterator);
            return FALSE;
        }

        //
        //  Schedule check:  Put a line in the registry like
        //  "autocheck autochk \??\X:" for each command-line argument.
        //

        if (_schedule_check) {

            if (!IFS_SYSTEM::QueryFileSystemName(&nt_drive_name, &fs_name, NULL)) {

                DisplayMessage(MSG_CHKNTFS_CANNOT_CHECK, NORMAL_MESSAGE,
                               "%W", display_drive_string);
                DELETE(iterator);
                return FALSE;
            }

            if (fs_name == ntfs_str ||
                fs_name == fat_str ||
                fs_name == fat32_str) {

                if (!cmd_line.Initialize("autocheck autochk") ||
                    !AUTOREG::DeleteEntry(&cmd_line, &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }

                if (dos_drive_name->QueryChCount() == 2) {
                    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_drive_name,
                                                               &nt_drive_name)) {
                        DELETE(iterator);
                        return FALSE;
                    }
                    if (!cmd_line.Initialize("autocheck autochk") ||
                        !AUTOREG::DeleteEntry(&cmd_line, &nt_drive_name)) {
                        DELETE(iterator);
                        return FALSE;
                    }
                }

                if (!cmd_line.Initialize("autocheck autochk /m ") ||
                    !cmd_line.Strcat(&nt_drive_name) ||
                    !AUTOREG::PushEntry(&cmd_line)) {
                    DELETE(iterator);
                    return FALSE;
                }
            } else {
                DisplayMessage(MSG_CHKNTFS_SKIP_DRIVE_RAW, NORMAL_MESSAGE,
                               "%W", display_drive_string);
            }

            continue;
        }

        //
        //  Default:  check to see if the volume is dirty.
        //

        if (IFS_SYSTEM::QueryFileSystemName(&nt_drive_name, &fs_name,
                                            NULL, &fs_name_and_version)) {

            DisplayMessage(MSG_FILE_SYSTEM_TYPE, NORMAL_MESSAGE,
                           "%W", &fs_name);

        }

        if (!IFS_SYSTEM::IsVolumeDirty(&nt_drive_name, &is_dirty)) {

            DisplayMessage(MSG_CHKNTFS_CANNOT_CHECK, NORMAL_MESSAGE,
                           "%W", display_drive_string);
            DELETE(iterator);
            return FALSE;

        }

        if (is_dirty) {

            DisplayMessage(MSG_CHKNTFS_DIRTY, NORMAL_MESSAGE,
                           "%W", display_drive_string);

            ExitStatus = 1;

        } else {

            DSTRING     cmd_line2;

            if (!cmd_line.Initialize("autocheck autochk") ||
                !cmd_line2.Initialize(" ") ||
                !cmd_line2.Strcat(&nt_drive_name)) {
                DELETE(iterator);
                return FALSE;
            }

            if (AUTOREG::IsFrontEndPresent(&cmd_line, &nt_drive_name)) {
                DisplayMessage(MSG_CHKNTFS_CHKDSK_WILL_RUN,
                               NORMAL_MESSAGE,
                               "%W", display_drive_string);
                continue;
            } else if (dos_drive_name->QueryChCount() == 2) {
                if (!IFS_SYSTEM::DosDriveNameToNtDriveName(dos_drive_name,
                                                           &nt_drive_name)) {
                    DELETE(iterator);
                    return FALSE;
                }
                if (AUTOREG::IsFrontEndPresent(&cmd_line, &nt_drive_name)) {
                    DisplayMessage(MSG_CHKNTFS_CHKDSK_WILL_RUN,
                                   NORMAL_MESSAGE,
                                   "%W", display_drive_string);
                    continue;
                }
            }
            DisplayMessage(MSG_CHKNTFS_CLEAN, NORMAL_MESSAGE,
                           "%W", display_drive_string);
        }
    }

    DELETE(iterator);
    return TRUE;
}

VOID __cdecl
main()
{
    DEFINE_CLASS_DESCRIPTOR(CHKNTFS);

    {
        CHKNTFS     ChkNtfs;

        if (!ChkNtfs.Initialize() ||
            !ChkNtfs.CheckNtfs()) {

            exit(2);
        }

        exit(ChkNtfs.ExitStatus);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cipher\makefile.inc ===
msg.h msg.rc msg00001.bin: msg.mc
    mc -v msg.mc

$(NTTARGETFILE0): msg.rc msg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\chkdsk\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

MAJORCOMP=utils
MINORCOMP=chkdsk

TARGETNAME=chkdsk
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\chkdsk.cxx ..\chkdsk.rc

LINKER_FLAGS=$(LINKER_FLAGS) -LARGEADDRESSAWARE

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

!IF defined(CHKDSK_PRE_RELEASE_NOTICE)
C_DEFINES=$(C_DEFINES) /DPRE_RELEASE_NOTICE
!ENDIF

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF


MSC_WARNING_LEVEL=/W3 /WX

UMLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\compact\makefile.inc ===
msg.h msg.rc msg00001.bin: msg.mc
    mc -v msg.mc

$(NTTARGETFILE0): msg.rc msg.h msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cipher\cipher.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    cipher.c

Abstract:

    This module implements the encryption utility for encrypted
    NTFS files.

Author:

    Robert Reichel     [RobertRe]        28-Feb-1997
    Robert Gu          [RobertG]         24-Mar-1998

Revision History:

    Code reused from compact.exe, file compression utility


--*/

//
// Include the standard header files.
//

//#define UNICODE
//#define _UNICODE

#include <windows.h>
#include <stdio.h>

#include <winioctl.h>
#include <shellapi.h>
#include <winefs.h>
#include <malloc.h>

#include <rc4.h>
#include <randlib.h>    // NewGenRandom() - Win2k and whistler
#include <rpc.h>
#include <wincrypt.h>

#include "support.h"
#include "msg.h"

#define lstrchr wcschr
#define lstricmp _wcsicmp
#define lstrnicmp _wcsnicmp

//
//  FIRST_COLUMN_WIDTH - When encrypting files, the width of the output
//  column which displays the file name
//

#define FIRST_COLUMN_WIDTH  (20)
#define ENUMPATHLENGTH      (4096)
#define DosDriveLimitCount  (26)

#define PASSWORDLEN         1024
#define UserChooseYes       0
#define UserChooseNo        1
#define ChoiceNotDefined    3

#define KEYPATH  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\EFS\\CurrentKeys")
#define KEYPATHROOT HKEY_CURRENT_USER
#define CERT_HASH      TEXT("CertificateHash")

#define WIPING_DIR  TEXT("EFSTMPWP\\")

#define RANDOM_BYTES(pv, cb)    NewGenRandom(NULL, NULL, pv, cb)

#define YEARCOUNT (LONGLONG) 10000000*3600*24*365 // One Year's tick count

//
// Local data structure
//

typedef struct _CIPHER_VOLUME_INFO {
    LPWSTR      VolumeName[DosDriveLimitCount];
    LPWSTR      DosDeviceName[DosDriveLimitCount];
} CIPHER_VOLUME_INFO, *PCIPHER_VOLUME_INFO;

//
//
// definitions for initializing and working with random fill data.
//

typedef struct {
    RC4_KEYSTRUCT       Key;
    CRITICAL_SECTION    Lock;
    BOOL                LockValid;
    PBYTE               pbRandomFill;
    DWORD               cbRandomFill;
    LONG                cbFilled;
    BOOLEAN             fRandomFill;    // is fill randomized?
} SECURE_FILL_INFO, *PSECURE_FILL_INFO;

//  Local procedure types
//

typedef BOOLEAN (*PACTION_ROUTINE) (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    );

typedef VOID (*PFINAL_ACTION_ROUTINE) (
    );


//
//  Declare global variables to hold the command line information
//

BOOLEAN DoSubdirectories      = FALSE;      // recurse
BOOLEAN IgnoreErrors          = FALSE;      // keep going despite errs
BOOLEAN UserSpecifiedFileSpec = FALSE;
BOOLEAN ForceOperation        = FALSE;      // encrypt/decrypt even if already so
BOOLEAN Quiet                 = FALSE;      // be less verbose
BOOLEAN DisplayAllFiles       = FALSE;      // dsply hidden, system?
BOOLEAN DoFiles               = FALSE;      // operation for files "/a"
BOOLEAN SetUpNewUserKey       = FALSE;      // Set up new user key
BOOLEAN RefreshUserKeyOnFiles = FALSE;      // Refresh User Key on EFS files
BOOLEAN DisplayFilesOnly      = FALSE;      // Do not refresh $EFS, just display the file names
BOOLEAN FillUnusedSpace       = FALSE;      // Fill unused disk space with random data
BOOLEAN GenerateDRA           = FALSE;      // Generate Data Recovery Certificate files
TCHAR   StartingDirectory[MAX_PATH];        // parameter to "/s"
ULONG   AttributesNoDisplay = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;

BOOLEAN DisplayUseOptionW     = FALSE;

//
//  Declare global variables to hold encryption statistics
//

LARGE_INTEGER TotalDirectoryCount;
LARGE_INTEGER TotalFileCount;

TCHAR Buf[1024];                            // for displaying stuff

SECURE_FILL_INFO    GlobalSecureFill;
BOOLEAN             GlobalSecureFillInitialized;

#if 0
#define TestOutPut
#endif

//
//  Now do the routines to list the encryption state and size of
//  a file and/or directory
//

BOOLEAN
DisplayFile (
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )
{
    TCHAR PrintState;


    //
    //  Decide if the file is compressed and if so then
    //  get the compressed file size.
    //

    if (FindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

        PrintState = 'E';

    } else {

        PrintState = 'U';
    }

    //
    //  Print out the encryption state and file name
    //

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {

        swprintf(Buf, TEXT("%c %s",), PrintState, FindData->cFileName);
        DisplayMsg(CIPHER_THROW_NL, Buf);
    }

    TotalFileCount.QuadPart += 1;

    return TRUE;
}



BOOLEAN
DoListAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen(DirectorySpec);

    //
    //  List the encryption attribute for the directory
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if (0xFFFFFFFF == Attributes) {

                if (!Quiet || !IgnoreErrors) {

                    //
                    // Refrain from displaying error only when in quiet
                    // mode *and* we're ignoring errors.
                    //

                    DisplayErr(DirectorySpec, GetLastError());
                }

                if (!IgnoreErrors) {
                    return FALSE;
                }
            } else {

                if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {
                    DisplayMsg(CIPHER_LIST_EDIR, DirectorySpec);
                } else {
                    DisplayMsg(CIPHER_LIST_UDIR, DirectorySpec);
                }
            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and list its encryption state
    //

    {
        HANDLE FindHandle;
        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        //
        //  Make sure we don't try any paths that are too long for us
        //  to deal with.
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

            lstrcpy( DirectorySpecEnd, FileSpec );

            FindHandle = FindFirstFile( DirectorySpec, &FindData );

            if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  append the found file to the directory spec and open the
                   //  file
                   //

                   if (0 == lstrcmp(FindData.cFileName, TEXT("..")) ||
                       0 == lstrcmp(FindData.cFileName, TEXT("."))) {
                       continue;
                   }

                   //
                   //  Make sure we don't try any paths that are too long for us
                   //  to deal with.
                   //

                   if ((DirectorySpecEnd - DirectorySpec) +
                       lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                       continue;
                   }

                   lstrcpy( DirectorySpecEnd, FindData.cFileName );

                   //
                   //  Now print out the state of the file
                   //

                   DisplayFile( DirectorySpec, &FindData );

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  For if we are to do subdirectores then we will look for every
    //  subdirectory and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoListAction( DirectorySpec, FileSpec )) {

                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalListAction (
    )
{
    return;
}


BOOLEAN
EncryptAFile (
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )

{
    USHORT State = 1;
    ULONG i;
    BOOL Success;
    double f = 1.0;

    if ((FindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
        !ForceOperation) {

        return TRUE;
    }

//    Success = DeviceIoControl(Handle, FSCTL_SET_COMPRESSION, &State,
//        sizeof(USHORT), NULL, 0, &Length, FALSE );

    if ( (0 == (FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) && (!DoFiles)) {

        //
        // Skip the files
        //

        return TRUE;
    }


    Success = EncryptFile( FileSpec );

    if (!Success) {

        if (Quiet && IgnoreErrors) {
            return FALSE || IgnoreErrors;
        }

        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(CIPHER_THROW, Buf);

        for (i = lstrlen(FindData->cFileName) + 1; i < FIRST_COLUMN_WIDTH; ++i) {
            swprintf(Buf, TEXT("%c"), ' ');
            DisplayMsg(CIPHER_THROW, Buf);
        }

        DisplayMsg(CIPHER_ERR);

        if (!Quiet && !IgnoreErrors) {
            if (ERROR_INVALID_FUNCTION == GetLastError()) {

                // This error is caused by doing the fsctl on a
                // non-encrypting volume.

                DisplayMsg(CIPHER_WRONG_FILE_SYSTEM, FindData->cFileName);

            } else {
                DisplayErr(FindData->cFileName, GetLastError());
            }
        }

        return FALSE || IgnoreErrors;
    }

    if (!DisplayUseOptionW && ( 0 == (FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))){

        DisplayUseOptionW = TRUE;

    }

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {
        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(CIPHER_THROW, Buf);

        for (i = lstrlen(FindData->cFileName) + 1; i < FIRST_COLUMN_WIDTH; ++i) {
            swprintf(Buf, TEXT("%c"), ' ');
            DisplayMsg(CIPHER_THROW, Buf);
        }

        DisplayMsg(CIPHER_OK);
    }

    TotalFileCount.QuadPart += 1;

    return TRUE;
}

BOOLEAN
DoEncryptAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  If the file spec is null then we'll set the encryption bit for the
    //  the directory spec and get out.
    //

    if (lstrlen(FileSpec) == 0) {

        USHORT State = 1;
        ULONG Length;

        DisplayMsg(CIPHER_ENCRYPT_DIR, DirectorySpec);

        if (!EncryptFile( DirectorySpec )) {

            if (!Quiet || !IgnoreErrors) {
                DisplayMsg(CIPHER_ERR);
            }
            if (!Quiet && !IgnoreErrors) {
                DisplayErr(DirectorySpec, GetLastError());
            }
            return FALSE || IgnoreErrors;
        }

        if (!Quiet) {
            DisplayMsg(CIPHER_OK);
        }

        TotalDirectoryCount.QuadPart += 1;
        TotalFileCount.QuadPart += 1;

        return TRUE;
    }

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec );

    //
    //  List the directory that we will be encrypting within and say what its
    //  current encryption attribute is.
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if ( DoFiles ) {

                if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {


                    DisplayMsg(CIPHER_ENCRYPT_EDIR, DirectorySpec);

                } else {

                    DisplayMsg(CIPHER_ENCRYPT_UDIR, DirectorySpec);

                }

            } else {

                if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {


                    DisplayMsg(CIPHER_ENCRYPT_EDIR_NF, DirectorySpec);

                } else {

                    DisplayMsg(CIPHER_ENCRYPT_UDIR_NF, DirectorySpec);

                }

            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and encrypt it
    //

    {
        HANDLE FindHandle;
        HANDLE FileHandle;

        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, FileSpec );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ( (DirectorySpecEnd - DirectorySpec) +
                           lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                           continue;
                       }

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //


                       lstrcpy( DirectorySpecEnd, FindData.cFileName );

                       //
                       //  Hack hack, kludge kludge.  Refrain from compressing
                       //  files named "\NTDLR" to help users avoid hosing
                       //  themselves.
                       //

                       if (IsNtldr(DirectorySpec)) {

                           if (!Quiet) {
                               DisplayMsg(CIPHER_SKIPPING, DirectorySpecEnd);
                           }

                           continue;
                       }

                       EncryptAFile( DirectorySpec, &FindData );

                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  If we are to do subdirectores then we will look for every subdirectory
    //  and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoEncryptAction( DirectorySpec, FileSpec )) {
                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalEncryptAction (
    )
{
    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);

    if ( DoFiles ) {
        DisplayMsg(CIPHER_ENCRYPT_SUMMARY, FileCount, DirectoryCount);
        if (DisplayUseOptionW) {
            DisplayMsg(CIPHER_USE_W);
        }
    } else {
        DisplayMsg(CIPHER_ENCRYPT_SUMMARY_NF, FileCount, DirectoryCount);
    }
    return;

}


BOOLEAN
DecryptAFile (
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )
{
    USHORT State = 0;
    ULONG Length;

    if (!(FindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
        !ForceOperation) {

        return TRUE;
    }


    if ( (0 == (FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) && (!DoFiles)) {

        //
        // Skip the files
        //

        return TRUE;
    }

    if (!DecryptFile(FileSpec, 0L )) {

        if (!Quiet || !IgnoreErrors) {

            swprintf(Buf, TEXT("%s "), FindData->cFileName);
            DisplayMsg(CIPHER_THROW, Buf);

            DisplayMsg(CIPHER_ERR);

            if (!Quiet && !IgnoreErrors) {

                if (ERROR_INVALID_FUNCTION == GetLastError()) {

                    // This error is caused by doing the fsctl on a
                    // non-compressing volume.

                    DisplayMsg(CIPHER_WRONG_FILE_SYSTEM, FindData->cFileName);

                } else {
                    DisplayErr(FindData->cFileName, GetLastError());
                }
            }
        }
        return FALSE || IgnoreErrors;
    }

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {
        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(CIPHER_THROW, Buf);

        DisplayMsg(CIPHER_OK);
    }

    //
    //  Increment our running total
    //

    TotalFileCount.QuadPart += 1;

    return TRUE;
}

BOOLEAN
DoDecryptAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  If the file spec is null then we'll clear the encryption bit for the
    //  the directory spec and get out.
    //

    if (lstrlen(FileSpec) == 0) {

        HANDLE FileHandle;
        USHORT State = 0;
        ULONG Length;

        DisplayMsg(CIPHER_DECRYPT_DIR, DirectorySpec);

        if (!DecryptFile( DirectorySpec, 0L )) {

            if (!Quiet || !IgnoreErrors) {
                DisplayMsg(CIPHER_ERR);

            }
            if (!Quiet && !IgnoreErrors) {
                DisplayErr(DirectorySpec, GetLastError());
            }

            return FALSE || IgnoreErrors;
        }

        if (!Quiet) {
            DisplayMsg(CIPHER_OK);
        }


        TotalDirectoryCount.QuadPart += 1;
        TotalFileCount.QuadPart += 1;

        return TRUE;
    }

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec );

    //
    //  List the directory that we will be uncompressing within and say what its
    //  current compress attribute is
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if ( DoFiles) {

                if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {

                    DisplayMsg(CIPHER_DECRYPT_EDIR, DirectorySpec);

                } else {

                    DisplayMsg(CIPHER_DECRYPT_UDIR, DirectorySpec);
                }

            } else {

                if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {

                    DisplayMsg(CIPHER_DECRYPT_EDIR_NF, DirectorySpec);

                } else {

                    DisplayMsg(CIPHER_DECRYPT_UDIR_NF, DirectorySpec);
                }

            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and uncompress it
    //

    {
        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, FileSpec );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ((DirectorySpecEnd - DirectorySpec) +
                           lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                           continue;
                       }

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //

                       lstrcpy( DirectorySpecEnd, FindData.cFileName );

                       //
                       //  Now decrypt the file
                       //

                       DecryptAFile( DirectorySpec, &FindData );

                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  If we are to do subdirectores then we will look for every subdirectory
    //  and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );
           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoDecryptAction( DirectorySpec, FileSpec )) {
                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalDecryptAction (
    )

{
    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);

    if (DoFiles) {
        DisplayMsg(CIPHER_DECRYPT_SUMMARY, FileCount, DirectoryCount);
    } else {
        DisplayMsg(CIPHER_DECRYPT_SUMMARY_NF, FileCount, DirectoryCount);
    }

    return;
}


VOID
CipherConvertHashToStr(
    IN PBYTE pHashData,
    IN DWORD cbData,
    OUT LPWSTR OutHashStr
    )
{

    DWORD Index = 0;
    BOOLEAN NoLastZero = FALSE;

    for (; Index < cbData; Index+=2) {

        BYTE HashByteLow = pHashData[Index] & 0x0f;
        BYTE HashByteHigh = (pHashData[Index] & 0xf0) >> 4;

        OutHashStr[Index * 5/2] = HashByteHigh > 9 ? (WCHAR)(HashByteHigh - 9 + 0x40): (WCHAR)(HashByteHigh + 0x30);
        OutHashStr[Index * 5/2 + 1] = HashByteLow > 9 ? (WCHAR)(HashByteLow - 9 + 0x40): (WCHAR)(HashByteLow + 0x30);

        if (Index + 1 < cbData) {
            HashByteLow = pHashData[Index+1] & 0x0f;
            HashByteHigh = (pHashData[Index+1] & 0xf0) >> 4;
    
            OutHashStr[Index * 5/2 + 2] = HashByteHigh > 9 ? (WCHAR)(HashByteHigh - 9 + 0x40): (WCHAR)(HashByteHigh + 0x30);
            OutHashStr[Index * 5/2 + 3] = HashByteLow > 9 ? (WCHAR)(HashByteLow - 9 + 0x40): (WCHAR)(HashByteLow + 0x30);
    
            OutHashStr[Index * 5/2 + 4] = L' ';

        } else {
            OutHashStr[Index * 5/2 + 2] = 0;
            NoLastZero = TRUE;
        }

    }

    if (!NoLastZero) {
        OutHashStr[Index*5/2] = 0;
    }

}

VOID
CipherDisplayCrntEfsHash(
    )
{

    DWORD rc;
    HKEY hRegKey = NULL;
    PBYTE pbHash;
    DWORD cbHash;

    DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1;
    WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    if (!GetComputerName ( LocalComputerName, &nSize )){

        //
        //  This is not likely to happen.
        //

        return;
    }

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             KEYPATH,
             0,
             GENERIC_READ,
             &hRegKey
             );

    if (rc == ERROR_SUCCESS) {

        DWORD Type;

        rc = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                &cbHash
                );

        if (rc == ERROR_SUCCESS) {

            //
            // Query out the thumbprint, find the cert, and return the key information.
            //

            if (pbHash = (PBYTE)malloc( cbHash )) {

                rc = RegQueryValueEx(
                        hRegKey,
                        CERT_HASH,
                        NULL,
                        &Type,
                        pbHash,
                        &cbHash
                        );


                if (rc == ERROR_SUCCESS) {
            
                    LPWSTR OutHash;


                    OutHash = (LPWSTR) malloc(((((cbHash + 1)/2) * 5)+1) * sizeof(WCHAR));
                    if (OutHash) {
                
                        CipherConvertHashToStr(pbHash, cbHash, OutHash);
                        DisplayMsg(CIPHER_CURRENT_CERT, LocalComputerName, OutHash);
                        free(OutHash);
                
                    }
                }
                free(pbHash);
            }
        }
        RegCloseKey( hRegKey );
    }
    return;
}

BOOL
CipherConvertToDriveLetter(
    IN OUT LPWSTR VolBuffer, 
    IN     PCIPHER_VOLUME_INFO VolumeInfo
    )
{
    WCHAR DeviceName[MAX_PATH];
    WORD DriveIndex = 0;

    while (DriveIndex < DosDriveLimitCount) {
        if (VolumeInfo->VolumeName[DriveIndex]) {
            if (!wcscmp(VolBuffer, VolumeInfo->VolumeName[DriveIndex])) {
                lstrcpy(VolBuffer, TEXT("A:\\"));
                VolBuffer[0] += DriveIndex;
                return TRUE;
            }

            VolBuffer[48] = 0;
            if (VolumeInfo->DosDeviceName[DriveIndex] && QueryDosDevice( &(VolBuffer[4]), DeviceName, MAX_PATH)) {
    
                if (!wcscmp(DeviceName, VolumeInfo->DosDeviceName[DriveIndex])) {
                    lstrcpy(VolBuffer, TEXT("A:\\"));
                    VolBuffer[0] += DriveIndex;
                    return TRUE;
                }

    
            }
        }
        DriveIndex++;
    }

    return FALSE;

}

VOID
CipherTouchDirFiles(
    IN WCHAR *DirPath,
    IN PCIPHER_VOLUME_INFO VolumeInfo
    )
{
    
    PTCHAR DirectorySpecEnd;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    HANDLE hFile;


    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //


    DirectorySpecEnd = DirPath + lstrlen( DirPath );



    //
    //  setup the template for findfirst/findnext
    //

    if ((DirectorySpecEnd - DirPath)  < ENUMPATHLENGTH - 2* sizeof(WCHAR)) {

       lstrcpy( DirectorySpecEnd, TEXT("*") );

       FindHandle = FindFirstFile( DirPath, &FindData );

       if (INVALID_HANDLE_VALUE != FindHandle) {

           do {

               //
               //  Now skip over the . and .. entries
               //

               if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                   0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                   continue;

               } else {

                   //
                   //  Make sure we don't try any paths that are too long for us
                   //  to deal with.
                   //

                   if ((DirectorySpecEnd - DirPath) +
                            lstrlen( FindData.cFileName ) >= ENUMPATHLENGTH ) {

                       continue;
                   }

                   if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (FindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //
    
                       lstrcpy( DirectorySpecEnd, FindData.cFileName );
    
                       //
                       //  Now touch the file
                       //

                       if (DisplayFilesOnly) {
                           //swprintf(Buf, TEXT("%s",), DirPath);
                           DisplayMsg(CIPHER_THROW_NL, DirPath);
                       } else {

                           hFile = CreateFileW(
                                        DirPath,
                                        GENERIC_READ,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL
                                        );
    
                           if ( INVALID_HANDLE_VALUE != hFile ){
    
                               DisplayMsg(CIPHER_TOUCH_OK, DirPath);
    
                               CloseHandle(hFile);
    
                           } else {
    
                               DisplayErr(DirPath, GetLastError());
    
                           }
                       }
    
                   }

               }

           } while ( FindNextFile( FindHandle, &FindData ));

           FindClose( FindHandle );
       }
    }


    //
    //  Setup findfirst/findnext to search the sub directory
    //

    if ((DirectorySpecEnd - DirPath)  < ENUMPATHLENGTH - 2* sizeof(WCHAR)) {

       lstrcpy( DirectorySpecEnd, TEXT("*") );

       FindHandle = FindFirstFile( DirPath, &FindData );
       if (INVALID_HANDLE_VALUE != FindHandle) {

           do {

               //
               //  Now skip over the . and .. entries otherwise we'll recurse
               //  like mad
               //

               if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                   0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                   continue;

               } else {

                   //
                   //  If the entry is for a directory then we'll tack on the
                   //  subdirectory name to the directory spec and recursively
                   //  call otherselves
                   //

                   if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                       BOOL  b;
                       WCHAR MountVolName[MAX_PATH];

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ((DirectorySpecEnd - DirPath) +
                           lstrlen( TEXT("\\") ) +
                           lstrlen( FindData.cFileName ) >= ENUMPATHLENGTH ) {

                           continue;
                       }

                       lstrcpy( DirectorySpecEnd, FindData.cFileName );
                       lstrcat( DirectorySpecEnd, TEXT("\\") );

                       //
                       // Check if this DIR point to another volume
                       //


                       b = GetVolumeNameForVolumeMountPoint(DirPath, MountVolName, MAX_PATH);
                       if (b) {
                           if (CipherConvertToDriveLetter(MountVolName, VolumeInfo)){
                               continue;
                           }
                       }

                       CipherTouchDirFiles(DirPath, VolumeInfo);

                   }
               }

           } while ( FindNextFile( FindHandle, &FindData ));

           FindClose( FindHandle );
       }
    }

}

DWORD
CipherTouchEncryptedFiles(
                          )
{

    WCHAR  VolBuffer[MAX_PATH];
    WCHAR  *SearchPath = NULL;
    HANDLE SearchHandle;
    BOOL   SearchNext = TRUE;
    CIPHER_VOLUME_INFO VolumeInfo;
    LPWSTR VolumeNames;
    LPWSTR VolumeNamesCrnt;
    LPWSTR DosDeviceNames;
    LPWSTR DosDeviceNamesCrnt;
    DWORD  DriveIndex = 0;
    WCHAR  TmpChar;
    BOOL   b;

    VolumeNames = (LPWSTR) malloc ( DosDriveLimitCount * MAX_PATH * sizeof(WCHAR) );
    DosDeviceNames = (LPWSTR) malloc ( DosDriveLimitCount * MAX_PATH * sizeof(WCHAR) );

    if ( !VolumeNames || !DosDeviceNames) {
        if (VolumeNames) {
            free(VolumeNames);
        }
        if (DosDeviceNames) {
            free(DosDeviceNames);
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Don't popup when query floopy and etc.
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);
    lstrcpy(VolBuffer, TEXT("A:\\"));
    VolumeNamesCrnt = VolumeNames;
    DosDeviceNamesCrnt = DosDeviceNames;

    //
    //  Get all the volume and device names which has a drive letter assigned
    //

    while (DriveIndex < DosDriveLimitCount) {

        b = GetVolumeNameForVolumeMountPoint( VolBuffer, 
                                              VolumeNamesCrnt, 
                                              (DWORD)(VolumeNames + DosDriveLimitCount * MAX_PATH - VolumeNamesCrnt));
        if (!b) {
            VolumeInfo.VolumeName[DriveIndex] = NULL;
            VolumeInfo.DosDeviceName[DriveIndex++] = NULL;
            VolBuffer[0]++;
            continue;
        }

        VolumeInfo.VolumeName[DriveIndex] = VolumeNamesCrnt;
        VolumeNamesCrnt += lstrlen(VolumeNamesCrnt) + 1;

        //
        //  The number 48 is copied from utils\mountvol\mountvol.c
        //

        TmpChar = VolumeInfo.VolumeName[DriveIndex][48];
        VolumeInfo.VolumeName[DriveIndex][48] = 0;
        if (QueryDosDevice( &(VolumeInfo.VolumeName[DriveIndex][4]), 
                            DosDeviceNamesCrnt, 
                            (DWORD)(DosDeviceNames + DosDriveLimitCount * MAX_PATH - DosDeviceNamesCrnt))) {

            VolumeInfo.DosDeviceName[DriveIndex] = DosDeviceNamesCrnt;
            DosDeviceNamesCrnt += lstrlen(DosDeviceNamesCrnt) + 1;

        } else {
            VolumeInfo.DosDeviceName[DriveIndex] = NULL;
        }

        VolumeInfo.VolumeName[DriveIndex][48] = TmpChar;
        VolBuffer[0]++;
        DriveIndex++;

    }


    SearchPath = (WCHAR *) malloc( ENUMPATHLENGTH * sizeof(WCHAR) );
    if (!SearchPath) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SearchHandle = FindFirstVolume(VolBuffer, MAX_PATH);

    if ( INVALID_HANDLE_VALUE != SearchHandle ) {

        if (DisplayFilesOnly) {

            DisplayMsg(CIPHER_ENCRYPTED_FILES, NULL);

        }

        while ( SearchNext ) {
    
            if (CipherConvertToDriveLetter(VolBuffer, &VolumeInfo)){

                //
                // Check if this volume is a NTFS volume
                //

                if(GetVolumeInformation(
                        VolBuffer, // Current root directory.
                        NULL, // Volume name.
                        0, // Volume name length.
                        NULL, // Serial number.
                        NULL, // Maximum length.
                        NULL,
                        SearchPath, // File system type.
                        MAX_PATH
                        )){
                    if(!wcscmp(SearchPath, TEXT("NTFS"))){
        
                        lstrcpy( SearchPath, VolBuffer );
                        CipherTouchDirFiles(SearchPath, &VolumeInfo);

                    }
                }
            }
            SearchNext =  FindNextVolume(SearchHandle, VolBuffer, MAX_PATH);

        }
        FindVolumeClose(SearchHandle);
    }

    free(SearchPath);
    free(VolumeNames);
    free(DosDeviceNames);
    return ERROR_SUCCESS;
}


BOOL
EncodeAndAlloc(
    DWORD dwEncodingType,
    LPCSTR lpszStructType,
    const void * pvStructInfo,
    PBYTE * pbEncoded,
    PDWORD pcbEncoded
    )
{
    BOOL b = FALSE;

    if (CryptEncodeObject(
          dwEncodingType,
          lpszStructType,
          pvStructInfo,
          NULL,
          pcbEncoded )) {

        *pbEncoded = (PBYTE)malloc( *pcbEncoded );

        if (*pbEncoded) {

            if (CryptEncodeObject(
                  dwEncodingType,
                  lpszStructType,
                  pvStructInfo,
                  *pbEncoded,
                  pcbEncoded )) {

                b = TRUE;

            } else {

                free( *pbEncoded );
                *pbEncoded = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return( b );
}


BOOLEAN
CreateSelfSignedRecoveryCertificate(
    OUT PCCERT_CONTEXT * pCertContext,
    OUT LPWSTR *lpContainerName,
    OUT LPWSTR *lpProviderName
    )
/*++

Routine Description:

    This routine sets up and creates a self-signed certificate.

Arguments:


Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    BOOLEAN fReturn = FALSE;
    DWORD rc = ERROR_SUCCESS;

    PBYTE  pbHash          = NULL;
    LPWSTR lpDisplayInfo   = NULL;

    HCRYPTKEY hKey = 0;
    HCRYPTPROV hProv = 0;
    GUID    guidContainerName;
    LPWSTR  TmpContainerName;

    *pCertContext = NULL;
    *lpContainerName = NULL;
    *lpProviderName  = NULL;

    //
    // Create a key pair
    //

    //
    // Container name
    //




    if ( ERROR_SUCCESS != UuidCreate(&guidContainerName) ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(fReturn);
    }


    if (ERROR_SUCCESS == UuidToStringW(&guidContainerName, (unsigned short **)lpContainerName )) {

        //
        // Copy the container name into LSA heap memory
        //

        *lpProviderName = MS_DEF_PROV;

        //
        // Create the key container
        //

        if (CryptAcquireContext(&hProv, *lpContainerName, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET )) {

            if (CryptGenKey(hProv, AT_KEYEXCHANGE, RSA1024BIT_KEY | CRYPT_EXPORTABLE, &hKey)) {

                DWORD NameLength = 64;
                LPWSTR AgentName = NULL;

                //
                // Construct the subject name information
                //

                //lpDisplayInfo = MakeDNName();

                AgentName = (LPWSTR)malloc(NameLength * sizeof(WCHAR));
                if (AgentName){
                    if (!GetUserName(AgentName, &NameLength)){
                        free(AgentName);
                        AgentName = (LPWSTR)malloc(NameLength * sizeof(WCHAR));

                        //
                        // Try again with big buffer
                        //

                        if ( AgentName ){

                            if (!GetUserName(AgentName, &NameLength)){
                                rc = GetLastError();
                                free(AgentName);
                                AgentName = NULL;
                            }

                        } else {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                if (AgentName) {

                    LPCWSTR     DNNameTemplate = L"CN=%ws,L=EFS,OU=EFS File Encryption Certificate";
                    DWORD       cbDNName = 0;

                    cbDNName = (wcslen( DNNameTemplate ) + 1) * sizeof( WCHAR ) + (wcslen( AgentName ) + 1) * sizeof( WCHAR );
                    lpDisplayInfo = (LPWSTR)malloc( cbDNName );
                    if (lpDisplayInfo) {
                        swprintf( lpDisplayInfo, DNNameTemplate, AgentName );
                    } else {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    free(AgentName);
                    AgentName = NULL;

                }

                if (lpDisplayInfo) {

                    //
                    // Use this piece of code to create the PCERT_NAME_BLOB going into CertCreateSelfSignCertificate()
                    //

                    CERT_NAME_BLOB SubjectName;

                    SubjectName.cbData = 0;

                    if(CertStrToNameW(
                           CRYPT_ASN_ENCODING,
                           lpDisplayInfo,
                           0,
                           NULL,
                           NULL,
                           &SubjectName.cbData,
                           NULL)) {

                        SubjectName.pbData = (BYTE *) malloc(SubjectName.cbData);

                        if (SubjectName.pbData) {

                            if (CertStrToNameW(
                                    CRYPT_ASN_ENCODING,
                                    lpDisplayInfo,
                                    0,
                                    NULL,
                                    SubjectName.pbData,
                                    &SubjectName.cbData,
                                    NULL) ) {

                                //
                                // Make the enhanced key usage
                                //

                                CERT_ENHKEY_USAGE certEnhKeyUsage;
                                LPSTR lpstr;
                                CERT_EXTENSION certExt;

                                lpstr = szOID_EFS_RECOVERY;
                                certEnhKeyUsage.cUsageIdentifier = 1;
                                certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;

                                // now call CryptEncodeObject to encode the enhanced key usage into the extension struct

                                certExt.Value.cbData = 0;
                                certExt.Value.pbData = NULL;
                                certExt.fCritical = FALSE;
                                certExt.pszObjId = szOID_ENHANCED_KEY_USAGE;

                                //
                                // Encode it
                                //

                                if (EncodeAndAlloc(
                                        CRYPT_ASN_ENCODING,
                                        X509_ENHANCED_KEY_USAGE,
                                        &certEnhKeyUsage,
                                        &certExt.Value.pbData,
                                        &certExt.Value.cbData
                                        )) {

                                    //
                                    // finally, set up the array of extensions in the certInfo struct
                                    // any further extensions need to be added to this array.
                                    //

                                    CERT_EXTENSIONS certExts;
                                    CRYPT_KEY_PROV_INFO KeyProvInfo;
                                    SYSTEMTIME  StartTime;
                                    FILETIME    FileTime;
                                    LARGE_INTEGER TimeData;
                                    SYSTEMTIME  EndTime;

                                    certExts.cExtension = 1;
                                    certExts.rgExtension = &certExt;


                                    memset( &KeyProvInfo, 0, sizeof( CRYPT_KEY_PROV_INFO ));

                                    KeyProvInfo.pwszContainerName = *lpContainerName;
                                    KeyProvInfo.pwszProvName      = *lpProviderName;
                                    KeyProvInfo.dwProvType        = PROV_RSA_FULL;
                                    KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;


                                    GetSystemTime(&StartTime);
                                    SystemTimeToFileTime(&StartTime, &FileTime);
                                    TimeData.LowPart = FileTime.dwLowDateTime;
                                    TimeData.HighPart = (LONG) FileTime.dwHighDateTime;
                                    TimeData.QuadPart += YEARCOUNT * 100;
                                    FileTime.dwLowDateTime = TimeData.LowPart;
                                    FileTime.dwHighDateTime = (DWORD) TimeData.HighPart;

                                    FileTimeToSystemTime(&FileTime, &EndTime);

                                    *pCertContext = CertCreateSelfSignCertificate(
                                                       hProv,
                                                       &SubjectName,
                                                       0,
                                                       &KeyProvInfo,
                                                       NULL,
                                                       &StartTime,
                                                       &EndTime,
                                                       &certExts
                                                       );

                                    if (*pCertContext) {

                                        fReturn = TRUE;

                                    } else {

                                        rc = GetLastError();
                                    }

                                    free( certExt.Value.pbData );

                                } else {

                                    rc = GetLastError();
                                }

                            } else {

                                rc = GetLastError();
                            }

                            free( SubjectName.pbData );

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {

                        rc = GetLastError();
                    }

                    free( lpDisplayInfo );

                } else {

                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                CryptDestroyKey( hKey );

            } else {

                 rc = GetLastError();
            }

            CryptReleaseContext( hProv, 0 );
            hProv = 0;
            if (ERROR_SUCCESS != rc) {

                //
                // Creating cert failed. Let's delete the key container.
                //

                CryptAcquireContext(&hProv, *lpContainerName, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_SILENT );
            }

        } else {

            rc = GetLastError();
        }

        if (ERROR_SUCCESS != rc) {
            RpcStringFree( (unsigned short **)lpContainerName );
            *lpContainerName = NULL;
        }
    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }


    if (!fReturn) {

        if (*pCertContext) {
            CertFreeCertificateContext( *pCertContext );
            *pCertContext = NULL;
        }
    }

    SetLastError( rc );
    return( fReturn );
}

BOOLEAN
GetPassword(
    OUT LPWSTR *PasswordStr
    )
/*++

Routine Description:

    Input a string from stdin in the Console code page.

    We can't use fgetws since it uses the wrong code page.

Arguments:

    Buffer - Buffer to put the read string into.
        The Buffer will be zero terminated and will have any traing CR/LF removed

Return Values:

    None.

--*/
{
    int size;
    LPSTR MbcsBuffer = NULL;
    LPSTR Result;
    DWORD Mode;
    DWORD MbcsSize;
    DWORD MbcsLength;

    //
    // Allocate a local buffer to read the string into
    //  Include room for the trimmed CR/LF
    //

    MbcsSize = (PASSWORDLEN+2) * sizeof(WCHAR);
    MbcsBuffer = (LPSTR) malloc((PASSWORDLEN+2) * sizeof(WCHAR));
    *PasswordStr = (LPWSTR) malloc((PASSWORDLEN+1) * sizeof(WCHAR));

    if ( (MbcsBuffer == NULL) || (*PasswordStr == NULL) ) {

        if (MbcsBuffer) {
            free (MbcsBuffer);
        }
        if (*PasswordStr) {
            free (*PasswordStr);
        }
        DisplayMsg(CIPHER_NO_MEMORY);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    DisplayMsg(CIPHER_PROMPT_PASSWORD);

    // turn off echo
    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &Mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
          (~(ENABLE_ECHO_INPUT)) & Mode);

    Result = fgets( MbcsBuffer, MbcsSize, stdin  );

    if ( Result == NULL ) {
        SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), Mode);
        free(MbcsBuffer);
        free (*PasswordStr);
        *PasswordStr = NULL;
        return TRUE;
    }

    DisplayMsg(CIPHER_CONFIRM_PASSWORD);
    Result = fgets( (LPSTR)*PasswordStr, (PASSWORDLEN+1) * sizeof(WCHAR), stdin  );

    // turn echo back on
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), Mode);
    _putws ( L"\n" );

    if (strcmp( (LPSTR) *PasswordStr, MbcsBuffer)){

        //
        //  Password not match.
        //
        
        DisplayMsg(CIPHER_PASSWORD_NOMATCH);
        free(MbcsBuffer);
        free (*PasswordStr);
        SetLastError(ERROR_INVALID_PASSWORD);
        *PasswordStr = NULL;
        return FALSE;
    }

    if ( Result == NULL ) {
        free(MbcsBuffer);
        free (*PasswordStr);
        *PasswordStr = NULL;
        return TRUE;
    }

    //
    // Trim any trailing CR or LF char from the string
    //

    MbcsLength = lstrlenA( MbcsBuffer );
    if ( MbcsLength == 0 ) {
        free(MbcsBuffer);
        free (*PasswordStr);
        *PasswordStr = NULL;
        return TRUE;
    }

    if ( MbcsBuffer[MbcsLength-1] == '\n' || MbcsBuffer[MbcsLength-1] == '\r' ) {
        MbcsBuffer[MbcsLength-1] = '\0';
        MbcsLength --;
    }


    //
    // Convert the string to UNICODE
    //
    size = MultiByteToWideChar( GetConsoleOutputCP(),
                                0,
                                MbcsBuffer,
                                MbcsLength+1,   // Include trailing zero
                                *PasswordStr,
                                PASSWORDLEN );
    free(MbcsBuffer);

    if ( size == 0 ) {
        DisplayErr(NULL, GetLastError());
        free (*PasswordStr);
        *PasswordStr = NULL;
        return FALSE;
    }
    return TRUE;

}

DWORD
PromtUserYesNo(
     IN LPWSTR FileName,
     OUT DWORD *UserChoice
     )
{
    BOOLEAN Continue = TRUE;
    LPWSTR Result;
    LPWSTR Yesnotext;
    DWORD TextLen;

    //
    //  File exists
    //

    *UserChoice = ChoiceNotDefined;

    TextLen = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL, CIPHER_YESNOANSWER, 0, (LPVOID)&Yesnotext, 0, NULL);

    if (TextLen && Yesnotext) {

        while (TRUE) {

            WCHAR FirstChar;

            DisplayMsg(CIPHER_FILE_EXISTS, FileName);
            Result = fgetws((LPWSTR)Buf, sizeof(Buf)/sizeof (WCHAR), stdin);
            if (!Result) {

                //
                // Error or end of file. Just return.
                //

                LocalFree(Yesnotext);   
                return GetLastError();

            }

            //
            // Trim any trailing CR or LF char from the string
            //

            FirstChar = towupper(Buf[0]);
            if (Yesnotext[0] == FirstChar) {
                *UserChoice = UserChooseYes;
                break;
            } else if (Yesnotext[1] == FirstChar) {
                *UserChoice = UserChooseNo;
                break;
            }
        
        }

        LocalFree(Yesnotext);   

    } else {

        return GetLastError();

    }

    return ERROR_SUCCESS;

}


DWORD
GenerateCertFiles(
    IN  LPWSTR StartingDirectory
    )
{
    HCERTSTORE memStore;
    DWORD dwLastError = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext;
    LPWSTR ContainerName;
    LPWSTR ProviderName;
    LPWSTR CertFileName;
    LPWSTR PfxPassword;


    if (!GetPassword( &PfxPassword )){
        return GetLastError();
    }
    
    memStore = CertOpenStore(
                         CERT_STORE_PROV_MEMORY,
                         0,
                         0,
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                         NULL
                         );

    CertFileName = (LPWSTR)malloc((wcslen(StartingDirectory)+5) * sizeof(WCHAR));

    if (memStore && CertFileName) {

        //
        // Let's check if the files exist or not
        //

        wcscpy(CertFileName, StartingDirectory);
        wcscat(CertFileName, L".PFX");
        if (GetFileAttributes(CertFileName) != -1) {

            DWORD UserChoice;

            if (((dwLastError = PromtUserYesNo(CertFileName, &UserChoice)) != ERROR_SUCCESS) ||
                 (UserChoice != 0)) {

                free(CertFileName);
                CertCloseStore( memStore, 0 );
                return dwLastError;

            }

        }

        wcscpy(CertFileName, StartingDirectory);
        wcscat(CertFileName, L".CER");
        if (GetFileAttributes(CertFileName) != -1) {

            DWORD UserChoice;

            if (((dwLastError = PromtUserYesNo(CertFileName, &UserChoice)) != ERROR_SUCCESS) ||
                 (UserChoice != 0)) {

                free(CertFileName);
                CertCloseStore( memStore, 0 );
                return dwLastError;

            }

        }

        //
        // Generate the cert first
        //

        if (CreateSelfSignedRecoveryCertificate(&pCertContext, &ContainerName, &ProviderName)){

            HANDLE hFile;
            HCRYPTPROV hProv = 0;
            DWORD  BytesWritten = 0;

            //
            // We got the certificate. Let's generate the CER file first
            //

            hFile = CreateFileW(
                         CertFileName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         );
            if ( INVALID_HANDLE_VALUE != hFile) {

                //
                // Let's write out the CER file
                //


                if(!WriteFile(
                        hFile,
                        pCertContext->pbCertEncoded,
                        pCertContext->cbCertEncoded,
                        &BytesWritten,
                        NULL
                        )){

                    dwLastError = GetLastError();
                } else {
                    DisplayMsg(CIPHER_CER_CREATED);
                }

                CloseHandle(hFile);

            } else {

                dwLastError = GetLastError();

            }

            if (CertAddCertificateContextToStore(memStore, pCertContext, CERT_STORE_ADD_ALWAYS, NULL)){

                CRYPT_DATA_BLOB PFX;

                memset( &PFX, 0, sizeof( CRYPT_DATA_BLOB ));

                //
                // Asking password
                //

                if (PFXExportCertStoreEx(
                        memStore,
                        &PFX,
                        PfxPassword,
                        NULL,
                        EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY | REPORT_NO_PRIVATE_KEY)){

                    PFX.pbData = (BYTE *) malloc(PFX.cbData);

                    if (PFX.pbData) {

                        if (PFXExportCertStoreEx(
                                memStore,
                                &PFX,
                                PfxPassword,
                                NULL,
                                EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY | REPORT_NO_PRIVATE_KEY)){

                            //
                            // Write out the PFX file
                            //
                            wcscpy(CertFileName, StartingDirectory);
                            wcscat(CertFileName, L".PFX");
                
                            hFile = CreateFileW(
                                         CertFileName,
                                         GENERIC_WRITE,
                                         0,
                                         NULL,
                                         CREATE_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL
                                         );

                            if ( INVALID_HANDLE_VALUE != hFile) {
                
                                //
                                // Let's write out the CER file
                                //
                
                
                                if(!WriteFile(
                                        hFile,
                                        PFX.pbData,
                                        PFX.cbData,
                                        &BytesWritten,
                                        NULL
                                        )){
                
                                    dwLastError = GetLastError();
                                }  else {
                                    DisplayMsg(CIPHER_PFX_CREATED);
                                }

                
                                CloseHandle(hFile);
                
                            } else {
                
                                dwLastError = GetLastError();
                
                            }

                        } else {

                            dwLastError = GetLastError();

                        }

                        free( PFX.pbData );

                    } else {

                        dwLastError = ERROR_NOT_ENOUGH_MEMORY;

                    }

                } else {

                    dwLastError = GetLastError();

                }
            }


            //
            // Let's delete the key
            //

            CertFreeCertificateContext(pCertContext);
            RpcStringFree( (unsigned short **)&ContainerName );
            CryptAcquireContext(&hProv, ContainerName, ProviderName, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_SILENT );

        } else {
            dwLastError = GetLastError();
        }

        //
        // Close Store and free the 
        //

        free(CertFileName);
        CertCloseStore( memStore, 0 );

    } else {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }
    if (PfxPassword){
        free(PfxPassword);
    }

    if (ERROR_SUCCESS != dwLastError) {

        DisplayErr(NULL, dwLastError);

    }

    return dwLastError;
}

DWORD
SecureInitializeRandomFill(
    IN OUT  PSECURE_FILL_INFO   pSecureFill,
    IN      ULONG               FillSize,
    IN      PBYTE               FillValue   OPTIONAL
    )
/*++

    FillValue = NULL
    Use Random fill and random mixing logic.
    
    FillValue = valid pointer to fill byte
    Fill region with specified value, with no random mixing.


--*/

{
    DWORD dwLastError;

    __try {
        
        //
        // allocate the critical section.
        //

        InitializeCriticalSection( &pSecureFill->Lock );
    } __except (EXCEPTION_EXECUTE_HANDLER )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pSecureFill->LockValid = TRUE;

    pSecureFill->cbRandomFill = FillSize;
    pSecureFill->pbRandomFill = VirtualAlloc(
                                        NULL,
                                        FillSize,
                                        MEM_COMMIT,
                                        PAGE_READWRITE
                                        );

    if( pSecureFill->pbRandomFill != NULL )
    {
        BYTE RandomFill[256];
        
        
        if( FillValue != NULL )
        {
            memset( pSecureFill->pbRandomFill, *FillValue, pSecureFill->cbRandomFill );
            pSecureFill->fRandomFill = FALSE;
            return ERROR_SUCCESS;
        }
        
        //
        // initialize the region with initial random pad.
        //
        
        pSecureFill->fRandomFill = TRUE;

        RANDOM_BYTES( RandomFill, sizeof(RandomFill) );

        rc4_key( &pSecureFill->Key, sizeof(RandomFill), RandomFill );
        rc4( &pSecureFill->Key, pSecureFill->cbRandomFill, pSecureFill->pbRandomFill );

        //
        // initialize the key.
        //

        RANDOM_BYTES( RandomFill, sizeof(RandomFill) );
        rc4_key( &pSecureFill->Key, sizeof(RandomFill), RandomFill );

        ZeroMemory( RandomFill, sizeof(RandomFill) );
        
        return ERROR_SUCCESS;
    }

    
    dwLastError = GetLastError();

    DeleteCriticalSection( &pSecureFill->Lock );
    pSecureFill->LockValid = FALSE;

    return dwLastError;
}

VOID
SecureMixRandomFill(
    IN OUT  PSECURE_FILL_INFO   pSecureFill,
    IN      ULONG               cbBytesThisFill
    )
{
    LONG Result;
    LONG Compare;
     
    if( !pSecureFill->fRandomFill )
    {
        return;
    }
    
    //
    // update the fill once it has been used 8 times.
    //

    Compare = (LONG)(8 * pSecureFill->cbRandomFill);

    Result = InterlockedExchangeAdd(
                &pSecureFill->cbFilled,
                cbBytesThisFill
                );

    if( (Result+Compare) > Compare )
    {
        Result = 0;
        
        //
        // if there was a race condition, only one thread will update the random fill.
        //

        if( TryEnterCriticalSection( &pSecureFill->Lock ) )
        {
            rc4( &pSecureFill->Key, pSecureFill->cbRandomFill, pSecureFill->pbRandomFill );

            LeaveCriticalSection( &pSecureFill->Lock );
        }
    }
}

DWORD
SecureDeleteRandomFill(
    IN      PSECURE_FILL_INFO   pSecureFill
    )
{
    if( pSecureFill->pbRandomFill != NULL )
    {
        VirtualFree( pSecureFill->pbRandomFill, pSecureFill->cbRandomFill, MEM_RELEASE );
    }

    if( pSecureFill->LockValid )
    {
        DeleteCriticalSection( &pSecureFill->Lock );
    }

    ZeroMemory( pSecureFill, sizeof(*pSecureFill) );

    return ERROR_SUCCESS;
}

#define MaxFileNum 100000000
#define MaxDigit   9

HANDLE
CreateMyTempFile(
    LPWSTR TempPath
    )
{
    static DWORD TempIndex = 0;
    WCHAR TempFileName[MAX_PATH];
    WCHAR TempIndexString[MaxDigit+2];
    DWORD TempPathLength;
    HANDLE TempHandle;
    BOOLEAN ContinueSearch = TRUE;
    DWORD RetCode;

    if (wcslen(TempPath) >= (MAX_PATH - 3 - MaxDigit)) {

        //
        //  Path too long. This should not happen as the TempPath should be the root of the volume
        //

        SetLastError(ERROR_LABEL_TOO_LONG);

        return INVALID_HANDLE_VALUE;

    }

    wcscpy(TempFileName, TempPath);
    TempPathLength = wcslen(TempPath);

    while ( (TempIndex <= MaxFileNum) && ContinueSearch ) {

        wsprintf(TempIndexString, L"%ld", TempIndex);
        wcscat(TempFileName, TempIndexString);
        wcscat(TempFileName, L".E");
        TempHandle =  CreateFileW(
                         TempFileName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_NEW,
                         FILE_ATTRIBUTE_NORMAL |
                         FILE_FLAG_DELETE_ON_CLOSE,
                         NULL
                         );
        if (TempHandle != INVALID_HANDLE_VALUE) {
            return TempHandle;
        }

        RetCode = GetLastError();

        switch (RetCode) {
                case ERROR_INVALID_PARAMETER     :
                case ERROR_WRITE_PROTECT         :
                case ERROR_FILE_NOT_FOUND        :
                case ERROR_BAD_PATHNAME          :
                case ERROR_INVALID_NAME          :
                case ERROR_PATH_NOT_FOUND        :
                case ERROR_NETWORK_ACCESS_DENIED :
                case ERROR_DISK_CORRUPT          :
                case ERROR_FILE_CORRUPT          :
                case ERROR_DISK_FULL             :

                    ContinueSearch = FALSE;

                break;
        default:

                TempFileName[TempPathLength] = 0;
                break;

        }

        TempIndex++;

    }


    //
    // We got the filename.
    //

    return TempHandle;
}

DWORD
SecureProcessMft(
    IN  LPWSTR DriveLetter,
    IN  HANDLE hTempFile
    )
{
    NTFS_VOLUME_DATA_BUFFER VolumeData;
    DWORD cbOutput;

    __int64 TotalMftEntries;
    PHANDLE pHandleArray = NULL;
    DWORD FreeMftEntries;
    DWORD i;
    DWORD dwLastError = ERROR_SUCCESS;


    //
    // get the count of MFT records.  This will fail if not NTFS, so bail in that case.
    //

    if(!DeviceIoControl(
                    hTempFile,
                    FSCTL_GET_NTFS_VOLUME_DATA, // dwIoControlCode
                    NULL,
                    0,
                    &VolumeData,
                    sizeof(VolumeData),
                    &cbOutput,
                    NULL
                    ))
    {
        return GetLastError();
    }

    TotalMftEntries = VolumeData.MftValidDataLength.QuadPart / VolumeData.BytesPerFileRecordSegment;
    if( TotalMftEntries > (0xFFFFFFFF/sizeof(HANDLE)) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    FreeMftEntries = (DWORD)TotalMftEntries;

    pHandleArray = HeapAlloc(GetProcessHeap(), 0 , FreeMftEntries*sizeof(HANDLE));
    if( pHandleArray == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory( pHandleArray, FreeMftEntries * sizeof(HANDLE) );


    for( i=0;i< FreeMftEntries ; i++ )
    {
        WCHAR szTempPath[ MAX_PATH + 1 ];
        DWORD FillIndex;
        
        pHandleArray[i] = CreateMyTempFile(DriveLetter);
        if( pHandleArray[i] == INVALID_HANDLE_VALUE )
        {
            dwLastError = GetLastError();
            break;
        }
    
        //
        // for each file created, write at most BytesPerFileRecordSegment data to it.
        //

        for( FillIndex = 0 ; FillIndex < (VolumeData.BytesPerFileRecordSegment/8) ; FillIndex++ )
        {
            DWORD dwBytesWritten;

            if(!WriteFile(
                    pHandleArray[i],
                    GlobalSecureFill.pbRandomFill,
                    8,
                    &dwBytesWritten,
                    NULL
                    ))
            {
                break;
            }

        }

        if (i && !(i % 200)) {

            //
            // Keep users informed for every 50 files we created.
            //

            printf(".");
        }
    }

    if( dwLastError == ERROR_DISK_FULL )
    {
        dwLastError = ERROR_SUCCESS;
    }


#ifdef TestOutPut
    printf("\nmft error=%lu entries created=%lu total = %I64u\n", dwLastError, i, TotalMftEntries);
#endif


    for (i=0;i < FreeMftEntries;i++) {
        if( pHandleArray[i] != INVALID_HANDLE_VALUE &&
            pHandleArray[i] != NULL
            )
        {
            CloseHandle( pHandleArray[i] );
        }
    }


    if( pHandleArray != NULL )
    {
        HeapFree(GetProcessHeap(), 0, pHandleArray );
    }

    return dwLastError;
}


DWORD
SecureProcessFreeClusters(
    IN  LPWSTR DrivePath,
    IN  HANDLE hTempFile
    )
{
    HANDLE hVolume = INVALID_HANDLE_VALUE;
    
    WCHAR VolumeName[100]; // 50 should be enough. 100 is more than enough.
    
    NTFS_VOLUME_DATA_BUFFER VolumeData;
    STARTING_LCN_INPUT_BUFFER LcnInput;
    VOLUME_BITMAP_BUFFER *pBitmap = NULL;
    MOVE_FILE_DATA MoveFile;
    __int64 cbBitmap;
    DWORD cbOutput;

    unsigned __int64 ClusterLocation;
    unsigned __int64 Lcn;
    BYTE Mask;

    unsigned __int64 Free = 0;
    DWORD Fail = 0;

#ifdef TestOutPut
    DWORD dwStart, dwStop;
#endif
    
    __int64 ClusterIndex;
    DWORD dwLastError = ERROR_SUCCESS;

    //
    // first, find out if there are free or reserved clusters.
    // this will fail if the volume is not NTFS.
    //

    if (!GetVolumeNameForVolumeMountPoint(
              DrivePath,
              VolumeName,
              sizeof(VolumeName)/sizeof(WCHAR)  )){

        return GetLastError();

    }

    VolumeName[wcslen(VolumeName)-1] = 0;  // Truncate the trailing slash

    if(!DeviceIoControl(
                    hTempFile,
                    FSCTL_GET_NTFS_VOLUME_DATA, // dwIoControlCode
                    NULL,
                    0,
                    &VolumeData,
                    sizeof(VolumeData),
                    &cbOutput,
                    NULL
                    ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    if( VolumeData.FreeClusters.QuadPart == 0 &&
        VolumeData.TotalReserved.QuadPart == 0 )
    {
        return ERROR_SUCCESS;
    }

    hVolume = CreateFileW(  VolumeName,
                            FILE_READ_ATTRIBUTES | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_NO_BUFFERING, // no buffering
                            NULL
                            );

    if( hVolume == INVALID_HANDLE_VALUE )
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    //
    // allocate space for the volume bitmap.
    //

    cbBitmap = sizeof(VOLUME_BITMAP_BUFFER) + (VolumeData.TotalClusters.QuadPart / 8);
    if( cbBitmap > 0xFFFFFFFF )
    {
        dwLastError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    pBitmap = HeapAlloc(GetProcessHeap(), 0, (DWORD)cbBitmap);
    if( pBitmap == NULL )
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // grab the volume bitmap.
    //

    LcnInput.StartingLcn.QuadPart = 0;

    ZeroMemory( &MoveFile, sizeof(MoveFile) );

    MoveFile.FileHandle = hTempFile;
    MoveFile.StartingVcn.QuadPart = 0;
    MoveFile.ClusterCount = 1;

#ifdef TestOutPut
    dwStart = GetTickCount();
#endif


    if(!DeviceIoControl(
            hVolume,        
            FSCTL_GET_VOLUME_BITMAP,
            &LcnInput,
            sizeof(LcnInput),
            pBitmap,
            (DWORD)cbBitmap,
            &cbOutput,
            NULL
            ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }
    

    //
    // insure file is only bytes per cluster in length.
    // this will shrink the file if necessary.  We waited until after we fetched the
    // volume bitmap to insure we only process the free clusters that existed prior to
    // the shrink operation.
    //
    
    if(SetFilePointer(
                    hTempFile,
                    (LONG)VolumeData.BytesPerCluster,
                    NULL,
                    FILE_BEGIN
                    ) == INVALID_SET_FILE_POINTER)
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }
    
    if(!SetEndOfFile( hTempFile ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }


    Mask = 1;
    Lcn = pBitmap->StartingLcn.QuadPart;

    for(ClusterIndex = 0 ; ClusterIndex < VolumeData.TotalClusters.QuadPart ; ClusterIndex++)
    {
        if( (pBitmap->Buffer[ClusterIndex/8] & Mask) == 0 )
        {
            DWORD dwMoveError = ERROR_SUCCESS;

            //
            // move a single cluster from the temp file to the free cluster.
            //

            MoveFile.StartingLcn.QuadPart = Lcn;
            
            if(!DeviceIoControl(
                        hVolume,
                        FSCTL_MOVE_FILE,    // dwIoControlCode
                        &MoveFile,
                        sizeof(MoveFile),
                        NULL,
                        0,
                        &cbOutput,
                        NULL
                        ))
            {
                dwMoveError = GetLastError();
            }
            
            //
            // if it succeeded, or the cluster was in use, mark it used in the bitmap.
            //
            
            if( dwMoveError == ERROR_SUCCESS || dwMoveError == ERROR_ACCESS_DENIED )
            {
                pBitmap->Buffer[ClusterIndex/8] |= Mask;
            } else {
                Fail++;
            }

            Free++;
            if ( !(Free % 200) ) {

                //
                // Keep users informed for every 50 files we created.
                //
                printf(".");

            }
        }

        Lcn ++;
        
        Mask <<= 1;

        if(Mask == 0)
        {
            Mask = 1;
        }
    }

#ifdef TestOutPut
    dwStop = GetTickCount();

    printf("\nFreeCount = %I64x fail = %lu elapsed = %lu\n", Free, Fail, dwStop-dwStart);
#endif

Cleanup:
    
    if( pBitmap != NULL )
    {
        HeapFree( GetProcessHeap(), 0, pBitmap );
    }

    if( hVolume != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hVolume );
    }

    return dwLastError;
}


DWORD
SecureDeleteFreeSpace(
    IN  LPWSTR Directory
    )
/*++

    This routine fills the disk specified by the input Directory parameter with random fill.
    Input is of the form "C:\", for instance.

    Notes on approaches not employed here:

    Alternate method would use defrag API to move random fill around the
    free cluster map.  Requires admin priviliges to the volume.  Slower than filling volume with
    a new file.
    
    Variant on alternate method: fill volume 80% with file, grab free cluster map,
    delete file associated with 80% fill, then use defrag API to fill the free cluster map
    mentioned previously.

    Does not fill cluster slack space for each file on the system.  Could do this by
    enumerating all files, and then extending+fill to slack boundry+restore original
    EOF.
    
    Does not fill $LOG.  Queried file system folks on whether this is possible by creating
    many small temporary files containing random fill.    

--*/
{
    UINT DriveType;
    DWORD DirNameLength;
    DWORD BufferLength;
    LPWSTR PathName = NULL;
    LPWSTR TempDirName = NULL;
    BOOL   b;
    BOOL   DirCreated = FALSE;
    DWORD  Attributes;

    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    WCHAR TempFileName[ MAX_PATH + 1 ];
    HANDLE hTempFile = INVALID_HANDLE_VALUE;
    DWORD dwWriteBytes;

    unsigned __int64 TotalBytesWritten;
    unsigned __int64 NotifyBytesWritten;
    unsigned __int64 NotifyInterval;
    ULARGE_INTEGER TotalFreeBytes;

    PBYTE pbFillBuffer = NULL;
    ULONG cbFillBuffer;

    NTFS_VOLUME_DATA_BUFFER VolumeData;
    __int64 MftEntries = 0;
    BOOLEAN ClustersRemaining = FALSE;
    DWORD cbOutput;

    DWORD dwLastError = ERROR_SUCCESS;
    DWORD dwTestError;

#ifdef TestOutPut

    ULARGE_INTEGER StartTime;
    ULARGE_INTEGER StopTime;

#endif


    //
    // collect information about the disk in question.
    //


    DirNameLength = wcslen(Directory);

    BufferLength = (DirNameLength + 1) <= MAX_PATH ?
                            (MAX_PATH + 1) * sizeof(WCHAR) : (DirNameLength + 1) * sizeof (WCHAR);
    PathName = (LPWSTR) malloc(BufferLength);
    if ( !PathName ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    TempDirName = (LPWSTR) malloc(BufferLength + wcslen(WIPING_DIR) * sizeof (WCHAR));
    if ( !TempDirName ) {
        free(PathName);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    b = GetVolumePathNameW(
                    Directory,
                    PathName,
                    BufferLength
                    );

    if (!b) {
        dwLastError = GetLastError();
        goto Cleanup;
    }


    DriveType = GetDriveTypeW( PathName );


    if( DriveType == DRIVE_REMOTE ||
        DriveType == DRIVE_CDROM )
    {
        dwLastError = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    if(!GetDiskFreeSpaceW(
                PathName,
                &SectorsPerCluster,
                &BytesPerSector,
                NULL,
                NULL
                ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }


    
    //
    // allocate memory chunk to accomodate cluster size data
    //


    cbFillBuffer = GlobalSecureFill.cbRandomFill;
    pbFillBuffer = GlobalSecureFill.pbRandomFill;


    //
    // determine how many bytes free space on the disk to enable notification of
    // overall progress.
    //

    if(!GetDiskFreeSpaceExW(
                PathName,
                NULL,
                NULL,
                &TotalFreeBytes
                ))
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    //
    // Let's Create the temp directory
    //

    wcscpy(TempDirName, PathName);
    wcscat(TempDirName, WIPING_DIR);
    if (!CreateDirectory(TempDirName, NULL)){

        //
        // Could not create our temp directory. Quit.
        //

        if ((dwLastError = GetLastError()) != ERROR_ALREADY_EXISTS){
            goto Cleanup;
        }
        
    } 

    DirCreated = TRUE;

    //
    // generate temporary file.
    //

    if( GetTempFileNameW(
                TempDirName,
                L"fil",
                0,
                TempFileName
                ) == 0 )
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    Attributes = GetFileAttributes(TempFileName);
    if (0xFFFFFFFF == Attributes) {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    if (Attributes & FILE_ATTRIBUTE_ENCRYPTED) {

        if (!DecryptFile(TempFileName, 0)){
            dwLastError = GetLastError();
            goto Cleanup;
        }

    }

    hTempFile = CreateFileW(
                        TempFileName,
                        GENERIC_WRITE,
                        0,                          // exclusive access
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_NO_BUFFERING |    // no buffering
                        FILE_FLAG_DELETE_ON_CLOSE,  // delete file when it closes.
                        NULL
                        );

    if( hTempFile == INVALID_HANDLE_VALUE )
    {
        dwLastError = GetLastError();
        goto Cleanup;
    }


    if (Attributes & FILE_ATTRIBUTE_COMPRESSED) {

        USHORT State = COMPRESSION_FORMAT_NONE;

        //
        //  Uncompress the directory first
        //

        b = DeviceIoControl(hTempFile,
                            FSCTL_SET_COMPRESSION,
                            &State,
                            sizeof(USHORT),
                            NULL,
                            0,
                            &BufferLength,
                            FALSE
                            );

        if ( !b ){
            dwLastError = GetLastError();
            goto Cleanup;
        }

    }


    TotalBytesWritten = 0;
    
    //
    // tell the user something happened for each 1% processed.
    //

    NotifyInterval = (TotalFreeBytes.QuadPart / 100);
    NotifyBytesWritten = NotifyInterval;
    
    dwWriteBytes = cbFillBuffer;


#ifdef TestOutPut
    GetSystemTimeAsFileTime( (FILETIME*)&StartTime );
#endif
    
    while( TRUE )
    {
        DWORD BytesWritten;

        if( TotalBytesWritten >= NotifyBytesWritten )
        {
            printf(".");

            NotifyBytesWritten += NotifyInterval;
        }


        //
        // mix random fill.
        //

        SecureMixRandomFill( &GlobalSecureFill, dwWriteBytes );

        if(!WriteFile(
                hTempFile,
                pbFillBuffer,
                dwWriteBytes,
                &BytesWritten,
                NULL
                ))
        {
            if( GetLastError() == ERROR_DISK_FULL )
            {
                dwLastError = ERROR_SUCCESS;

                //
                // if the attempted write failed, enter a retry mode with downgraded
                // buffersize to catch the last bits of slop.
                //

                if( dwWriteBytes > BytesPerSector )
                {
                    dwWriteBytes = BytesPerSector;
                    continue;
                }
            } else {
                dwLastError = GetLastError();
            }

            break;
        }

        TotalBytesWritten += BytesWritten;
    }

#ifdef TestOutPut
    GetSystemTimeAsFileTime( (FILETIME*)&StopTime );

    {
        ULARGE_INTEGER ElapsedTime;
        SYSTEMTIME st;

        ElapsedTime.QuadPart = (StopTime.QuadPart - StartTime.QuadPart);

        FileTimeToSystemTime( (FILETIME*)&ElapsedTime, &st );

        printf("\nTotalWritten = %I64u time = %02u:%02u:%02u.%02u\n",
                TotalBytesWritten,
                st.wHour,
                st.wMinute,
                st.wSecond,
                st.wMilliseconds
                );

    }
#endif


    
    //
    // at this point, the disk should be full.
    // If the disk is NTFS:
    // 1. Fill the MFT.
    // 2. Fill any free/reserved clusters.
    //

    dwTestError = SecureProcessMft( TempDirName, hTempFile );
//    dwTestError = SecureProcessMft( PathName, hTempFile );

#ifdef TestOutPut
    if (ERROR_SUCCESS != dwTestError) {
        printf("\nWriting NTFS MFT & LOG. Error:");
        DisplayErr(NULL, dwTestError);
    }
#endif

    dwTestError = SecureProcessFreeClusters( PathName, hTempFile );

#ifdef TestOutPut
    if (ERROR_SUCCESS != dwTestError) {
        printf("\nWriting NTFS reserved clusters. Error:");
        DisplayErr(NULL, dwTestError);
    }
#endif

Cleanup:

    if (hTempFile != INVALID_HANDLE_VALUE) {
        //
        // flush the buffers.  Likely has no effect if we used FILE_FLAG_NO_BUFFERING
        //
        //Sleep(INFINITE);
        FlushFileBuffers( hTempFile );
        CloseHandle( hTempFile );
    }

    if (DirCreated && TempDirName) {
        RemoveDirectory(TempDirName);
    }

    if( PathName != NULL ){
        free(PathName);
    }

    if ( TempDirName != NULL ) {
        free(TempDirName);
    }
    
    return dwLastError;
}

BOOL CheckMinVersion () 
{
   OSVERSIONINFOEX osvi;
   DWORDLONG dwlConditionMask = 0;
   BOOL GoodVersion;

   // Initialize the OSVERSIONINFOEX structure.

   ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
   osvi.dwMajorVersion = 5;
   osvi.dwMinorVersion = 0;
   osvi.wServicePackMajor = 3;

   // Initialize the condition mask.

   VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, 
      VER_GREATER_EQUAL );
   VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, 
      VER_GREATER_EQUAL );
   VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, 
      VER_GREATER_EQUAL );

   // Perform the test.

   GoodVersion = VerifyVersionInfo(
                      &osvi, 
                      VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR,
                      dwlConditionMask
                      );

   //
   // Check HotFix here
   // 
   // if (!GoodVersion) {
   //    GoodVersion = WeHaveTheHotFixVersion();
   // }
   //


   return GoodVersion;
}


VOID
__cdecl
main()
{
    PTCHAR *argv;
    ULONG argc;

    ULONG i;

    PACTION_ROUTINE ActionRoutine = NULL;
    PFINAL_ACTION_ROUTINE FinalActionRoutine = NULL;

    TCHAR DirectorySpec[MAX_PATH];
    TCHAR FileSpec[MAX_PATH];
    PTCHAR p;
    BOOL b;

    InitializeIoStreams();


    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if (NULL == argv) {
        DisplayErr(NULL, GetLastError());
        return;
    }

    //
    //  Scan through the arguments looking for switches
    //

    for (i = 1; i < argc; i += 1) {

        if (argv[i][0] == '/') {

            if (0 == lstricmp(argv[i], TEXT("/e"))) {

                if (ActionRoutine != NULL && ActionRoutine != DoEncryptAction) {

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

                ActionRoutine = DoEncryptAction;
                FinalActionRoutine = DoFinalEncryptAction;

            } else if (0 == lstricmp(argv[i], TEXT("/d"))) {

                if (ActionRoutine != NULL && ActionRoutine != DoListAction) {

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

                ActionRoutine = DoDecryptAction;
                FinalActionRoutine = DoFinalDecryptAction;

            } else if (0 == lstricmp(argv[i], TEXT("/a"))){

                DoFiles = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/q"))) {

                Quiet = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/k"))){

                SetUpNewUserKey = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/u"))){
            
                RefreshUserKeyOnFiles = TRUE;
                    
            } else if (0 == lstricmp(argv[i], TEXT("/n"))){

                DisplayFilesOnly = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/h"))){

                DisplayAllFiles = TRUE;

            } else if (0 == lstrnicmp(argv[i], TEXT("/s"), 2)) {

                PTCHAR pch;

                DoSubdirectories = TRUE;

                pch = lstrchr(argv[i], ':');
                if (NULL != pch) {
                    lstrcpy(StartingDirectory, pch + 1);
                } else {

                    //
                    // We require an explicit directory to be passed.
                    //

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

            } else if (0 == lstricmp(argv[i], TEXT("/i"))) {

                IgnoreErrors = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/f"))) {

                ForceOperation = TRUE;

            } else if (0 == lstrnicmp(argv[i], TEXT("/r"), 2)){

                PTCHAR pch;

                GenerateDRA = TRUE;

                pch = lstrchr(argv[i], ':');
                if (NULL != pch) {
                    lstrcpy(StartingDirectory, pch + 1);
                } else {

                    //
                    // We require an explicit file to be passed.
                    //

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

            } else if (0 == lstrnicmp(argv[i], TEXT("/w"), 2)){

                PTCHAR pch;

                FillUnusedSpace = TRUE;

                pch = lstrchr(argv[i], ':');
                if (NULL != pch) {
                    lstrcpy(StartingDirectory, pch + 1);
                } else {

                    //
                    // We require an explicit directory to be passed.
                    //

                    DisplayMsg(CIPHER_USAGE, NULL);
                    return;
                }

            } else {

                DisplayMsg(CIPHER_USAGE, NULL);
                return;
            }

        } else {

            UserSpecifiedFileSpec = TRUE;
        }
    }

    if (SetUpNewUserKey) {

        DWORD RetCode;

        //
        // Set up new user key here
        //

        RetCode = SetUserFileEncryptionKey(NULL);
        if ( ERROR_SUCCESS != RetCode ) {

            //
            // Display error info.
            //

            DisplayErr(NULL, GetLastError());

            
        } else {

            //
            // Get the new hash and display it.
            //

            CipherDisplayCrntEfsHash();

        }

        //
        // Create user key should not be used with other options.
        // We will ignore other options if user do.
        //

        return;

    }

    if (RefreshUserKeyOnFiles) {

        DWORD RetCode;
        
        RetCode = CipherTouchEncryptedFiles();

        if (RetCode != ERROR_SUCCESS) {
            DisplayErr(NULL, RetCode);
        }

        return;

    }

    if (GenerateDRA) {

        DWORD RetCode;

        RetCode = GenerateCertFiles(StartingDirectory);
        return;

    }

    if (FillUnusedSpace) {

        BYTE FillByte[2] = { 0x00, 0xFF };
        DWORD WriteValue[3] = {CIPHER_WRITE_ZERO, CIPHER_WRITE_FF, CIPHER_WRITE_RANDOM};
        PBYTE pFillByte[3] = {&FillByte[0], &FillByte[1], NULL};
        LPWSTR WriteChars;
        DWORD RetCode;

        if (!CheckMinVersion()) {
            DisplayErr(NULL, ERROR_OLD_WIN_VERSION);
            return;
        }

        //
        // We are going to erase the disks
        //


        DisplayMsg(CIPHER_WIPE_WARNING, NULL);
        
        for (i = 0; i < 3; i++) {
            RetCode = SecureInitializeRandomFill( &GlobalSecureFill, 4096 * 128, pFillByte[i] );
            if (RetCode != ERROR_SUCCESS) {
                SecureDeleteRandomFill(&GlobalSecureFill);
                break;
            }

            if ( ERROR_SUCCESS == GetResourceString(&WriteChars, WriteValue[i])){ 
                //LoadStringW(0, WriteValue[i], WriteChars, sizeof(WriteChars)/sizeof(WCHAR));
                DisplayMsg(CIPHER_WIPE_PROGRESS, WriteChars);
                LocalFree(WriteChars);
            }
            RetCode = SecureDeleteFreeSpace(StartingDirectory);
            printf("\n");
            SecureDeleteRandomFill( &GlobalSecureFill );
            if (RetCode != ERROR_SUCCESS) {
                break;
            }
        }

        if (RetCode != ERROR_SUCCESS) {
            DisplayErr(NULL, RetCode);
        }

        return;
    }


    //
    //  If the use didn't specify an action then set the default to do a listing
    //

    if (ActionRoutine == NULL) {

        ActionRoutine = DoListAction;
        FinalActionRoutine = DoFinalListAction;
    }



    //
    //  If the user didn't specify a file spec then we'll do just "*"
    //

    if (!UserSpecifiedFileSpec) {

        //
        //  Get our current directory because the action routines might move us
        //  around
        //

        if (DoSubdirectories) {
            if (ActionRoutine != DoListAction) {
                (VOID)(ActionRoutine)( StartingDirectory, TEXT("") );
            }
            if (!SetCurrentDirectory( StartingDirectory )) {
                DisplayErr(StartingDirectory, GetLastError());
                return;
            }
        } else {
            GetCurrentDirectory( MAX_PATH, StartingDirectory );
        }


        (VOID)GetFullPathName( TEXT("*"), MAX_PATH, DirectorySpec, &p );

        lstrcpy( FileSpec, p ); *p = '\0';

        (VOID)(ActionRoutine)( DirectorySpec, FileSpec );

    } else {

        //
        //  Get our current directory because the action routines might move us
        //  around
        //

        if (!DoSubdirectories) {
            GetCurrentDirectory( MAX_PATH, StartingDirectory );
        } else if (!SetCurrentDirectory( StartingDirectory )) {
            DisplayErr(StartingDirectory, GetLastError());
            return;
        }

        //
        //  Now scan the arguments again looking for non-switches
        //  and this time do the action, but before calling reset
        //  the current directory so that things work again
        //

        for (i = 1; i < argc; i += 1) {

            if (argv[i][0] != '/') {

                SetCurrentDirectory( StartingDirectory );

                //
                // Handle a command with "." as the file argument specially,
                // since it doesn't make good sense and the results without
                // this code are surprising.
                //

                if ('.' == argv[i][0] && '\0' == argv[i][1]) {
                    argv[i] = TEXT("*");
                    GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &p);
                    *p = '\0';
                    p = NULL;
                } else {

                    PWCHAR pwch;
                    DWORD  PathLen;

                    //
                    // We need to deal with path longer than MAX_PATH later.
                    // This code is based on Compact. They have the same problem
                    // as we do. So far, we have not heard any one complaining about this.
                    // Let's track this in the RAID.
                    //

                    PathLen = GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &p);
                    if ( 0 == PathLen ){
                        DisplayMsg(CIPHER_INVALID_PARAMETER, argv[i]);
                        break;
                    }

                    //
                    // We want to treat "foobie:xxx" as an invalid drive name,
                    // rather than as a name identifying a stream.  If there's
                    // a colon, there should be only a single character before
                    // it.
                    //

                    pwch = wcschr(argv[i], ':');
                    if (NULL != pwch && pwch - argv[i] != 1) {
                        DisplayMsg(CIPHER_INVALID_PATH, argv[i]);
                        break;
                    }

                    //
                    // GetFullPathName strips trailing dots, but we want
                    // to save them so that "*." will work correctly.
                    //

                    if ('.' == argv[i][lstrlen(argv[i]) - 1]) {
                        lstrcat(DirectorySpec, TEXT("."));
                    }
                }

                if (p != NULL) {
                    lstrcpy( FileSpec, p ); *p = '\0';
                } else {
                    FileSpec[0] = '\0';
                }

                if (!(ActionRoutine)( DirectorySpec, FileSpec ) &&
                    !IgnoreErrors) {
                    break;
                }
            }
        }
    }

    //
    //  Reset our current directory back
    //

    SetCurrentDirectory( StartingDirectory );

    //
    //  And do the final action routine that will print out the final
    //  statistics of what we've done
    //

    (FinalActionRoutine)();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\chkdsk\chkdsk.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        chkdsk.cxx

Abstract:

        Chkdsk is a program that checks your disk for corruption and/or bad sectors.

Author:

        Bill McJohn (billmc) 12-April-91

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"

#include "arg.hxx"
#include "chkmsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"

#include "system.hxx"
#include "ifssys.hxx"
#include "substrng.hxx"

#include "ulibcl.hxx"
#include "ifsentry.hxx"

#include "keyboard.hxx"

#include "supera.hxx"           // for CHKDSK_EXIT_*

int __cdecl
main(
        )
/*++

Routine Description:

    Entry point for chkdsk.exe.  This function parses the arguments,
    determines the appropriate file system (by querying the volume),
    and invokes the appropriate version of chkdsk.

    The arguments accepted by Chkdsk are:

        /f                  Fix errors on drive
        /v                  Verbose operation
        drive:              drive to check
        file-name           files to check for contiguity
                            (Note that HPFS ignores file-name parameters).
        /x                  Force the volume to dismount first if necessary (implied /f)
        /i                  include index entries checking during index verification
        /c                  include cycles checking during index verification
        /r                  locate bad sectors and recover readable information
        /l[:size]           change or display log file size

--*/
{
    DSTRING         CurrentDirectory;
    DSTRING         FsName;
    DSTRING         FsNameAndVersion;
    DSTRING         LibraryName;
    DSTRING         DosDriveName;
    DSTRING         CurrentDrive;
    DSTRING         NtDriveName;
    PWSTRING        p;
    HANDLE          FsUtilityHandle;
    DSTRING         ChkdskString;
    DSTRING         Colon;
    CHKDSKEX_FN     ChkdskEx = NULL;
    PWSTRING        pwstring;
    BOOLEAN         fix;
    BOOLEAN         resize_logfile;
    ULONG           logfile_size;
    FSTRING         acolon, bcolon;
    ULONG           exit_status;

    ARGUMENT_LEXEMIZER  Lexemizer;
    ARRAY               EmptyArray;
    ARRAY               ArgumentArray;
    FLAG_ARGUMENT       ArgumentHelp;
    FLAG_ARGUMENT       ArgumentForce;
    FLAG_ARGUMENT       ArgumentFix;
    FLAG_ARGUMENT       ArgumentVerbose;
    FLAG_ARGUMENT       ArgumentRecover;
    LONG_ARGUMENT       ArgumentAlgorithm;
    FLAG_ARGUMENT       ArgumentSkipIndexScan;
    FLAG_ARGUMENT       ArgumentSkipCycleScan;
    FLAG_ARGUMENT       ArgumentResize;
    LONG_ARGUMENT       ArgumentResizeLong;
    STRING_ARGUMENT     ArgumentProgramName;
    PATH_ARGUMENT       ArgumentPath;


    CHKDSK_MESSAGE      Message;
    NTSTATUS            Status;
    DWORD               oldErrorMode;
    PATH_ANALYZE_CODE   rst;
    PPATH               ppath;
    PATH                fullpath;
    PATH                drivepath;
    DSTRING             drivename;
    DSTRING             drive_path_string;
    BOOLEAN             is_drivepath_invalid = TRUE;
    DSTRING             ntfs_name;
    USHORT              algorithm;

    CHKDSKEX_FN_PARAM   param;


    if( !Message.Initialize( Get_Standard_Output_Stream(),
                             Get_Standard_Input_Stream() ) ) {
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

#if defined(PRE_RELEASE_NOTICE)
    Message.Set(MSG_CHK_PRE_RELEASE_NOTICE);
    Message.Display();
#endif

    // Initialize the colon string in case we need it later:

    if( !Colon.Initialize( ":" ) ||
        !ntfs_name.Initialize( "NTFS" )) {

        Message.Set( MSG_CHK_NO_MEMORY );
        Message.Display( "" );
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }


    // Parse the arguments.  First, initialize all the
    // parsing machinery.  Then put the potential arguments
    // into the argument array,

    if( !ArgumentArray.Initialize( 5, 1 )               ||
        !EmptyArray.Initialize( 5, 1 )                  ||
        !Lexemizer.Initialize( &EmptyArray )            ||
        !ArgumentHelp.Initialize( "/?" )                ||
        !ArgumentForce.Initialize( "/X" )               ||
        !ArgumentFix.Initialize( "/F" )                 ||
        !ArgumentVerbose.Initialize( "/V" )             ||
        !ArgumentRecover.Initialize( "/R" )             ||
        !ArgumentAlgorithm.Initialize( "/I:*" )         ||
        !ArgumentSkipIndexScan.Initialize( "/I" )       ||
        !ArgumentSkipCycleScan.Initialize( "/C" )       ||
        !ArgumentResize.Initialize( "/L" )              ||
        !ArgumentResizeLong.Initialize( "/L:*" )        ||
        !ArgumentProgramName.Initialize( "*" )          ||
        !ArgumentPath.Initialize( "*", FALSE ) ) {

        Message.Set( MSG_CHK_NO_MEMORY );
        Message.Display( "" );
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // CHKDSK is not case sensitive.

    Lexemizer.SetCaseSensitive( FALSE );

    if( !ArgumentArray.Put( &ArgumentProgramName )  ||
        !ArgumentArray.Put( &ArgumentHelp )         ||
        !ArgumentArray.Put( &ArgumentForce )        ||
        !ArgumentArray.Put( &ArgumentFix )          ||
        !ArgumentArray.Put( &ArgumentVerbose )      ||
        !ArgumentArray.Put( &ArgumentRecover )      ||
        !ArgumentArray.Put( &ArgumentAlgorithm )    ||
        !ArgumentArray.Put( &ArgumentSkipIndexScan )||
        !ArgumentArray.Put( &ArgumentSkipCycleScan )||
        !ArgumentArray.Put( &ArgumentResize )       ||
        !ArgumentArray.Put( &ArgumentResizeLong )   ||
        !ArgumentArray.Put( &ArgumentPath ) ) {

        Message.Set( MSG_CHK_NO_MEMORY );
        Message.Display( "" );
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // Parse.  Note that PrepareToParse will, by default, pick
    // up the command line.

    if( !Lexemizer.PrepareToParse() ) {

        Message.Set( MSG_CHK_NO_MEMORY );
        Message.Display( "" );
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }


    // If the parsing failed, display a helpful command line summary.

    if( !Lexemizer.DoParsing( &ArgumentArray ) ) {

        Message.Set(MSG_INVALID_PARAMETER);
        Message.Display("%W", pwstring = Lexemizer.QueryInvalidArgument());
        DELETE(pwstring);

        return CHKDSK_EXIT_COULD_NOT_CHK;
    }


    // If the user requested help, give it.

    if( ArgumentHelp.QueryFlag() ) {

        Message.Set( MSG_CHK_USAGE_HEADER );
        Message.Display( "" );
        Message.Set( MSG_BLANK_LINE );
        Message.Display( "" );
        Message.Set( MSG_CHK_COMMAND_LINE );
        Message.Display( "" );
        Message.Set( MSG_BLANK_LINE );
        Message.Display( "" );
        Message.Set( MSG_CHK_DRIVE );
        Message.Display( "" );
        Message.Set( MSG_CHK_USG_FILENAME );
        Message.Display( "" );
        Message.Set( MSG_CHK_F_SWITCH );
        Message.Display( "" );
        Message.Set( MSG_CHK_V_SWITCH );
        Message.Display( "" );

        return CHKDSK_EXIT_COULD_NOT_CHK;
    }


    if (!ArgumentPath.IsValueSet()) {

        if (!SYSTEM::QueryCurrentDosDriveName(&DosDriveName) ||
            !drivepath.Initialize(&DosDriveName)) {
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }
        ppath = &drivepath;
    } else {
        ppath = ArgumentPath.GetPath();
#if defined(RUN_ON_NT4)
        if (!DosDriveName.Initialize(ppath->GetPathString()))
            return CHKDSK_EXIT_COULD_NOT_CHK;
#endif
    }

#if !defined(RUN_ON_NT4)
    rst = ppath->AnalyzePath(&DosDriveName,
                             &fullpath,
                             &drive_path_string);

    switch (rst) {
        case PATH_OK:
        case PATH_COULD_BE_FLOPPY:
            is_drivepath_invalid = fullpath.IsDrive() ||
                                   (fullpath.GetPathString()->QueryChCount() == 0);
            if (ppath->IsGuidVolName()) {
                if (!drivename.Initialize(&DosDriveName))
                    return CHKDSK_EXIT_COULD_NOT_CHK;
            } else {
                if (!drivename.Initialize(fullpath.GetPathString()))
                    return CHKDSK_EXIT_COULD_NOT_CHK;
            }

            if (fullpath.GetPathString()->QueryChCount() == 2 &&
                fullpath.GetPathString()->QueryChAt(1) == (WCHAR)':') {
                // if there is a drive letter for this drive, use it
                // instead of the guid volume name
                if (!DosDriveName.Initialize(fullpath.GetPathString())) {
                    return CHKDSK_EXIT_COULD_NOT_CHK;
                }
            }
            if (!fullpath.AppendString(&drive_path_string) ||
                !drivepath.Initialize(&drive_path_string))
                return CHKDSK_EXIT_COULD_NOT_CHK;
            break;

        case PATH_OUT_OF_MEMORY:
            DebugPrint("Out of memory.\n");
            return CHKDSK_EXIT_COULD_NOT_CHK;

        case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
            Message.Set(MSG_CHK_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;

        default:
            Message.Set(MSG_CHK_BAD_DRIVE_PATH_FILENAME);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
    }
#endif

    if (!DosDriveName.Strupr()) {
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // disable popups while we determine the drive type
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    // Make sure that drive is of a correct type.

    switch (SYSTEM::QueryDriveType(&DosDriveName)) {

        case RemoteDrive:
            SetErrorMode( oldErrorMode );
            Message.Set(MSG_CHK_CANT_NETWORK);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;

#if 0
        case CdRomDrive:
            SetErrorMode( oldErrorMode );
            Message.Set(MSG_CHK_CANT_CDROM);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
#endif

        default:
            break;

    }

    SetErrorMode( oldErrorMode );

    if (!SYSTEM::QueryCurrentDosDriveName(&CurrentDrive)) {
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // /R ==> /F
    // /X ==> /F

    fix = ArgumentFix.QueryFlag() ||
          ArgumentForce.QueryFlag() ||
          ArgumentRecover.QueryFlag();

    //      From here on we want to deal with an NT drive name:

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&DosDriveName, &NtDriveName)) {
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // disable popups while we determine the file system name and version
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    // Determine the type of the file system.
    // Ask the volume what file system it has.  The
    // IFS utilities for file system xxxx are in Uxxxx.DLL.
    //

    if (!IFS_SYSTEM::QueryFileSystemName(&NtDriveName,
                                         &FsName,
                                         &Status,
                                         &FsNameAndVersion )) {

        SetErrorMode( oldErrorMode );

        if( Status == STATUS_ACCESS_DENIED ) {

            Message.Set( MSG_DASD_ACCESS_DENIED );
            Message.Display( "" );

        } else if( Status != STATUS_SUCCESS ) {

            Message.Set( MSG_CANT_DASD );
            Message.Display( "" );

        } else {

            Message.Set( MSG_FS_NOT_DETERMINED );
            Message.Display( "%W", &drivename );
        }

        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    // re-enable hardware popups
    SetErrorMode( oldErrorMode );

    if (FsName == ntfs_name && drive_path_string.QueryChCount()) {
        Message.Set(MSG_CHK_BAD_DRIVE_PATH_FILENAME);
        Message.Display();
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    Message.SetLoggingEnabled();

    Message.Set( MSG_CHK_RUNNING );
    Message.Log( "%W", &drivename );

    Message.Set( MSG_FILE_SYSTEM_TYPE );
    Message.Display( "%W", &FsName );


    if ( !FsName.Strupr() ) {
       return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    DSTRING fat32_name;

    if ( !fat32_name.Initialize("FAT32") ) {
       return CHKDSK_EXIT_COULD_NOT_CHK;

    }

    if ( FsName == fat32_name ) {
       FsName.Initialize("FAT");
    }


    if ( !LibraryName.Initialize( "U" ) ||
         !LibraryName.Strcat( &FsName ) ||
         !ChkdskString.Initialize( "ChkdskEx" ) ) {

         Message.Set( MSG_CHK_NO_MEMORY );
         Message.Display( "" );
         return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    if (fix && (CurrentDrive == DosDriveName)) {

        Message.Set(MSG_CANT_LOCK_CURRENT_DRIVE);
        Message.Display();

        if (IsNEC_98) {

            DP_DRIVE    dpdrive;

            dpdrive.Initialize(&NtDriveName, &Message);

            if (dpdrive.IsFloppy()) {
            return CHKDSK_EXIT_COULD_NOT_CHK;
            }

        } else {

            acolon.Initialize((PWSTR) L"A:");
            bcolon.Initialize((PWSTR) L"B:");

            if (!DosDriveName.Stricmp(&acolon) ||
                !DosDriveName.Stricmp(&bcolon)) {

                return CHKDSK_EXIT_COULD_NOT_CHK;
            }

        }

        // Fall through so that the lock fails and then the
        // run autochk on reboot logic kicks in.
        //
    }

    if (ArgumentAlgorithm.IsValueSet() && ArgumentSkipIndexScan.QueryFlag()) {

        Message.Set(MSG_CHK_ALGORITHM_AND_SKIP_INDEX_SPECIFIED);
        Message.Display();
        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

    if (ArgumentAlgorithm.IsValueSet()) {

        if (ArgumentAlgorithm.QueryLong() < 0 ||
            ArgumentAlgorithm.QueryLong() > CHKDSK_MAX_ALGORITHM_VALUE) {

            Message.Set(MSG_CHK_INCORRECT_ALGORITHM_VALUE);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
        } else
            algorithm = (USHORT)ArgumentAlgorithm.QueryLong();

    } else
        algorithm = 0;

    if (ArgumentSkipIndexScan.QueryFlag() || ArgumentAlgorithm.IsValueSet()) {

        if (0 != FsName.Stricmp( &ntfs_name )) {

            Message.Set(MSG_CHK_SKIP_INDEX_NOT_NTFS);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }

    }

    if (ArgumentSkipCycleScan.QueryFlag()) {

        if (0 != FsName.Stricmp( &ntfs_name )) {

            Message.Set(MSG_CHK_SKIP_CYCLE_NOT_NTFS);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }

    }

    // Does the user want to resize the logfile?  This is only sensible
    // for NTFS.  If she specified a size of zero, print an error message
    // because that's a poor choice and will confuse the untfs code,
    // which assumes that zero means resize to the default size.
    //

    resize_logfile = ArgumentResize.IsValueSet() || ArgumentResizeLong.IsValueSet();

    if (resize_logfile) {

        if (0 != FsName.Stricmp( &ntfs_name )) {

            Message.Set(MSG_CHK_LOGFILE_NOT_NTFS);
            Message.Display();
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }

        if (ArgumentResizeLong.IsValueSet()) {

            if (ArgumentResizeLong.QueryLong() <= 0) {

                Message.Set(MSG_CHK_WONT_ZERO_LOGFILE);
                Message.Display();
                return CHKDSK_EXIT_COULD_NOT_CHK;
            }

            if (ArgumentResizeLong.QueryLong() > MAXULONG/1024) {
                Message.Set(MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_BIG);
                Message.Display();
                return CHKDSK_EXIT_COULD_NOT_CHK;
            }
            logfile_size = ArgumentResizeLong.QueryLong() * 1024;
        } else {

            logfile_size = 0;
        }
    }

    if ((ChkdskEx =
        (CHKDSKEX_FN)SYSTEM::QueryLibraryEntryPoint( &LibraryName,
                                                     &ChkdskString,
                                                     &FsUtilityHandle )) !=
        NULL ) {

        if (fix &&
            !KEYBOARD::EnableBreakHandling()) {
            return CHKDSK_EXIT_COULD_NOT_CHK;
        }

        //
        // setup parameter block v1.0 to be passed to ChkdskEx
        //

        param.Major = 1;
        param.Minor = 1;
        param.Flags = (ArgumentVerbose.QueryFlag() ? CHKDSK_VERBOSE : 0);
        param.Flags |= (ArgumentRecover.QueryFlag() ? CHKDSK_RECOVER : 0);
        param.Flags |= (ArgumentForce.QueryFlag() ? CHKDSK_FORCE : 0);
        param.Flags |= (resize_logfile ? CHKDSK_RESIZE_LOGFILE : 0);
        param.Flags |= (ArgumentSkipIndexScan.QueryFlag() ? CHKDSK_SKIP_INDEX_SCAN : 0);
        param.Flags |= (ArgumentSkipCycleScan.QueryFlag() ? CHKDSK_SKIP_CYCLE_SCAN : 0);
        param.Flags |= (ArgumentAlgorithm.IsValueSet() ? CHKDSK_ALGORITHM_SPECIFIED : 0);
        param.LogFileSize = logfile_size;
        param.PathToCheck = &fullpath;
        param.RootPath = (is_drivepath_invalid) ? NULL : &drivepath;
        param.Algorithm = algorithm;

        if (fix) {
            ChkdskEx( &NtDriveName,
                      &Message,
                      fix,
                      &param,
                      &exit_status );
        } else {

//disable C4509 warning about nonstandard ext: SEH + destructor
#pragma warning(disable:4509)

            __try {
                ChkdskEx( &NtDriveName,
                          &Message,
                          fix,
                          &param,
                          &exit_status );
            } __except (EXCEPTION_EXECUTE_HANDLER) {

                // If we get an access violation during read-only mode
                // CHKDSK then it's because the file system is partying
                // on the volume while we are.

                Message.Set(MSG_CHK_NTFS_ERRORS_FOUND);
                Message.Display();
                exit_status = CHKDSK_EXIT_ERRS_NOT_FIXED;
            }
        }

        if (CHKDSK_EXIT_ERRS_FIXED == exit_status && !fix) {
            exit_status = CHKDSK_EXIT_ERRS_NOT_FIXED;
        }

        SYSTEM::FreeLibraryHandle( FsUtilityHandle );

        if (fix &&
            !KEYBOARD::DisableBreakHandling()) {

            return 1;
        }

    } else {

        Message.Set( MSG_FS_NOT_SUPPORTED );
        Message.Display( "%s%W", "CHKDSK", &FsName );
        Message.Set( MSG_BLANK_LINE );
        Message.Display( "" );

        return CHKDSK_EXIT_COULD_NOT_CHK;
    }

//    Message.Set(MSG_CHK_NTFS_MESSAGE);
//    Message.Display("%s%d", "Exit Status ", exit_status);

    return exit_status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cipher\support.h ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    Support.h

Abstract:

    Support routine interfaces

Author:

    Matthew Bradburn    [mattbr]        05-Oct-1994
    Robert  Reichel     [RobertRe]      01-Apr-1997

Revision History:


--*/

extern VOID
ArrangeCommandLine(
    PTCHAR **pargv,
    int *pargc
    );

extern BOOLEAN
IsNtldr(
    PTCHAR pch
    );

extern BOOLEAN
IsUncRoot(
    PTCHAR pch
    );

extern VOID
DisplayMsg(DWORD MsgNum, ... );

extern VOID
DisplayErr(PTCHAR Prefix, DWORD MsgNum, ... );


extern DWORD
GetResourceString(LPWSTR *OutStr, DWORD MsgNum, ...);

extern VOID
InitializeIoStreams();

#define lstrchr wcschr
#define lstricmp _wcsicmp
#define lstrnicmp _wcsnicmp

extern ULONG
FormatFileSize(
    IN  PLARGE_INTEGER FileSize,
    IN  DWORD          Width,
    OUT PTCHAR         FormattedSize,
    IN  BOOLEAN        WithCommas
    );

extern
PTOKEN_USER
GetTokenUser(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\comp\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=comp
TARGETPATH=obj
TARGETTYPE=PROGRAM

LINKER_STACKCOMMITSIZE=4096

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\comp.cxx ..\comp.rc

INCLUDES=..\.;..\..\ulib\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\comp\comp.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    Comp.cxx

Abstract:

    Compares the contents of two files or sets of files.

    COMP [data1] [data2] [/D] [/A] [/L] [/N=number] [/C]

      data1     Specifies location and name(s) of first file(s) to compare.
      data2     Specifies location and name(s) of second files to compare.
      /D        Displays differences in decimal format. This is the default
                setting.
      /A        Displays differences in ASCII characters.
      /L        Displays line numbers for differences.
      /N=number Compares only the first specified number of lines in each file.
      /C        Disregards case of ASCII letters when comparing files.
      /OFFLINE  Do not skip files with offline attribute set.

    To compare sets of files, use wildcards in data1 and data2 parameters.

Author:

    Barry J. Gilhuly  ***  W-Barry  *** Jun 91

Environment:

    ULIB, User Mode

--*/

#include "ulib.hxx"
#include "ulibcl.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "bytestrm.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "iterator.hxx"
#include "path.hxx"
#include "rtmsg.h"
#include "system.hxx"
#include "smsg.hxx"
#include "comp.hxx"


extern "C" {
#include <ctype.h>
#include <stdio.h>
#include <string.h>
}


STREAM_MESSAGE  *psmsg = NULL;  // Create a pointer to the stream message
                                // class for program output.
ULONG           Errlev;         // The current program error level
ULONG           CompResult;



//
// Define a macro to deal with case insensitive comparisons
//
#define CASE_SENSITIVE( x )     ( ( _CaseInsensitive ) ? towupper( x ) : x )

VOID
StripQuotesFromString(
    IN  PWSTRING String
    )
/*++

Routine Description:

    This routine removes leading and trailing quote marks (if
    present) from a quoted string.  If the string is not a quoted
    string, it is left unchanged.

--*/
{
    if( String->QueryChCount() >= 2    &&
        String->QueryChAt( 0 ) == '\"' &&
        String->QueryChAt( String->QueryChCount() - 1 ) == '\"' ) {

        String->DeleteChAt( String->QueryChCount() - 1 );
        String->DeleteChAt( 0 );
    }
}

DEFINE_CONSTRUCTOR( COMP, PROGRAM );

VOID
COMP::Construct(
    )
/*++

Routine Description:

    Initializes the object.

Arguments:

    None.

Return Value:

    None.


--*/

{
    _InputPath1 = NULL;
    _InputPath2 = NULL;

    return;
}

VOID
COMP::Destruct(
    )
/*++

Routine Description:

    Cleans up after finishing with an FC object.

Arguments:

    None.

Return Value:

    None.


--*/

{
    DELETE( psmsg );
    if( _InputPath1 != NULL ) {
        DELETE( _InputPath1 );
    }
    if( _InputPath2 != NULL ) {
        DELETE( _InputPath2 );
    }

    return;
}

BOOLEAN
COMP::Initialize(
    )

/*++

Routine Description:

    Initializes an FC object.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;
    ARRAY               ArrayOfArg;
    PATH_ARGUMENT       ProgramName;
    FLAG_ARGUMENT       FlagDecimalFormat;
    FLAG_ARGUMENT       FlagAsciiFormat;
    FLAG_ARGUMENT       FlagLineNumbers;
    FLAG_ARGUMENT       FlagCaseInsensitive;
    FLAG_ARGUMENT       FlagRequestHelp;
    FLAG_ARGUMENT       FlagWrongNumber;
    FLAG_ARGUMENT       FlagIncludeOffline;
    FLAG_ARGUMENT       FlagIncludeOffline2;
    LONG_ARGUMENT       LongMatchLines;
    PATH_ARGUMENT       InFile1;
    PATH_ARGUMENT       InFile2;
    STRING_ARGUMENT     StringInvalidSwitch;
    WCHAR               WChar;
    DSTRING             InvalidString;

    _Numbered = FALSE;
    _Limited = FALSE;
    _InputPath1 = NULL;
    _InputPath2 = NULL;
    if( !LexArray.Initialize() ) {
        DebugPrintTrace(( "LexArray.Initialize() Failed!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }
    if( !ArgLex.Initialize(&LexArray) ) {
        DebugPrintTrace(( "ArgLex.Initialize() Failed!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }

    ArgLex.PutSwitches("/");
    ArgLex.SetCaseSensitive( FALSE );
    ArgLex.PutMultipleSwitch( "acdl" );
    ArgLex.PutSeparators( " /\t" );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );

    if( !ArgLex.PrepareToParse() ) {
        DebugPrintTrace(( "ArgLex.PrepareToParse() Failed!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }

    if( !ProgramName.Initialize("*")                ||
        !FlagDecimalFormat.Initialize("/D")         ||
        !FlagAsciiFormat.Initialize("/A")           ||
        !FlagLineNumbers.Initialize("/L")           ||
        !FlagCaseInsensitive.Initialize("/C")       ||
        !FlagIncludeOffline.Initialize("/OFFLINE")  ||
        !FlagIncludeOffline2.Initialize("/OFF")     ||
        !FlagWrongNumber.Initialize("/N")           ||
        !LongMatchLines.Initialize("/N=*")          ||
        !FlagRequestHelp.Initialize("/?")           ||
        !StringInvalidSwitch.Initialize("/*")       ||
        !InFile1.Initialize("*")                    ||
        !InFile2.Initialize("*") ) {

        DebugPrintTrace(( "Unable to Initialize some or all of the Arguments!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }


    if( !ArrayOfArg.Initialize() ) {
        DebugPrintTrace(( "ArrayOfArg.Initialize() Failed\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );
    }

    if( !ArrayOfArg.Put(&ProgramName)           ||
        !ArrayOfArg.Put(&FlagDecimalFormat)     ||
        !ArrayOfArg.Put(&FlagAsciiFormat)       ||
        !ArrayOfArg.Put(&FlagLineNumbers)       ||
        !ArrayOfArg.Put(&FlagCaseInsensitive)   ||
        !ArrayOfArg.Put(&FlagIncludeOffline)    ||
        !ArrayOfArg.Put(&FlagIncludeOffline2)   ||
        !ArrayOfArg.Put(&FlagWrongNumber)       ||
        !ArrayOfArg.Put(&LongMatchLines)        ||
        !ArrayOfArg.Put(&FlagRequestHelp)       ||
        !ArrayOfArg.Put(&StringInvalidSwitch)   ||
        !ArrayOfArg.Put(&InFile1)               ||
        !ArrayOfArg.Put(&InFile2) ) {

        DebugPrintTrace(( "ArrayOfArg.Put() Failed!\n" ));
        Errlev = INTERNAL_ERROR;
        return( FALSE );

    }


    if( !ArgLex.DoParsing( &ArrayOfArg ) ||
         StringInvalidSwitch.IsValueSet() ) {

        if( StringInvalidSwitch.IsValueSet() ) {
            //
            // An invalid switch was found...
            //
//          InvalidString.Initialize( "/" );
//          InvalidString.Strcat( StringInvalidSwitch.GetString() );
            InvalidString.Initialize( "" );
            InvalidString.Strcat( StringInvalidSwitch.GetLexeme() );
            Errlev = INV_SWITCH;
            psmsg->Set( MSG_COMP_INVALID_SWITCH );
            psmsg->Display( "%W", &InvalidString );
        } else {
            psmsg->Set( MSG_COMP_BAD_COMMAND_LINE );
            psmsg->Display( "" );
            Errlev = SYNT_ERR;
        }
        return( FALSE );
    }

    if( FlagWrongNumber.IsValueSet() ) {
        psmsg->Set( MSG_COMP_NUMERIC_FORMAT );
        psmsg->Display( "" );
    }

    // It should now be safe to test the arguments for their values...
    if( FlagRequestHelp.QueryFlag() ) {

        // Send help message
        psmsg->Set( MSG_COMP_HELP_MESSAGE );
        psmsg->Display( "" );
        return( FALSE );
    }

    if( InFile1.IsValueSet() ) {
        StripQuotesFromString( (PWSTRING)InFile1.GetPath()->GetPathString() );
        if( ( _InputPath1 = NEW PATH ) == NULL ) {
            psmsg->Set( MSG_COMP_NO_MEMORY );
            psmsg->Display( "" );
            Errlev = NO_MEM_AVAIL;
            return( FALSE );
        }
        if( !_InputPath1->Initialize( InFile1.GetPath(), FALSE ) ) {
            DebugAbort( "Failed to initialize canonicolized version of the path 1\n" );
            Errlev = INTERNAL_ERROR;
            return( FALSE );
        }
    } else {
        _InputPath1 = NULL;
    }

    if( InFile2.IsValueSet() ) {
        StripQuotesFromString( (PWSTRING)InFile2.GetPath()->GetPathString() );
        if( ( _InputPath2 = NEW PATH ) == NULL ) {
            Errlev = NO_MEM_AVAIL;
            psmsg->Set( MSG_COMP_NO_MEMORY );
            psmsg->Display( "" );
            return( FALSE );
        }
        if( !_InputPath2->Initialize( InFile2.GetPath(), FALSE ) ) {
            DebugAbort( "Failed to initialize canonicolized version of the path 2\n" );
            Errlev = INTERNAL_ERROR;
            return( FALSE );
        }
    } else {
        _InputPath2 = NULL;
    }

    //
    // Set the output mode...
    //
    if( FlagAsciiFormat.QueryFlag() ) {
        _Mode = OUTPUT_ASCII;
    } else if( FlagDecimalFormat.QueryFlag() ) {
        _Mode = OUTPUT_DECIMAL;
    } else {
        _Mode = OUTPUT_HEX;
    }

    //
    // Set the remaining flags...
    //
    if( LongMatchLines.IsValueSet() ) {
        if( ( ( WChar = ( LongMatchLines.GetLexeme()->QueryChAt( 3 ) ) ) == '+' ) ||
            WChar == '-' ||
            ( _NumberOfLines = LongMatchLines.QueryLong() ) < 0 ) {
            Errlev = INV_SWITCH;
            psmsg->Set( MSG_COMP_BAD_NUMERIC_ARG );
            psmsg->Display( "%W", LongMatchLines.GetLexeme() );
            return( FALSE );
        }

        if ( _NumberOfLines != 0 ) {
            _Numbered = TRUE;
            _Limited = TRUE;
        }

    } else {
        _Numbered = FlagLineNumbers.QueryFlag();
        _Limited = FALSE;
    }
    _CaseInsensitive = FlagCaseInsensitive.QueryFlag();

    _SkipOffline = ( !FlagIncludeOffline.QueryFlag() ) &&
                   ( !FlagIncludeOffline2.QueryFlag() );

    if( FlagDecimalFormat.IsValueSet()      ||
        FlagAsciiFormat.IsValueSet()        ||
        FlagLineNumbers.IsValueSet()        ||
        FlagCaseInsensitive.IsValueSet()    ||
        FlagIncludeOffline.IsValueSet()     ||
        FlagIncludeOffline2.IsValueSet()    ||
        LongMatchLines.IsValueSet()         ||
        ( InFile1.IsValueSet()              &&
          InFile2.IsValueSet() ) ) {
        _OptionsFound = TRUE;
    } else {
        _OptionsFound = FALSE;
    }

    return( TRUE );
}

VOID
COMP::Start(
    )
/*++

Routine Description:

    Query missing information from the user and start the comparison

Arguments:

    None.

Return Value:

    None.


--*/


{
    DSTRING UserInput;
    PWSTRING InvalidSwitch;
    USHORT  OptionCount;
    LONG  Number;

    for( ;; ) {

        if( _InputPath1 == NULL ) {

            // Query a path for file 1...
            psmsg->Set( MSG_COMP_QUERY_FILE1, ERROR_MESSAGE );
            psmsg->Display( "" );
            if( !psmsg->QueryStringInput( &UserInput ) ) {
                psmsg->Set( MSG_COMP_UNEXPECTED_END );
                psmsg->Display( "" );
                Errlev = UNEXP_EOF;
                return;
            }
            if( ( _InputPath1 = NEW PATH ) == NULL ) {
                psmsg->Set( MSG_COMP_NO_MEMORY );
                psmsg->Display( "" );
                Errlev = NO_MEM_AVAIL;
                return;
            }
            if( !_InputPath1->Initialize( &UserInput, FALSE ) ) {
                DebugPrintTrace(( "Unable to initialize the path for file 1\n" ));
                Errlev = INTERNAL_ERROR;
                return;
            }
        }
        if( _InputPath2 == NULL ) {

            // Query a path for file 2...
            psmsg->Set( MSG_COMP_QUERY_FILE2, ERROR_MESSAGE );
            psmsg->Display( "" );
            if( !psmsg->QueryStringInput( &UserInput ) ) {
                psmsg->Set( MSG_COMP_UNEXPECTED_END );
                psmsg->Display( "" );
                Errlev = UNEXP_EOF;
                return;
            }
            if( ( _InputPath2 = NEW PATH ) == NULL ) {
                psmsg->Set( MSG_COMP_NO_MEMORY );
                psmsg->Display( "" );
                Errlev = NO_MEM_AVAIL;
                return;
            }
            if( !_InputPath2->Initialize( &UserInput, FALSE ) ) {
                DebugPrintTrace(( "Unable to initialize the path for file 2\n" ));
                Errlev = INTERNAL_ERROR;
                return;
            }
        }
        if( !_OptionsFound ) {

            //
            // Query Options from the user...
            //
            DSTRING Options;
            DSTRING Delim;
            CHNUM   CurSwitchStart, NextSwitchStart, Len;

            Delim.Initialize( "/-" );
            // Query a new list of options from the user
            for( OptionCount = 0; OptionCount < 5; OptionCount++ ) {
                psmsg->Set( MSG_COMP_OPTION, ERROR_MESSAGE );
                psmsg->Display( "" );
                if( !psmsg->QueryStringInput( &Options ) ) {
                    psmsg->Set( MSG_COMP_UNEXPECTED_END );
                    psmsg->Display( "" );
                    Errlev = UNEXP_EOF;
                    return;
                }
                if( Options.QueryChCount() == 0 ) {
                    break;
                }

                CurSwitchStart = Options.Strcspn( &Delim );
                if( CurSwitchStart != 0 ) {
                    psmsg->Set( MSG_COMP_BAD_COMMAND_LINE );
                    psmsg->Display( "" );
                    Errlev = SYNT_ERR;
                    return;
                }
                for( ;; ) {

                    Len = 0;
                    CurSwitchStart++;
                    NextSwitchStart = Options.Strcspn( &Delim, CurSwitchStart );

                    switch( towupper( Options.QueryChAt( CurSwitchStart ) ) ) {
                        case    'A':
                            _Mode = OUTPUT_ASCII;
                            CurSwitchStart++;
                            break;
                        case    'D':
                            _Mode = OUTPUT_DECIMAL;
                            CurSwitchStart++;
                            break;
                        case    'C':
                            _CaseInsensitive = TRUE;
                            CurSwitchStart++;
                            break;
                        case    'L':
                            _Numbered = TRUE;
                            CurSwitchStart++;
                            break;
                        case    'O':
                            PWSTRING pArg;
                            if( NextSwitchStart == INVALID_CHNUM ) {
                                pArg = Options.QueryString(CurSwitchStart);
                            } else {
                                pArg = Options.QueryString(CurSwitchStart, NextSwitchStart-CurSwitchStart);
                            }
                            if (pArg                                            &&
                                (0 == _wcsicmp(pArg->GetWSTR(), L"OFFLINE")) ) {
                                _SkipOffline = FALSE;
                                CurSwitchStart += wcslen( L"OFFLINE" );
                                DELETE( pArg );
                            } else if (pArg                                      &&
                                (0 == _wcsicmp(pArg->GetWSTR(), L"OFF")) ) {
                                _SkipOffline = FALSE;
                                CurSwitchStart += wcslen( L"OFF" );
                                DELETE( pArg );
                            } else {
                                InvalidSwitch = Options.QueryString( CurSwitchStart );
                                psmsg->Set( MSG_COMP_INVALID_SWITCH );
                                psmsg->Display( "%W", InvalidSwitch );
                                Errlev = INV_SWITCH;
                                DELETE( InvalidSwitch );
                                DELETE( pArg );

                                return;
                            }
                            break;
                        case    'N':
                            ++CurSwitchStart;
                            if( Options.QueryChAt( CurSwitchStart ) != '=' ) {
                                psmsg->Set( MSG_COMP_NUMERIC_FORMAT );
                                psmsg->Display( "" );
                                break;
                            }
                            ++CurSwitchStart;
                            if( CurSwitchStart == NextSwitchStart ) {
                                break;
                            }
                            if( NextSwitchStart == INVALID_CHNUM ) {
                                Len = INVALID_CHNUM;
                            } else {
                                Len = NextSwitchStart - CurSwitchStart;
                            }
                            if( !Options.QueryNumber( &Number, CurSwitchStart, Len ) ) {
                                InvalidSwitch = Options.QueryString( CurSwitchStart );
                                psmsg->Set( MSG_COMP_BAD_NUMERIC_ARG );
                                psmsg->Display( "%W", InvalidSwitch );
                                Errlev = BAD_NUMERIC_ARG;
                                DELETE( InvalidSwitch );

                                return;
                            }
                            if (Options.QueryNumber( &_NumberOfLines, CurSwitchStart, Len ) )    {
                                _Numbered = TRUE;
                                _Limited = TRUE;
                            }
                            CurSwitchStart += Len;
                            break;
                        default:
                            InvalidSwitch = Options.QueryString( CurSwitchStart - 1 );
                            psmsg->Set( MSG_COMP_INVALID_SWITCH );
                            psmsg->Display( "%W", InvalidSwitch );
                            Errlev = INV_SWITCH;
                            DELETE( InvalidSwitch );

                            return;
                    }
                    if( ( CurSwitchStart != NextSwitchStart ) ||
                        ( Len == INVALID_CHNUM ) ) {
                        break;
                    }
                }
            }
        }

        DoCompare();

        //
        // Check if there are more files to be compared...
        //
        psmsg->Set( MSG_COMP_MORE, ERROR_MESSAGE );
        psmsg->Display( "" );
        if( !psmsg->IsYesResponse() ) {
            break;
        }
        DELETE( _InputPath1 );
        DELETE( _InputPath2 );
        _InputPath1 = NULL;
        _InputPath2 = NULL;
        _OptionsFound = NULL;
    }

    return;
}

VOID
COMP::DoCompare(
    )
/*++

Routine Description:

    Perform the comparison of the files.

Arguments:

    None.

Return Value:

    None.


--*/


{
    FSN_FILTER          Filter;
    PARRAY              pNodeArray;
    PITERATOR           pIterator;
    PWSTRING            pTmp;
    PATH                File1Path;
    PFSN_DIRECTORY      pDirectory = NULL;
    PATH                CanonPath1;     // Canonicolized versions of the user paths
    PATH                CanonPath2;
    DSTRING             WildCardString;
    BOOLEAN             PrintSkipWarning = FALSE;
    BOOLEAN             OfflineSkipped;

    //
    // Initialize the wildcard string..
    //
    WildCardString.Initialize( "" );
    SYSTEM::QueryResourceString( &WildCardString, MSG_COMP_WILDCARD_STRING, "" );

    // Check to see if the input paths are empty.

    if (_InputPath1->GetPathString()->QueryChCount() == 0) {
        Errlev = CANT_OPEN_FILE;
        psmsg->Set( MSG_COMP_UNABLE_TO_OPEN );
        psmsg->Display( "%W", _InputPath1->GetPathString() );
        return;
    }

    if (_InputPath2->GetPathString()->QueryChCount() == 0) {
        Errlev = CANT_OPEN_FILE;
        psmsg->Set( MSG_COMP_UNABLE_TO_OPEN );
        psmsg->Display( "%W", _InputPath2->GetPathString() );
        return;
    }

    //
    // Test if the input paths contain only a directory name.  If it
    // does, append '*.*' to the path so all files in that directory
    // may be compared.
    //
    if( _InputPath1->IsDrive() ||
        ( !_InputPath1->HasWildCard() &&
          ( pDirectory = SYSTEM::QueryDirectory( _InputPath1 ) ) != NULL ) ) {

        // The input path corresponds to a directory...
        _InputPath1->AppendBase( &WildCardString );

    }
    DELETE( pDirectory );
    if( _InputPath2->IsDrive() ||
        ( !_InputPath2->HasWildCard() &&
          ( pDirectory = SYSTEM::QueryDirectory( _InputPath2 ) ) != NULL ) ) {

        // The input path corresponds to a directory...
        _InputPath2->AppendBase( &WildCardString );

    }
    DELETE( pDirectory );

    //
    // Canonicolize the input paths...
    //
    CanonPath1.Initialize( _InputPath1, TRUE );
    CanonPath2.Initialize( _InputPath2, TRUE );

    //
    // Test if the first path name contains any wildcards.  If it does,
    // the program must initialize an array of FSN_NODES (for multiple
    // files...
    //
    if( CanonPath1.HasWildCard() ) {
        PPATH   pTmpPath;
        //
        // Get a directory based on what the user specified for File 1
        //
        if( ( pTmpPath = CanonPath1.QueryFullPath() ) == NULL ) {
            DebugPrintTrace(( "Unable to grab the Prefix from the input path...\n" ));
            Errlev = INTERNAL_ERROR;
            return;
        }
        pTmpPath->TruncateBase();
        if( ( pDirectory = SYSTEM::QueryDirectory( pTmpPath, FALSE ) ) != NULL ) {
            //
            // Create an FSN_FILTER so we can use the directory to create an
            // array of FSN_NODES
            Filter.Initialize();

            pTmp = CanonPath1.QueryName();
            Filter.SetFileName( pTmp );
            DELETE( pTmp );
            Filter.SetAttributes( (FSN_ATTRIBUTE)0,             // ALL
                                  FSN_ATTRIBUTE_FILES,          // ANY
                                  FSN_ATTRIBUTE_DIRECTORY );    // NONE
            pNodeArray = pDirectory->QueryFsnodeArray( &Filter );
            pIterator = pNodeArray->QueryIterator();
            DELETE( pDirectory );

            _File1 = (FSN_FILE *)pIterator->GetNext();
        } else {
            _File1 = NULL;
        }
        DELETE( pTmpPath );
    } else {
        _File1 = SYSTEM::QueryFile( &CanonPath1 );
    }

    if( _File1 == NULL ) {
        Errlev = CANT_OPEN_FILE;
        psmsg->Set( MSG_COMP_UNABLE_TO_OPEN );
        psmsg->Display( "%W", _InputPath1->GetPathString() );
        return;
    }

    do {

        //
        // Explicitly find if File1 has offline attributes set (This is required
        // because SYSTEM::QueryFile is not used for getting the FSN_FILE object)
        //
        if (_SkipOffline && IsOffline(_File1)) {
            PrintSkipWarning = TRUE;
            Errlev = FILES_SKIPPED;
            DELETE( _File1 );
            if( !CanonPath1.HasWildCard() ) {
                break;
            }
            continue;
        }

        //
        // Replace the input path filename with what is to be opened...
        //
        pTmp = _File1->GetPath()->QueryName();
        _InputPath1->SetName( pTmp );
        DELETE( pTmp );


        // Determine if filename 2 contains any wildcards...
        if( CanonPath2.HasWildCard() ) {
            // ...if it does, expand them...
            PPATH   pExpanded;

            pExpanded = CanonPath2.QueryWCExpansion( (PATH *)_File1->GetPath() );
            if( pExpanded == NULL ) {
                Errlev = COULD_NOT_EXP;
                psmsg->Set( MSG_COMP_UNABLE_TO_EXPAND );
                psmsg->Display( "%W%W", _InputPath1->GetPathString(), _InputPath2->GetPathString() );
                DELETE( _File1 );
                break;
            }

            //
            // Place the expanded name in the input path...
            //
            pTmp = pExpanded->QueryName();
            _InputPath2->SetName( pTmp );
            DELETE( pTmp );

            psmsg->Set( MSG_COMP_COMPARE_FILES );
            psmsg->Display( "%W%W", _InputPath1->GetPathString(),
                                    _InputPath2->GetPathString()
                          );
            _File2 = SYSTEM::QueryFile( pExpanded, _SkipOffline, &OfflineSkipped );
            DELETE( pExpanded );

        } else {

            psmsg->Set( MSG_COMP_COMPARE_FILES );
            psmsg->Display( "%W%W", _InputPath1->GetPathString(),
                                    _InputPath2->GetPathString()
                          );
            _File2 = SYSTEM::QueryFile( &CanonPath2, _SkipOffline, &OfflineSkipped );

        }

        if( _File2 == NULL ) {
            if (OfflineSkipped) {
                // Skipping offline files is not an error, just track this happened
                PrintSkipWarning = TRUE;
                Errlev = FILES_SKIPPED;
            } else {
                // Display error message
                psmsg->Set( MSG_COMP_UNABLE_TO_OPEN );
                psmsg->Display( "%W", _InputPath2->GetPathString() );
                Errlev = CANT_OPEN_FILE;
            }
            DELETE( _File1 );
            if( !CanonPath1.HasWildCard() ) {
                break;
            }
            continue;
        }


        //
        // Open the streams...
        // Initialize _ByteStream1 and _ByteStream2 with BufferSize = 1024, to
        // improve performance
        //
        if( (( _FileStream1 = (FILE_STREAM *)_File1->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL ) ) == NULL) ||
            !_ByteStream1.Initialize( _FileStream1, 1024 )
          ) {
            Errlev = CANT_READ_FILE;
            psmsg->Set( MSG_COMP_UNABLE_TO_READ );
            psmsg->Display( "%W", _File1->GetPath()->GetPathString() );
            DELETE( _File1 );
            DELETE( _File2 );
            if( !CanonPath1.HasWildCard() ) {
                break;
            }
            continue;
        }
        if( (( _FileStream2 = (FILE_STREAM *)_File2->QueryStream( READ_ACCESS, FILE_FLAG_OPEN_NO_RECALL ) ) == NULL ) ||
            !_ByteStream2.Initialize( _FileStream2, 1024 )
          ) {
            Errlev = CANT_READ_FILE;
            psmsg->Set( MSG_COMP_UNABLE_TO_READ );
            psmsg->Display( "%W", _File2->GetPath()->GetPathString() );
            DELETE( _FileStream1 );
            DELETE( _File1 );
            DELETE( _File2 );
            if( !CanonPath1.HasWildCard() ) {
                break;
            }
            continue;
        }

        BinaryCompare();

        // Close both streams now, since we are done with them...
        DELETE( _FileStream1 );
        DELETE( _FileStream2 );
        DELETE( _File1 );
        DELETE( _File2 );

        if( !CanonPath1.HasWildCard() ) {
            break;
        }

    } while( ( _File1 = (FSN_FILE *)pIterator->GetNext() ) != NULL );

    //
    // Print warning message if offline files were skipped
    //
    if(PrintSkipWarning) {
        psmsg->Set( MSG_COMP_OFFLINE_FILES_SKIPPED );
        psmsg->Display( "" );
    }

    return;
}

BOOLEAN
COMP::IsOffline(
    PFSN_FILE pFile
    )
/*++

Routine Description:

    Checks if a file object represents an offline file

Arguments:

    pFile - The file to check

Return Value:

    TRUE - if offline

Notes:

    This routine assumes a valid object that represnts a valid file
    On error, it returns FALSE since a none offline file is the default.

--*/
{
    PWSTRING    FullPath        =   NULL;
    BOOLEAN     fRet            =   FALSE;
    PCWSTR      FileName;
    DWORD       dwAttributes;

    DebugAssert( pFile );

    if ( pFile                                                                       &&
         ((FullPath = pFile->GetPath()->QueryFullPathString()) != NULL )             &&
         ((FileName = FullPath->GetWSTR()) != NULL )                                 &&
         ( FileName[0] != (WCHAR)'\0' )                                              &&
         ((dwAttributes = GetFileAttributes( FileName )) != -1) ) {

        if (dwAttributes & FILE_ATTRIBUTE_OFFLINE) {
            fRet = TRUE;
        }
    }

    DELETE( FullPath );

    return fRet;
}


#ifdef FE_SB  // v-junm - 08/30/93

BOOLEAN
COMP::CharEqual(
    PUCHAR  c1,
    PUCHAR  c2
    )
/*++

Routine Description:

    Checks to see if a PCHAR DBCS or SBCS char is equal or not.  For SBCS
    chars, if the CaseInsensitive flag is set, the characters are converted
    to uppercase and checked for equality.

Arguments:

    c1 - NULL terminating DBCS/SBCS char *.
    c2 - NULL terminating DBCS/SBCS char *.

Return Value:

    TRUE - if equal.

Notes:

    The char string sequence is:

        SBCS:
            c1[0] - char code.
            c1[1] - 0.
        DBCS:
            c1[0] - leadbyte.
            c1[1] - tailbyte.
            c1[2] - 0.

--*/
{
    if ( (*(c1+1) == 0)  && (*(c2+1) == 0 ) )
        return( CASE_SENSITIVE( *c1 ) == CASE_SENSITIVE( *c2 ) );
    else
        return( (*c1 == *c2) && (*(c1+1) == *(c2+1)) );
}

#endif

VOID
COMP::BinaryCompare(
    )
/*++

Routine Description:

    Does the actual binary compare between the two streams

Arguments:

    None.

Return Value:

    None.

Notes:

    The binary compare simply does a byte by byte comparison of the two
    files and reports all differences, as well as the offset into the
    file...   ...no line buffer is required for this comparision...

--*/
{
    ULONG   FileOffset = 0;
    ULONG   LineCount = 1;                  // Start the line count at 1...
    USHORT  Differences = 0;
    BYTE    Byte1, Byte2;
#ifdef FE_SB  // v-junm - 08/30/93
    BOOLEAN Lead = 0;                       // Set when leadbyte is read.
    UCHAR   Byte1W[3], Byte2W[3];           // PCHAR to contain DBCS/SBCS char.
    ULONG   DBCSFileOffset = 0;             // When ASCII output and DBCS char,
                                            //  the offset is where the lead
                                            //  byte is, not the tail byte.
#endif
    STR     Message[ 9 ];
    DSTRING ErrType;

    //
    // Set up the message string...
    //
    Message[ 0 ] = '%';
    Message[ 1 ] = 'W';
    if( !_Numbered ) {
        if (!SYSTEM::QueryResourceString(&ErrType, MSG_COMP_OFFSET_STRING, "")) {
            DebugPrintTrace(("COMP: Unable to read resource string %d\n", MSG_COMP_OFFSET_STRING));
            Errlev = INTERNAL_ERROR;
            return;
        }
        Message[ 2 ] = '%';
        Message[ 3 ] = 'X';
    } else {
        if (!SYSTEM::QueryResourceString(&ErrType, MSG_COMP_LINE_STRING, "")) {
            DebugPrintTrace(("COMP: Unable to read resource string %d\n", MSG_COMP_LINE_STRING));
            Errlev = INTERNAL_ERROR;
            return;
        }
        Message[ 2 ] = '%';
        Message[ 3 ] = 'd';
    }
    if( _Mode == OUTPUT_HEX ) {
        Message[ 4 ] = '%';
        Message[ 5 ] = 'X';
        Message[ 6 ] = '%';
        Message[ 7 ] = 'X';
    } else if( _Mode == OUTPUT_DECIMAL ) {
        Message[ 4 ] = '%';
        Message[ 5 ] = 'd';
        Message[ 6 ] = '%';
        Message[ 7 ] = 'd';
    } else {
#ifdef FE_SB  // v-junm - 08/30/93
// This is needed to display DBCS chars.  DBCS chars will be handed over
// as a pointer of chars.  In which turns out to go to a call to swprintf in
// basesys.cxx.  You may wonder why a DBCS char is stored as a string, but
// it works because before the call to swprintf is made, a 'h' is placed before
// the '%s' and makes a conversion to unicode.

        Message[ 4 ] = '%';
        Message[ 5 ] = 's';
        Message[ 6 ] = '%';
        Message[ 7 ] = 's';
#else // FE_SB
        Message[ 4 ] = '%';
        Message[ 5 ] = 'c';
        Message[ 6 ] = '%';
        Message[ 7 ] = 'c';
#endif // FE_SB
    }
    Message[ 8 ] = 0;

    // Compare the lengths of the files - if they aren't the same and
    // the number of lines to match hasn't been specified, then return
    // 'Files are different sizes'.
    if( !_Limited ) {
        if( _File1->QuerySize() != _File2->QuerySize() ) {
            Errlev = DIFFERENT_SIZES;
            CompResult = FILES_ARE_DIFFERENT;
            psmsg->Set( MSG_COMP_DIFFERENT_SIZES );
            psmsg->Display( "" );
            return;
        }
    }

    for( ;; FileOffset++ ) {
        //if( !_FileStream1->ReadByte( &Byte1 ) ) {
        if( !_ByteStream1.ReadByte( &Byte1 ) ) {
            if( !_ByteStream1.IsAtEnd() ) {
                Errlev = CANT_READ_FILE;
                psmsg->Set( MSG_COMP_UNABLE_TO_READ );
                psmsg->Display( "%W", _File1->GetPath()->GetPathString() );
                return;
            }
            //if( !_FileStream2->ReadByte( &Byte2 ) ) {
            if( !_ByteStream2.ReadByte( &Byte2 ) ) {
                if( !_ByteStream2.IsAtEnd() ) {
                    Errlev = CANT_READ_FILE;
                    psmsg->Set( MSG_COMP_UNABLE_TO_READ );
                    psmsg->Display( "%W", _File2->GetPath()->GetPathString() );
                    return;
                }
                break;
            } else {
                Errlev = FILE1_LINES;
                psmsg->Set( MSG_COMP_FILE1_TOO_SHORT );
                psmsg->Display( "%d", LineCount-1 );
                return;
            }
        } else {
            //if( !_FileStream2->ReadByte( &Byte2 ) ) {
            if( !_ByteStream2.ReadByte( &Byte2 ) ) {
                if( !_ByteStream2.IsAtEnd() ) {
                    Errlev = CANT_READ_FILE;
                    psmsg->Set( MSG_COMP_UNABLE_TO_READ );
                    psmsg->Display( "%W", _File2->GetPath()->GetPathString() );
                    return;
                }
                Errlev = FILE2_LINES;
                psmsg->Set( MSG_COMP_FILE2_TOO_SHORT );
                psmsg->Display( "%d", LineCount-1 );
                return;
            }
        }

#ifdef FE_SB  // v-junm - 08/30/93
// For hex and decimal display, we don't want to worry about DBCS chars.  This
// is a different spec than DOS/V (Japanese DOS), but it's much cleaner this
// way.  So, we will only worry about DBCS chars when the user asks us to
// display the difference in characters (/A option).  The file offset displayed
// for DBCS characters is always where the leadbyte is in the file even though
// only the tailbyte is different.

        DBCSFileOffset = FileOffset;

        //
        // Only going to worry about DBCS when user is comparing with
        // ASCII output.
        //
        //if ( _Mode == OUTPUT_ASCII )  {


        //kksuzuka: #133
        //We have to worry about DBCS with 'c' option also.
        if ( (_Mode==OUTPUT_ASCII) || ( _CaseInsensitive ) )  {

            if ( Lead )  {

                //
                // DBCS leadbyte already found.  Setup variables and
                // fill in tailbyte and null.
                //

                DBCSFileOffset--;
                Lead = FALSE;
                *(Byte1W+1) = Byte1;
                *(Byte2W+1) = Byte2;
                *(Byte1W+2) = *(Byte2W+2) = 0;

            }
            else if ( IsDBCSLeadByte( Byte1 ) || IsDBCSLeadByte( Byte2 ) )  {

                //
                // Found leadbyte.  Set lead flag telling the next time
                // around that the character is a tailbyte.
                //

                //
                // Save the leadbyte.  Tailbyte will be filled next time
                // around(above).
                //

                *Byte1W = Byte1;
                *Byte2W = Byte2;
                Lead = TRUE;
                continue;

            }
            else  {

                //
                // SBCS char.
                //

                *Byte1W = Byte1;
                *Byte2W = Byte2;
                *(Byte1W+1) = *(Byte2W+1) = 0;
                Lead = FALSE;
            }
        }
        else  {

            //
            // Not ASCII output (/a option).  Perform original routines.
            //

            *Byte1W = Byte1;
            *Byte2W = Byte2;
            *(Byte1W+1) = *(Byte2W+1) = 0;
        }

        //
        // Check to see if chars are equal.  If not, display difference.
        //

        if ( CharEqual( Byte1W, Byte2W ) == FALSE )  {

            psmsg->Set( MSG_COMP_COMPARE_ERROR );

            if ( _Mode == OUTPUT_ASCII )  {

                if ( _Numbered )
                    psmsg->Display( Message, &ErrType,
                                    LineCount, Byte1W, Byte2W );
                else
                    psmsg->Display( Message, &ErrType,
                                    DBCSFileOffset, Byte1W, Byte2W );

            }
            else  {
                if ( _Numbered )
                    psmsg->Display( Message, &ErrType,
                                    LineCount, *Byte1W, *Byte2W );
                //kksuzuka: #133
                //We have to worry about DBCS with c option also.
                //else
                else {
                    if( *Byte1W != *Byte2W ) {
                        psmsg->Display( Message, &ErrType,
                                    FileOffset, *Byte1W, *Byte2W );
                    }
                    else {
                        psmsg->Display( Message, &ErrType,
                                    FileOffset, *(Byte1W+1), *(Byte2W+1) );
                    }
                }
            }
#else // FE_SB
        // Now compare the bytes...if they are different, report the
        // difference...
        if( CASE_SENSITIVE( Byte1 ) != CASE_SENSITIVE( Byte2 ) ) {
            if( _Numbered ) {
                psmsg->Set( MSG_COMP_COMPARE_ERROR );
                psmsg->Display( Message, &ErrType, LineCount, Byte1, Byte2 );
            } else {
                psmsg->Set( MSG_COMP_COMPARE_ERROR );
                psmsg->Display( Message, &ErrType, FileOffset, Byte1, Byte2 );
            }

#endif // FE_SB

            if( ++Differences == MAX_DIFF ) {
                psmsg->Set( MSG_COMP_TOO_MANY_ERRORS );
                psmsg->Display( "" );
                Errlev = TEN_MISM;
                CompResult = FILES_ARE_DIFFERENT;
                return;
            }
        }
        //
        // Use <CR>'s imbedded in File1 to determine the line count.  This is
        // an inexact method (the differing byte may be '/r') but it is good
        // enough for the purposes of this program.
        //
#ifdef FE_SB // v-junm - 08/30/93
        if( *Byte1W == '\r' ) {
#else // FE_SB
        if( Byte1 == '\r' ) {
#endif // FE_SB
            LineCount++;
        }
        if( _Limited ) {
            if( LineCount > (ULONG)_NumberOfLines ) {
                break;
            }
        }
    }

#ifdef FE_SB  // v-junm - 08/30/93
// There may be a leadbyte without a tailbyte at the end of the file.  Check
// for it, and process accordingly.

    if ( _Mode == OUTPUT_ASCII && Lead )  {

        //
        // There is a leadbyte left.  Check to see if they are equal and
        // print difference if not.
        //

        if ( *Byte2W != *Byte1W )  {

            *(Byte1W+1) = *(Byte2W+1) = 0;
            Differences++;

            psmsg->Set( MSG_COMP_COMPARE_ERROR );
            if ( _Numbered )
                psmsg->Display(Message, &ErrType, LineCount, Byte1W, Byte2W);
            else
                psmsg->Display(Message, &ErrType, FileOffset-1, Byte1W, Byte2W);
        }
    }

#endif // FE_SB

    //
    // Check if any differences were found in the files
    //
    if( !Differences ) {
        psmsg->Set( MSG_COMP_FILES_OK );
        psmsg->Display( " " );
    } else {
        CompResult = FILES_ARE_DIFFERENT;
    }

    return;
}


int __cdecl
main(
    )
{


    DEFINE_CLASS_DESCRIPTOR( COMP );


    __try {

        COMP    Comp;

        psmsg = NEW STREAM_MESSAGE;

        if (psmsg == NULL) {
            DebugPrint("COMP: Out of memory\n");
            Errlev = NO_MEM_AVAIL;
            return( CANNOT_COMPARE_FILES );
        }
        // Initialize the stream message for standard input, stdout
        if (!Get_Standard_Output_Stream() ||
            !Get_Standard_Input_Stream() ||
            !psmsg->Initialize( Get_Standard_Output_Stream(),
                                Get_Standard_Input_Stream(),
                                Get_Standard_Error_Stream() )) {

            if (!Get_Standard_Output_Stream()) {
                DebugPrintTrace(("COMP: Output stream is NULL\n"));
            } else if (!Get_Standard_Input_Stream()) {
                DebugPrintTrace(("COMP: Input stream is NULL\n"));
            } else {
                DebugPrintTrace(("COMP: Unable to initialize message stream\n"));
            }

            Comp.Destruct();
            return( CANNOT_COMPARE_FILES );
        }

        if( !SYSTEM::IsCorrectVersion() ) {
            DebugPrintTrace(( "COMP: Incorrect Version Number...\n" ));
            psmsg->Set( MSG_COMP_INCORRECT_VERSION );
            psmsg->Display( "" );
            Comp.Destruct();
            return( CANNOT_COMPARE_FILES );
//            return( INCORRECT_DOS_VER );
        }

        // Set the Error level to Zero - No error...
        Errlev = NO_ERRORS;
        CompResult = FILES_ARE_EQUAL;

        if( !( Comp.Initialize() ) ) {
            //
            // The Command line didn't initialize properly, die nicely
            // without printing any error messages - Main doesn't know
            // why the Initialization failed...
            //
            // What has to be deleted by hand, or can everything be removed
            // by the destructor for the FC class?
            //
            Comp.Destruct();
            return( CANNOT_COMPARE_FILES );
//            return( Errlev );
        }


        // Do file comparison stuff...
        Comp.Start();
        Comp.Destruct();
//        return( Errlev );
        if( ( Errlev == NO_ERRORS ) || ( Errlev == TEN_MISM ) || ( Errlev == DIFFERENT_SIZES ) ) {
            return( CompResult );
        } else {
            return( CANNOT_COMPARE_FILES );
        }

    } __except ((_exception_code() == STATUS_STACK_OVERFLOW) ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        // may not be able to display anything if initialization failed
        // in additional to out of stack space
        // so just send a message to the debug port

        DebugPrint("COMP: Out of stack space\n");
        Errlev = NO_MEM_AVAIL;
        return CANNOT_COMPARE_FILES;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cipher\support.c ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    Support.c

Abstract:

    Support routines for compact utility

Author:

    Matthew Bradburn    [mattbr]        05-Oct-1994
    Robert Reichel      [RobertRe]      01-Apr-1997

Revision History:


--*/

#undef UNICODE
#define UNICODE

#undef _UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <windows.h>
#include "support.h"
#include "msg.h"



//
//  Declare routines to put out internationalized messages
//

typedef enum {
    READ_ACCESS,
    WRITE_ACCESS
} STREAMACCESS;

HANDLE
GetStandardStream(
    IN HANDLE   Handle,
    IN STREAMACCESS Access
    );

HANDLE hInput;
HANDLE hOutput;
HANDLE hError;

#define STDIN   0
#define STDOUT  1
#define STDERR  2

BOOL ConsoleInput;
BOOL ConsoleOutput;
BOOL ConsoleError;

int
FileIsConsole(int fh)
{
    unsigned htype;
    DWORD dwMode;
    HANDLE hFile;

    hFile = (HANDLE)_get_osfhandle(fh);
    htype = GetFileType(hFile);
    htype &= ~FILE_TYPE_REMOTE;

    if (FILE_TYPE_CHAR == htype) {

        switch (fh) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }

        if (GetConsoleMode(hFile, &dwMode)) {
            return TRUE;
        }
    }

    return FALSE;

}


VOID
InitializeIoStreams()
{
    hInput = GetStdHandle(STD_INPUT_HANDLE);
    ConsoleInput = FileIsConsole(STDIN);

    hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    ConsoleOutput = FileIsConsole(STDOUT);

    hError = GetStdHandle(STD_ERROR_HANDLE);
    ConsoleError = FileIsConsole(STDERR);
}

VOID
DisplayMsg(DWORD MsgNum, ... )
{
    DWORD len, bytes_written;
    BOOL success = FALSE;
    DWORD status;
    va_list ap;
    LPTSTR DisplayBuffer;

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL, MsgNum, 0,
        (LPVOID)&DisplayBuffer, 0, &ap);

    if (len && DisplayBuffer) {

        if (ConsoleOutput) {
            success = WriteConsole(hOutput, (LPVOID)DisplayBuffer, len,
                     &bytes_written, NULL);
    
        } else {
            DWORD ascii_len;
            LPSTR DisplayBufferAscii;
    
            len = lstrlen(DisplayBuffer);
    
            ascii_len = WideCharToMultiByte(
                CP_OEMCP,                                 // Unicode -> OEM
                0,                                        // gives best visual match
                DisplayBuffer, len+1,                     // source & length
                NULL, 0,                                  // dest & length
                NULL,                                     // default char
                NULL);
    
            DisplayBufferAscii = LocalAlloc(LPTR, ascii_len);
            if (DisplayBufferAscii != NULL) {
                WideCharToMultiByte(
                    CP_OEMCP,
                    0,
                    DisplayBuffer, len+1,
                    DisplayBufferAscii, ascii_len,
                    NULL,
                    NULL);
    
                success = WriteFile(hOutput, (LPVOID)DisplayBufferAscii, ascii_len,
                         &bytes_written, NULL);
    
                len = ascii_len;
    
                LocalFree(DisplayBufferAscii);
            }
        }
    
        if (!success || bytes_written != len) {
            status = GetLastError();
        }
    
        LocalFree(DisplayBuffer);
    }

    va_end(ap);
}

VOID
DisplayErr(
    PTCHAR Prefix,
    DWORD MsgNum,
    ...
    )
{
    DWORD len, bytes_written, PrefixLen;
    BOOL success = FALSE;
    DWORD status;
    va_list ap;
    LPTSTR DisplayBuffer;
    LPTSTR MessageBuffer;
    #define PREFIX_MSG TEXT(": ")

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL, MsgNum, 0,
            (LPVOID)&MessageBuffer, 0, &ap);
    if (len && MessageBuffer) {

        if (Prefix == NULL) {
            PrefixLen = 0;
        } else {
            PrefixLen = wcslen(Prefix)+wcslen(PREFIX_MSG);
        }
    
        DisplayBuffer = LocalAlloc(LPTR, (len+PrefixLen+1) * sizeof(WCHAR));
        if (DisplayBuffer != NULL) {
    
            if (NULL != Prefix) {
                lstrcpy(DisplayBuffer, Prefix);
                lstrcat(DisplayBuffer, PREFIX_MSG);
            } else {
                DisplayBuffer[0] = UNICODE_NULL;
            }
    
            lstrcat(DisplayBuffer, MessageBuffer);
    
            len = lstrlen(DisplayBuffer);
    
            if (ConsoleError) {
                success = WriteConsole(hError, (LPVOID)DisplayBuffer, len,
                         &bytes_written, NULL);
    
            } else {
                DWORD ascii_len;
                LPSTR DisplayBufferAscii;
    
                ascii_len = WideCharToMultiByte(
                    CP_OEMCP,                                 // Unicode -> OEM
                    0,                                        // gives best visual match
                    DisplayBuffer, len+1,                     // source & length
                    NULL, 0,                                  // dest & length
                    NULL,                                     // default char
                    NULL);
    
                DisplayBufferAscii = LocalAlloc(LPTR, ascii_len);
                if (DisplayBufferAscii != NULL) {
                    WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        DisplayBuffer, len+1,
                        DisplayBufferAscii, ascii_len,
                        NULL,
                        NULL);
    
                    success = WriteFile(hError, (LPVOID)DisplayBufferAscii, ascii_len,
                             &bytes_written, NULL);
    
                    LocalFree(DisplayBufferAscii);
                }
            }
    
            LocalFree(DisplayBuffer);
        }
    
        if (!success) {
            status = GetLastError();
        }
    
        LocalFree(MessageBuffer);
    }

    va_end(ap);
}

DWORD
GetResourceString(
    LPWSTR *OutStr,
    DWORD MsgNum,
    ...
    )
{

    DWORD rc = ERROR_SUCCESS;
    DWORD len;
    va_list ap;

    va_start(ap, MsgNum);

    *OutStr = NULL;

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL, 
            MsgNum, 
            0,
            (LPVOID)OutStr, 
            0, 
            &ap
            );

    if (len && *OutStr) {

        //
        // Let's get rid of \n
        //
        
        len = wcslen( *OutStr );
        if (((*OutStr)[len-1] == 0x000a) && ((*OutStr)[len-2] == 0x000d) ) {

            (*OutStr)[len-2] = 0;

        }

    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    va_end(ap);

    return rc;

}

BOOLEAN
IsNtldr(
    PTCHAR Path
    )
/*++

Routine Description:

    Used to keep the user from compressing \NTLDR (which would prevent
    the machine from booting).

Arguments:

    Path - the path to examine.

Return Value:

    TRUE - the path looks like \ntldr.
    FALSE - the path does not look like \ntldr.

--*/
{
    PTCHAR pch;

    // try "X:\ntldr"

    if (0 == lstricmp(Path + 2, TEXT("\\ntldr"))) {
        return TRUE;
    }

    // try "\\machine\share\ntldr"

    if ('\\' == Path[0] && '\\' != Path[1]) {
        pch = lstrchr(Path + 2, '\\');
        if (NULL == pch) {
            return FALSE;
        }
        pch = lstrchr(pch + 1, '\\');
        if (NULL == pch) {
            return FALSE;
        }
        if (0 == lstricmp(pch, TEXT("\\ntldr"))) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOLEAN
IsUncRoot(
    PTCHAR Path
    )
/*++

Routine Description:

    Determine whether the given path is of the form \\server\share.

Arguments:

    Path - the path to examine.

Return Value:

    TRUE - the path looks like a unc share name.
    FALSE - the path does not look like that.

--*/
{
    PTCHAR pch;

    if ('\\' != *Path || '\\' != *(Path + 1)) {
        return FALSE;
    }

    pch = lstrchr(Path + 2, '\\');
    if (NULL == pch) {
        //
        // There is no slash to seperate server and share.
        //

        return FALSE;
    }

    pch = lstrchr(pch + 1, '\\');
    if (NULL != pch) {
        //
        // There are additional component -- no match.
        //

        return FALSE;
    }

    if ('\\' == *(Path + lstrlen(Path))) {

        //
        // The string ends in slash -- it doesn't match.
        //

        return FALSE;
    }

    return TRUE;
}

ULONG
FormatFileSize(
    IN PLARGE_INTEGER FileSize,
    IN DWORD Width,
    OUT PTCHAR FormattedSize,
    IN BOOLEAN Commas
    )
{
    TCHAR Buffer[100];
    PTCHAR s, s1;
    ULONG DigitIndex, Digit;
    ULONG Size;
    LARGE_INTEGER TempSize;

    s = &Buffer[ 99 ];
    *s = TEXT('\0');
    DigitIndex = 0;
    TempSize = *FileSize;
    while (TempSize.HighPart != 0) {
        if (TempSize.HighPart != 0) {
            Digit = (ULONG)(TempSize.QuadPart % 10);
            TempSize.QuadPart = TempSize.QuadPart / 10;
        } else {
            Digit = TempSize.LowPart % 10;
            TempSize.LowPart = TempSize.LowPart / 10;
        }
        *--s = (TCHAR)(TEXT('0') + Digit);

        if ((++DigitIndex % 3) == 0 && Commas) {
            *--s = TEXT(',');
        }
    }
    Size = TempSize.LowPart;
    while (Size != 0) {
        *--s = (TCHAR)(TEXT('0') + (Size % 10));
        Size = Size / 10;

        if ((++DigitIndex % 3) == 0 && Commas) {
            *--s = TEXT(',');
        }
    }

    if (DigitIndex == 0) {
        *--s = TEXT('0');
    } else if (Commas && *s == TEXT(',')) {
        s += 1;
    }

    Size = lstrlen( s );
    if (Width != 0 && Size < Width) {
        s1 = FormattedSize;
        while (Width > Size) {
            Width -= 1;
            *s1++ = TEXT(' ');
        }
        lstrcpy( s1, s );
    } else {
        lstrcpy( FormattedSize, s );
    }

    return lstrlen( FormattedSize );
}


PTOKEN_USER
GetTokenUser(
    VOID
    )
{

    HANDLE TokenHandle;
    BOOL b;
    DWORD ReturnLength;

    PTOKEN_USER TokenInfo;

    //
    // If we're impersonating, use the thread token, otherwise
    // use the process token.
    //

    PTOKEN_USER Result = NULL;

    b = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &TokenHandle
            );

    if (!b) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            //
            // We're not impersonating, try the process token
            //

            b = OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_QUERY,
                    &TokenHandle
                    );

            if (!b) {

                return( Result );
            }

        } else {

            //
            // We failed for some unexpected reason, return NULL and
            // let the caller figure it out if he so chooses.
            //

            return( Result );
        }
    }

    ReturnLength = GetSidLengthRequired( SID_MAX_SUB_AUTHORITIES ) + sizeof( TOKEN_USER );

    TokenInfo = (PTOKEN_USER)malloc( ReturnLength );

    if (TokenInfo != NULL) {

        b = GetTokenInformation (
               TokenHandle,
               TokenUser,
               TokenInfo,
               ReturnLength,
               &ReturnLength
               );

        if (b) {

            Result = TokenInfo;

        } else {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

                //
                // Reallocate TokenInfo
                //

                free( TokenInfo );

                TokenInfo = (PTOKEN_USER)malloc( ReturnLength );

                if (TokenInfo != NULL) {

                    b = GetTokenInformation (
                           TokenHandle,
                           TokenUser,
                           TokenInfo,
                           ReturnLength,
                           &ReturnLength
                           );

                    if (b) {

                        Result = TokenInfo;
                    }

                } else {

                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
        }

    } else {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    CloseHandle( TokenHandle );

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\compact\compact.c ===
/*++

Copyright (c) 1994-2001 Microsoft Corporation

Module Name:

    Compact.c

Abstract:

    This module implements the double stuff utility for compressed NTFS
    volumes.

Author:

    Gary Kimura     [garyki]        10-Jan-1994

Revision History:


--*/

//
// Include the standard header files.
//

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include <shellapi.h>
#include <tchar.h>

#include "support.h"
#include "msg.h"

#define lstrchr wcschr
#define lstricmp _wcsicmp
#define lstrnicmp _wcsnicmp

//
//  FIRST_COLUMN_WIDTH - When compressing files, the width of the output
//  column which displays the file name
//

#define FIRST_COLUMN_WIDTH  (20)

//
//  Local procedure types
//

typedef BOOLEAN (*PACTION_ROUTINE) (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    );

typedef VOID (*PFINAL_ACTION_ROUTINE) (
    );

//
//  Declare global variables to hold the command line information
//

BOOLEAN DoSubdirectories      = FALSE;      // recurse
BOOLEAN IgnoreErrors          = FALSE;      // keep going despite errs
BOOLEAN UserSpecifiedFileSpec = FALSE;
BOOLEAN ForceOperation        = FALSE;      // compress even if already so
BOOLEAN Quiet                 = FALSE;      // be less verbose
BOOLEAN DisplayAllFiles       = FALSE;      // dsply hidden, system?
TCHAR   StartingDirectory[MAX_PATH];        // parameter to "/s"
ULONG   AttributesNoDisplay = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN;

//
//  Declere global variables to hold compression statistics
//

LARGE_INTEGER TotalDirectoryCount;
LARGE_INTEGER TotalFileCount;
LARGE_INTEGER TotalCompressedFileCount;
LARGE_INTEGER TotalUncompressedFileCount;

LARGE_INTEGER TotalFileSize;
LARGE_INTEGER TotalCompressedSize;

TCHAR Buf[1024];                            // for displaying stuff


HANDLE
OpenFileForCompress(
    IN      PTCHAR      ptcFile
    )
/*++

Routine Description:

    This routine jumps through the hoops necessary to open the file
    for READ_DATA|WRITE_DATA even if the file has the READONLY
    attribute set.

Arguments:

    ptcFile     - Specifies the file that should be opened.

Return Value:

    A handle open on the file if successfull, INVALID_HANDLE_VALUE
    otherwise, in which case the caller may use GetLastError() for more
    info.

--*/
{
    BY_HANDLE_FILE_INFORMATION fi;
    HANDLE hRet;
    HANDLE h;
    INT err;

    hRet = CreateFile(
                ptcFile,
                FILE_READ_DATA | FILE_WRITE_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if (INVALID_HANDLE_VALUE != hRet) {
        return hRet;
    }

    if (ERROR_ACCESS_DENIED != GetLastError()) {
        return INVALID_HANDLE_VALUE;
    }

    err = GetLastError();

    h = CreateFile(
            ptcFile,
            FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            );

    if (INVALID_HANDLE_VALUE == h) {
        return INVALID_HANDLE_VALUE;
    }

    if (!GetFileInformationByHandle(h, &fi)) {
        CloseHandle(h);
        return INVALID_HANDLE_VALUE;
    }

    if ((fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY) == 0) {

        // If we couldn't open the file for some reason other than that
        // the readonly attribute was set, fail.

        SetLastError(err);
        CloseHandle(h);
        return INVALID_HANDLE_VALUE;
    }

    fi.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;

    if (!SetFileAttributes(ptcFile, fi.dwFileAttributes)) {
        CloseHandle(h);
        return INVALID_HANDLE_VALUE;
    }

    hRet = CreateFile(
            ptcFile,
            FILE_READ_DATA | FILE_WRITE_DATA,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            );

    CloseHandle(h);

    if (INVALID_HANDLE_VALUE == hRet) {
        return INVALID_HANDLE_VALUE;
    }

    fi.dwFileAttributes |= FILE_ATTRIBUTE_READONLY;

    if (!SetFileAttributes(ptcFile, fi.dwFileAttributes)) {
        CloseHandle(hRet);
        return INVALID_HANDLE_VALUE;
    }

    return hRet;
}

//
//  Now do the routines to list the compression state and size of
//  a file and/or directory
//

BOOLEAN
DisplayFile (
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )
{
    LARGE_INTEGER FileSize;
    LARGE_INTEGER CompressedSize;
    TCHAR PrintState;

    ULONG Percentage = 100;
    double Ratio = 1.0;

    FileSize.LowPart = FindData->nFileSizeLow;
    FileSize.HighPart = FindData->nFileSizeHigh;
    PrintState = ' ';

    //
    //  Decide if the file is compressed and if so then
    //  get the compressed file size.
    //

    CompressedSize.LowPart = GetCompressedFileSize( FileSpec,
        &CompressedSize.HighPart );

    if (FindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {

        // detecting any error according to Jul 2000 MSDN GetCompressedFileSize doc

        if (CompressedSize.LowPart == -1 && GetLastError() != 0) {
            CompressedSize.QuadPart = 0;
        }

        PrintState = 'C';
        TotalCompressedFileCount.QuadPart += 1;

    } else {

        // detecting any error according to Jul 2000 MSDN GetCompressedFileSize doc

        if ((CompressedSize.LowPart != -1 || GetLastError() == 0) &&
            CompressedSize.QuadPart != 0 &&
            CompressedSize.QuadPart < FileSize.QuadPart) {

            // File on DblSpace partition.

            PrintState = 'd';
            TotalCompressedFileCount.QuadPart += 1;

        } else {

            CompressedSize = FileSize;
            TotalUncompressedFileCount.QuadPart += 1;
        }
    }


    //
    //  Calculate the compression ratio for this file
    //

    if (CompressedSize.QuadPart != 0) {

        if (CompressedSize.QuadPart > FileSize.QuadPart) {

            //
            // The file probably grew between the time we got its size
            // and the time we got its compressed size.  Kludge.
            //

            FileSize.QuadPart = CompressedSize.QuadPart;
        }

        Ratio = (double)FileSize.QuadPart / (double)CompressedSize.QuadPart;
    }

    //
    //  Print out the sizes compression state and file name
    //

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {

        FormatFileSize(&FileSize, 9, Buf, FALSE);
        lstrcat(Buf, TEXT(" : "));
        FormatFileSize(&CompressedSize, 9, &Buf[lstrlen(Buf)], FALSE);

        swprintf(&Buf[lstrlen(Buf)], TEXT(" = %2.1lf "), Ratio);

        if (_tcslen(DecimalPlace) == 1) {
            Buf[lstrlen(Buf)-3] = DecimalPlace[0];
        }

        DisplayMsg(COMPACT_THROW, Buf);

        DisplayMsg(COMPACT_TO_ONE);

        swprintf(Buf, TEXT("%c %s",), PrintState, FindData->cFileName);
        DisplayMsg(COMPACT_THROW_NL, Buf);
    }

    //
    //  Increment our running total
    //

    TotalFileSize.QuadPart += FileSize.QuadPart;
    TotalCompressedSize.QuadPart += CompressedSize.QuadPart;
    TotalFileCount.QuadPart += 1;

    return TRUE;
}


BOOLEAN
DoListAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen(DirectorySpec);

    //
    //  List the compression attribute for the directory
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if (0xFFFFFFFF == Attributes) {

                if (!Quiet || !IgnoreErrors) {

                    //
                    // Refrain from displaying error only when in quiet
                    // mode *and* we're ignoring errors.
                    //

                    DisplayErr(DirectorySpec, GetLastError());
                }

                if (!IgnoreErrors) {
                    return FALSE;
                }
            } else {

                if (Attributes & FILE_ATTRIBUTE_COMPRESSED) {
                    DisplayMsg(COMPACT_LIST_CDIR, DirectorySpec);
                } else {
                    DisplayMsg(COMPACT_LIST_UDIR, DirectorySpec);
                }
            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and list its compression state
    //

    {
        HANDLE FindHandle;
        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        //
        //  Make sure we don't try any paths that are too long for us
        //  to deal with.
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

            lstrcpy( DirectorySpecEnd, FileSpec );

            FindHandle = FindFirstFile( DirectorySpec, &FindData );

            if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  append the found file to the directory spec and open the
                   //  file
                   //

                   if (0 == lstrcmp(FindData.cFileName, TEXT("..")) ||
                       0 == lstrcmp(FindData.cFileName, TEXT("."))) {
                       continue;
                   }

                   //
                   //  Make sure we don't try any paths that are too long for us
                   //  to deal with.
                   //

                   if ((DirectorySpecEnd - DirectorySpec) +
                       lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                       continue;
                   }

                   lstrcpy( DirectorySpecEnd, FindData.cFileName );

                   //
                   //  Now print out the state of the file
                   //

                   DisplayFile( DirectorySpec, &FindData );

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  For if we are to do subdirectores then we will look for every
    //  subdirectory and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoListAction( DirectorySpec, FileSpec )) {

                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalListAction (
    )
{
    ULONG TotalPercentage = 100;
    double f = 1.0;

    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];
    TCHAR CompressedFileCount[32];
    TCHAR UncompressedFileCount[32];
    TCHAR CompressedSize[32];
    TCHAR FileSize[32];
    TCHAR Percentage[10];
    TCHAR Ratio[8];

    if (TotalCompressedSize.QuadPart != 0) {
        f = (double)TotalFileSize.QuadPart /
            (double)TotalCompressedSize.QuadPart;
    }

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);
    FormatFileSize(&TotalCompressedFileCount, 0, CompressedFileCount, FALSE);
    FormatFileSize(&TotalUncompressedFileCount, 0, UncompressedFileCount, FALSE);
    FormatFileSize(&TotalCompressedSize, 0, CompressedSize, TRUE);
    FormatFileSize(&TotalFileSize, 0, FileSize, TRUE);

    swprintf(Percentage, TEXT("%d"), TotalPercentage);
    swprintf(Ratio, TEXT("%2.1lf"), f);

    if (_tcslen(DecimalPlace) == 1)
        Ratio[lstrlen(Ratio)-2] = DecimalPlace[0];

    DisplayMsg(COMPACT_LIST_SUMMARY, FileCount, DirectoryCount,
               CompressedFileCount, UncompressedFileCount,
               FileSize, CompressedSize,
               Ratio );

    return;
}


BOOLEAN
CompressFile (
    IN HANDLE Handle,
    IN PTCHAR FileSpec,
    IN PWIN32_FIND_DATA FindData
    )

{
    USHORT State = 1;
    ULONG Length;
    ULONG i;
    BOOL Success;
    double f = 1.0;

    if ((FindData->dwFileAttributes &
         (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ENCRYPTED)) &&
        !ForceOperation) {

        return TRUE;
    }

    Success = DeviceIoControl(Handle, FSCTL_SET_COMPRESSION, &State,
        sizeof(USHORT), NULL, 0, &Length, FALSE );

    if (!Success) {

        if (Quiet && IgnoreErrors) {
            return FALSE || IgnoreErrors;
        }

        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(COMPACT_THROW, Buf);

        for (i = lstrlen(FindData->cFileName) + 1; i < FIRST_COLUMN_WIDTH; ++i) {
            swprintf(Buf, TEXT("%c"), ' ');
            DisplayMsg(COMPACT_THROW, Buf);
        }

        DisplayMsg(COMPACT_ERR);

        if (!Quiet && !IgnoreErrors) {
            if (ERROR_INVALID_FUNCTION == GetLastError()) {

                // This error is caused by doing the fsctl on a
                // non-compressing volume.

                DisplayMsg(COMPACT_WRONG_FILE_SYSTEM_OR_CLUSTER_SIZE, FindData->cFileName);

            } else {
                DisplayErr(FindData->cFileName, GetLastError());
            }
        }

        return FALSE || IgnoreErrors;
    }

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {
        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(COMPACT_THROW, Buf);

        for (i = lstrlen(FindData->cFileName) + 1; i < FIRST_COLUMN_WIDTH; ++i) {
            swprintf(Buf, TEXT("%c"), ' ');
            DisplayMsg(COMPACT_THROW, Buf);
        }
    }


    //
    //  Gather statistics and increment our running total
    //

    {
        LARGE_INTEGER FileSize;
        LARGE_INTEGER CompressedSize;
        ULONG Percentage = 100;

        FileSize.LowPart = FindData->nFileSizeLow;
        FileSize.HighPart = FindData->nFileSizeHigh;

        CompressedSize.LowPart = GetCompressedFileSize( FileSpec,
            &CompressedSize.HighPart );

        if (CompressedSize.LowPart == -1 && GetLastError() != 0)
            CompressedSize.QuadPart = 0;

        //
        // This statement to prevent confusion from the case where the
        // compressed file had been 0 size, but has grown since the filesize
        // was examined.
        //

        if (0 == FileSize.QuadPart) {
            CompressedSize.QuadPart = 0;
        }

        if (CompressedSize.QuadPart != 0) {

            f = (double)FileSize.QuadPart / (double)CompressedSize.QuadPart;
        }

        //
        //  Print out the sizes compression state and file name
        //

        if (!Quiet &&
            (DisplayAllFiles ||
                (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {

            FormatFileSize(&FileSize, 9, Buf, FALSE);
            lstrcat(Buf, TEXT(" : "));
            FormatFileSize(&CompressedSize, 9, &Buf[lstrlen(Buf)], FALSE);

            swprintf(&Buf[lstrlen(Buf)], TEXT(" = %2.1lf "), f);

            if (_tcslen(DecimalPlace) == 1)
                Buf[lstrlen(Buf)-3] = DecimalPlace[0];

            DisplayMsg(COMPACT_THROW, Buf);

            DisplayMsg(COMPACT_TO_ONE);
            DisplayMsg(COMPACT_OK);
        }

        //
        //  Increment our running total
        //

        TotalFileSize.QuadPart += FileSize.QuadPart;
        TotalCompressedSize.QuadPart += CompressedSize.QuadPart;
        TotalFileCount.QuadPart += 1;
    }

    return TRUE;
}

BOOLEAN
DoCompressAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  If the file spec is null then we'll set the compression bit for the
    //  the directory spec and get out.
    //

    if (lstrlen(FileSpec) == 0) {

        HANDLE FileHandle;
        USHORT State = 1;
        ULONG Length;

        FileHandle = OpenFileForCompress(DirectorySpec);

        if (INVALID_HANDLE_VALUE == FileHandle) {

            DisplayErr(DirectorySpec, GetLastError());
            return FALSE || IgnoreErrors;
        }

        DisplayMsg(COMPACT_COMPRESS_DIR, DirectorySpec);

        if (!DeviceIoControl(FileHandle, FSCTL_SET_COMPRESSION, &State,
            sizeof(USHORT), NULL, 0, &Length, FALSE )) {

            if (!Quiet || !IgnoreErrors) {
                DisplayMsg(COMPACT_ERR);
            }
            if (!Quiet && !IgnoreErrors) {
                DisplayErr(DirectorySpec, GetLastError());
            }
            CloseHandle( FileHandle );
            return FALSE || IgnoreErrors;
        }

        if (!Quiet) {
            DisplayMsg(COMPACT_OK);
        }

        CloseHandle( FileHandle );

        TotalDirectoryCount.QuadPart += 1;
        TotalFileCount.QuadPart += 1;

        return TRUE;
    }

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec );

    //
    //  List the directory that we will be compressing within and say what its
    //  current compress attribute is
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if (Attributes == 0xFFFFFFFF) {
                DisplayErr(DirectorySpec, GetLastError());
                return FALSE || IgnoreErrors;
            }

            if (Attributes & FILE_ATTRIBUTE_COMPRESSED) {

                DisplayMsg(COMPACT_COMPRESS_CDIR, DirectorySpec);

            } else {

                DisplayMsg(COMPACT_COMPRESS_UDIR, DirectorySpec);

            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and compress it
    //

    {
        HANDLE FindHandle;
        HANDLE FileHandle;

        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, FileSpec );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ( (DirectorySpecEnd - DirectorySpec) +
                           lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                           continue;
                       }

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //


                       lstrcpy( DirectorySpecEnd, FindData.cFileName );

                       //
                       //  Hack hack, kludge kludge.  Refrain from compressing
                       //  files named "\NTDLR" to help users avoid hosing
                       //  themselves.
                       //

                       if (ExcludeThisFile(DirectorySpec)) {

                           if (!Quiet) {
                               DisplayMsg(COMPACT_SKIPPING, DirectorySpecEnd);
                           }

                           continue;
                       }

                       FileHandle = OpenFileForCompress(DirectorySpec);

                       if (INVALID_HANDLE_VALUE == FileHandle) {

                           if (!Quiet || !IgnoreErrors) {
                               DisplayErr(FindData.cFileName, GetLastError());
                           }

                           if (!IgnoreErrors) {
                               FindClose(FindHandle);
                               return FALSE;
                           }
                           continue;
                       }

                       //
                       //  Now compress the file
                       //

                       if (!CompressFile( FileHandle, DirectorySpec, &FindData )) {
                           CloseHandle( FileHandle );
                           FindClose( FindHandle );
                           return FALSE || IgnoreErrors;
                       }

                       //
                       //  Close the file and go get the next file
                       //

                       CloseHandle( FileHandle );
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  If we are to do subdirectores then we will look for every subdirectory
    //  and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoCompressAction( DirectorySpec, FileSpec )) {
                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalCompressAction (
    )
{
    ULONG TotalPercentage = 100;
    double f = 1.0;

    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];
    TCHAR CompressedSize[32];
    TCHAR FileSize[32];
    TCHAR Percentage[32];
    TCHAR Ratio[8];

    if (TotalCompressedSize.QuadPart != 0) {
        f = (double)TotalFileSize.QuadPart /
            (double)TotalCompressedSize.QuadPart;
    }

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);
    FormatFileSize(&TotalCompressedSize, 0, CompressedSize, TRUE);
    FormatFileSize(&TotalFileSize, 0, FileSize, TRUE);

    swprintf(Percentage, TEXT("%d"), TotalPercentage);
    swprintf(Ratio, TEXT("%2.1f"), f);

    if (_tcslen(DecimalPlace) == 1)
        Ratio[lstrlen(Ratio)-2] = DecimalPlace[0];

    DisplayMsg(COMPACT_COMPRESS_SUMMARY, FileCount, DirectoryCount,
                FileSize, CompressedSize, Ratio );

}


BOOLEAN
UncompressFile (
    IN HANDLE Handle,
    IN PWIN32_FIND_DATA FindData
    )
{
    USHORT State = 0;
    ULONG Length;

    if (!(FindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) &&
        !ForceOperation) {

        return TRUE;
    }

    if (!DeviceIoControl(Handle, FSCTL_SET_COMPRESSION, &State,
        sizeof(USHORT), NULL, 0, &Length, FALSE )) {

        if (!Quiet || !IgnoreErrors) {

            swprintf(Buf, TEXT("%s "), FindData->cFileName);
            DisplayMsg(COMPACT_THROW, Buf);

            DisplayMsg(COMPACT_ERR);

            if (!Quiet && !IgnoreErrors) {

                if (ERROR_INVALID_FUNCTION == GetLastError()) {

                    // This error is caused by doing the fsctl on a
                    // non-compressing volume.

                    DisplayMsg(COMPACT_WRONG_FILE_SYSTEM, FindData->cFileName);

                } else {
                    DisplayErr(FindData->cFileName, GetLastError());
                }
            }
        }
        return FALSE || IgnoreErrors;
    }

    if (!Quiet &&
        (DisplayAllFiles ||
            (0 == (FindData->dwFileAttributes & AttributesNoDisplay)))) {
        swprintf(Buf, TEXT("%s "), FindData->cFileName);
        DisplayMsg(COMPACT_THROW, Buf);

        DisplayMsg(COMPACT_OK);
    }

    //
    //  Increment our running total
    //

    TotalFileCount.QuadPart += 1;

    return TRUE;
}

BOOLEAN
DoUncompressAction (
    IN PTCHAR DirectorySpec,
    IN PTCHAR FileSpec
    )

{
    PTCHAR DirectorySpecEnd;

    //
    //  If the file spec is null then we'll clear the compression bit for the
    //  the directory spec and get out.
    //

    if (lstrlen(FileSpec) == 0) {

        HANDLE FileHandle;
        USHORT State = 0;
        ULONG Length;

        FileHandle = OpenFileForCompress(DirectorySpec);

        if (INVALID_HANDLE_VALUE == FileHandle) {

            if (!Quiet || !IgnoreErrors) {
                DisplayErr(DirectorySpec, GetLastError());
            }
            CloseHandle( FileHandle );
            return FALSE || IgnoreErrors;
        }

        DisplayMsg(COMPACT_UNCOMPRESS_DIR, DirectorySpec);

        if (!DeviceIoControl(FileHandle, FSCTL_SET_COMPRESSION, &State,
            sizeof(USHORT), NULL, 0, &Length, FALSE )) {

            if (!Quiet || !IgnoreErrors) {
                DisplayMsg(COMPACT_ERR);

            }
            if (!Quiet && !IgnoreErrors) {
                DisplayErr(DirectorySpec, GetLastError());
            }
            CloseHandle( FileHandle );
            return FALSE || IgnoreErrors;
        }

        if (!Quiet) {
            DisplayMsg(COMPACT_OK);
        }

        CloseHandle( FileHandle );

        TotalDirectoryCount.QuadPart += 1;
        TotalFileCount.QuadPart += 1;

        return TRUE;
    }

    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //

    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec );

    //
    //  List the directory that we will be uncompressing within and say what its
    //  current compress attribute is
    //

    {
        ULONG Attributes;

        if (!Quiet || Quiet) {

            Attributes = GetFileAttributes( DirectorySpec );

            if (Attributes == 0xFFFFFFFF) {
                DisplayErr(DirectorySpec, GetLastError());
                return FALSE || IgnoreErrors;
            }

            if (Attributes & FILE_ATTRIBUTE_COMPRESSED) {

                DisplayMsg(COMPACT_UNCOMPRESS_CDIR, DirectorySpec);

            } else {

                DisplayMsg(COMPACT_UNCOMPRESS_UDIR, DirectorySpec);
            }
        }

        TotalDirectoryCount.QuadPart += 1;
    }

    //
    //  Now for every file in the directory that matches the file spec we will
    //  will open the file and uncompress it
    //

    {
        HANDLE FindHandle;
        HANDLE FileHandle;

        WIN32_FIND_DATA FindData;

        //
        //  setup the template for findfirst/findnext
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, FileSpec );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );

           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ((DirectorySpecEnd - DirectorySpec) +
                           lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                           continue;
                       }

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //

                       lstrcpy( DirectorySpecEnd, FindData.cFileName );

                       FileHandle = OpenFileForCompress(DirectorySpec);

                       if (INVALID_HANDLE_VALUE == FileHandle) {

                           if (!Quiet || !IgnoreErrors) {
                               DisplayErr(DirectorySpec, GetLastError());
                           }

                           if (!IgnoreErrors) {
                               FindClose( FindHandle );
                               return FALSE;
                           }
                           continue;
                       }

                       //
                       //  Now compress the file
                       //

                       if (!UncompressFile( FileHandle, &FindData )) {
                           CloseHandle( FileHandle );
                           FindClose( FindHandle );
                           return FALSE || IgnoreErrors;
                       }

                       //
                       //  Close the file and go get the next file
                       //

                       CloseHandle( FileHandle );
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    //
    //  If we are to do subdirectores then we will look for every subdirectory
    //  and recursively call ourselves to list the subdirectory
    //

    if (DoSubdirectories) {

        HANDLE FindHandle;

        WIN32_FIND_DATA FindData;

        //
        //  Setup findfirst/findnext to search the entire directory
        //

        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) <
            MAX_PATH) {

           lstrcpy( DirectorySpecEnd, TEXT("*") );

           FindHandle = FindFirstFile( DirectorySpec, &FindData );
           if (INVALID_HANDLE_VALUE != FindHandle) {

               do {

                   //
                   //  Now skip over the . and .. entries otherwise we'll recurse
                   //  like mad
                   //

                   if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                       0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                       continue;

                   } else {

                       //
                       //  If the entry is for a directory then we'll tack on the
                       //  subdirectory name to the directory spec and recursively
                       //  call otherselves
                       //

                       if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                           //
                           //  Make sure we don't try any paths that are too long for us
                           //  to deal with.
                           //

                           if ((DirectorySpecEnd - DirectorySpec) +
                               lstrlen( TEXT("\\") ) +
                               lstrlen( FindData.cFileName ) >= MAX_PATH ) {

                               continue;
                           }

                           lstrcpy( DirectorySpecEnd, FindData.cFileName );
                           lstrcat( DirectorySpecEnd, TEXT("\\") );

                           if (!DoUncompressAction( DirectorySpec, FileSpec )) {
                               FindClose( FindHandle );
                               return FALSE || IgnoreErrors;
                           }
                       }
                   }

               } while ( FindNextFile( FindHandle, &FindData ));

               FindClose( FindHandle );
           }
        }
    }

    return TRUE;
}

VOID
DoFinalUncompressAction (
    )

{
    TCHAR FileCount[32];
    TCHAR DirectoryCount[32];

    FormatFileSize(&TotalFileCount, 0, FileCount, FALSE);
    FormatFileSize(&TotalDirectoryCount, 0, DirectoryCount, FALSE);

    DisplayMsg(COMPACT_UNCOMPRESS_SUMMARY, FileCount, DirectoryCount);

    return;
}


int
__cdecl
main()
{
    PTCHAR  *argv;
    ULONG   argc;

    ULONG   i;

    PACTION_ROUTINE         ActionRoutine = NULL;
    PFINAL_ACTION_ROUTINE   FinalActionRoutine = NULL;

    BOOLEAN UserSpecifiedFileSpec = FALSE;

    TCHAR   DirectorySpec[MAX_PATH];
    TCHAR   FileSpec[MAX_PATH];
    PTCHAR  p;
    INT     rtncode;

    InitializeIoStreams();

    DirectorySpec[0] = '\0';

    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if (NULL == argv) {
        DisplayErr(NULL, GetLastError());
        return 1;
    }

    //
    //  Scan through the arguments looking for switches
    //

    for (i = 1; i < argc; i += 1) {

        if (argv[i][0] == '/') {

            if (0 == lstricmp(argv[i], TEXT("/c"))) {

                if (ActionRoutine != NULL &&
                    ActionRoutine != DoCompressAction) {

                    DisplayMsg(COMPACT_USAGE, NULL);
                    return 1;
                }

                ActionRoutine = DoCompressAction;
                FinalActionRoutine = DoFinalCompressAction;

            } else if (0 == lstricmp(argv[i], TEXT("/u"))) {

                if (ActionRoutine != NULL && ActionRoutine != DoListAction) {

                    DisplayMsg(COMPACT_USAGE, NULL);
                    return 1;
                }

                ActionRoutine = DoUncompressAction;
                FinalActionRoutine = DoFinalUncompressAction;

            } else if (0 == lstricmp(argv[i], TEXT("/q"))) {

                Quiet = TRUE;

            } else if (0 == lstrnicmp(argv[i], TEXT("/s"), 2)) {

                PTCHAR pch;

                DoSubdirectories = TRUE;

                pch = lstrchr(argv[i], ':');
                if (NULL != pch) {
                    lstrcpy(StartingDirectory, pch + 1);
                } else if (2 == lstrlen(argv[i])) {

                    // Starting dir is CWD

                    GetCurrentDirectory( MAX_PATH, StartingDirectory );

                } else {
                    DisplayMsg(COMPACT_USAGE, NULL);
                    return 1;
                }

            } else if (0 == lstricmp(argv[i], TEXT("/i"))) {

                IgnoreErrors = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/f"))) {

                ForceOperation = TRUE;

            } else if (0 == lstricmp(argv[i], TEXT("/a"))) {

                DisplayAllFiles = TRUE;

            } else {

                DisplayMsg(COMPACT_USAGE, NULL);
                if (0 == lstricmp(argv[i], TEXT("/?")))
                    return 0;
                else
                    return 1;
            }

        } else {

            UserSpecifiedFileSpec = TRUE;
        }
    }

    //
    //  If the use didn't specify an action then set the default to do a listing
    //

    if (ActionRoutine == NULL) {

        ActionRoutine = DoListAction;
        FinalActionRoutine = DoFinalListAction;
    }

    //
    //  Get our current directoy because the action routines might move us
    //  around
    //

    if (!DoSubdirectories) {
        GetCurrentDirectory( MAX_PATH, StartingDirectory );
    } else if (!SetCurrentDirectory( StartingDirectory )) {
        DisplayErr(StartingDirectory, GetLastError());
        return 1;
    }

    //
    //  If the user didn't specify a file spec then we'll do just "*"
    //

    rtncode = 0;

    if (!UserSpecifiedFileSpec) {

        (VOID)GetFullPathName( TEXT("*"), MAX_PATH, DirectorySpec, &p );

        lstrcpy( FileSpec, p ); *p = '\0';

        //
        // Also want to make "compact /c" set the bit for the current
        // directory.
        //

        if (ActionRoutine != DoListAction) {

            if (!(ActionRoutine)( DirectorySpec, TEXT("") ))
                rtncode = 1;
        }

        if (!(ActionRoutine)( DirectorySpec, FileSpec ))
            rtncode = 1;

    } else {

        //
        //  Now scan the arguments again looking for non-switches
        //  and this time do the action, but before calling reset
        //  the current directory so that things work again
        //

        for (i = 1; i < argc; i += 1) {

            if (argv[i][0] != '/') {

                SetCurrentDirectory( StartingDirectory );

                //
                // Handle a command with "." as the file argument specially,
                // since it doesn't make good sense and the results without
                // this code are surprising.
                //

                if ('.' == argv[i][0] && '\0' == argv[i][1]) {
                    argv[i] = TEXT("*");
                    GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &p);
                    *p = '\0';
                    p = NULL;
                } else {

                    PWCHAR pwch;

                    GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &p);

                    //
                    // We want to treat "foobie:xxx" as an invalid drive name,
                    // rather than as a name identifying a stream.  If there's
                    // a colon, there should be only a single character before
                    // it.
                    //

                    pwch = wcschr(argv[i], ':');
                    if (NULL != pwch && pwch - argv[i] != 1) {
                        DisplayMsg(COMPACT_INVALID_PATH, argv[i]);
                        rtncode = 1;
                        break;
                    }

                    //
                    // GetFullPathName strips trailing dots, but we want
                    // to save them so that "*." will work correctly.
                    //

                    if ((lstrlen(argv[i]) > 0) &&
                        ('.' == argv[i][lstrlen(argv[i]) - 1])) {
                        lstrcat(DirectorySpec, TEXT("."));
                    }
                }

                if (IsUncRoot(DirectorySpec)) {

                    //
                    // If the path is like \\server\share, we append an
                    // additional slash to make things come out right.
                    //

                    lstrcat(DirectorySpec, TEXT("\\"));
                    p = NULL;
                }


                if (p != NULL) {
                    lstrcpy( FileSpec, p ); *p = '\0';
                } else {
                    FileSpec[0] = '\0';
                }

                if (!(ActionRoutine)( DirectorySpec, FileSpec ) &&
                    !IgnoreErrors) {
                    rtncode = 1;
                    break;
                }
            }
        }
    }

    //
    //  Reset our current directory back
    //

    SetCurrentDirectory( StartingDirectory );

    //
    //  And do the final action routine that will print out the final
    //  statistics of what we've done
    //

    (FinalActionRoutine)();

    return rtncode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\compact\support.c ===
/*++

Copyright (c) 1994-1995  Microsoft Corporation

Module Name:

    Support.c

Abstract:

    Support routines for compact utility

Author:

    Matthew Bradburn    [mattbr]        05-Oct-1994

Revision History:


--*/

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <windows.h>
#include <tchar.h>
#include <limits.h>

#include "support.h"
#include "msg.h"


//
//  Declare routines to put out internationalized messages
//

typedef enum {
    READ_ACCESS,
    WRITE_ACCESS
} STREAMACCESS;

HANDLE
GetStandardStream(
    IN HANDLE   Handle,
    IN STREAMACCESS Access
    );

BOOLEAN
IsFile(
    IN PTCHAR   File,
    IN PTCHAR   Path
    );

HANDLE hInput;
HANDLE hOutput;
HANDLE hError;

#define STDIN   0
#define STDOUT  1
#define STDERR  2

BOOL ConsoleInput;
BOOL ConsoleOutput;
BOOL ConsoleError;

TCHAR   ThousandSeparator[8];
TCHAR   DecimalPlace[8];

int
FileIsConsole(int fh)
{
    unsigned htype;
    DWORD dwMode;
    HANDLE hFile;

    hFile = (HANDLE)_get_osfhandle(fh);
    htype = GetFileType(hFile);
    htype &= ~FILE_TYPE_REMOTE;

    if (FILE_TYPE_CHAR == htype) {

        switch (fh) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }

        if (GetConsoleMode(hFile, &dwMode)) {
            return TRUE;
        }
    }

    return FALSE;

}


VOID
InitializeIoStreams()
{
#ifdef FE_SB
    LANGID  LangId;
    LCID    lcid;

    switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            break;
    }

    SetThreadLocale( lcid = MAKELCID(LangId, SORT_DEFAULT) );

    if (!GetLocaleInfo(lcid, LOCALE_STHOUSAND, ThousandSeparator, sizeof(ThousandSeparator))) {
        _tcscpy(ThousandSeparator, TEXT(","));
    }
    if (!GetLocaleInfo(lcid, LOCALE_SDECIMAL, DecimalPlace, sizeof(DecimalPlace))) {
        _tcscpy(DecimalPlace, TEXT("."));
    }

#endif

    hInput = GetStdHandle(STD_INPUT_HANDLE);
    ConsoleInput = FileIsConsole(STDIN);

    hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    ConsoleOutput = FileIsConsole(STDOUT);

    hError = GetStdHandle(STD_ERROR_HANDLE);
    ConsoleError = FileIsConsole(STDERR);
}

TCHAR DisplayBuffer[4096];
CHAR DisplayBuffer2[4096];

VOID
DisplayMsg(DWORD MsgNum, ... )
{
    DWORD len, bytes_written;
    BOOL success;
    DWORD status;
    va_list ap;

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MsgNum, 0,
        DisplayBuffer, 4096, &ap);

    if (ConsoleOutput) {
        success = WriteConsole(hOutput, (LPVOID)DisplayBuffer, len,
                 &bytes_written, NULL);

    } else {
        CharToOem(DisplayBuffer, DisplayBuffer2);
        success = WriteFile(hOutput, (LPVOID)DisplayBuffer2, len,
                 &bytes_written, NULL);
    }

    if (!success || bytes_written != len) {
        status = GetLastError();
    }

    va_end(ap);
}

VOID
DisplayErr(
    PTCHAR Prefix,
    DWORD MsgNum,
    ...
    )
{
    DWORD len, bytes_written;
    BOOL success;
    DWORD status;
    va_list ap;
    ULONG i;

    va_start(ap, MsgNum);

    if (NULL != Prefix) {
        lstrcpy(DisplayBuffer, Prefix);
        lstrcat(DisplayBuffer, TEXT(": "));
    } else {
        DisplayBuffer[0] = UNICODE_NULL;
    }

    i = lstrlen(DisplayBuffer);

    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, MsgNum, 0,
        DisplayBuffer + i, 4096 - i, &ap);

    if (ConsoleError) {
        success = WriteConsole(hError, (LPVOID)DisplayBuffer, len + i,
                 &bytes_written, NULL);

    } else {
        CharToOem(DisplayBuffer, DisplayBuffer2);
        success = WriteFile(hError, (LPVOID)DisplayBuffer2, len + i,
                 &bytes_written, NULL);
    }

    if (!success) {
        status = GetLastError();
    }
    va_end(ap);
}

BOOLEAN
ExcludeThisFile(
    IN PTCHAR Path
    )
/*++

Routine Description:

    Used to keep the user from compressing certain files
    which the machine needs to boot up.

Arguments:

    File - name to check for
    Path - the path to examine.

Return Value:

    TRUE  - the path looks like one that should not be compressed
    FALSE - the path looks like one that can be compressed

--*/
{
  return IsFile(TEXT("\\ntldr"), Path) ||
         IsFile(TEXT("\\cmldr"), Path);
}

BOOLEAN
IsFile(
    IN PTCHAR   File,
    IN PTCHAR   Path
    )
/*++

Routine Description:

    Checks to see if the given File matches that specified by Path.

Arguments:

    File - Name to look for
    Path - Path to examine

Return Value:

    TRUE - the path looks like the specified file.
    FALSE - the path does not look like the specified file.

--*/
{
    PTCHAR pch;

    // try "X:\<File>"

    if (0 == lstricmp(Path + 2, File)) {
        return TRUE;
    }

    // try "\\machine\share\<File>"

    if ('\\' == Path[0] && '\\' != Path[1]) {
        pch = lstrchr(Path + 2, '\\');
        if (NULL == pch) {
            return FALSE;
        }
        pch = lstrchr(pch + 1, '\\');
        if (NULL == pch) {
            return FALSE;
        }
        if (0 == lstricmp(pch, File)) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOLEAN
IsUncRoot(
    PTCHAR Path
    )
/*++

Routine Description:

    Determine whether the given path is of the form \\server\share.

Arguments:

    Path - the path to examine.

Return Value:

    TRUE - the path looks like a unc share name.
    FALSE - the path does not look like that.

--*/
{
    PTCHAR pch;

    if ('\\' != *Path || '\\' != *(Path + 1)) {
        return FALSE;
    }

    pch = lstrchr(Path + 2, '\\');
    if (NULL == pch) {
        //
        // There is no slash to seperate server and share.
        //

        return FALSE;
    }

    pch = lstrchr(pch + 1, '\\');
    if (NULL != pch) {
        //
        // There are additional component -- no match.
        //

        return FALSE;
    }

    if ('\\' == *(Path + lstrlen(Path))) {

        //
        // The string ends in slash -- it doesn't match.
        //

        return FALSE;
    }

    return TRUE;
}

ULONG
FormatFileSize(
    IN PLARGE_INTEGER FileSize,
    IN DWORD Width,
    OUT PTCHAR FormattedSize,
    IN BOOLEAN Commas
    )
{
    TCHAR           Buffer[100];
    PTCHAR          s, s1;
    ULONG           DigitIndex, Digit;
    ULONG           Size;
    LARGE_INTEGER   TempSize;
    ULONG           tslen;


    s = &Buffer[ 99 ];
    *s = TEXT('\0');
    DigitIndex = 0;
    TempSize = *FileSize;
    while (TempSize.HighPart != 0) {
        if (TempSize.HighPart != 0) {
            Digit = (ULONG)(TempSize.QuadPart % 10);
            TempSize.QuadPart = TempSize.QuadPart / 10;
        } else {
            Digit = TempSize.LowPart % 10;
            TempSize.LowPart = TempSize.LowPart / 10;
        }
        *--s = (TCHAR)(TEXT('0') + Digit);

        if ((++DigitIndex % 3) == 0 && Commas) {
            tslen = _tcslen(ThousandSeparator);
            s -= tslen;
            _tcsncpy(s, ThousandSeparator, tslen);
        }
    }
    Size = TempSize.LowPart;
    while (Size != 0) {
        *--s = (TCHAR)(TEXT('0') + (Size % 10));
        Size = Size / 10;

        if ((++DigitIndex % 3) == 0 && Commas) {
            tslen = _tcslen(ThousandSeparator);
            s -= tslen;
            _tcsncpy(s, ThousandSeparator, tslen);
        }
    }

    if (DigitIndex == 0) {
        *--s = TEXT('0');
    } else if (Commas && !_tcsncmp(s, ThousandSeparator, tslen)) {
        s += 1;
    }

    Size = lstrlen( s );
    if (Width != 0 && Size < Width) {
        s1 = FormattedSize;
        while (Width > Size) {
            Width -= 1;
            *s1++ = TEXT(' ');
        }
        lstrcpy( s1, s );
    } else {
        lstrcpy( FormattedSize, s );
    }

    return lstrlen( FormattedSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\compact\support.h ===
/*++

Copyright (c) 1994-1995  Microsoft Corporation

Module Name:

    Support.h

Abstract:

    Support routine interfaces

Author:

    Matthew Bradburn    [mattbr]        05-Oct-1994

Revision History:


--*/


extern TCHAR    DecimalPlace[];
extern TCHAR    ThousandSeparator[];

extern VOID
ArrangeCommandLine(
    PTCHAR **pargv,
    int *pargc
    );

extern BOOLEAN
ExcludeThisFile(
    IN PTCHAR pch
    );

extern BOOLEAN
IsUncRoot(
    PTCHAR pch
    );

extern VOID
DisplayMsg(DWORD MsgNum, ... );

extern VOID
DisplayErr(PTCHAR Prefix, DWORD MsgNum, ... );

extern VOID
InitializeIoStreams();

#define lstrchr wcschr
#define lstricmp _wcsicmp
#define lstrnicmp _wcsnicmp

extern ULONG
FormatFileSize(
    IN  PLARGE_INTEGER FileSize,
    IN  DWORD          Width,
    OUT PTCHAR         FormattedSize,
    IN  BOOLEAN        WithCommas
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cryptmnu\classfac.cpp ===
#include "priv.h"
#include "cryptmnu.h"

CCryptMenuClassFactory::CCryptMenuClassFactory()  {
   m_ObjRefCount = 1;
   g_DllRefCount++;	
}

CCryptMenuClassFactory::~CCryptMenuClassFactory() {
   g_DllRefCount--;
}

STDMETHODIMP 
CCryptMenuClassFactory::QueryInterface( REFIID iid, void **ppvObject)  {
   if (IsEqualIID(iid,IID_IUnknown))  {
      *ppvObject = (LPUNKNOWN)(LPCLASSFACTORY) this; 	
      m_ObjRefCount++;
	  return(NOERROR);
   } 
   if (IsEqualIID(iid,IID_IClassFactory))  {
      *ppvObject = (LPCLASSFACTORY) this; 	
      m_ObjRefCount++;
	  return(NOERROR);
   }
   *ppvObject = NULL;
   return(E_NOINTERFACE);
}

STDMETHODIMP_(DWORD) 
CCryptMenuClassFactory::AddRef()  {
   return(++m_ObjRefCount);
}

STDMETHODIMP_(DWORD)
CCryptMenuClassFactory::Release()  {
   if(--m_ObjRefCount ==0)  {
   	  delete this;
   }

   return(m_ObjRefCount);
}

STDMETHODIMP 
CCryptMenuClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
							  REFIID riid,
							  void **ppvObject) {
   CCryptMenuExt *pCryptMenu;
   HRESULT hr;

   *ppvObject = NULL;

   if (pUnkOuter)  {
   	  return(CLASS_E_NOAGGREGATION);
   }
   
   pCryptMenu = new CCryptMenuExt;
   if (!pCryptMenu)  {
   	  return(E_OUTOFMEMORY);
   }

   hr = pCryptMenu->QueryInterface(riid,ppvObject);
   pCryptMenu->Release();
   
   return hr;
}

STDMETHODIMP 
CCryptMenuClassFactory::LockServer(BOOL)  {
    return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\convert\convert.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

        convert.cxx

Abstract:

        This module contains the definition of the CONVERT class, which
        implements the File System Conversion Utility.

Author:

    Ramon J. San Andres (ramonsa) sep-23-1991

Environment:

        ULIB, User Mode

--*/


#define _NTAPI_ULIB_
#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "ulibcl.hxx"
#include "arg.hxx"
#include "file.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "system.hxx"
#include "autoreg.hxx"
#include "ifssys.hxx"
#include "ifsentry.hxx"
#include "hmem.hxx"
#include "convert.hxx"
#include "supera.hxx"

extern "C" {
#include <stdio.h>
#include "undo.h"
}

#include "fatofs.hxx"


#define     AUTOCHK_PROGRAM_NAME    L"AUTOCHK.EXE"
#define     AUTOCONV_PROGRAM_NAME   L"AUTOCONV.EXE"

#define     AUTOCHK_NAME            L"AUTOCHK"
#define     AUTOCONV_NAME           L"AUTOCONV"

#define     VALUE_NAME_PATH         L"PATH"
#define     VALUE_NAME_ARGS         L"ARGUMENTS"
#define     VALUE_NAME_FS           L"TARGET FILESYSTEM"

//
//  Scheduling status codes
//
#define     CONV_STATUS_NONE        0
#define     CONV_STATUS_SCHEDULED   1

static WCHAR    NameBuffer[16];         // holds cvf name

DWORD
WINAPI
SceConfigureConvertedFileSecurity(
    IN  PWSTR   pszDriveName,
    IN  DWORD   dwConvertDisposition
    );

INT __cdecl
main (
        )

/*++

Routine Description:

        Entry point for the conversion utility.

Arguments:

    None.

Return Value:

        One of the CONVERT exit codes.

Notes:

--*/

{

    INT     ExitCode = EXIT_ERROR;      //  Let's be pessimistic

    DEFINE_CLASS_DESCRIPTOR( CONVERT );

    {
        CONVERT Convert;

        //
        //      Initialize the CONVERT object.
        //
        if ( Convert.Initialize( &ExitCode ) ) {

            //
            //      Do the conversion
            //
            ExitCode = Convert.Convert();
        }
    }

    return ExitCode;
}



DEFINE_CONSTRUCTOR( CONVERT, PROGRAM );


NONVIRTUAL
VOID
CONVERT::Construct (
    )
/*++

Routine Description:

    converts a CONVERT object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/
{
    _Autochk    =   NULL;
    _Autoconv   =   NULL;
}



NONVIRTUAL
VOID
CONVERT::Destroy (
    )
/*++

Routine Description:

    Destroys a CONVERT object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/
{
    DELETE( _Autochk );
    DELETE( _Autoconv );
}




CONVERT::~CONVERT (
        )

/*++

Routine Description:

        Destructs a CONVERT object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    Destroy();
}




BOOLEAN
CONVERT::Initialize (
        OUT PINT        ExitCode
        )

/*++

Routine Description:

    Initializes the CONVERT object. Initialization consist of allocating memory
    for certain object members and argument parsing.

Arguments:

    ExitCode    -   Supplies pointer to CONVERT exit code.

Return Value:

    BOOLEAN -   TRUE if initialization succeeded, FALSE otherwise.

Notes:

--*/

{
    Destroy();

    //
    //      Initialize program object
    //
    if ( PROGRAM::Initialize( MSG_CONV_USAGE ) ) {

        //
        //      Parse the arguments
        //
        return ParseArguments( ExitCode );
    }

    //
    //  Could not initialize the program object.
    //
    *ExitCode = EXIT_ERROR;
    return FALSE;
}


INT
CONVERT::Convert (
        )
/*++

Routine Description:

    Converts the file system in a volume.
    Depending on the current file system, it loads the appropriate
    conversion library and calls its conversion entry point.

Arguments:

    None

Return Value:

    INT -   One of the CONVERT return codes

Notes:


--*/
{
    DSTRING         CurrentFsName;      //  Name of current FS in volume
    DSTRING         LibraryName;        //  Name of library to load
    DSTRING         EntryPoint;         //  Name of entry point in DLL
    DSTRING         fat_name;
    DSTRING         fat32_name;
    DSTRING         driveletter;
    DSTRING         user_old_label;
    DSTRING         null_string;
    PWSTRING        old_volume_label = NULL;
    PATH            dos_drive_path;
    INT             ExitCode = EXIT_SUCCESS;           //  CONVERT exit code
    CONVERT_STATUS  ConvertStatus;      //  Conversion status
    NTSTATUS        Status;             //  NT API status
    HANDLE          FsUtilityHandle;    //  Handle to DLL
    CONVERT_FN      Convert;            //  Pointer to entry point in DLL
    IS_CONVERSION_AVAIL_FN      IsConversionAvailable;
    DWORD           OldErrorMode;
    DRIVE_TYPE      drive_type;
    VOL_SERIAL_NUMBER old_serial;
    BOOLEAN         Error = FALSE;
    BOOLEAN         Success;
    BOOLEAN         Result;
    ULONG           flags;

#if defined(FE_SB) && defined(_X86_)
    if(IsPC98_N()){
        CONVERT Convert2;

        Convert2.ChangeBPB1(&_NtDrive);
    }
#endif

    //      Check to see if this is an ARC System Partition--if it
    //      is, don't convert it.
    //
    if( IFS_SYSTEM::IsArcSystemPartition( &_NtDrive, &Error ) ) {

        DisplayMessage( MSG_CONV_ARC_SYSTEM_PARTITION, ERROR_MESSAGE );
        return EXIT_ERROR;
    }

    //
    //      Ask the volume what file system it has, and use that name to
    //      figure out what DLL to load.
    //
    if ( !IFS_SYSTEM::QueryFileSystemName( &_NtDrive,
                                           &CurrentFsName,
                                           &Status )) {

        if ( Status == STATUS_ACCESS_DENIED ) {
            DisplayMessage( MSG_DASD_ACCESS_DENIED, ERROR_MESSAGE );
        } else {
            DisplayMessage( MSG_FS_NOT_DETERMINED, ERROR_MESSAGE, "%W", &_DisplayDrive );
        }

        return EXIT_ERROR;
    }

    CurrentFsName.Strupr();
    _FsName.Strupr();

    if( CurrentFsName == _FsName ) {
        DisplayMessage( MSG_CONV_ALREADY_CONVERTED, ERROR_MESSAGE, "%W%W",
                        &_DisplayDrive, &_FsName );
        return EXIT_ERROR;
    }

    if (!fat_name.Initialize("FAT") ||
        !fat32_name.Initialize("FAT32")) {
        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
        return EXIT_ERROR;
    }

    if (CurrentFsName == fat_name || CurrentFsName == fat32_name) {

        if ( !LibraryName.Initialize( "CNVFAT" ) ||
             !EntryPoint.Initialize( "IsConversionAvailable" ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            return( EXIT_ERROR );
        }

        //
        //  Get pointer to the conversion entry point and convert the volume.
        //
        if (NULL == (IsConversionAvailable =
                     (IS_CONVERSION_AVAIL_FN)SYSTEM::QueryLibraryEntryPoint(
                      &LibraryName, &EntryPoint, &FsUtilityHandle ))) {
            //
            //  There is no conversion DLL for the file system in the volume.
            //
            DisplayMessage( MSG_FS_NOT_SUPPORTED, ERROR_MESSAGE, "%s%W",
                            "CONVERT", &CurrentFsName );
            return EXIT_ERROR;
        }

        if (IsConversionAvailable(&_FsName) == -1) {
            DisplayMessage ( MSG_CONV_CONVERSION_NOT_AVAILABLE, ERROR_MESSAGE,
                             "%W%W", &CurrentFsName, &_FsName );
            return EXIT_ERROR;
        }

    } else {
        DisplayMessage( MSG_FS_NOT_SUPPORTED, ERROR_MESSAGE, "%s%W",
                        "CONVERT", &CurrentFsName );
        return EXIT_ERROR;
    }

    //
    //  Display the current file system type. (Standard in all file system utilities)
    //
    DisplayMessage( MSG_FILE_SYSTEM_TYPE, NORMAL_MESSAGE, "%W", &CurrentFsName );

    //
    //  We also initialize the name of the conversion entry point in the DLL
    //  ("Convert")
    //
    if ( !EntryPoint.Initialize( "ConvertFAT" )) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        return( EXIT_ERROR );
    }

    //
    //  Get pointer to the conversion entry point and convert the volume.
    //
    if (NULL == (Convert = (CONVERT_FN)SYSTEM::QueryLibraryEntryPoint(
        &LibraryName, &EntryPoint, &FsUtilityHandle ))) {
        //
        //  There is no conversion DLL for the file system in the volume.
        //
        DisplayMessage( MSG_FS_NOT_SUPPORTED, ERROR_MESSAGE, "%s%W",
                        "CONVERT", &CurrentFsName );
        return EXIT_ERROR;
    }


    // If the volume has a label, prompt the user for it.
    // Note that if it has no label we do nothing.

    OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    drive_type = SYSTEM::QueryDriveType(&_DosDrive);

    if (null_string.Initialize( "" ) &&
        (drive_type != RemovableDrive) &&
        dos_drive_path.Initialize( &_DosDrive) &&
        (old_volume_label =
         SYSTEM::QueryVolumeLabel( &dos_drive_path,
                                   &old_serial )) != NULL &&
        old_volume_label->Stricmp( &null_string ) != 0 ) {

        // This drive has a label. To give the user
        // a bit more protection, prompt for the old label:

        DisplayMessage( MSG_ENTER_CURRENT_LABEL, NORMAL_MESSAGE, "%W",
                        &_DisplayDrive );

        _Message.QueryStringInput( &user_old_label );

        if( old_volume_label->Stricmp( &user_old_label ) != 0 ) {

            // Re-enable hard error popups.
            SetErrorMode( OldErrorMode );

            DisplayMessage( MSG_WRONG_CURRENT_LABEL, ERROR_MESSAGE );

            DELETE( old_volume_label );

            return EXIT_ERROR;
        }
    }

    // Re-enable hard error popups

    SetErrorMode( OldErrorMode );

    DELETE( old_volume_label );

    BOOLEAN         delete_uninstall_backup = FALSE;
    OSVERSIONINFOEX os_version_info;

    if (Uninstall_Valid == IsUninstallImageValid(Uninstall_FatToNtfsConversion, &os_version_info)) {
        DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP, NORMAL_MESSAGE );
        if (!_Message.IsYesResponse(FALSE)) {
            return EXIT_ERROR;
        }
        delete_uninstall_backup = TRUE;
    }


    flags = _Verbose ? CONVERT_VERBOSE_FLAG : 0;
    flags |= _NoChkdsk ? CONVERT_NOCHKDSK_FLAG : 0;
    flags |= _ForceDismount ? CONVERT_FORCE_DISMOUNT_FLAG : 0;
    flags |= _NoSecurity ? CONVERT_NOSECURITY_FLAG : 0;
    //
    // no pause flag needed since we don't want to pause
    //

    Result = Convert( &_NtDrive,
                      &_FsName,
                      &_CvtZoneFileName,
                      &_Message,
                      flags,
                      &ConvertStatus);

    SYSTEM::FreeLibraryHandle( FsUtilityHandle );

    if ( Result ) {

        DWORD       sce_result = NO_ERROR;

        ExitCode = EXIT_SUCCESS;

        if (!_NoSecurity && _DosDrive.QueryChCount() == 2 && _DosDrive.QueryChAt(1) == ':') {

            DSTRING     msg;

            sce_result = SceConfigureConvertedFileSecurity( (PWSTR)_DosDrive.GetWSTR(), 0 );
            if ( sce_result != NO_ERROR ) {
                if ( SYSTEM::QueryWindowsErrorMessage( sce_result, &msg ) ) {
                    DisplayMessage( MSG_CONV_SCE_FAILURE_WITH_MESSAGE, ERROR_MESSAGE, "%W", &msg );
                } else {
                    DisplayMessage( MSG_CONV_SCE_SET_FAILURE, ERROR_MESSAGE, "%d", sce_result );
                }
            }
        }

        if (!NT_SUCCESS(SUPERAREA::GenerateLabelNotification(&_NtDrive))) {
            DisplayMessage( MSG_CONV_UNABLE_TO_NOTIFY, ERROR_MESSAGE );
            ExitCode = EXIT_ERROR;
        }

        if (delete_uninstall_backup && !RemoveUninstallImage()) {

            DWORD       last_error = GetLastError();
            DSTRING     errmsg;

            if (SYSTEM::QueryWindowsErrorMessage( last_error, &errmsg )) {
                DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP_ERROR, ERROR_MESSAGE, "%W", &errmsg );
            } else {
                DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP_ERROR, ERROR_MESSAGE, "%d", last_error );
            }
            ExitCode = EXIT_ERROR;
        }

        //
        // We're done.
        //
        if ( sce_result == NO_ERROR && ExitCode == EXIT_SUCCESS ) {
            DisplayMessage( MSG_CONV_CONVERSION_COMPLETE, NORMAL_MESSAGE );
            return EXIT_SUCCESS;
        } else {
            return EXIT_ERROR;
        }

    } else {

        //
        //  The conversion was not successful. Determine what the problem
        //  was and return the appropriate CONVERT exit code.
        //
        switch ( ConvertStatus ) {

          case CONVERT_STATUS_CONVERTED:
            //
            //  This is an inconsistent state, Convert should return
            //  TRUE if the conversion was successful!
            //
            DebugPrintTrace(( "CONVERT Error: Conversion failed, but status is success!\n" ));
            DebugAssert( FALSE );
            DisplayMessage( MSG_CONV_CONVERSION_MAYHAVE_FAILED, ERROR_MESSAGE,
                            "%W%W", &_DisplayDrive, &_FsName );
            ExitCode = EXIT_ERROR;
            break;

          case CONVERT_STATUS_INVALID_FILESYSTEM:
            //
            //  The conversion DLL does not recognize the target file system.
            //
            DisplayMessage( MSG_CONV_INVALID_FILESYSTEM, ERROR_MESSAGE, "%W", &_FsName );
            ExitCode = EXIT_UNKNOWN;
            break;

          case CONVERT_STATUS_CONVERSION_NOT_AVAILABLE:
            //
            //  The target file system is valid, but the conversion is not
            //  available.
            //
            DisplayMessage( MSG_CONV_CONVERSION_NOT_AVAILABLE, ERROR_MESSAGE,
                            "%W%W", &CurrentFsName, &_FsName );
            ExitCode = EXIT_NOCANDO;
            break;

          case CONVERT_STATUS_NTFS_RESERVED_NAMES:
            DisplayMessage( MSG_CONV_NTFS_RESERVED_NAMES, ERROR_MESSAGE, "%W", &_DisplayDrive );
            ExitCode = EXIT_ERROR;
            break;

          case CONVERT_STATUS_WRITE_PROTECTED:
            DisplayMessage( MSG_CONV_WRITE_PROTECTED, ERROR_MESSAGE, "%W", &_DisplayDrive );
            ExitCode = EXIT_ERROR;
            break;

          case CONVERT_STATUS_CANNOT_LOCK_DRIVE:
            //
            //  The drive cannot be locked. We must schedule ChkDsk and AutoConv
            //  to do the job during the next system boot.
            //

            DisplayMessage( MSG_CONVERT_ON_REBOOT_PROMPT, NORMAL_MESSAGE, "%W",
                            &_DisplayDrive );

            // Note that ScheduleAutoConv reports its success or
            // failure, so no additional messages are required.
            //
            if ( _Message.IsYesResponse( FALSE ) &&
                 ScheduleAutoConv() ) {
                if (!_NoSecurity && _DosDrive.QueryChCount() == 2 && _DosDrive.QueryChAt(1) == ':') {

                    DSTRING     msg;
                    DWORD       sce_result;

                    sce_result = SceConfigureConvertedFileSecurity( (PWSTR)_DosDrive.GetWSTR(), 1 );
                    if ( sce_result != NO_ERROR ) {
                        if ( SYSTEM::QueryWindowsErrorMessage( sce_result, &msg ) ) {
                            DisplayMessage( MSG_CONV_SCE_FAILURE_WITH_MESSAGE, ERROR_MESSAGE, "%W", &msg );
                        } else {
                            DisplayMessage( MSG_CONV_SCE_SCHEDULE_FAILURE, ERROR_MESSAGE, "%d", sce_result );
                        }
                        //
                        // error in setting up security for files
                        //
                        ExitCode = EXIT_ERROR;
                    } else {
                        ExitCode = EXIT_SCHEDULED;
                    }

                } else {
                    //
                    // no need to worry about security and so return success
                    //
                    ExitCode = EXIT_SCHEDULED;
                }

                if (delete_uninstall_backup && !RemoveUninstallImage()) {

                    DWORD       last_error = GetLastError();
                    DSTRING     errmsg;

                    if (SYSTEM::QueryWindowsErrorMessage( last_error, &errmsg )) {
                        DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP_ERROR, ERROR_MESSAGE, "%W", &errmsg );
                    } else {
                        DisplayMessage( MSG_CONV_DELETE_UNINSTALL_BACKUP_ERROR, ERROR_MESSAGE, "%d", last_error );
                    }
                    ExitCode = EXIT_ERROR;
                }

            } else {
                //
                // Don't want to schedule a convert or scheduling failed
                //
                ExitCode = EXIT_ERROR;
            }

            break;

          case CONVERT_STATUS_INSUFFICIENT_FREE_SPACE:
          case CONVERT_STATUS_DRIVE_IS_DIRTY:
          case CONVERT_STATUS_ERROR:
            //
            //  The conversion failed.
            //
            DisplayMessage( MSG_CONV_CONVERSION_FAILED, ERROR_MESSAGE,
                            "%W%W", &_DisplayDrive, &_FsName );
            if(ConvertStatus == CONVERT_STATUS_INSUFFICIENT_FREE_SPACE) {
                ExitCode = EXIT_NOFREESPACE;
            } else {
                ExitCode = EXIT_ERROR;
            }
            break;

          default:
            //
            //  Invalid status code
            //
            DebugPrintTrace(( "CONVERT Error: Convert status code %X invalid!\n",
                              ConvertStatus ));
            DisplayMessage( MSG_CONV_CONVERSION_FAILED, ERROR_MESSAGE,
                            "%W%W", &_DisplayDrive, &_FsName );
            ExitCode = EXIT_ERROR;
            break;
        }

        return ExitCode;
    }
}


PPATH
CONVERT::FindSystemFile(
    IN  PWSTR   FileName
    )

/*++

Routine Description:

    Makes sure that the given file is in the system directory.

Arguments:

    FileName    -   Supplies the name of the file to look for.

Return Value:

    PPATH   -   Path to the file found

--*/

{


    DSTRING     Name;
    PPATH       Path    = NULL;
    PFSN_FILE   File    = NULL;


    if ( !(Path = SYSTEM::QuerySystemDirectory() ) ) {

        DisplayMessage( MSG_CONV_CANNOT_FIND_SYSTEM_DIR, ERROR_MESSAGE );
        return FALSE;

    }

    if ( !Name.Initialize( FileName ) ||
         !Path->AppendBase( &Name ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE   );
        DELETE( Path );
                return FALSE;
    }


    if ( !(File = SYSTEM::QueryFile( Path )) ) {
        DisplayMessage( MSG_CONV_CANNOT_FIND_FILE, ERROR_MESSAGE, "%W", Path->GetPathString() );
        DELETE( Path );
                return FALSE;
    }

    DELETE( File );

    return Path;
}





BOOLEAN
CONVERT::ParseArguments(
        OUT PINT                        ExitCode
        )

/*++

Routine Description:

    Parses the command line and sets the parameters used by the conversion
        utility.

    The arguments accepted are:

        drive:              Drive to convert
        /fs:fsname          File system to convert to
        /v                  Verbose mode
        /?                  Help
        /CVTAREA:filename   Filename for convert zone as place holder
                            for the $MFT, $Logfile, and Volume bitmap
        /NoSecurity         Allow everyone access
        /NoChkdsk           Skip chkdsk
        /x                  Force a dismount on the volume if necessary


Arguments:

    ExitCode -          Supplies pointer to CONVERT exit code

Return Value:

    BOOLEAN - TRUE if arguments were parsed correctly and program can
                    continue.
              FALSE if the program should exit. ExitCode contains the
                    value with which the program should exit. Note that this
                    does not necessarily means an error (e.g. user requested
                    help).

--*/

{

    UCHAR       SequenceNumber;

    PATH                path;
    DSTRING             drive_path_string;
    PATH_ANALYZE_CODE   rst;

    DebugPtrAssert( ExitCode );

    //
    //  Parse command line
    //
    if ( !ParseCommandLine( NULL, TRUE ) ) {

        *ExitCode = EXIT_ERROR;
        return FALSE;
    }

        //
        //      If the user requested help, give it.
        //
    if ( _Help ) {
        DisplayMessage( MSG_CONV_USAGE );
        *ExitCode = EXIT_SUCCESS;
        return FALSE;
    }


#ifdef DBLSPACE_ENABLED
    if (_Compress && !_Uncompress) {
        //
        // We don't allow you to specify /c (compress resulting
        // filesystem) unless the source filesystem has dblspace.
        //

        DisplayMessage(MSG_CONV_SLASH_C_INVALID, ERROR_MESSAGE);
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }
#endif // DBLSPACE_ENABLED

    //
    //  If the command line did not specify a drive, we use the
    //  current drive.
    //
    if ( _DosDrive.QueryChCount() == 0 ) {

        if ( !SYSTEM::QueryCurrentDosDriveName( &_DosDrive ) ) {

            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;
        }
    }

    if ( !path.Initialize( &_DosDrive ) ) {

        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }

    rst = path.AnalyzePath( &_GuidDrive,
                            &_FullPath,
                            &drive_path_string );

    switch (rst) {
        case PATH_OK:
        case PATH_COULD_BE_FLOPPY:
            if (drive_path_string.QueryChCount() != 0) {
                DisplayMessage( MSG_CONV_INVALID_DRIVE_SPEC, ERROR_MESSAGE );
                *ExitCode = EXIT_ERROR;
                return FALSE;
            }
            if (path.IsGuidVolName()) {
                if (!_DisplayDrive.Initialize(&_GuidDrive)) {
                    DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                    *ExitCode = EXIT_ERROR;
                    return FALSE;
                }
            } else {
                if (!_DisplayDrive.Initialize(_FullPath.GetPathString())) {
                    DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                    *ExitCode = EXIT_ERROR;
                    return FALSE;
                }
            }
            if (_FullPath.GetPathString()->QueryChCount() == 2 &&
                _FullPath.GetPathString()->QueryChAt(1) == (WCHAR)':') {
                // if there is a drive letter for this drive, use it
                // instead of the guid volume name
                if (!_DosDrive.Initialize(_FullPath.GetPathString())) {
                    DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                    *ExitCode = EXIT_ERROR;
                    return FALSE;
                }
            } else {
                if (!_DosDrive.Initialize(&_GuidDrive)) {
                    DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                    *ExitCode = EXIT_ERROR;
                    return FALSE;
                }
            }
            break;

        case PATH_OUT_OF_MEMORY:
            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        case PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH:
            DisplayMessage( MSG_CONV_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        default:
            DisplayMessage( MSG_CONV_INVALID_DRIVE_SPEC, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;
    }

    if (!_DosDrive.Strupr()) {
        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }

    //
    // Make sure that drive is valid and is not remote.
    //
    switch ( SYSTEM::QueryDriveType( &_DosDrive ) ) {

        case UnknownDrive:
            DisplayMessage( MSG_CONV_INVALID_DRIVE_SPEC, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        case CdRomDrive:
            DisplayMessage( MSG_CONV_CANT_CDROM, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        case RemoteDrive:
            DisplayMessage( MSG_CONV_CANT_NETWORK, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;

        default:
            break;

    }

    //
    //  Make sure a target file system was specified. Note that we do not
    //  validate the file system, we accept any string.
    //
    if ( _FsName.QueryChCount() == 0 ) {
        DisplayMessage( MSG_CONV_NO_FILESYSTEM_SPECIFIED, ERROR_MESSAGE );
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }



    //
    //  Set other object members.
    //
    if ( !IFS_SYSTEM::DosDriveNameToNtDriveName( &_DosDrive, &_NtDrive )) {
        DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        *ExitCode = EXIT_ERROR;
        return FALSE;
    }

#ifdef DBLSPACE_ENABLED
    //
    // If we're to uncompress a dblspace volume, generate the cvf name.
    //

    if (_Uncompress) {
        swprintf(NameBuffer, L"DBLSPACE.%03d", SequenceNumber);

        if ( _FullPath.GetPathString()->QueryChCount() == 0 ) {
            DisplayMessage( MSG_CONV_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH, ERROR_MESSAGE );
            *ExitCode = EXIT_ERROR;
            return FALSE;
        }
        if (!_CvfName.Initialize(NameBuffer)) {
            DisplayMessage(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
            *ExitCode = EXIT_ERROR;
            return FALSE;
        }
    }
#endif // DBLSPACE_ENABLED

    *ExitCode = EXIT_SUCCESS;
    return TRUE;
}



BOOLEAN
CONVERT::ParseCommandLine (
    IN      PCWSTRING   CommandLine,
    IN      BOOLEAN     Interactive
    )
/*++

Routine Description:

    Parses the CONVERT (AUTOCONV) command line.

    The arguments accepted are:

        drive:                  Drive to convert
        /fs:fsname              File system to convert to
        /v                      Verbose mode
        /uncompress[:sss]       Convert from dblspace
        /c                      Compress resulting filesystem
        /?                      Help
        /CVTAREA:filename       Filename for convert zone as place holder
                                for the $MFT, $Logfile, and Volume bitmap

Arguments:

    CommandLine     -   Supplies command line to parse
    Interactive     -   Supplies Interactive flag

Return Value:

    BOOLEAN - TRUE if arguments were parsed correctly.

--*/

{
    ARRAY               ArgArray;               //  Array of arguments
    ARRAY               LexArray;               //  Array of lexemes
    ARGUMENT_LEXEMIZER  ArgLex;                 //  Argument Lexemizer
    STRING_ARGUMENT     DriveArgument;          //  Drive argument
    STRING_ARGUMENT     ProgramNameArgument;    //  Program name argument
    STRING_ARGUMENT     FsNameArgument;         //  Target FS name argument
    STRING_ARGUMENT     ConvertZoneArgument;    //  Convert Zone file name
    FLAG_ARGUMENT       HelpArgument;           //  Help flag argument
    FLAG_ARGUMENT       VerboseArgument;        //  Verbose flag argument
    FLAG_ARGUMENT       NoSecurityArgument;     //  Skip setting of security argument
    FLAG_ARGUMENT       NoChkdskArgument;       //  Skip chkdsk argument
    FLAG_ARGUMENT       ForceDismountArgument;  //  Force a dismount argument
#ifdef DBLSPACE_ENABLED
    FLAG_ARGUMENT       UncompressArgument;     //  Uncompress flag argument
    FLAG_ARGUMENT       CompressArgument;       //  Compress flag argument
    LONG_ARGUMENT       UncompressNumberArgument;// Sequence number argument
#endif // DBLSPACE_ENABLED
    PWSTRING            InvalidArg;             //  Invalid argument catcher


    //
    //      Initialize all the argument parsing machinery.
    //
    if( !ArgArray.Initialize( 7, 1 )                    ||
        !LexArray.Initialize( 7, 1 )                    ||
        !ArgLex.Initialize( &LexArray )                 ||
        !DriveArgument.Initialize( "*" )                ||
        !HelpArgument.Initialize( "/?" )                ||
        !VerboseArgument.Initialize( "/V" )             ||
        !NoSecurityArgument.Initialize( "/NoSecurity" ) ||
        !NoChkdskArgument.Initialize( "/NoChkdsk" )     ||
        !ForceDismountArgument.Initialize( "/X" )       ||
#ifdef DBLSPACE_ENABLED
        !CompressArgument.Initialize( "/C" )            ||
#endif // DBLSPACE_ENABLED
        !ProgramNameArgument.Initialize( "*" )          ||
#ifdef DBLSPACE_ENABLED
        !UncompressArgument.Initialize( "/UNCOMPRESS" ) ||
        !UncompressNumberArgument.Initialize( "/UNCOMPRESS:*" ) ||
#endif // DBLSPACE_ENABLED
        !FsNameArgument.Initialize( "/FS:*" )           ||
        !ConvertZoneArgument.Initialize( "/CVTAREA:*" ) ) {

        if ( Interactive ) {
            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        }
        return FALSE;
    }

    //
    //  The conversion utility is case-insensitive
    //
    ArgLex.SetCaseSensitive( FALSE );

    if( !ArgArray.Put( &ProgramNameArgument )           ||
        !ArgArray.Put( &HelpArgument )                  ||
        !ArgArray.Put( &DriveArgument )                 ||
        !ArgArray.Put( &VerboseArgument )               ||
        !ArgArray.Put( &NoSecurityArgument )            ||
        !ArgArray.Put( &NoChkdskArgument )              ||
        !ArgArray.Put( &ForceDismountArgument )         ||
#ifdef DBLSPACE_ENABLED
        !ArgArray.Put( &CompressArgument )              ||
#endif // DBLSPACE_ENABLED
#ifdef DBLSPACE_ENABLED
        !ArgArray.Put( &UncompressArgument )            ||
        !ArgArray.Put( &UncompressNumberArgument )      ||
#endif // DBLSPACE_ENABLED
        !ArgArray.Put( &FsNameArgument )                ||
        !ArgArray.Put( &ConvertZoneArgument ) ) {

        if ( Interactive ) {
            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        }
        return FALSE;
    }

    //
    //  Lexemize the command line.
    //
    if ( !ArgLex.PrepareToParse( (PWSTRING)CommandLine ) ) {

        if ( Interactive ) {
            DisplayMessage( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        }
                return FALSE;
    }

        //
        //      Parse the arguments.
        //
    if( !ArgLex.DoParsing( &ArgArray ) ) {

        if ( Interactive ) {
            DisplayMessage( MSG_CONV_INVALID_PARAMETER, ERROR_MESSAGE, "%W",
                            InvalidArg = ArgLex.QueryInvalidArgument() );
            DELETE( InvalidArg );
        }
                return FALSE;
    }


    _Help       = HelpArgument.QueryFlag();
    _Verbose    = VerboseArgument.QueryFlag();
    _NoSecurity = NoSecurityArgument.QueryFlag();
    _NoChkdsk   = NoChkdskArgument.QueryFlag();
    _ForceDismount = ForceDismountArgument.QueryFlag();
    _Restart    = FALSE;    // obsolete argument
#ifdef DBLSPACE_ENABLED
    _Compress   = CompressArgument.QueryFlag();
#endif // DBLSPACE_ENABLED


    if ( DriveArgument.IsValueSet() ) {
        if ( !_DosDrive.Initialize( DriveArgument.GetString() ) ) {
            return FALSE;
        }

    } else {
        if ( !_DosDrive.Initialize( L"" ) ) {
            return FALSE;
        }
    }

    if ( FsNameArgument.IsValueSet() ) {
        if ( !_FsName.Initialize( FsNameArgument.GetString() ) ) {
            return FALSE;
        }
    } else {
        if ( !_FsName.Initialize( L"" ) ) {
            return FALSE;
        }
    }

    if( ConvertZoneArgument.IsValueSet() ) {

        if( !_CvtZoneFileName.Initialize( ConvertZoneArgument.GetString() ) ) {

            return FALSE;
        }

    } else {

        _CvtZoneFileName.Initialize( L"" );
    }

#ifdef DBLSPACE_ENABLED
    _SequenceNumber = 0;

    _Uncompress = FALSE;
    if (UncompressArgument.IsValueSet()) {
        _Uncompress = TRUE;
    }
    if (UncompressNumberArgument.IsValueSet()) {
        _SequenceNumber = (UCHAR)UncompressNumberArgument.QueryLong();
        _Uncompress = TRUE;
    }
#endif // DBLSPACE_ENABLED

    return TRUE;
}



BOOLEAN
CONVERT::Schedule (
    )

/*++

Routine Description:

    Schedules AutoConv

Arguments:

    None.

Return Value:

    BOOLEAN -   TRUE if AutoConv successfully scheduled.
                FALSE otherwise

--*/

{
    DSTRING CommandLine;
    DSTRING Space;
    DSTRING FileSystem;
    DSTRING ConvertZoneFlag;
    DSTRING NoChkdskFlag;
    DSTRING VerboseFlag;
    DSTRING NoSecurityFlag;

    if( !CommandLine.Initialize( (LPWSTR)L"autocheck autoconv " )   ||
        !Space.Initialize( (LPWSTR)L" " )                           ||
        !FileSystem.Initialize( (LPWSTR)L"/FS:" )                   ||
        !CommandLine.Strcat( &_NtDrive )                            ||
        !CommandLine.Strcat( &Space )                               ||
        !CommandLine.Strcat( &FileSystem )                          ||
        !CommandLine.Strcat( &_FsName ) ) {

        return FALSE;
    }

    if( _CvtZoneFileName.QueryChCount() &&
        ( !CommandLine.Strcat( &Space )                 ||
          !ConvertZoneFlag.Initialize( L"/CVTAREA:" )   ||
          !CommandLine.Strcat( &ConvertZoneFlag )       ||
          !CommandLine.Strcat( &_CvtZoneFileName ) ) ) {

        return FALSE;
    }

    if( _NoChkdsk &&
        ( !CommandLine.Strcat( &Space )              ||
          !NoChkdskFlag.Initialize( L"/NoChkdsk" )   ||
          !CommandLine.Strcat( &NoChkdskFlag ) ) ) {

        return FALSE;
    }

    if( _Verbose &&
        ( !CommandLine.Strcat( &Space )      ||
          !VerboseFlag.Initialize( L"/V" )   ||
          !CommandLine.Strcat( &VerboseFlag ) ) ) {

        return FALSE;
    }

    if( _NoSecurity &&
        ( !CommandLine.Strcat( &Space )      ||
          !NoSecurityFlag.Initialize( L"/NoSecurity" )   ||
          !CommandLine.Strcat( &NoSecurityFlag ) ) ) {

        return FALSE;
    }

    //
    // There is no need to add options that are only for convert.exe
    // like /x.
    //
    return( AUTOREG::AddEntry( &CommandLine ) );
}



BOOLEAN
CONVERT::ScheduleAutoConv(
        )

/*++

Routine Description:

    Schedules AutoConv to be invoked during boot the next time
    that the machine reboots.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if AutoConv successfully scheduled.
                FALSE otherwise

--*/

{
    BOOLEAN     Ok;

    //
    //  Make sure that Autoconv.exe is in the right place.
    //
    if ( !(_Autoconv = FindSystemFile( (LPWSTR)AUTOCONV_PROGRAM_NAME )) ) {
        DisplayMessage( MSG_CONV_CANNOT_SCHEDULE, ERROR_MESSAGE );
        return FALSE;
    }

    // Remove any previously scheduled conversion
    //
    if ( !RemoveScheduledAutoConv( ) ) {
        DisplayMessage( MSG_CONV_CANNOT_SCHEDULE, ERROR_MESSAGE );
        return FALSE;
    }

    //
    //  schedule autoconvert
    //
    if ( Ok = Schedule( ) ) {
        DisplayMessage( MSG_CONV_WILL_CONVERT_ON_REBOOT, NORMAL_MESSAGE, "%W", &_DisplayDrive );
    } else {
        DisplayMessage( MSG_CONV_CANNOT_SCHEDULE, ERROR_MESSAGE );
    }

    return Ok;
}



BOOLEAN
CONVERT::RemoveScheduledAutoConv(
    )
/*++

Routine Description:

    Remove possibly old entry of autoconv for the specified volume.

Arguments:

    N/A

Return Value:

    TRUE if no error.

--*/

{
    DSTRING CommandLine;
    DSTRING NtDrive;

    if (!CommandLine.Initialize( (LPWSTR)L"autocheck autoconv " )) {
        return FALSE;
    }

    if (!AUTOREG::DeleteEntry(&CommandLine, &_NtDrive)) {
        return FALSE;
    }

    if (_DosDrive.Stricmp(&_GuidDrive) == 0)
        return FALSE;

    DebugAssert(_DosDrive.QueryChCount() == 2);

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&_GuidDrive, &NtDrive)) {
        return FALSE;
    }

    if (!AUTOREG::DeleteEntry(&CommandLine, &NtDrive)) {
        return FALSE;
    }

    return TRUE;
}

#if defined(FE_SB) && defined(_X86_)

BOOLEAN
CONVERT::ChangeBPB1(
    IN      PCWSTRING     NtDrive
        )

/*++

Routine Description:

    Change Bpb parameters Logical to Physical

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE  Change OK
                FALSE otherwise

--*/

{
    USHORT              work,work2;
    ULONG               work3;

    BIG_INT             start_sec;
    ULONG               sector_len;
    PUCHAR      Bpb_Buff;
    HMEM        hmem;

    _NtDrive.Initialize(NtDrive);

    start_sec=0;
    sector_len=1;
    LOG_IO_DP_DRIVE    dpdrive;
//*** open
    if (!dpdrive.Initialize( &_NtDrive, &_Message )) {
        return FALSE;
    }

    if (!hmem.Acquire(2048, dpdrive.QueryAlignmentMask())) {
        return(FALSE);
    }
    Bpb_Buff = (PUCHAR)hmem.GetBuf();

//*** read
      if(!dpdrive.Read( start_sec, sector_len, Bpb_Buff)){
         return FALSE;
      }

        work=(USHORT)dpdrive.QueryPhysicalSectorSize();     // get physical sector size

//*** change to physical from logical ***
        _BytePerSec  = Bpb_Buff[11]+Bpb_Buff[12]*256;
        _SecPerClus  = Bpb_Buff[13];
        _Reserved    = Bpb_Buff[14]+Bpb_Buff[15]*256;
        _SectorNum   = Bpb_Buff[19]+Bpb_Buff[20]*256;
        _SecPerFat   = Bpb_Buff[22]+Bpb_Buff[23]*256;
        _LargeSector = Bpb_Buff[32]+Bpb_Buff[33]*256+Bpb_Buff[34]*256*256+Bpb_Buff[35]*256*256*256;
        if (work != _BytePerSec){
            Bpb_Buff[11] = (UCHAR)(work%256);
            Bpb_Buff[12] = (UCHAR)(work/256);
            Bpb_Buff[13]*= (UCHAR)(_BytePerSec/work);
            work2 = _Reserved*_BytePerSec/work;
            Bpb_Buff[14] = (UCHAR)(work2%256);
            Bpb_Buff[15] = (UCHAR)(work2/256);
            work2 = _SecPerFat*_BytePerSec/work;
            Bpb_Buff[22] = (UCHAR)(work2%256);
            Bpb_Buff[23] = (UCHAR)(work2/256);
            if (_SectorNum*(_BytePerSec/work)>0xffff){
                Bpb_Buff[19] = 0;
                Bpb_Buff[20] = 0;
                work3 = ((long)_SectorNum*(long)(_BytePerSec/work));
                Bpb_Buff[32] = (UCHAR)(work3%256L);
                Bpb_Buff[35] = (UCHAR)(work3/(256L*256L*256L));
                Bpb_Buff[34] = (UCHAR)(work3/(256L*256L)-(ULONG)Bpb_Buff[31]*256L);
                Bpb_Buff[33] = (UCHAR)(work3/256L-(ULONG)Bpb_Buff[31]*256L*256L-(ULONG)Bpb_Buff[30]*256L);

            } else {
                work2 = _SectorNum*(_BytePerSec/work);
                Bpb_Buff[19] = (UCHAR)(work2%256);
                Bpb_Buff[20] = (UCHAR)(work2/256);
                work3 = _LargeSector;
                Bpb_Buff[32] = (UCHAR)(work3%256L);
                Bpb_Buff[35] = (UCHAR)(work3/(256L*256L*256L));
                Bpb_Buff[34] = (UCHAR)(work3/(256L*256L)-(ULONG)Bpb_Buff[31]*256L);
                Bpb_Buff[33] = (UCHAR)(work3/256L-(ULONG)Bpb_Buff[31]*256L*256L-(ULONG)Bpb_Buff[30]*256L);
            }

            start_sec=0;
            sector_len=1;
//*** write
        if (!dpdrive.Write(start_sec,sector_len,Bpb_Buff)){
//*** close
           return FALSE;
        }

    } else {
//*** close
        return FALSE;
    }

    return TRUE;

 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cryptmnu\dllmain.cpp ===
#include "priv.h"
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "cryptmnu.h"
DWORD g_DllRefCount;
HINSTANCE g_hinst;

extern "C" {
   BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) ;
}
STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID rclsid,REFIID riid,LPVOID *ppv);

BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)  {
   switch(dwReason)  {
      case DLL_PROCESS_ATTACH:
          DisableThreadLibraryCalls(hInstance);
		 g_hinst = hInstance;
         break;
      case DLL_PROCESS_DETACH:
         break;
      case DLL_THREAD_ATTACH:
         break;
      case DLL_THREAD_DETACH:
         break;
   }
   return(TRUE);
}

STDAPI
DllCanUnloadNow(void)  {
   return(g_DllRefCount ? S_FALSE : S_OK);
}

STDAPI
DllGetClassObject(REFCLSID rclsid,REFIID riid,LPVOID *ppv)  {
   HRESULT hr;

   *ppv = NULL;


   if (!IsEqualCLSID(rclsid,CLSID_CryptMenu))  {
      return(CLASS_E_CLASSNOTAVAILABLE);
   }

   CCryptMenuClassFactory *pCF = new CCryptMenuClassFactory();
   if (!pCF)  {
      return(E_OUTOFMEMORY);
   }

   hr = pCF->QueryInterface(riid,ppv);
   pCF->Release();

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cryptmnu\cryptmnu.cpp ===
#include "priv.h"
#include "cryptmnu.h"
#include <shellapi.h>
#include "resource.h"

enum {
    VERB_ERROR = -1,
    VERB_ENCRYPT = 0,
    VERB_DECRYPT,
};

LPTSTR szVerbs[] = {
   TEXT("encrypt"),
   TEXT("decrypt"),
};

bool Encryptable(LPCTSTR szFile);

CCryptMenuExt::CCryptMenuExt()  {
   InitCommonControls();
   m_pDataObj = NULL;
   m_ObjRefCount = 1;
   g_DllRefCount++;
   m_nFile = m_nFiles = m_nToDecrypt = m_nToEncrypt = 0;
   m_cbToEncrypt = m_cbToDecrypt = 0;
   m_cbFile = 256;
   m_szFile = new TCHAR[m_cbFile];
   m_fShutDown = false;
}

CCryptMenuExt::~CCryptMenuExt()  {
   ResetSelectedFileList();
   if (m_pDataObj)  {
      m_pDataObj->Release();
   }
   if (m_szFile) {
      delete[] m_szFile;
   }

   g_DllRefCount--;
}

//IUnknown methods
STDMETHODIMP
CCryptMenuExt::QueryInterface(REFIID riid, void **ppvObject)  {
   if (IsEqualIID(riid, IID_IUnknown)) {
      *ppvObject = (LPUNKNOWN) (LPCONTEXTMENU) this;
      AddRef();
      return(S_OK);
   } else if (IsEqualIID(riid, IID_IShellExtInit))  {
      *ppvObject = (LPSHELLEXTINIT) this;
      AddRef();
      return(S_OK);
   } else if (IsEqualIID(riid, IID_IContextMenu)) {
      *ppvObject = (LPCONTEXTMENU) this;
      AddRef();
      return(S_OK);
   }

   *ppvObject = NULL;
   return(E_NOINTERFACE);
}

STDMETHODIMP_(DWORD)
CCryptMenuExt::AddRef()  {
   return(++m_ObjRefCount);

}

STDMETHODIMP_(DWORD)
CCryptMenuExt::Release()  {
   if (--m_ObjRefCount == 0)  {
      m_fShutDown = true;
      delete this;
   }
   return(m_ObjRefCount);
}

//Utility methods
HRESULT
CCryptMenuExt::GetNextSelectedFile(LPTSTR *szFile, __int64 *cbFile) {
   FORMATETC fe;
   STGMEDIUM med;
   HRESULT hr;
   DWORD cbNeeded;
   WIN32_FIND_DATA w32fd;
   DWORD dwAttributes;

   if (!m_pDataObj) {
       return E_UNEXPECTED;
   }

   if (!szFile) {
      return E_INVALIDARG;
   }

   *szFile = NULL;
   while (!*szFile) {
      HANDLE hFile = INVALID_HANDLE_VALUE;

      // get the next file out of m_pDataObj
      fe.cfFormat = CF_HDROP;
      fe.ptd      = NULL;
      fe.dwAspect = DVASPECT_CONTENT;
      fe.lindex   = -1;
      fe.tymed    = TYMED_HGLOBAL;

      hr = m_pDataObj->GetData(&fe,&med);
      if (FAILED(hr))  {
         return(E_FAIL);
      }

      if (!m_nFiles) {
         m_nFiles = DragQueryFile(reinterpret_cast<HDROP>(med.hGlobal),0xFFFFFFFF,NULL,0);
      }

      if (m_nFile >= m_nFiles) {
         return E_FAIL;
      }

      cbNeeded = DragQueryFile(reinterpret_cast<HDROP>(med.hGlobal),m_nFile,NULL,0) + 1;
      if (cbNeeded > m_cbFile) {
         if (m_szFile) delete[] m_szFile;
         m_szFile = new TCHAR[cbNeeded];
         m_cbFile = cbNeeded;
      }

      DragQueryFile(reinterpret_cast<HDROP>(med.hGlobal),m_nFile++,m_szFile,m_cbFile);
      *szFile = m_szFile;

       if (!Encryptable(*szFile)) {
            *szFile = NULL;
            continue;
      }

      hFile = FindFirstFile(*szFile,&w32fd);

      if (hFile != INVALID_HANDLE_VALUE)
      {
         *cbFile = MAXDWORD * w32fd.nFileSizeHigh + w32fd.nFileSizeLow +1;
         FindClose(hFile);
      }
      else
      {
         *szFile = NULL;
         continue;
      }

      dwAttributes = GetFileAttributes(*szFile);

      // If we found a system file then skip it:
      if ((FILE_ATTRIBUTE_SYSTEM & dwAttributes) ||
          (FILE_ATTRIBUTE_TEMPORARY & dwAttributes)) {
         *szFile = NULL;
         continue;
      }
   }

   return S_OK;
}

void
CCryptMenuExt::ResetSelectedFileList() {
   m_nFile = 0;
}

// A file can be encrypted only if it is on an NTFS volume.
bool
Encryptable(LPCTSTR szFile) {
    TCHAR szFSName[6]; // This just needs to be longer than "NTFS"
   LPTSTR szRoot;
    int cchFile;
    int nWhack = 0;


    if (!szFile || (cchFile = lstrlen(szFile)) < 3) return false;
   szRoot = new TCHAR [ cchFile + 1 ];
   lstrcpy(szRoot,szFile);
                
    // GetVolumeInformation wants only the root path, so we need to
    // strip off the rest.  Yuck.
    if ('\\' == szRoot[0] && '\\' == szRoot[1]) {
       /* UNC Path: chop after the second '\': \\server\share\ */
       for(int i=2;i<cchFile;i++) {
          if ('\\' == szRoot[i]) nWhack++;
          if (2 == nWhack) {
             szRoot[i+1] = '\0';
             break;
          }
       }
    } else {
       // Drive Letter
       szRoot[3] = '\0';
    }
    if (!GetVolumeInformation(szRoot,NULL,0,NULL,NULL,NULL,
                szFSName,sizeof(szFSName)/sizeof(szFSName[0]))) {
      delete[] szRoot;
      return false;
    }

   delete[] szRoot;
    return 0 == lstrcmp(szFSName,TEXT("NTFS"));
}

BOOL CALLBACK
EncryptProgressDlg(HWND hdlg, UINT umsg, WPARAM wp, LPARAM lp) {
   switch(umsg) {
      case WM_INITDIALOG:
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wp)) {
            case IDCANCEL: {
               DestroyWindow(hdlg);
            }
         }
         break;
   }
   return FALSE;
}


//IShellExtInit methods
STDMETHODIMP
CCryptMenuExt::Initialize(LPCITEMIDLIST pidlFolder,
                      LPDATAOBJECT  pDataObj,
                      HKEY hkeyProgID)
{
   DWORD dwAttributes;
   LPTSTR szFile;
   __int64 cbFile;

   // Hang on to the data object for later.
   // We'll want this information in QueryContextMenu and InvokeCommand
   if (!m_pDataObj)  {
      m_pDataObj = pDataObj;
      m_pDataObj->AddRef();
   } else {
      return(E_UNEXPECTED);
   }

   ResetSelectedFileList();
   while(SUCCEEDED(GetNextSelectedFile(&szFile,&cbFile))) {
      // is it encrypted?  increment our count of decryptable files
      //        otherwise increment our count of encryptable files
      dwAttributes = GetFileAttributes(szFile);
      if (dwAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
          m_nToDecrypt++;
         m_cbToDecrypt += cbFile;
      } else {
            m_nToEncrypt++; 
         m_cbToEncrypt += cbFile;
      }
      //We need the actual values for the title of the progress dialog
      //if ((m_nToEncrypt > 1) && (m_nToDecrypt > 1)) break;
   }

   return(NOERROR);
}



//IContextMenu methods
STDMETHODIMP
CCryptMenuExt::QueryContextMenu(HMENU hmenu,
                      UINT indexMenu,
                      UINT idCmdFirst,
                      UINT idCmdLast,
                      UINT uFlags)
{
   TCHAR szMenu[50];
   UINT idCmd;

   if (!m_pDataObj) {
      return E_UNEXPECTED;
   }

   if ((CMF_EXPLORE != (0xF & uFlags)) &&
       (CMF_NORMAL != (0xF & uFlags))) {
      return(NOERROR);
   }

   idCmd = idCmdFirst;
   if (1 < m_nToEncrypt) {
      LoadString(g_hinst,IDS_ENCRYPTMANY,szMenu,sizeof(szMenu)/sizeof(szMenu[0]));
   } else if (1 == m_nToEncrypt) {
       LoadString(g_hinst,IDS_ENCRYPTONE,szMenu,sizeof(szMenu)/sizeof(szMenu[0]));
   }
   if (m_nToEncrypt) {
      InsertMenu(hmenu,indexMenu++,MF_STRING|MF_BYPOSITION,idCmd,szMenu);
   }
   idCmd++;

   if (1 < m_nToDecrypt) {
      LoadString(g_hinst,IDS_DECRYPTMANY,szMenu,sizeof(szMenu)/sizeof(szMenu[0]));
   } else if (1 == m_nToDecrypt) {
      LoadString(g_hinst,IDS_DECRYPTONE,szMenu,sizeof(szMenu)/sizeof(szMenu[0]));
   }
   if (m_nToDecrypt) {
      InsertMenu(hmenu,indexMenu++,MF_STRING|MF_BYPOSITION,idCmd,szMenu);
   }
   idCmd++;

   return(MAKE_SCODE(SEVERITY_SUCCESS,0,idCmd-idCmdFirst));
}


DWORD WINAPI
DoEncryptFile(LPVOID szFile) {
    return EncryptFile(reinterpret_cast<LPTSTR>(szFile));
}

DWORD WINAPI
DoDecryptFile(LPVOID szFile) {
   return DecryptFile(reinterpret_cast<LPTSTR>(szFile),0);
}



STDMETHODIMP
CCryptMenuExt::InvokeCommand(LPCMINVOKECOMMANDINFO lpici) {
   HRESULT hrRet;
   LPCMINVOKECOMMANDINFO pici;
   int nVerb;
   LPTSTR szFile;

   if (!m_pDataObj) {
      return E_UNEXPECTED;
   }

   pici = reinterpret_cast<LPCMINVOKECOMMANDINFO>(lpici);

   // If pici->lpVerb has 0 in the high word then the low word
   // contains the offset to the menu as set in QueryContextMenu
   if (HIWORD(pici->lpVerb) == 0) {
      nVerb = LOWORD(pici->lpVerb);
   } else {
      // Initialize nVerb to an illegal value so we don't accidentally
      // recognize an invalid verb as legitimate
      nVerb = VERB_ERROR;
      for(int i=0;i<sizeof(szVerbs)/sizeof(szVerbs[0]);i++) {
         if (0 == lstrcmp(reinterpret_cast<LPCTSTR>(pici->lpVerb),szVerbs[i])) {
             nVerb = i;
              break;
         }
      }
   }

   switch(nVerb) {
      case VERB_ENCRYPT:
      case VERB_DECRYPT: {
         HWND hDlg;
         TCHAR szDlgTitle[50];
         TCHAR szDlgFormat[50];
         TCHAR szTimeLeft[50];
         TCHAR szTimeFormat[50];
         TCHAR szTimeFormatInMin[50];
         DWORD nTimeStarted;
         DWORD nTimeElapsed;
         __int64 nTimeLeft;
         __int64 cbDone;  // How many bytes we've handled
         __int64 cbToDo;  // How many bytes total we have to do
         __int64 cbFile;  // How many bites in the current file
         int nShifts;     // How many right shifts we need to do to get cbToDo
                          // into a range handleable by the progress bar.


         hDlg = CreateDialog(g_hinst,MAKEINTRESOURCE(IDD_ENCRYPTPROGRESS),GetForegroundWindow(),
                             reinterpret_cast<DLGPROC>(EncryptProgressDlg));

         // Setup the dialog's title, progress bar & animation
         if (VERB_ENCRYPT==nVerb) {
            if (1 == m_nToEncrypt) {
               LoadString(g_hinst,IDS_ENCRYPTINGONE,szDlgTitle,sizeof(szDlgTitle)/sizeof(szDlgTitle[0]));
            } else {
               LoadString(g_hinst,IDS_ENCRYPTINGMANY,szDlgFormat,sizeof(szDlgFormat)/sizeof(szDlgFormat[0]));
               wsprintf(szDlgTitle,szDlgFormat,m_nToEncrypt);
            }
            SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETRANGE,0,MAKELPARAM(0,m_nToEncrypt));
            SendDlgItemMessage(hDlg,IDC_ANIMATE,ACM_OPEN,0,reinterpret_cast<LPARAM>(MAKEINTRESOURCE(IDA_ENCRYPT)));

            cbToDo = m_cbToEncrypt;
         } else {
            if (1 == m_nToDecrypt) {
               LoadString(g_hinst,IDS_DECRYPTINGONE,szDlgTitle,sizeof(szDlgTitle)/sizeof(szDlgTitle[0]));
            } else {
               LoadString(g_hinst,IDS_DECRYPTINGMANY,szDlgFormat,sizeof(szDlgFormat)/sizeof(szDlgFormat[0]));
               wsprintf(szDlgTitle,szDlgFormat,m_nToDecrypt);
            }
            SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETRANGE,0,MAKELPARAM(0,m_nToDecrypt));
            SendDlgItemMessage(hDlg,IDC_ANIMATE,ACM_OPEN,0,reinterpret_cast<LPARAM>(MAKEINTRESOURCE(IDA_ENCRYPT)));
            cbToDo = m_cbToDecrypt;
         }

         nShifts = 0;
         cbDone = 0;
         while((cbToDo >> nShifts) > 65535) {
            nShifts++;
         }

#ifdef DISPLAY_TIME_ESTIMATE
         LoadString(g_hinst,IDS_TIMEEST,szTimeFormat,sizeof(szTimeFormat)/sizeof(szTimeFormat[0]));
         LoadString(g_hinst,IDS_TIMEESTMIN,szTimeFormatInMin,sizeof(szTimeFormatInMin)/sizeof(szTimeFormatInMin[0]));
#endif // DISPLAY_TIME_ESTIMATE

         SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETRANGE,0,MAKELPARAM(0,cbToDo >> nShifts));
         SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETPOS,0,0);
         SetWindowText(hDlg,szDlgTitle);
        ShowWindow(hDlg,SW_NORMAL);

         nTimeStarted = GetTickCount();
         ResetSelectedFileList();
         while(SUCCEEDED(GetNextSelectedFile(&szFile,&cbFile))) {
               if (!IsWindow(hDlg)) {
                  break;
               }

            if (GetFileAttributes(szFile) & FILE_ATTRIBUTE_ENCRYPTED) {
               if (VERB_ENCRYPT == nVerb) {
                  continue;
               }
            } else {
               if (VERB_DECRYPT == nVerb) {
                  continue;
               }
            }
            // Set the name of the file currently being encrypted
               SetDlgItemText(hDlg,IDC_NAME,szFile);

            HANDLE hThread;
            if (VERB_ENCRYPT == nVerb) {
                  hThread = CreateThread(NULL,0,DoEncryptFile,szFile,0,NULL);
              } else {
                  hThread = CreateThread(NULL,0,DoDecryptFile,szFile,0,NULL);
              } 


            MSG msg;
            DWORD dw;
            do {
               dw = MsgWaitForMultipleObjects(1,&hThread,0,INFINITE,QS_ALLINPUT);
               while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                  TranslateMessage(&msg);
                  DispatchMessage(&msg);
               }
            } while (WAIT_OBJECT_0 != dw);

            GetExitCodeThread(hThread,&dw);
            if (0 == dw) {
               // Encrypt or Decrypt Failed
               TCHAR szFormat[512];
               TCHAR szBody[512];
               TCHAR szTitle[80];
               int nResBody,nResTitle;
               UINT uMBType;

               uMBType = MB_OKCANCEL;
               if (VERB_ENCRYPT == nVerb) {
                  nResTitle = IDS_ENCRYPTFAILEDTITLE;
                  if (1 == m_nToEncrypt) {
                     uMBType = MB_OK;
                     nResBody = IDS_ENCRYPTFAILEDONE;
                  } else {
                     nResBody = IDS_ENCRYPTFAILEDMANY;
                  }
               } else {
                  nResTitle = IDS_DECRYPTFAILEDTITLE;
                  if (1 == m_nToDecrypt) {
                     uMBType = MB_OK;
                     nResBody = IDS_DECRYPTFAILEDONE;
                  } else {
                     nResBody = IDS_DECRYPTFAILEDMANY;
                  }
               }
               LoadString(g_hinst,nResBody,szFormat,sizeof(szFormat)/sizeof(szFormat[0]));
               wsprintf(szBody,szFormat,szFile);
               LoadString(g_hinst,nResTitle,szFormat,sizeof(szFormat)/sizeof(szFormat[0]));
               wsprintf(szTitle,szFormat,szFile);
               if (IDCANCEL == MessageBox(hDlg,szBody,szTitle,uMBType|MB_ICONWARNING)) {
                  if (IsWindow(hDlg)) {
                     DestroyWindow(hDlg);
                  }
               }
            }
            CloseHandle(hThread);

               if (!IsWindow(hDlg)) {
                  break;
               }
            // Advance the progress Bar
            cbDone += cbFile;
            SendDlgItemMessage(hDlg,IDC_PROBAR,PBM_SETPOS,(DWORD)(cbDone >> nShifts),0);

#ifdef DISPLAY_TIME_ESTIMATE
            nTimeElapsed = GetTickCount() - nTimeStarted;
            nTimeLeft = (cbToDo * nTimeElapsed) / cbDone - nTimeElapsed;
            nTimeLeft /= 1000; // Convert to seconds
            if (nTimeLeft < 60) {
               wsprintf(szTimeLeft,szTimeFormat,(DWORD)(nTimeLeft));
            } else {
               wsprintf(szTimeLeft,szTimeFormatInMin,(DWORD)(nTimeLeft / 60), (DWORD) (nTimeLeft % 60));
            }
            SetDlgItemText(hDlg,IDC_TIMEEST,szTimeLeft);
#endif // DISPLAY_TIME_ESTIMATE
         }
           if (IsWindow(hDlg)) {
              DestroyWindow(hDlg);
         }
            hrRet = NOERROR;
         }
          break;
       default:
         hrRet = E_UNEXPECTED;
           break;
   }

   return(hrRet);
}

STDMETHODIMP
CCryptMenuExt::GetCommandString(
    UINT_PTR idCmd,   //Menu item identifier offset
    UINT uFlags,  //Specifies information to retrieve
    LPUINT pwReserved,   //Reserved; must be NULL
    LPSTR pszName,   //Address of buffer to receive string
    UINT cchMax   //Size of the buffer that receives the string
   )
{
   LPTSTR wszName;

   // On NT we get unicode here, even though the base IContextMenu class
   // is hardcoded to ANSI.
   wszName = reinterpret_cast<LPTSTR>(pszName);

   if (idCmd >= sizeof(szVerbs)/sizeof(szVerbs[0])) {
      return(E_INVALIDARG);
   }
   switch(uFlags)  {
      case GCS_HELPTEXT:
         switch(idCmd) {
             case VERB_ENCRYPT:
                 if (1 < m_nToEncrypt) {
                  LoadString(g_hinst,IDS_ENCRYPTMANYHELP,wszName,cchMax);
               } else {
                  LoadString(g_hinst,IDS_ENCRYPTONEHELP,wszName,cchMax);
               }
               break;
            case VERB_DECRYPT:
                 if (1 < m_nToDecrypt) {
                    LoadString(g_hinst,IDS_DECRYPTMANYHELP,wszName,cchMax);
               } else {
                  LoadString(g_hinst,IDS_DECRYPTONEHELP,wszName,cchMax);
               }
               break;
            default:
               break;
         }
         break;

      case GCS_VALIDATE: {
         break;
      }
      case GCS_VERB:
          lstrcpyn(wszName,szVerbs[idCmd],cchMax);
        pszName[cchMax-1] = '\0';
          break;
   }

   return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cryptmnu\priv.h ===
//--------------------------------------------------------------
// common user interface routines
//
//
//--------------------------------------------------------------

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <shlobj.h>

extern DWORD g_DllRefCount;
extern HINSTANCE g_hinst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\convert\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=convert
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\convert.cxx ..\convert.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ifsutil\inc;..\..\cufat\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

UMLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib \
    $(SDK_LIB_PATH)\scecli.lib \
    $(PROJECT_LIB_PATH)\osuninst.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cryptmnu\cryptmnu.h ===
// {853FE2B1-B769-11d0-9C4E-00C04FB6C6FA}
DEFINE_GUID(CLSID_CryptMenu, 
0x853fe2b1, 0xb769, 0x11d0, 0x9c, 0x4e, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa);


class CCryptMenuClassFactory : public IClassFactory
{
protected:
	DWORD m_ObjRefCount;

public:
	CCryptMenuClassFactory();
	~CCryptMenuClassFactory();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IClassFactory methods
   STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
   STDMETHODIMP LockServer(BOOL);
};


class CCryptMenuExt : public IShellExtInit, public IContextMenu 
{
public:
   CCryptMenuExt();
   ~CCryptMenuExt();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();
   
   //IShellExtInit methods
   STDMETHODIMP Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY);
   
   //IContextMenu methods
   STDMETHODIMP QueryContextMenu(HMENU, UINT, UINT, UINT, UINT);
   STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO);
   STDMETHODIMP GetCommandString(UINT_PTR, UINT, LPUINT, LPSTR, UINT);

protected:
   void ResetSelectedFileList();
   HRESULT GetNextSelectedFile(LPTSTR *, __int64 *);

   DWORD m_ObjRefCount;
   LPDATAOBJECT m_pDataObj;

   int m_nToEncrypt;
   int m_nToDecrypt;
   __int64 m_cbToEncrypt;
   __int64 m_cbToDecrypt;
   int m_nFile;
   int m_nFiles;
   DWORD m_cbFile;
   LPTSTR m_szFile;

   bool m_fShutDown;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cryptmnu\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptmnu.rc
//
#define IDS_ENCRYPTONE                  1
#define IDS_DECRYPTONE                  2
#define IDS_ENCRYPTMANY                 3
#define IDS_DECRYPTMANY                 4
#define IDS_ENCRYPTHELP                 5
#define IDS_ENCRYPTMANYHELP             5
#define IDS_DECRYPTHELP                 6
#define IDS_DECRYPTMANYHELP             6
#define IDS_ENCRYPTONEHELP              7
#define IDS_DECRYPTONEHELP              8
#define IDS_ENCRYPTINGONE               9
#define IDS_ENCRYPTINGMANY              10
#define IDS_DECRYPTINGONE               11
#define IDS_DECRYPTINGMANY              12
#define IDS_TIMEEST                     13
#define IDS_TIMEESTMIN                  14
#define IDS_ENCRYPTFAILEDTITLE          15
#define IDS_DECRYPTFAILEDTITLE          16
#define IDS_ENCRYPTFAILEDMANY           17
#define IDS_DECRYPTFAILEDMANY           18
#define IDS_ENCRYPTFAILEDONE            19
#define IDS_DECRYPTFAILEDONE            20
#define IDD_ENCRYPTPROGRESS             101
#define IDA_ENCRYPT                     102
#define IDA_DECRYPT                     103
#define IDC_ANIMATE                     1000
#define IDC_PROBAR                      1001
#define IDC_NAME                        1002
#define IDC_TONAME                      1003
#define IDC_TIMEEST                     1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cufat\src\pch.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

	pch.cxx

Abstract:

	This module is used to pre-compiles cufat headers.

Author:

	Matthew Bradburn (mattbr)  27-Apr-1994

--*/

#define _NTAPI_ULIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cufat\src\cufat.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        Cufat.cxx

Abstract:

        This module contains run-time, global support for the
        FAT Conversion library (CUFAT). This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Ramon Juan San Andres (ramonsa) 23-Sep-1991

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#include "ulib.hxx"

//
//      Local prototypes
//
STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

extern "C" BOOLEAN
InitializeCufat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

BOOLEAN
InitializeCufat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Cufat by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ )

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Cufat initialization failed!!!\n" );
        return( FALSE );
    }

    DebugPrint("CUFAT.DLL got attached.\n");

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
                DebugPrintTrace(("CUFAT.DLL got attached %d times.\n", count));
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Cufat initialization failed!!!\n" );
                return( FALSE );
            }

            DebugPrint("CUFAT.DLL got attached.\n");

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
                DebugPrintTrace(("CUFAT.DLL got detached.  %d time(s) left.\n", count));
                return TRUE;
            }
            if (count == 1) {

                DebugPrint("CUFAT.DLL got detached.\n");

                UndefineClassDescriptors();
                count--;
            } else
                DebugPrint("CUFAT.DLL detached more than attached\n");
            break;
    }
#endif // _AUTOCHECK || _SETUP_LOADER_

    return TRUE;
}



DECLARE_CLASS(  FAT_NTFS        );


STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
        if ( DEFINE_CLASS_DESCRIPTOR(   FAT_NTFS        )        &&
                TRUE ) {
                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR(   FAT_NTFS        );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\adminprivs.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  AdminPrivs.cpp
//=============================================================================*
// DfrgVols.cpp : Implementation of CDfrgVols

#include "stdafx.h"
#include <windows.h>
#include "message.h"
#include "AdminPrivs.h"
#include "assert.h"

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine checks if the current user belongs to an Administrator Group.

GLOBAL VARIABLES:

INPUT:
    None.

RETURN:
	TRUE  = success - User does belong to an Administrator group
	FALSE = failure - User does Not belong to an Administrator group
*/

BOOL
CheckForAdminPrivs()
{
	BOOL      bIsAdministrator = FALSE;
	HRESULT   hr = S_OK;
	DWORD     dwErr = 0;
	TCHAR     cString[300];

	DWORD						dwInfoBufferSize = 0;
	PSID						psidAdministrators;
	SID_IDENTIFIER_AUTHORITY	siaNtAuthority = SECURITY_NT_AUTHORITY;

	BOOL bResult = AllocateAndInitializeSid(&siaNtAuthority, 2,
			SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
			0, 0, 0, 0, 0, 0, &psidAdministrators);

	if (bResult) {
		bResult = CheckTokenMembership(0, psidAdministrators, &bIsAdministrator);
		assert(bResult);

		if (!bResult) {
			wsprintf(cString, TEXT("Error = %d"), GetLastError());
			Message(TEXT("CheckForAdminPrivs::CheckTokenMembership"), E_FAIL, cString);
		}
		FreeSid(psidAdministrators);
	}
	else {
        wsprintf(cString, TEXT("Error = %d"), GetLastError());
        Message(TEXT("CheckForAdminPrivs::AllocateAndInitializeSid"), E_FAIL, cString);
	}

	return bIsAdministrator;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cufat\src\convfat.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

        entry.cxx

Abstract:

        This module contains the Convert entry point for CUFAT.DLL.

Author:

        Ramon San Andres (ramonsa)      Sep-19-91

Environment:

        ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#include "ulib.hxx"
#include "error.hxx"
#include "drive.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "fatsa.hxx"
#include "fatntfs.hxx"
#include "convfat.hxx"
#include "rwcache.hxx"
#include "rfatsa.hxx"
#include "ifssys.hxx"

#if !defined(_AUTOCHECK_) && !defined(_SETUP_LOADER_)

#include "fatofs.hxx"     // FAT->OFS Conversion
#include "system.hxx"

#include <stdio.h>

#endif  // _AUTOCHECK_ || _SETUP_LOADER_

//#define RWCACHE_PERF_COUNTERS   1
//#define CONVERT_CACHE_BLOCKS    1

//
//    This file maintains a table that maps file system names to
//  conversion functions. The Convert entry point looks up the
//  target file name system in the table, if found, then it calls
//  the corresponding conversion function.  This data-driven scheme
//  makes it easy to add new conversions to the library, since no
//  code has to be changed.
//
//    The code & data for performing a particular conversion are
//  contained in a class. This avoids name conflicts and lets us
//  have the global data for each conversion localized.
//
//    Each conversion function will typically just initialize
//  the appropriate conversion object and invoke its conversion
//  method.
//



//
//  A FAT_CONVERT_FN is a pointer to a conversion function.
//
typedef BOOLEAN(FAR APIENTRY * FAT_CONVERT_FN)( PLOG_IO_DP_DRIVE,
                                                PREAL_FAT_SA,
                                                PCWSTRING,
                                                PMESSAGE,
                                                ULONG,
                                                PCONVERT_STATUS );

//
//    Prototypes of conversion functions. Note that all conversion
//  functions must have the same interface since they are all called
//  thru a FAT_CONVERT_FN pointer.
//
//    Also note that the Drive object passed to the function is
//  LOCKED by the Convert entry point before invoking the function.
//
BOOLEAN
FAR APIENTRY
ConvertFatToNtfs(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PREAL_FAT_SA        FatSa,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags,
    OUT     PCONVERT_STATUS     Status
    );


//
//  The FILESYSTEM_MAP structure is used to map the name of
//  a file system to the function in charge of converting a FAT
//  volume to that particular file system.
//
typedef struct _FILESYSTEM_MAP {

    PWCHAR          FsName;         //      Name of the file system
    FAT_CONVERT_FN  Function;       //      Conversion function

} FILESYSTEM_MAP, *PFILESYSTEM_MAP;

//  To add a new conversion, create a FAT_CONVERT_FN function
//  for it and add the appropriate entry to the FileSystemMap
//  table.
//
//  Note that this table contains an entry for every known
//  file system. A NULL entry in the Function field means that
//  the particular conversion is not implemented.
//
//    This table has to be NULL-terminated.
//
FILESYSTEM_MAP  FileSystemMap[] = {

        { L"NTFS",   ConvertFatToNtfs    },
        { L"HPFS",   NULL                },
        { L"FAT",    NULL                },
        { L"CDFS",   NULL                },
        { L"FAT32",  NULL                },
        { NULL,     NULL                }
};


LONG
FAR APIENTRY
IsConversionAvailable(
    IN      PCWSTRING           TargetFileSystem
    )
/*++

Routine Description:

    This method determines if a conversion is allowed from FAT/FAT32
    to the desired TargetFileSystem.

Arguments:

    TargetFileSyste --  Supplies the name of the file system to convert
                        the drive to.

Return Value:

    >= 0 if conversion is supported.
    -1 if conversion is not supported.

--*/
{
    PFILESYSTEM_MAP     FsMap;                  //  Maps name->Function
    DSTRING             FsName;

    //
    //  Find out if the target file system is valid and
    //  if we can convert to it, by looking up the target
    //  file system in the FileSystemMap table.
    //
    FsMap = FileSystemMap;

    while ( FsMap->FsName ) {

        //
        //  If this is the guy we are looking for, we stop searching
        //
        if ( WSTRING::Stricmp((PWSTR)TargetFileSystem->GetWSTR(), FsMap->FsName) == 0 ) {

            break;
        }

        FsMap++;
    }

    if (FsMap->FsName && FsMap->Function)
        return (LONG)(FsMap - FileSystemMap);
    else
        return -1;
}


BOOLEAN
IsTargetNTFS(
    IN      PCWSTRING           TargetFileSystem )
{
    DSTRING NTFSName;


    if(!NTFSName.Initialize("NTFS")) {
    return TRUE;
    }
    return 0 == TargetFileSystem->Stricmp(&NTFSName);
}

NTSTATUS
FileExists(
    PCWSTRING lpFileName
    )

/*++

Routine Description:

    The attributes of a file can be obtained using GetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

    This routine is a copy of the WIN32 one and also takes the drive
    in the NT form rather than the DOS form. We would need this in
    the AUTOCHK case in any event since WIN32 isn't around for AUTOCHK,
    but we also need it in the non-AUTOCHK case since we only have the NT
    form drive name available.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
    be gotten. This must be a WFP using the NT drive name format.

Return Value:

     Returns STATUS_SUCCESS if file does exist.
     Returns STATUS_OBJECT_NAME_NOT_FOUND if file does not exist.
     Returns other NTSTATUS.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    FILE_BASIC_INFORMATION BasicInfo;
    UNICODE_STRING FileName;

    RtlInitUnicodeString(&FileName, lpFileName->GetWSTR());

    InitializeObjectAttributes(
        &Obja,
    &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Get the file attributes
    //

    Status = NtQueryAttributesFile(
                 &Obja,
                 &BasicInfo
                 );

    return Status;
}

BOOLEAN
CheckForNTFSReserveNames(
     IN      PCWSTRING           NtDriveName,
        OUT  PBOOLEAN            Found
     )
{
     char * NTFSResvdNames[] = {
                                         { "\\$Mft"     },
                                         { "\\$MftMirr" },
                                         { "\\$LogFile" },
                                         { "\\$Volume"  },
                                         { "\\$AttrDef" },
                                         { "\\$BitMap"  },
                                         { "\\$Boot"    },
                                         { "\\$BadClus" },
                                         { "\\$Secure"  },
                                         { "\\$UpCase"  },
                                         { "\\$Extend"  },
                                         { "\\$Quota"   },
                                         { NULL   }
                                        };
     int     i = 0;
     DSTRING ThisName1;
     DSTRING ThisName2;

     *Found = FALSE;
     while (NTFSResvdNames[i]) {

        if (!ThisName1.Initialize(NtDriveName) ||
            !ThisName2.Initialize(NTFSResvdNames[i]) ||
            !ThisName1.Strcat(&ThisName2)) {
            return FALSE;
        }

        if (FileExists(&ThisName1) != STATUS_OBJECT_NAME_NOT_FOUND) {
            //
            // if it didn't say it does not exist, assume it does
            //
            *Found = TRUE;
            return TRUE;
        }
        i++;
     }
     return TRUE;
}

BOOLEAN
FAR APIENTRY
CvtAreaFileExist(
     IN      PCWSTRING           NtDriveName,
     IN      PCWSTRING           CvtZoneFileName,
        OUT  PBOOLEAN            Found
     )
{
    DSTRING     ThisName1;
    DSTRING     ThisName2;
    NTSTATUS    status;

    *Found = FALSE;

    if (CvtZoneFileName->QueryChCount() == 0) {
        return TRUE;
    }

    if (!ThisName1.Initialize(NtDriveName) ||
        !ThisName2.Initialize(L"\\") ||
        !ThisName2.Strcat(CvtZoneFileName) ||
        !ThisName1.Strcat(&ThisName2)) {
        return FALSE;
    }

    status = FileExists(&ThisName1);

    switch (status) {
      case STATUS_SUCCESS:
        //
        // if it didn't say it exists, assumes it doesn't
        //
        *Found = TRUE;
        break;

      case STATUS_OBJECT_NAME_NOT_FOUND:
        break;  // this is expected

      default:
        DebugPrintTrace(("CNVFAT: Unable to query file %08x.\n", status));
    }

    return TRUE;
}

BOOLEAN
FAR APIENTRY
ConvertFATVolume(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PCWSTRING           TargetFileSystem,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags,
    OUT     PCONVERT_STATUS     Status
    )
/*++

Routine Description:

    This method converts an opened FAT volume to another
    file system.

Arguments:

    Drive           --  Supplies the drive to be converted; note that
                        the drive must already be opened and locked
                        (Convert) or opened for exclusive write access
                        (Autoconvert).
    TargetFileSyste --  Supplies the name of the file system to which
                        the drive will be converted.
    CvtZoneFileName --  Supplies the name of the convert zone.
    Message         --  Supplies a channel for messages.
    Flags           --  Supplies flags (CONVERT_VERBOSE_FLAG, CONVERT_FORCE_DISMOUNT_FLAG, etc)
    Status          --  Receives the status of the conversion.

Return Value:

    TRUE upon successful completion.

--*/
{
    REAL_FAT_SA         FatSa;                  //  Fat SuperArea
    LONG                indx;                   // index to conversion table
    PREAD_WRITE_CACHE   rwcache = NULL;
    ULONG               blocks;

    SYSTEM_BASIC_INFORMATION    sys_basic_info;
    NTSTATUS                    status;
    ULONG64                     vm_pages;

    DebugPtrAssert( Drive );
    DebugPtrAssert( TargetFileSystem );
    DebugPtrAssert( Status );

    if (!Drive->IsWriteable()) {
        *Status = CONVERT_STATUS_WRITE_PROTECTED;
        return FALSE;
    }

    //
    // Obtain number of physical pages and page size first
    //
    status = NtQuerySystemInformation(SystemBasicInformation,
                                      &sys_basic_info,
                                      sizeof(sys_basic_info),
                                      NULL);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("CNVFAT: NtQuerySystemInformation(SystemBasicInformation) failed (%x)\n", status));
        return FALSE;
    }

    vm_pages = (sys_basic_info.MaximumUserModeAddress -
                sys_basic_info.MinimumUserModeAddress)/sys_basic_info.PageSize;

    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "CNVFAT: Page Size = %x\n", sys_basic_info.PageSize));
    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "CNVFAT: User Virtual pages = %I64x\n", vm_pages));
    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "CNVFAT: Physical pages = %x\n", sys_basic_info.NumberOfPhysicalPages));

    if (sys_basic_info.NumberOfPhysicalPages < vm_pages) {
        vm_pages = sys_basic_info.NumberOfPhysicalPages;
    }

#if defined(_AUTOCHECK_)
    SYSTEM_PERFORMANCE_INFORMATION  perf_info;

    status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &perf_info,
                                      sizeof(perf_info),
                                      NULL);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("CNVFAT: NtQuerySystemInformation(SystemPerformanceInformation) failed (%x)\n", status));
        return FALSE;
    }

    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "CNVFAT: AvailablePages = %x\n", perf_info.AvailablePages));

    if (perf_info.AvailablePages < vm_pages)
        vm_pages = perf_info.AvailablePages;
#endif

    //
    // For a 32GB drive, the FAT can be as large as 16MB and
    // the two bitmaps can be each be as large as 8MB.
    // Thus the 32MB below.
    //
    vm_pages = vm_pages - (32*1024*1024)/sys_basic_info.PageSize;
    vm_pages = vm_pages/2;

    if (vm_pages <= (64*1024*1024)/sys_basic_info.PageSize) {
        vm_pages = min(vm_pages, (4*1024*1024)/sys_basic_info.PageSize);
    } else {
        vm_pages = min(vm_pages, (256*1024*1024)/sys_basic_info.PageSize);
    }

    vm_pages *= sys_basic_info.PageSize;
    blocks = (ULONG)(vm_pages / Drive->QuerySectorSize());

#if !defined(_AUTOCHECK_) && defined(CONVERT_CACHE_BLOCKS)

    PWCHAR      wstr;

    if (wstr = _wgetenv(L"CONVERT_CACHE_BLOCKS")) {

        INT     r;
        ULONG   blks;

        r = swscanf(wstr, L"%d", &blks);
        if (r != 0 && r != EOF) {
            blocks = blks;
        }
    }
#endif

    //
    // Set up a read-write cache for the volume.
    //
    if (blocks != 0 &&
        (rwcache = NEW READ_WRITE_CACHE) &&
        rwcache->Initialize(Drive, blocks)) {
        Drive->SetCache(rwcache);

#if defined(CONVERT_CACHE_BLOCKS)
        Message->Set(MSG_CHK_NTFS_MESSAGE);
        Message->Display("%s%d", "Cache blocks = ", blocks);
#endif

    } else {

        DELETE(rwcache);
    }

    //
    //  Find out if the target file system is valid and
    //  if we can convert to it, by looking up the target
    //  file system in the FileSystemMap table.
    //

    indx = IsConversionAvailable(TargetFileSystem);

    //
    //  If the target file system is valid, and there is a conversion
    //  for it, lock the drive, initialize the superarea, and
    //  invoke the conversion function.
    //
    if ( indx >= 0) {

#if defined(_AUTOCHECK_)
        if (IsTargetNTFS( TargetFileSystem )) {

            BOOLEAN             found;

            if (CheckForNTFSReserveNames(Drive->GetNtDriveName(), &found)) {
                if (found) {
                    *Status = CONVERT_STATUS_NTFS_RESERVED_NAMES;
                    return FALSE;
                }
            } else {
                Message->Set(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
                Message->Display();
                *Status = CONVERT_STATUS_ERROR;
                return FALSE;
            }
        }
#endif

        if ( FatSa.Initialize( Drive, Message, TRUE ) ||
             FatSa.Initialize( Drive, Message, FALSE )) {

            if (FatSa.Read( Message )) {

                BOOLEAN     rst;
                //
                //  The dive is locked and we have the
                //  FAT superarea. Invoke the conversion
                //  function.
                //

#if !defined(RUN_ON_NT4)
                NTSTATUS            es_status;
                EXECUTION_STATE     prev_state;

                es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                                      ES_DISPLAY_REQUIRED|
                                                      ES_SYSTEM_REQUIRED,
                                                      &prev_state);

                if (!NT_SUCCESS(es_status)) {
                    DebugPrintTrace(("CNVFAT: Unable to set thread execution state (%x)\n", es_status));
                }

                __try {
#endif
                    rst = (FileSystemMap[indx].Function)( Drive,
                                                          &FatSa,
                                                          CvtZoneFileName,
                                                          Message,
                                                          Flags,
                                                          Status );

                    RestoreThreadExecutionState(es_status, prev_state);
#if !defined(RUN_ON_NT4)
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    RestoreThreadExecutionState(es_status, prev_state);
                    rst = FALSE;
                    *Status = CONVERT_STATUS_ERROR;
                }
#endif

#if defined(RWCACHE_PERF_COUNTERS)
                if (rwcache) {

                    ULONG   rmiss, rhit, roverhead, wmiss, whit, usage;

                    rwcache->Flush();
                    rwcache->QueryPerformanceCounters(&rmiss, &rhit, &roverhead, &wmiss, &whit, &usage);
                    printf("RMiss = %d (%d)\n", rmiss, (rmiss*100)/(rmiss+rhit));
                    printf("RHit = %d (%d)\n", rhit, (rhit*100)/(rmiss+rhit));
                    printf("ROverHead = %d (%d)\n", roverhead, (roverhead*100)/(rmiss+rhit));
                    printf("WMiss = %d (%d)\n", wmiss, (wmiss*100)/(wmiss+whit));
                    printf("WHit = %d (%d)\n", whit, (whit*100)/(wmiss+whit));
                    printf("Usage = %d (%d)\n", usage, (usage*100)/blocks);
                }
#endif
                return rst;

            } else {

                //
                //  Cannot read superarea
                //
                *Status = CONVERT_STATUS_ERROR;
                return FALSE;
            }

        } else {

            //
            //  Cannot initialize Superarea
            //
            *Status = CONVERT_STATUS_ERROR;
            return FALSE;
        }

    } else {

        //
        //  The file system is not valid
        //
        *Status = CONVERT_STATUS_INVALID_FILESYSTEM;
        return FALSE;
    }
}

#if !defined(_AUTOCHECK_)

BOOLEAN
IsTargetOfs(
    IN      PCWSTRING           TargetFileSystem )
{
    DSTRING Ofs;
    Ofs.Initialize("OFS");

    return 0 == TargetFileSystem->Stricmp(&Ofs);
}

BOOLEAN
IsChkdskOkay(
    IN        PCWSTRING      NtDriveName,
    IN OUT    PMESSAGE       Message,
    IN        BOOLEAN        Verbose
            )
{
    DSTRING             libraryName;
    DSTRING             entryPoint;
    HANDLE              fsUtilityHandle;
    CHKDSKEX_FN         Chkdsk;
    CHKDSKEX_FN_PARAM   param;

    if (!libraryName.Initialize( L"UFAT.DLL" ) ||
          !entryPoint.Initialize( L"ChkdskEx" )) {
          Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        Message->Display();
          return FALSE;
     }

    Chkdsk = (CHKDSKEX_FN)SYSTEM::QueryLibraryEntryPoint(&libraryName,
                                                       &entryPoint,
                                                       &fsUtilityHandle );

    if ( NULL == Chkdsk ) {
        //
        //  There is no conversion DLL for the file system in the volume.
        //

        Message->Set( MSG_FS_NOT_SUPPORTED );
        Message->Display( "%s%W", "CHKDSK", L"FAT" );
        Message->Set( MSG_BLANK_LINE );
        Message->Display( "" );

        return FALSE;
    }

    ULONG   exitStatus;

    memset(&param, 0, sizeof(param));

    param.Major = 1;
    param.Minor = 1;
    param.Flags = Verbose ? CHKDSK_VERBOSE : 0;

    Chkdsk( NtDriveName,
            Message,
            FALSE,      // don't fix - just see if they are consistent
            &param,
            &exitStatus );

    SYSTEM::FreeLibraryHandle( fsUtilityHandle );

    if ( CHKDSK_EXIT_SUCCESS != exitStatus ) {
        Message->Set(MSG_CONV_NTFS_CHKDSK);
        Message->Display();
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
ConvertToOfs(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Verbose,
    OUT     PCONVERT_STATUS     Status
            )
{
    DSTRING libraryName;
    DSTRING entryPoint;
    HANDLE  fsUtilityHandle;

    libraryName.Initialize( FAT_TO_OFS_DLL_NAME );

    entryPoint.Initialize( FAT_TO_OFS_FUNCTION_NAME );

    FAT_OFS_CONVERT_FN Convert;

    Convert = (FAT_OFS_CONVERT_FN)SYSTEM::QueryLibraryEntryPoint(
        &libraryName, &entryPoint, &fsUtilityHandle );

    if ( NULL == Convert )
    {
        //
        //  There is no conversion DLL for the file system in the volume.
        //
        *Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    PWSTR pwszNtDriveName = NtDriveName->QueryWSTR();
    FAT_OFS_CONVERT_STATUS cnvStatus;
    BOOLEAN fResult= Convert( pwszNtDriveName,
                              Message,
                              Verbose,
                              FALSE,    // Not in Setup Time
                              &cnvStatus );

    DELETE( pwszNtDriveName );
    SYSTEM::FreeLibraryHandle( fsUtilityHandle );

    if ( FAT_OFS_CONVERT_SUCCESS == cnvStatus )
    {
        *Status = CONVERT_STATUS_CONVERTED;
    }
    else
    {
        *Status = CONVERT_STATUS_ERROR;
    }

    return fResult;

}
#endif  // _AUTOCHECK_


BOOLEAN
FAR APIENTRY
ConvertFAT(
    IN      PCWSTRING           NtDriveName,
    IN      PCWSTRING           TargetFileSystem,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags,
    OUT     PCONVERT_STATUS     Status
        )
/*++

Routine Description:

        Converts a FAT volume to another file system.

Arguments:

        NtDrivName       -- supplies the name of the drive to check
        TargetFileSystem -- supplies the name of the target file system
        CvtZoneFileName  -- supplies the name of the convert zone
        Message          -- supplies an outlet for messages
        Flags            -- supplies flags (CONVERT_VERBOSE_FLAG, CONVERT_FORCE_DISMOUNT_FLAG, etc)
        Status           -- supplies pointer to convert status code

Return Value:

        BOOLEAN -   TRUE if conversion successful

--*/
{
#if defined(_AUTOCHECK_)
    return FALSE;
#else
    //
    // If we are converting to OFS, we have to delete the drive before
    // calling the routine. So, use a pointer instead of a stack object.
    //
    PLOG_IO_DP_DRIVE    pDrive;     //  Drive to convert

    DebugPtrAssert( NtDriveName );
    DebugPtrAssert( TargetFileSystem );
    DebugPtrAssert( Status );

    BOOLEAN             ForceDismount;

    ForceDismount = (Flags & CONVERT_FORCE_DISMOUNT_FLAG) ? TRUE : FALSE;

    if (!(Flags & CONVERT_NOCHKDSK_FLAG)) {

        pDrive = NEW LOG_IO_DP_DRIVE;
        if ( NULL == pDrive ) {
            *Status = CONVERT_STATUS_ERROR;
            return FALSE;
        }

        //
        // Open the drive and make sure we can lock it before proceeding into chkdsk.
        // Eventually, we need to support a readonly chkdsk with volume locked.
        //
        if ( !pDrive->Initialize( NtDriveName ) ) {

            //
            //  Could not initialize the drive
            //
            *Status = CONVERT_STATUS_ERROR;
            DELETE(pDrive);
            return FALSE;
        }

        if (!pDrive->IsWriteable()) {
            *Status = CONVERT_STATUS_WRITE_PROTECTED;
            DELETE(pDrive);
            return FALSE;
        }

        if (pDrive->IsSonyMS()) {
            *Status = CONVERT_STATUS_CONVERSION_NOT_AVAILABLE;
            DELETE(pDrive);
            return FALSE;
        }

        if ( !pDrive->Lock() ) {
            //
            //  Could not lock the volume
            //  Try to dismount the volume or prompt the user to do so
            //
            if (!ForceDismount) {
                Message->Set(MSG_CONV_FORCE_DISMOUNT_PROMPT);
                Message->Display();
                if (Message->IsYesResponse(FALSE)) {
                    ForceDismount = TRUE;
                }
            }

            if (ForceDismount) {
                if (!IFS_SYSTEM::DismountVolume(NtDriveName)) {
                    Message->Set(MSG_CONV_UNABLE_TO_DISMOUNT);
                    Message->Display();
                    ForceDismount = FALSE;
                } else {
                    Message->Set(MSG_VOLUME_DISMOUNTED);
                    Message->Display();
                }
            }

            if (!ForceDismount) {
                *Status = CONVERT_STATUS_CANNOT_LOCK_DRIVE;
                DELETE(pDrive);
                return FALSE;
            }

            if ( !pDrive->Initialize( NtDriveName ) ) {

                //
                //  Could not initialize the drive
                //
                *Status = CONVERT_STATUS_ERROR;
                DELETE(pDrive);
                return FALSE;
            }

            if ( !pDrive->Lock() ) {

                //
                // Still cannot lock the volume
                //
                *Status = CONVERT_STATUS_CANNOT_LOCK_DRIVE;
                DELETE(pDrive);
                return FALSE;
            }
        }

        DELETE(pDrive); // unlock it so that we can run chkdsk

        //
        // Do a chkdsk before proceeding ahead.
        //
        if ( !IsChkdskOkay( NtDriveName, Message, (Flags & CONVERT_VERBOSE_FLAG) ? TRUE : FALSE) ) {
            *Status = CONVERT_STATUS_ERROR;
            return FALSE;
        }

        Message->Set(MSG_BLANK_LINE);
        Message->Display();
    }

    pDrive = NEW LOG_IO_DP_DRIVE;
    if ( NULL == pDrive ) {
        *Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    // Open the drive and lock it.
    //
    if ( !pDrive->Initialize( NtDriveName ) ) {

        //
        //  Could not initialize the drive
        //
        *Status = CONVERT_STATUS_ERROR;
        DELETE(pDrive);
        return FALSE;
    }

    if (!pDrive->IsWriteable()) {
        *Status = CONVERT_STATUS_WRITE_PROTECTED;
        DELETE(pDrive);
        return FALSE;
    }

    if (pDrive->IsSonyMS()) {
        *Status = CONVERT_STATUS_CONVERSION_NOT_AVAILABLE;
        DELETE(pDrive);
        return FALSE;
    }

    if (IsTargetNTFS( TargetFileSystem )) {

        BOOLEAN    found;

        if (CheckForNTFSReserveNames(NtDriveName, &found)) {
             if (found) {
                 *Status = CONVERT_STATUS_NTFS_RESERVED_NAMES;
                 DELETE(pDrive);
                 return FALSE;
             }
        } else {
             Message->Set(MSG_CONV_NO_MEMORY, ERROR_MESSAGE);
             Message->Display();
             *Status = CONVERT_STATUS_ERROR;
             DELETE(pDrive);
             return FALSE;
        }
    }

    if ( !pDrive->Lock() ) {
        //
        //  Could not lock the volume
        //  Try to dismount the volume or prompt the user to do so
        //
        if (!ForceDismount) {
            Message->Set(MSG_CONV_FORCE_DISMOUNT_PROMPT);
            Message->Display();
            if (Message->IsYesResponse(FALSE)) {
                ForceDismount = TRUE;
            }
        }

        if (ForceDismount) {
            if (!IFS_SYSTEM::DismountVolume(NtDriveName)) {
                Message->Set(MSG_CONV_UNABLE_TO_DISMOUNT);
                Message->Display();
                ForceDismount = FALSE;
            } else {
                //
                // Display the message only if this is the first time we dismount
                //
                if (Flags & CONVERT_NOCHKDSK_FLAG) {
                    Message->Set(MSG_VOLUME_DISMOUNTED);
                    Message->Display();
                }
            }
        }

        if (!ForceDismount) {
            *Status = CONVERT_STATUS_CANNOT_LOCK_DRIVE;
            DELETE(pDrive);
            return FALSE;
        }

        if ( !pDrive->Initialize( NtDriveName ) ) {

            //
            //  Could not initialize the drive
            //
            *Status = CONVERT_STATUS_ERROR;
            DELETE(pDrive);
            return FALSE;
        }

        if ( !pDrive->Lock() ) {

            //
            // Still cannot lock the volume
            //
            *Status = CONVERT_STATUS_CANNOT_LOCK_DRIVE;
            DELETE(pDrive);
            return FALSE;
        }
    }

    BOOLEAN fResult = ConvertFATVolume( pDrive,
                                        TargetFileSystem,
                                        CvtZoneFileName,
                                        Message,
                                        Flags,
                                        Status );

    DELETE( pDrive );
    return fResult;
#endif
}


BOOLEAN
FAR APIENTRY
ConvertFatToNtfs(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PREAL_FAT_SA        FatSa,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags,
    OUT     PCONVERT_STATUS     Status
    )

/*++

Routine Description:

    Converts a FAT volume to NTFS

Arguments:

    Drive                           supplies pointer to drive
    FatSa                           supplies pointer to FAT superarea
    CvtZoneFileName                 supplies the name of the convert zone.
    Message                         supplies an outlet for messages
    Verbose                         TRUE if should run inv verbose mode
    Status                          supplies pointer to convert status code

Return Value:

    BOOLEAN -   TRUE if conversion successful

Notes:

    The volume is locked on entry. The FAT superarea has
    been read.

--*/

{
    FAT_NTFS        FatNtfs;    //  FAT-NTFS conversion object

    DebugPrintTrace(( "CONVERT: Converting FAT volume to NTFS\n"));

    //
    //  Initialize the conversion object and invoke its
    //  conversion method.
    //

    if ( FatNtfs.Initialize( Drive, FatSa, CvtZoneFileName, Message, Flags )) {

        return FatNtfs.Convert( Status );

    } else {

        //
        //  Could not initialize FAT_NTFS object
        //
        *Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cufat\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=cnvfat
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib              \
           ..\..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib       \
           ..\..\..\ufat\src\$(ALT_PROJECT)\$(O)\ufat.lib       \
           ..\..\..\untfs\src\$(ALT_PROJECT)\$(O)\untfs.lib     \
           ..\..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib

USE_MSVCRT=1

DLLENTRY=InitializeCufat
PRECOMPILED_INCLUDE= ..\pch.cxx
MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\convfat.cxx \
        ..\cufat.cxx   \
        ..\cufat.rc    \
        ..\fatntfs.cxx

INCLUDES=..\.;                          \
         ..\..\inc;                     \
         ..\..\..\ufat\inc;             \
         ..\..\..\untfs\inc;            \
         ..\..\..\ulib\inc;             \
         ..\..\..\ifsutil\inc;          \
         $(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

UMTYPE=console
DLLDEF=..\cufat.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\alloc.cpp ===
/***************************************************************************

File Name: Alloc.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"
#ifdef BOOTIME
    extern "C"{
        #include <stdio.h>
    }
        #include "Offline.h"
#else
    #ifndef NOWINDOWSH
        #include <windows.h>
    #endif
#endif


#include "ErrMacro.h"
#include "alloc.h"

/****************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Allocate or reallocate a block of memory and optionally lock it.
    If ppMemory != NULL, then lock the memory.

GLOBALS:
    ErrorTable is defined in errors.h and corresponds the error numbers 
    to the text define for them.

INPUT:
    SizeInBytes - How much memory to allocate or reallocate
    phMemory - receives the handle to the memory
    ppMemory - Optionally receives the pointer to the locked memory

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
AllocateMemory(
    IN DWORD SizeInBytes,
    IN OUT PHANDLE phMemory,
    IN OUT PVOID* ppMemory
    )
{
    BOOL bStatus = FALSE;

    HGLOBAL hTemp = NULL;

    // Check for zero size to allocate.
    if (SizeInBytes == 0){
        EH(FALSE);
        return FALSE;
    }

    __try {

        // Check to see if the handle is NULL.  This means no memory yet - so allocate some.
        if(*phMemory == NULL) {

            // Allocate the requested memory.
            *phMemory = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, SizeInBytes);
            if (*phMemory == NULL){
                EH(FALSE);
                bStatus = FALSE;
            }
            else {
                bStatus = TRUE;
            }
            __leave;
        }
        // We already have some memory so we want to reallocate.
        // First check if the size of the memory being requested
        // is the same as that already allocated.
        if(GlobalSize(*phMemory) == SizeInBytes) {
            bStatus = TRUE;
            __leave;
        }

        // Check to see if we have a pointer to locked memory.
        if((ppMemory != NULL) && (*ppMemory != NULL)) {

            // Unlock it so that we can reallocate.
            GlobalUnlock(*phMemory);
        }

        // Reallocate the memory.  Store the return value in a temporary handle
        // so that we still have a pointer to (clean-up) the original memory 
        // block if GlobalReAlloc fails.  (RAID 516728)
        hTemp = GlobalReAlloc(*phMemory, SizeInBytes, GMEM_MOVEABLE|GMEM_ZEROINIT);
        if (hTemp == NULL){
            EH(FALSE);
            bStatus = FALSE;
            __leave;
        }
        else {
            *phMemory = hTemp;
        }

        // Success.
        bStatus = TRUE;
    }
    __finally {

        // If there was an error then cleanup.
        if (bStatus == FALSE) {

            // Check to see if we have a pointer.
            if((ppMemory != NULL) && (*ppMemory != NULL) && (*phMemory != NULL)) {

                // So unlock it the memory.
                EH_ASSERT(GlobalUnlock(*phMemory) == FALSE);
                *ppMemory = NULL;
            }
            // Now Free the memory.
            if(*phMemory != NULL) {

                EH_ASSERT(GlobalFree(*phMemory) == NULL);
                *phMemory = NULL;
            }
        } else {
            // Check to see if we have a pointer to a pointer to locked memory.
            if((ppMemory != NULL)  && (*phMemory != NULL)) {

                // Lock the memory and return the pointer..
                *ppMemory = GlobalLock(*phMemory);
                if (*ppMemory == NULL){
                    bStatus = FALSE;
                }
            }
        }
    }
    return bStatus;
}                   


/*
VOID
SapDumpSlabList(
    IN CONST PSA_CONTEXT pSaContext
    )
/*++

Routine Description:
    Utility function to dump out the slabs for a given Context

Arguments:
    pSaContext - The context for which the slabs are to be dumped

Return Value:
    None

//--/
{
    PSLAB_HEADER pSlab = pSaContext->pAllocatedSlabs;
    DWORD dwCount = 0;

    //
    // Slabs in use
    //
    printf("\n**   Dumping allocated slabs:  ");
    while (pSlab) {

        ++dwCount;
        printf("%p(%lu) ", pSlab, pSlab->dwFreeCount);
        pSlab = pSlab->pNext;
    }
    printf("%p  <<%lu>>\n", pSlab, dwCount);

    //
    // Free slab cache
    //
    dwCount = 0;
    pSlab = pSaContext->pFreeSlabs;
    printf("**   Dumping free      slabs:  ");
    while (pSlab) {

        ++dwCount;
        printf("%p ", pSlab);
        pSlab = pSlab->pNext;
    }
    printf("%p  (%lu)\n\n", pSlab, dwCount);

}
*/


inline
VOID
SapUnlinkSlab(
    IN CONST PSLAB_HEADER pSlab       
    )
/*++

Routine Description:
    Utility function to remove a slab from the linked list.  Note that the 
    pNext and pPrev for this slab are left untouched.  It is the caller's
    responsibility to ensure that he doesn't use those pointers!

Arguments:
    pSlab - Slab to be unlinked.

Return Value:
    None

--*/
{
    //
    // Unlink from the chain
    //
    if (pSlab->pNext) {
        pSlab->pNext->pPrev = pSlab->pPrev;
    }

    if (pSlab->pPrev) {
        pSlab->pPrev->pNext = pSlab->pNext;
    }

}


PSLAB_HEADER
SapGarbageCollect(
    IN OUT PSA_CONTEXT pSaContext,
    IN OUT PSLAB_HEADER pSlab
    )
/*++

Routine Description:
    Routine to deal with slabs that are freed.  The first couple of freed
    slabs will generally end up in our free list (which is used as a cache
    for future allocations).  If our free list already has two empty slabs, 
    we return this slab to the system.
    
Arguments:
    pSaContext - The slab-allocator context

    pSlab - Slab that was freed.  This may be NULL, in which case this 
            routine will just return NULL.

Return Value:
    pSlab->pNext

--*/
{
    PSLAB_HEADER pFree = pSaContext->pFreeSlabs;
    PSLAB_HEADER pNext = NULL;

    if (NULL == pSlab) {
        return NULL;
    }

    pNext = pSlab->pNext;
    //
    // If this is the first slab being freed, move the slabHead pointer to
    // the next slab
    //
    if (pSlab == pSaContext->pAllocatedSlabs) {
        pSaContext->pAllocatedSlabs = pNext;
    }

    //
    // Make sure we unlink this slab from our chain of allocated slabs
    //
    SapUnlinkSlab(pSlab);

    //
    // Check what we should do with this slab--add it to our free list,
    // or return to the system
    //
    if ((pFree) && (pFree->pNext)) {
        //
        // We already have two free slabs, return this to the system
        //
        HeapFree(GetProcessHeap(), 0L, pSlab);
    }
    else {
        //
        // We have less than two entries in our free slab list.  Add this 
        // slab to the head of the free list
        //
        pSlab->pPrev = NULL;
        pSlab->pNext = pFree;
        
        if (pFree) {
            pFree->pPrev = pSlab;
        }

        pSaContext->pFreeSlabs = pSlab;
    }

    return pNext;
}


PVOID
SaAllocatePacket(
    IN OUT PSA_CONTEXT pSaContext
    ) 
/*++

Routine Description:
    Returns a packet of size SIZE_OF_PACKET bytes.  May return NULL if the 
    system is out of free memory.

    SaInitialiseContext must have been called prior to this routine 
    being called.
    
Arguments:
    pSaContext - The slab-allocator context

Return Value:
    Pointer to a packet, or NULL if the system is out of memory. 
    
    Packets returned should be freed using SaFreePacket (or SaFreeAllPackets).

--*/
{
    PSLAB_HEADER pSlab = NULL;
    PPACKET_HEADER pReturn = NULL;

    //
    // Check input parameters
    // 
    if (NULL == pSaContext) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Find the first slab with unallocated packets
    //
    pSlab = pSaContext->pAllocatedSlabs;
    while ((NULL != pSlab) && (0 == pSlab->dwFreeCount)) {
        //
        // This slab is fully allocated, try the next one (till we run out 
        // of slabs)
        //
        pSlab = pSlab->pNext;
    }

    if (NULL == pSlab) {
        // 
        // All slabs are full, allocate a new slab.  Check if our free 
        // slab list has any slabs we can use.
        //
        if (pSaContext->pFreeSlabs != NULL) {

            pSlab = pSaContext->pFreeSlabs;
            // pSlab->pNext and pPrev will be initialised below


            pSaContext->pFreeSlabs = pSaContext->pFreeSlabs->pNext;
            if (pSaContext->pFreeSlabs) {
                pSaContext->pFreeSlabs->pPrev = NULL;
            }
        }
        else {
            //
            // Our free list is empty.  Allocate a new slab from ProcessHeap.
            //
            pSlab = (PSLAB_HEADER) HeapAlloc(GetProcessHeap(), 
                0L, 
                pSaContext->dwSlabSize);

            if (NULL == pSlab) {
                //
                // System is out of memory.  Sigh.
                //
                return NULL;
            }
        }

        // 
        // Initialise the new slab
        //
        pSlab->pNext = pSaContext->pAllocatedSlabs;
        pSlab->pPrev = NULL;
        pSlab->pFree = NULL;
        pSlab->dwFreeCount = pSaContext->dwPacketsPerSlab;

        if (pSaContext->pAllocatedSlabs) {
            // 
            // Add it to the head of the chain
            //
            pSaContext->pAllocatedSlabs->pPrev = pSlab;
        }
        pSaContext->pAllocatedSlabs = pSlab;
    }

    // 
    // Get the packet to return;
    //
    if (NULL == pSlab->pFree) {
        pReturn = (PPACKET_HEADER) ((LPBYTE)pSlab + sizeof(SLAB_HEADER) + 
            ((pSaContext->dwPacketsPerSlab - (pSlab->dwFreeCount)) * 
            pSaContext->dwPacketSize));
    }
    else {
        pReturn = pSlab->pFree;
        pSlab->pFree = pSlab->pFree->pNext;
    }

    //
    // And decrement our free count
    //
    --(pSlab->dwFreeCount);

    //
    // Write the slab header at the start of the packet, and return the rest 
    // of the packet to the caller
    //
    pReturn->pSlab = pSlab;
    return (PVOID) ((LPBYTE)pReturn + sizeof(PACKET_HEADER));
}


VOID
SaFreePacket(
    IN PSA_CONTEXT pSaContext,
    IN PVOID pMemory
    )
/*++

Routine Description:
    Frees a packet allocated by SaAllocatePacket.  
    
Arguments:
    pSaContext - The slab-allocator context
    pMemory - The memory to be freed.

Return Value:
    None

--*/
{
    PSLAB_HEADER pSlab = NULL;
    PPACKET_HEADER pPacket = NULL;

    if ((NULL == pSaContext) || (NULL == pMemory)) {
        return;
    }

    // 
    // The packet starts one pointer-length before the memory we returned 
    // to the caller
    //
    pPacket = (PPACKET_HEADER)((LPBYTE)pMemory - sizeof(PACKET_HEADER));
    
    //
    // The slab start address is written at the start of our packet
    //
    pSlab = pPacket->pSlab;
    
    //
    // Add this packet to the (head of the) slab's free packet list
    //
    pPacket->pNext  = pSlab->pFree;
    pSlab->pFree    = pPacket;

    //
    // Increment the FreeCount for the slab
    //
    ++(pSlab->dwFreeCount);

    //
    // Check if the entire slab is free
    //
    if (pSaContext->dwPacketsPerSlab  == pSlab->dwFreeCount) {
        SapGarbageCollect(pSaContext, pSlab);
    }
    else {
        //
        // If this has more than twice as many free packets as the slab at 
        // the list head, move this up
        //
        if ((pSlab->dwFreeCount > 4) && 
            (pSlab->dwFreeCount > ((pSaContext->pAllocatedSlabs->dwFreeCount) * 2))
            ) {

            SapUnlinkSlab(pSlab);

            pSlab->pNext = pSaContext->pAllocatedSlabs;
            pSlab->pPrev = NULL;

            if (pSaContext->pAllocatedSlabs) {
                pSaContext->pAllocatedSlabs->pPrev = pSlab; 
            }

            pSaContext->pAllocatedSlabs = pSlab;
        }
    }
}


VOID
SaFreeAllPackets(
    IN OUT PSA_CONTEXT pSaContext
    )
/*++

Routine Description:
    Frees all packets that have been allocated for a given context
    
Arguments:
    pSaContext - The slab-allocator context that is to be freed

Return Value:
    None

--*/
{
    PSLAB_HEADER pTemp = NULL,
        pSlab = pSaContext->pAllocatedSlabs;

    if (NULL == pSaContext) {
        return;
    }

    //
    // Free all allocated slabs.  No need to free invidiual packets
    //
    while (SapGarbageCollect(pSaContext, pSaContext->pAllocatedSlabs))
        ;
}


BOOL
SaInitialiseContext(
    IN OUT PSA_CONTEXT pSaContext,
    IN CONST DWORD dwPacketSize,
    IN CONST DWORD dwSlabSize
    )
/*++

Routine Description:
    Initialisation routine to set up a slab allocator context.  This routine 
    must be called before any of the Sa* routines above.
    
Arguments:
    pSaContext - The slab-allocator context to set up
    
    dwPacketSize - The size of a packet for this slab, in bytes

    dwSlabSize - The size of a slab.  Generally close to a PAGE_SIZE.

Return Value:
    TRUE - Initialization completed successfully

    FALSE - The slab wasn't initialized.  (Generally because the parameters
            are invalid)

--*/
{
    if ((NULL == pSaContext) || (0 == dwPacketSize) || (0 == dwSlabSize)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pSaContext->pAllocatedSlabs = NULL;
    pSaContext->pFreeSlabs = NULL;

    pSaContext->dwPacketSize = dwPacketSize 
                                + sizeof(struct _PACKET_HEADER)     // allow for our packet header
                                + (sizeof(PVOID) * 4);              // allow for the AVL tree over-head

    pSaContext->dwSlabSize = dwSlabSize;
    
    pSaContext->dwPacketsPerSlab = 
      (pSaContext->dwSlabSize - sizeof(struct _SLAB_HEADER)) / (pSaContext->dwPacketSize);


    if (pSaContext->dwPacketsPerSlab < 1) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    else {
        return TRUE;
    }
}

VOID
SaFreeContext(
    IN OUT PSA_CONTEXT pSaContext
    )
/*++

Routine Description:
    Clean up routine to free all memory associated with a slab allocator 
    context.
    
Arguments:
    pSaContext - The slab-allocator context to be cleaned up
    
Return Value:
    None

--*/
{
    if (!pSaContext) {
        return;
    }

    //
    // Free all allocated packets
    //
    SaFreeAllPackets(pSaContext);

    // 
    // Return the free slabs to the system
    //
    if (pSaContext->pFreeSlabs) {
        
        if (pSaContext->pFreeSlabs->pNext) {
            HeapFree(GetProcessHeap(), 0L, pSaContext->pFreeSlabs->pNext);
        }

        HeapFree(GetProcessHeap(), 0L, pSaContext->pFreeSlabs);
        pSaContext->pFreeSlabs = NULL;
    }

    //
    // And zero out the struct
    //
    ZeroMemory(pSaContext, sizeof(SA_CONTEXT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\cufat\src\fatntfs.cxx ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    fatntfs.cxx

Abstract:

    This module implements the conversion from FAT to NTFS

Author:

    Ramon J. San Andres (ramonsa)  Sep-19-1991

Environment:

    ULIB, User Mode

--*/


#include <pch.cxx>

//
//  ULIB include files
//
#define _NTAPI_ULIB_
#include "ulib.hxx"
#include "array.hxx"
#include "drive.hxx"
#include "hmem.hxx"
#include "wstring.hxx"
#include "rtmsg.h"

//#define CONVERT_PERF_COUNTERS   1

//
//  IFSUTIL include files
//
#include "secrun.hxx"

#if defined ( _AUTOCONV_ )
#include "ifssys.hxx"
#else
#if defined(CONVERT_PERF_COUNTERS)
#include <stdio.h>
#endif
#endif

//
//  CUFAT include files
//

#include "fatsa.hxx"
#include "fatntfs.hxx"

//
//  UFAT include files
//
#include "fatdent.hxx"
#include "fatdir.hxx"
#include "filedir.hxx"

//
//  UNTFS include files
//
#include "attrib.hxx"
#include "upfile.hxx"
#include "logfile.hxx"
#include "ntfssa.hxx"

//
//  Number of clusters in boot sector
//
#define CLUSTERS_IN_BOOT         ((BYTES_IN_BOOT_AREA + _ClusterFactor*_Drive->QuerySectorSize() - 1)/ \
                                  (_ClusterFactor*_Drive->QuerySectorSize()))

//
//  Maximum ntfs cluster size to use during conversion
//
#define MAX_NTFS_CLUSTER_SIZE   (1024*4)    // 4K

DEFINE_CONSTRUCTOR( FAT_NTFS, OBJECT );

#if defined(CONVERT_PERF_COUNTERS)
typedef struct _PERF_DATA {
    BOOLEAN             first_call;
    LARGE_INTEGER       t1;
    LARGE_INTEGER       wwtime;
    LARGE_INTEGER       wrtime;
    LARGE_INTEGER       wctime;
    LARGE_INTEGER       wscnt;
    LARGE_INTEGER       wccnt;
    LARGE_INTEGER       rrtime;
    LARGE_INTEGER       rscnt;
    LARGE_INTEGER       rccnt;
} PERF_DATA;

BOOLEAN
CheckTime(
    PMESSAGE            Message,
    PLOG_IO_DP_DRIVE    pDrive,
    PERF_DATA           *pData,
    PCHAR               Title
)
{
    LARGE_INTEGER   freq;
    LARGE_INTEGER   wwtime;
    LARGE_INTEGER   wrtime;
    LARGE_INTEGER   wctime;
    LARGE_INTEGER   wscnt;
    LARGE_INTEGER   wccnt;
    LARGE_INTEGER   rrtime;
    LARGE_INTEGER   rscnt;
    LARGE_INTEGER   rccnt;
    LARGE_INTEGER   t2;

    if (pData->first_call) {
        pData->first_call = FALSE;
        pDrive->QueryPerformanceCounters(&pData->wwtime,
                                         &pData->wrtime,
                                         &pData->wctime,
                                         &pData->wscnt,
                                         &pData->wccnt,
                                         &pData->rrtime,
                                         &pData->rscnt,
                                         &pData->rccnt);
        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", "VVVV ", Title);
        QueryPerformanceCounter(&pData->t1);
    } else {
        QueryPerformanceCounter(&t2);
        pDrive->QueryPerformanceCounters(&wwtime,
                                         &wrtime,
                                         &wctime,
                                         &wscnt,
                                         &wccnt,
                                         &rrtime,
                                         &rscnt,
                                         &rccnt);
        QueryPerformanceFrequency(&freq);
        Message->Set(MSG_CHK_NTFS_MESSAGE);
        Message->Display("%s%I64d", "^^^^ Elapsed time in ms: ",
                         ((t2.QuadPart-pData->t1.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ WWTime: ", ((wwtime.QuadPart-pData->wwtime.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ WRTime: ", ((wrtime.QuadPart-pData->wrtime.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ WCTime: ", ((wctime.QuadPart-pData->wctime.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ WSCnt: ",  wscnt.QuadPart -pData->wscnt.QuadPart);
        Message->Display("%s%I64d", "^^^^ WCCnt: ",  wccnt.QuadPart -pData->wccnt.QuadPart);
        Message->Display("%s%I64d", "^^^^ RCTime: ", ((rrtime.QuadPart-pData->rrtime.QuadPart)*1000)/freq.QuadPart);
        Message->Display("%s%I64d", "^^^^ RSCnt: ",  rscnt.QuadPart -pData->rscnt.QuadPart);
        Message->Display("%s%I64d", "^^^^ RCCnt: ",  rccnt.QuadPart -pData->rccnt.QuadPart);

        pData->wwtime = wwtime;
        pData->wrtime = wrtime;
        pData->wctime = wctime;
        pData->wscnt = wscnt;
        pData->wccnt = wccnt;
        pData->rrtime = rrtime;
        pData->rscnt = rscnt;
        pData->rccnt = rccnt;

        Message->Display("%s%s", "VVVV ", Title);
        QueryPerformanceCounter(&pData->t1);
    }
    return TRUE;
}
#endif


VOID
FAT_NTFS::Construct (
    )
/*++

Routine Description:

    Constructs a FAT_NTFS object

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FatSa          =   NULL;
    _Drive          =   NULL;
    _Message        =   NULL;
    _FileNameBuffer =   NULL;
}



VOID
FAT_NTFS::Destroy (
    )
/*++

Routine Description:

    Destroys a FAT_NTFS object

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE( _FatSa );
    DELETE( _Drive );
    DELETE( _Message );
    DELETE( _FileNameBuffer );
}



FAT_NTFS::~FAT_NTFS (
    )
/*++

Routine Description:

    Destructor for FAT_NTFS.

Arguments:

    None.

Return Value:

    None.

--*/
{
}



BOOLEAN
FAT_NTFS::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PREAL_FAT_SA        FatSa,
    IN      PCWSTRING           CvtZoneFileName,
    IN OUT  PMESSAGE            Message,
    IN      ULONG               Flags
    )
/*++

Routine Description:

    Initializes a FAT_NTFS object

Arguments:

    FatVol  -   Supplies the FAT volume
    FatSa   -   Supplies pointer to FAT superarea
    CvtZoneFileName - Supplies the name of the convert zone.
    Message -   Supplies message object
    Flags   -   Supplies convert flags

Return Value:

    BOOLEAN -   TRUE if successfully initialized, FALSE otherwise

--*/

{
    ULONG   fat_cluster_size;
    LCN     cvt_zone_in_ntfs;
    BIG_INT cvt_zone_size_in_ntfs;

    DebugPtrAssert( Drive     );
    DebugPtrAssert( FatSa     );
    DebugPtrAssert( Message   );

    //
    //  Initialize the stuff passed as argument
    //
    _FatSa          =   FatSa;
    _Drive          =   Drive;
    _Message        =   Message;
    _Flags          =   Flags;

    //  Floppies cannot be converted to NTFS.
    //
    if( _Drive->IsFloppy() ) {

        Message->Set(MSG_NTFS_FORMAT_NO_FLOPPIES);
        Message->Display();
        return FALSE;
    }

    //  To protect ourselves from disk drivers that cannot
    //  correctly determine the disk geometry, compare the
    //  boot-code-critical values from the existing BPB with
    //  the drive's values.  If they don't match, we can't
    //  convert this drive because if it's the system partition,
    //  the system won't boot.
    //
    if( !CheckGeometryMatch( ) ) {

        _Message->Set( MSG_CONV_GEOMETRY_MISMATCH );
        _Message->Display( "%s", "NTFS"  );
        return FALSE;
    }

    fat_cluster_size = FatSa->QuerySectorsPerCluster() * _Drive->QuerySectorSize();

    //
    //  For volumes that are not data aligned, make cluster size
    //  equals sector size.
    //  For volumes that are data aligned, preserve the cluster size
    //
    if (FatSa->IsVolumeDataAligned()) {
        _ClusterFactor = min(FatSa->QuerySectorsPerCluster(),
                             MAX_NTFS_CLUSTER_SIZE/_Drive->QuerySectorSize());
        _ClusterRatio = max(1, fat_cluster_size/MAX_NTFS_CLUSTER_SIZE);
    } else {
        _ClusterFactor = 1;
        _ClusterRatio = FatSa->QuerySectorsPerCluster();
    }


    if (SMALL_FRS_SIZE >= Drive->QuerySectorSize())
        _FrsSize = SMALL_FRS_SIZE;
    else
        _FrsSize = Drive->QuerySectorSize();

    //  Set the default number of clusters per Index Allocation Buffer
    //  to a useful value.
    //
    _ClustersPerIndexBuffer = NTFS_SA::QueryDefaultClustersPerIndexBuffer(
                                       _Drive, _ClusterFactor);

    //
    //  _NumberOfFiles and _NumberOfDirectories are used to extend
    //  the MFT when we know how many files there are in the volume.
    //  Unless we do a volume census these values must be zero.
    //
    _NumberOfFiles          =   0;
    _NumberOfDirectories    =   0;

    if ( CvtZoneFileName->QueryChCount() ) {

        PFATDIR     RootDir;
        FAT_DIRENT  CvtZoneFileEntry;

        //
        //  Get the root directory
        //
        RootDir = (PFATDIR)_FatSa->GetRootDir();
        if ( !RootDir ) {
            RootDir = (PFATDIR)_FatSa->GetFileDir();
        }

        DebugPtrAssert( RootDir );

        //
        //  Locate the convert zone file. If it exists then remember its starting cluster
        //  number and it's size.
        //
        //  The starting cluster of the convert zone is remembered because it is used
        //  later on for identifying the convert zone file while traversing the root directory.
        //

        if ( CvtZoneFileEntry.Initialize( RootDir->SearchForDirEntry( CvtZoneFileName ),
                                          FatSa->GetFileDir() ? FAT_TYPE_FAT32 : FAT_TYPE_EAS_OKAY )) {

            if (CvtZoneFileEntry.IsDirectory()) {
                Message->Set(MSG_CONV_CVTAREA_MUST_BE_FILE, ERROR_MESSAGE);
                Message->Display("%W", CvtZoneFileName);
                return FALSE;
            }
            _CvtZoneFileFirstCluster = CvtZoneFileEntry.QueryStartingCluster();
            _CvtZoneSize = (((BIG_INT)CvtZoneFileEntry.QueryFileSize() + fat_cluster_size - 1)/fat_cluster_size).GetLowPart();

            if (!FatSa->IsFileContiguous(_CvtZoneFileFirstCluster)) {
                Message->Set(MSG_CONV_CVTAREA_FILE_NOT_CONTIGUOUS, ERROR_MESSAGE);
                Message->Display("%W", CvtZoneFileName);
                return FALSE;
            }

            cvt_zone_in_ntfs = FatClusterToLcn(_CvtZoneFileFirstCluster)/_ClusterFactor;
            cvt_zone_size_in_ntfs = _CvtZoneSize*_ClusterRatio;
        } else {
            Message->Set(MSG_CONV_CVTAREA_FILE_MISSING, ERROR_MESSAGE);
            Message->Display("%W", CvtZoneFileName);
            return FALSE;
        }
    } else {
        _CvtZoneFileFirstCluster = 0;
        _CvtZoneSize = 0;
        cvt_zone_in_ntfs = 0;
        cvt_zone_size_in_ntfs = 0;
    }

    DebugAssert(cvt_zone_in_ntfs.GetHighPart() == 0);
    DebugAssert(cvt_zone_size_in_ntfs.GetHighPart() == 0);

    //  Allocate space for the file name attribute buffer and initialize
    //  the NTFS superarea and the Bad LCN stack.
    //

    if ( (

        _FileNameBuffer =
         (PFILE_NAME)MALLOC( sizeof(FILE_NAME) +
                             sizeof(WCHAR) * NAMEBUFFERSIZE )) == NULL ||
        !_RootIndexName.Initialize( FileNameIndexNameData ) ||
        !_NtfsSa.Initialize( _Drive, _Message,
                             cvt_zone_in_ntfs,
                             cvt_zone_size_in_ntfs )       ||
        !_BadLcn.Initialize() ) {
        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
FAT_NTFS::Convert(
    OUT PCONVERT_STATUS Status
    )

/*++

Routine Description:

    Converts a FAT volume to NTFS

Arguments:

    Status  -   Supplies pointer to conversion status

Return Value:

    BOOLEAN -   TRUE if successfully converted, FALSE otherwise

--*/

{
    BOOLEAN     Converted;
#if defined(CONVERT_PERF_COUNTERS)
    PERF_DATA   pdata;

    pdata.first_call = TRUE;
#endif

    DebugPtrAssert( Status );

#if defined ( _AUTOCONV_ )

    _Message->Set( MSG_CONV_WILL_REBOOT );
    _Message->Display();

#endif // _AUTOCONV_

    //
    //  The conversion from FAT to NTFS consists of a sequence of well-defined
    //  steps:
    //
    //  1.- Create holes (i.e. relocate FAT clusters) for fixed-location
    //      NTFS structures and save FAT.
    //
    //  2.- Create NTFS elementary data structures in FAT free space
    //
    //  3.- Convert the File system, creating the NTFS file system in
    //      the FAT free space.
    //
    //  4.- Mark as free in the NTFS bitmap those NTFS clusters being used
    //      by FAT-specific structures.
    //
    //  5.- Write NTFS boot sector
    //
    //
    //  Since a crash can occur at any time, we must minimize the chance of
    //  disk corruption. Note that (almost) all writes are to FAT free space,
    //  so a crash will preserve the FAT intact.
    //
    //  The only times at which we write to non-free space, i.e. the times at
    //  which a crash might cause problems are:
    //
    //  a.- At the end of step 1, when we overwrite the FAT. The algorithm
    //      for relocating clusters (in UFAT) guarantees that CHKDSK will be
    //      able to fix the disk without any loss of data.
    //
    //  b.- In step 5, while writting the boot sector. If a crash occurs during
    //      this step, We're out of luck.
    //
    //

    Converted = (BOOLEAN)(  //
                            //  Create holes for fixed-location structures
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "CheckSpaceAndCreateHoles") &&
#endif
                            CheckSpaceAndCreateHoles( )                                     &&
                            //
                            //    Initialize the bitmaps
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "CreateBitmaps")            &&
#endif
                            CreateBitmaps( )                                                &&
                            //
                            //    Create the NTFS elementary data structures
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "CreateElementary")         &&
#endif
                            CreateElementary( )                                             &&
                            //
                            //    Convert the file system
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "ConvertFileSystem")        &&
#endif
                            ConvertFileSystem( )                                            &&
                            //
                            //    Mark the reserved sectors as free
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "FreeReservedSectors")      &&
#endif
                            FreeReservedSectors( )                                          &&
                            //
                            //    Volume converted, write the boot code
                            //
#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "WriteBoot")                &&
#endif
                            WriteBoot( )                                                    &&

#if defined(CONVERT_PERF_COUNTERS)
                            CheckTime(_Message, _Drive, &pdata, "Done")                     &&
#endif
                            (TRUE));

    *Status = _Status;

    return Converted;
}



BOOLEAN
FAT_NTFS::CheckSpaceAndCreateHoles (
    )

/*++

Routine Description:

    Determines free space requirements, makes sure that there is
    enough space for conversion, and makes holes. All this
    is done in one step so that we only have to traverse the
    file system once.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if there is enough space for conversion and
                the holes are in place.
                FALSE otherwise

--*/

{
    INTSTACK        HoleStack;          //  Stack of holes
    CENSUS_REPORT   CensusReport;       //  Census report
    PCENSUS_REPORT  Census;             //  Pointer to census report
    BIG_INT         SectorsTotal;       //  Number of sectors on the volume
    BIG_INT         SectorsFree;        //  Free sectors on the volume
    BIG_INT         SectorsNeeded;      //  Sectors needed by conversion
    BIG_INT         KbytesTotal;
    BIG_INT         KbytesFree;
    BIG_INT         KbytesNeeded;
    BOOLE