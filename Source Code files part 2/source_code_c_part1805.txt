  // Add this element to the master list so we save it when we submit
            //  and sink the submit event for this element's form
            MarkDirty();
        }

        ASSERT((m_pEnumString && m_hwndEdit) || (lKey==VK_TAB));
    }

    // If AutoComplete hasn't been initialized there's nothing for us to do
    if (!m_pAutoCompleteDD || !m_hwndEdit)
    {
        return E_FAIL;
    }

    // Update the position of our hidden edit box
    long lLeft, lTop, lWidth, lHeight;

    // call UpdateDropdownPosition instead
    if (SUCCEEDED(GetScreenCoordinates(pEle, m_pParent->m_hwndBrowser, &lLeft, &lTop, &lWidth, &lHeight)))
    {
        MoveWindow(m_hwndEdit, lLeft, lTop, lWidth, lHeight, FALSE);
    }

    switch (Event)
    {
        case EVENT_FOCUS :
            SendMessage(m_hwndEdit, WM_SETFOCUS, 0, 0);
            break;

        case EVENT_BLUR:
        {
            if (m_hwndEdit)
            {
                SendMessage(m_hwndEdit, WM_KILLFOCUS, 0, 0);
            }

            // ensure that script hasn't changed value of edit field?
            BSTR bstrUsername=NULL;
            m_pTextEle->get_value(&bstrUsername);
            if (bstrUsername)
            {
                CheckAutoFillPassword(bstrUsername);
                SysFreeString(bstrUsername);
            }
        }
        break;
        
        case EVENT_MOUSEDOWN:
        case EVENT_DBLCLICK:
        {
            // If the dropdown is invisible, give AutoComplete a downarrow
            long lButton=0;
            pEventObj->get_button(&lButton);
            if ((Event == EVENT_DBLCLICK) ||
                (lButton & 1))                      // Left button down?
            {
                DWORD dwFlags;

                if (SUCCEEDED(m_pAutoCompleteDD->GetDropDownStatus(&dwFlags, NULL)) &&
                    !(dwFlags & ACDD_VISIBLE))
                {
                    TraceMsg(TF_IFORMS, "IForms sending downarrow because of mouse click");
                    PostMessage(m_hwndEdit, IF_KEYDOWN, (WPARAM)VK_DOWN, 0);
                    m_fEscapeHit = FALSE;
                }
            }
        }
        break;
        
        case EVENT_KEYPRESS:
        {
            // Add this element to the master list so we save it when we submit
            //  and sink the submit event for this element's form
            MarkDirty();

            // Ignore ctrl-enter (quickcomplete) (may be unnecessary)
            if (lKey == VK_RETURN)
            {
                VARIANT_BOOL bCtrl;
                if (SUCCEEDED(pEventObj->get_ctrlKey(&bCtrl)) && bCtrl)
                {
                    lKey = 0;
                }
            }

            if (lKey != 0)
            {
                if (lKey == m_lCancelKeyPress)
                {
                    // tell MSHTML to ignore this keystroke (may be tab, enter, escape)
                    TraceMsg(TF_IFORMS, "Intelliforms cancelling default action for EVENT_KEYPRESS=%d", lKey);

                    VARIANT v;
                    v.vt = VT_BOOL;
                    v.boolVal = VARIANT_FALSE;
                    pEventObj->put_returnValue(v);
                    if(!(lKey == VK_DOWN || lKey == VK_UP))
                        pEventObj->put_cancelBubble(VARIANT_TRUE);
                }

                m_lCancelKeyPress = 0;

                // Tell AutoComplete about this keystroke
                if (!m_fEscapeHit)
                {
                    PostMessage(m_hwndEdit, IF_CHAR, (WPARAM)lKey, 0);
                }
            }

            if (fIsComposition)
            {
                // Tell AutoComplete about the new string. This must be a Post so that
                //  Trident handles the event before we send the WM_CHAR to browseui.
                PostMessage(m_hwndEdit, IF_IME_COMPOSITION, 0, 0);
            }
        }
        break;
        
        case EVENT_KEYDOWN:
        {
            long    lKey;
            BOOL    fCancelEvent=FALSE,         // Cancel default MSHTML action?
                    fForwardKeystroke=TRUE;     // Forward keystroke to AutoComplete?

            pEventObj->get_keyCode(&lKey);

            if (m_fEscapeHit)
            {
                // They dismissed the dropdown; don't bring it back unless they ask for it
                if (lKey == VK_DOWN)
                {
                    m_fEscapeHit = FALSE;
                }
                else
                {
                    fForwardKeystroke = FALSE;
                }
            }

            if (lKey != 0)
            {
                if ((lKey == VK_RETURN) || (lKey == VK_TAB))
                {
                    fForwardKeystroke=FALSE;

                    LPWSTR pwszString=NULL;

                    if (SUCCEEDED(m_pAutoCompleteDD->GetDropDownStatus(NULL, &pwszString)) && pwszString)
                    {
                        // User is inside dropdown
                        fForwardKeystroke=TRUE;

                        // Set this value into our edit field
                        SetText(pwszString);

                        // We will fill in their password if they asked for it in m_uMsgItemActivate

                        if (lKey == VK_RETURN)
                        {
                            // Avoid submitting this form
                            fCancelEvent = TRUE;
                        }

                        CoTaskMemFree(pwszString);
                    }
                    else if (lKey == VK_RETURN)
                    {
                        // User's gonna submit. Give 'em their password first.
                        // ensure that script hasn't changed value of edit field?
                        BSTR bstrUsername=NULL;
                        m_pTextEle->get_value(&bstrUsername);
                        if (bstrUsername)
                        {
                            CheckAutoFillPassword(bstrUsername);
                            SysFreeString(bstrUsername);
                        }
                    }
                }
                else if (lKey == VK_DELETE)
                {
                    LPWSTR pwszString=NULL;

                    if (SUCCEEDED(m_pAutoCompleteDD->GetDropDownStatus(NULL, &pwszString)) && pwszString)
                    {
                        // User is inside dropdown
                        fForwardKeystroke=FALSE;

                        // Delete this value from our string lists
                        CStringList *psl=NULL;
                        BSTR bstrName;

                        CIntelliForms::GetName(m_pTextEle, &bstrName);

                        if (bstrName)
                        {
                            int iIndex;

                            if (SUCCEEDED(m_pParent->ReadFromStore(bstrName, &psl)) &&
                                SUCCEEDED(psl->FindString(pwszString, -1, &iIndex, FALSE)))
                            {
                                TraceMsg(TF_IFORMS, "IForms: Deleting string \"%ws\"", pwszString);
                                psl->DeleteString(iIndex);

                                // We deleted string.
                                if (psl->NumStrings() > 0)
                                {
                                    m_pParent->WriteToStore(bstrName, psl);
                                }
                                else
                                {
                                    m_pParent->DeleteFromStore(bstrName);
                                }
                            }
                        }

                        SysFreeString(bstrName);
                        if (psl) delete psl;

                        // avoid deleting a character from the edit window; user was inside dropdown
                        fCancelEvent = TRUE;

                        // Check this url to see if we should maybe delete a password entry
                        m_pParent->DeletePassword(pwszString);

                        // Get AutoComplete to fill in the dropdown again
                        m_pEnumString->ResetEnum();
                        m_pAutoCompleteDD->ResetEnumerator();

                        CoTaskMemFree(pwszString);
                    }
                }

                if (lKey == VK_ESCAPE)
                {
                    DWORD dwFlags;

                    if (SUCCEEDED(m_pAutoCompleteDD->GetDropDownStatus(&dwFlags, NULL)) &&
                        (dwFlags & ACDD_VISIBLE))
                    {
                        fCancelEvent = TRUE;
                        m_fEscapeHit = TRUE;
                    }
                }

                if (lKey == VK_DOWN || lKey == VK_UP)
                {
                    // Cancel the MSHTML events. This will cause MSHTML to return
                    //  S_OK instead of S_FALSE from its TranslateAccelerator, and we
                    //  won't get multiple keystrokes in different panes
                    fCancelEvent = TRUE;
                }

                if (fForwardKeystroke)
                {
                    PostMessage(m_hwndEdit, IF_KEYDOWN, lKey, 0);

                    if (lKey == VK_BACK)
                    {
                        // Never get OnKeyPress for this guy
                        PostMessage(m_hwndEdit, IF_CHAR, lKey, 0);
                    }
                }

                if (fCancelEvent)
                {
                    TraceMsg(TF_IFORMS, "Intelliforms cancelling default action for EVENT_KEYDOWN=%d", lKey);

                    m_lCancelKeyPress = lKey;    // Cancel the EVENT_KEYPRESS when it comes

                    VARIANT v;
                    v.vt = VT_BOOL;
                    v.boolVal = VARIANT_FALSE;
                    pEventObj->put_returnValue(v);
                    if(!(lKey == VK_DOWN || lKey == VK_UP))
                        pEventObj->put_cancelBubble(VARIANT_TRUE);
                }
                else
                {
                    m_lCancelKeyPress = 0;
                }
            }
        }
        break;
    }

    return S_OK;
}

HRESULT CIntelliForms::CAutoSuggest::GetText(int cchTextMax, LPWSTR pszTextOut, LRESULT *lcchCopied)
{
    *pszTextOut = TEXT('\0');
    *lcchCopied = 0;

    if (m_pTextEle)
    {
        BSTR bstr=NULL;
        m_pTextEle->get_value(&bstr);
        if (bstr)
        {
            StrCpyN(pszTextOut, bstr, cchTextMax);
            *lcchCopied = lstrlenW(pszTextOut);     // needed for NT

            SysFreeString(bstr);
        }
    }

    return (*pszTextOut) ? S_OK : E_FAIL;
}

HRESULT CIntelliForms::CAutoSuggest::GetTextLength(int *pcch)
{
    *pcch = 0;

    if (m_pTextEle)
    {
        BSTR bstr=NULL;
        m_pTextEle->get_value(&bstr);
        if (bstr)
        {
            *pcch = SysStringLen(bstr);

            SysFreeString(bstr);
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::CAutoSuggest::SetText(LPCWSTR pszTextIn)
{
    if (m_pTextEle && pszTextIn)
    {
        BSTR bstr=SysAllocString(pszTextIn);

        if (bstr)
        {
            // Even though we know we already have this string in our dropdown, mark
            //  it as dirty so that we sink submit event; can be necessary in saved
            //  password situation.
            MarkDirty();

            // Make sure we don't put a string longer than the max length in this field
            long lMaxLen=-1;
            m_pTextEle->get_maxLength(&lMaxLen);
            if ((lMaxLen >= 0) && (lstrlenW(bstr) > lMaxLen))
            {
                bstr[lMaxLen] = L'\0';
            }

            m_pTextEle->put_value(bstr);
            SysFreeString(bstr);
        }
    }

    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::SetText \"%ws\"", pszTextIn);

    return S_OK;
}

#define MY_GWL_THISPTR 0

LRESULT CALLBACK CIntelliForms::CAutoSuggest::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CIntelliForms::CAutoSuggest *pThis = (CIntelliForms::CAutoSuggest *)GetWindowLongPtr(hwnd, MY_GWL_THISPTR);

    switch (uMsg)
    {
    case WM_CREATE:
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;

            if (!pcs || !(pcs->lpCreateParams))
            {
                return -1;
            }
            SetWindowLongPtr(hwnd, MY_GWL_THISPTR, (LONG_PTR) pcs->lpCreateParams);
            return 0;
        }

    case WM_GETTEXT:
        if (pThis)
        {
            LRESULT lcchCopied=0;

            if (g_fRunningOnNT)
            {
                pThis->GetText((int)wParam, (LPWSTR) lParam, &lcchCopied);
            }
            else
            {
                // We are actually an ANSI window. Convert.
                LPWSTR pwszOutBuf = (LPWSTR) LocalAlloc(LPTR, (wParam+1)*sizeof(WCHAR));

                if (pwszOutBuf)
                {
                    pThis->GetText((int)wParam, pwszOutBuf, &lcchCopied);

                    SHUnicodeToAnsi(pwszOutBuf, (LPSTR) lParam, (int)(wParam+1));

                    LocalFree((HLOCAL)pwszOutBuf);
                    pwszOutBuf = NULL;
                }
            }
            return lcchCopied;
        }

        return 0;

    case WM_GETTEXTLENGTH:
        if (pThis)
        {
            int iLen;
            pThis->GetTextLength(&iLen);
            return iLen;
        }

        return 0;

    case EM_GETSEL:
        // Must return zeroes here or autocomp will use uninitialized
        //  values and crash
        if (wParam) (*(DWORD *)wParam) = 0;
        if (lParam) (*(DWORD *)lParam) = 0;
        break;

    case IF_IME_COMPOSITION:
        // Forward a WM_CHAR. Autocomplete will notice that the rest of the string
        //  has changed if necessary (it does a GetText)
        SendMessage(hwnd, WM_CHAR, 32, 0);
        break;

    case IF_CHAR:
        SendMessage(hwnd, WM_CHAR, wParam, lParam);
        break;

    case IF_KEYDOWN:
        SendMessage(hwnd, WM_KEYDOWN, wParam, lParam);
        break;

    case WM_KEYDOWN:
    case WM_CHAR:
        return 0;       // eat it (see notes at top of file)

    default:

        // Check registered message
        if (pThis && uMsg == pThis->m_uMsgItemActivate)
        {
            TraceMsg(TF_IFORMS, "IForms: Received AM_ITEMACTIVATE(WM_APP+2)");
            pThis->SetText((LPCWSTR)lParam);
            pThis->CheckAutoFillPassword((LPCWSTR)lParam);

            return 0;
        }

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 1;
}

CIntelliForms::CAutoSuggest::CEnumString::CEnumString()
{
//  TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::CEnumString::CEnumString");
    DllAddRef();

    InitializeCriticalSection(&m_crit);

    m_cRef = 1;
}

CIntelliForms::CAutoSuggest::CEnumString::~CEnumString()
{
//  TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::CEnumString::~CEnumString");
    if (m_pslMain)
    {
        delete m_pslMain;
    }
    SysFreeString(m_bstrName);
    if (m_pszOpsValue)
    {
        CoTaskMemFree(m_pszOpsValue);
    }

    DeleteCriticalSection(&m_crit);

    DllRelease();
}

HRESULT CIntelliForms::CAutoSuggest::CEnumString::Init(IHTMLInputTextElement *pInputEle, CIntelliForms *pIntelliForms)
{
    if (m_fInit ||              // Can only init once
        !pInputEle || !pIntelliForms)       // Need both pointers
    {
        return E_FAIL;
    }

    m_fInit=TRUE;
    m_pIntelliForms = pIntelliForms;

    // Take care of things that must be done on the main thread. Autocomplete will
    //  call us on a secondary thread to do the enumeration.
    CIntelliForms::GetName(pInputEle, &m_bstrName);

    if (m_bstrName && m_bstrName[0])
    {
        // See if this specifies the "vcard." format
        if (IsEnabledInCPL() &&
            !StrCmpNICW(m_bstrName, c_wszVCardPrefix, ARRAYSIZE(c_wszVCardPrefix)-1))
        {
            // It does. Retrieve string from the profile assistant store.
            IHTMLWindow2     *pWin2 = NULL;
            IServiceProvider *pQS   = NULL;

            // QS up to get the shdocvw IHTMLWindow2 instead of NF trident's
            pInputEle->QueryInterface(IID_IServiceProvider, (void **)&pQS);

            if (pQS)
            {
                pQS->QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void **)&pWin2);
                pQS->Release();
            }

            if (pWin2)
            {
                IOmNavigator *pNav=NULL;
                pWin2->get_navigator(&pNav);
                if (pNav)
                {
                    IHTMLOpsProfile *pProfile=NULL;
                    pNav->get_userProfile(&pProfile);
                    if (pProfile)
                    {
                        IOpsProfileSimple *pSimple=NULL;
                        pProfile->QueryInterface(IID_IOpsProfileSimple, (void **)&pSimple);
                        if (pSimple)
                        {
                            pSimple->ReadProperties(1, &m_bstrName, &m_pszOpsValue);
                            pSimple->Release();
                        }
                        pProfile->Release();
                    }
                    pNav->Release();
                }
                pWin2->Release();
            }
        }
    }

    return S_OK;
}

void CIntelliForms::CAutoSuggest::CEnumString::UnInit()
{
    EnterCriticalSection(&m_crit);

    m_pIntelliForms = NULL;

    LeaveCriticalSection(&m_crit);
}

HRESULT CIntelliForms::CAutoSuggest::CEnumString::ResetEnum()
{
    EnterCriticalSection(&m_crit);

    if (m_pslMain)
    {
        delete m_pslMain;
        m_pslMain = NULL;
    }

    m_fFilledStrings = FALSE;

    LeaveCriticalSection(&m_crit);

    return S_OK;
}

STDMETHODIMP CIntelliForms::CAutoSuggest::CEnumString::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IEnumString == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IEnumString *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CIntelliForms::CAutoSuggest::CEnumString::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CIntelliForms::CAutoSuggest::CEnumString::Release(void)
{
    if (InterlockedDecrement(&m_cRef) != 0)
    {
        return 1;
    }

    delete this;
    return 0;
}

STDMETHODIMP CIntelliForms::CAutoSuggest::CEnumString::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    EnterCriticalSection(&m_crit);

    if (!m_fFilledStrings)
    {
        FillEnumerator();
    }

    if (m_pslMain)
    {
        int iNewPtr = m_iPtr + celt;

        if (iNewPtr > m_pslMain->NumStrings())
        {
            iNewPtr = m_pslMain->NumStrings();
        }

        *pceltFetched = iNewPtr - m_iPtr;

        LPOLESTR lpstr;

        for (; m_iPtr < iNewPtr; m_iPtr ++)
        {
             m_pslMain->GetTaskAllocString(m_iPtr, &lpstr);

             if (!lpstr) break;

             *(rgelt ++) = lpstr;
        }

        if (m_iPtr < iNewPtr)
        {
            *pceltFetched += (m_iPtr - iNewPtr);
        }
    }

    LeaveCriticalSection(&m_crit);

    if (!m_pslMain)
    {
        return E_FAIL;
    }

    return (*pceltFetched) ? S_OK : S_FALSE;
}

STDMETHODIMP CIntelliForms::CAutoSuggest::CEnumString::Reset()
{
    EnterCriticalSection(&m_crit);

    m_iPtr = 0;

    LeaveCriticalSection(&m_crit);

    return S_OK;
}

HRESULT CIntelliForms::CAutoSuggest::CEnumString::FillEnumerator()
{
    // Already in critical section
    ASSERT(!m_pslMain);

    if (m_fFilledStrings)
    {
        return S_FALSE;
    }

    if (!m_bstrName || !m_bstrName[0] || !m_pIntelliForms)
    {
        return E_FAIL;
    }

    m_fFilledStrings = TRUE;

    m_iPtr = 0;

    // Fill the enumerator based on our name
    TraceMsg(TF_IFORMS, "IForms: Intelliforms filling enumerator");

    // Open any previously saved strings
    if (!m_pIntelliForms->IsRestricted() &&
        IsEnabledInCPL() &&
        m_pIntelliForms->IsEnabledForPage())
    {
        m_pIntelliForms->ReadFromStore(m_bstrName, &m_pslMain);

        // Add in profile assistant value, if any
        if (m_pszOpsValue && m_pszOpsValue[0])
        {
            if (!m_pslMain)
            {
                CStringList_New(&m_pslMain);
            }
            else
            {
                // don't risk a scavenge (perf)
                m_pslMain->SetMaxStrings(CStringList::MAX_STRINGS+4);
            }

            if (m_pslMain)
            {
                m_pslMain->AddString(m_pszOpsValue);
            }
        }
    }

    // Next fill with any usernames that have saved passwords
    CStringList *pslPasswords;

    if (!m_pIntelliForms->IsRestrictedPW() &&
        CIntelliForms::IsEnabledRestorePW() &&
        SUCCEEDED(m_pIntelliForms->GetPasswordStringList(&pslPasswords)))
    {
        ASSERT(!(pslPasswords->NumStrings() & 1));

        FILETIME ft;

        if (pslPasswords->NumStrings() > 0)
        {
            if (!m_pslMain)
            {
                CStringList_New(&m_pslMain);
            }
            else
            {
                // avoid expensive scavenging while adding usernames to string list
                m_pslMain->SetMaxStrings(m_pslMain->GetMaxStrings() + pslPasswords->NumStrings()/2);
            }

            if (m_pslMain)
            {
                for (int i=0; i<pslPasswords->NumStrings(); i+=2)
                {
                    if (SUCCEEDED(pslPasswords->GetStringTime(i, &ft)) &&
                        FILETIME_TO_INT(ft) != 0)
                    {
                        // We have a saved password for this username. Add username to enumerator.
                        m_pslMain->AddString(pslPasswords->GetString(i));
                    }
                }
            }
        }

        // do not delete pslPasswords
    }

    return (m_pslMain) ? ((m_pslMain->NumStrings()) ? S_OK : S_FALSE) : E_FAIL;
}

// Static helper. Pretty basic.
HRESULT CStringList_New(CStringList **ppNew, BOOL fAutoDelete/*=TRUE*/)
{
    *ppNew = new CStringList();

    if (*ppNew)
    {
        (*ppNew)->SetAutoScavenge(fAutoDelete);
    }

    return (*ppNew) ? S_OK : E_OUTOFMEMORY;
}

CStringList::CStringList()
{
    TraceMsg(TF_IFORMS, "IForms: CStringList::CStringList");
    m_fAutoScavenge = TRUE;
    m_dwMaxStrings = MAX_STRINGS;
}

CStringList::~CStringList()
{
    TraceMsg(TF_IFORMS, "IForms: CStringList::~CStringList");
    CleanUp();
}

void CStringList::CleanUp()
{
    if (m_psiIndex)
    {
        LocalFree(m_psiIndex);
        m_psiIndex = NULL;
    }
    if (m_pBuffer)
    {
        LocalFree(m_pBuffer);
        m_pBuffer = NULL;
    }
    m_dwIndexSize = 0;
    m_dwBufEnd = m_dwBufSize = 0;
}

HRESULT CStringList::WriteToBlobs(LPBYTE *ppBlob1, DWORD *pcbBlob1, LPBYTE *ppBlob2, DWORD *pcbBlob2)
{
    HRESULT hr = E_FAIL;
    TraceMsg(TF_IFORMS, "+WriteToBlobs");

    if (SUCCEEDED(Validate()))
    {
        DWORD dwIndexSize;

        dwIndexSize = INDEX_SIZE(m_psiIndex->dwNumStrings);
        ASSERT(dwIndexSize <= m_dwIndexSize);

        *ppBlob1 = (LPBYTE) LocalAlloc(LMEM_FIXED, dwIndexSize);
        if (*ppBlob1)
        {
            *ppBlob2 = (LPBYTE) LocalAlloc(LMEM_FIXED, m_dwBufEnd);

            if (*ppBlob2)
            {
                memcpy(*ppBlob1, m_psiIndex, dwIndexSize);
                *pcbBlob1=dwIndexSize;

                memcpy(*ppBlob2, m_pBuffer, m_dwBufEnd);
                *pcbBlob2=m_dwBufEnd;

                hr = S_OK;
            }
        }
    }
    else
    {
        // Validate failed.
        TraceMsg(TF_ERROR | TF_IFORMS, "Validate FAILED in WriteToBlobs");
        *ppBlob1=NULL;
        *ppBlob2=NULL;
    }

    if (FAILED(hr))
    {
        if (*ppBlob1)
        {
            LocalFree(*ppBlob1);
            *ppBlob1=NULL;
        }
        if (*ppBlob2)
        {
            LocalFree(*ppBlob2);
            *ppBlob2=NULL;
        }
        *pcbBlob1=0;
        *pcbBlob2=0;
    }

    TraceMsg(TF_IFORMS, "-WriteToBlobs");

    return hr;
}

// Take the blobs and use as our buffer
HRESULT CStringList::ReadFromBlobs(LPBYTE *ppBlob1, DWORD cbBlob1, LPBYTE *ppBlob2, DWORD cbBlob2)
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_IFORMS, "+ReadFromBlobs");

    if (m_psiIndex)
    {
        TraceMsg(TF_IFORMS, "IForms: CStringList::ReadFromRegistry called with initialized instance.");
        CleanUp();
    }

    // Allocate our buffers.
    m_psiIndex = (StringIndex *) (*ppBlob1);
    m_pBuffer = (LPBYTE) (*ppBlob2);

    *ppBlob1 = NULL;
    *ppBlob2 = NULL;

    if (!m_psiIndex || !m_pBuffer || !cbBlob1 || !cbBlob2)
    {
        // Nothing to do
        CleanUp();

        return S_FALSE;
    }

    // Validate our string index.
    if ((m_psiIndex->dwSignature == INDEX_SIGNATURE) &&
        (m_psiIndex->cbSize == STRINGINDEX_CBSIZE) &&
        (m_psiIndex->dwNumStrings <= MAX_STRINGS))
    {
        m_dwBufEnd = m_dwBufSize = cbBlob2;
        m_dwIndexSize = cbBlob1;

        if (SUCCEEDED(Validate()))
        {
            // Everything worked. Amazing.
            hr = S_OK;
        }
    }

    if (FAILED(hr))
    {
        // Release buffers if necessary.
        CleanUp();
    }

    TraceMsg(TF_IFORMS, "-ReadFromBlobs");

    return hr;
}

// static
HRESULT CStringList::GetFlagsFromIndex(LPBYTE pBlob1, INT64 *piFlags)
{
    StringIndex *psiIndex = (StringIndex *)pBlob1;

    if ((psiIndex->dwSignature == INDEX_SIGNATURE) &&
        (psiIndex->cbSize == STRINGINDEX_CBSIZE))
    {
        *piFlags = psiIndex->iData;

        return S_OK;
    }

    return E_FAIL;
}

HRESULT CStringList::Validate()
{
    TraceMsg(TF_IFORMS, "+CStringList::Validate");
    if (!m_psiIndex || !m_pBuffer)
    {
        return E_FAIL;
    }

    for (DWORD dw=0; dw < m_psiIndex->dwNumStrings; dw++)
    {
        DWORD dwPtr  = m_psiIndex->StringEntry[dw].dwStringPtr;
        DWORD dwSize = (GetStringLen(dw)+1) * sizeof(WCHAR);

        if (dwPtr + dwSize > m_dwBufSize)
        {
            return E_FAIL;
        }
    }

    TraceMsg(TF_IFORMS, "-CStringList::Validate");
    return S_OK;
}

HRESULT CStringList::Init(DWORD dwBufSize /* =0 */)
{
    DWORD dwMaxStrings=0;
    DWORD dwIndexSize=0;

    if (m_psiIndex)
    {
        TraceMsg(TF_IFORMS, "IForms: CStringList::Init called when already initialized");
        CleanUp();
    }

    if (dwBufSize == 0)
    {
        dwBufSize = INIT_BUF_SIZE;
    }

    dwMaxStrings = dwBufSize >> 5;  // this is relatively arbitrary but doesn't matter much

    if (dwMaxStrings == 0)
        dwMaxStrings = 1;

    dwIndexSize = INDEX_SIZE(dwMaxStrings);

    m_pBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, dwBufSize);
    m_psiIndex = (StringIndex *)LocalAlloc(LMEM_FIXED, dwIndexSize);

    if ((NULL == m_psiIndex) ||
        (NULL == m_pBuffer))
    {
        TraceMsg(TF_IFORMS, "IForms: CStringList::Init memory allocation failed");

        CleanUp();
        return E_OUTOFMEMORY;
    }

    *((WCHAR *)m_pBuffer) = L'\0';

    m_dwBufSize = dwBufSize;
    m_dwBufEnd = 0;

    m_psiIndex->dwSignature = INDEX_SIGNATURE;
    m_psiIndex->cbSize = STRINGINDEX_CBSIZE;
    m_psiIndex->dwNumStrings = 0;
    m_psiIndex->iData = 0;
    m_dwIndexSize = dwIndexSize;

    TraceMsg(TF_IFORMS, "IForms: CStringList::Init succeeded");

    return S_OK;
}

HRESULT CStringList::GetBSTR(int iIndex, BSTR *pbstrRet)
{
    LPCWSTR lpwstr = GetString(iIndex);

    if (!lpwstr)
    {
        *pbstrRet = NULL;
        return E_INVALIDARG;
    }

    *pbstrRet = SysAllocString(lpwstr);

    return (*pbstrRet) ? S_OK : E_OUTOFMEMORY;
}

HRESULT CStringList::GetTaskAllocString(int iIndex, LPOLESTR *pRet)
{
    LPCWSTR lpwstr = GetString(iIndex);

    if (!lpwstr)
    {
        *pRet = NULL;
        return E_INVALIDARG;
    }

    DWORD dwSize = (GetStringLen(iIndex)+1) * sizeof(WCHAR);

    *pRet = (LPOLESTR)CoTaskMemAlloc(dwSize);

    if (!*pRet)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*pRet, lpwstr, dwSize);

    return S_OK;
}

HRESULT CStringList::FindString(LPCWSTR lpwstr, int iLen, int *piNum, BOOL fCaseSensitive)
{
    if (!m_psiIndex) return E_FAIL;

    DWORD dw;

    if (!lpwstr)
    {
        return E_INVALIDARG;
    }

    if (iLen <= 0)
    {
        iLen = lstrlenW(lpwstr);
    }

    if (piNum)
    {
        *piNum = -1;
    }

    for (dw=0; dw<m_psiIndex->dwNumStrings; dw++)
    {
        if (m_psiIndex->StringEntry[dw].dwStringLen == (DWORD)iLen)
        {
            if ((fCaseSensitive && (!StrCmpW(GetString(dw), lpwstr))) ||
                (!fCaseSensitive && (!StrCmpIW(GetString(dw), lpwstr))))
            {
                // Match!
                if (piNum)
                {
                    *piNum = (int) dw;
                }

                return S_OK;
            }
        }
    }

    return E_FAIL;      // Couldn't find it
}

// CStringList is not optimized for deleting
HRESULT CStringList::DeleteString(int iIndex)
{
    TraceMsg(TF_IFORMS, "+DeleteString");
    if (!m_psiIndex)
    {
        return E_FAIL;
    }

    if ((iIndex<0) || ((DWORD)iIndex >= m_psiIndex->dwNumStrings))
    {
        return E_INVALIDARG;
    }

    if ((DWORD)iIndex == (m_psiIndex->dwNumStrings-1))
    {
        // Simple case - deleting last string
        m_dwBufEnd -= (sizeof(WCHAR) * (GetStringLen(iIndex) + 1));
        m_psiIndex->dwNumStrings --;
        return S_OK;
    }

    DWORD cbSizeDeleted;
    LPCWSTR pwszString1, pwszString2;

    pwszString1 = GetString(iIndex);
    pwszString2 = GetString(iIndex+1);

    // Size in bytes of string to be deleted including null terminator
    cbSizeDeleted = (DWORD)((DWORD_PTR)pwszString2 - (DWORD_PTR)pwszString1);

    ASSERT(cbSizeDeleted == (sizeof(WCHAR) * (lstrlenW(GetString(iIndex))+1)));

    // Delete entry in index
    memcpy(&(m_psiIndex->StringEntry[iIndex]), &(m_psiIndex->StringEntry[iIndex+1]),
                STRINGENTRY_SIZE*(m_psiIndex->dwNumStrings - iIndex - 1));
    m_psiIndex->dwNumStrings --;

    // Delete string in buffer
    memcpy((LPWSTR)pwszString1, pwszString2, m_dwBufEnd-(int)PtrDiff(pwszString2, m_pBuffer));
    m_dwBufEnd -= cbSizeDeleted;

    // Fix up pointers in index
    for (int i=iIndex; (DWORD)i < m_psiIndex->dwNumStrings; i++)
    {
        m_psiIndex->StringEntry[i].dwStringPtr -= cbSizeDeleted;
    }
    TraceMsg(TF_IFORMS, "-DeleteString");

    return S_OK;
}

HRESULT CStringList::InsertString(int iIndex, LPCWSTR lpwstr)
{
    TraceMsg(TF_IFORMS, "+InsertString");
    if (!m_psiIndex)
    {
        return E_FAIL;
    }

    if ((iIndex<0) || ((DWORD)iIndex > m_psiIndex->dwNumStrings))
    {
        return E_INVALIDARG;
    }

    if ((DWORD)iIndex == m_psiIndex->dwNumStrings)
    {
        // Simple case - inserting to end
        return _AddString(lpwstr, FALSE, NULL);
    }

    DWORD dwLen = (DWORD)lstrlenW(lpwstr);
    DWORD dwSizeInserted = sizeof(WCHAR) * (dwLen + 1);

    if (FAILED(EnsureBuffer(m_dwBufEnd + dwSizeInserted)) ||
        FAILED(EnsureIndex(m_psiIndex->dwNumStrings + 1)))
    {
        return E_OUTOFMEMORY;
    }


    // Insert into buffer
    LPWSTR pwszBufLoc = GetStringPtr(iIndex);

    memcpy((LPBYTE)pwszBufLoc + dwSizeInserted, pwszBufLoc, m_dwBufEnd - (int) PtrDiff(pwszBufLoc, m_pBuffer));
    memcpy(pwszBufLoc, lpwstr, dwSizeInserted);
    m_dwBufEnd += dwSizeInserted;

    // Insert into index
    memcpy(&(m_psiIndex->StringEntry[iIndex+1]), &(m_psiIndex->StringEntry[iIndex]),
                STRINGENTRY_SIZE*(m_psiIndex->dwNumStrings - iIndex));
    struct StringIndex::tagStringEntry *pse=&(m_psiIndex->StringEntry[iIndex]);
    pse->dwStringPtr = (DWORD)PtrDiff(pwszBufLoc, m_pBuffer);
    pse->ftLastSubmitted.dwLowDateTime = pse->ftLastSubmitted.dwHighDateTime = 0;
    pse->dwStringLen = dwLen;
    m_psiIndex->dwNumStrings ++;

    // Fix up pointers after inserted string
    for (int i=iIndex+1; (DWORD)i<m_psiIndex->dwNumStrings; i++)
    {
        m_psiIndex->StringEntry[i].dwStringPtr += dwSizeInserted;
    }
    TraceMsg(TF_IFORMS, "-InsertString");

    return S_OK;
}

HRESULT CStringList::ReplaceString(int iIndex, LPCWSTR lpwstr)
{
    TraceMsg(TF_IFORMS, "+ReplaceString");
    if (!m_psiIndex)
    {
        return E_FAIL;
    }

    if ((iIndex<0) || ((DWORD)iIndex >= m_psiIndex->dwNumStrings))
    {
        return E_INVALIDARG;
    }

    if ((DWORD)lstrlenW(lpwstr) == m_psiIndex->StringEntry[iIndex].dwStringLen)
    {
        // Simple case - strings equal length
        memcpy( GetStringPtr(iIndex),
                lpwstr,
                 (m_psiIndex->StringEntry[iIndex].dwStringLen)*sizeof(WCHAR));

        return S_OK;
    }

    // Delete old string, then insert new one
    DeleteString(iIndex);

    HRESULT hr = InsertString(iIndex, lpwstr);

    TraceMsg(TF_IFORMS, "-ReplaceString");

    return hr;
}

HRESULT CStringList::AddString(LPCWSTR lpwstr, FILETIME ft, int *piNum /*=NULL*/)
{
    int iNum;
    HRESULT hr;

    TraceMsg(TF_IFORMS, "+AddString");

    hr = _AddString(lpwstr, TRUE, &iNum);

    if (piNum)
    {
        *piNum = iNum;
    }

    if (SUCCEEDED(hr))
    {
        UpdateStringTime(iNum, ft);
    }

    TraceMsg(TF_IFORMS, "-AddString");

    return hr;
}


HRESULT CStringList::AddString(LPCWSTR lpwstr, int *piNum /*=NULL*/)
{
    return _AddString(lpwstr, TRUE, piNum);
}

HRESULT CStringList::AppendString(LPCWSTR lpwstr, int *piNum /*=NULL*/)
{
    return _AddString(lpwstr, FALSE, piNum);
}

HRESULT CStringList::AppendString(LPCWSTR lpwstr, FILETIME ft, int *piNum /*=NULL*/)
{
    int iNum;
    HRESULT hr;

    hr = _AddString(lpwstr, FALSE, &iNum);

    if (piNum)
    {
        *piNum = iNum;
    }

    if (SUCCEEDED(hr))
    {
        SetStringTime(iNum, ft);
    }

    return hr;
}

HRESULT CStringList::_AddString(LPCWSTR lpwstr, BOOL fCheckDuplicates, int *piNum)
{
    DWORD dwSize, dwLen;
    int iNum = -1;
    WCHAR wchBufTruncated[MAX_URL_STRING];
    LPCWSTR lpwstrTruncated=lpwstr;

    TraceMsg(TF_IFORMS, "+_AddString");

    if (piNum)
    {
        *piNum = -1;
    }

    if (!lpwstr)
    {
        return E_INVALIDARG;
    }

    if (!m_psiIndex)
    {
        if (FAILED(Init()))
        {
            return E_FAIL;
        }
    }

    dwLen = (DWORD) lstrlenW(lpwstr);

    // Explicitly truncate strings to MAX_URL characters. If we don't do this, browseui
    //  autocomplete code truncates it anyway and then we have problems removing
    //  duplicates and deleting these long strings. All IntelliForms code can handle
    //  arbitrary length strings.
    if (dwLen >= ARRAYSIZE(wchBufTruncated))
    {
        StrCpyNW(wchBufTruncated, lpwstr, ARRAYSIZE(wchBufTruncated));
        lpwstrTruncated = wchBufTruncated;
        dwLen = lstrlenW(wchBufTruncated);
    }

    dwSize = (dwLen+1)*sizeof(WCHAR);

    if (fCheckDuplicates && SUCCEEDED(FindString(lpwstrTruncated, (int)dwLen, &iNum, FALSE)))
    {
        if (piNum)
        {
            *piNum = iNum;
        }

        if (!StrCmpW(lpwstrTruncated, GetString(iNum)))
        {
            return S_FALSE;             // String is an exact duplicate
        }

        // String is a duplicate but has different case. Replace.
        ASSERT(m_psiIndex->StringEntry[iNum].dwStringLen == dwLen);
        memcpy(GetStringPtr(iNum), lpwstrTruncated, dwSize);

        return S_OK;                    // String was different in case
    }

    if (m_psiIndex->dwNumStrings >= m_dwMaxStrings)
    {
        if (m_fAutoScavenge)
        {
            // Remove the oldest string from our list.
            DWORD dwIndex;
            int iOldest=-1;
            FILETIME ftOldest = { 0xFFFFFFFF, 0x7FFFFFFF };
            for (dwIndex=0; dwIndex<m_psiIndex->dwNumStrings; dwIndex++)
            {
                if ((FILETIME_TO_INT(m_psiIndex->StringEntry[dwIndex].ftLastSubmitted) != 0) &&
                    (1 == CompareFileTime(&ftOldest, &m_psiIndex->StringEntry[dwIndex].ftLastSubmitted)))
                {
                    ftOldest = m_psiIndex->StringEntry[dwIndex].ftLastSubmitted;
                    iOldest = (int)dwIndex;
                }
            }

            if (iOldest != -1)
            {
                DeleteString(iOldest);
            }
            else
            {
                // User must not be setting string times.
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            // Auto-scavenge is disabled.
            return E_OUTOFMEMORY;
        }
    }

    if (FAILED(EnsureBuffer(m_dwBufEnd + dwSize)) ||
        FAILED(EnsureIndex(m_psiIndex->dwNumStrings + 1)))
    {
        return E_OUTOFMEMORY;
    }

    // Our buffers are large enough. Do it.
    if (piNum)
    {
        *piNum = (int) m_psiIndex->dwNumStrings;
    }

    LPWSTR pwszNewString = (LPWSTR)(m_pBuffer + m_dwBufEnd);

    memcpy(pwszNewString, lpwstrTruncated, dwSize);
    m_dwBufEnd += dwSize;

    struct StringIndex::tagStringEntry *pse=&(m_psiIndex->StringEntry[m_psiIndex->dwNumStrings]);
    pse->dwStringPtr = (DWORD)PtrDiff(pwszNewString, m_pBuffer);
    pse->ftLastSubmitted.dwLowDateTime = pse->ftLastSubmitted.dwHighDateTime = 0;
    pse->dwStringLen = dwLen;

    m_psiIndex->dwNumStrings ++;

    TraceMsg(TF_IFORMS, "-_AddString");

    return S_OK;           // We added a new string
}

HRESULT CStringList::EnsureBuffer(DWORD dwSizeNeeded)
{
    TraceMsg(TF_IFORMS, "+EnsureBuffer");

    if (dwSizeNeeded <= m_dwBufSize)
    {
        return S_OK;        // Already big enough
    }

    if (!m_pBuffer)
    {
        return E_FAIL;
    }

    DWORD dwNewBufSize = m_dwBufSize * 2;

    // Grow buffer.
    if (dwSizeNeeded > dwNewBufSize)
    {
        TraceMsg(TF_IFORMS, "IForms: StringList special growing size (big string)");
        dwNewBufSize = dwSizeNeeded;
    }

    TraceMsg(TF_IFORMS, "IForms: CStringList growing");

    LPBYTE pBuf = (LPBYTE)LocalReAlloc(m_pBuffer, dwNewBufSize, LMEM_MOVEABLE);
    if (!pBuf)
    {
        TraceMsg(TF_IFORMS, "IForms: CStringList: ReAlloc failure");
        // Realloc failure: our old memory is still present
        return E_FAIL;
    }

    m_dwBufSize = dwNewBufSize;

    m_pBuffer = pBuf;

    TraceMsg(TF_IFORMS, "-EnsureBuffer");

    // Successfully realloced to bigger buffer
    return S_OK;
}

// grow psiIndex if needed
HRESULT CStringList::EnsureIndex(DWORD dwNumStringsNeeded)
{
    TraceMsg(TF_IFORMS, "+EnsureIndex");

    if (!m_psiIndex)
    {
        return E_FAIL;
    }

    if (INDEX_SIZE(dwNumStringsNeeded) > m_dwIndexSize)
    {
        DWORD dwNewMaxStrings = (m_psiIndex->dwNumStrings) * 2;
        DWORD dwNewIndexSize = INDEX_SIZE(dwNewMaxStrings);

        TraceMsg(TF_IFORMS, "IForms: CStringList growing max strings");

        StringIndex *psiBuf =
            (StringIndex *)LocalReAlloc(m_psiIndex, dwNewIndexSize, LMEM_MOVEABLE);

        if (!psiBuf)
        {
            // Realloc failure: Old memory still present
            TraceMsg(TF_IFORMS, "IForms: CStringList ReAlloc failure");
            return E_OUTOFMEMORY;
        }

        // Success. Don't need to fix any pointers in index (buffer is unchanged)
        m_psiIndex = psiBuf;
        m_dwIndexSize = dwNewIndexSize;
    }

    TraceMsg(TF_IFORMS, "-EnsureIndex");

    return S_OK;
}

// This dlg proc is used for password save, change, delete dialogs
INT_PTR AutoSuggestDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        CenterWindow(hDlg, GetParent(hDlg));

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) lParam);

        if (lParam == IDD_AUTOSUGGEST_SAVEPASSWORD)
        {
            // For "Save" password we default to no. For "Change" and "Delete" we default to yes.
            SetFocus(GetDlgItem(hDlg, IDNO));
            return FALSE;
        }
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDCANCEL:          // close box
            case IDYES:             // yes button
            case IDNO:              // no button
                if (IDD_AUTOSUGGEST_SAVEPASSWORD == GetWindowLongPtr(hDlg, DWLP_USER))
                {
                    // Check the "don't ask me again" checkbox for the save password dlg
                    if (IsDlgButtonChecked(hDlg, IDC_AUTOSUGGEST_NEVER))
                    {
                        SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValAskPasswords,
                                REG_SZ, c_szNo, sizeof(c_szNo));
                    }
                }

                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
        }
        break;

#ifdef CHECKBOX_HELP
    case WM_HELP:
        // Only process WM_HELP for save password dlg
        if (IDD_AUTOSUGGEST_SAVEPASSWORD == GetWindowLong(hDlg, DWL_USER))
        {
            SHWinHelpOnDemandWrap((HWND) ((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) c_aIFormsHelpIds);
        }
        break;

    case WM_CONTEXTMENU:      // right mouse click
        // Only process WM_HELP for save password dlg
        if (IDD_AUTOSUGGEST_SAVEPASSWORD == GetWindowLong(hDlg, DWL_USER))
        {
            SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR) c_aIFormsHelpIds);
        }
        break;
#endif
    }

    return FALSE;
}


//================================================================================

INT_PTR CALLBACK AskUserDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        CenterWindow(hDlg, GetParent(hDlg));
        Animate_OpenEx(GetDlgItem(hDlg, IDD_ANIMATE), HINST_THISDLL, MAKEINTRESOURCE(IDA_AUTOSUGGEST));
        return TRUE;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_AUTOSUGGEST_HELP:
                    SHHtmlHelpOnDemandWrap(GetParent(hDlg), TEXT("iexplore.chm > iedefault"),
                        HH_DISPLAY_TOPIC, (DWORD_PTR) TEXT("autocomp.htm"), ML_CROSSCODEPAGE);
                    break;

                case IDYES:
                case IDNO:
                {
                    LPCTSTR pszData;
                    DWORD  cbData;
                    DWORD  dwData=0;

                    if (LOWORD(wParam) == IDYES)
                    {
                        pszData = c_szYes;
                        cbData = sizeof(c_szYes);
                    }
                    else
                    {
                        pszData = c_szNo;
                        cbData = sizeof(c_szNo);
                    }

                    // Write the enabled state into our CPL regkey
                    SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValUseFormSuggest,
                        REG_SZ, pszData, cbData);

                    // Flag it as "asked user" so we don't ask them again
                    SHSetValue(HKEY_CURRENT_USER, c_szRegKeyIntelliForms, c_szRegValAskUser,
                        REG_DWORD, &dwData, sizeof(dwData));
                }

                // Fall through
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                }
                break;
            }
        }
        return TRUE;

    case WM_DESTROY:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\iformsp.h ===
// IForms.h : Declaration of the CIntelliForms class

#ifndef __IFORMS_H_
#define __IFORMS_H_

#include "iforms.h"

const TCHAR c_szRegKeySMIEM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
const TCHAR c_szRegKeyIntelliForms[] = TEXT("Software\\Microsoft\\Internet Explorer\\IntelliForms");
const WCHAR c_wszRegKeyIntelliFormsSPW[] = TEXT("Software\\Microsoft\\Internet Explorer\\IntelliForms\\SPW");
const TCHAR c_szRegKeyRestrict[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel");

const TCHAR c_szRegValUseFormSuggest[] = TEXT("Use FormSuggest");
const TCHAR c_szRegValFormSuggestRestrict[] = TEXT("FormSuggest");
const TCHAR c_szRegValSavePasswords[] = TEXT("FormSuggest Passwords");
const TCHAR c_szRegValAskPasswords[] = TEXT("FormSuggest PW Ask");
const TCHAR c_szRegValAskUser[] = TEXT("AskUser");

interface IAutoComplete2;
interface IAutoCompleteDropDown;
class CStringList;

#define IF_CHAR             WM_APP  + 0x08
#define IF_KEYDOWN          WM_APP  + 0x09
#define IF_IME_COMPOSITION  WM_APP  + 0x0A

/////////////////////////////////////////////////////////////////////////////
// CIntelliForms
class CEventSinkCallback
{
public:
    typedef enum
    {
        EVENT_BOGUS     = 100,
        EVENT_KEYDOWN   = 0,
        EVENT_KEYPRESS,
        EVENT_MOUSEDOWN,
        EVENT_DBLCLICK,
        EVENT_FOCUS,
        EVENT_BLUR,
        EVENT_SUBMIT,
        EVENT_SCROLL,

        EVENT_COMPOSITION,
        EVENT_NOTIFY,
    }
    EVENTS;

    typedef struct
    {
        EVENTS                      Event;
        LPCWSTR                     pwszEventSubscribe;
        LPCWSTR                     pwszEventName;
    }
    EventSinkEntry;

    virtual HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) = 0;

    static EventSinkEntry EventsToSink[];
};

class CEditEventSinkCallback
{
public:
    virtual HRESULT PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj* pIEventObj) = 0;
};

class CIntelliForms : 
    public CEventSinkCallback,
    public CEditEventSinkCallback
{
    long    m_cRef;

public:
    class CEventSink;
    class CEditEventSink;
    class CAutoSuggest;
    friend CAutoSuggest;

    CIntelliForms();
    ~CIntelliForms();

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


    // CEventSinkCallback
    HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj);

    // CEditEventSinkCallback
    HRESULT PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj* pIEventObj);

public:
    HRESULT Init(CIEFrameAuto::COmWindow *pOmWindow, IHTMLDocument2 *pDoc2, HWND hwnd);
    HRESULT UnInit();

    LPCWSTR GetUrl();

    HRESULT UserInput(IHTMLInputTextElement *pTextEle);

    HRESULT WriteToStore(LPCWSTR pwszName, CStringList *psl);
    HRESULT ReadFromStore(LPCWSTR pwszName, CStringList **ppsl, BOOL fPasswordList=FALSE);
    HRESULT DeleteFromStore(LPCWSTR pwszName);
    HRESULT ClearStore(DWORD dwClear);

    BOOL    IsRestricted() { return m_fRestricted; }
    BOOL    IsRestrictedPW() { return m_fRestrictedPW; }

    IUnknown *GetDocument() { return m_punkDoc2; }

    HRESULT ScriptSubmit(IHTMLFormElement *pForm);
    HRESULT HandleFormSubmit(IHTMLFormElement *pForm);

    // for CEnumString
    HRESULT GetPasswordStringList(CStringList **ppslPasswords);
    // for IntelliFormsSaveForm
    CIntelliForms *GetNext() { return m_pNext; }

    BOOL    IsEnabledForPage();

    static HRESULT GetName(IHTMLInputTextElement *pTextEle, BSTR *pbstrName);

    // Default to disabled, since we need to ask the user before enabling it
    static BOOL    IsEnabledInCPL() {
                        return IsEnabledInRegistry(c_szRegKeySMIEM, c_szRegValUseFormSuggest, FALSE); }
    // Default to enabled, since we prompt before saving passwords anyway
    static BOOL    IsEnabledRestorePW() {
                        return IsEnabledInRegistry(c_szRegKeySMIEM, c_szRegValSavePasswords, TRUE); }
    static BOOL    IsEnabledAskPW() {
                        return IsEnabledRestorePW() &&
                            IsEnabledInRegistry(c_szRegKeySMIEM, c_szRegValAskPasswords, TRUE); }

    static BOOL    IsAdminRestricted(LPCTSTR pszRegVal);

    BOOL AskedUserToEnable();
    
    typedef HRESULT (*PFN_ENUM_CALLBACK)(IDispatch *pDispEle, DWORD_PTR dwCBData);
    HRESULT ActiveElementChanged(IHTMLElement * pHTMLElement);

protected:
    enum { LIST_DATA_PASSWORD = 1 };    // Flag to indicate a password list in store

    HRESULT AddToElementList(IHTMLInputTextElement *pITE);
    HRESULT FindInElementList(IHTMLInputTextElement *pITE);
    void    FreeElementList();

    HRESULT AddToFormList(IHTMLFormElement *pFormEle);
    HRESULT FindInFormList(IHTMLFormElement *pFormEle);
    void    FreeFormList();

    static BOOL IsElementEnabled(IHTMLElement *pEle);
    static HRESULT ShouldAttachToElement(IUnknown *, BOOL fCheckForm, 
                                IHTMLElement2**, IHTMLInputTextElement**, IHTMLFormElement**, BOOL *pfPassword);
    HRESULT GetBodyEle(IHTMLElement2 **ppEle2);

    HRESULT SubmitElement(IHTMLInputTextElement *pITE, FILETIME ft, BOOL fEnabledInCPL);

    LPCWSTR GetUrlHash();
    
    BOOL ArePasswordsSaved();
    BOOL LoadPasswords();
    void SavePasswords();
    HRESULT FindPasswordEntry(LPCWSTR pwszValue, int *piIndex);
    void SetPasswordsAreSaved(BOOL fSaved);
    HRESULT AutoFillPassword(IHTMLInputTextElement *pTextEle, LPCWSTR pwszUsername);
    HRESULT SavePassword(IHTMLFormElement *pFormEle, FILETIME ftSubmit, IHTMLInputTextElement *pFirstEle);
    HRESULT DeletePassword(LPCWSTR pwszUsername);

    HRESULT AttachToForm(IHTMLFormElement *pFormEle);

    HRESULT CreatePStore();
    HRESULT CreatePStoreAndType();
    void ReleasePStore();

    static BOOL IsEnabledInRegistry(LPCTSTR pszKey, LPCTSTR pszValue, BOOL fDefault);

    inline void EnterModalDialog();
    inline void LeaveModalDialog();


private:
    // CIntelliForms member variables
    CEventSink  *m_pSink;
    CEditEventSink *m_pEditSink;
    CAutoSuggest *m_pAutoSuggest;   // Can attach to one edit control at a time

    HINSTANCE   m_hinstPStore;
    IPStore     *m_pPStore;
    BOOL        m_fPStoreTypeInit : 1;  // Our types initialized

    HDPA        m_hdpaElements;         // Elements user has modified
    HDPA        m_hdpaForms;            // Forms we are sinked to

    BOOL        m_fCheckedIfEnabled : 1; // Checked if we're enabled for this page?
    BOOL        m_fEnabledForPage : 1;   // We're enabled for this page (non-SSL)?
    BOOL        m_fHitPWField : 1;      // Went to a password field?
    BOOL        m_fCheckedPW  : 1;      // Checked if we have a password for this URL?
    CStringList *m_pslPasswords;        // Usernames && Passwords for page, if any
    int         m_iRestoredIndex;       // Index of restored password in m_pslPasswords (-1=none)
    BOOL        m_fRestricted : 1;      // Are we restricted for normal Intelliforms?
    BOOL        m_fRestrictedPW : 1;    // Are save passwords restricted?

    // Lifetime management - see Enter/LeaveModalDialog
    BOOL        m_fInModalDialog : 1;   // Are we in a dialog?
    BOOL        m_fUninitCalled : 1;    // Was Uninit called during dialog?

    // Useful stuff for the attached document
    HWND            m_hwndBrowser;
    IHTMLDocument2 *m_pDoc2;
    IUnknown       *m_punkDoc2;
    
    CIEFrameAuto::COmWindow   *m_pOmWindow;

    BSTR        m_bstrFullUrl;          // Full url if https: protocol (security check)
    BSTR        m_bstrUrl;              // Full url with anchor/query string stripped
    LPCWSTR     m_pwszUrlHash;          // String based on UrlHash(m_bstrUrl)

    // Linked list of objects, to find CIntelliForms object for IHTMLDocument2
    CIntelliForms *m_pNext;

public:
    // GUID to use for subtype of PStore - identity GUID or c_PStoreType
    GUID        m_guidUserId;

public:
    // Helper classes
    template <class TYPE> class CEnumCollection
    {
    public:
        static HRESULT EnumCollection(TYPE *pCollection, PFN_ENUM_CALLBACK pfnCB, DWORD_PTR dwCBData);
    };

    // Sinks regular Trident events. Calls back via CEventSinkCallback
    class CEventSink : public IDispatch
    {
        ULONG   m_cRef;

    public:

        CEventSink(CEventSinkCallback *pParent);
        ~CEventSink();

        HRESULT SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);

        void SetParent(CEventSinkCallback *pParent) { m_pParent = pParent; }

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
        STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
            LCID lcid, DISPID *rgDispId);
        STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
            EXCEPINFO *pExcepInfo, UINT *puArgErr);

    private:
        CEventSinkCallback *m_pParent;
    };

    // Sinks editing Trident events. Required for IME events. Callback CEditEventSinkCallback
    class CEditEventSink : public IHTMLEditDesigner
    {
        ULONG   m_cRef;

    public:
        CEditEventSink(CEditEventSinkCallback *pParent);
        ~CEditEventSink();

        HRESULT Attach(IUnknown *punkElement);  // Attach(NULL) to detach
        void SetParent(CEditEventSinkCallback *pParent) { m_pParent = pParent; }

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IHTMLEditDesigner
        STDMETHODIMP PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj *pIEventObj);
        STDMETHODIMP PostHandleEvent(DISPID inEvtDispId, IHTMLEventObj *pIEventObj);
        STDMETHODIMP TranslateAccelerator(DISPID inEvtDispId, IHTMLEventObj *pIEventObj);
        STDMETHODIMP PostEditorEventNotify(DISPID inEvtDispId, IHTMLEventObj *pIEventObj) {return S_FALSE;}

    private:
        CEditEventSinkCallback  *m_pParent;
        IHTMLEditServices       *m_pEditServices;   // we keep a ref so we can unsink
    };

    class CAutoSuggest : public CEventSinkCallback
    {
        class CEnumString;

    public:
        CAutoSuggest(CIntelliForms *pParent, BOOL fEnabled, BOOL fEnabledSPW);
        ~CAutoSuggest();

        void SetParent(CIntelliForms *pParent) { m_pParent = pParent; }

        HRESULT AttachToInput(IHTMLInputTextElement *pTextEle);
        HRESULT DetachFromInput();

        static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        static EVENTS s_EventsToSink[];

    protected:
        // Called by window to perform requests by CAutoComplete to MSHTML
        HRESULT GetText(int cchTextMax, LPWSTR pszTextOut, LRESULT *lcchCopied);
        HRESULT GetTextLength(int *pcch);
        HRESULT SetText(LPCWSTR pszTextIn);

        void CheckAutoFillPassword(LPCWSTR pwszUsername);

        inline void MarkDirty();

    public:
        // Called to pass on events from MSHTML to CAutoComplete
        HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj);
        HRESULT UpdateDropdownPosition();

        IHTMLInputTextElement *AttachedElement() { return m_pTextEle; }
        
    private:
        HRESULT CreateAutoComplete();
        
        HRESULT CleanUp();

        CIntelliForms  *m_pParent;          // No refcount
        CEventSink     *m_pEventSink;
        IAutoComplete2 *m_pAutoComplete;
        IAutoCompleteDropDown *m_pAutoCompleteDD;
        HWND            m_hwndEdit;
        IHTMLInputTextElement *m_pTextEle;
        CEnumString    *m_pEnumString;
        long        m_lCancelKeyPress;

        BOOL        m_fAddedToDirtyList : 1;        // Add to list once they hit a key

        BOOL        m_fAllowAutoFillPW : 1;         // Call AutoFillPassword?
        BSTR        m_bstrLastUsername;             // Last Username we called AutoFillPassword for

        BOOL        m_fInitAutoComplete : 1;        // Initialized Auto Complete?

        BOOL        m_fEnabled : 1;                 // Regular intelliforms enabled?
        BOOL        m_fEnabledPW : 1;               // Restore passwords enabled?

        BOOL        m_fEscapeHit : 1;               // Escape key used to dismiss dropdown?

        UINT        m_uMsgItemActivate;             // registered message from autocomplete
        static BOOL s_fRegisteredWndClass;

        // This object is thread-safed because AutoComplete calls on second thread
        class CEnumString : public IEnumString
        {
            long    m_cRef;

        public:
            CEnumString();
            ~CEnumString();

            HRESULT Init(IHTMLInputTextElement *pInputEle, CIntelliForms *pIForms);
            void UnInit();

            HRESULT ResetEnum();

            STDMETHODIMP QueryInterface(REFIID, void **);
            STDMETHODIMP_(ULONG) AddRef(void);
            STDMETHODIMP_(ULONG) Release(void);

            // IEnumString
            virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
            virtual STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }
            virtual STDMETHODIMP Reset();
            virtual STDMETHODIMP Clone(IEnumString **ppenum) { return E_NOTIMPL; }

        protected:
            HRESULT FillEnumerator();       // called on secondary thread

            CRITICAL_SECTION m_crit;
            CStringList *m_pslMain;
            BSTR    m_bstrName;         // name of input field
            LPWSTR  m_pszOpsValue;      // value from profile assistant
            CIntelliForms *m_pIntelliForms;

            int     m_iPtr;

            BOOL    m_fFilledStrings : 1;
            BOOL    m_fInit : 1;
        };
    };
};

template <class TYPE>
HRESULT CIntelliForms::CEnumCollection<TYPE>::EnumCollection(
            TYPE                   *pCollection,
            PFN_ENUM_CALLBACK       pfnCB,
            DWORD_PTR               dwCBData)
{
    IDispatch       *pDispItem;

    HRESULT hr;
    long    l, lCount;
    VARIANT vIndex, vEmpty;

    VariantInit(&vEmpty);
    VariantInit(&vIndex);

    hr = pCollection->get_length(&lCount);

    if (FAILED(hr))
        lCount = 0;

    for (l=0; l<lCount; l++)
    {
        vIndex.vt = VT_I4;
        vIndex.lVal = l;

        hr = pCollection->item(vIndex, vEmpty, &pDispItem);

        if (SUCCEEDED(hr) && pDispItem)
        {
            hr = pfnCB(pDispItem, dwCBData);

            pDispItem->Release();
        }

        if (E_ABORT == hr)
        {
            break;
        }
    }

    return hr;
}

inline void CIntelliForms::CAutoSuggest::MarkDirty()
{
    if (!m_fAddedToDirtyList && m_pParent)
    {
        m_fAddedToDirtyList = TRUE;
        m_pParent->UserInput(m_pTextEle);
    }
}

// These wrap modal dialogs, keeping us alive and attached to the document
//  even if something weird happens while our dlgbox messageloop is alive
inline void CIntelliForms::EnterModalDialog()
{
    ASSERT(!m_fInModalDialog);  // Don't support nested Enter/Leave
    ASSERT(!m_fUninitCalled);

    m_fInModalDialog = TRUE;    // Keep us attached to document
    
    AddRef();                   // Keep us alive
}

inline void CIntelliForms::LeaveModalDialog()
{
    ASSERT(m_fInModalDialog);

    m_fInModalDialog = FALSE;
    
    if (m_fUninitCalled)
    {
        UnInit();           // Detach from document
    }

    Release();
}

// HKCU/S/MS/Win/CV/IForms/Names  /[name]/ SIndex | SData

// CStringList is optimized for appending arbitrary amounts of strings and converting to and
//  from blobs. It is not optimized for deleting or inserting strings.
class CStringList
{
protected:
    CStringList();

public:
    ~CStringList();

    friend static HRESULT CStringList_New(CStringList **ppNew, BOOL fAutoDelete=TRUE);

    // E_FAIL, S_FALSE (duplicate), S_OK
    HRESULT AddString(LPCWSTR lpwstr, int *piNum = NULL);
    HRESULT AddString(LPCWSTR lpwstr, FILETIME ft, int *piNum = NULL);

    // E_FAIL, S_OK   Doesn't check for duplicates
    HRESULT AppendString(LPCWSTR lpwstr, int *piNum = NULL);
    HRESULT AppendString(LPCWSTR lpwstr, FILETIME ft, int *piNum = NULL);

    // iLen must be length in characters of string, not counting null term.
    // -1 if unknown. *piNum filled in with index if specified
    HRESULT FindString(LPCWSTR lpwstr, int iLen/*=-1*/, int *piNum/*=NULL*/, BOOL fCaseSensitive);

    inline int      NumStrings();
    inline LPCWSTR  GetString(int iIndex);
    inline LPWSTR   GetStringPtr(int iIndex);
    inline DWORD    GetStringLen(int iIndex);
    inline HRESULT  GetStringTime(int iIndex, FILETIME *ft);
    inline HRESULT  SetStringTime(int iIndex, FILETIME ft);
    inline HRESULT  UpdateStringTime(int iIndex, FILETIME ft);
//  inline HRESULT  GetStringData(int iIndex, DWORD *pdwData);
//  inline HRESULT  SetStringData(int iIndex, DWORD dwData);

    HRESULT GetBSTR(int iIndex, BSTR *pbstrRet);
    HRESULT GetTaskAllocString(int iIndex, LPOLESTR *pRet);

    inline HRESULT  GetListData(INT64 *piData);
    inline HRESULT  SetListData(INT64 iData);

    // If set to TRUE, CStringList will delete old strings when full
    void SetAutoScavenge(BOOL fAutoScavenge) { m_fAutoScavenge=fAutoScavenge; }

    HRESULT DeleteString(int iIndex);
    HRESULT InsertString(int iIndex, LPCWSTR lpwstr);
    HRESULT ReplaceString(int iIndex, LPCWSTR lpwstr);

    // Functions to read/write to the store; converts to and from BLOBs
    // For efficiencies sake these take and return heap alloced blobs
    HRESULT WriteToBlobs(LPBYTE *ppBlob1, DWORD *pcbBlob1, LPBYTE *ppBlob2, DWORD *pcbBlob2);
    HRESULT ReadFromBlobs(LPBYTE *ppBlob1, DWORD cbBlob1, LPBYTE *ppBlob2, DWORD cbBlob2);

    static HRESULT GetFlagsFromIndex(LPBYTE pBlob1, INT64 *piFlags);

    // Warning: Don't set max strings past the MAX_STRINGS constant our ReadFromBlobs will fail
    //  if you save/restore the string list
    void SetMaxStrings(DWORD dwMaxStrings) { m_dwMaxStrings = dwMaxStrings; }
    DWORD GetMaxStrings() { return m_dwMaxStrings; }
    
    enum { MAX_STRINGS = 200 };
    
protected:
    enum { INDEX_SIGNATURE=0x4B434957 };        // WICK
    enum { INIT_BUF_SIZE=1024 };

#pragma warning (disable: 4200)     // zero-sized array warning
typedef struct 
{
    DWORD   dwSignature;    // Offset: 00
    DWORD   cbSize;         // Offset: 04 (up to not including first StringEntry)
    DWORD   dwNumStrings;   // Offset: 08 (Num of StringEntry present)
                            // Offset: 0C (--PAD--)
    INT64   iData;          // Offset: 10 (Extra data for string list user)

    struct tagStringEntry
    {
        DWORD       dwStringPtr;        // Offset: 18 (Offset of string in buffer)
        FILETIME    ftLastSubmitted;    // Offset: 1C (filetime of last submit) (unaligned)
        DWORD       dwStringLen;        // Offset: 24 (Length of this string)
    }
    StringEntry[];

} StringIndex;
#pragma warning (default: 4200)

// Value for cbSize in StringIndex
#define STRINGINDEX_CBSIZE PtrToUlong(&((StringIndex*)NULL)->StringEntry)
#define STRINGENTRY_SIZE (PtrToUlong(&((StringIndex*)NULL)->StringEntry[1]) - STRINGINDEX_CBSIZE )
// Size of StringIndex for given number of strings 
#define INDEX_SIZE(n) (STRINGINDEX_CBSIZE + (n)*STRINGENTRY_SIZE)


    void    CleanUp();
    HRESULT Init(DWORD dwBufSize=0);
    HRESULT Validate();

    HRESULT EnsureBuffer(DWORD dwSizeNeeded);
    HRESULT EnsureIndex(DWORD dwNumStringsNeeded);

    HRESULT _AddString(LPCWSTR lpwstr, BOOL fCheckDuplicates, int *piNum);

private:
    StringIndex *m_psiIndex;            // Index of strings
    DWORD   m_dwIndexSize;              // size in bytes of m_psiIndex

    LPBYTE  m_pBuffer;                  // Holds all character data
    DWORD   m_dwBufEnd;                 // Last byte used in buffer
    DWORD   m_dwBufSize;                // Size of buffer in bytes

    DWORD   m_dwMaxStrings;             // Max # strings

    BOOL    m_fAutoScavenge:1;          // Automatically remove old strings when full?
};

// We really only use this for comparing to 0, so this method works just as well and does not require alignment.
#define FILETIME_TO_INT(ft) (ft.dwLowDateTime | ft.dwHighDateTime)

inline int     CStringList::NumStrings()
{
    if (!m_psiIndex) return 0;
    return m_psiIndex->dwNumStrings;
}

inline LPCWSTR CStringList::GetString(int iIndex)
{
    if (!m_psiIndex) return NULL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    return (LPCWSTR) (m_pBuffer + m_psiIndex->StringEntry[iIndex].dwStringPtr);
}

inline LPWSTR CStringList::GetStringPtr(int iIndex)
{
    if (!m_psiIndex) return NULL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    return (LPWSTR) (m_pBuffer + m_psiIndex->StringEntry[iIndex].dwStringPtr);
}

inline DWORD CStringList::GetStringLen(int iIndex)
{ 
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    return m_psiIndex->StringEntry[iIndex].dwStringLen;
}

inline HRESULT CStringList::GetStringTime(int iIndex, FILETIME *ft)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    *ft = m_psiIndex->StringEntry[iIndex].ftLastSubmitted;
    return S_OK;
}

inline HRESULT CStringList::SetStringTime(int iIndex, FILETIME ft)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    ASSERT(-1 != CompareFileTime(&ft, &m_psiIndex->StringEntry[iIndex].ftLastSubmitted));
    m_psiIndex->StringEntry[iIndex].ftLastSubmitted = ft;
    return S_OK;
}

inline HRESULT CStringList::UpdateStringTime(int iIndex, FILETIME ft)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    if (1 == CompareFileTime(&ft, &m_psiIndex->StringEntry[iIndex].ftLastSubmitted))
    {
        m_psiIndex->StringEntry[iIndex].ftLastSubmitted = ft;
        return S_OK;
    }
    return S_FALSE;
}
inline HRESULT CStringList::GetListData(INT64 *piData)
{
    if (m_psiIndex)
    {
        *piData = m_psiIndex->iData;
        return S_OK;
    }
    return E_FAIL;
}
inline HRESULT CStringList::SetListData(INT64 iData)
{
    if (!m_psiIndex && FAILED(Init()))
        return E_FAIL;

    m_psiIndex->iData = iData;
    return S_OK;
}
/*
inline HRESULT CStringList::GetStringData(int iIndex, DWORD *pdwData)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    *pdwData = m_psiIndex->StringEntry[iIndex].dwData;
    return S_OK;
}

inline HRESULT CStringList::SetStringData(int iIndex, DWORD dwData)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    m_psiIndex->StringEntry[iIndex].dwData = dwData;
    return S_OK;
}
*/
#endif //__IFORMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\impexp.cpp ===
//
// IMPEXP.CPP - Browser Import and Export Code
//
// Imports and Exports Favorites in various formats
//
// julianj  2/16/98
//

//
// *** IMPORT FAVORITES CODE ***
//

   /************************************************************\
    FILE: impext.cpp

    DATE: April 1, 1996

    AUTHOR(S):  Bryan Starbuck (bryanst)

    DESCRIPTION:
    This file contains functions that can be used to upgrade
    settings from the Microsoft Internet Explorer v2.0 to v3.0,
    and some features to import Netscape features into Internet
    Explorer.

    This file will handle the logic to convert Netscape
    bookmarks to Microsoft Internet Explorer favorites.  This
    will happen by finding the location of the Netscape bookmarks
    file and the Microsoft Internet Explorer favorites directory
    from the registry.  Then it will parse the bookmarks file to
    extract the URLs, which will finally be added to the favorites
    directory.

    USAGE:
    This code is designed to be called when the user may
    want Netscape bookmarks imported into system level Favorites
    usable by programs such as Internet Explorer.  External
    users should call ImportBookmarks().  If this is done during
    setup, it should be done after setup specifies the Favorites
    registry entry and directory.  If Netscape is not installed,
    then the ImportBookmarks() is just a big no-op.

  NOTE:
    If this file is being compiled into something other
    than infnist.exe, it will be necessary to include the
    following String Resource:

    #define     IDS_NS_BOOKMARKS_DIR    137
    STRINGTABLE DISCARDABLE
    BEGIN
    ...
    IDS_NS_BOOKMARKS_DIR    "\\Imported Bookmarks"
    END


  UPDATES:  I adopted this file to allow IE4.0 having the abilities
    to upgrade from NetScape's setting.  Two CustomActions will be added
    to call in functions in this file. (inateeg)

    8/14/98: added functions to import or export via an URL,
    8/19/98: added UI to allow user to import/export via browser's File 
            menu/"Import and Exporting..."
\************************************************************/
#include "priv.h"
#include "impexp.h"
#include <regstr.h>
#include "resource.h"

#include <mluisupp.h>

//
// Information about the Netscape Bookmark file format that is shared between
// the import and export code
// 

#define BEGIN_DIR_TOKEN         "<DT><H"
#ifdef UNIX
#define MID_DIR_TOKEN0          "3>"
#endif
#define MID_DIR_TOKEN           "\">"
#define END_DIR_TOKEN           "</H"
#define BEGIN_EXITDIR_TOKEN     "</DL><p>"
#define BEGIN_URL_TOKEN         "<DT><A HREF=\""
#define END_URL_TOKEN           "\" A"
#ifdef UNIX
#define END_URL_TOKEN2          "\">"
#endif
#define BEGIN_BOOKMARK_TOKEN    ">"
#define END_BOOKMARK_TOKEN      "</A>"

#define VALIDATION_STR "<!DOCTYPE NETSCAPE-Bookmark-file-"

//
// Use by export code
// 
#define COMMENT_STR "<!-- This is an automatically generated file.\r\nIt will be read and overwritten.\r\nDo Not Edit! -->"
#define TITLE     "<TITLE>Bookmarks</TITLE>\r\n<H1>Bookmarks</H1>"

// ItemType is going to be the type of entry found in the bookmarks
// file.
typedef enum MYENTRYTYPE
{
    ET_OPEN_DIR     = 531,  // New level in heirarchy
    ET_CLOSE_DIR,           // Close level in heirarchy
    ET_BOOKMARK,            // Bookmark entry.
    ET_NONE,                // End of File
    ET_ERROR                // Bail, we encountered an error
} MyEntryType;

//////////////////////////////////////////////////////////////////
//  Internal Functions
//////////////////////////////////////////////////////////////////
BOOL    ImportNetscapeProxy(void);		// Import Netscape Proxy Setting
BOOL    UpdateHomePage(void);			// Upgrade IE v1.0 Home URL to v3.0
BOOL    ImportBookmarks(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd);			//  Import Netscape Bookmarks to IE Favorites
BOOL    ExportFavorites(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd);			//  Export IE Favorites to Netscape Bookmarks
BOOL    RegStrValueEmpty(HKEY hTheKey, char * szPath, char * szKey);
BOOL    GetNSProxyValue(char * szProxyValue, DWORD * pdwSize);

BOOL        VerifyBookmarksFile(HANDLE hFile);
BOOL        ConvertBookmarks(TCHAR * szFavoritesDir, HANDLE hFile);
MyEntryType   NextFileEntry(char ** ppStr, char ** ppToken);
BOOL        GetData(char ** ppData, HANDLE hFile);
void        RemoveInvalidFileNameChars(char * pBuf);
BOOL        CreateDir(char *pDirName);
BOOL        CloseDir(void);
BOOL        CreateBookmark(char *pBookmarkName);
BOOL        GetPathFromRegistry(LPTSTR szPath, UINT cbPath, HKEY theHKEY, LPTSTR szKey, LPTSTR szVName);
BOOL        GetNavBkMkDir( LPTSTR lpszDir, int isize);
BOOL        GetTargetFavoritesPath(LPTSTR szPath, UINT cbPath);

BOOL    PostFavorites(TCHAR *pszPathToBookmarks, TCHAR* pszPathToPost);
void    CALLBACK StatusCallback(HINTERNET hInternet, DWORD_PTR dwContext, DWORD dwStatus,
            LPVOID lpvInfo, DWORD dwInfoLength);

//////////////////////////////////////////////////////////////////
//  TYPES:
//////////////////////////////////////////////////////////////////

//typedef enum MYENTRYTYPE MyEntryType;

//////////////////////////////////////////////////////////////////
//  Constants:
//////////////////////////////////////////////////////////////////
#define MAX_URL 2048
#define FILE_EXT 4          // For ".url" at the end of favorite filenames
#define REASONABLE_NAME_LEN     100


#define ANSIStrStr(p, q) StrStrIA(p, q)
#define ANSIStrChr(p, q) StrChrIA(p, q)

//////////////////////////////////////////////////////////////////
//  GLOBALS:
//////////////////////////////////////////////////////////////////
#ifndef UNIX
TCHAR   * szNetscapeBMRegSub        = TEXT("SOFTWARE\\Netscape\\Netscape Navigator\\Bookmark List");
#else
TCHAR   * szNetscapeBMRegSub        = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\unix\\nsbookmarks");
#endif

TCHAR   * szNetscapeBMRegKey        = TEXT("File Location");
TCHAR   * szIEFavoritesRegSub       = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
TCHAR   * szIEFavoritesRegKey       = TEXT("Favorites");
char    * szInvalidFolderCharacters = "\\/:*?\"<>|";

BOOL    gfValidNetscapeFile = FALSE;
BOOL    gfValidIEDirFile = FALSE;



#define _FAT_   1
#define _HPFS_  0
#define _NTFS_  0
#define _WILD_  0
#define _OFS_   0
#define _OLE_   0

#define AnsiMaxChar     128                 // The array below only indicates the lower 7 bits of the byte.

static UCHAR LocalLegalAnsiCharacterArray[AnsiMaxChar] = {

    0,                                                // 0x00 ^@
                          _OLE_,  // 0x01 ^A
                          _OLE_,  // 0x02 ^B
                          _OLE_,  // 0x03 ^C
                          _OLE_,  // 0x04 ^D
                          _OLE_,  // 0x05 ^E
                          _OLE_,  // 0x06 ^F
                          _OLE_,  // 0x07 ^G
                          _OLE_,  // 0x08 ^H
                          _OLE_,  // 0x09 ^I
                          _OLE_,  // 0x0A ^J
                          _OLE_,  // 0x0B ^K
                          _OLE_,  // 0x0C ^L
                          _OLE_,  // 0x0D ^M
                          _OLE_,  // 0x0E ^N
                          _OLE_,  // 0x0F ^O
                          _OLE_,  // 0x10 ^P
                          _OLE_,  // 0x11 ^Q
                          _OLE_,  // 0x12 ^R
                          _OLE_,  // 0x13 ^S
                          _OLE_,  // 0x14 ^T
                          _OLE_,  // 0x15 ^U
                          _OLE_,  // 0x16 ^V
                          _OLE_,  // 0x17 ^W
                          _OLE_,  // 0x18 ^X
                          _OLE_,  // 0x19 ^Y
                          _OLE_,  // 0x1A ^Z
                          _OLE_,  // 0x1B ESC
                          _OLE_,  // 0x1C FS
                          _OLE_,  // 0x1D GS
                          _OLE_,  // 0x1E RS
                          _OLE_,  // 0x1F US
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x20 space
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_,          // 0x21 !
                  _WILD_,                 // 0x22 "
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x23 #
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x24 $
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x25 %
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x26 &
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x27 '
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x28 (
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x29 )
                  _WILD_,                 // 0x2A *
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2B +
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2C ,
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2D -
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2E .
    0,                                                // 0x2F /
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x30 0
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x31 1
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x32 2
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x33 3
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x34 4
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x35 5
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x36 6
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x37 7
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x38 8
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x39 9
             _NTFS_ |         _OFS_,          // 0x3A :
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x3B ;
                  _WILD_,                 // 0x3C <
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x3D =
                  _WILD_,                 // 0x3E >
                  _WILD_,                 // 0x3F ?
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x40 @
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x41 A
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x42 B
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x43 C
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x44 D
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x45 E
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x46 F
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x47 G
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x48 H
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x49 I
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4A J
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4B K
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4C L
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4D M
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4E N
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4F O
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x50 P
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x51 Q
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x52 R
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x53 S
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x54 T
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x55 U
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x56 V
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x57 W
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x58 X
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x59 Y
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5A Z
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5B [
    0,                                                // 0x5C backslash
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5D ]
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5E ^
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5F _
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x60 `
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x61 a
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x62 b
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x63 c
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x64 d
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x65 e
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x66 f
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x67 g
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x68 h
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x69 i
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6A j
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6B k
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6C l
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6D m
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6E n
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6F o
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x70 p
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x71 q
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x72 r
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x73 s
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x74 t
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x75 u
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x76 v
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x77 w
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x78 x
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x79 y
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7A z
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7B {
                          _OLE_,  // 0x7C |
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7D }
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7E ~
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7F 
};



// Returns the location of the favorites folder in which to import the netscape favorites
BOOL GetTargetFavoritesPath(LPTSTR szPath, UINT cbPath)
{
    if (GetPathFromRegistry(szPath, cbPath, HKEY_CURRENT_USER, szIEFavoritesRegSub, szIEFavoritesRegKey))
    {
        //MLLoadString(IDS_NS_BOOKMARKS_DIR, szSubDir, sizeof(szSubDir))
        //lstrcat(szPath, "\\Imported Netscape Favorites");
        return TRUE;
    }
    return FALSE;
}

///////////////////////////////////////////////////////
//  Import Netscape Bookmarks to Microsoft
//  Internet Explorer's Favorites
///////////////////////////////////////////////////////

/************************************************************\
    FUNCTION: ImportBookmarks

    PARAMETERS:
    HINSTANCE hInstWithStr - Location of String Resources.
    BOOL return - If an error occurs importing the bookmarks, FALSE is returned.

    DESCRIPTION:
    This function will see if it can find a IE Favorite's
    registry entry and a Netscape bookmarks registry entry.  If
    both are found, then the conversion can happen.  It will
    attempt to open the verify that the bookmarks file is
    valid and then convert the entries to favorite entries.
    If an error occures, ImportBookmarks() will return FALSE,
    otherwise it will return TRUE.
\*************************************************************/

BOOL ImportBookmarks(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd)
{
    HANDLE  hBookmarksFile        = INVALID_HANDLE_VALUE;
    BOOL    fSuccess              = FALSE;

    // Prompt the user to insert floppy, format floppy or drive, remount mapped partition,
    // or any create sub directories so pszPathToBookmarks becomes valid.
    if (FAILED(SHPathPrepareForWriteWrap(hwnd, NULL, pszPathToBookmarks, FO_COPY, (SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME))))
        return FALSE;

    if (pszPathToFavorites==NULL || *pszPathToFavorites == TEXT('\0') ||
        pszPathToBookmarks==NULL || *pszPathToBookmarks == TEXT('\0'))
    {
        return FALSE;
    }
    
    hBookmarksFile = CreateFile(pszPathToBookmarks, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    
    if ( hBookmarksFile != INVALID_HANDLE_VALUE ) 
    {
        //
        // Verify it's a valid Bookmarks file
        //
        if (VerifyBookmarksFile( hBookmarksFile ))
        {
            //
            // Do the importing...
            //
            fSuccess = ConvertBookmarks(pszPathToFavorites, hBookmarksFile);

            if (hwnd && !fSuccess)
            {
                MLShellMessageBox(
                    hwnd,
                    MAKEINTRESOURCE(IDS_IMPORTCONVERTERROR),
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV),
                    MB_OK);
            }
        }
        else
        {
            if (hwnd)
            {
                MLShellMessageBox(
                    hwnd,
                    MAKEINTRESOURCE(IDS_NOTVALIDBOOKMARKS),
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV),
                    MB_OK);
            }
        }
        CloseHandle(hBookmarksFile);
    }
    else
    {
        if (hwnd)
        {
            MLShellMessageBox(
                hwnd,
                MAKEINTRESOURCE(IDS_COULDNTOPENBOOKMARKS),
                MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV),
                MB_OK);
        }
    }
    return(fSuccess);
}


/************************************************************\
    FUNCTION: ConvertBookmarks

    PARAMETERS:
    char * szFavoritesDir - String containing the path to
            the IE Favorites directory
    BOOL return - If an error occurs importing the bookmarks, FALSE is returned.

    DESCRIPTION:
    This function will continue in a loop converting each
    entry in the bookmark file.  There are three types of
    entries in the bookmark file, 1) a bookmark, 2) start of
    new level in heirarchy, 3) end of current level in heirarchy.
    The function NextFileEntry() will return these values until
    the file is empty, at which point, this function will end.

    NOTE:
    In order to prevent an infinite loop, it's assumed
    that NextFileEntry() will eventually return ET_NONE or ET_ERROR.
\************************************************************/

BOOL ConvertBookmarks(TCHAR * szFavoritesDir, HANDLE hFile)
{
    BOOL    fDone       = FALSE;
    BOOL    fSuccess    = TRUE;
    BOOL    fIsEmpty    = TRUE;
    char    * szData    = NULL;
    char    * szCurrent = NULL;
    char    * szToken   = NULL;

    fSuccess = GetData(&szData, hFile);
    if (NULL == szData)
        fSuccess = FALSE;

    szCurrent = szData;

    // Verify directory exists or that we can make it.
    if ((TRUE == fSuccess) && ( !SetCurrentDirectory(szFavoritesDir)))
    {
        // If the directory doesn't exist, make it...
        if ( !CreateDirectory(szFavoritesDir, NULL))
            fSuccess = FALSE;
        else
            if (!SetCurrentDirectory(szFavoritesDir))
                fSuccess = FALSE;
    }

   
    while ((FALSE == fDone) && (TRUE == fSuccess))
    {
        switch(NextFileEntry(&szCurrent, &szToken))
        {
            case ET_OPEN_DIR:
                fSuccess = CreateDir(szToken);
                break;
            case ET_CLOSE_DIR:
                fSuccess = CloseDir();
                break;
            case ET_BOOKMARK:
                fSuccess = CreateBookmark(szToken);
                fIsEmpty = FALSE;
                break;
            case ET_ERROR:
                fSuccess = FALSE;
                break;
            case ET_NONE:            
            default:
                fDone = TRUE;
                break;
        }
    }

    if ( fIsEmpty )
    {
        // nothing to import, delete the dir created earlier
        RemoveDirectory(szFavoritesDir);
    }

    if (NULL != szData)
    {
        LocalFree(szData);
        szData = NULL;
        szCurrent = NULL;       // szCurrent no longer points to valid data.
        szToken = NULL;     // szCurrent no longer points to valid data.
    }

    return(fSuccess);
}

/************************************************************\
    FUNCTION: NextFileEntry

    PARAMETERS:
    char ** ppStr   - The data to parse.
    char ** ppToken - The token pointer.
    EntryType return- See below.

    DESCRIPTION:
    This function will look for the next entry in the
    bookmark file to create or act on.  The return value
    will indicate this response:
    ET_OPEN_DIR             Create a new level in heirarchy
    ET_CLOSE_DIR,           Close level in heirarchy
    ET_BOOKMARK,            Create Bookmark entry.
    ET_NONE,                End of File
    ET_ERROR                Error encountered

    Errors will be detected by finding the start of a token,
    but in not finding other parts of the token that are needed
    to parse the data.
\************************************************************/

MyEntryType NextFileEntry(char ** ppStr, char ** ppToken)
{
    MyEntryType   returnVal       = ET_NONE;
    char *      pCurrentToken   = NULL;         // The current token to check if valid.
    char *      pTheToken       = NULL;         // The next valid token.
    char *      pszTemp         = NULL;
#ifdef UNIX
    char        szMidDirToken[8];
#endif

    //ASSERTSZ(NULL != ppStr, "It's an error to pass NULL for ppStr");
    //ASSERTSZ(NULL != *ppStr, "It's an error to pass NULL for *ppStr");
    //ASSERTSZ(NULL != ppToken, "It's an error to pass NULL for ppToken");

    if ((NULL != ppStr) && (NULL != *ppStr) && (NULL != ppToken))
    {
        // Check for begin dir token
        if (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_DIR_TOKEN)))
        {
            // Begin dir token found
            // Verify that other needed tokens exist or it's an error
#ifndef UNIX
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, MID_DIR_TOKEN))) ||
#else
	    if (pCurrentToken[7] == ' ')
	        StrCpyNA(szMidDirToken, MID_DIR_TOKEN, ARRAYSIZE(szMidDirToken));
	    else
	        StrCpyNA(szMidDirToken, MID_DIR_TOKEN0, ARRAYSIZE(szMidDirToken));
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, szMidDirToken))) ||
#endif
                (NULL == ANSIStrStr(pszTemp, END_DIR_TOKEN)))
            {
                returnVal = ET_ERROR;       // We can't find all the tokens needed.
            }
            else
            {
                // This function has to set *ppToken to the name of the directory to create
#ifndef UNIX
                *ppToken =  ANSIStrStr(pCurrentToken, MID_DIR_TOKEN) + sizeof(MID_DIR_TOKEN)-1;
#else
                *ppToken =  ANSIStrStr(pCurrentToken, szMidDirToken) + lstrlenA(szMidDirToken);
#endif
                pTheToken = pCurrentToken;
                returnVal = ET_OPEN_DIR;
            }
        }
        // Check for exit dir token
        if ((ET_ERROR != returnVal) &&
            (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_EXITDIR_TOKEN))))
        {
            // Exit dir token found
            // See if this token comes before TheToken.
            if ((NULL == pTheToken) || (pCurrentToken < pTheToken))
            {
                // ppToken is not used for Exit Dir
                *ppToken = NULL;
                pTheToken = pCurrentToken;
                returnVal = ET_CLOSE_DIR;
            }
        }
        // Check for begin url token
        if ((ET_ERROR != returnVal) &&
            (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_URL_TOKEN))))
        {
            // Bookmark token found
            // Verify that other needed tokens exist or it's an error
#ifndef UNIX
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, END_URL_TOKEN))) ||
#else
            if (((NULL == (pszTemp = ANSIStrStr(pCurrentToken, END_URL_TOKEN))) && 
		 (NULL == (pszTemp = ANSIStrStr(pCurrentToken, END_URL_TOKEN2)))) ||
#endif
                (NULL == (pszTemp = ANSIStrStr(pszTemp, BEGIN_BOOKMARK_TOKEN))) ||
                (NULL == ANSIStrStr(pszTemp, END_BOOKMARK_TOKEN)))
            {
                returnVal = ET_ERROR;       // We can't find all the tokens needed.
            }
            else
            {
                // See if this token comes before TheToken.
                if ((NULL == pTheToken) || (pCurrentToken < pTheToken))
                {
                    // This function has to set *ppToken to the name of the bookmark
                    *ppToken =  pCurrentToken + sizeof(BEGIN_URL_TOKEN)-1;
                    pTheToken = pCurrentToken;
                    returnVal = ET_BOOKMARK;
                }
            }
        }
    }
    else
        returnVal = ET_ERROR;               // We should never get here.

    if (NULL == pTheToken)
        returnVal = ET_NONE;
    else
    {
        // Next time we will start parsing where we left off.
        switch(returnVal)
        {
            case ET_OPEN_DIR:
#ifndef UNIX
                *ppStr = ANSIStrStr(pTheToken, MID_DIR_TOKEN) + sizeof(MID_DIR_TOKEN);
#else
                *ppStr = ANSIStrStr(pTheToken, szMidDirToken) + lstrlenA(szMidDirToken) + 1;
#endif
                break;
            case ET_CLOSE_DIR:
                *ppStr = pTheToken + sizeof(BEGIN_EXITDIR_TOKEN);
                break;
            case ET_BOOKMARK:
                *ppStr = ANSIStrStr(pTheToken, END_BOOKMARK_TOKEN) + sizeof(END_BOOKMARK_TOKEN);
                break;
            default:
                break;
    }
    }

    return(returnVal);
}


/************************************************************\
    FUNCTION: GetPathFromRegistry

    PARAMETERS:
    LPSTR szPath    - The value found in the registry. (Result of function)
    UINT cbPath     - Size of szPath.
    HKEY theHKEY    - The HKEY to look into (HKEY_CURRENT_USER)
    LPSTR szKey     - Path in Registry (Software\...\Explore\Shell Folders)
    LPSTR szVName   - Value to query (Favorites)
    BOOL return     - TRUE if succeeded, FALSE if Error.
    EXAMPLE:
    HKEY_CURRENT_USER\Software\Microsoft\CurrentVersion\Explore\Shell Folders
    Favorites = "C:\WINDOWS\Favorites"

    DESCRIPTION:
    This function will look in the registry for the value
    to look up.  The caller specifies the HKEY, subkey (szKey),
    value to query (szVName).  The caller also sets a side memory
    for the result and passes a pointer to that memory in szPath
    with it's size in cbPath.  The BOOL return value will indicate
    success or failure of this function.
\************************************************************/

BOOL GetPathFromRegistry(LPTSTR szPath, UINT cbPath, HKEY theHKEY,
                LPTSTR szKey, LPTSTR szVName)
{
    DWORD   dwType;
    DWORD   dwSize;

    /*
     * Get Path to program
     *      from the registry
     */
    dwSize = cbPath;
    return (ERROR_SUCCESS == SHGetValue(theHKEY, szKey, szVName, &dwType, (LPBYTE) szPath, &dwSize)
            && (dwType == REG_EXPAND_SZ || dwType == REG_SZ));
}


/************************************************************\
    FUNCTION: RemoveInvalidFileNameChars

    PARAMETERS:
    char * pBuf     - The data to search.

    DESCRIPTION:
    This function will search pBuf until it encounters
    a character that is not allowed in a file name.  It will
    then replace that character with a SPACE and continue looking
    for more invalid chars until they have all been removed.
\************************************************************/

void RemoveInvalidFileNameChars(char * pBuf)
{
    //ASSERTSZ(NULL != pBuf, "Invalid function parameter");

    // Go through the array of chars, replacing offending characters with a space
    if (NULL != pBuf)
    {
    if (REASONABLE_NAME_LEN < strlen(pBuf))
        pBuf[REASONABLE_NAME_LEN] = '\0';   // String too long. Terminate it.

    while ('\0' != *pBuf)
    {
        // Check if the character is invalid
        if (!IsDBCSLeadByte(*pBuf))
        {
        if  (ANSIStrChr(szInvalidFolderCharacters, *pBuf) != NULL)
            *pBuf = '_';
        }
#if 0
// Old code
        // We look in the array to see if the character is supported by FAT.
        // The array only includes the first 128 values, so we need to fail
        // on the other 128 values that have the high bit set.
        if (((AnsiMaxChar <= *pBuf) && (FALSE == IsDBCSLeadByte(*pBuf))) ||
        (0 == LocalLegalAnsiCharacterArray[*pBuf]))
        *pBuf = '$';
#endif
        pBuf = CharNextA(pBuf);
    }
    }
}



/************************************************************\
    FUNCTION: CreateBookmark

    PARAMETERS:
    char * pBookmarkName- This is a pointer that contains
              the name of the bookmark to create.
              Note that it is not NULL terminated.
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will take the data that is passed to
    it and extract the name of the bookmark and it's value to create.
    If the name is too long, it will be truncated.  Then,
    the directory will be created.  Any errors encountered
    will cause the function to return FALSE to indicate
    failure.
\************************************************************/

BOOL CreateBookmark(char *pBookmarkName)
{
    BOOL    fSuccess                = FALSE;
    char    szNameOfBM[REASONABLE_NAME_LEN];
    char    szURL[MAX_URL];
    char    * pstrEndOfStr          = NULL;
    char    * pstrBeginOfName       = NULL;
    long    lStrLen                 = 0;
    HANDLE  hFile                   = NULL;
    DWORD   dwSize;
    char    szBuf[MAX_URL];

    //ASSERTSZ(NULL != pBookmarkName, "Bad input parameter");
    if (NULL != pBookmarkName)
    {

    pstrEndOfStr = ANSIStrStr(pBookmarkName, END_URL_TOKEN);
#ifdef UNIX
    if (!pstrEndOfStr)
        pstrEndOfStr = ANSIStrStr(pBookmarkName, END_URL_TOKEN2);
#endif
    if (NULL != pstrEndOfStr)
    {
        lStrLen = (int) (pstrEndOfStr-pBookmarkName);
        if (MAX_URL < lStrLen)
        lStrLen = MAX_URL-1;

        // Create the name of the Bookmark
        StrCpyNA(szURL, pBookmarkName, ARRAYSIZE(szURL));
        szURL[lStrLen] = '\0';

        // filter out file links, we won't create a bookmark to a file link
        // but remove the link silently and continue
        if (IsFileUrl(szURL))
            return TRUE;

        pstrBeginOfName = ANSIStrStr(pstrEndOfStr, BEGIN_BOOKMARK_TOKEN);
        if (NULL != pstrBeginOfName)
        {
        pstrBeginOfName += sizeof(BEGIN_BOOKMARK_TOKEN) - 1;            // Start at beginning of Name

        pstrEndOfStr = ANSIStrStr(pstrBeginOfName, END_BOOKMARK_TOKEN); // Find end of name
        if (NULL != pstrEndOfStr)
        {
            lStrLen = (int) (pstrEndOfStr-pstrBeginOfName);
            if (REASONABLE_NAME_LEN-FILE_EXT < lStrLen)
            lStrLen = REASONABLE_NAME_LEN-FILE_EXT-1;

            // Generate the URL
            StrCpyNA(szNameOfBM, pstrBeginOfName, lStrLen+1);
            //szNameOfBM[lStrLen] = '\0';
            StrCatBuffA(szNameOfBM, ".url", ARRAYSIZE(szNameOfBM));
            RemoveInvalidFileNameChars(szNameOfBM);

            // Check to see if Favorite w/same name exists
            if (INVALID_HANDLE_VALUE != (hFile = CreateFileA(szNameOfBM, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                                 CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL )))
            {
                WriteFile(hFile, "[InternetShortcut]\n", lstrlenA( "[InternetShortcut]\n" ), &dwSize, NULL);
                wnsprintfA( szBuf, ARRAYSIZE(szBuf), "URL=%s\n", szURL);
                WriteFile(hFile, szBuf, lstrlenA(szBuf), &dwSize, NULL );
                fSuccess = TRUE;
            }
            else
            {
                fSuccess = TRUE;
            }

            if (NULL != hFile)
            {
                CloseHandle( hFile );
                hFile = NULL;
            }

        }
        }
    }
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: CreateDir

    PARAMETERS:
    char * pDirName - This is a pointer that contains
              the name of the directory to create.
              Note that it is not NULL terminated.
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will take the data that is passed to
    it and extract the name of the directory to create.
    If the name is too long, it will be truncated.  Then,
    the directory will be created.  Any errors encountered
    will cause the function to return FALSE to indicate
    failure.
\************************************************************/
BOOL CreateDir(char *pDirName)
{
    BOOL    fSuccess                = FALSE;
    char    szNameOfDir[REASONABLE_NAME_LEN];
    char    * pstrEndOfName         = NULL;
    long    lStrLen                 = 0;

    //ASSERTSZ(NULL != pDirName, "Bad input parameter");
    if (NULL != pDirName)
    {
        pstrEndOfName = ANSIStrStr(pDirName, END_DIR_TOKEN);
        if (NULL != pstrEndOfName)
        {
            lStrLen = (int) (pstrEndOfName-pDirName);
            if (REASONABLE_NAME_LEN < lStrLen)
            lStrLen = REASONABLE_NAME_LEN-1;

            StrCpyNA(szNameOfDir, pDirName, lStrLen+1);
            //szNameOfDir[lStrLen] = '\0';
            RemoveInvalidFileNameChars(szNameOfDir);

            if ( !SetCurrentDirectoryA(szNameOfDir) )
            {
                if ( CreateDirectoryA(szNameOfDir, NULL) )
                {
                    if ( SetCurrentDirectoryA(szNameOfDir) )
                    {
                        fSuccess = TRUE;// It didn't exist, but now it does.
                    }
                }
            }
            else
                fSuccess = TRUE;        // It exists already.
        }
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: CloseDir

    PARAMETERS:
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will back out of the current directory.
\************************************************************/
BOOL CloseDir(void)
{
    return( SetCurrentDirectoryA("..") );
}


/************************************************************\
    FUNCTION: VerifyBookmarksFile

    PARAMETERS:
    FILE * pFile    - Pointer to Netscape Bookmarks file.
    BOOL return     - TRUE if No Error and Valid Bookmark file

    DESCRIPTION:
    This function needs to be passed with a valid pointer
    that points to an open file.  Upon return, the file will
    still be open and is guarenteed to have the file pointer
    point to the beginning of the file.
    This function will return TRUE if the file contains
    text that indicates it's a valid Netscape bookmarks file.
\************************************************************/

BOOL VerifyBookmarksFile(HANDLE hFile)
{
    BOOL    fSuccess            = FALSE;
    char    szFileHeader[sizeof(VALIDATION_STR)+1] = "";
    DWORD   dwSize;

    //ASSERTSZ(NULL != pFile, "You can't pass me a NULL File Pointer");
    if (INVALID_HANDLE_VALUE == hFile)
        return(FALSE);

    // Reading the first part of the file.  If the file isn't this long, then
    // it can't possibly be a Bookmarks file.    
    if ( ReadFile( hFile, szFileHeader, sizeof(VALIDATION_STR)-1, &dwSize, NULL ) && (dwSize == sizeof(VALIDATION_STR)-1) )
    {
#ifndef UNIX
        szFileHeader[sizeof(VALIDATION_STR)] = '\0';            // Terminate String.
#else
        // The above statement doesn;t serve the purpose on UNIX.
        // I think we should change for NT also.
        // IEUNIX : NULL character after the buffer read
        szFileHeader[sizeof(VALIDATION_STR)-1] = '\0';          // Terminate String.
#endif

        if (0 == StrCmpA(szFileHeader, VALIDATION_STR))          // See if header is the same as the Validation string.
            fSuccess = TRUE;
    }

    // Reset the point to point to the beginning of the file.
    dwSize = SetFilePointer( hFile, 0, NULL, FILE_BEGIN );
    if ( dwSize == 0xFFFFFFFF )
         fSuccess = FALSE;

    return(fSuccess);
}



/************************************************************\
    FUNCTION: GetData

    PARAMETERS:
    char ** ppData  - Where to put the data
    FILE * pFile    - Pointer to Netscape Bookmarks file.
    BOOL return     - Return TRUE is successful.

    DESCRIPTION:
    This function will find the size of the bookmarks file,
    malloc that much memory, and put the file's contents in
    that buffer.  ppData will be invalid when the function
    is called and will return with malloced memory that
    needs to be freed by the falling function.
\************************************************************/

BOOL GetData(char ** ppData, HANDLE hFile)
{
    DWORD  dwlength, dwRead;
    BOOL   fSuccess = FALSE;

    //ASSERTSZ(NULL != ppData, "Invalid input parameter");

    if (NULL != ppData)
    {
        *ppData = NULL;

        // Find the size of the data
        if ( dwlength = GetFileSize(hFile, NULL))
        {
            *ppData = (PSTR)LocalAlloc(LPTR, dwlength+1 );
            if (NULL != *ppData)
            {                
                if ( ReadFile( hFile, *ppData, dwlength+1, &dwRead, NULL ) &&
                     ( dwlength == dwRead ) )
                {
                    fSuccess = TRUE;
                }

                (*ppData)[dwlength] = '\0';
            }
        }
    }

    return(fSuccess);
}

//
// AddPath - added by julianj when porting from setup code to stand alone
//
void PASCAL AddPath(LPTSTR pszPath, LPCTSTR pszName, int cchPath )
{
    LPTSTR pszTmp;
    int    cchTmp;

    // Find end of the string
    cchTmp = lstrlen(pszPath);
    pszTmp = pszPath + cchTmp;
    cchTmp = cchPath - cchTmp;

        // If no trailing backslash then add one
    if ( pszTmp > pszPath && *(CharPrev( pszPath, pszTmp )) != FILENAME_SEPARATOR )
    {
        *(pszTmp++) = FILENAME_SEPARATOR;
        cchTmp--;
    }

        // Add new name to existing path string
    while ( *pszName == TEXT(' ') ) pszName++;
    StrCpyN( pszTmp, pszName, cchTmp );
}

//
// GetVersionFromFile - added by julianj when porting from setup code to stand alone
//
BOOL GetVersionFromFile(PTSTR pszFileName, PDWORD pdwMSVer, PDWORD pdwLSVer)
{
    DWORD dwVerInfoSize, dwHandle;
    LPVOID lpVerInfo;
    VS_FIXEDFILEINFO *pvsVSFixedFileInfo;
    UINT uSize;

    HRESULT hr = E_FAIL;

    *pdwMSVer = *pdwLSVer = 0;

    if ((dwVerInfoSize = GetFileVersionInfoSize(pszFileName, &dwHandle)))
    {
        if ((lpVerInfo = (LPVOID) LocalAlloc(LPTR, dwVerInfoSize)) != NULL)
        {
            if (GetFileVersionInfo(pszFileName, dwHandle, dwVerInfoSize, lpVerInfo))
            {
                if (VerQueryValue(lpVerInfo, TEXT("\\"), (LPVOID *) &pvsVSFixedFileInfo, &uSize))
                {
                    *pdwMSVer = pvsVSFixedFileInfo->dwFileVersionMS;
                    *pdwLSVer = pvsVSFixedFileInfo->dwFileVersionLS;
                    hr = S_OK;
                }
            }
            LocalFree(lpVerInfo);
            lpVerInfo = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

BOOL GetNavBkMkDir( LPTSTR lpszDir, int isize)
{
    BOOL    bDirFound = FALSE;
#ifndef UNIX
    TCHAR   szDir[MAX_PATH];
    HKEY    hKey;
    HKEY    hKeyUser;
    TCHAR   szUser[MAX_PATH];
    DWORD   dwSize;

    StrCpyN( szUser, REGSTR_PATH_APPPATHS, ARRAYSIZE(szUser) );
    AddPath( szUser, TEXT("NetScape.exe"), ARRAYSIZE(szUser) );
    if ( GetPathFromRegistry( szDir, MAX_PATH, HKEY_LOCAL_MACHINE, szUser, TEXT("") ) &&
         lstrlen(szDir) )
    {
        DWORD dwMV, dwLV;

        if ( SUCCEEDED(GetVersionFromFile( szDir, &dwMV, &dwLV )) )
        {
            if ( dwMV < 0x00040000 )
                bDirFound = GetPathFromRegistry( lpszDir, isize, HKEY_CURRENT_USER,
                                     szNetscapeBMRegSub, szNetscapeBMRegKey);
            else
            {
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Netscape\\Netscape Navigator\\Users"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(szUser);
                    if (RegQueryValueEx(hKey, TEXT("CurrentUser"), NULL, NULL, (LPBYTE)szUser, &dwSize) == ERROR_SUCCESS)
                    {
                        if (RegOpenKeyEx(hKey, szUser, 0, KEY_READ, &hKeyUser) == ERROR_SUCCESS)
                        {
                            dwSize = sizeof(szDir);
                            if (RegQueryValueEx(hKeyUser, TEXT("DirRoot"), NULL, NULL, (LPBYTE)szDir, &dwSize) == ERROR_SUCCESS)
                            {
                                // Found the directory for the current user.
                                StrCpyN( lpszDir, szDir, isize);
                                AddPath( lpszDir, TEXT("bookmark.htm"), isize );
                                bDirFound = TRUE;
                            }
                            RegCloseKey(hKeyUser);
                        }
                    }
                    RegCloseKey(hKey);
                }
            }
        }
    }
    else
#endif
        bDirFound = GetPathFromRegistry( lpszDir, isize, HKEY_CURRENT_USER,
                                         szNetscapeBMRegSub, szNetscapeBMRegKey);
 
    return bDirFound;
}


//
// *** EXPORT FAVORITES CODE ***
//

// REVIEW REMOVE THESE
#include <windows.h>
//#include <stdio.h>
#include <shlobj.h>
#include <shlwapi.h>

//
// Generate HTML from favorites
//

#define INDENT_AMOUNT 4

int Indent = 0;

HANDLE g_hOutputStream = INVALID_HANDLE_VALUE;
 
void Output(const char *format, ...)
{
    DWORD dwSize;
    char buf[MAX_URL];

    va_list argptr;

    va_start(argptr, format);

    for (int i=0; i<Indent*INDENT_AMOUNT; i++)
    {
        WriteFile(g_hOutputStream, " ", 1, &dwSize, NULL);
    }

    wvnsprintfA(buf, ARRAYSIZE(buf), format, argptr);
    WriteFile(g_hOutputStream, buf, lstrlenA(buf), &dwSize, NULL);
}

void OutputLn(const char *format, ...)
{
    DWORD dwSize;
    char buf[MAX_URL];

    va_list argptr;

    va_start(argptr, format);

    for (int i=0; i<Indent*INDENT_AMOUNT; i++)
    {
        WriteFile(g_hOutputStream, " ", 1, &dwSize, NULL);
    }

    wvnsprintfA(buf, ARRAYSIZE(buf), format, argptr);
    WriteFile(g_hOutputStream, buf, lstrlenA(buf), &dwSize, NULL);
    WriteFile(g_hOutputStream, "\r\n", 2, &dwSize, NULL);
}

#define CREATION_TIME 0
#define ACCESS_TIME   1
#define MODIFY_TIME   2

//
// This nasty looking macro converts a FILETIME structure
// (100-nanosecond intervals since Jan 1st 1601) to a
// unix time_t value (seconds since Jan 1st 1970).
//
// The numbers come from knowledgebase article Q167296
//
#define FILETIME_TO_UNIXTIME(ft) (UINT)((*(LONGLONG*)&ft-116444736000000000)/10000000)

UINT GetUnixFileTime(LPTSTR pszFileName, int mode)
{

    WIN32_FIND_DATA wfd;
    HANDLE hFind;

    hFind = FindFirstFile(pszFileName,&wfd);

    if (hFind == INVALID_HANDLE_VALUE)
        return 0;

    FindClose(hFind);

    switch (mode)
    {

    case CREATION_TIME:
        return FILETIME_TO_UNIXTIME(wfd.ftCreationTime);

    case ACCESS_TIME:
        return FILETIME_TO_UNIXTIME(wfd.ftLastAccessTime);

    case MODIFY_TIME:
        return FILETIME_TO_UNIXTIME(wfd.ftLastWriteTime);

    default:
        ASSERT(0);
        return 0;
        
    }
    
}

void WalkTree(TCHAR * szDir)
{
    WIN32_FIND_DATA findFileData;
    TCHAR buf[MAX_PATH];
    HANDLE hFind;

    Indent++;

    //
    // First iterate through all directories
    //
    wnsprintf(buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("*"), szDir);
    hFind = FindFirstFile(buf, &findFileData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if ((StrCmp(findFileData.cFileName, TEXT(".")) != 0  &&
                     StrCmp(findFileData.cFileName, TEXT("..")) != 0 &&
                     StrCmp(findFileData.cFileName, TEXT("History")) != 0 && // REVIEW just for JJ. Should check for system bit on folders
                     StrCmp(findFileData.cFileName, TEXT("Software Updates")) != 0 && // don't export software updates
                     StrCmp(findFileData.cFileName, TEXT("Channels")) != 0))         // don't export channels for now!
                {
                    char thisFile[MAX_PATH];
                    wnsprintf(buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s"), szDir, findFileData.cFileName);

                    if (!(GetFileAttributes(buf)&FILE_ATTRIBUTE_SYSTEM))
                    {
                        SHTCharToAnsi(findFileData.cFileName, thisFile, MAX_PATH);
                        OutputLn("<DT><H3 FOLDED ADD_DATE=\"%u\">%s</H3>", GetUnixFileTime(buf,CREATION_TIME), thisFile);
                        OutputLn("<DL><p>");
                        WalkTree(buf);
                        OutputLn(BEGIN_EXITDIR_TOKEN);
                    }

                }
                else
                {
                    ; // ignore . and ..
                }
            }
        } while (FindNextFile(hFind, &findFileData));

        FindClose(hFind);
    }

    //
    // Next iterate through all files
    //
    wnsprintf(buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("*"), szDir);
    hFind = FindFirstFile(buf, &findFileData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                wnsprintf(buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s"), szDir, findFileData.cFileName);

                //
                // Read the url from the .url file
                //
                TCHAR szUrl[MAX_PATH];

                SHGetIniString(
                    TEXT("InternetShortcut"),
                    TEXT("URL"),
                    szUrl,       // returns url
                    MAX_PATH,
                    buf);        // full path to .url file

                if (*szUrl != 0)
                {
                    //
                    // create a copy of the filename without the extension
                    // note PathFindExtension returns a ptr to the NULL at 
                    // end if '.' not found so its ok to just blast *pch with 0
                    //
                    TCHAR szFileName[MAX_PATH];
                    StrCpyN(szFileName, findFileData.cFileName, ARRAYSIZE(szFileName));
                    TCHAR *pch = PathFindExtension(szFileName);
                    *pch = TEXT('\0'); // 
                    char  szUrlAnsi[MAX_PATH], szFileNameAnsi[MAX_PATH];
                    SHTCharToAnsi(szUrl, szUrlAnsi, MAX_PATH);
                    SHTCharToAnsi(szFileName, szFileNameAnsi, MAX_PATH);
                    OutputLn("<DT><A HREF=\"%s\" ADD_DATE=\"%u\" LAST_VISIT=\"%u\" LAST_MODIFIED=\"%u\">%s</A>", 
						szUrlAnsi, 
						GetUnixFileTime(buf,CREATION_TIME),
						GetUnixFileTime(buf,ACCESS_TIME),
						GetUnixFileTime(buf,MODIFY_TIME),
						szFileNameAnsi);
                }
            }
        } while (FindNextFile(hFind, &findFileData));

        FindClose(hFind);
    }

    Indent--;
}

BOOL ExportFavorites(TCHAR * pszPathToFavorites, TCHAR * pszPathToBookmarks, HWND hwnd)
{
    // Prompt the user to insert floppy, format floppy or drive, remount mapped partition,
    // or any create sub directories so pszPathToBookmarks becomes valid.
    if (FAILED(SHPathPrepareForWriteWrap(hwnd, NULL, pszPathToBookmarks, FO_COPY, (SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME))))
        return FALSE;

    // Open output file REVIEW redo to use Win32 file apis
    g_hOutputStream = CreateFile(
        pszPathToBookmarks,
        GENERIC_WRITE,
        0, // no sharing,
        NULL, // no security attribs
        CREATE_ALWAYS, // overwrite if present
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (g_hOutputStream == INVALID_HANDLE_VALUE)
        return FALSE;

    //
    // Output bookmark file header stuff
    //
    Output(VALIDATION_STR);
    OutputLn("1>");
    OutputLn(COMMENT_STR);
    OutputLn(TITLE); // REVIEW put/persist users name in Title???

    //
    // Do the walk
    //
    OutputLn("<DL><p>");
    WalkTree(pszPathToFavorites);
    OutputLn(BEGIN_EXITDIR_TOKEN);

    //
    // Close output file handle
    //
    CloseHandle(g_hOutputStream); // REVIEW

    return TRUE;
}

//
// Import/Export User interface dialog routines
//

//
// Standalone app for importing the Netscape Favorites into IE.
//
// julianj 3/9/98
//

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#ifdef _WIN32_WINDOWS
#undef _WIN32_WINDOWS
#endif
#ifdef WINVER
#undef WINVER
#endif
#define _WIN32_WINDOWS      0x0400
#define _WIN32_WINNT        0x0400
#define WINVER              0x0400



TCHAR g_szPathToFavorites[MAX_PATH+1];
TCHAR g_szPathToBookmarks[MAX_PATH+1];
LPITEMIDLIST g_pidlFavorites = NULL;

enum DIALOG_TYPE {FILE_OPEN_DIALOG, FILE_SAVE_DIALOG};

BOOL BrowseForBookmarks(TCHAR *pszPathToBookmarks, int cchPathToBookmarks, HWND hwnd, DIALOG_TYPE dialogType)
{
    TCHAR szFile[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR *pszFileName = PathFindFileName(pszPathToBookmarks);
    TCHAR szDialogTitle[MAX_PATH];
    
    //
    // Now copy the filename into the buffer for use with OpenFile
    // and then copy szDir from path to bookmarks and truncate it at filename 
    // so it contains the initial working directory for the dialog
    //
    StrCpyN(szFile, pszFileName, ARRAYSIZE(szFile));
    StrCpyN(szDir,  pszPathToBookmarks, ARRAYSIZE(szDir));
    szDir[pszFileName-pszPathToBookmarks] = TEXT('\0');

    //
    // Use common dialog code to get path to folder
    //
    TCHAR filter[] = TEXT("HTML File\0*.HTM\0All Files\0*.*\0");
    OPENFILENAME ofn = {0};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = HINST_THISDLL;
    ofn.lpstrFilter = filter;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = szDir;
    ofn.lpstrDefExt = TEXT("htm");

    if (dialogType == FILE_SAVE_DIALOG)
    {
        MLLoadString(IDS_EXPORTDIALOGTITLE, szDialogTitle, ARRAYSIZE(szDialogTitle));

        ofn.lpstrTitle = szDialogTitle;
        ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
        if (GetSaveFileName(&ofn))
        {
            StrCpyN(pszPathToBookmarks, szFile, cchPathToBookmarks);
            return TRUE;
        }
    }
    else
    {
        MLLoadString(IDS_IMPORTDIALOGTITLE, szDialogTitle, ARRAYSIZE(szDialogTitle));

        ofn.lpstrTitle = szDialogTitle;
        ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
        if (GetOpenFileName(&ofn))
        {
            StrCpyN(pszPathToBookmarks, szFile, cchPathToBookmarks);
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT CreateILFromPath(LPCTSTR pszPath, LPITEMIDLIST* ppidl)
{
    // ASSERT(pszPath);
    // ASSERT(ppidl);

    HRESULT hr;

    IShellFolder* pIShellFolder;

    hr = SHGetDesktopFolder(&pIShellFolder);

    if (SUCCEEDED(hr))
    {
        // ASSERT(pIShellFolder);

        WCHAR wszPath[MAX_PATH];

        if (SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath)))
        {
            ULONG ucch;

            hr = pIShellFolder->ParseDisplayName(NULL, NULL, wszPath, &ucch,
                                                 ppidl, NULL);
        }
        else
        {
            hr = E_FAIL;
        }
        pIShellFolder->Release();
    }
    return hr;
}

int CALLBACK BrowseForFavoritesCallBack(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        SendMessage(hwnd, BFFM_SETSELECTIONA, (WPARAM)TRUE, lpData);
        break;

    default:
        break;
    }
    return 0;
}


void BrowseForFavorites(char *pszPathToFavorites, HWND hwnd)
{
    //
    // Use SHBrowseForFolder to get path to folder
    //
    char szDisplayName[MAX_PATH];
    char szTitle[MAX_PATH];

    MLLoadStringA(IDS_IMPORTEXPORTTITLE, szTitle, ARRAYSIZE(szTitle));

    BROWSEINFOA bi = {0};
    bi.hwndOwner = hwnd;
    bi.pidlRoot = g_pidlFavorites;
    bi.pszDisplayName = szDisplayName;
    bi.lpszTitle = szTitle;
    // bi.ulFlags = BIF_EDITBOX; // do we want this?
    bi.ulFlags = BIF_USENEWUI;
    bi.lpfn = BrowseForFavoritesCallBack;
    bi.lParam = (LPARAM)pszPathToFavorites;
    LPITEMIDLIST pidl = SHBrowseForFolderA(&bi);

    if (pidl)
    {
        SHGetPathFromIDListA(pidl, pszPathToFavorites);
        ILFree(pidl);
    };
}

#define REG_STR_IMPEXP          TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define REG_STR_PATHTOFAVORITES TEXT("FavoritesImportFolder")
#define REG_STR_PATHTOBOOKMARKS TEXT("FavoritesExportFile")
#define REG_STR_DESKTOP         TEXT("Desktop")
#define REG_STR_SHELLFOLDERS    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")

#ifndef UNIX
#define STR_BOOKMARK_FILE       TEXT("\\bookmark.htm")
#else
#define STR_BOOKMARK_FILE       TEXT("/bookmark.html")
#endif

//
// InitializePaths
//
void InitializePaths()
{
    //
    // Read the Netscape users bookmark file location and the
    // current users favorite path from registry
    //
    if (!GetNavBkMkDir(g_szPathToBookmarks, MAX_PATH))
    {
        //
        // If Nav isn't installed then use the desktop
        //
        GetPathFromRegistry(g_szPathToBookmarks, MAX_PATH, HKEY_CURRENT_USER,
            REG_STR_SHELLFOLDERS, REG_STR_DESKTOP);
        StrCatBuff(g_szPathToBookmarks, STR_BOOKMARK_FILE, ARRAYSIZE(g_szPathToBookmarks));
    }

    GetTargetFavoritesPath(g_szPathToFavorites, MAX_PATH);
    
    if (FAILED(CreateILFromPath(g_szPathToFavorites, &g_pidlFavorites)))
        g_pidlFavorites = NULL;

    //
    // Now override these values with values stored in the registry just for
    // this tool, so if the user consistently wants to save their favorites
    // out to a separate .HTM file its easy to do
    //
    HKEY hKey;
    DWORD dwSize;
    DWORD dwType;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_STR_IMPEXP, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = MAX_PATH;
        dwType = REG_SZ;
        RegQueryValueEx(hKey, REG_STR_PATHTOBOOKMARKS, 0, &dwType, (LPBYTE)g_szPathToBookmarks, &dwSize);

        dwSize = MAX_PATH;
        dwType = REG_SZ;
        RegQueryValueEx(hKey, REG_STR_PATHTOFAVORITES, 0, &dwType, (LPBYTE)g_szPathToFavorites, &dwSize);

        RegCloseKey(hKey);
    }
}

void PersistPaths()
{
    HKEY hKey;
    DWORD dwDisp;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, REG_STR_IMPEXP, 0, NULL, 0, KEY_WRITE, NULL, &hKey, &dwDisp) == ERROR_SUCCESS)
    {
        RegSetValueEx(hKey, REG_STR_PATHTOBOOKMARKS, 0, REG_SZ, (LPBYTE)g_szPathToBookmarks, (lstrlen(g_szPathToBookmarks)+1)*sizeof(TCHAR));
        RegSetValueEx(hKey, REG_STR_PATHTOFAVORITES, 0, REG_SZ, (LPBYTE)g_szPathToFavorites, (lstrlen(g_szPathToFavorites)+1)*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
}

#define REG_STR_IE_POLICIES          TEXT("Software\\Policies\\Microsoft\\Internet Explorer")
#define REG_STR_IMPEXP_POLICIES      TEXT("DisableImportExportFavorites")

BOOL IsImportExportDisabled(void)
{
    HKEY  hKey;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;
    DWORD value = 0;
    BOOL  bret = FALSE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_STR_IE_POLICIES, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, REG_STR_IMPEXP_POLICIES, 0, &dwType, (PBYTE)&value, &dwSize) == ERROR_SUCCESS &&
                   (dwType == REG_BINARY || dwType == REG_DWORD))
            bret = (value) ? TRUE : FALSE;

        RegCloseKey(hKey);
    }

    return bret;
}

void DoImportOrExport(BOOL fImport, LPCWSTR pwszPath, LPCWSTR pwszImpExpPath, BOOL fConfirm)
{
    BOOL fRemote = FALSE;
    HWND hwnd = NULL;
    TCHAR szImpExpPath[INTERNET_MAX_URL_LENGTH];

    //
    // REVIEW should this be passed in...
    //
    hwnd = GetActiveWindow();

    // Decide if import/export is allowed here
    if (IsImportExportDisabled())
    {
        MLShellMessageBox(
                        hwnd, 
                        (fImport) ? MAKEINTRESOURCE(IDS_IMPORT_DISABLED) :
                                    MAKEINTRESOURCE(IDS_EXPORT_DISABLED),
                        (fImport) ? MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV) :
                                    MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                        MB_OK);
        return;
    }

 
    InitializePaths();

    //
    // Overwrite path to favorites with passed in one if present
    //
    if (pwszPath && *pwszPath != 0)
    {
        SHUnicodeToTChar(pwszPath, g_szPathToFavorites, ARRAYSIZE(g_szPathToFavorites));
    }

    //
    // Decide if we export/import to/from an URL? or a file
    //   (we expect pwszImpExpPath an absolute path)
    // if it's not a valid URL or filename, we give error message and bail out
    //
    if (pwszImpExpPath && *pwszImpExpPath != 0)
    {
        SHUnicodeToTChar(pwszImpExpPath, szImpExpPath, ARRAYSIZE(szImpExpPath));

        if (PathIsURL(pwszImpExpPath))
        {
            
            TCHAR szDialogTitle[MAX_PATH];
            TCHAR szfmt[MAX_PATH], szmsg[MAX_PATH+INTERNET_MAX_URL_LENGTH];
            fRemote = TRUE;
            
            if (fImport)
            {
                if (fConfirm)
                {
                    //
                    // Show confirmation UI when importing over internet
                    //
                    MLLoadShellLangString(IDS_CONFIRM_IMPTTL_FAV, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    MLLoadShellLangString(IDS_CONFIRM_IMPORT, szfmt, ARRAYSIZE(szfmt));
                    wnsprintf(szmsg, ARRAYSIZE(szmsg), szfmt, szImpExpPath);
                    if (MLShellMessageBox(hwnd, szmsg, szDialogTitle,
                                              MB_YESNO | MB_ICONQUESTION) == IDNO)
                        return;
                }
                // download imported file to cache

                if ( (IsGlobalOffline() && !InternetGoOnline(g_szPathToBookmarks,hwnd,0)) ||
                      FAILED(URLDownloadToCacheFile(NULL, szImpExpPath, g_szPathToBookmarks, MAX_PATH, 0, NULL)))
                {
                    MLShellMessageBox(
                        hwnd, 
                        MAKEINTRESOURCE(IDS_IMPORTFAILURE_FAV), 
                        MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV), 
                        MB_OK);
                    return;
                }
            }
            else
            {
                if (fConfirm)
                {
                    //
                    // Show confirmation UI when exporting over internet
                    //
                    MLLoadShellLangString(IDS_CONFIRM_EXPTTL_FAV, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    MLLoadShellLangString(IDS_CONFIRM_EXPORT, szfmt, ARRAYSIZE(szfmt));
                    wnsprintf(szmsg, ARRAYSIZE(szmsg), szfmt, szImpExpPath);
                    if (MLShellMessageBox(hwnd, szmsg, szDialogTitle,
                                              MB_YESNO | MB_ICONQUESTION) == IDNO)
                        return;
                }
                
                //
                // Create bookmark file name from bookmark directory with favorite name so we can export
                // favorites to local file before posting to URL
                //
                TCHAR *pszFav = PathFindFileName(g_szPathToFavorites);
                TCHAR *pszBMD = PathFindFileName(g_szPathToBookmarks);
                if (pszFav && pszBMD)
                {
                    StrCpyN(pszBMD, pszFav, ARRAYSIZE(g_szPathToFavorites) - ((int)(pszFav - g_szPathToFavorites)));
                    StrCatBuff(pszBMD, TEXT(".htm"), ARRAYSIZE(g_szPathToBookmarks) - ((int)(pszFav - g_szPathToBookmarks)));
                }
                
            }
        }
        else
        {

            if (fConfirm)
            {
                TCHAR szDialogTitle[MAX_PATH];
                TCHAR szfmt[MAX_PATH], szmsg[MAX_PATH+INTERNET_MAX_URL_LENGTH];

                if (fImport)
                {
                    //
                    // Show confirmation UI when importing
                    //
                    MLLoadShellLangString(IDS_CONFIRM_IMPTTL_FAV, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    MLLoadShellLangString(IDS_CONFIRM_IMPORT, szfmt, ARRAYSIZE(szfmt));
                    wnsprintf(szmsg, ARRAYSIZE(szmsg), szfmt, szImpExpPath);
                    if (MLShellMessageBox(hwnd, szmsg, szDialogTitle,
                                              MB_YESNO | MB_ICONQUESTION) == IDNO)
                        return;
                }
                else
                {
                    //
                    // Show confirmation UI when exporting.
                    //
                    MLLoadShellLangString(IDS_CONFIRM_EXPTTL_FAV, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    MLLoadShellLangString(IDS_CONFIRM_EXPORT, szfmt, ARRAYSIZE(szfmt));
                    wnsprintf(szmsg, ARRAYSIZE(szmsg), szfmt, szImpExpPath);
                    if (MLShellMessageBox(hwnd, szmsg, szDialogTitle,
                                              MB_YESNO | MB_ICONQUESTION) == IDNO)
                        return;
                }
            }
                
            if (PathFindFileName(szImpExpPath) != szImpExpPath)
            {
            
                //override path to bookmarks with passed in one
                StrCpyN(g_szPathToBookmarks, szImpExpPath, ARRAYSIZE(g_szPathToBookmarks));

            }
            else
            {
                MLShellMessageBox(
                    hwnd, 
                    MAKEINTRESOURCE(IDS_IMPORTFAILURE_FAV), 
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV), 
                    MB_OK);
                return;
            }

        }
    }
    else
    {
        if (fImport)
        {
            //
            // Do Import Favorites UI
            //
            if (!BrowseForBookmarks(g_szPathToBookmarks, ARRAYSIZE(g_szPathToBookmarks), hwnd, FILE_OPEN_DIALOG))
                return;
        }
        else
        {
            //
            // Do Export Favorites UI
            //
            if (!BrowseForBookmarks(g_szPathToBookmarks, ARRAYSIZE(g_szPathToBookmarks), hwnd, FILE_SAVE_DIALOG))
                return;
        }
    }
    
    if (fImport)
    {
        if (ImportBookmarks(g_szPathToFavorites, g_szPathToBookmarks, hwnd))
        {
            MLShellMessageBox(
                            hwnd, 
                            MAKEINTRESOURCE(IDS_IMPORTSUCCESS_FAV), 
                            MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV), 
                            MB_OK);
#ifdef UNIX
	    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH | SHCNF_FLUSH, g_szPathToFavorites, 0);
#endif
            if (!fRemote)
                PersistPaths();
        }
        else
        {
            ; // ImportBookmarks will report errors
        }
    }
    else  
    {
        if (ExportFavorites(g_szPathToFavorites, g_szPathToBookmarks, hwnd))
        {
            if (fRemote)
            {
                if ( (!IsGlobalOffline() || InternetGoOnline(g_szPathToBookmarks,hwnd,0)) &&
                       PostFavorites(g_szPathToBookmarks, szImpExpPath))
                {
                    MLShellMessageBox(
                                hwnd, 
                                MAKEINTRESOURCE(IDS_EXPORTSUCCESS_FAV), 
                                MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                                MB_OK);
                }
                else
                    MLShellMessageBox(
                                hwnd, 
                                MAKEINTRESOURCE(IDS_EXPORTFAILURE_FAV), 
                                MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                                MB_OK);

                //Remove temp file on local disk
                DeleteFile(g_szPathToBookmarks);
            }
            else
            {
                MLShellMessageBox(
                                hwnd, 
                                MAKEINTRESOURCE(IDS_EXPORTSUCCESS_FAV), 
                                MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                                MB_OK);
                PersistPaths();
            }
        }
        else
        {
            MLShellMessageBox(
                            hwnd, 
                            MAKEINTRESOURCE(IDS_EXPORTFAILURE_FAV), 
                            MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                            MB_OK);
        }
    }
}


//
//  *** POST FAVORITES HTML FILE ***
//
HINTERNET g_hInternet = 0;
HINTERNET g_hConnect = 0;
HINTERNET g_hHttpRequest = 0;

HANDLE    g_hEvent = NULL;

typedef struct AsyncRes
{
    DWORD_PTR   Result;
    DWORD_PTR   Error;
} ASYNCRES;

#define STR_USERAGENT          "PostFavorites"

void CloseRequest(void)
{
    if (g_hHttpRequest)
        InternetCloseHandle(g_hHttpRequest);
    if (g_hConnect)
        InternetCloseHandle(g_hConnect);
    if (g_hInternet)
        InternetCloseHandle(g_hInternet);

    g_hInternet = g_hConnect = g_hHttpRequest = 0;

}

HRESULT InitRequest(LPSTR pszPostURL, BOOL bAsync, ASYNCRES *pasyncres)
{
    char    hostName[INTERNET_MAX_HOST_NAME_LENGTH+1];
    char    userName[INTERNET_MAX_USER_NAME_LENGTH+1];
    char    password[INTERNET_MAX_PASSWORD_LENGTH+1];
    char    urlPath[INTERNET_MAX_PATH_LENGTH+1];
    URL_COMPONENTSA     uc;

    memset(&uc, 0, sizeof(URL_COMPONENTS));
    uc.dwStructSize = sizeof(URL_COMPONENTS);
    uc.lpszHostName = hostName;
    uc.dwHostNameLength = sizeof(hostName);
    uc.nPort = INTERNET_INVALID_PORT_NUMBER;
    uc.lpszUserName = userName;
    uc.dwUserNameLength = sizeof(userName);
    uc.lpszPassword = password;
    uc.dwPasswordLength = sizeof(password);
    uc.lpszUrlPath = urlPath;
    uc.dwUrlPathLength = sizeof(urlPath);
    
    if (!InternetCrackUrlA(pszPostURL,lstrlenA(pszPostURL),ICU_DECODE, &uc))
    {
        return E_FAIL;
    }

    if (bAsync)
    {
        // Create an auto-reset event
        g_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if (g_hEvent == NULL)
            bAsync = FALSE;
    }

    g_hInternet = InternetOpenA(STR_USERAGENT,               // used in User-Agent: header 
                            INTERNET_OPEN_TYPE_PRECONFIG,  //INTERNET_OPEN_TYPE_DIRECT, 
                            NULL,
                            NULL, 
                            (bAsync) ? INTERNET_FLAG_ASYNC : 0
                            );

    if ( !g_hInternet )
    {
        return E_FAIL;
    }

    if (bAsync)
    {
        if (INTERNET_INVALID_STATUS_CALLBACK == InternetSetStatusCallbackA(g_hInternet, StatusCallback))
            return E_FAIL;
    }

    // Connect to host
    g_hConnect = InternetConnectA(g_hInternet, 
                                    uc.lpszHostName,
                                    uc.nPort,           //INTERNET_INVALID_PORT_NUMBER,
                                    uc.lpszUserName, 
                                    uc.lpszPassword,
                                    INTERNET_SERVICE_HTTP, 
                                    0,                  //INTERNET_FLAG_KEEP_CONNECTION, 
                                    (bAsync)? (DWORD_PTR) pasyncres : 0); 

    if ( !g_hConnect )
    {
        if (bAsync && GetLastError() == ERROR_IO_PENDING)
        {
            WaitForSingleObject(g_hEvent, INFINITE);
            if (pasyncres->Result == 0)
                return E_FAIL;

            g_hConnect = (HINTERNET)pasyncres->Result;
        }
        else
            return E_FAIL;
    }                                    
    
    // Create request.
    g_hHttpRequest = HttpOpenRequestA
        (
            g_hConnect, 
            "POST", 
            uc.lpszUrlPath,
            HTTP_VERSIONA, 
            NULL,                     //lpszReferer
            NULL,                     //lpszAcceptTypes
            INTERNET_FLAG_RELOAD
            | INTERNET_FLAG_KEEP_CONNECTION
            | SECURITY_INTERNET_MASK, // ignore SSL warnings 
            (bAsync)? (DWORD_PTR) pasyncres : 0);
                            

    if ( !g_hHttpRequest )
    {
        if (bAsync && GetLastError() == ERROR_IO_PENDING)
        {
            WaitForSingleObject(g_hEvent, INFINITE);
            if (pasyncres->Result == 0)
                return E_FAIL;

            g_hHttpRequest = (HINTERNET)pasyncres->Result;
        }
        else
            return E_FAIL;
    }
    
    return S_OK;
    
}                                                                

const char c_szHeaders[] = "Content-Type: application/x-www-form-urlencoded\r\n";
#define c_ccHearders  (ARRAYSIZE(c_szHeaders) - 1)

BOOL AddRequestHeaders
(
    LPCSTR     lpszHeaders,
    DWORD      dwHeadersLength,
    DWORD      dwAddFlag,
    BOOL       bAsync,
    ASYNCRES   *pasyncres
)
{
    BOOL bRet = FALSE;

    bRet = HttpAddRequestHeadersA(g_hHttpRequest, 
                           lpszHeaders, 
                           dwHeadersLength, 
                           HTTP_ADDREQ_FLAG_ADD | dwAddFlag);

    if (bAsync && !bRet && GetLastError() == ERROR_IO_PENDING) 
    {
        WaitForSingleObject(g_hEvent, INFINITE);
        bRet = (BOOL)pasyncres->Result;
    }

    return bRet;
}

HRESULT SendRequest
(
    LPCSTR     lpszHeaders,
    DWORD      dwHeadersLength,
    LPCSTR     lpszOption,
    DWORD      dwOptionLength,
    BOOL       bAsync,
    ASYNCRES   *pasyncres
)
{
    BOOL bRet=FALSE;

    bRet = AddRequestHeaders((LPCSTR)c_szHeaders, (DWORD)-1L, 0, bAsync, pasyncres);

    if (lpszHeaders && *lpszHeaders)        // don't bother if it's empty
    {

        bRet = AddRequestHeaders( 
                          (LPCSTR)lpszHeaders, 
                          dwHeadersLength, 
                          HTTP_ADDREQ_FLAG_REPLACE,
                          bAsync,
                          pasyncres);
        if ( !bRet )
        {
            return E_FAIL;
        }
    }

    pasyncres->Result = 0;

    bRet = HttpSendRequestA(g_hHttpRequest, 
                          NULL,                            //HEADER_ENCTYPE, 
                          0,                               //sizeof(HEADER_ENCTYPE), 
                          (LPVOID)lpszOption, 
                          dwOptionLength);

    if ( !bRet )
    {
        DWORD_PTR dwLastError = GetLastError();
        if (bAsync && dwLastError == ERROR_IO_PENDING)
        {
            WaitForSingleObject(g_hEvent, INFINITE);
            dwLastError = pasyncres->Error;
            bRet = (BOOL)pasyncres->Result;
            if (!bRet)
            {
                TraceMsg(DM_ERROR, "Async HttpSendRequest returned FALSE");
                if (dwLastError != ERROR_SUCCESS)
                {
                    TraceMsg(DM_ERROR, "Async HttpSendRequest failed: Error = %lx", dwLastError);
                    return E_FAIL;
                }
            }

        }
        else
        {
            TraceMsg(DM_ERROR, "HttpSendRequest failed: Error = %lx", dwLastError);
            return E_FAIL;
        }
    }

    //
    //verify request response here
    //
    DWORD dwBuffLen;
    TCHAR buff[10];

    dwBuffLen = sizeof(buff);

    bRet = HttpQueryInfo(g_hHttpRequest,
                        HTTP_QUERY_STATUS_CODE,   //HTTP_QUERY_RAW_HEADERS,
                        buff,
                        &dwBuffLen,
                        NULL);

    int iretcode = StrToInt(buff);
    TraceMsg(DM_TRACE, "HttpQueryInfo returned %d", iretcode);
    return (iretcode == HTTP_STATUS_OK) ? 
        S_OK : E_FAIL;

}                                                                

DWORD ReadFavoritesFile(LPCTSTR lpFile, LPSTR* lplpbuf)
{
    HANDLE  hFile = NULL;
    DWORD   cbFile = 0;
    DWORD   cbRead;

    hFile = CreateFile(lpFile, 
                GENERIC_READ,
                0,                              //no sharing
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (hFile == INVALID_HANDLE_VALUE) 
        return 0;

    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == 0xFFFFFFFF)
    {
        CloseHandle(hFile);
        return 0;
    }
        
    *lplpbuf = (LPSTR)GlobalAlloc(LPTR, (cbFile + 2) * sizeof(CHAR));
    cbRead = 0;
    if (!ReadFile(hFile, *lplpbuf, cbFile, &cbRead, NULL))
    {
        cbRead = 0;
    }    
        
    ASSERT((cbRead == cbFile));
    CloseHandle(hFile);
    return cbRead;
}


BOOL PostFavorites(TCHAR *pszPathToBookmarks, TCHAR* pszPathToPost)
{
    DWORD cbRead = 0;
    LPSTR lpbuf = NULL;
    BOOL  bret = FALSE;
    BOOL  bAsync = TRUE;
    CHAR  szPathToPost[INTERNET_MAX_URL_LENGTH];
    ASYNCRES asyncres = {0, 0};

    cbRead = ReadFavoritesFile(pszPathToBookmarks, &lpbuf);
    if (cbRead == 0)
    {
        if (lpbuf)
        {
            GlobalFree(lpbuf);
            lpbuf = NULL;
        }

        return TRUE;
    }
    SHTCharToAnsi(pszPathToPost, szPathToPost, ARRAYSIZE(szPathToPost));
    if (SUCCEEDED(InitRequest(szPathToPost, bAsync, &asyncres)))
    {
        bret = (SUCCEEDED(SendRequest(NULL, lstrlenA(""), lpbuf, cbRead, bAsync, &asyncres)));
    }

    CloseRequest();

    if (lpbuf)
    {
        GlobalFree( lpbuf );
        lpbuf = NULL;
    }

    return bret;
}

//
// Callback function for Asynchronous HTTP POST request
//
void CALLBACK StatusCallback(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwStatus,
    LPVOID lpvInfo,
    DWORD dwInfoLength
    )
{
    switch (dwStatus)
    {

    case INTERNET_STATUS_REQUEST_COMPLETE:
    {
        ASYNCRES *pasyncres = (ASYNCRES *)dwContext;

        pasyncres->Result = ((LPINTERNET_ASYNC_RESULT)lpvInfo)->dwResult;
        pasyncres->Error = ((LPINTERNET_ASYNC_RESULT)lpvInfo)->dwError;

        SetEvent(g_hEvent);
    }
        break;

    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\impexpwz.h ===
#ifndef _IMPEXPWZ_H
#define _IMPEXPWZ_H

BOOL RunImportExportFavoritesWizard(HWND hDlg);

#endif // _IMPEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\impexp.h ===
/************************************************************\
	FILE: convert.h

	DATE: Apr 1, 1996

	AUTHOR: Bryan Starbuck (bryanst)

	DESCRIPTION:
		This file will handle the logic to convert Netscape
	bookmarks to Microsoft Internet Explorer favorites.  This 
	will happen by finding the location of the Netscape bookmarks
	file and the Microsoft Internet Explorer favorites directory
	from the registry.  Then it will parse the bookmarks file to
	extract the URLs, which will finally be added to the favorites
	directory.

  NOTES:
	This was developed with Netscape 2.0 and IE 2.0.  Future notes
	will be made about compatibility with different versions of
	these browsers.
	
\************************************************************/

#ifndef _IMPEXP_H
#define _IMPEXP_H


//////////////////////////////////////////////////////////////////
//	Exported Functions
//////////////////////////////////////////////////////////////////
BOOL    GetVersionFromFile(PTSTR pszFileName, PDWORD pdwMSVer, PDWORD pdwLSVer);
void    DoImportOrExport(BOOL fImport, LPCWSTR pwszPath, LPCWSTR pwszImpExpDestPath, BOOL fConfirm);

BOOL    ImportBookmarks(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd);			//  Import Netscape Bookmarks to IE Favorites
BOOL    ExportFavorites(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks);			//  Export IE Favorites to Netscape Bookmarks

#ifdef UNIX
BOOL        GetNavBkMkDir( LPTSTR lpszDir, int isize);
BOOL        GetPathFromRegistry(LPTSTR szPath, UINT cbPath, HKEY theHKEY, LPTSTR szKey, LPTSTR szVName);
BOOL        VerifyBookmarksFile(HANDLE hFile);
BOOL    ImportBookmarks(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd);//  Import Netscape Bookmarks to IE Favorites
#endif
#endif // _IMPEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\inetnot.h ===
#ifndef _INETNOT_H
#define _INETNOT_H

//+-------------------------------------------------------------------------
// Wininet currently only support sending notifications of changes to the
// cache to one window.  This class creates one top-level window per process
// for receiving and re-broadcasting these notifications.  When the
// process shuts down, we look for another window to take over these
// messages. 
//
// This is an imperfect solution. It would have been much easier if the
// wininet guys could have been convinced to call SHChangeNotify instead. 
// However, they are planning to enhace this later. (stevepro))
//--------------------------------------------------------------------------
class CWinInetNotify
{
public:
    CWinInetNotify();
    ~CWinInetNotify();

    void Enable(BOOL fEnable = TRUE);

    static void GlobalEnable();
    static void GlobalDisable();

protected:
    void _EnterMutex();
    void _LeaveMutex();

    static void _HookInetNotifications(HWND hwnd);
    static void _OnNotify(DWORD_PTR dwFlags);
    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam);
    enum
    {
        CWM_WININETNOTIFY  = WM_USER + 410
    };

    HANDLE          _hMutex;
    BOOL            _fEnabled;

    static HWND     s_hwnd;
    static ULONG    s_ulEnabled;
    static CWinInetNotify* s_pWinInetNotify;
};

#define CWinInetNotify_szWindowClass TEXT("Inet Notify_Hidden")



#endif //_INETNOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\impexpwz.cpp ===
/*
 * Author: t-franks
 *
 * Last Modified On: Oct 16, 1998
 * Last Modified By: t-joshp
 *
 */

#include "priv.h"
#include "resource.h"
#include "impexp.h"
#include "mluisupp.h"  // for MLLoadString
#include "apithk.h"

//
// Indices into our imagelist
// (used for the open and closed folder icons on the tree view)
//
#define FOLDER_CLOSED 0
#define FOLDER_OPEN   1

#define ImportCookieFile ImportCookieFileW
#define ExportCookieFile ExportCookieFileW

BOOL ImportCookieFileW(IN LPCWSTR szFilename);
BOOL ExportCookieFileW(IN LPCWSTR szFilename, BOOL fAppend);

extern void SetListViewToString (HWND hLV, LPCTSTR pszString);

//
// used to display "file already exists" and "file not found" messages
//
int WarningMessageBox(HWND hwnd, UINT idTitle, UINT idMessage, LPCTSTR szFile, DWORD dwFlags);

//
// Strings that don't need localizing
//

#define NS3_COOKIE_REG_PATH         TEXT("Software\\Netscape\\Netscape Navigator\\Cookies")
#define NS3_COOKIE_REG_KEY          TEXT("Cookie File")

#ifndef UNIX
#define NS3_BOOKMARK_REG_PATH       TEXT("Software\\Netscape\\Netscape Navigator\\Bookmark List")
#else
#define NS3_BOOKMARK_REG_PATH       TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\unix\\nsbookmarks")
#endif

#define NS3_BOOKMARK_REG_KEY        TEXT("File Location")

#define NS4_USERS_REG_PATH          TEXT("Software\\Netscape\\Netscape Navigator\\Users")
#define NS4_USERPATH_REG_KEY        TEXT("DirRoot")

#define NS_FALLBACK_ROOT_REG_KEY    TEXT("Software\\Netscape\\Netscape Navigator")
#define NS_FALLBACK_VERSION_REG_VAL TEXT("CurrentVersion")
#define NS_FALLBACK_MAIN_REG_VAL    TEXT("Main")
#define NS_FALLBACK_INST_REG_VAL    TEXT("Install Directory")

#ifndef UNIX
#define ALL_FILES_WILDCARD          TEXT("\\*.*")
#else
#define ALL_FILES_WILDCARD          TEXT("/*")
#endif

#define DOT_DIR                     TEXT(".")
#define DOT_DOT_DIR                 TEXT("..")

#ifdef UNIX
#define DIR_SEPARATOR_CHAR  TEXT('/')
#else
#define DIR_SEPARATOR_CHAR  TEXT('\\')
#endif

//*************************************************************
//
//      class ListIterator
//
//  Keeps hold on a position in a list.  Allows basic access
//to a list.  The list is set up to map a name to a value.

class NestedList;

class ListIterator
{
    friend NestedList;
    
    struct node
    {
        LPTSTR _sName;
        LPTSTR _sValue;
        DWORD _cNameSize, _cValueSize;
        node* _pnNext;
        node* _pnSublist;
    };

    //  A position is held by pointing to the
    //current node and the pointer that is directed
    //to that node.  The back pointer is kept so the 
    //list can be manipulated at the current element.
    //  when m_pnCurrent == NULL, the iterator is
    //at the end of the list.
    node** m_ppnPrev;
    node* m_pnCurrent;

    //  The invariant could be broken if two iterators
    //point to the same node, and one inserts or deletes
    //an element.  So only one iterator should exist in 
    //a branch of the list at a time.
    BOOL invariant()
    {
        return *m_ppnPrev == m_pnCurrent;
    }

public:
    ListIterator( node** ppnPrev)
    {
        m_ppnPrev = ppnPrev;
        m_pnCurrent = *m_ppnPrev;
    }

    BOOL Insert( LPCTSTR sName, DWORD cNameSize, LPCTSTR sValue, DWORD cValueSize);
    BOOL Remove();

    ListIterator GetSublist();
    void DeleteSublist();

    BOOL Next();
    BOOL AtEndOfList();

    LPCTSTR GetName();
    DWORD GetNameSize();
    LPCTSTR GetValue();
    DWORD GetValueSize();
};


//*************************************************************
//
//  class NestedList
//      Keeps a pointer to a node which heads a list,
//  and deletes that list on destruction.


class NestedList
{
    ListIterator::node* m_pnRoot;
    
public:
    NestedList();
    ~NestedList();

    operator ListIterator();
};


NestedList::NestedList()
: m_pnRoot(NULL)
{
}


NestedList::~NestedList()
{
    while( ((ListIterator)*this).Remove())
    {
    }
}


NestedList::operator ListIterator()
{
    return ListIterator( &m_pnRoot);
}

//*************************************************************
//*************************************************************
//
//  ListIterator functions
//


//  Inserts an element before the current one,
//leaves iterator pointing at new node.
BOOL ListIterator::Insert( 
    LPCTSTR sName, 
    DWORD cNameSize, 
    LPCTSTR sValue, 
    DWORD cValueSize)
{
    ASSERT( invariant());

    node* pNewNode = (node*)(new BYTE[ sizeof(node) 
                                       + (( cNameSize + cValueSize)
                                          * sizeof(TCHAR))]);

    if( pNewNode == NULL)
        return FALSE;

    //  the name and value will be appended to the node.
    pNewNode->_sName = (LPTSTR)((BYTE*)pNewNode + sizeof(node));
    pNewNode->_sValue = pNewNode->_sName + cNameSize;

    pNewNode->_cNameSize = cNameSize;
    pNewNode->_cValueSize = cValueSize;

    memcpy( pNewNode->_sName, sName, pNewNode->_cNameSize * sizeof(TCHAR));
    memcpy( pNewNode->_sValue, sValue, pNewNode->_cValueSize * sizeof(TCHAR));

    // insert new node in list
    pNewNode->_pnNext = m_pnCurrent;
    *m_ppnPrev = pNewNode;

    //  The iterator now points to the new element.
    m_pnCurrent = *m_ppnPrev;
    
    ASSERT( invariant());

    return TRUE;
}


//  Deletes the current node.
//  Returns FALSE if at end of list.
BOOL ListIterator::Remove()
{
    ASSERT( invariant());
    
    //  If this list is empty, or if the iterator 
    //points at the end of the list, there is nothing to
    //delete.
    if( m_pnCurrent == NULL)
        return FALSE;

    // remove sublist
    DeleteSublist();
    
    //  Remember where target node is
    //so it can be deleted once out of
    //the list.
    node* pOldNode = m_pnCurrent;

    // take the target node out of the list.
    //(iterator points to next node or end of list)
    *m_ppnPrev = m_pnCurrent->_pnNext;
    m_pnCurrent = *m_ppnPrev;

    //  Get rid of target node.
    delete [] (BYTE*)pOldNode;

    ASSERT( invariant());

    return TRUE;    
}


//  Returns the sublist of the current node.
ListIterator ListIterator::GetSublist()
{
    ASSERT( invariant());
    
    return ListIterator( &(m_pnCurrent->_pnSublist));
}


//  deletes the children of the current node.
void ListIterator::DeleteSublist()
{
    ASSERT( invariant());
    
    ListIterator sublist( &(m_pnCurrent->_pnSublist));
    
    while( sublist.Remove())
    {
    }

    ASSERT( invariant());
}


//  Advances to the next node.
//  Returns FALSE if already at end of list.
BOOL ListIterator::Next()
{
    ASSERT( invariant());

    if( m_pnCurrent == NULL)
        return FALSE;

    m_ppnPrev = &(m_pnCurrent->_pnNext);
    m_pnCurrent = *m_ppnPrev;

    ASSERT( invariant());

    return m_pnCurrent != NULL;
}


//  
BOOL ListIterator::AtEndOfList()
{
    return ( m_pnCurrent == NULL) ? TRUE : FALSE;
};


//
LPCTSTR ListIterator::GetName()
{
    ASSERT( invariant() && m_pnCurrent != NULL);

    return m_pnCurrent->_sName;
}


//
DWORD ListIterator::GetNameSize()
{
    ASSERT( invariant() && m_pnCurrent != NULL);

    return m_pnCurrent->_cNameSize;
}


//
LPCTSTR ListIterator::GetValue()
{
    ASSERT( invariant() && m_pnCurrent != NULL);

    return m_pnCurrent->_sValue;
}


//
DWORD ListIterator::GetValueSize()
{
    ASSERT( invariant() && m_pnCurrent != NULL);

    return m_pnCurrent->_cValueSize;
}


//*************************************************************
//*************************************************************
//
//  class ImpExpUserProcess
//
//      maintains the description of an import/export process
//  for an import/export wizard, and finally executes the
//  the import/export.

enum ExternalType { INVALID_EXTERNAL = 0, COOKIES, BOOKMARKS};
enum TransferType { INVALID_TRANSFER = 0, IMPORT, EXPORT};

class ImpExpUserProcess
{
public:
    ImpExpUserProcess();
    ~ImpExpUserProcess();
    
    //  the first step the wizard should do is identify the type of
    //import/export process to be done.
    void SelectExternalType( ExternalType selection)    { m_ExternalType = selection; }
    void SelectTransferType( TransferType selection)    { m_TransferType = selection; }
    ExternalType GetExternalType()                      { return m_ExternalType; }
    TransferType GetTransferType()                      { return m_TransferType; }

    BOOL PopulateComboBoxForExternalSelection( HWND hComboBox);
    BOOL GetExternalManualDefault( LPTSTR sExternal, DWORD* pcSize);

    //
    // used to fill the listbox with names of netscape profiles
    //
    void purgeExternalList();
    BOOL populateExternalList();
    BOOL populateExternalListForCookiesOrBookmarks();

    //
    // for netscape 3.x
    //
    BOOL populateExternalListForCookiesOrBookmarksWithNS3Entry();

    //
    // for netscape 4.x
    //
    BOOL populateExternalListForCookiesOrBookmarksWithNS4Entries();

    //
    // fallback case for "funny" versions of netscape
    //
    BOOL populateExternalListFromFolders(LPTSTR pszPath);
    BOOL populateExternalListWithNSEntriesFallBack();

    //  If the transfer is for favorites, the wizard needs to specify
    //an internal folder to import to or export from.
    LPCTSTR GetInternalSelection()       { return m_pSelectedInternal; }

    BOOL PopulateTreeViewForInternalSelection( HWND TreeView);
    BOOL populateTreeViewWithInternalList( HWND hTreeView, ListIterator iterator, HTREEITEM hParent);
    BOOL ExpandTreeViewRoot ( HWND hTreeView ) ;

    BOOL SelectInternalSelection( HWND TreeView);

    void purgeInternalList();
    BOOL populateInternalList();
    BOOL populateInternalListForBookmarks();
    BOOL appendSubdirsToInternalList( LPTSTR sPath, ListIterator iterator);
    
    //  And then, the import/export can be completed.
    void PerformImpExpProcess(HWND hwnd);

    //
    // The filename that we're exporting to or 
    // importing from.
    //
    TCHAR m_szFileName[MAX_PATH];

private:
    ExternalType m_ExternalType;
    TransferType m_TransferType;

    //  m_ExternalList is a flat list of names associated with files
    //example: name =  "Netscape 4.0 profile - Dr. Falken"
    //         value =  "c:\netscapeprofiledir\DrFalken.chs"
    NestedList m_ExternalList;

    //  m_InternalList is a nested list favorites' pathnames,
    //associated with the complete path.
    NestedList m_InternalList;

    //  Maintain synchronization between m_ExternalType/m_TransferType 
    //and m_InternalList
    ExternalType m_InternalListExternalType;
    TransferType m_InternalListTransferType;

    // if ExternalType == BOOKMARKS,
    //m_pSelectedInternal is the path of a Favorites folder,
    //residing in m_InternalList somewhere, or NULL if a folder
    //hasn't been selected yet.
    LPTSTR m_pSelectedInternal;

};


ImpExpUserProcess::ImpExpUserProcess()
:   m_ExternalType(INVALID_EXTERNAL), m_TransferType(INVALID_TRANSFER),
    m_InternalListExternalType(INVALID_EXTERNAL), m_InternalListTransferType(INVALID_TRANSFER),
    m_pSelectedInternal(0)
{
}


ImpExpUserProcess::~ImpExpUserProcess()
{
}


//*************************************************************
//   PopulateComboBoxForExternal
//
//  Loads content for list box into memory and into List Box,
//associating value of each element with the list element.

//  returns FALSE if the list box is left empty
BOOL ImpExpUserProcess::PopulateComboBoxForExternalSelection( HWND hComboBox)
{
    ASSERT ( m_ExternalType != INVALID_EXTERNAL ) ;

    ComboBox_ResetContent(hComboBox);
   
    //  If ExternalList is invalid, the list box will be left empty.
    if( !populateExternalList() )
        return FALSE;

    ListIterator iterator = m_ExternalList;

    //  Detect and notify if the list is empty.
    if( iterator.AtEndOfList() )
        return FALSE;

    //  add entries from the new ExternalList to the ComboBox.
    do
    {
        int index = ComboBox_AddString( hComboBox, const_cast<LPTSTR>(iterator.GetName() ) );
        ComboBox_SetItemData( hComboBox, index, const_cast<LPTSTR>(iterator.GetValue() ) );
    } while( iterator.Next());

    // set the first one as selected
    ComboBox_SetCurSel( hComboBox, 0 );

    return TRUE;
}


//*************************************************************
//
//  GetExternalManualDefault
//
//  Allows user interface to offer some sort of default
//  filename/location.
//
BOOL ImpExpUserProcess::GetExternalManualDefault(LPTSTR sExternal, DWORD* pcSize)
{
    ASSERT(NULL != pcSize);

    //
    // We only fill it in if it's blank
    //
    if (m_szFileName[0])
    {
        return FALSE;
    }

    ListIterator iterator = m_ExternalList;

    TCHAR szFileName[MAX_PATH];
    INT cchFileName;
    if(m_ExternalType == BOOKMARKS)
        MLLoadString(IDS_NETSCAPE_BOOKMARK_FILE,szFileName,ARRAYSIZE(szFileName));
    else
        MLLoadString(IDS_NETSCAPE_COOKIE_FILE,szFileName,ARRAYSIZE(szFileName));
    cchFileName = lstrlen(szFileName) + 1;

    //  Grab the first item in the External List and use its value.
    if( ((ListIterator)m_ExternalList).AtEndOfList() == FALSE
        && ((ListIterator)m_ExternalList).GetValue() != NULL
        && *pcSize >= ((ListIterator)m_ExternalList).GetValueSize())
    {
        StrCpyN( sExternal,
                 ((ListIterator)m_ExternalList).GetValue(),
                 ((ListIterator)m_ExternalList).GetValueSize());
        *pcSize = ((ListIterator)m_ExternalList).GetValueSize();

        return TRUE;
    }
    //  If there is enough room, specify some file with the correct name
    //  in the "my documents" directory.
    else 
    {
        ASSERT(m_ExternalType == BOOKMARKS || m_ExternalType == COOKIES);
        
        TCHAR szMyDocsPath[MAX_PATH];

        SHGetSpecialFolderPath(NULL,szMyDocsPath,CSIDL_PERSONAL,TRUE);

        *pcSize = wnsprintf(sExternal,MAX_PATH,TEXT("%s%c%s"),szMyDocsPath,DIR_SEPARATOR_CHAR,szFileName);

        return *pcSize > 0;
    }
}


//*************************************************************
//
//
//  purgeExternalList
//
//  Used to clear external target/source list loaded into memory

void ImpExpUserProcess::purgeExternalList()
{
    // delete elements until they're all gone.
    ListIterator iterator = m_ExternalList;

    while( iterator.Remove())
    {
    }

}


//*************************************************************
//
//  populeExternalList
//
//  Used to load external target/source list into memory

BOOL ImpExpUserProcess::populateExternalList()
{
    ASSERT(m_ExternalType != INVALID_EXTERNAL)

    purgeExternalList();

    if(!populateExternalListForCookiesOrBookmarks())
    {
        //
        // If we didn't get any entries using the "standard"
        // techniques, then (and only then) we try the "fallback"
        //
        if (!populateExternalListWithNSEntriesFallBack())
        {
            purgeExternalList();
            return FALSE;
        }

    }

    return TRUE;
}


//*************************************************************
//
//  populateExternalListforCookiesOrBookmarks
//
//  Used to lod external target/source list into memory
//in the case that the content to be transfered is cookies
//or bookmarks.

//  returns TRUE if any elements have been added to the external list
BOOL ImpExpUserProcess::populateExternalListForCookiesOrBookmarks()
{
    ASSERT( m_ExternalType == COOKIES || m_ExternalType == BOOKMARKS);

    BOOL fHasAddedElements = FALSE;

    if( populateExternalListForCookiesOrBookmarksWithNS3Entry())
        fHasAddedElements = TRUE;

    if( populateExternalListForCookiesOrBookmarksWithNS4Entries())
        fHasAddedElements = TRUE;
 
    return fHasAddedElements;
}


//*************************************************************
//
//  populateExternalList..WithNS3Entry
//
//  subfunc of populateExternalListForCookiesOrBookmarks.

//  returns TRUE if any elements have been added to the external list
BOOL ImpExpUserProcess::populateExternalListForCookiesOrBookmarksWithNS3Entry()
{
    BOOL retVal = FALSE;

    //  Determine where to look for reg key
    LPTSTR sNS3RegPath;
    LPTSTR sNS3RegKey;

    if( m_ExternalType == BOOKMARKS)
    {
        sNS3RegPath = NS3_BOOKMARK_REG_PATH;
        sNS3RegKey = NS3_BOOKMARK_REG_KEY;
    }
    else
    {
        sNS3RegPath = NS3_COOKIE_REG_PATH;
        sNS3RegKey = NS3_COOKIE_REG_KEY;
    }

    //  Get the file location and add it to the list
    //  The registry location has the complete path + filename.
    TCHAR sFilePath[MAX_PATH];
    DWORD cbFilePathSize = sizeof(sFilePath);
    DWORD dwType;
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, sNS3RegPath, sNS3RegKey,
                                    &dwType, (BYTE*)sFilePath, &cbFilePathSize)
        && (dwType == REG_SZ || dwType == REG_EXPAND_SZ))
    {
        TCHAR szBuffer[MAX_PATH];

        MLLoadString(IDS_NS3_VERSION_CAPTION, szBuffer, MAX_PATH);
        
        retVal = ((ListIterator)m_ExternalList).Insert( 
                   szBuffer, lstrlen(szBuffer)+1,
                   sFilePath, cbFilePathSize / sizeof(TCHAR));
    }

    return retVal;
}


//*************************************************************
//
//  populateExternalList..WithNS4Entries
//
//  subfunc of populateExternalListForCookiesOrBookmarks.

//  returns TRUE if any elements have been added to the external list
BOOL ImpExpUserProcess::populateExternalListForCookiesOrBookmarksWithNS4Entries()
{
    BOOL retVal = FALSE;

    //  Get an iterator to advance position as items are inserted.
    ListIterator iterator = (ListIterator)m_ExternalList;

    //  Get the filename to be attached and the associated string size.
    TCHAR sFilename[MAX_PATH];
    DWORD cFilenameLength;
    if(m_ExternalType == BOOKMARKS)
        MLLoadString(IDS_NETSCAPE_BOOKMARK_FILE,sFilename,ARRAYSIZE(sFilename));
    else
        MLLoadString(IDS_NETSCAPE_COOKIE_FILE,sFilename,ARRAYSIZE(sFilename));
    cFilenameLength = lstrlen(sFilename);

    //  Get the reg key of the root of the NS profiles for enumeration.
    HKEY hUserRootKey = NULL;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, NS4_USERS_REG_PATH, 
                      0, KEY_READ, &hUserRootKey) 
        != ERROR_SUCCESS)
    {
        hUserRootKey = NULL;
        goto donePopulateExternalListForCookiesOrBookmarksWithNS4Entries;
    }

    DWORD dwNumberOfProfiles;
    if( RegQueryInfoKey( hUserRootKey, NULL, NULL, NULL, &dwNumberOfProfiles,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS
        || dwNumberOfProfiles == 0)
    {
        goto donePopulateExternalListForCookiesOrBookmarksWithNS4Entries;
    }

    //  Enumerate over the NS profiles, getting their names and
    //directory paths.  Associated the profile name with the path
    //of the desired files by appending the filename to the
    //user's root.
    TCHAR sProfileName[MAX_PATH];
    DWORD cProfileNameSize;  
    cProfileNameSize = MAX_PATH;
    DWORD iEnumIndex;  iEnumIndex = 0;
    while( RegEnumKeyEx( hUserRootKey, (iEnumIndex++), sProfileName, 
                         &cProfileNameSize, NULL, NULL, NULL, NULL) 
           == ERROR_SUCCESS)
    {
        //RegEnumKeyEx gives us the ProfileNameSize w/out the '\0'.
        cProfileNameSize = MAX_PATH;

        HKEY hProfileKey = NULL;

        if( RegOpenKeyEx( hUserRootKey, sProfileName, 0, KEY_READ, &hProfileKey) 
            != ERROR_SUCCESS)
        {
            hProfileKey = NULL;
            goto doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries;
        }

        DWORD dwType;  //  should be REG_SZ when returned from QueryValue
        TCHAR sProfilePath[MAX_PATH];
        DWORD cProfilePathSize;  cProfilePathSize = sizeof(sProfilePath);
        if( (RegQueryValueEx( hProfileKey, NS4_USERPATH_REG_KEY, NULL, &dwType, 
                             (LPBYTE)sProfilePath, &cProfilePathSize) 
                != ERROR_SUCCESS)
            || dwType != REG_SZ)
        {
            goto doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries;
        }
        cProfilePathSize /= sizeof(TCHAR);
        
        if( (MAX_PATH - cProfilePathSize) < cFilenameLength)
        {
            goto doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries;
        }

        //  append "\\sFilename\0" to the path.
        sProfilePath[ cProfilePathSize - 1] = TCHAR(FILENAME_SEPARATOR);
        memcpy( &sProfilePath[cProfilePathSize], 
                sFilename, cFilenameLength * sizeof(TCHAR));
        cProfilePathSize += cFilenameLength;
        sProfilePath[cProfilePathSize++] = TCHAR('\0');

        // we can only import files if they exist!
        if( m_TransferType == IMPORT
            && GetFileAttributes(sProfilePath) == 0xFFFFFFFF)
                goto doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries;

        //
        // construct the string for the combo box
        //
        TCHAR sRawProfileName[MAX_PATH];
        TCHAR sRealProfileName[MAX_PATH];
        UINT cRealProfileName;

        MLLoadString(IDS_NS4_FRIENDLY_PROFILE_NAME, sRawProfileName, MAX_PATH);

        cRealProfileName = 
            wnsprintf(sRealProfileName, MAX_PATH, 
                      sRawProfileName, sProfileName);

        //  Insert the profile into the list.  If it inserts, thats
        //enough to consider the whole functions call a success.
        if( iterator.Insert(sRealProfileName, cRealProfileName + 1,
                            sProfilePath, cProfilePathSize))
            retVal = TRUE;

    doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries:
        if( hProfileKey != NULL)
            RegCloseKey(hProfileKey);
    }

donePopulateExternalListForCookiesOrBookmarksWithNS4Entries:
    if( hUserRootKey != NULL)
        RegCloseKey( hUserRootKey);

    return retVal;
}

BOOL ImpExpUserProcess::populateExternalListFromFolders(LPTSTR pszPath)
{

    BOOL retval = FALSE;
    TCHAR szFileName[MAX_PATH];
    TCHAR szPathWithWildcards[MAX_PATH];

    ListIterator iterator = (ListIterator)m_ExternalList;

    HANDLE hFind = NULL;
    WIN32_FIND_DATA wfd;

    //
    // what are we looking for?
    //
    if(m_ExternalType == BOOKMARKS)
        MLLoadString(IDS_NETSCAPE_BOOKMARK_FILE,szFileName,ARRAYSIZE(szFileName));
    else
        MLLoadString(IDS_NETSCAPE_COOKIE_FILE,szFileName,ARRAYSIZE(szFileName));

    //
    // prepare the path variable
    //
    StrCpyN(szPathWithWildcards,pszPath,MAX_PATH);
    StrCatBuff(szPathWithWildcards,ALL_FILES_WILDCARD,MAX_PATH);

    //
    // start the find file thing
    //
    hFind = FindFirstFile(szPathWithWildcards,&wfd);

    if (hFind == INVALID_HANDLE_VALUE)
        goto Cleanup;

    do
    {

        //
        // the actual bookmark or cookie file
        //
        TCHAR szFullPath[MAX_PATH];
        int cchFullPath;

        //
        // a "friendly" name for the corresponding profile
        //
        TCHAR szProfileFormat[MAX_PATH];
        TCHAR szProfileName[MAX_PATH];
        int cchProfileName;

        //
        // skip over "." and ".."
        //
        if(!StrCmp(wfd.cFileName, DOT_DIR) ||
           !StrCmp(wfd.cFileName, DOT_DOT_DIR))
            continue;

        //
        // skip over any non-directories
        //
        if (!(wfd.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY))
            continue;

        //
        // generate the path
        //
#ifndef UNIX
        cchFullPath = wnsprintf(szFullPath,MAX_PATH,TEXT("%s\\%s\\%s"),pszPath,wfd.cFileName,szFileName);
#else
        cchFullPath = wnsprintf(szFullPath,MAX_PATH,TEXT("%s/%s/%s"),pszPath,wfd.cFileName,szFileName);
#endif

        //
        // see if the file actually exists
        //
        if (GetFileAttributes(szFullPath) == 0xFFFFFFFF)
            continue;

        //
        // generate the profile name
        //
        MLLoadString(IDS_FB_FRIENDLY_PROFILE_NAME, szProfileFormat, MAX_PATH);
        cchProfileName = wnsprintf(szProfileName, MAX_PATH, szProfileFormat, wfd.cFileName);

        //
        // add the entry to the list
        //
        iterator.Insert(
            szProfileName,cchProfileName+1,
            szFullPath,cchFullPath+1);

        retval = TRUE;

    } while(FindNextFile(hFind,&wfd));

Cleanup:

    if (hFind)
        FindClose(hFind);

    return retval;

}

BOOL ImpExpUserProcess::populateExternalListWithNSEntriesFallBack()
{

    BOOL retVal = FALSE;

    HKEY hRoot = NULL;
    HKEY hCurrentVersion = NULL;
    HKEY hCurrentVersionMain = NULL;

    TCHAR szUsersDir[64]; // will contain "..\\Users"

    DWORD dwType;
    TCHAR szVersion[64];
    TCHAR szPath[MAX_PATH];
    DWORD cbSize;

    LONG result;

    //
    // Open the root of netscape's HKLM registry hierarchy
    //
    result = RegOpenKeyEx(
         HKEY_LOCAL_MACHINE, 
         NS_FALLBACK_ROOT_REG_KEY,
         0, 
         KEY_READ, 
         &hRoot);
    
    if (result != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Retrieve the "CurrentVersion" value
    //
    cbSize = sizeof(szVersion);
    result = RegQueryValueEx(
        hRoot, 
        NS_FALLBACK_VERSION_REG_VAL, 
        NULL, 
        &dwType, 
        (LPBYTE)szVersion, 
        &cbSize);

    if (result != ERROR_SUCCESS || dwType != REG_SZ)
        goto Cleanup;

    //
    // Open the sub-hierarchy corresponding to the current version
    //
    result = RegOpenKeyEx(
         hRoot, 
         szVersion, 
         0, 
         KEY_READ, 
         &hCurrentVersion);

    if (result != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Open the "main" sub-hierarchy
    //
    result = RegOpenKeyEx(
         hCurrentVersion, 
         NS_FALLBACK_MAIN_REG_VAL, 
         0, 
         KEY_READ, 
         &hCurrentVersionMain);

    if (result != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Retrieve the "Install Directory" value
    //
    cbSize = sizeof(szPath);
    result = RegQueryValueEx(
        hCurrentVersionMain, 
        NS_FALLBACK_INST_REG_VAL, 
        NULL, 
        &dwType, 
        (LPBYTE)szPath, 
        &cbSize);

    if (result != ERROR_SUCCESS || dwType != REG_SZ)
        goto Cleanup;

    //
    // Take a wild guess at where the "Users" dir might be
    //
    MLLoadString(IDS_NETSCAPE_USERS_DIR,szUsersDir,ARRAYSIZE(szUsersDir));
    StrCatBuff(szPath,szUsersDir,ARRAYSIZE(szPath));

    //
    // Fill in the list
    //
    if (populateExternalListFromFolders(szPath))
        retVal = TRUE;

Cleanup:

    if (hRoot)
        RegCloseKey(hRoot);

    if (hCurrentVersion)
        RegCloseKey(hCurrentVersion);

    if (hCurrentVersionMain)
        RegCloseKey(hCurrentVersionMain);

    return retVal;

}


//*************************************************************
//
//  PopulateTreeViewForInternalSelection
//
//  Load a nested list of the favorites folders into memory
//and then into a Tree View.

//  returns FALSE if TreeView is left empty.
BOOL ImpExpUserProcess::PopulateTreeViewForInternalSelection( HWND hTreeView)
{
    ASSERT( m_TransferType != INVALID_TRANSFER);

    TreeView_DeleteAllItems( hTreeView);

    if( !populateInternalList())
        return FALSE;

    return populateTreeViewWithInternalList
            ( hTreeView, (ListIterator)m_InternalList, TVI_ROOT);
}


//*************************************************************
//
//  populateTreeViewWithInternalList
//
//  Loads list entries at 'iterator' below tree view item 'hParent'
//  into 'hTreeView'.  Associates value of each list entry with 
//  the Param of the Tree View node.
//
BOOL ImpExpUserProcess::populateTreeViewWithInternalList
(
    HWND hTreeView,
    ListIterator iterator,
    HTREEITEM hParent
)
{
    BOOL retVal = FALSE;
    
    if( iterator.AtEndOfList())
        goto donePopulateTreeViewWithInternalList;

    TVINSERTSTRUCT newTV;
    HTREEITEM hNew;
    
    //  declare parent and intent to put at end of list.
    newTV.hParent = hParent;
    newTV.hInsertAfter = TVI_LAST;

    // build info struct
    newTV.itemex.mask = TVIF_TEXT
                        | TVIF_PARAM
                        | TVIF_CHILDREN
                        | TVIF_IMAGE
                        | TVIF_SELECTEDIMAGE;

    // give name
    newTV.itemex.cchTextMax = lstrlen( iterator.GetName()) + 1;
    newTV.itemex.pszText = const_cast<LPTSTR>(iterator.GetName());
    
    // associate the necessary data
    newTV.itemex.lParam = (LPARAM)iterator.GetValue();

    // tell tree view if there are any children.
    newTV.itemex.cChildren = 
        iterator.GetSublist().AtEndOfList() == TRUE ? FALSE : TRUE;

    //  use correct icons
    newTV.itemex.iSelectedImage = FOLDER_OPEN ;
    newTV.itemex.iImage = FOLDER_CLOSED ;

    hNew = TreeView_InsertItem( hTreeView, &newTV );

    if( hNew == NULL)
        goto donePopulateTreeViewWithInternalList;

    //  an element has been added, so we should return TRUE.
    retVal = TRUE;

    //  add children
    populateTreeViewWithInternalList( hTreeView, iterator.GetSublist(), hNew );

    //  add siblings
    if( iterator.Next())
        populateTreeViewWithInternalList( hTreeView, iterator, hParent );

donePopulateTreeViewWithInternalList:
    return retVal;

}

BOOL ImpExpUserProcess::ExpandTreeViewRoot ( HWND hTreeView ) 
{

    HTREEITEM hRoot ;

    hRoot = TreeView_GetRoot ( hTreeView ) ;

    if ( hRoot != NULL )
        TreeView_Expand ( hTreeView, hRoot, TVE_EXPAND ) ;
    else
        return FALSE ;

    return TRUE ;

}

//*************************************************************
//
//  SelectInternalSelection
//
//  Gets the data associated with the current selection of
//'hTreeView'.

BOOL ImpExpUserProcess::SelectInternalSelection( HWND hTreeView)
{
    HTREEITEM hSelection = TreeView_GetSelection( hTreeView);
    
    if( hSelection == NULL)
        return FALSE;

    //TVITEM is built up to query the lParam
    //(the lParam has been associated with a pointer to the path value)
    TVITEM TV;
    TV.mask = TVIF_PARAM;
    TV.hItem = hSelection;
    
    if( !TreeView_GetItem( hTreeView, &TV))
        return FALSE;

    m_pSelectedInternal = (LPTSTR)TV.lParam;

    ASSERT( m_pSelectedInternal != NULL);
    
    return TRUE;
}


//*************************************************************
//
//  purgeInternalList
//
//  Wipes out whatever has been loaded in the internal
//target/source list.

void ImpExpUserProcess::purgeInternalList()
{
    // clear the list.
    ListIterator iterator = (ListIterator)m_InternalList;

    while( iterator.Remove())
    {
    }

    m_pSelectedInternal = NULL;
    m_InternalListExternalType = INVALID_EXTERNAL;
    m_InternalListTransferType = INVALID_TRANSFER;
}


//*************************************************************
//
//  populateInternalList
//
//  Builds the internal list for potential internal target/sources.
//  This currently only makes sense for bookmarks, where a favorites
//directory has to be picked.

//  returns TRUE if any elements have been added to the internal list
BOOL ImpExpUserProcess::populateInternalList()
{
    ASSERT( m_ExternalType != INVALID_EXTERNAL);

    if( m_InternalListExternalType == m_ExternalType
        && m_InternalListTransferType == m_TransferType)
        return TRUE;

    purgeInternalList();

    // (could switch on different m_ExternalTypes here)
    if( !populateInternalListForBookmarks())
    {
        purgeInternalList();
        return FALSE;
    }

    m_InternalListExternalType = m_ExternalType;
    m_InternalListTransferType = m_TransferType;
    return TRUE;
}


//*************************************************************
//
//  populateInternalListForBookmarks

//  returns TRUE if any elements have been added to the internal list
BOOL ImpExpUserProcess::populateInternalListForBookmarks()
{
    TCHAR szFavoritesPath[MAX_PATH];

    if( SHGetSpecialFolderPath( NULL, szFavoritesPath, CSIDL_FAVORITES, FALSE)
        && appendSubdirsToInternalList( szFavoritesPath, m_InternalList))
    {
        return TRUE;
    }
    else return FALSE;
}


//*************************************************************
//
//  appendSubdirsToInternalList
//
//  Takes 'sPath' as a specification for a file search.  All
//directories that match that are added to the internal list 
//at 'iterator'.
//  Recursively adds subdirectories found.
//
//typical usage:
//     szPath is "c:\Root\Favorites",
//       finds "c:\Root\Favorites",
//   recursively calls itself with
//     szPath = "c:\Root\Favorites\*.*"
//       finding and recursing into all subdirs

//  returns TRUE if any directories have been added to the internal list
//  Edits the contents of the buffer past the last '\\'.
BOOL ImpExpUserProcess::appendSubdirsToInternalList
(
    LPTSTR sPath, 
    ListIterator iterator
)
{
    BOOL fHaveAddedDirectories = FALSE;

    DWORD cPathLength = lstrlen(sPath);

    HANDLE hEnum;
    WIN32_FIND_DATA currentFile;

    hEnum = FindFirstFile( sPath, &currentFile);

    //example:
    //given: "c:\root\*.*"  (will find all dirs in root)
    //want: "c:\root\"
    //given: "c:\favorites" (will find favorites in root)
    //want: "c:\"
    //  left search to '\\' to find the path of the files to be found.
    while( cPathLength > 0
           && sPath[ --cPathLength] != TCHAR(FILENAME_SEPARATOR))
    {
    }
    cPathLength++;

    if( hEnum == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        DWORD cFileNameLength;
        
        // we only handle directories
        if( !(currentFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            continue;

        // we don't want '.' and '..' to show up.
        if( !StrCmp( currentFile.cFileName, DOT_DIR)
            || !StrCmp( currentFile.cFileName, DOT_DOT_DIR))
            continue;

        cFileNameLength = lstrlen( currentFile.cFileName);
        memcpy( sPath + cPathLength, currentFile.cFileName, cFileNameLength * sizeof(TCHAR));
        sPath[ cPathLength + cFileNameLength] = TCHAR('\0');

        if( iterator.Insert( currentFile.cFileName, cFileNameLength + 1,
                             sPath, cPathLength + cFileNameLength + 1))
        {
            memcpy( sPath + cPathLength + cFileNameLength,
                    ALL_FILES_WILDCARD, sizeof(ALL_FILES_WILDCARD));
            appendSubdirsToInternalList( sPath, iterator.GetSublist());
            // we know now that a directory has been added
            fHaveAddedDirectories = TRUE;
        }
    } while( FindNextFile( hEnum, &currentFile));
    ASSERT(ERROR_NO_MORE_FILES == GetLastError());

    FindClose(hEnum);
    return fHaveAddedDirectories;
}


//*************************************************************
//
//  PerformImpExpProcess
//
//  Once everything is set up right, this should do the trick.

void ImpExpUserProcess::PerformImpExpProcess(HWND hwnd)
{
    ASSERT( GetExternalType() != INVALID_EXTERNAL);
    ASSERT( GetTransferType() != INVALID_TRANSFER);
    ASSERT( (GetExternalType() == BOOKMARKS) ? (GetInternalSelection() != NULL) : TRUE);

    HCURSOR hOldCursor;

    //
    // This could take a while, so show an hourglass cursor
    //
    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    switch( GetExternalType())
    {
    case COOKIES:

        switch( GetTransferType())
        {
        case IMPORT:
            if (ImportCookieFile(m_szFileName))
            {
                MLShellMessageBox(
                    hwnd, 
                    MAKEINTRESOURCE(IDS_IMPORTSUCCESS_COOK), 
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_COOK),
                    MB_OK);
            }
            else
            {
                MLShellMessageBox(
                    hwnd, 
                    MAKEINTRESOURCE(IDS_IMPORTFAILURE_COOK), 
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_COOK),
                    MB_OK);
            }
            break;

        case EXPORT:
            if (SUCCEEDED(SHPathPrepareForWriteWrap(hwnd, NULL, m_szFileName, FO_COPY, (SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME))))
            {
                //  FALSE specifies that we will overwrite cookies
                if (ExportCookieFile(m_szFileName, FALSE ))
                {
                    MLShellMessageBox(
                        hwnd, 
                        MAKEINTRESOURCE(IDS_EXPORTSUCCESS_COOK), 
                        MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_COOK),
                        MB_OK);
                }
                else
                {
                    MLShellMessageBox(
                        hwnd, 
                        MAKEINTRESOURCE(IDS_EXPORTFAILURE_COOK), 
                        MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_COOK),
                        MB_OK);
                }
            }
            break;

        default:
            ASSERT(0);
            
        }
        break;
        
    case BOOKMARKS:

        DoImportOrExport(
            GetTransferType()==IMPORT,
            m_pSelectedInternal,
            m_szFileName,
            FALSE);

        break;

    default:
        ASSERT(0);

    }

    //
    // Put the old cursor back when finished
    //
    SetCursor(hOldCursor);

}


//*************************************************************
//*************************************************************
//
//   ImpExpUserDlg
//
//  Handles the user interface side of things, building
//  up an ImpExpUserProcess then executing it.
//  The dialog procedures below will all have a return value
//  which can be set to something besides FALSE if used, or left
//  as FALSE if not used.  Since only one section of code should
//  attempt to give the return value a value before returning,
//  class RetVal is set up to throw an assertion if two pieces
//  of code intended to pass back a return value at the same
//  time.

class ReturnValue
{

private:
    BOOL_PTR m_value;

public:
    ReturnValue()
    { 
        m_value = FALSE;
    }
    
    BOOL_PTR operator =(BOOL_PTR newVal)
    {
        ASSERT( m_value == FALSE);
        m_value = newVal;
        return m_value;
    }
    
    operator BOOL_PTR ()
    {
        return m_value;
    }
};

class ImpExpUserDlg
{

private:

    static HIMAGELIST m_himl ;
    static BOOL InitImageList ( HWND hwndTree ) ;   
    static BOOL DestroyImageList ( HWND hwndTree ) ;    

    static HFONT m_hfont ;
    static BOOL InitFont ( HWND hwndStatic ) ;
    static BOOL DestroyFont ( HWND hwndStatic ) ;

    //  A sheet knows its resource ID and what process
    //it contributes to.
    struct SheetData
    {
        int _idPage;
        ImpExpUserProcess* _pImpExp;

        SheetData( int idPage, ImpExpUserProcess* pImpExp )
        : _idPage( idPage ), _pImpExp( pImpExp )
        {
        }
    };
    //
    //  InitializePropertySheetPage() will associate a dialog 
    //  with an allocated copy of SheetData, which will be
    //  found at PSN_SETACTIVE with and stored with SetWindowLong.
    //  The allocated SheetData will be cleaned up by callback
    //  procedure PropertySheetPageProc().
    //
    //  Callback functions sure are a drag for maintaining identity.
    //  GetWindowLong and SetWindowLong will be used to keep tabs
    //  on who is who, setting 'ghost' member variables.
    //
    // 'ghost' SheetData*         This;
    // 'ghost' ImpExpUserProcess* m_pImpExp;
    // 'ghost' DWORD              m_idPage;
    //
    //  CommonDialogProc retrieves the 'ghost' values and does other 
    //  shared behavior.
    //
    static DWORD CommonDialogProc
    ( 
        IN HWND hwndDlg, IN UINT msg, IN WPARAM wParam, IN LPARAM lParam,
        OUT ImpExpUserProcess** ppImpExp, OUT DWORD* pPageId,
        IN OUT ReturnValue& retVal
    );

    static void InitializePropertySheetPage( PROPSHEETPAGE* psp, DWORD idDialogTemplate, DWORD idTitle, DWORD idSubTitle,DLGPROC dlgProc, ImpExpUserProcess* lParam);
    static UINT CALLBACK PropertySheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

    //  some dialog procedures
    static BOOL_PTR CALLBACK Wizard97DlgProc( HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK TransferTypeDlg(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK InternalDlg(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK ExternalDlg(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    static void HandleTransferTypeChange ( HWND hwndDlg, ImpExpUserProcess* m_pImpExp, UINT iSelect ) ;

public:
    static BOOL RunNewDialogProcess( HWND hParent ) ;

};

HIMAGELIST ImpExpUserDlg::m_himl = NULL ;

BOOL ImpExpUserDlg::InitImageList ( HWND hwndTree )
{

    //
    // Code to retrieve icons for open and closed folders
    // was based on code in private/samples/sampview/utility.cpp.
    //

    TCHAR       szFolder[MAX_PATH];
    SHFILEINFO  sfi;
    HIMAGELIST  himlOld ;
    DWORD       dwRet ;

    // create the image list
    m_himl = ImageList_Create ( GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_COLORDDB, 2, 2 ) ;

    if ( m_himl == NULL )
        return FALSE ;

    ImageList_SetBkColor( m_himl, GetSysColor(COLOR_WINDOW) ) ;

    // add the closed folder icon
    GetWindowsDirectory(szFolder, MAX_PATH);
    SHGetFileInfo( szFolder,
                   0,
                   &sfi,
                   sizeof(sfi),
                   SHGFI_ICON | SHGFI_SMALLICON);
    dwRet = ImageList_AddIcon(m_himl, sfi.hIcon);
    ASSERT ( dwRet == FOLDER_CLOSED ) ;

    // add the open folder icon
    SHGetFileInfo( szFolder,
                   0,
                   &sfi,
                   sizeof(sfi),
                   SHGFI_ICON | SHGFI_SMALLICON | SHGFI_OPENICON);
    dwRet = ImageList_AddIcon(m_himl, sfi.hIcon);
    ASSERT ( dwRet == FOLDER_OPEN ) ;

    himlOld = TreeView_SetImageList( hwndTree, m_himl, TVSIL_NORMAL );

    if ( himlOld != NULL )
    {
        BOOL fOk ;
        fOk = ImageList_Destroy ( himlOld ) ;
        ASSERT ( fOk ) ;
    }

    return TRUE ;

}

BOOL ImpExpUserDlg::DestroyImageList ( HWND hwndTree ) 
{
    HIMAGELIST himlOld ;

    himlOld = TreeView_SetImageList( hwndTree, NULL, TVSIL_NORMAL );

    if ( himlOld != NULL )
    {
        BOOL fOk ;
        fOk = ImageList_Destroy ( himlOld ) ;
        ASSERT ( fOk ) ;
    }

    return TRUE ;
}


HFONT ImpExpUserDlg::m_hfont = NULL ;

BOOL ImpExpUserDlg::InitFont ( HWND hwndStatic ) 
{

    HDC hdc = GetDC ( hwndStatic ) ;

    if ( hdc == NULL )
        return FALSE ;

    LOGFONT lf;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH;
    lf.lfItalic = 0;
    lf.lfWeight = FW_BOLD;
    lf.lfStrikeOut = 0;
    lf.lfUnderline = 0;
    lf.lfWidth = 0;
    lf.lfHeight = -MulDiv(13, GetDeviceCaps(hdc, LOGPIXELSY), 72);

    LOGFONT lfTmp;
    HFONT   hFontOrig = (HFONT)SendMessage(hwndStatic, WM_GETFONT, (WPARAM)0, (LPARAM)0);
    if (hFontOrig && GetObject(hFontOrig, sizeof(lfTmp), &lfTmp))
    {
        lf.lfCharSet = lfTmp.lfCharSet;
        StrCpyN(lf.lfFaceName, lfTmp.lfFaceName, LF_FACESIZE);
    }
    else
    {
        lf.lfCharSet = GetTextCharset(hdc);
        StrCpyN(lf.lfFaceName, TEXT("MS Shell Dlg"), LF_FACESIZE);
    }

    m_hfont = CreateFontIndirect(&lf);

    if ( m_hfont == NULL )
    {
        ReleaseDC(hwndStatic, hdc);
        return FALSE ;
    }

    SendMessage ( hwndStatic, WM_SETFONT, (WPARAM)m_hfont, MAKELPARAM(FALSE, 0) ) ;

    ReleaseDC ( hwndStatic,hdc ) ;

    return TRUE ;

}

BOOL ImpExpUserDlg::DestroyFont ( HWND hwndDlg )
{

    if ( m_hfont )
        DeleteObject ( m_hfont ) ;

    return TRUE ;
}

void ImpExpUserDlg::InitializePropertySheetPage
(
    PROPSHEETPAGE* psp, 
    DWORD idDialogTemplate,
    DWORD idTitle,
    DWORD idSubTitle,
    DLGPROC dlgProc,
    ImpExpUserProcess* lParam
)
{
    psp->dwFlags |= PSP_USECALLBACK | PSP_USETITLE;
    psp->hInstance = MLGetHinst();
    psp->pszTemplate = MAKEINTRESOURCE(idDialogTemplate);
    psp->pfnDlgProc = dlgProc;
    psp->lParam = (LPARAM)(new SheetData(idDialogTemplate,lParam));
    psp->pfnCallback = PropertySheetPageProc;
    psp->pszHeaderTitle = MAKEINTRESOURCE(idTitle);
    psp->pszHeaderSubTitle = MAKEINTRESOURCE(idSubTitle);
    psp->pszTitle = MAKEINTRESOURCE(IDS_IMPEXP_CAPTION);

    if ( idDialogTemplate == IDD_IMPEXPWELCOME ||
         idDialogTemplate == IDD_IMPEXPCOMPLETE )
    {
        psp->dwFlags |= PSP_HIDEHEADER; 
    }
    else
    {
        psp->dwFlags |= (PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE);
    }

}


UINT CALLBACK ImpExpUserDlg::PropertySheetPageProc
(
    HWND hwnd, 
    UINT uMsg, 
    LPPROPSHEETPAGE ppsp
)
{

    switch(uMsg)
    {

    case PSPCB_CREATE:
        break;

    case PSPCB_RELEASE:
        delete (SheetData*)ppsp->lParam;
        ppsp->lParam = NULL;
        break;

    default:
        break;

    }

    return TRUE ;
}


//*************************************************************
//
//  RunNewDialogProcess
//
//  Runs the Import Export Wizard.

BOOL_PTR CALLBACK TEMP(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
{
    return (uMsg==WM_INITDIALOG);
}

BOOL ImpExpUserDlg::RunNewDialogProcess(HWND hParent)
{


    const int numPages = 9;
    ImpExpUserProcess* pImpExp = new ImpExpUserProcess();

    if( pImpExp == NULL)
        return FALSE;
        
    PROPSHEETPAGE pspOld[numPages];
    PROPSHEETPAGE* psp = pspOld;

    // dwSkip is set in Whistler_AllocatePropertySheetPage to whatever the size of Whistler's PROPSHEETPAGE
    // is. 0x34 last I checked. (IE5 PROPSHEETPAGE is 0x30)
    DWORD dwSkip = sizeof(PROPSHEETPAGE);
    if (IsOS(OS_WHISTLERORGREATER))
    {
        PROPSHEETPAGE* psp2 = Whistler_AllocatePropertySheetPage(numPages, &dwSkip);
        if (psp2)
        {
            psp = psp2;
        }
    }
    if (psp==pspOld)
    {
        for (int i=0; i<numPages; i++)
        {
            memset(&psp[i], 0, sizeof(PROPSHEETPAGE));
            psp[i].dwSize = sizeof(PROPSHEETPAGE);
        }
    }
     
    PROPSHEETHEADER psh;

    PBYTE pspNext = (PBYTE)psp;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPWELCOME,        0,                              0,                                  Wizard97DlgProc, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPTRANSFERTYPE,   IDS_IMPEXPTRANSFERTYPE_TITLE,   IDS_IMPEXPTRANSFERTYPE_SUBTITLE,    TransferTypeDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPIMPFAVSRC,      IDS_IMPEXPIMPFAVSRC_TITLE,      IDS_IMPEXPIMPFAVSRC_SUBTITLE,       ExternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPIMPFAVDES,      IDS_IMPEXPIMPFAVDES_TITLE,      IDS_IMPEXPIMPFAVDES_SUBTITLE,       InternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPEXPFAVSRC,      IDS_IMPEXPEXPFAVSRC_TITLE,      IDS_IMPEXPEXPFAVSRC_SUBTITLE,       InternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPEXPFAVDES,      IDS_IMPEXPEXPFAVDES_TITLE,      IDS_IMPEXPEXPFAVDES_SUBTITLE,       ExternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPIMPCKSRC,       IDS_IMPEXPIMPCKSRC_TITLE,       IDS_IMPEXPIMPCKSRC_SUBTITLE,        ExternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPEXPCKDES,       IDS_IMPEXPEXPCKDES_TITLE,       IDS_IMPEXPEXPCKDES_SUBTITLE,        ExternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPCOMPLETE,       0,                              0,                                  Wizard97DlgProc, pImpExp );

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_WIZARD97 | PSH_PROPSHEETPAGE | PSH_HEADER | PSH_WATERMARK ; 
    psh.hwndParent = hParent;
    psh.hInstance = MLGetHinst();
    psh.pszCaption = MAKEINTRESOURCE(IDS_IMPEXP_CAPTION);
    psh.nPages = numPages;
    psh.nStartPage = 0;
    psh.ppsp = psp;
    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_IMPEXPWATERMARK);
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_IMPEXPHEADER);

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    int iResult = (int)PropertySheet(&psh) ;
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
    delete pImpExp;
    if (psp!=pspOld)
    {
        HeapFree(GetProcessHeap(), NULL, psp);
    }
    return iResult;

}


//*************************************************************
//
//  CommonDialogProc
//
//  Prepares 'ghost' member variables of the user dialog process,
//  handles ordering details of wizard pages and initializes common
//  dialog elements.
//
//  retVal passes through CommonDialogProc so that it can be set
//  if necessary.  Clients of CommonDialogProc should not need
//  to specify a new return value if CommonDialogProc has specified
//  a non-FALSE return value.
//
//  If CommonDialogProc returns FALSE dialog procedure should
//  considered 'msg' handled and return retVal immediately.
//
//  If this dialog has yet to receive WM_INITDIALOG, the 'ghost'
//  values will be zero (and invalid).
//

DWORD ImpExpUserDlg::CommonDialogProc
( 
    IN HWND hwndDlg, 
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam,
    OUT ImpExpUserProcess** ppImpExp,
    OUT DWORD* pPageId,
    ReturnValue& retVal
)
{

    SheetData* sheetData;
    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    //
    // Do init-dialog stuff
    //
    if ( WM_INITDIALOG == msg )
    {
        sheetData = (SheetData*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)sheetData);
    }

    //
    // Initialize the sheetData field
    //
    sheetData = (SheetData*)GetWindowLongPtr( hwndDlg, DWLP_USER ) ;
    if ( sheetData != NULL )
    {
        m_pImpExp = *ppImpExp = sheetData->_pImpExp;
        m_idPage = *pPageId = sheetData->_idPage;
    }

    //
    // Next, we check to make sure we're on the correct page.  If not, simply
    // return -1 and the wizard will automatically advance to the next page.
    //
    if( WM_NOTIFY == msg && PSN_SETACTIVE == ((LPNMHDR)lParam)->code )
    {

        BOOL fPageValidation = TRUE ;

        switch( m_idPage )
        {

        case IDD_IMPEXPWELCOME:
        case IDD_IMPEXPTRANSFERTYPE:
        case IDD_IMPEXPCOMPLETE:                    
            break;

        case IDD_IMPEXPIMPFAVSRC:
        case IDD_IMPEXPIMPFAVDES:
            if(m_pImpExp->GetTransferType() != IMPORT || m_pImpExp->GetExternalType() != BOOKMARKS)
                fPageValidation = FALSE;
            break;
    
        case IDD_IMPEXPEXPFAVSRC:
        case IDD_IMPEXPEXPFAVDES:
            if(m_pImpExp->GetTransferType() != EXPORT || m_pImpExp->GetExternalType() != BOOKMARKS)
                fPageValidation = FALSE;
            break;

        case IDD_IMPEXPIMPCKSRC:
            if(m_pImpExp->GetTransferType() != IMPORT || m_pImpExp->GetExternalType() != COOKIES)
                fPageValidation = FALSE;
            break;

        case IDD_IMPEXPEXPCKDES:
            if(m_pImpExp->GetTransferType() != EXPORT || m_pImpExp->GetExternalType() != COOKIES)
                fPageValidation = FALSE;
            break;
        }

        SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, fPageValidation ? 0 : -1 ) ;
        retVal = TRUE ;
        
        if ( ! fPageValidation )
            return FALSE ;

    }

    //
    // Initialize fonts and image lists (if needed)
    //
    if ( WM_NOTIFY == msg )
    {

        HWND hwndTitle = GetDlgItem ( hwndDlg, IDC_IMPEXPTITLETEXT )  ;
        HWND hwndTree = GetDlgItem ( hwndDlg, IDC_IMPEXPFAVTREE )  ;

        switch ( ((LPNMHDR)lParam)->code )
        {

        case PSN_SETACTIVE:
        
            if ( hwndTitle )
                InitFont ( hwndTitle ) ;

            if ( hwndTree )
                InitImageList( hwndTree ) ;
    
            break ;

        case PSN_KILLACTIVE:
        case PSN_QUERYCANCEL:

            if ( hwndTitle )
                DestroyFont ( hwndTitle ) ;

            if ( hwndTree )
                DestroyImageList( hwndTree ) ;

            break;

        }
    
    }

    if( WM_NOTIFY == msg && PSN_SETACTIVE == ((LPNMHDR)lParam)->code )
    {

        HWND hwndParent = GetParent( hwndDlg);

        switch( m_idPage )
        {
        case IDD_IMPEXPWELCOME:
            PropSheet_SetWizButtons( hwndParent, PSWIZB_NEXT );
            break;
            
        case IDD_IMPEXPCOMPLETE:
            {

                UINT idText ;
                const TCHAR *szInsert = m_pImpExp->m_szFileName ;
                TCHAR szRawString[1024] ;
                TCHAR szRealString[1024] ;

                //
                // First, we need to figure out which string should 
                // be used to describe what the wizard is going to 
                // do (for example "Import the cookies from...")
                //
                if ( m_pImpExp->GetTransferType() == IMPORT )
                {
                    if ( m_pImpExp->GetExternalType() == COOKIES )
                        idText = IDS_IMPEXP_COMPLETE_IMPCK ;
                    else
                        idText = IDS_IMPEXP_COMPLETE_IMPFV ;
                }
                else
                {
                    if ( m_pImpExp->GetExternalType() == COOKIES )
                        idText = IDS_IMPEXP_COMPLETE_EXPCK ;
                    else
                        idText = IDS_IMPEXP_COMPLETE_EXPFV ;
                }

                LoadString(MLGetHinst(), idText, szRawString, 1024);

                wnsprintf(szRealString, 1024, szRawString, szInsert);

                //
                // Set the text in the listview, and do all the other magic to make
                // the tooltips work, etc.
                //
                SetListViewToString(GetDlgItem(hwndDlg,IDC_IMPEXPCOMPLETECONFIRM), szRealString);

                //
                // The SetListViewToString function helpfully sets the background color to
                // gray instead of the default (white).  But we actually want it white, so 
                // let's reset it here.
                // 
                ListView_SetBkColor(GetDlgItem(hwndDlg,IDC_IMPEXPCOMPLETECONFIRM), GetSysColor(COLOR_WINDOW));
                ListView_SetTextBkColor(GetDlgItem(hwndDlg,IDC_IMPEXPCOMPLETECONFIRM), GetSysColor(COLOR_WINDOW));
                
                PropSheet_SetWizButtons(hwndParent, PSWIZB_BACK|PSWIZB_FINISH);

            }
            break;
            
        default:
            PropSheet_SetWizButtons( hwndParent, PSWIZB_NEXT | PSWIZB_BACK );
            break;
        }

    }

    return TRUE ;
}


//*************************************************************
//
//  Wizard97DlgProc
//
//  Dialog proc for welcome and complete pages.
//  

BOOL_PTR CALLBACK ImpExpUserDlg::Wizard97DlgProc
(
    HWND hwndDlg, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    ReturnValue retVal;

    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    if( !CommonDialogProc( hwndDlg, msg, wParam, lParam, 
                        &m_pImpExp, &m_idPage, retVal))
    {
        return retVal;
    }

    if( m_idPage == IDD_IMPEXPCOMPLETE 
        && msg == WM_NOTIFY
        && PSN_WIZFINISH == ((LPNMHDR)lParam)->code)

    m_pImpExp->PerformImpExpProcess(hwndDlg);

    return retVal;;
}


//*************************************************************
//
//  TransferTypeDlg
//
//  Dialog proc for dialog where user picks transfer type
//  (import vs. export), (cookies vs. bookmarks)

BOOL_PTR CALLBACK ImpExpUserDlg::TransferTypeDlg
(
    HWND hwndDlg, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    ReturnValue retVal;

    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    if( !CommonDialogProc( hwndDlg, msg, wParam, lParam, 
                        &m_pImpExp, &m_idPage, retVal))
    {
        return retVal;
    }

    HWND hwndDlgItem;
   
    switch( msg)
    {
    case WM_INITDIALOG:
        {
            hwndDlgItem = GetDlgItem( hwndDlg, IDC_IMPEXPACTIONLISTBOX);

            LRESULT index;
            TCHAR szBuffer[MAX_PATH];
            const DWORD cbSize = MAX_PATH;

            if( MLLoadString( IDS_IMPFAVORITES, szBuffer, cbSize))
            {
                index = ListBox_AddString( hwndDlgItem, szBuffer);
                ListBox_SetItemData( hwndDlgItem, index, IDS_IMPFAVORITES);
            }

            if( MLLoadString( IDS_EXPFAVORITES, szBuffer, cbSize))
            {
                index = ListBox_AddString( hwndDlgItem, szBuffer);
                ListBox_SetItemData( hwndDlgItem, index, IDS_EXPFAVORITES);
            }
            
            if( MLLoadString( IDS_IMPCOOKIES, szBuffer, cbSize))
            {
                index = ListBox_AddString( hwndDlgItem, szBuffer);
                ListBox_SetItemData( hwndDlgItem, index, IDS_IMPCOOKIES);
            }
            
            if( MLLoadString( IDS_EXPCOOKIES, szBuffer, cbSize))
            {
                index = ListBox_AddString( hwndDlgItem, szBuffer);
                ListBox_SetItemData( hwndDlgItem, index, IDS_EXPCOOKIES);
            }

            // Select the first list item, by default
            ListBox_SetCurSel(hwndDlgItem, 0);
            HandleTransferTypeChange(hwndDlg, m_pImpExp, IDS_IMPFAVORITES);

        }  // end of WM_INITDIALOG
        break;
        
    case WM_COMMAND:
        //  when the user selects an option, choose it and
        //and update the description box.
        hwndDlgItem = GetDlgItem(hwndDlg, IDC_IMPEXPACTIONLISTBOX);

        if(hwndDlgItem == (HWND)lParam
           && HIWORD(wParam) == LBN_SELCHANGE)
        {

            //  find out which string resource was selected.
            LRESULT index = ListBox_GetCurSel(hwndDlgItem);
            LRESULT selection = ListBox_GetItemData(hwndDlgItem, index);

            HandleTransferTypeChange ( hwndDlg, m_pImpExp, (UINT)selection ) ;
            retVal = TRUE;

        }
        break;
        
    case WM_NOTIFY:

        //
        //  Prevent advancement until user has made valid choices
        //
        if( ((LPNMHDR)lParam)->code == PSN_WIZNEXT && m_pImpExp
            &&  (m_pImpExp->GetExternalType() == INVALID_EXTERNAL
                 || m_pImpExp->GetTransferType() == INVALID_TRANSFER))
        {
            SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, -1);
            retVal = TRUE;
        }

        //
        // otherwise, set the filename to nul (so we get the default)
        // and allow default navigation behavior
        //

        if (m_pImpExp)
            m_pImpExp->m_szFileName[0] = TEXT('\0');

        break;
    }

    return retVal;
}

void ImpExpUserDlg::HandleTransferTypeChange ( HWND hwndDlg, ImpExpUserProcess* pImpExp, UINT iSelect )
{

    TCHAR szBuffer[MAX_PATH];
    const DWORD cbSize = MAX_PATH;

    if (pImpExp)
    {
        //
        //  Note:  The description of each option has a resource id
        //  which is one higher than the resource id of the option name.
        //
        switch( iSelect )
        {
        case IDS_IMPFAVORITES:
            if( MLLoadString( IDS_IMPFAVORITES + 1, szBuffer, cbSize ) )
                SetWindowText( GetDlgItem( hwndDlg, IDC_IMPEXPACTIONDESCSTATIC ),
                               szBuffer );
            pImpExp->SelectExternalType( BOOKMARKS );
            pImpExp->SelectTransferType( IMPORT );
            break;
        
        case IDS_EXPFAVORITES:
            if( MLLoadString( IDS_EXPFAVORITES + 1, szBuffer, cbSize ) )
                SetWindowText( GetDlgItem( hwndDlg, IDC_IMPEXPACTIONDESCSTATIC ),
                               szBuffer );
            pImpExp->SelectExternalType( BOOKMARKS );
            pImpExp->SelectTransferType( EXPORT );
            break;
        
        case IDS_IMPCOOKIES:
            if( MLLoadString( IDS_IMPCOOKIES + 1, szBuffer, cbSize))
                SetWindowText( GetDlgItem( hwndDlg, IDC_IMPEXPACTIONDESCSTATIC),
                               szBuffer);
            pImpExp->SelectExternalType( COOKIES);
            pImpExp->SelectTransferType( IMPORT);
            break;

        case IDS_EXPCOOKIES:
            if( MLLoadString( IDS_EXPCOOKIES + 1, szBuffer, cbSize))
                SetWindowText( GetDlgItem( hwndDlg, IDC_IMPEXPACTIONDESCSTATIC),
                               szBuffer);
            pImpExp->SelectExternalType( COOKIES);
            pImpExp->SelectTransferType( EXPORT);
            break;
        }
    }

}


//*************************************************************
//
//  InternalDlg
//
//  Allows user to pick internal target/source from tree view.

BOOL_PTR CALLBACK ImpExpUserDlg::InternalDlg
(
    HWND hwndDlg, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    ReturnValue retVal;

    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    if( !CommonDialogProc( hwndDlg, msg, wParam, lParam, 
                        &m_pImpExp, &m_idPage, retVal))
    {
        return retVal;
    }


    HWND hwndDlgItem;

    switch( msg)
    {
    case WM_INITDIALOG:

        //
        // Populate the tree control
        //
        hwndDlgItem = GetDlgItem(hwndDlg, IDC_IMPEXPFAVTREE);
        if ( hwndDlgItem )
        {
            if (m_pImpExp)
            {
                m_pImpExp->PopulateTreeViewForInternalSelection(hwndDlgItem);
                m_pImpExp->ExpandTreeViewRoot ( hwndDlgItem ) ;
            }
        }
        else
            ASSERT(0);

        return TRUE;


    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code)
        {

        case PSN_WIZNEXT:

            //  Only allow user to go to next if there is a valid selection.
            if( !m_pImpExp->SelectInternalSelection(GetDlgItem(hwndDlg,IDC_IMPEXPFAVTREE)) )
            {
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, -1);
                retVal = TRUE;
            }

        }
    }

    return retVal;
}

BOOL IsValidFileOrURL(LPTSTR szFileOrURL)
{
    if (szFileOrURL == NULL)
        return FALSE;

    //
    // any URL is ok
    //
    if (PathIsURL(szFileOrURL))
        return TRUE;

    //
    // just a directory is no good, we need a filename too
    //
    if (PathIsDirectory(szFileOrURL))
        return FALSE;

    //
    // just a filename is no good, we need a directory too
    //
    if (PathIsFileSpec(szFileOrURL))
        return FALSE;

    //
    // relative paths are no good
    //
    if (PathIsRelative(szFileOrURL))
        return FALSE;

    //
    // now make sure it parses correctly
    //
    if (PathFindFileName(szFileOrURL) == szFileOrURL)
        return FALSE;

    return TRUE;

}

//*************************************************************
//
//  ExternalDlg
//
//  Allows user to pick external target/source from list box
//or manual browse.

BOOL_PTR CALLBACK ImpExpUserDlg::ExternalDlg
(
    HWND hwndDlg, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    ReturnValue retVal;

    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    if( !CommonDialogProc( hwndDlg, msg, wParam, lParam, 
                           &m_pImpExp, &m_idPage, retVal))
    {
        return retVal;
    }

    HWND hwndDlgItem;
    
    switch(msg)
    {

    case WM_COMMAND:

        hwndDlgItem = (HWND) lParam;
        if( HIWORD(wParam) == BN_CLICKED && LOWORD(wParam) == IDC_IMPEXPBROWSE)
        {
            OPENFILENAME ofn;
            TCHAR szFile[MAX_PATH];
            TCHAR szTitle[MAX_PATH];
            TCHAR szFilter[MAX_PATH];
            TCHAR szInitialPath[MAX_PATH];
            int i;

            ZeroMemory(&ofn, sizeof(OPENFILENAME));
            ofn.lStructSize = sizeof(OPENFILENAME);
            ofn.hwndOwner = hwndDlg;
            ofn.hInstance = MLGetHinst();
            ofn.lpstrFilter = szFilter;
            ofn.nFilterIndex = 1;
            ofn.lpstrCustomFilter = NULL;
            ofn.lpstrFile = szFile;
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFileTitle = NULL;
            ofn.lpstrInitialDir = szInitialPath;
            ofn.lpstrTitle = szTitle;
            ofn.lpstrDefExt = (m_pImpExp->GetExternalType()==COOKIES) ? TEXT("txt") : TEXT("htm");

            GetDlgItemText(hwndDlg, IDC_IMPEXPMANUAL, szInitialPath, ARRAYSIZE(szFile));
            szFile[0] = 0;

            if (PathIsDirectory(szInitialPath))
            {
                ofn.lpstrInitialDir = szInitialPath;
                szFile[0] = TEXT('\0');    
            }
            else
            {
                TCHAR *pchFilePart;

                pchFilePart = PathFindFileName(szInitialPath);

                if (pchFilePart == szInitialPath || pchFilePart == NULL)
                {

                    if (PathIsFileSpec(szInitialPath))
                        StrCpyN(szFile,szInitialPath,MAX_PATH);
                    else
                        szFile[0] = TEXT('\0');

                    ofn.lpstrInitialDir = szInitialPath;
                    SHGetSpecialFolderPath(NULL,szInitialPath,CSIDL_DESKTOP,FALSE);

                }
                else
                {
                    pchFilePart[-1] = TEXT('\0');
                    ofn.lpstrInitialDir = szInitialPath;
                    StrCpyN(szFile,pchFilePart,MAX_PATH);
                }

            }
            
            //
            // Work out the title and the filter strings
            //
            if (m_pImpExp->GetExternalType() == BOOKMARKS)
            {
                MLLoadShellLangString(IDS_IMPEXP_CHOSEBOOKMARKFILE,szTitle,MAX_PATH);
                MLLoadShellLangString(IDS_IMPEXP_BOOKMARKFILTER,szFilter,MAX_PATH);
            }
            else
            {
                MLLoadShellLangString(IDS_IMPEXP_CHOSECOOKIEFILE,szTitle,MAX_PATH);
                MLLoadShellLangString(IDS_IMPEXP_COOKIEFILTER,szFilter,MAX_PATH);
            }

            //
            // Search and replace '@' with nul in the filter string
            //
            for (i=0; szFilter[i]; i++)
                if (szFilter[i]==TEXT('@'))
                    szFilter[i]=TEXT('\0');

            //
            // Set the flags for openfilename
            //
            ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY ;
            if (m_pImpExp->GetTransferType() == IMPORT)
                ofn.Flags |= (OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST);

            //
            // Show the dialog
            //
            if(GetSaveFileName(&ofn))
                if(SetWindowText(GetDlgItem(hwndDlg, IDC_IMPEXPMANUAL), ofn.lpstrFile))
                {
                    Button_SetCheck(GetDlgItem( hwndDlg, IDC_IMPEXPRADIOFILE), BST_CHECKED);
                    Button_SetCheck(GetDlgItem( hwndDlg, IDC_IMPEXPRADIOAPP), BST_UNCHECKED);
                }

            retVal = TRUE;
        }
        break;

    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code )
        {

        case PSN_SETACTIVE:
            {

                TCHAR sBuffer[MAX_PATH];
                DWORD cbSize = ARRAYSIZE(sBuffer);

                hwndDlgItem = GetDlgItem( hwndDlg, IDC_IMPEXPEXTERNALCOMBO );
                
                //
                // Load the "application list" into the combo box.
                // If the list is empty, then disable the combo box, 
                // disable the associated radio button, and select the
                // "to/from file" option (the second radio button).
                //
                if( hwndDlgItem != NULL
                    && m_pImpExp && m_pImpExp->PopulateComboBoxForExternalSelection( hwndDlgItem ) )
                {
                    EnableWindow ( GetDlgItem(hwndDlg, IDC_IMPEXPRADIOAPP), TRUE ) ;
                    EnableWindow ( hwndDlgItem, TRUE ) ;
                    Button_SetCheck( GetDlgItem( hwndDlg, IDC_IMPEXPRADIOAPP), BST_CHECKED);
                    Button_SetCheck( GetDlgItem( hwndDlg, IDC_IMPEXPRADIOFILE), BST_UNCHECKED);
                }
                else if ( hwndDlgItem != NULL)
                {
                    EnableWindow ( GetDlgItem(hwndDlg, IDC_IMPEXPRADIOAPP), FALSE ) ;
                    EnableWindow( hwndDlgItem, FALSE ) ;
                    Button_SetCheck( GetDlgItem( hwndDlg, IDC_IMPEXPRADIOFILE), BST_CHECKED);
                    Button_SetCheck( GetDlgItem( hwndDlg, IDC_IMPEXPRADIOAPP), BST_UNCHECKED);
                }
                
                //  Put a default value in the browse option.
                if(m_pImpExp->GetExternalManualDefault(sBuffer, &cbSize))
                    SetDlgItemText(hwndDlg, IDC_IMPEXPMANUAL, sBuffer);

                SHAutoComplete(GetDlgItem(hwndDlg, IDC_IMPEXPMANUAL), SHACF_FILESYSTEM);
            }
            break;

        case PSN_WIZNEXT:
            
            //    If the application radio button is checked,
            //  select the selection from the application combo box.  If
            //  the manual button is checked, select the selection
            //  using the manual edit box.

            retVal = TRUE;
            
            if (Button_GetCheck(GetDlgItem(hwndDlg,IDC_IMPEXPRADIOAPP)) == BST_CHECKED)
            {
                
                HWND hwndComboBox = GetDlgItem(hwndDlg,IDC_IMPEXPEXTERNALCOMBO);
                
                if (hwndComboBox != NULL)
                {
                    // Find out the index of the selected item
                    INT nIndex = ComboBox_GetCurSel(hwndDlg);
                    
                    if (nIndex != CB_ERR)
                    {
                        // Retrieve a pointer to the filename
                        LPTSTR pszFileName = (LPTSTR)ComboBox_GetItemData(hwndComboBox, nIndex);
                        
                        if (pszFileName != NULL)
                            StrCpyN(m_pImpExp->m_szFileName,pszFileName,MAX_PATH);
                        
                    }
                    
                }
            }
            else if (Button_GetCheck(GetDlgItem(hwndDlg,IDC_IMPEXPRADIOFILE)) == BST_CHECKED)
            {
                
                // just get the text from the edit box
                GetDlgItemText(hwndDlg,IDC_IMPEXPMANUAL,m_pImpExp->m_szFileName,MAX_PATH);

                //
                // Don't allow "next" if the edit control contains a bogus filename
                //
                if (!IsValidFileOrURL(m_pImpExp->m_szFileName))
                {
                    
                    TCHAR szFmt[128];
                    TCHAR szMsg[INTERNET_MAX_URL_LENGTH+128];
                    MLLoadShellLangString(IDS_INVALIDURLFILE, szFmt, ARRAYSIZE(szFmt));
                    wnsprintf(szMsg, INTERNET_MAX_URL_LENGTH+40, szFmt, m_pImpExp->m_szFileName);
                    MLShellMessageBox(
                        hwndDlg, 
                        szMsg, 
                        (IMPORT == m_pImpExp->GetTransferType()) ? 
                           MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV) : 
                           MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                        MB_OK);
                    
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                    return retVal;
                }

                //
                // If the user doesn't type an extension, then we add ".htm"
                // or ".txt" as appropriate.  Otherwise, we don't touch it.
                //
                if (*PathFindExtension(m_pImpExp->m_szFileName) == TEXT('\0'))
                {
                    PathRenameExtension(
                        m_pImpExp->m_szFileName,
                        (m_pImpExp->GetExternalType()==COOKIES) ? TEXT(".txt") : TEXT(".htm"));
                }

            }
            else
            {
                ASSERT(0);
                m_pImpExp->m_szFileName[0] = TEXT('\0');
            }

            //
            // Finally, show an overwrite or file-not-found message
            // (but supress it if importing or exporting to a web address)
            //

            if (m_pImpExp->GetExternalType() == COOKIES ||
                !PathIsURL(m_pImpExp->m_szFileName))
            {
                if ( EXPORT == m_pImpExp->GetTransferType() && 
                    GetFileAttributes(m_pImpExp->m_szFileName) != 0xFFFFFFFF )
                {
                    int answer ;
                    UINT idTitle ;
                    
                    if ( m_pImpExp->GetExternalType() == COOKIES )
                        idTitle = IDS_EXPCOOKIES ;
                    else if ( m_pImpExp->GetExternalType() == BOOKMARKS )
                        idTitle = IDS_EXPFAVORITES ;
                    else
                        ASSERT(0);
                    
                    answer = WarningMessageBox(
                        hwndDlg,
                        idTitle,
                        IDS_IMPEXP_FILEEXISTS,
                        m_pImpExp->m_szFileName,
                        MB_YESNO | MB_ICONEXCLAMATION);
                    
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (IDYES==answer)?0:-1);

                }
                else
                {
                    if (IMPORT == m_pImpExp->GetTransferType())
                    {
                        BOOL fError;

                        fError = FALSE;
                        if (PathIsUNC(m_pImpExp->m_szFileName))
                            ;
                        else
                            // Give the user a chance to insert the floppy if it's not already in.
                            fError = FAILED(SHPathPrepareForWriteWrap(hwndDlg,
                                                                      NULL,
                                                                      m_pImpExp->m_szFileName,
                                                                      FO_COPY,
                                                                      (SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME)));

                        if (!fError)
                            fError = (0xFFFFFFFF == GetFileAttributes(m_pImpExp->m_szFileName));

                        if (fError)
                        {
                            UINT idTitle ;
                    
                            if ( m_pImpExp->GetExternalType() == COOKIES )
                                idTitle = IDS_IMPCOOKIES ;
                            else if ( m_pImpExp->GetExternalType() == BOOKMARKS )
                                idTitle = IDS_IMPFAVORITES ;
                            else
                                ASSERT(0);

                            WarningMessageBox(
                                hwndDlg,
                                idTitle,
                                IDS_IMPEXP_FILENOTFOUND,
                                m_pImpExp->m_szFileName,
                                MB_OK | MB_ICONEXCLAMATION);
                    
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                    
                        }
                    }
                }

            }
            
            break; // PSN_WIZNEXT

        } // WM_NOTIFY

        break;
    
    } // switch(msg)

    return retVal;
}

BOOL WINAPI RunImportExportFavoritesWizard(HWND hDlg)
{

    ImpExpUserDlg::RunNewDialogProcess(hDlg);
    return TRUE;

}

int WarningMessageBox(HWND hwnd, UINT idTitle, UINT idMessage, LPCTSTR szFile, DWORD dwFlags)
{

    TCHAR szBuffer[1024];
    TCHAR szFormat[1024];

    //
    // load the string (must contain "%s")
    //
    MLLoadShellLangString(idMessage, szFormat, 1024);
   
    //
    // insert the filename
    //
    wnsprintf(szBuffer,1024,szFormat,szFile);

    //
    // display the messagebox
    //
    return MLShellMessageBox(
        hwnd,
        szBuffer,
        MAKEINTRESOURCE(idTitle),
        dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\inetnot.cpp ===
#include "priv.h"
#include "inetnot.h"

//+-------------------------------------------------------------------------
// Static initialization
//--------------------------------------------------------------------------
HWND  CWinInetNotify::s_hwnd = NULL;
ULONG CWinInetNotify::s_ulEnabled = 0;
CWinInetNotify* CWinInetNotify::s_pWinInetNotify = NULL;

//+-------------------------------------------------------------------------
// Constructor - Creates invisible top-level window.
//--------------------------------------------------------------------------
CWinInetNotify::CWinInetNotify()
:   _hMutex(NULL),
    _fEnabled(FALSE)
{
}

//+-------------------------------------------------------------------------
// Enables/disables wininet notifications
//--------------------------------------------------------------------------
void CWinInetNotify::Enable(BOOL fEnable)
{
    if (fEnable && !_fEnabled)
    {
        //
        // Enable the notifications
        //
        ENTERCRITICAL;
        ++s_ulEnabled;
        if (NULL == s_hwnd)
        {
            // create an invisible top-level window to receive notifications
            WNDCLASS  wc;
            ZeroMemory(&wc, SIZEOF(wc));

            wc.lpfnWndProc      = _WndProc;
            wc.hInstance        = HINST_THISDLL;
            wc.lpszClassName    = CWinInetNotify_szWindowClass;

            SHRegisterClass(&wc);

            s_hwnd = CreateWindow(CWinInetNotify_szWindowClass, NULL, WS_POPUP,
                        0, 0, 1, 1, NULL, NULL, HINST_THISDLL, this);
        }

        if (s_hwnd)
        {
            _fEnabled = TRUE;
        }

        LEAVECRITICAL;
    }
    else if (!fEnable && _fEnabled)
    {
        //
        // Disable the notifications
        //
        ENTERCRITICAL;
        if (--s_ulEnabled == 0)
        {
            //
            // We use a mutex here because we can have multiple instances of
            // iexplore.  We want to avoid setting up a window to accept wininet 
            // notifications if it is in the process of being destroyed.
            //
            _EnterMutex();

            // Look for another window to receive wininet notifications
            if (EnumWindows(EnumWindowsProc, NULL))
            {
                // No one left so turn off notifications
                RegisterUrlCacheNotification(0, 0, 0, 0, 0);
            }

            //
            // Handle any queued notifications.
            //
            // Note that we have a small window in which a notification
            // can be lost!  Something could be posted to us after we are
            // destroyed!
            //
            MSG msg;
            if (PeekMessage(&msg, s_hwnd, CWM_WININETNOTIFY, CWM_WININETNOTIFY, PM_REMOVE))
            {
                _OnNotify(msg.wParam);
            }

            DestroyWindow(s_hwnd);
            s_hwnd = NULL;

            // Now that our window is gone, we can allow other processes to
            // look for windows to receive notifications.
            _LeaveMutex();
        }
        LEAVECRITICAL;

        _fEnabled = FALSE;
    }
}

//+-------------------------------------------------------------------------
// Destructor - Destroys top-level window when last instance is destroyed
//--------------------------------------------------------------------------
CWinInetNotify::~CWinInetNotify()
{
    Enable(FALSE);
}

//+-------------------------------------------------------------------------
// Called for each top level window to find another one to accept wininet
// notifications.
//--------------------------------------------------------------------------
BOOL CALLBACK CWinInetNotify::EnumWindowsProc
(
    HWND hwnd,      // handle to top-level window
    LPARAM lParam   // application-defined value 
 
)
{
    // Ignore our own window
    if (hwnd == s_hwnd)
        return TRUE;

    // See if it's one of our windows
    TCHAR szWindowClass[30];
    if (GetClassName(hwnd, szWindowClass, ARRAYSIZE(szWindowClass)) &&
        StrCmp(CWinInetNotify_szWindowClass, szWindowClass) == 0)
    {
        _HookInetNotifications(hwnd);
        return FALSE;
    }
    return TRUE;
}
 
//+-------------------------------------------------------------------------
// Hooks up wininet notifications.
//--------------------------------------------------------------------------
void CWinInetNotify::_HookInetNotifications(HWND hwnd)
{
    // We always want to know when cache items become sticky or unstickey
    // or transition between online and offline
    DWORD dwFlags = CACHE_NOTIFY_URL_SET_STICKY |
                    CACHE_NOTIFY_URL_UNSET_STICKY |
                    CACHE_NOTIFY_SET_ONLINE |
                    CACHE_NOTIFY_SET_OFFLINE ;

    //
    // We only care about things being added to or removed from the
    // cache when we are offline.  The name-space-control greys unavailable
    // items when we are offline.
    //
    if (SHIsGlobalOffline())
    {
        dwFlags |= CACHE_NOTIFY_ADD_URL | CACHE_NOTIFY_DELETE_URL | CACHE_NOTIFY_DELETE_ALL;
    }

    RegisterUrlCacheNotification(hwnd, CWM_WININETNOTIFY, 0, dwFlags, 0);
}

//+-------------------------------------------------------------------------
// Re-broadcasts the notification using SHChangeNotify
//--------------------------------------------------------------------------
void CWinInetNotify::_OnNotify(DWORD_PTR dwFlags)
{
    // Remove any other queued notifications
    MSG msg;
    while (PeekMessage(&msg, s_hwnd, CWM_WININETNOTIFY, CWM_WININETNOTIFY, PM_REMOVE))
    {
        // Combine the notification bits
        dwFlags |= msg.wParam;
    }

    SHChangeDWORDAsIDList dwidl;
    // Align for UNIX
    dwidl.cb      = (unsigned short) PtrDiff(& dwidl.cbZero, &dwidl);
    dwidl.dwItem1 = SHCNEE_WININETCHANGED;
    dwidl.dwItem2 = (DWORD)dwFlags;
    dwidl.cbZero  = 0;

    SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, (LPCITEMIDLIST)&dwidl, NULL);

    // If we are switching between online and offline, we need to update the
    // events that we are interested in.
    if (dwFlags & (CACHE_NOTIFY_SET_ONLINE | CACHE_NOTIFY_SET_OFFLINE))
    {
        _HookInetNotifications(s_hwnd);
    }
}

//+-------------------------------------------------------------------------
// Window procedure for our invisible top-level window.  Receives
// notifications from wininet.
//--------------------------------------------------------------------------
LRESULT CALLBACK CWinInetNotify::_WndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
        case WM_CREATE:
        {
            // Hook us up to get the notifications
            _HookInetNotifications(hwnd);
            break;
        }

        case CWM_WININETNOTIFY:
        {
            _OnNotify(wParam);
            return 0;
        }
    }

    return DefWindowProcWrap(hwnd, uMessage, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Protect simultaneous access by multiple processes
//--------------------------------------------------------------------------
void CWinInetNotify::_EnterMutex()
{
    ASSERT(_hMutex == NULL);

    // This gets an existing mutex if one exists
    _hMutex = CreateMutex(NULL, FALSE, CWinInetNotify_szWindowClass);

    // Wait for up to 20 seconds
    if (!_hMutex || WaitForSingleObject(_hMutex, 20000) == WAIT_TIMEOUT)
    {
        ASSERT(FALSE);
    }
}

void CWinInetNotify::_LeaveMutex()
{
    if (_hMutex)
    {
        ReleaseMutex(_hMutex);
        CloseHandle(_hMutex);
        _hMutex = NULL;
    }
}


//+-------------------------------------------------------------------------
// Manages a global CWinInetNotify object
//--------------------------------------------------------------------------
void CWinInetNotify::GlobalEnable()
{
    if (s_pWinInetNotify == NULL)
    {
        ENTERCRITICAL;
        if (s_pWinInetNotify == NULL)
        {
            s_pWinInetNotify = new CWinInetNotify();
            if (s_pWinInetNotify)
            {
                s_pWinInetNotify->Enable();
            }
        }
        LEAVECRITICAL;
    }
}

void CWinInetNotify::GlobalDisable()
{
    ENTERCRITICAL;
    if (s_pWinInetNotify)
    {
        delete s_pWinInetNotify;
        s_pWinInetNotify = NULL;
    }
    LEAVECRITICAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\infotip.cpp ===
#include "priv.h"
#include "infotip.h"
#include "resource.h"

#include <mluisupp.h>

HRESULT ReadProp(IPropertyStorage *ppropstg, PROPID propid, PROPVARIANT *ppropvar)
{
    PROPSPEC prspec = { PRSPEC_PROPID, propid };

    return ppropstg->ReadMultiple(1, &prspec, ppropvar);
}

STDAPI GetStringProp(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf)
{
    PROPVARIANT propvar;

    *pszBuf = 0;

    if (S_OK == ReadProp(ppropstg, propid, &propvar))
    {
        if (VT_LPWSTR == propvar.vt)
        {
            SHUnicodeToTChar(propvar.pwszVal, pszBuf, cchBuf);
        }
        else if (VT_LPSTR == propvar.vt)
        {
            SHAnsiToTChar(propvar.pszVal, pszBuf, cchBuf);
        }
        PropVariantClear(&propvar);
    }

    return *pszBuf ? S_OK : S_FALSE;
}

STDAPI GetFileTimeProp(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf)
{
    PROPVARIANT propvar;

    *pszBuf = 0;

    if (S_OK == ReadProp(ppropstg, propid, &propvar))
    {
        if (VT_FILETIME == propvar.vt)
        {
            SHFormatDateTime(&propvar.filetime, NULL, pszBuf, cchBuf);
        }
        PropVariantClear(&propvar);
    }

    return *pszBuf ? S_OK : S_FALSE;
}


DWORD AppendTipText(LPTSTR pszBuf, int cchBuf, UINT ids, ...)
{
    DWORD dwRet;
    TCHAR szFmt[64];
    va_list ArgList;

    if (ids == 0 || 0 == MLLoadString(ids, szFmt, SIZECHARS(szFmt)))
        StrCpyN(szFmt, TEXT("%s%s"), ARRAYSIZE(szFmt));

    va_start(ArgList, ids);
    dwRet = wvnsprintf(pszBuf, cchBuf, szFmt, ArgList);
    va_end(ArgList);

    return dwRet;
}

STDAPI GetInfoTipFromStorage(IPropertySetStorage *ppropsetstg, const ITEM_PROP *pip, WCHAR **ppszTip)
{
    TCHAR szTip[2048];
    LPTSTR psz = szTip;
    LPCTSTR pszCRLF = TEXT("");
    UINT cch, cchMac = SIZECHARS(szTip);
    const GUID *pfmtIdLast = NULL;
    IPropertyStorage *ppropstg = NULL;
    HRESULT hres = E_FAIL;

    *ppszTip = NULL;

    for (; pip->pfmtid; pip++)
    {
        // cache the last FMTID and reuse it if the next FMTID is the same

        if (!ppropstg || !IsEqualGUID(*pfmtIdLast, *pip->pfmtid))
        {
            if (ppropstg)
            {
                ppropstg->Release();
                ppropstg = NULL;
            }

            pfmtIdLast = pip->pfmtid;
            ppropsetstg->Open(*pip->pfmtid, STGM_READ | STGM_SHARE_EXCLUSIVE, &ppropstg);
        }

        if (ppropstg)
        {
            TCHAR szT[256];

            hres = pip->pfnRead(ppropstg, pip->idProp, szT, SIZECHARS(szT));
            if (S_OK == hres) 
            {
                cch = AppendTipText(psz, cchMac, pip->idFmtString, pszCRLF, szT);
                psz += cch;
                cchMac -= cch;
                pszCRLF = TEXT("\r\n");
            }
            else if (hres != S_FALSE)
            {
                break;  // error, exit for loop
            }
        }
    }

    if (ppropstg)
        ppropstg->Release();

    hres = S_FALSE;     // assume no tooltip

    if (psz != szTip)
    {
        hres = SHStrDup(szTip, ppszTip);
    }

    return hres;
}

class CDocFileInfoTip : public IPersistFile, public IQueryInfo
{
public:
    CDocFileInfoTip(void);

    // IUnknown methods
    STDMETHODIMP  QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IPersist methods

    STDMETHODIMP GetClassID(CLSID *pclsid);

    // IPersistFile methods

    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Save(LPCOLESTR pcwszFileName, BOOL bRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pcwszFileName);
    STDMETHODIMP Load(LPCOLESTR pcwszFileName, DWORD dwMode);
    STDMETHODIMP GetCurFile(LPOLESTR *ppwszFileName);

    // IQueryInfo methods

    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

private:

    LONG    m_cRef;
    WCHAR   m_szFile[MAX_PATH]; // Name of file we are working on

    ~CDocFileInfoTip(void);    // Prevent this class from being allocated on the stack or it will fault.
};


CDocFileInfoTip::CDocFileInfoTip(void) : m_cRef(1)
{
    DllAddRef();
}

CDocFileInfoTip::~CDocFileInfoTip(void)
{
    DllRelease();
}

STDMETHODIMP CDocFileInfoTip::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDocFileInfoTip, IQueryInfo),                     // IID_IQueryInfo
        QITABENT(CDocFileInfoTip, IPersistFile),                   // IID_IPersistFile
        QITABENTMULTI(CDocFileInfoTip, IPersist, IPersistFile),    // IID_IPersist
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDocFileInfoTip::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CDocFileInfoTip::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

// IPersist methods

STDMETHODIMP CDocFileInfoTip::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_DocFileInfoTip;
    return S_OK;
}

// IPersistFile methods

STDMETHODIMP CDocFileInfoTip::IsDirty(void)
{
    return S_FALSE;
}

STDMETHODIMP CDocFileInfoTip::Save(LPCOLESTR pwszFile, BOOL bRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocFileInfoTip::SaveCompleted(LPCOLESTR pwszFile)
{
    return S_OK;
}

STDMETHODIMP CDocFileInfoTip::Load(const WCHAR *pwszFile, DWORD dwMode)
{
    StrCpyNW(m_szFile, pwszFile, ARRAYSIZE(m_szFile));
    return S_OK;
}

STDMETHODIMP CDocFileInfoTip::GetCurFile(WCHAR **ppwszFile)
{
    return E_NOTIMPL;
}

// IQueryInfo methods

const ITEM_PROP c_rgDocProps[] = {
    { &FMTID_SummaryInformation, PIDSI_AUTHOR,       GetStringProp,      IDS_AUTHOR },
    { &FMTID_SummaryInformation, PIDSI_TITLE,        GetStringProp,      IDS_DOCTITLE },
    { &FMTID_SummaryInformation, PIDSI_SUBJECT,      GetStringProp,      IDS_SUBJECT },
    { &FMTID_SummaryInformation, PIDSI_COMMENTS,     GetStringProp,      IDS_COMMENTS },
    { NULL, 0, 0, 0 },
};


STDMETHODIMP CDocFileInfoTip::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    *ppwszTip = NULL;
    IStorage *pstg;
    HRESULT hres = StgOpenStorage(m_szFile, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, 0, &pstg);
    if (SUCCEEDED(hres))
    {
        IPropertySetStorage *pprop;
        hres = pstg->QueryInterface(IID_IPropertySetStorage, (void **)&pprop);
        if (SUCCEEDED(hres))
        {
            hres = GetInfoTipFromStorage(pprop, c_rgDocProps, ppwszTip);
            pprop->Release();
        }
        pstg->Release();
    }
    return hres;
}

STDMETHODIMP CDocFileInfoTip::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return S_OK;
}

STDAPI CDocFileInfoTip_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;
    CDocFileInfoTip *pis = new CDocFileInfoTip();
    if (pis)
    {
        *ppunk = SAFECAST(pis, IQueryInfo *);
        hres = S_OK;
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\ipstg.cpp ===
#include "priv.h"
#include "ipstg.h"

HRESULT CImpIPersistStorage::InitNew(IStorage *pStg)
{
    return InitNew();
}

HRESULT CImpIPersistStorage::Load(IStorage *pStg)
{
    HRESULT hres = E_INVALIDARG;

    if (EVAL(pStg))
    {
        IStream* pstm = NULL;
        hres = pStg->OpenStream(L"CONTENTS",0,STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pstm);
        if (EVAL(SUCCEEDED(hres)))
        {
            pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
            hres = Load(pstm);
            pstm->Release();
        }
    }

    return hres;
}

HRESULT CImpIPersistStorage::Save(IStorage *pStgSave, BOOL fSameAsLoad)
{
    HRESULT hres = E_INVALIDARG;

    if (EVAL(pStgSave))
    {
        IStream* pstm = NULL;
        hres = pStgSave->CreateStream(L"CONTENTS",STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
        if (EVAL(SUCCEEDED(hres)))
        {
            pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
            hres = Save(pstm, TRUE);
            pstm->Release();
        }
    }

    return hres;
}

HRESULT CImpIPersistStorage::SaveCompleted(IStorage *pStgNew)
{
    return S_OK;
}

HRESULT CImpIPersistStorage::HandsOffStorage(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\ipstg.h ===
#ifndef __IPSTG_H__
#define __IPSTG_H__

//
// CImpIPersistStorage works very well along-side an IPersistStreamInit
// implementation.
//
// IE30's CShellEmbedding implemented this interface because it was
// an embedding must-have. But none of our objects were marked as
// embeddable, so we really didn't need it.
//
// I pulled the implementation to a new class that can easily be
// included into any object that needs an IPersistStorange implementation
// that delegates to the object's IPersistStreamInit implementation.
//
class CImpIPersistStorage : public IPersistStorage
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    // *** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) PURE;

    // *** IPersistStorage ***
    virtual STDMETHODIMP IsDirty(void) PURE; // matches IPersistStreamInit
    virtual STDMETHODIMP InitNew(IStorage *pStg);
    virtual STDMETHODIMP Load(IStorage *pStg);
    virtual STDMETHODIMP Save(IStorage *pStgSave, BOOL fSameAsLoad);
    virtual STDMETHODIMP SaveCompleted(IStorage *pStgNew);
    virtual STDMETHODIMP HandsOffStorage(void);

    // These happen to match IPersistStreamInit methods.
    // They should update the dirty state of the object as
    // returned from IsDirty().
    //
    virtual STDMETHODIMP Load(IStream *pStm) PURE;
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) PURE;
    virtual STDMETHODIMP InitNew(void) PURE;
};

#endif // __IPSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\inst.cpp ===
//***   inst.cpp -- 'instance' (CoCreate + initialization) mechanism
// SYNOPSIS
//  CInstClassFactory_Create    create 'stub loader' class factory
//  InstallBrowBandInst install BrowserBand instance into registry
//  InstallInstAndBag   install arbitrary instance into registry
//  - debug
//  DBCreateInitInst    create an
//
// DESCRIPTION
//  the 'instance' mechanism provides an easy way to create and initialize
//  a class from the registry (w/o writing any code).
//
//  an 'instance' consists of an INSTID (unique to the instance), a CLSID
//  (for the code), and an InitPropertyBag (to initialize the instance).
//
//  it is fully transparent to CoCreateInstance; that is, one can do a
//  CCI of an INSTID and it will create it and initialize it w/ the caller
//  none the wiser.  (actually there will be at least one tip-off, namely
//  that IPS::GetClassID on the instance will return the 'code' CLSID not
//  the 'instance' INSTID [which is as it should be, since this is exactly
//  how persistance works when one programmatically creates his own multiple
//  instances and then persists them. 
//
//  the INSTID is in the HKR/CLSID section of the registry (just like a
//  'normal' CLSID).  the code points to shdocvw.  when shdocvw hits the
//  failure case in its DllGetClassObject search, it looks for the magic
//  key 'HKCR/CLSID/{instid}/Instance'.  if it finds it, it knows it's
//  dealing w/ an INSTID, and builds a class factory 'stub loader' which
//  has sufficient information to find the 'code' CLSID and the 'init'
//  property bag.

#include "priv.h"

//***
// NOTES
//  perf: failure case is cheap, only does a RegOpen, no object creation.
//  positions to the 'Instance' part, must 'ChDir' to get to InitXxx part.
HKEY GetInstKey(LPTSTR pszInst)
{
    TCHAR szRegName[MAX_PATH];      // "CLSID/{instid}/Instance" size?

    // "CLSID/{instid}/Instance"
    ASSERT(ARRAYSIZE(szRegName) >= 5 + 1 + GUIDSTR_MAX - 1 + 1 + 8 + 1);
    ASSERT(lstrlen(pszInst) == GUIDSTR_MAX - 1);
    wnsprintf(szRegName, ARRAYSIZE(szRegName), TEXT("CLSID\\%s\\Instance"), pszInst);

    HKEY hk = NULL;
    RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegName, 0, KEY_READ, &hk);
    return hk;
}

class CInstClassFactory : IClassFactory
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFacotry
    STDMETHODIMP CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    STDMETHODIMP LockServer(BOOL fLock);

    CInstClassFactory() { DllAddRef(); _cRef = 1; };
    HRESULT Init(REFCLSID rclsid);

private:
    ~CInstClassFactory();

    LONG _cRef;
    HKEY _hkey;  // hkey for instance info
};

// NOTES
//  called when class isn't in our sccls.c CCI table.  we see if it's an
// instance, and if so we make a stub for it that gives sufficient info
// for our CreateInstance to create and init it.
//
//  n.b. we keep the failure case as cheap as possible (just a regkey check,
// no object creation etc.).
//
STDAPI CInstClassFactory_Create(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CInstClassFactory *pcf = new CInstClassFactory();
    if (pcf) 
    {
        hr = pcf->Init(rclsid);
        if (SUCCEEDED(hr))
            hr = pcf->QueryInterface(riid, ppv);
        pcf->Release();
    }
    return hr;
}

HRESULT CInstClassFactory::Init(REFCLSID rclsid)
{
    ASSERT(_hkey == NULL);  // only init me once please

    TCHAR szClass[GUIDSTR_MAX];

    // "CLSID/{instid}/Instance"
    SHStringFromGUID(rclsid, szClass, ARRAYSIZE(szClass));
    _hkey = GetInstKey(szClass);
    
    return _hkey ? S_OK : E_OUTOFMEMORY;
}

CInstClassFactory::~CInstClassFactory()
{
    if (_hkey)
        RegCloseKey(_hkey);

    DllRelease();
}

ULONG CInstClassFactory::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CInstClassFactory::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CInstClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CInstClassFactory, IClassFactory), // IID_IClassFactory
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CInstClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;            // the usual optimism :-)
    *ppv = NULL;

    ASSERT(_hkey);          // o.w. shouldn't ever get here
    // get object (vs. instance) CLSID and create it

    // AppCompat: the "RealGuide" explorer bar from Real Audio has an extraneous
    // double quote at the end of its CLSID value.  This causes SHGetValue to fail
    // if given only an szClass[GUIDSTR_MAX] buffer, so we'll bump up the size.  

    TCHAR szClass[GUIDSTR_MAX + 1];

    DWORD cbTmp = sizeof(szClass);
    DWORD err = SHGetValue(_hkey, NULL, TEXT("CLSID"), NULL, szClass, &cbTmp);
    hr = HRESULT_FROM_WIN32(err);

    if (SUCCEEDED(hr))
    {
        // If there's a useless char at the end of the guid, we'll truncate it
        // to avoid making assumptions about GUIDFromString.  GUIDSTR_MAX includes
        // the null terminator, so szClass[GUIDSTR_MAX - 1] should always be 0
        // for a proper guid.

        szClass[GUIDSTR_MAX - 1] = 0;

        CLSID clsid;
        hr = GUIDFromString(szClass, &clsid) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            IUnknown* pUnk;
            if (NOERROR == SHGetValue(_hkey, NULL, TEXT("LoadWithoutCOM"), NULL, NULL, NULL))
                hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IUnknown, &pUnk));
            else
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &pUnk));

            if (SUCCEEDED(hr))
            {
                // try to load from propertybag first
                IPropertyBag *pbag;
                hr = SHCreatePropertyBagOnRegKey(_hkey, L"InitPropertyBag", STGM_READ, IID_PPV_ARG(IPropertyBag, &pbag));
                if (SUCCEEDED(hr))
                {
                    hr = SHLoadFromPropertyBag(pUnk, pbag);
                    pbag->Release();
                }

                // Did the property bag interface exist and did it load properly?
                if ( FAILED(hr))
                {
                    // No property bag interface or did not load suyccessfully, try stream
                    // Store this state temporarily, if stream fails too then we'll return the object
                    //  with this hr
                    HRESULT hrPropBag = hr;

                    IPersistStream* pPerStream;

                    hr = pUnk->QueryInterface(IID_PPV_ARG(IPersistStream, &pPerStream));

                    if (SUCCEEDED(hr))
                    {
                        IStream* pStream = SHOpenRegStream(_hkey, TEXT("InitStream"), NULL, STGM_READ);
                        if (pStream)
                        {
                            hr = pPerStream->Load(pStream);

                            pStream->Release();
                        }
                        else
                            hr = E_FAIL;

                        pPerStream->Release();
                    }
                    else
                        hr = hrPropBag;
                }

                if (SUCCEEDED(hr))
                {
                    hr = pUnk->QueryInterface(riid, ppv);
                }

                pUnk->Release();
            }  
        }
    }

    return hr;
}

HRESULT CInstClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\isbase.cpp ===
/*
 * isbase.cpp - IUnknown implementation for Intshcut class.
 */

#include "priv.h"
#include "sccls.h"
#include "ishcut.h"


HRESULT IsProtocolRegistered(LPCTSTR pcszProtocol)
{
    HRESULT hres = S_OK;

    ASSERT(IS_VALID_STRING_PTR(pcszProtocol, -1));

    if (NO_ERROR != SHGetValue(HKEY_CLASSES_ROOT, pcszProtocol, TEXT("URL Protocol"),
                               NULL, NULL, NULL))
    {
        TraceMsg(TF_ERROR, "IsProtocolRegistered(): Protocol \"%s\" is not registered.",
                 pcszProtocol);

        hres = URL_E_UNREGISTERED_PROTOCOL;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Takes the given URL and returns an allocated string
         containing the protocol.  Also optionally returns the
         parsed-url structure.

Returns: S_OK if the URL was parsed
Cond:    --
*/
STDAPI
CopyURLProtocol(
    IN  LPCTSTR     pcszURL,
    OUT LPTSTR *    ppszProtocol,
    OUT PARSEDURL * ppu)            OPTIONAL
{
    HRESULT hr;
    PARSEDURL pu;

    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppszProtocol, PTSTR));

    if (NULL == ppu)
        ppu = &pu;

    *ppszProtocol = NULL;

    ppu->cbSize = SIZEOF(*ppu);
    hr = ParseURL(pcszURL, ppu);

    if (hr == S_OK)
    {
        *ppszProtocol = (LPTSTR)LocalAlloc(LPTR, CbFromCch(ppu->cchProtocol + 1));
        if (*ppszProtocol)
        {
            // Just copy the protocol portion of string
            StrCpyN(*ppszProtocol, ppu->pszProtocol, ppu->cchProtocol + 1);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    ASSERT(FAILED(hr) ||
           (hr == S_OK &&
            IS_VALID_STRING_PTR(*ppszProtocol, -1)));

    return(hr);
}


HRESULT ValidateURL(LPCTSTR pcszURL)
{
    HRESULT hr;
    LPTSTR pszProtocol;

    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));

    hr = CopyURLProtocol(pcszURL, &pszProtocol, NULL);

    if (hr == S_OK)
    {
        hr = IsProtocolRegistered(pszProtocol);

        LocalFree(pszProtocol);
        pszProtocol = NULL;
    }

    return(hr);
}

HRESULT ValidateWorkingDirectory(LPCTSTR pcszWorkingDirectory)
{
    ASSERT(IS_VALID_STRING_PTR(pcszWorkingDirectory, -1));

    return(PathIsDirectory(pcszWorkingDirectory) ? S_OK : E_PATH_NOT_FOUND);
}

#define SUBS_DEL_TIMEOUT 3000

void DeleteSubsOnShortcutDelete(void *pData, BOOLEAN)
{
    IS_SUBS_DEL_DATA *pSubsDelData = (IS_SUBS_DEL_DATA *)pData;
    ASSERT(NULL != pData);
    ASSERT(0 != pSubsDelData->m_szFile[0]);
    ASSERT(0 != pSubsDelData->m_pwszURL[0]);

    if ((((DWORD)-1) == GetFileAttributes(pSubsDelData->m_szFile)) &&
        (ERROR_FILE_NOT_FOUND == GetLastError()))
    {
        if (SUCCEEDED(CoInitialize(NULL)))
        {
            ISubscriptionMgr2 *pSubsMgr2;

            if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr,
                                           NULL,
                                           CLSCTX_INPROC_SERVER,
                                           IID_ISubscriptionMgr2,
                                           (void **)&pSubsMgr2)))
            {
                pSubsMgr2->DeleteSubscription(pSubsDelData->m_pwszURL, NULL);
                pSubsMgr2->Release();
            }
            CoUninitialize();
        }
    }
    delete pSubsDelData;
}

#ifdef DEBUG

BOOL IsValidPCIntshcut(PCIntshcut pcintshcut)
{
    return(IS_VALID_READ_PTR(pcintshcut, CIntshcut) &&
           FLAGS_ARE_VALID(pcintshcut->m_dwFlags, ISF_ALL) &&
           (! pcintshcut->m_pszFile ||
            IS_VALID_STRING_PTR(pcintshcut->m_pszFile, -1)) &&
           EVAL(! pcintshcut->m_pszFolder ||
                IsValidPath(pcintshcut->m_pszFolder)) &&
           EVAL(! pcintshcut->m_pprop ||
                IS_VALID_STRUCT_PTR(pcintshcut->m_pprop, CIntshcutProp)) &&
           EVAL(! pcintshcut->m_psiteprop ||
                IS_VALID_STRUCT_PTR(pcintshcut->m_psiteprop, CIntsiteProp)));
}

#endif

Intshcut::Intshcut(void) : m_cRef(1)
{
    DllAddRef();
   // Intshcut objects should always be allocated
   ASSERT(ISF_DEFAULT == m_dwFlags);
   ASSERT(NULL == m_pszFile);
   ASSERT(NULL == m_pszFolder);
   ASSERT(NULL == m_pprop);
   ASSERT(NULL == m_psiteprop);
   ASSERT(NULL == _punkSite);
   ASSERT(NULL == m_pszTempFileName);
   ASSERT(NULL == m_pszDescription);
   ASSERT(NULL == m_pszFileToLoad);
   ASSERT(!m_fMustLoadSync);
   ASSERT(!m_bCheckForDelete);
   // Init our registered data formats
   InitClipboardFormats();

   ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

   return;
}

Intshcut::~Intshcut(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    if (m_bCheckForDelete)
    {
        if (NULL != m_pszFile)
        {
            IS_SUBS_DEL_DATA *pSubsDelData = new IS_SUBS_DEL_DATA;

            if (NULL != pSubsDelData)
            {
                HRESULT hr = GetURL(&pSubsDelData->m_pwszURL);

                if (SUCCEEDED(hr))
                {
                    StrCpyN(pSubsDelData->m_szFile, m_pszFile, ARRAYSIZE(pSubsDelData->m_szFile));
                    HANDLE hTimer = SHSetTimerQueueTimer(NULL,
                                                         DeleteSubsOnShortcutDelete,
                                                         pSubsDelData,
                                                         SUBS_DEL_TIMEOUT,
                                                         0,
                                                         NULL,
                                                         FALSE);
                    if (NULL == hTimer)
                    {
                        hr = E_FAIL;
                    }
                }

                if (FAILED(hr))
                {
                    delete pSubsDelData;
                }
            }
        }
        else
        {
            ASSERT(FALSE);  //  m_bCheckForDelete only gets set to TRUE in the context menu code
        }
    }

    Str_SetPtr(&m_pszFile, NULL);
    Str_SetPtr(&m_pszFileToLoad, NULL);
    if (m_pprop)
    {
        delete m_pprop;
        m_pprop = NULL;
    }

    if (m_psiteprop)
    {
        delete m_psiteprop;
        m_psiteprop = NULL;
    }

    if (m_pInitDataObject)
    {
        m_pInitDataObject->Release();
        m_pInitDataObject = NULL;
    }

    SetSite(NULL);

    if(m_pszTempFileName)
    {
        DeleteFile(m_pszTempFileName);
        Str_SetPtr(&m_pszTempFileName, NULL);
    }

    Str_SetPtr(&m_pszFolder, NULL);
    Str_SetPtr(&m_pszDescription, NULL);
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    ATOMICRELEASE(_punkLink);
    
    DllRelease();

    return;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface handler for Intshcut

Returns:
Cond:    --
*/
STDMETHODIMP Intshcut::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    // We try and delay when we load the file specified by IPersistFile::Load
    // until someone asks for an interface that actually needs that file.
    // So put the "safe" interfaces that don't require this in this first
    // table here, and all the "must load" interfaces in the second table:
    //
    static const QITAB qitDontLoad[] = {
        QITABENT(Intshcut, IExtractIconW),      // IID_IExtractIconW
        QITABENT(Intshcut, IExtractIconA),      // IID_IExtractIconA
        QITABENT(Intshcut, IPersistFile),       // IID_IPersistFile
        QITABENTMULTI(Intshcut, IPersist, IPersistFile), // IID_IPersist
        { 0 },
    };

    static const QITAB qitMustLoad[] = {        
        QITABENT(Intshcut, IContextMenu2),      // IID_IContextMenu2
        QITABENTMULTI(Intshcut, IContextMenu, IContextMenu2), // IID_IContextMenu
        QITABENT(Intshcut, IDataObject),        // IID_IDataObject
        QITABENT(Intshcut, INewShortcutHookW),  // IID_INewShortcutHookW
        QITABENT(Intshcut, INewShortcutHookA),  // IID_INewShortcutHookA
        QITABENT(Intshcut, IPersistStream),     // IID_IPersistStream
        QITABENT(Intshcut, IPropertySetStorage),// IID_IPropertySetStorage
        QITABENT(Intshcut, IShellExtInit),      // IID_IShellExtInit
        QITABENT(Intshcut, IShellLinkA),        // IID_IShellLinkA
        QITABENT(Intshcut, IShellLinkW),        // IID_IShellLinkW
        QITABENT(Intshcut, IShellPropSheetExt), // IID_IShellPropSheetExt
        QITABENT(Intshcut, IUniformResourceLocatorA),   // IID_IUniformResourceLocatorA
        QITABENT(Intshcut, IUniformResourceLocatorW),   // IID_IUniformResourceLocatorW
        QITABENT(Intshcut, IQueryInfo),         // IID_IQueryInfo
        QITABENT(Intshcut, IQueryCodePage),     // IID_IQueryCodePage
        QITABENT(Intshcut, INamedPropertyBag),  // IID_INamedPropertyBag
        QITABENT(Intshcut, IObjectWithSite),    // IID_IObjectWithSite
        QITABENT(Intshcut, IOleCommandTarget),  // IID_IOleCommandTarget
        { 0 },
    };

    HRESULT hres = QISearch(this, qitDontLoad, riid, ppvObj);
    if (FAILED(hres))
    {
        hres = QISearch(this, qitMustLoad, riid, ppvObj);
        if (SUCCEEDED(hres))
        {
            m_fMustLoadSync = TRUE;
            if (m_pszFileToLoad)
            {
                LoadFromAsyncFileNow();
            }
        }
    }
    return hres;
}

STDMETHODIMP_(ULONG) Intshcut::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) Intshcut::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

STDMETHODIMP Intshcut::InitProp()
{
    HRESULT hres;

    if (m_pprop)
        hres = S_OK;
    else
    {
        m_pprop = new IntshcutProp;
        if (m_pprop)
        {
            // m_pszFile may be NULL here
            hres = m_pprop->InitFromFile(m_pszFile);
            if (FAILED(hres))
            {
                delete m_pprop;
                m_pprop = NULL;
            }
        }
        else
            hres = E_OUTOFMEMORY;
    }

    return hres;
}

STDMETHODIMP Intshcut::InitSiteProp(void)
{
    HRESULT hres = InitProp();
    if (SUCCEEDED(hres))
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        hres = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        if (NULL == m_psiteprop && SUCCEEDED( hres ))
        {
            m_psiteprop = new IntsiteProp;
            if (m_psiteprop)
            {
                hres = m_psiteprop->InitFromDB(szURL, this, TRUE);
                if (FAILED(hres))
                {
                    delete m_psiteprop;
                    m_psiteprop = NULL;
                }
            }
            else
                hres = E_OUTOFMEMORY;
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Only copy the property if it is different.  Return
         TRUE if it was.

*/
BOOL CopyChangedProperty(IntshcutProp * pprop, PROPID pid,
                         IntsiteProp * psiteprop, PROPID pidSite,
                         BOOL bCopyToDB)
{
    BOOL bRet = FALSE;
    TCHAR szBuf[1024];
    TCHAR szBufSite[1024];

    pprop->GetProp(pid, szBuf, SIZECHARS(szBuf));
    psiteprop->GetProp(pidSite, szBufSite, SIZECHARS(szBufSite));
    StrTrim(szBuf, TEXT(" "));
    StrTrim(szBufSite, TEXT(" "));
    if (StrCmp(szBuf, szBufSite))
    {
        if (bCopyToDB)
            psiteprop->SetProp(pidSite, szBuf);
        else
            pprop->SetProp(pid, szBufSite);
        bRet = TRUE;
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: Mirror the following properties between FMTID_INTSHCUT
         and FMTID_INTSITE:

            PID_IS_WHATSNEW     <---->  PID_INTSITE_WHATSNEW
            PID_IS_DESCRIPTION  <---->  PID_INTSITE_DESCRIPTION
            PID_IS_AUTHOR       <---->  PID_INTSITE_AUTHOR
            PID_IS_COMMENT      <---->  PID_INTSITE_COMMENT

Returns:
Cond:    --
*/
STDMETHODIMP Intshcut::MirrorProperties(void)
{
    HRESULT hres = InitSiteProp();
    if (SUCCEEDED(hres))
    {
        STATPROPSETSTG statSite;
        STATPROPSETSTG stat;
        LONG lRet;

        // Get the times that the properties were set.  The later
        // time becomes the source.
        m_psiteprop->Stat(&statSite);
        m_pprop->Stat(&stat);

        // Don't do anything if the times are equal

        lRet = CompareFileTime(&stat.mtime, &statSite.mtime);
        if (0 != lRet)
        {
            BOOL bChanged = FALSE;
            BOOL bCopyToDB = (0 < lRet);

            bChanged |= CopyChangedProperty(m_pprop, PID_IS_WHATSNEW, m_psiteprop, PID_INTSITE_WHATSNEW, bCopyToDB);
            bChanged |= CopyChangedProperty(m_pprop, PID_IS_DESCRIPTION, m_psiteprop, PID_INTSITE_DESCRIPTION, bCopyToDB);
            bChanged |= CopyChangedProperty(m_pprop, PID_IS_AUTHOR, m_psiteprop, PID_INTSITE_AUTHOR, bCopyToDB);
            bChanged |= CopyChangedProperty(m_pprop, PID_IS_COMMENT, m_psiteprop, PID_INTSITE_COMMENT, bCopyToDB);

            if (bChanged)
            {
                if (bCopyToDB)
                {
                    m_psiteprop->SetTimes(&stat.mtime, NULL, NULL);
                    m_psiteprop->Commit(STGC_DEFAULT);

                    TraceMsg(TF_INTSHCUT, "Mirroring properties of %s to the central database", Dbg_SafeStr(m_pszFile));
                }
                else
                {
                    m_pprop->SetTimes(&statSite.mtime, NULL, NULL);
                    m_pprop->Commit(STGC_DEFAULT);

                    TraceMsg(TF_INTSHCUT, "Mirroring properties of %s to the .url file", Dbg_SafeStr(m_pszFile));
                }
            }
        }

        hres = S_OK;
    }

    return hres;
}


STDMETHODIMP_(void) Intshcut::ChangeNotify(LONG wEventId, UINT uFlags)
{
    if (m_pszFile)
        SHChangeNotify(wEventId, uFlags | SHCNF_PATH, m_pszFile, 0);
}


STDAPI
CIntShcut_CreateInstance(
    IUnknown * punkOuter,
    IUnknown ** ppunk,
    LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    Intshcut *pis = new Intshcut;
    if (pis)
    {
        *ppunk = SAFECAST(pis, IDataObject *);
        hres = S_OK;
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\infotip.h ===
typedef HRESULT (STDAPICALLTYPE *PFNREADPROP)(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf);
    
typedef struct {
    const FMTID *pfmtid;    // FMTID_ for property set
    UINT idProp;            // property ID
    PFNREADPROP pfnRead;    // function to fetch the string representation
    UINT idFmtString;       // format string to use, should be "%1String %2"
} ITEM_PROP;

// standard PFNREADPROP callback types
STDAPI GetStringProp(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf);
STDAPI GetFileTimeProp(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf);
STDAPI GetInfoTipFromStorage(IPropertySetStorage *ppropsetstg, const ITEM_PROP *pip, WCHAR **ppszTip);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\iscmdt.cpp ===
#include "priv.h"
#include "ishcut.h"
#include "assocurl.h"
#include "shlwapi.h"
#include "resource.h"
#include "shlguid.h"

STDMETHODIMP Intshcut::QueryStatus(
    const GUID *pguidCmdGroup,
    ULONG cCmds,
    MSOCMD rgCmds[],
    MSOCMDTEXT *pcmdtext
)
{
    return E_NOTIMPL;
}

struct SHORTCUT_ICON_PARAMS
{
    WCHAR *pwszFileName;
    WCHAR *pwszShortcutUrl;
    BSTR   bstrIconUrl;

    ~SHORTCUT_ICON_PARAMS()
    {
        if(pwszFileName)
        {
            LocalFree(pwszFileName);
            pwszFileName = NULL;
        }

        if(bstrIconUrl)
        {
            SysFreeString(bstrIconUrl);
            bstrIconUrl = NULL;
        }

        if(pwszShortcutUrl)
        {
            SHFree(pwszShortcutUrl);
            pwszShortcutUrl = NULL;
        }
    }
};


const WCHAR wszDefaultShortcutIconName[] = ISHCUT_DEFAULT_FAVICONW;
const WCHAR wszDefaultShortcutIconNameAtRoot[] = ISHCUT_DEFAULT_FAVICONATROOTW;
extern const LARGE_INTEGER c_li0 ;

VOID
GetIconUrlFromLinkTag(
    IHTMLDocument2* pHTMLDocument,
    BSTR *pbstrIconUrl
)
{
    HRESULT hres;
    IHTMLLinkElement *pLink = NULL;
    hres = SearchForElementInHead(pHTMLDocument, OLESTR("REL"), OLESTR("SHORTCUT ICON"), IID_IHTMLLinkElement, (LPUNKNOWN *)&pLink);
    if(S_OK == hres)
    {
        hres = pLink->get_href(pbstrIconUrl);
        pLink->Release();
    }

}


BOOL SetIconForShortcut(
    WCHAR *pwszIconUrl,
    INamedPropertyBag *pNamedBag
)
{
 // Do it synchronously on this thread
    BOOL fRet = FALSE;
    WCHAR wszCacheFileName[MAX_PATH];
    HRESULT hr;

    ASSERT(pNamedBag);

    hr = URLDownloadToCacheFileW(NULL, pwszIconUrl, wszCacheFileName, sizeof(wszCacheFileName), NULL, NULL);
    if(S_OK == hr)
    {
        // 77657 security bug: we must not call LoadImage because the Win9x version can
        // crash with buffer overrun if given a corrupt icon.  ExtractIcon helps validate the file
        // to prevent that specific crash.

        HICON hIcon = ExtractIcon(g_hinst, wszCacheFileName, 0);

        if(hIcon) // It is really an Icon
        {
            // Make this icon sticky in cache
            SetUrlCacheEntryGroupW(pwszIconUrl, INTERNET_CACHE_GROUP_ADD,
                                            CACHEGROUP_ID_BUILTIN_STICKY, NULL, 0, NULL);


            DestroyIcon(hIcon);
            // get the file - set the icon and return
            fRet = TRUE; // We Got the icon file - even if we are unable set it
            // Store this url away in the shortcut file
            PROPSPEC rgpropspec[2];
            PROPVARIANT rgpropvar[2];
            PROPVARIANT var;

            LBSTR::CString          strUrl;

            if ( pwszIconUrl )
            {
                strUrl = pwszIconUrl;
            }
            else
            {
                strUrl.Empty();
            }

            var.vt = VT_BSTR;
            var.bstrVal = strUrl;

            hr = pNamedBag->WritePropertyNPB(ISHCUT_INISTRING_SECTIONW, ISHCUT_INISTRING_ICONFILEW,
                                                &var);

            if ( S_OK == hr )
            {
                LBSTR::CString          strIndex;

                strIndex = L"1";

                var.vt = VT_BSTR;
                var.bstrVal = strIndex;

                hr = pNamedBag->WritePropertyNPB(ISHCUT_INISTRING_SECTIONW, ISHCUT_INISTRING_ICONINDEXW,
                                                &var);
            }


            // Update the intsite database - whether or not the
            // shortcut file was updated. This is because we need to
            // ensure that the intsite db is updated even if the shortcut file name is not known

            IPropertySetStorage *ppropsetstg;
            IPropertyStorage *ppropstg;

            rgpropspec[0].ulKind = PRSPEC_PROPID;
            rgpropspec[0].propid = PID_INTSITE_ICONINDEX;
            rgpropspec[1].ulKind = PRSPEC_PROPID;
            rgpropspec[1].propid = PID_INTSITE_ICONFILE;




            rgpropvar[0].vt = VT_I4;
            rgpropvar[0].lVal = 1;
            rgpropvar[1].vt = VT_LPWSTR;
            rgpropvar[1].pwszVal = pwszIconUrl;



            hr = pNamedBag->QueryInterface(IID_IPropertySetStorage,(LPVOID *)&ppropsetstg);


            if(SUCCEEDED(hr))
            {
                hr = ppropsetstg->Open(FMTID_InternetSite, STGM_READWRITE, &ppropstg);
                ppropsetstg->Release();
            }

            if(SUCCEEDED(hr))
            {
                hr = ppropstg->WriteMultiple(2, rgpropspec, rgpropvar, 0);
                ppropstg->Commit(STGC_DEFAULT);
                ppropstg->Release();
            }
       }
    }

    return fRet;
}

HRESULT PreUpdateShortcutIcon(IUniformResourceLocatorW *purlW, LPTSTR pszHashItem, int* piIndex,
                              UINT* puFlags, int* piImageIndex, LPWSTR *ppwszURL)
{
    ASSERT(pszHashItem);
    ASSERT(piIndex);
    ASSERT(puFlags);
    ASSERT(piImageIndex);
    
    HRESULT hr;

    ASSERT(purlW);

    if(purlW)
    {
        hr = purlW->GetURL(ppwszURL);

        if(S_OK == hr)
        {
            hr = GetGenericURLIcon(pszHashItem, MAX_PATH, piIndex);

            if (SUCCEEDED(hr))
            {
                SHFILEINFO fi = {0};

                if (SHGetFileInfo(pszHashItem, 0, &fi, sizeof(SHFILEINFO),
                                  SHGFI_SYSICONINDEX))
                {
                    *piImageIndex = fi.iIcon;
                }
                else
                {
                    *piImageIndex = -1;
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


DWORD
DownloadAndSetIconForShortCutThreadProc(
    LPVOID pIn
)
{
    HINSTANCE hShdocvw = LoadLibrary(TEXT("shdocvw.dll"));
    SHORTCUT_ICON_PARAMS *pParams = (SHORTCUT_ICON_PARAMS *)pIn;
    WCHAR *pwszShortcutFilePath = pParams->pwszFileName;
    WCHAR *pwszIconUrl = pParams->bstrIconUrl;
    WCHAR wszFullUrl[MAX_URL_STRING];
    LPWSTR pwszBaseUrl = NULL;
    DWORD cchFullUrlSize = ARRAYSIZE(wszFullUrl);
    TCHAR  szHash[MAX_PATH];
    IPersistFile *   ppf = NULL;
    BOOL fRet = FALSE;
    INT iImageIndex;
    INT iIconIndex;
    UINT uFlags = 0;
    HRESULT hr;
    IUniformResourceLocatorW *purlW = NULL;
    HRESULT hresCoInit = E_FAIL;

    hresCoInit = CoInitialize(NULL);
    ASSERT(hShdocvw);
    hr = CoCreateInstance(CLSID_InternetShortcut, NULL,
                CLSCTX_INPROC_SERVER,
                IID_IUniformResourceLocatorW, (LPVOID *)&purlW);

    ASSERT(purlW);
    if((S_OK == hr) && purlW)
    {

        if(S_OK == hr)
        {
            if(pwszShortcutFilePath)
            {
                hr = purlW->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf);
                if(S_OK == hr)
                {
                    ASSERT(ppf);
                    hr = ppf->Load(pwszShortcutFilePath, STGM_READWRITE);
                }
            }
            else if(pParams->pwszShortcutUrl)
            {
                // Use the URL to init the shortcut
                hr = purlW->SetURL(pParams->pwszShortcutUrl, IURL_SETURL_FL_GUESS_PROTOCOL);
            }
            else
            {
                hr = E_FAIL;
                // Can't create an object and init it
            }
        }
    }



    if((S_OK == hr) && (purlW))
    {
        hr = PreUpdateShortcutIcon(purlW, szHash, &iIconIndex, &uFlags, &iImageIndex, (LPWSTR *)&pwszBaseUrl);

        INamedPropertyBag   *pNamedBag = NULL;
        hr = purlW->QueryInterface(IID_INamedPropertyBag,(LPVOID *)&pNamedBag);
        if((S_OK == hr) && (pNamedBag))
        {
            if(pwszIconUrl)
            {
                WCHAR *pwszIconFullUrl;
                if(pwszBaseUrl)
                {
                    hr = UrlCombineW(pwszBaseUrl, pwszIconUrl, wszFullUrl, &cchFullUrlSize, 0);
                    ASSERT(S_OK == hr);
                    if(SUCCEEDED(hr))
                    {
                        pwszIconFullUrl = wszFullUrl;
                    }
                 }
                 else
                 {
                    pwszIconFullUrl = pwszIconUrl; // try it as it is
                 }
                 fRet = SetIconForShortcut( pwszIconFullUrl, pNamedBag);

            }

            if((FALSE == fRet) && (pwszBaseUrl))
            {
                 
                hr = UrlCombineW(pwszBaseUrl, wszDefaultShortcutIconNameAtRoot, wszFullUrl, &cchFullUrlSize, 0);
                fRet = SetIconForShortcut(wszFullUrl, pNamedBag);
            }

            pNamedBag->Release();
        }
    }



    if(fRet)
    {
        SHUpdateImage(szHash, iIconIndex, uFlags, iImageIndex);
    }

    if(ppf)
    {
        ppf->Save(NULL, FALSE); // Save off Icon related stuff
        ppf->Release();
    }

    if(purlW)
        purlW->Release();

    if(pParams)
        delete pParams;

    if(pwszBaseUrl)
        SHFree(pwszBaseUrl);

    if(SUCCEEDED(hresCoInit))
        CoUninitialize();


    //FreeLibraryAndExitThread(hShdocvw); -- Need a FreeLibraryAndExitThread for thread pools
    return fRet;
}






STDMETHODIMP Intshcut::_DoIconDownload()
{
    SHORTCUT_ICON_PARAMS *pIconParams;
    BOOL fThreadStarted = FALSE;
    HRESULT hr = S_OK;


    pIconParams = new SHORTCUT_ICON_PARAMS;
    if(pIconParams)
    {
        if(_punkSite)
        {
            IServiceProvider *psp;
            hr = _punkSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&psp);

            if(SUCCEEDED(hr))
            {
                IWebBrowser2 *pwb=NULL;

                hr = psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID *)&pwb);
                if(SUCCEEDED(hr))
                {
                    IDispatch *pdisp = NULL;
                    ASSERT(pwb);
                    hr = pwb->get_Document(&pdisp);
                    if(pdisp)
                    {
                        IHTMLDocument2 *pHTMLDocument;
                        ASSERT(SUCCEEDED(hr));
                        hr = pdisp->QueryInterface(IID_IHTMLDocument2, (void **)(&pHTMLDocument));
                        if(SUCCEEDED(hr))
                        {
                            ASSERT(pHTMLDocument);
                            GetIconUrlFromLinkTag(pHTMLDocument, &(pIconParams->bstrIconUrl));
                            pHTMLDocument->Release();
                        }
                        pdisp->Release();
                    }
                    pwb->Release();
                }
                psp->Release();
            }

        }


        if(m_pszFile)
        {
            pIconParams->pwszFileName = StrDupW(m_pszFile);

        }

        // Now fill in the URL of the shortcut
        hr = GetURLW(&(pIconParams->pwszShortcutUrl));

        ASSERT(SUCCEEDED(hr));
        if(S_OK == hr)
        {
            fThreadStarted = SHQueueUserWorkItem(DownloadAndSetIconForShortCutThreadProc,
                                                 (LPVOID)(pIconParams),
                                                 0,
                                                 (DWORD_PTR)NULL,
                                                 (DWORD_PTR *)NULL,
                                                 "shdocvw.dll",
                                                 0
                                                 );
        }


    }

    if(FALSE == fThreadStarted)
    {
        if(pIconParams)
        {
            delete pIconParams;
        }
    }

    return fThreadStarted ? S_OK : E_FAIL;
}



STDMETHODIMP Intshcut::Exec(
    const GUID *pguidCmdGroup,
    DWORD nCmdID,
    DWORD nCmdexecopt,
    VARIANTARG *pvarargIn,
    VARIANTARG *pvarargOut
)
{

    HRESULT hres = S_OK;

    if (pguidCmdGroup && IsEqualGUID(CGID_ShortCut, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
            case ISHCUTCMDID_DOWNLOADICON:
            {
                DWORD dwFlags = 0;
                BOOL fFetch = TRUE;
                WCHAR *pwszUrl;
                // Don't do it for FTP shortcuts

                if(SUCCEEDED(GetURLW(&pwszUrl))) 
                {
                    if((URL_SCHEME_FTP == GetUrlSchemeW(pwszUrl)))
                        fFetch = FALSE;
                    SHFree(pwszUrl);
                }
                
                if(fFetch && (InternetGetConnectedState(&dwFlags, 0)))
                    hres = _DoIconDownload();
            }
                break;

            default:
                break;

        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\isdtobj.cpp ===
#include "priv.h"
#include "ishcut.h"

STDMETHODIMP Intshcut::GetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    ZeroMemory(pstgmed, SIZEOF(*pstgmed));

    if (pfmtetc->cfFormat == g_cfURL || pfmtetc->cfFormat == g_cfURLW)
        hr = TransferUniformResourceLocator(pfmtetc, pstgmed);
    else if ((pfmtetc->cfFormat == CF_TEXT) || (pfmtetc->cfFormat == CF_UNICODETEXT))
        hr = TransferText(pfmtetc, pstgmed);
    else if (pfmtetc->cfFormat == g_cfFileDescA)
        hr = TransferFileGroupDescriptorA(pfmtetc, pstgmed);
    else if (pfmtetc->cfFormat == g_cfFileDescW)
        hr = TransferFileGroupDescriptorW(pfmtetc, pstgmed);
    else if (pfmtetc->cfFormat == g_cfFileContents)
        hr = TransferFileContents(pfmtetc, pstgmed);
    else
        hr = DV_E_FORMATETC;

    return hr;
}

STDMETHODIMP Intshcut::GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed)
{
    return E_NOTIMPL;
}

STDMETHODIMP Intshcut::QueryGetData(FORMATETC *pfmtetc)
{
    HRESULT hr;

    if ((pfmtetc->cfFormat == g_cfURL) ||
        (pfmtetc->cfFormat == g_cfURLW) ||
        (pfmtetc->cfFormat == CF_TEXT) ||
        (pfmtetc->cfFormat == CF_UNICODETEXT) ||
        (pfmtetc->cfFormat == g_cfFileDescA) ||
        (pfmtetc->cfFormat == g_cfFileDescW))
    {
        hr = (pfmtetc->tymed & TYMED_HGLOBAL) ? S_OK : DV_E_TYMED;
    }
    else if (pfmtetc->cfFormat == g_cfFileContents)
    {
        if (pfmtetc->dwAspect == DVASPECT_COPY)
            hr = (pfmtetc->tymed & TYMED_ISTREAM) ? S_OK : DV_E_TYMED;
        else if ((pfmtetc->dwAspect == DVASPECT_CONTENT) ||
                 (pfmtetc->dwAspect == DVASPECT_LINK))
            hr = (pfmtetc->tymed & TYMED_HGLOBAL) ? S_OK : DV_E_TYMED;
        else
            hr = DV_E_FORMATETC;
    }
    else
        hr = DV_E_FORMATETC;

    return hr;
}

STDMETHODIMP Intshcut::GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut)
{
    HRESULT hr = QueryGetData(pfmtetcIn);
    if (hr == S_OK)
    {
        *pfmtetcOut = *pfmtetcIn;

        if (pfmtetcIn->ptd == NULL)
            hr = DATA_S_SAMEFORMATETC;
        else
        {
            pfmtetcIn->ptd = NULL;
            ASSERT(hr == S_OK);
        }
    }
    else
        ZeroMemory(pfmtetcOut, SIZEOF(*pfmtetcOut));

    return hr;
}

STDMETHODIMP Intshcut::SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease)
{
    return DV_E_FORMATETC;
}

STDMETHODIMP Intshcut::EnumFormatEtc(DWORD dwDirFlags, IEnumFORMATETC **ppiefe)
{
    if (dwDirFlags == DATADIR_GET)
    {
        FORMATETC rgfmtetc[] =
        {
            // the order here defines the accuarcy of rendering
            { g_cfFileContents, NULL, DVASPECT_LINK,  0, TYMED_HGLOBAL },
            { g_cfFileDescW,    NULL, DVASPECT_LINK, -1, TYMED_HGLOBAL },
            { g_cfFileDescA,    NULL, DVASPECT_LINK, -1, TYMED_HGLOBAL },
            { g_cfFileContents, NULL, DVASPECT_COPY,  0, TYMED_ISTREAM },
            { g_cfFileDescW,    NULL, DVASPECT_COPY, -1, TYMED_HGLOBAL },
            { g_cfFileDescA,    NULL, DVASPECT_COPY, -1, TYMED_HGLOBAL },
            { g_cfFileContents, NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL },
            { g_cfFileDescW,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { g_cfFileDescA,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { g_cfURLW,         NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { CF_UNICODETEXT,   NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { g_cfURL,          NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { CF_TEXT,          NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        };
        return SHCreateStdEnumFmtEtc(ARRAYSIZE(rgfmtetc), rgfmtetc, ppiefe);
    }
    *ppiefe = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP Intshcut::DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink *piadvsink, DWORD *pdwConnection)
{
    *pdwConnection = 0;
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP Intshcut::DUnadvise( DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP Intshcut::EnumDAdvise(IEnumSTATDATA **ppiesd)
{
    *ppiesd = NULL;
    return OLE_E_ADVISENOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\isexicon.cpp ===
/*
 * isexicon.cpp - IExtractIcon implementation for URL class.
 */


#include "priv.h"
#include "htregmng.h"
#include "ishcut.h"
#include "resource.h"


// We still have to use url.dll as the source of the internet shortcut
// icons because the icons need to still be valid on uninstall.

#ifndef UNIX
#define c_szIntshcutDefaultIcon     TEXT("url.dll")
#else
// IEUNIX(perf) : use unixstyle dll name
#ifdef ux10 
#define c_szIntshcutDefaultIcon     TEXT("liburl.sl")
#else
#define c_szIntshcutDefaultIcon     TEXT("liburl.so")
#endif
#endif

#define IDEFICON_NORMAL             0

#define II_OVERLAY_UPDATED          1

typedef struct
    {
    HIMAGELIST himl;          
    HIMAGELIST himlSm;
    } URLIMAGES;

HRESULT
URLGetLocalFileName(
    LPCTSTR pszURL,
    LPTSTR szLocalFile,
    int cch,
    FILETIME* pftLastMod);


/*----------------------------------------------------------
Purpose: Initializes the images lists used by the URL icon  
         handler.

         There are just two icons placed in each imagelist:
         the given hicon and an overlay for the updated
         asterisk.

Returns: 
Cond:    --
*/
STDMETHODIMP
InitURLImageLists(
    IN URLIMAGES * pui,
    IN HICON       hicon,
    IN HICON       hiconSm)
    {
    HRESULT hres = E_OUTOFMEMORY;

    LoadCommonIcons();
    _InitSysImageLists();

    pui->himl = ImageList_Create(g_cxIcon, g_cyIcon, ILC_MASK, 2, 2);
    
    if (pui->himl)
    {
        pui->himlSm = ImageList_Create(g_cxSmIcon, g_cySmIcon, ILC_MASK, 2, 2);
        
        if ( !pui->himlSm ) 
            ImageList_Destroy(pui->himl);
        else
        {
            ImageList_SetBkColor(pui->himl, GetSysColor(COLOR_WINDOW));
            ImageList_SetBkColor(pui->himlSm, GetSysColor(COLOR_WINDOW));
         
            // Add the given icons
            ImageList_ReplaceIcon(pui->himl, -1, hicon);
            ImageList_ReplaceIcon(pui->himlSm, -1, hiconSm);

            // Add the overlay icon to the list
            ASSERT(IS_VALID_HANDLE(g_hiconSplat, ICON));
            ASSERT(IS_VALID_HANDLE(g_hiconSplatSm, ICON));

            if (g_hiconSplat)
            {
                int iOverlay = ImageList_ReplaceIcon(pui->himl, -1, g_hiconSplat);
                ImageList_ReplaceIcon(pui->himlSm, -1, g_hiconSplatSm);

                ImageList_SetOverlayImage(pui->himl, iOverlay, II_OVERLAY_UPDATED);
                ImageList_SetOverlayImage(pui->himlSm, iOverlay, II_OVERLAY_UPDATED);
            }
            
            hres = S_OK;
        }
    }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Destroys the url image lists

Returns: 
Cond:    --
*/
STDMETHODIMP
DestroyURLImageLists(
    IN URLIMAGES * pui)
{
    if (pui->himl)       
    {
        ImageList_Destroy(pui->himl);
        pui->himl = NULL;
    }

    if (pui->himlSm)       
    {
        ImageList_Destroy(pui->himlSm);
        pui->himlSm = NULL;
    }

    return S_OK;
}



/*----------------------------------------------------------
Purpose: Gets the icon location (filename and index) from the registry
         of the given key.

Returns: 
Cond:    --
*/
HRESULT 
GetURLIcon(
    IN  HKEY    hkey, 
    IN  LPCTSTR pcszKey, 
    IN  LPTSTR  pszIconFile,
    IN  UINT    cchIconFile, 
    OUT PINT    pniIcon)
{
    HRESULT hres = S_FALSE;
    DWORD dwSize = CbFromCch(cchIconFile);

    ASSERT(IS_VALID_HANDLE(hkey, KEY));
    ASSERT(IS_VALID_STRING_PTR(pcszKey, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

    if (NO_ERROR == SHGetValue(hkey, pcszKey, NULL, NULL, pszIconFile, &dwSize))
    {
        *pniIcon = PathParseIconLocation(pszIconFile);
        hres = S_OK;
    }

    ASSERT(IsValidIconIndex(hres, pszIconFile, cchIconFile, *pniIcon));

    return hres;
}


/*
** GetFallBackGenericURLIcon()
**
**
**
** Arguments:
**
** Returns:       S_OK if fallback generic icon information retrieved
**                successfully.
**                E_FAIL if not.
**
** Side Effects:  none
*/
HRESULT 
GetFallBackGenericURLIcon(
    LPTSTR pszIconFile,
    UINT cchIconFile,
    PINT pniIcon)
{
    HRESULT hr;

    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

    // Fall back to first icon in this module.

    StrCpyN(pszIconFile, c_szIntshcutDefaultIcon, cchIconFile);
    *pniIcon = IDEFICON_NORMAL;

    hr = S_OK;

    TraceMsg(TF_INTSHCUT, "GetFallBackGenericURLIcon(): Using generic URL icon file %s, index %d.",
              pszIconFile, *pniIcon);

    ASSERT(IsValidIconIndex(hr, pszIconFile, cchIconFile, *pniIcon));

    return(hr);
}


/*
** GetGenericURLIcon()
**
**
**
** Arguments:
**
** Returns:       S_OK if generic icon information retrieved successfully.
**                Otherwise error.
**
** Side Effects:  none
*/
HRESULT 
GetGenericURLIcon(
    LPTSTR pszIconFile,
    UINT cchIconFile, 
    PINT pniIcon)
{
    HRESULT hr;

    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

    hr = GetURLIcon(HKEY_CLASSES_ROOT, TEXT("InternetShortcut\\DefaultIcon"), pszIconFile,
                    cchIconFile, pniIcon);

    if (hr == S_FALSE)
        hr = GetFallBackGenericURLIcon(pszIconFile, cchIconFile, pniIcon);

    ASSERT(IsValidIconIndex(hr, pszIconFile, cchIconFile, *pniIcon));

    return(hr);
}


/****************************** Public Functions *****************************/


/*----------------------------------------------------------
Purpose: Given a full URL path, this function returns the 
         registry path to the associated protocol (plus the
         subkey path).

         pszBuf must be MAX_PATH.

Returns: 
Cond:    --
*/
HRESULT 
GetURLKey(
    LPCTSTR pcszURL, 
    LPCTSTR pszSubKey, 
    LPTSTR  pszBuf,
    int cchBuf)
{
    HRESULT hres;
    PTSTR pszProtocol;

    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));
    ASSERT(IS_VALID_STRING_PTR(pszSubKey, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, MAX_PATH));

    *pszBuf = '\0';

    hres = CopyURLProtocol(pcszURL, &pszProtocol, NULL);

    if (hres == S_OK)
    {
        StrCpyN(pszBuf, pszProtocol, cchBuf);
        PathAppend(pszBuf, pszSubKey);

        LocalFree(pszProtocol);
        pszProtocol = NULL;
    }

    return hres;
}


/********************************** Methods **********************************/

/*----------------------------------------------------------
Purpose : To help determine if the file to which this shortcut
          is persisted is in the favorites hierarchy
          
Returns : Returns TRUE if this shortcut is in the favorites 
         folder
*/


BOOL Intshcut::_IsInFavoritesFolder()
{
    BOOL fRet = FALSE;

    if(m_pszFile)
    {
        TCHAR szPath[MAX_PATH];
        if(SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE))
        {
            // Is szPath (i.e. the favorites dir) a prefix of the file associated with this
            // shortcut ?
            fRet = PathIsPrefix(szPath, m_pszFile);
        }
    }

    return fRet;
    
}
         
/*----------------------------------------------------------
Purpose: Get the icon location of the given url.

Returns: S_FALSE if the location is default for the type
         S_OK if the location is custom

         The way this extracticon stuff works is very strange and not
         well-documented.  In particular, there are multiple levels of
         name munging going on, and it's not clear how information is
         passed between IExtractIcon::GetIconLocation and
         IExtractIcon::Extract.  (In particular, it seems that we maintain
         state in our object in order to do secret communication between
         the two methods, which is out of spec.  The shell is allowed to
         instantiate you, call GetIconLocation, then destroy you.  Then
         the next day, it can instantiate you and call Extract with the
         result from yesterday's GetIconLocation.)

         I'm not going to try to fix it; I'm just
         pointing it out in case somebody has to go debugging into this
         code and wonders what is going on.

Cond:    --
*/
STDMETHODIMP
Intshcut::GetURLIconLocation(
    IN  UINT    uInFlags,
    IN  LPTSTR  pszBuf,
    IN  UINT    cchBuf,
    OUT int *   pniIcon,
    BOOL fRecentlyChanged,
    OUT PUINT  puOutFlags)
{
    // Call the IShellLink::GetIconLocation method
    HRESULT hres = _GetIconLocationWithURLHelper(pszBuf, cchBuf, pniIcon, NULL, 0, fRecentlyChanged);
    BOOL fNeedQualify = TRUE;
    hres = S_FALSE;
    if (*pszBuf)
    {
        if(puOutFlags && (FALSE == PathFileExists(pszBuf)))
            SetFlag(*puOutFlags, GIL_NOTFILENAME);
    }
    else
    {
        
        if(FALSE == _IsInFavoritesFolder() || (IsIEDefaultBrowserQuick()))
        {
            // This shortcut is not in the favorites folder as far as we know 
            TCHAR szURL[INTERNET_MAX_URL_LENGTH];

            *szURL = 0;

            hres = InitProp();
            if (SUCCEEDED(hres))
                m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));

            if (*szURL)
            {
                TCHAR szT[MAX_PATH];

                hres = E_FAIL;

                // If it's a file:// URL, then default to the icon from
                // the file target.  Must use IExtractIconA in case we're
                // on Win95.
                IExtractIconA *pxi;
                if (_TryLink(IID_IExtractIconA, (void **)&pxi))
                {
                    uInFlags |= GIL_FORSHORTCUT;                        // to help break recursion
                    // S_FALSE means "I don't know what icon to use",
                    // so treat only S_OK as successful icon extraction.
                    if (IExtractIcon_GetIconLocation(pxi, uInFlags, pszBuf, cchBuf, pniIcon, puOutFlags) == S_OK)
                    {
                        hres = S_OK;
                        fNeedQualify = FALSE;
                    }

                    pxi->Release();
                }

                // If couldn't get target icon or not a file:// URL, then
                // go get some default icon based on the URL scheme.
                if (FAILED(hres))
                {
                    // Look up URL icon based on protocol handler.

                    hres = GetURLKey(szURL, TEXT("DefaultIcon"), szT, ARRAYSIZE(szT));

                    if (hres == S_OK)
                    {
                        hres = GetURLIcon(HKEY_CLASSES_ROOT, szT, pszBuf, 
                                          cchBuf, pniIcon);
                    }
                }
            }
        }
        
        if (hres == S_FALSE)
        {
            // Use generic URL icon.

            hres = GetFallBackGenericURLIcon(pszBuf, cchBuf, pniIcon); // Make sure we have the E icon and 
                                                                       // Not any of netscape's icons

            if (hres == S_OK)
                TraceMsg(TF_INTSHCUT, "Intshcut::GetIconLocation(): Using generic URL icon.");
        }

        if (hres == S_OK && fNeedQualify)
        {
            TCHAR szFullPath[MAX_PATH];

            if (PathSearchAndQualify(pszBuf, szFullPath, SIZECHARS(szFullPath)))
            {
                hres = S_OK;

                if ((UINT)lstrlen(szFullPath) < cchBuf)
                    StrCpyN(pszBuf, szFullPath, cchBuf);
                else
                    hres = E_FAIL;
            }
            else
                hres = E_FILE_NOT_FOUND;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that determines the icon location based
         on the flags property of the internet site property set.

Returns: 
Cond:    --
*/
STDMETHODIMP
Intshcut::GetIconLocationFromFlags(
    IN  UINT   uInFlags,
    OUT LPTSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags,
    IN  DWORD  dwPropFlags)
{
    HRESULT hres = S_FALSE;

    *puOutFlags = 0;

    ClearFlag(m_dwFlags, ISF_SPECIALICON);

    // Normally, the icon is the standard icon that is retrieved.
    // If the url has been updated, though, we want to add the
    // overlay, in which case we return GIL_NOTFILENAME so the
    // Extract method will be called.

    hres = GetURLIconLocation(uInFlags, pszIconFile, cchIconFile, pniIcon,
                                IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED), puOutFlags);
    if (SUCCEEDED(hres))
    {
        // (scotth): we don't support red splats on browser
        //                  only because it requires new SHELL32 APIs.

        // Has this item been updated since last viewed? 
        
        if (IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED) && 
                    (FALSE == (*puOutFlags & GIL_NOTFILENAME)))
        {
            // Yes; cache the item as a non-file so we get the
            // dynamically created icon 
            SetFlag(*puOutFlags, GIL_NOTFILENAME);

            // Add the icon index at the end of the filename, so
            // it will be hashed differently from the filename 
            // instance.
            wnsprintf(&pszIconFile[lstrlen(pszIconFile)], cchIconFile - lstrlen(pszIconFile),
                      TEXT(",%d"), *pniIcon);

            // cdturner
            // this is done for browser only mode to stop the shell hacking the path
            // down to the dll and not calling us
            
            // remove the dot from the string
            LPTSTR pszDot = StrRChr( pszIconFile, NULL, TCHAR('.'));
            if ( pszDot )
            {
                *pszDot = TCHAR('*');  // should be DBCS safe as it is in the lower 7 bits ASCII
            }
            
            SetFlag(m_dwFlags, ISF_SPECIALICON);
        }

    }
    else
    {
        // Init to default values
        *pniIcon = IDEFICON_NORMAL;
        if (cchIconFile > 0)
            StrCpyN(pszIconFile, c_szIntshcutDefaultIcon, cchIconFile);
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IExtractIcon::GetIconLocation handler for Intshcut

Returns: 
Cond:    --
*/
// This is the real one for the platform...
HRESULT
Intshcut::_GetIconLocation(
    IN  UINT   uInFlags,
    OUT LPWSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags)
{
    HRESULT hres;

    if (uInFlags & (GIL_ASYNC | GIL_FORSHORTCUT))
    {
        hres = GetGenericURLIcon(pszIconFile, cchIconFile, pniIcon);

        if (uInFlags & GIL_ASYNC)
            return ((SUCCEEDED(hres)) ? E_PENDING : hres);
        else
            return hres;
    }

    hres = LoadFromAsyncFileNow();
    if(FAILED(hres))
        return hres;

    hres = S_FALSE;

    // We also use this method to perform the mirroring
    // of the values between the internet shortcut file and
    // the central database.  IExtractIcon is a good interface
    // to do this because it is virtually guaranteed to be 
    // called for a URL.
    MirrorProperties();

    // Init to default values
    *puOutFlags = 0;
    *pniIcon = 0;
    if (cchIconFile > 0)
        *pszIconFile = TEXT('\0');


    DWORD dwVal = 0;

    if (m_psiteprop)
        m_psiteprop->GetProp(PID_INTSITE_FLAGS, &dwVal);

    hres = GetIconLocationFromFlags(uInFlags, pszIconFile, cchIconFile, pniIcon,
                                    puOutFlags, dwVal);


    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return hres;
}

HRESULT Intshcut::_CreateShellLink(LPCTSTR pszPath, IUnknown **ppunk)
{
    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punk);
    
    if (SUCCEEDED(hr))
    {
        if (g_fRunningOnNT)
        {
            IShellLink *psl;
            hr = punk->QueryInterface(IID_IShellLink, (void **)&psl);
            if (SUCCEEDED(hr))
            {
                hr = psl->SetPath(pszPath);
                psl->Release();
            }
        }
        else
        {
            IShellLinkA *psl;
            hr = punk->QueryInterface(IID_IShellLinkA, (void **)&psl);
            if (SUCCEEDED(hr))
            {
                CHAR sz[MAX_PATH];
                SHTCharToAnsi(pszPath, sz, SIZECHARS(sz));
                hr = psl->SetPath(sz);
                psl->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppunk = punk;
        }
        else
            punk->Release();
    }

    return hr;
}
    
HRESULT
Intshcut::GetIconLocation(
    IN  UINT   uInFlags,
    OUT LPTSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags)
{
    HRESULT hr = E_FAIL;
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));
    ASSERT(IS_VALID_WRITE_PTR(puOutFlags, UINT));

    if (FAILED(hr))
    {
        hr = _GetIconLocation(uInFlags, pszIconFile, cchIconFile, pniIcon, puOutFlags);
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\
//
// *** URLGetLocalFileName ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
URLGetLocalFileName(
    LPCTSTR pszURL,
    LPTSTR szLocalFile,
    int cch,
    FILETIME* pftLastMod
)
{
    ASSERT(pszURL);
    ASSERT(szLocalFile || 0 == cch);

    HRESULT hr = E_FAIL;

    if (pftLastMod)
    {
        pftLastMod->dwLowDateTime  = 0;
        pftLastMod->dwHighDateTime = 0;
    }

    // by using the internal shlwapi function, we avoid loading WININET 
    // unless we really really need it...
    DWORD scheme = GetUrlScheme(pszURL);
    if (scheme != URL_SCHEME_INVALID)
    {
        switch(scheme)
        {
        case URL_SCHEME_HTTP:
        case URL_SCHEME_FTP:
        case URL_SCHEME_GOPHER:
            {
                ULONG cbSize  = MAX_CACHE_ENTRY_INFO_SIZE;

                INTERNET_CACHE_ENTRY_INFO* piceiAlloced = 
                (INTERNET_CACHE_ENTRY_INFO*) new BYTE[cbSize];

                if (piceiAlloced)
                {
                    piceiAlloced->dwStructSize =
                                      sizeof(INTERNET_CACHE_ENTRY_INFO);

                    if (GetUrlCacheEntryInfoEx(pszURL, piceiAlloced,
                                               &cbSize, NULL, NULL,
                                               NULL, 0))
                    {
                        if (StrCpyN(szLocalFile,
                                    piceiAlloced->lpszLocalFileName, cch))
                        {
                            if (pftLastMod)
                            {
                                *pftLastMod = piceiAlloced->LastModifiedTime;
                            }

                            hr = S_OK;
                        }
                    }

                    delete [] piceiAlloced;
                }
            }
            break;

        case URL_SCHEME_FILE:
            hr = PathCreateFromUrl(pszURL, szLocalFile, (LPDWORD)&cch, 0);
            break;

        }
    }
    else
    {
        if (StrCpyN(szLocalFile, pszURL, cch))
            hr = S_OK;
    }

    return hr;
}


BOOL
PretendFileIsICONFileAndLoad(
    IN LPTSTR lpszTempBuf,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize)
{
    WORD wSizeSmall = HIWORD(ucIconSize);
    WORD wSizeLarge = LOWORD(ucIconSize);

    BOOL fRet = FALSE;
    // Pretend that the file is a .ico file and load it

    ASSERT(phiconLarge);
    ASSERT(phiconSmall);
    
    *phiconSmall = (HICON)LoadImage(NULL, lpszTempBuf, IMAGE_ICON, wSizeSmall, wSizeSmall, LR_LOADFROMFILE);
    if(*phiconSmall)
    {
        fRet = TRUE;
        *phiconLarge = (HICON)LoadImage(NULL, lpszTempBuf, IMAGE_ICON, wSizeLarge, wSizeLarge, LR_LOADFROMFILE);
    }
                

    return fRet;
}




BOOL
Intshcut::ExtractIconFromWininetCache(
    IN  LPCTSTR pszIconString,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize,
    BOOL *pfFoundUrl,
    DWORD dwPropFlags)
{
    IPropertyStorage *ppropstg = NULL;
    BOOL fRet = FALSE;
    INT iTempIconIndex;
    HRESULT hr;
    BOOL fFoundURL = FALSE;


    ASSERT(pfFoundUrl && (FALSE == *pfFoundUrl));
    ASSERT((lstrlen(pszIconString) + 1)<= MAX_PATH);
    
    TCHAR szTempBuf[MAX_URL_STRING + 1];
    *szTempBuf = TEXT('\0');
    TCHAR szTempIconBuf[MAX_PATH + 1];
    *szTempIconBuf = TEXT('\0');
      
    hr =  _GetIconLocationWithURLHelper(
                    szTempIconBuf, ARRAYSIZE(szTempIconBuf), &iTempIconIndex, 
                    szTempBuf, ARRAYSIZE(szTempBuf), IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED));
    
    if((S_OK == hr) && (*szTempIconBuf))
    {
        if((UINT)iTempIconIndex == iIcon)
        {
            if(0 == StrCmp(szTempIconBuf, pszIconString))
            {
                if(*szTempBuf)
                {
                    BOOL fUsesCache=FALSE;
                    DWORD dwBufSize=0;
                    CoInternetQueryInfo(szTempBuf, QUERY_USES_CACHE, 0,
                                     &fUsesCache, sizeof(fUsesCache), &dwBufSize, 0);

                    if(fUsesCache)
                    {
                        fFoundURL = TRUE;
                    }
                }
            }
        }
    }



    if(fFoundURL)
    {
        // Now szTempBuf has the URL of the ICON
        // now look and see if the shortcut file itself has the icon and if so
        // simply use it  --- TBD 
        
        
        // we need to grovel in the cache and see if we can get
        // it there and then convert it to an icon
        TCHAR szIconFile[MAX_PATH + 1];
        hr = URLGetLocalFileName(szTempBuf, szIconFile, ARRAYSIZE(szIconFile), NULL);

        if(S_OK == hr)
        {

            if(PretendFileIsICONFileAndLoad(szIconFile, phiconLarge, phiconSmall, ucIconSize))
            {
                fRet = TRUE;
            }

            // It's a bitmap, gif or a jpeg          
        }
    }
    

    if(pfFoundUrl)
        *pfFoundUrl = fFoundURL;
    return fRet;
}

/*----------------------------------------------------------
Purpose: IExtractIcon::Extract method for Intshcut

         Extract the icon.  This function really returns an icon
         that is dynamically created, based upon the properties
         of the URL (recently changed, etc).

         Expect that for normal cases, when the icon does not
         need to be munged (an overlay added), the GetIconLocation
         method should suffice.  Otherwise, this method will get
         called.

Returns: 
Cond:    --
*/
// This is the real one for the platform...
HRESULT
Intshcut::_Extract(
    IN  LPCTSTR pszIconFile,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize)
{
    HRESULT hres;
    HICON hiconLarge = NULL;
    HICON hiconSmall = NULL;
    TCHAR szPath[MAX_PATH];
    int nIndex;
    BOOL fSpecialUrl = FALSE;
    *phiconLarge = NULL;
    *phiconSmall = NULL;
    DWORD dwPropFlags = 0;

    hres = LoadFromAsyncFileNow();
    if(FAILED(hres))
        return hres;

    hres = S_FALSE;    
    
    InitSiteProp();

    // Get the property Flags
    if (m_psiteprop)
            m_psiteprop->GetProp(PID_INTSITE_FLAGS, &dwPropFlags);
    
    // First check to see if this is a special icon
    // This function returns a usable value for fSpecialUrl even if it returns FALSE
    if(ExtractIconFromWininetCache(pszIconFile, iIcon, &hiconLarge, &hiconSmall, ucIconSize, &fSpecialUrl, dwPropFlags))
    {
        hres = S_OK;
    } 
    else 
    {
        if(TRUE == fSpecialUrl)
        {
            // The extract failed even though this was a special URL
            // we need to revert back to using the default IE icon
            hres = GetGenericURLIcon(szPath, MAX_PATH, (int *)(&iIcon));
            
            if (hres == S_OK)
            {
                fSpecialUrl = FALSE; // It's no longer a special URL
                hres = InitProp();
                if (SUCCEEDED(hres))
                {
                    hres = m_pprop->SetProp(PID_IS_ICONFILE, szPath);
                    if (SUCCEEDED(hres))
                    {
                        hres = m_pprop->SetProp(PID_IS_ICONINDEX, (INT)iIcon);
                    }
                }
            }
            
            if(S_OK != hres)
            {
                ASSERT(0);
                goto DefIcons;
            }
        } 
        else
        {
            StrCpyN(szPath, pszIconFile, ARRAYSIZE(szPath));
            // The path may be munged.  Get the icon index as appropriate.
            if (IsFlagSet(m_dwFlags, ISF_SPECIALICON) && (!fSpecialUrl) )
            {
                // Get the icon location from the munged path
                iIcon = PathParseIconLocation(szPath);

                // cdturner
                // now replace the '*' with the dot
                // this is done for browser only mode to stop the shell hacking the path
                // down to the dll and not calling us
                LPTSTR pszPlus = StrRChr( szPath, NULL, TCHAR('*'));
                if ( pszPlus )
                {
                    *pszPlus = TCHAR('.');
                }
                
                
            }
        }
        
        
        nIndex = iIcon;

        if(!fSpecialUrl)
        {
            if ( WhichPlatform() == PLATFORM_INTEGRATED )
            {
                // Extract the icons 
                CHAR szTempPath[MAX_PATH + 1];
                SHTCharToAnsi(szPath, szTempPath, ARRAYSIZE(szTempPath));
                hres = SHDefExtractIconA(szTempPath, nIndex, 0, &hiconLarge, &hiconSmall, 
                                        ucIconSize);
            }
            else
            {
                // cdturner
                // use a more hacky solution to support browser only mode..
                _InitSysImageLists();
                
                int iIndex = Shell_GetCachedImageIndex( szPath, nIndex, 0 );
                if ( iIndex > 0 )
                {
                    hiconLarge = ImageList_GetIcon( g_himlSysLarge, iIndex, 0 );
                    hiconSmall = ImageList_GetIcon( g_himlSysSmall, iIndex, 0 );

                    hres = NOERROR;
                }
                else 
                {
                    hiconLarge = hiconSmall = NULL;
                    
                    // it will get the windows icon if it should be gleamed, and 
                    // it will the normal icon otherwsie
                    hres = IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED) ? E_FAIL : S_FALSE;
                    goto DefIcons;
                }
            }
        }
    }

    

    if (SUCCEEDED(hres))
    {
        // Has this URL changed recently? 
        if (IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED))
        {
            // Yes 
            URLIMAGES ui;

            if (SUCCEEDED(InitURLImageLists(&ui, hiconLarge, hiconSmall)))
            {
                *phiconLarge = ImageList_GetIcon(ui.himl, 0, INDEXTOOVERLAYMASK(II_OVERLAY_UPDATED));
                *phiconSmall = ImageList_GetIcon(ui.himlSm, 0, INDEXTOOVERLAYMASK(II_OVERLAY_UPDATED));

                DestroyURLImageLists(&ui);

                // these were created, they are not global handles, so they must be cleanedup.
                DestroyIcon( hiconLarge );
                DestroyIcon( hiconSmall );
            }
            else
                goto DefIcons;
        }
        else
        {
            // No
DefIcons:
            *phiconLarge = hiconLarge;
            *phiconSmall = hiconSmall;
        }
    }

    return hres;
}

STDMETHODIMP
Intshcut::Extract(
    IN  LPCTSTR pszIconFile,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize)
{
    if (URL_SCHEME_FILE == GetScheme() && _punkLink)
        return IExtractIcon_Extract(_punkLink, pszIconFile, iIcon, phiconLarge, phiconSmall, ucIconSize);
    else
        return _Extract(pszIconFile, iIcon, phiconLarge, phiconSmall, ucIconSize);
}

// Now handle the
// Unicode or Ansi one for the "Other" platform...

STDMETHODIMP
Intshcut::GetIconLocation(UINT uInFlags, LPSTR pszIconFile, UINT cchIconFile,
        PINT pniIcon, PUINT  puOutFlags)
{
    HRESULT hres;
    WCHAR   wszIconFile[MAX_PATH];

    // IconFile is output so...
    // Note, we will only handle up to MAXPATH
    if (cchIconFile > ARRAYSIZE(wszIconFile))
        cchIconFile = ARRAYSIZE(wszIconFile);

    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    hres = GetIconLocation(uInFlags, wszIconFile, cchIconFile, pniIcon, puOutFlags);

    if (cchIconFile > 0 && SUCCEEDED(hres))
    {
        WideCharToMultiByte(CP_ACP, 0, wszIconFile, -1, pszIconFile, cchIconFile, NULL, NULL);
    }
    return hres;
}


STDMETHODIMP Intshcut::Extract(IN  LPCSTR pszIconFile, IN  UINT    iIcon,
    OUT HICON * phiconLarge, OUT HICON * phiconSmall, IN  UINT    ucIconSize)
{
    WCHAR wszIconFile[MAX_PATH];

    // First convert the string...
    MultiByteToWideChar(CP_ACP, 0, pszIconFile, -1, wszIconFile, ARRAYSIZE(wszIconFile));

    return Extract(wszIconFile, iIcon, phiconLarge, phiconSmall, ucIconSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\ishcut.h ===
/*
 * ishcut.h - Internet Shortcut class implementation description.
 */

#ifndef _INTSHCUT_HPP_
#define _INTSHCUT_HPP_

#include "urlprop.h"
#include "subsmgr.h"
#include "cowsite.h"
//
// Define this to enable the integrated history database
//
#define USE_NEW_HISTORYDATA

#ifdef __cplusplus

/* Types
 ********/

// Intshcut flags

#define ISF_DEFAULT             0x00000000
#define ISF_DIRTY               0x00000001      // URL is dirty
#define ISF_DESKTOP             0x00000002      // Located on the desktop
#define ISF_FAVORITES           0x00000004      // Located in favorites folder
#define ISF_WATCH               0x00000008      // Scratch flag for context menu
#define ISF_SPECIALICON         0x00000010      // Icon is munged for splat
#define ISF_CODEPAGE            0x00000020      // Code page is set
#define ISF_ALL                 0x0000003F


// Intshcut Shell extension

class Intshcut : public IDataObject,
                 public IContextMenu2,
                 public IExtractIconA,
                 public IExtractIconW,
                 public IPersistFile,
                 public IPersistStream,
                 public IShellExtInit,
                 public IShellLinkA,
                 public IShellLinkW,
                 public IShellPropSheetExt,
                 public IPropertySetStorage,
                 public INewShortcutHookA,
                 public INewShortcutHookW,
                 public IUniformResourceLocatorA,
                 public IUniformResourceLocatorW,
                 public IQueryInfo,
                 public IQueryCodePage,
                 public CObjectWithSite, 
                 public INamedPropertyBag,
                 public IOleCommandTarget
{


private:

    LONG        m_cRef;
    DWORD       m_dwFlags;              // ISF_* flags
    LPTSTR      m_pszFile;              // Name of internet shortcut
    LPTSTR      m_pszFileToLoad ;        // Name of Internet Shortcut that was 
    IntshcutProp *m_pprop;              // Internal properties
    IntsiteProp  *m_psiteprop;          // Internet Site properties
    LPTSTR      m_pszFolder;            // Used by INewShortcutHook
    UINT        m_uiCodePage;           // Used by IQueryCodePage -- sendmail.dll for send current document
    BOOL        m_bCheckForDelete;      // Used to see if we need to delete a subscription if the
                                        // shortcut is deleted.
    BOOL        m_fMustLoadSync;        // Set to TRUE if any interface other than IPersistFile or
                                        // IExtractIconW/A are given out
    BOOL        m_fProbablyDefCM;       // this shortcut was most likely init'd by defcm
    
    IDataObject *m_pInitDataObject;
    LPTSTR      m_pszTempFileName;      // temporary file to be deleted when ishcut goes away
    LPTSTR      m_pszDescription;
    IUnknown   *_punkLink;                   //  for file: URLs

    STDMETHODIMP InitProp(void);
    STDMETHODIMP InitSiteProp(void);
    STDMETHODIMP OnReadOffline(void);
    STDMETHODIMP OnWatch(void);
    STDMETHODIMP MirrorProperties(void);

    // data transfer methods

    STDMETHODIMP_(DWORD) GetFileContentsAndSize(LPSTR *ppsz);
    STDMETHODIMP TransferUniformResourceLocator(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP TransferText(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP TransferFileGroupDescriptorA(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP TransferFileGroupDescriptorW(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP TransferFileContents(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP GetDocumentStream(IStream **ppstm);
    STDMETHODIMP GetDocumentName(LPTSTR pszName);

    // protocol registration methods

    STDMETHODIMP RegisterProtocolHandler(HWND hwndParent, LPTSTR pszAppBuf, UINT ucAppBufLen);

    HRESULT _Extract(LPCTSTR pszIconFile, UINT iIcon, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);
    HRESULT _GetIconLocation(UINT uFlags, LPWSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);

    ~Intshcut(void);    // Prevent this class from being allocated on the stack or it will fault.

public:
    Intshcut(void);

    // IDataObject methods

    STDMETHODIMP GetData(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    STDMETHODIMP GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    STDMETHODIMP QueryGetData(FORMATETC *pfmtetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    STDMETHODIMP SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, PDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppienumStatData);

    // IExtractIconA methods

    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
    STDMETHODIMP Extract(LPCSTR pcszFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);

    // IExtractIconW methods

    STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
    STDMETHODIMP Extract(LPCWSTR pcszFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);

    // INewShortcutHookA methods

    STDMETHODIMP SetReferent(LPCSTR pcszReferent, HWND hwndParent);
    STDMETHODIMP GetReferent(LPSTR pszReferent, int ncReferentBufLen);
    STDMETHODIMP SetFolder(LPCSTR pcszFolder);
    STDMETHODIMP GetFolder(LPSTR pszFolder, int ncFolderBufLen);
    STDMETHODIMP GetName(LPSTR pszName, int ncNameBufLen);
    STDMETHODIMP GetExtension(LPSTR pszExtension, int ncExtensionBufLen);

    // INewShortcutHookW methods

    STDMETHODIMP SetReferent(LPCWSTR pcszReferent, HWND hwndParent);
    STDMETHODIMP GetReferent(LPWSTR pszReferent, int ncReferentBufLen);
    STDMETHODIMP SetFolder(LPCWSTR pcszFolder);
    STDMETHODIMP GetFolder(LPWSTR pszFolder, int ncFolderBufLen);
    STDMETHODIMP GetName(LPWSTR pszName, int ncNameBufLen);
    STDMETHODIMP GetExtension(LPWSTR pszExtension, int ncExtensionBufLen);

    // IPersist methods

    STDMETHODIMP GetClassID(CLSID *pclsid);

    // IPersistFile methods

    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Save(LPCOLESTR pcwszFileName, BOOL bRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pcwszFileName);
    STDMETHODIMP Load(LPCOLESTR pcwszFileName, DWORD dwMode);
    STDMETHODIMP GetCurFile(LPOLESTR *ppwszFileName);

    // IPersistStream methods

    STDMETHODIMP Save(IStream * pistr, BOOL bClearDirty);
    STDMETHODIMP Load(IStream * pistr);
    STDMETHODIMP GetSizeMax(PULARGE_INTEGER pcbSize);

    // IShellExtInit methods

    STDMETHODIMP Initialize(LPCITEMIDLIST pcidlFolder, IDataObject * pidobj, HKEY hkeyProgID);

    // IShellLink methods

    STDMETHODIMP SetPath(LPCSTR pcszPath);
    STDMETHODIMP GetPath(LPSTR pszFile, int ncFileBufLen, PWIN32_FIND_DATAA pwfd, DWORD dwFlags);
    STDMETHODIMP SetRelativePath(LPCSTR pcszRelativePath, DWORD dwReserved);
    STDMETHODIMP SetIDList(LPCITEMIDLIST pcidl);
    STDMETHODIMP GetIDList(LPITEMIDLIST *ppidl);
    STDMETHODIMP SetDescription(LPCSTR pcszDescription);
    STDMETHODIMP GetDescription(LPSTR pszDescription, int ncDesciptionBufLen);
    STDMETHODIMP SetArguments(LPCSTR pcszArgs);
    STDMETHODIMP GetArguments(LPSTR pszArgs, int ncArgsBufLen);
    STDMETHODIMP SetWorkingDirectory(LPCSTR pcszWorkingDirectory);
    STDMETHODIMP GetWorkingDirectory(LPSTR pszWorkingDirectory, int ncbLen);
    STDMETHODIMP SetHotkey(WORD wHotkey);
    STDMETHODIMP GetHotkey(PWORD pwHotkey);
    STDMETHODIMP SetShowCmd(int nShowCmd);
    STDMETHODIMP GetShowCmd(PINT pnShowCmd);
    STDMETHODIMP SetIconLocation(LPCSTR pcszIconFile, int niIcon);
    STDMETHODIMP GetIconLocation(LPSTR pszIconFile, int ncbLen, PINT pniIcon);
    STDMETHODIMP Resolve(HWND hwnd, DWORD dwFlags);

    // IShellLinkW functions that change from the A functions...
    STDMETHODIMP SetPath(LPCWSTR pcszPath);
    STDMETHODIMP GetPath(LPWSTR pszFile, int ncFileBufLen, PWIN32_FIND_DATAW pwfd, DWORD dwFlags);
    STDMETHODIMP SetRelativePath(LPCWSTR pcszRelativePath, DWORD dwReserved);
    STDMETHODIMP SetDescription(LPCWSTR pcszDescription);
    STDMETHODIMP GetDescription(LPWSTR pszDescription, int ncDesciptionBufLen);
    STDMETHODIMP SetArguments(LPCWSTR pcszArgs);
    STDMETHODIMP GetArguments(LPWSTR pszArgs, int ncArgsBufLen);
    STDMETHODIMP SetWorkingDirectory(LPCWSTR pcszWorkingDirectory);
    STDMETHODIMP GetWorkingDirectory(LPWSTR pszWorkingDirectory, int ncbLen);
    STDMETHODIMP SetIconLocation(LPCWSTR pcszIconFile, int niIcon);
    STDMETHODIMP GetIconLocation(LPWSTR pszIconFile, int ncbLen, PINT pniIcon);

    // IShellPropSheetExt methods

    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

    // IContextMenu methods

    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(IN LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT * puReserved, LPSTR pszName, UINT cchMax);
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUniformResourceLocatorA methods

    STDMETHODIMP SetURL(LPCSTR pcszURL, DWORD dwFlags);
    STDMETHODIMP GetURL(LPSTR *ppszURL);
    STDMETHODIMP InvokeCommand(PURLINVOKECOMMANDINFOA purlici);
    
    // IUniformResourceLocatorW methods

    STDMETHODIMP SetURL(LPCWSTR pcszURL, DWORD dwFlags);
    STDMETHODIMP GetURL(LPWSTR *ppszURL);
    STDMETHODIMP InvokeCommand(PURLINVOKECOMMANDINFOW purlici);
    
    // IPropertySetStorage methods

    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    // IQueryInfo methods

    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
                                ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
                        
    // IQueryCodePage methods 
    // Purpose: This is a hack to use the URL to store the codepage for
    // send currenct document and pass it to sendmail.dll
    STDMETHODIMP GetCodePage(UINT * puiCodePage);
    STDMETHODIMP SetCodePage(UINT uiCodePage);

    // *** IObjectWithSite methods from CObjectWithSite***
    /*
    virtual STDMETHODIMP SetSite(IUnknown *pUnkSite);        
    virtual STDMETHODIMP GetSite(REFIID riid, void **ppvSite);
    */

    // INamedPropertyBag Methods
    STDMETHODIMP ReadPropertyNPB(/* [in] */ LPCOLESTR pszSectionname, 
                                       /* [in] */ LPCOLESTR pszPropName, 
                                       /* [out] */ PROPVARIANT *pVar);
                            
    STDMETHODIMP WritePropertyNPB(/* [in] */ LPCOLESTR pszSectionname, 
                                        /* [in] */ LPCOLESTR pszPropName, 
                                        /* [in] */ PROPVARIANT  *pVar);


    STDMETHODIMP RemovePropertyNPB (/* [in] */ LPCOLESTR pszBagname,
                                    /* [in] */ LPCOLESTR pszPropName);
    
    // IUnknown methods
    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // other methods
    
    STDMETHODIMP SaveToFile(LPCTSTR pcszFile, BOOL bRemember);
    STDMETHODIMP LoadFromFile(LPCTSTR pcszFile);
    STDMETHODIMP LoadFromAsyncFileNow();
    STDMETHODIMP GetCurFile(LPTSTR pszFile, UINT ucbLen);
    STDMETHODIMP Dirty(BOOL bDirty);
    STDMETHODIMP GetURLIconLocation(UINT uInFlags, LPTSTR pszBuf, UINT cchBuf, int * pniIcon, BOOL fRecentlyChanged, OUT PUINT  puOutFlags);
    
    STDMETHODIMP GetIconLocationFromFlags(UINT uInFlags, LPTSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags, DWORD dwPropFlags);
    STDMETHODIMP_(void) ChangeNotify(LONG wEventId, UINT uFlags);
    STDMETHODIMP GetIDListInternal(LPITEMIDLIST *ppidl);
    STDMETHODIMP GetURLW(WCHAR **ppszURL);
    BOOL ExtractIconFromWininetCache(IN  LPCTSTR pszIconString, 
                                     IN  UINT iIcon, 
                                     OUT HICON * phiconLarge, 
                                     OUT HICON * phiconSmall, 
                                     IN  UINT ucIconSize,
                                     BOOL *pfFoundUrl,
                                     DWORD dwPropFlags);
    STDMETHODIMP _GetIconLocationWithURLHelper(IN  LPTSTR pszBuf,
                                               IN  int    cchBuf,
                                               OUT PINT   pniIcon,
                                               IN  LPTSTR pszActualUrl,
                                               UINT cchUrlBufSize,
                                               BOOL fRecentlyChanged);

    STDMETHODIMP _DoIconDownload();
    STDMETHODIMP _SaveOffPersistentDataFromSite();
    STDMETHODIMP _CreateTemporaryBackingFile();
    STDMETHODIMP _SetTempFileName(TCHAR *pszTempFileName);
    STDMETHODIMP _ComputeDescription();
    STDMETHODIMP_(BOOL) _IsInFavoritesFolder();
    IDataObject *GetInitDataObject() { ASSERT(m_pInitDataObject); return m_pInitDataObject; }
    STDMETHODIMP_(BOOL)_TryLink(REFIID riid, void **ppvOut);
    STDMETHODIMP _CreateShellLink(LPCTSTR pszPath, IUnknown **ppunk);


    // Query methods

    STDMETHODIMP_(DWORD) GetScheme(void);

#ifdef DEBUG
    STDMETHODIMP_(void) Dump(void);
    friend BOOL IsValidPCIntshcut(const Intshcut *pcintshcut);
#endif
};

typedef Intshcut * PIntshcut;
typedef const Intshcut CIntshcut;
typedef const Intshcut * PCIntshcut;



/* Prototypes
 *************/

// isbase.cpp

HRESULT ValidateURL(LPCTSTR pcszURL);

HRESULT IsProtocolRegistered(LPCTSTR pcszProtocol);

BOOL    AnyMeatW(LPCWSTR pcsz);
BOOL    AnyMeatA(LPCSTR pcsz);
#ifdef UNICODE
#define AnyMeat     AnyMeatW
#else
#define AnyMeat     AnyMeatA
#endif

BOOL    IsWebsite(Intshcut * pintshcut);

#define ISHCUT_INISTRING_SECTION      TEXT("InternetShortcut")
#define ISHCUT_INISTRING_SECTIONW         L"InternetShortcut"
#define ISHCUT_INISTRING_URL          TEXT("URL")
#define ISHCUT_INISTRING_WORKINGDIR   TEXT("WorkingDirectory")
#define ISHCUT_INISTRING_WHATSNEW     TEXT("WhatsNew")
#define ISHCUT_INISTRING_AUTHOR       TEXT("Author")
#define ISHCUT_INISTRING_DESC         TEXT("Desc")
#define ISHCUT_INISTRING_COMMENT      TEXT("Comment")
#define ISHCUT_INISTRING_MODIFIED     TEXT("Modified")
#define ISHCUT_INISTRING_ICONINDEX    TEXT("IconIndex")
#define ISHCUT_INISTRING_ICONINDEXW       L"IconIndex"
#define ISHCUT_INISTRING_ICONFILE     TEXT("IconFile")
#define ISHCUT_INISTRING_ICONFILEW         L"IconFile"

#define ISHCUT_DEFAULT_FAVICONW            L"favicon.ico";
#define ISHCUT_DEFAULT_FAVICONATROOTW      L"/favicon.ico";


HRESULT 
GetGenericURLIcon(
    LPTSTR pszIconFile,
    UINT cchIconFile, 
    PINT pniIcon);


struct IS_SUBS_DEL_DATA
{
    TCHAR m_szFile[MAX_PATH];
    LPWSTR m_pwszURL;

    ~IS_SUBS_DEL_DATA()
    {
        if (m_pwszURL)
        {
            SHFree(m_pwszURL);
        }
    }
};

#endif  // __cplusplus


//
// Prototypes for all modules
//

STDAPI  CopyURLProtocol(LPCTSTR pcszURL, LPTSTR * ppszProtocol, PARSEDURL * ppu);

#endif  // _INTSHCUT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\libx.cpp ===
//***   libx.cpp -- 'source library' inclusions
// DESCRIPTION
//  there are some things that we share in source (rather than .obj or .dll)
// form.  this file builds them in the current directory.

#include "priv.h"

#include "..\inc\uassist.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\isnewshk.cpp ===
/*
 * isnewshk.cpp - INewShortcutHook implementation for URL class.
 */


#include "priv.h"
#include "ishcut.h"

#include "resource.h"

#include <mluisupp.h>

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

STDMETHODIMP
Intshcut::SetReferent(
    LPCTSTR pcszReferent,
    HWND hwndParent)
{
    HRESULT hr;
    TCHAR szURL[MAX_URL_STRING];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRING_PTR(pcszReferent, -1));
    ASSERT(IS_VALID_HANDLE(hwndParent, WND));

    hr = IURLQualify(pcszReferent, UQF_IGNORE_FILEPATHS | UQF_GUESS_PROTOCOL, szURL, NULL, NULL);
    if (SUCCEEDED(hr))
    {
        hr = ValidateURL(szURL);

        if (hr == S_OK)
            hr = SetURL(szURL, 0);
    }

    if (S_OK != hr)
    {
        ASSERT(FAILED(hr));

        // Massage result
        switch (hr)
        {
            case URL_E_INVALID_SYNTAX:
            case URL_E_UNREGISTERED_PROTOCOL:
                hr = S_FALSE;
                break;

            default:
                break;
        }

        TraceMsg(TF_INTSHCUT, "Intshcut::SetReferent(): Failed to set referent to %s.",
                   pcszReferent);
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


STDMETHODIMP Intshcut::GetReferent(PTSTR pszReferent, int cchReferent)
{
    HRESULT hr = InitProp();
    if (SUCCEEDED(hr))
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        hr = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        if (S_OK == hr)
        {
            if (lstrlen(szURL) < cchReferent)
            {
                StrCpyN(pszReferent, szURL, cchReferent);
                hr = S_OK;
            }
            else
                hr = E_FAIL;
        }
        else
            hr = S_FALSE;

        if (hr != S_OK)
        {
            if (cchReferent > 0)
                *pszReferent = '\0';
        }
    }
    return hr;
}


STDMETHODIMP Intshcut::SetFolder(LPCTSTR pcszFolder)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(PathIsDirectory(pcszFolder));

    if (Str_SetPtr(&m_pszFolder, pcszFolder))
    {
        hr = S_OK;

        TraceMsg(TF_INTSHCUT, "Intshcut::SetFolder(): Set folder to %s.",
                   m_pszFolder);
    }
    else
        hr = E_OUTOFMEMORY;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}


STDMETHODIMP
Intshcut::GetFolder(
    LPTSTR pszFolder,
    int cchFolder)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszFolder, TCHAR, cchFolder));

    if (m_pszFolder)
    {
        if (lstrlen(m_pszFolder) < cchFolder)
        {
            StrCpyN(pszFolder, m_pszFolder, cchFolder);

            hr = S_OK;

            TraceMsg(TF_INTSHCUT, "Intshcut::GetFolder(): Returning folder %s.",
                     pszFolder);
        }
        else
            hr = E_FAIL;
    }
    else
        hr = S_FALSE;

    if (hr != S_OK)
    {
        if (cchFolder > 0)
            *pszFolder = '\0';
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT((hr == S_OK &&
            IS_VALID_STRING_PTR(pszFolder, -1) &&
            EVAL(lstrlen(pszFolder) < cchFolder)) ||
           ((hr == S_FALSE ||
             hr == E_FAIL) &&
            EVAL(! cchFolder ||
                 ! *pszFolder)));

    return(hr);
}


STDMETHODIMP
Intshcut::GetName(
    LPTSTR pszName,
    int cchBuf)
{
    HRESULT hr = E_FAIL;
    TCHAR rgchShortName[MAX_PATH];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszName, TCHAR, cchBuf));

    hr = E_FAIL;

    if (MLLoadString(IDS_SHORT_NEW_INTSHCUT, rgchShortName, SIZECHARS(rgchShortName)))
    {
        TCHAR rgchLongName[MAX_PATH];

        if (MLLoadString(IDS_NEW_INTSHCUT, rgchLongName, SIZECHARS(rgchLongName)))
        {
            TCHAR rgchCurDir[MAX_PATH];
            LPCTSTR pcszFolderToUse;

            // Use current directory if m_pszFolder has not been set.

            pcszFolderToUse = m_pszFolder;

            if (! pcszFolderToUse)
            {
                if (GetCurrentDirectory(SIZECHARS(rgchCurDir), rgchCurDir) > 0)
                    pcszFolderToUse = rgchCurDir;
            }

            if (pcszFolderToUse)
            {
                TCHAR rgchUniqueName[MAX_PATH];

                if (PathYetAnotherMakeUniqueName(rgchUniqueName, pcszFolderToUse,
                                                 rgchShortName, rgchLongName))
                {
                    PTSTR pszFileName;
                    PTSTR pszRemoveExt;

                    pszFileName = (PTSTR)PathFindFileName(rgchUniqueName);
                    pszRemoveExt = (PTSTR)PathFindExtension(pszFileName);
                    *pszRemoveExt = '\0';

                    if (lstrlen(pszFileName) < cchBuf)
                    {
                        StrCpyN(pszName, pszFileName, cchBuf);
                        hr = S_OK;
                    }
                }
            }
        }
    }

    if (hr == S_OK)
        TraceMsg(TF_INTSHCUT, "Intshcut::GetName(): Returning %s.", pszName);

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT((hr == S_OK &&
            IS_VALID_STRING_PTR(pszName, -1) &&
            EVAL(lstrlen(pszName) < cchBuf)) ||
           (hr == E_FAIL &&
            (! cchBuf ||
             ! *pszName)));

    return(hr);
}


STDMETHODIMP
Intshcut::GetExtension(
    LPTSTR pszExtension,
    int cchBufMax)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszExtension, TCHAR, cchBufMax));

    if (SIZECHARS(TEXT(".url")) < cchBufMax)
    {
        StrCpyN(pszExtension, TEXT(".url"), cchBufMax);

        hr = S_OK;

        TraceMsg(TF_INTSHCUT, "Intshcut::GetExtension(): Returning extension %s.",
                   pszExtension);
    }
    else
    {
        if (cchBufMax > 0)
            *pszExtension = '\0';

        hr = E_FAIL;
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT((hr == S_OK &&
            IS_VALID_STRING_PTR(pszExtension, -1) &&
            EVAL(lstrlen(pszExtension) < cchBufMax)) ||
           (hr == E_FAIL &&
            EVAL(! cchBufMax ||
                 ! *pszExtension)));

    return(hr);
}


// Ansi versions.  Needed for W9x

STDMETHODIMP
Intshcut::SetReferent(
    LPCSTR pcszReferent,
    HWND hwndParent)
{
    HRESULT hr;

    WCHAR szReferent[MAX_URL_STRING];
    ASSERT(lstrlenA(pcszReferent) + 1 < ARRAYSIZE(szReferent));

    SHAnsiToUnicode(pcszReferent, szReferent, ARRAYSIZE(szReferent));

    hr = SetReferent(szReferent, hwndParent);

    return hr;
}


STDMETHODIMP Intshcut::GetReferent(PSTR pszReferent, int cchReferent)
{
    HRESULT hr;

    WCHAR szReferent[MAX_URL_STRING];

    ASSERT(cchReferent <= ARRAYSIZE(szReferent));

    hr = GetReferent(szReferent, ARRAYSIZE(szReferent));

    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szReferent, pszReferent, cchReferent);

    return hr;
}


STDMETHODIMP Intshcut::SetFolder(LPCSTR pcszFolder)
{
    HRESULT hr;

    WCHAR szFolder[MAX_PATH];
    ASSERT(lstrlenA(pcszFolder) + 1 < ARRAYSIZE(szFolder))

    SHAnsiToUnicode(pcszFolder, szFolder, ARRAYSIZE(szFolder));

    hr = SetFolder(szFolder);
    
    return(hr);
}


STDMETHODIMP
Intshcut::GetFolder(
    LPSTR pszFolder,
    int cchFolder)
{
    HRESULT hr;

    WCHAR szFolder[MAX_PATH];
    ASSERT(cchFolder <= ARRAYSIZE(szFolder));

    hr = GetFolder(szFolder, ARRAYSIZE(szFolder));

    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szFolder, pszFolder, cchFolder);

    return hr;
}


STDMETHODIMP
Intshcut::GetName(
    LPSTR pszName,
    int cchBuf)
{
    HRESULT hr;

    WCHAR szName[MAX_PATH];
    ASSERT(cchBuf <= ARRAYSIZE(szName));

    hr = GetName(szName, ARRAYSIZE(szName));

    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szName, pszName, cchBuf);

    return hr;
}


STDMETHODIMP
Intshcut::GetExtension(
    LPSTR pszExtension,
    int cchBufMax)
{
    HRESULT hr;

    WCHAR szExtension[MAX_PATH];
    ASSERT(cchBufMax<= ARRAYSIZE(szExtension));

    hr = GetExtension(szExtension, ARRAYSIZE(szExtension));

    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szExtension, pszExtension, cchBufMax);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\ispersis.cpp ===
/*
 * ispersis.cpp - IPersist, IPersistFile, and IPersistStream implementations for
 *               URL class.
 */


#include "priv.h"
#include "ishcut.h"

#include "resource.h"

// Need to flush the file to prevent win95 from barfing after stuff is written in
VOID FlushFile(LPCTSTR pszFile)
{
    if (!g_fRunningOnNT)
    {
        WritePrivateProfileString(NULL, NULL, NULL, pszFile);
    }
}


// save object to file

STDMETHODIMP Intshcut::SaveToFile(LPCTSTR pszFile, BOOL bRemember)
{
    HRESULT hres = InitProp();
    if (SUCCEEDED(hres))
    {
        m_pprop->SetFileName(pszFile);

        hres = m_pprop->Commit(STGC_DEFAULT);

        // Remember file if requested 

        if (SUCCEEDED(hres))
        {
            if (bRemember)
            {
                Dirty(FALSE);

                if ( !Str_SetPtr(&m_pszFile, pszFile) )
                    hres = E_OUTOFMEMORY;

#ifdef DEBUG
                Dump();
#endif
            }
            SHChangeNotify(SHCNE_UPDATEITEM, (SHCNF_PATH | SHCNF_FLUSH), pszFile, NULL);
        }

        if (!bRemember)
            m_pprop->SetFileName(m_pszFile);
    }

    if(pszFile && (S_OK == hres))
        FlushFile(pszFile);
    return hres;
}

STDMETHODIMP Intshcut::LoadFromFile(LPCTSTR pszFile)
{
    HRESULT hres;

    if (Str_SetPtr(&m_pszFile, pszFile))
    {
        hres = InitProp();
#ifdef DEBUG
        Dump();
#endif
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}


STDMETHODIMP Intshcut::LoadFromAsyncFileNow()
{
    HRESULT hres = S_OK;
    if (m_pszFileToLoad)
    {
        hres = LoadFromFile(m_pszFileToLoad);
        Str_SetPtr(&m_pszFileToLoad, NULL);
    }    
    return hres;
}

STDMETHODIMP Intshcut::GetCurFile(LPTSTR pszFile, UINT cchLen)
{
    HRESULT hr;

    if (m_pszFile)
    {
        StrCpyN(pszFile, m_pszFile, cchLen);
        hr = S_OK;
    }
    else
        hr = S_FALSE;

    return hr;
}

STDMETHODIMP Intshcut::Dirty(BOOL bDirty)
{
    HRESULT hres;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    
    if (bDirty)
    {
        if (IsFlagClear(m_dwFlags, ISF_DIRTY))
            TraceMsg(TF_INTSHCUT, "Intshcut now dirty.");
        
        SetFlag(m_dwFlags, ISF_DIRTY);
    }
    else
    {
        if (IsFlagSet(m_dwFlags, ISF_DIRTY))
            TraceMsg(TF_INTSHCUT, "Intshcut now clean.");
        
        ClearFlag(m_dwFlags, ISF_DIRTY);
    }
    
    hres = S_OK;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    
    return hres;
}

// IPersist::GetClassID method for Intshcut

STDMETHODIMP Intshcut::GetClassID(CLSID *pclsid)
{
    ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

    *pclsid = CLSID_InternetShortcut;
    return S_OK;
}


// IPersistFile::IsDirty handler for Intshcut

STDMETHODIMP Intshcut::IsDirty(void)
{
    HRESULT hres = LoadFromAsyncFileNow();

    if(SUCCEEDED(hres))
    {
        hres = InitProp();
        if (SUCCEEDED(hres))
        {
            if (IsFlagSet(m_dwFlags, ISF_DIRTY) || S_OK == m_pprop->IsDirty())
                hres = S_OK;
            else
                hres = S_FALSE;
        }
    }
    return hres;
}

// Helper function to save off Trident specific stuff 

STDMETHODIMP Intshcut::_SaveOffPersistentDataFromSite()
{
    IOleCommandTarget *pcmdt = NULL;
    HRESULT hr = S_OK;
    if (_punkSite)
    {
        if(S_OK == _CreateTemporaryBackingFile())
        {
            ASSERT(m_pszTempFileName);
            hr = _punkSite->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pcmdt);
            if((S_OK == hr))
            {
                ASSERT(pcmdt);
                VARIANT varIn = {0};
                varIn.vt = VT_UNKNOWN;
                varIn.punkVal = (LPUNKNOWN)(SAFECAST(this, IUniformResourceLocator *));
                
                // Tell the site to save off it's persistent stuff
                hr = pcmdt->Exec(&CGID_ShortCut, CMDID_INTSHORTCUTCREATE, 0, &varIn, NULL);
                
                pcmdt->Release();
            }
            FlushFile(m_pszTempFileName);
        }
    }
    return hr;
}

// IPersistFile::Save handler for Intshcut

STDMETHODIMP Intshcut::Save(LPCOLESTR pwszFile, BOOL bRemember)
{
    HRESULT hres = LoadFromAsyncFileNow();
    if (SUCCEEDED(hres))
    {
        TCHAR szFile[MAX_PATH];

        if (pwszFile)
            SHUnicodeToTChar(pwszFile, szFile, SIZECHARS(szFile));
        else if (m_pszFile)
            StrCpyN(szFile, m_pszFile, ARRAYSIZE(szFile));
        else
            return E_FAIL;
        
        // Perhaps there is a site which wants to save off stuff ?
        // However, the site may end up calling via intefaces 
        hres = _SaveOffPersistentDataFromSite();

        if ((S_OK == hres) && (m_pszTempFileName) && (StrCmp(m_pszTempFileName, szFile) != 0))
        {
            // Copy contents of the temp file to the destination
            // if they are different files
            EVAL(CopyFile(m_pszTempFileName, szFile, FALSE));
        }

        // Then save off in memory stuff to this file
        hres = SaveToFile(szFile, bRemember);
    }
    return hres;
}

STDMETHODIMP Intshcut::SaveCompleted(LPCOLESTR pwszFile)
{
    return S_OK;
}

// IPersistFile::Load()

STDMETHODIMP Intshcut::Load(LPCOLESTR pwszFile, DWORD dwMode)
{
    HRESULT hres;

    if (m_pszFile || m_pszFileToLoad)
    {
        hres = E_FAIL; // can't ::Load twice
    }
    else
    {
        if (m_fMustLoadSync)
            hres = LoadFromFile(pwszFile);
        else
        {
            if (Str_SetPtr(&m_pszFileToLoad, pwszFile))
                hres = S_OK;
            else
                hres = E_OUTOFMEMORY;
        }
    }
    return hres;
}

// IPersistFile::GetCurFile method for Intshcut

STDMETHODIMP Intshcut::GetCurFile(WCHAR **ppwszFile)
{
    HRESULT hr;
    TCHAR szTempFile[MAX_PATH];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_PTR(ppwszFile, LPOLESTR));

    hr = LoadFromAsyncFileNow();
    if (FAILED(hr))
        return hr;

    if (m_pszFile)
    {
        StrCpyN(szTempFile, m_pszFile, SIZECHARS(szTempFile));
        hr = S_OK;
    }
    else
    {
        StrCpyN(szTempFile, TEXT("*.url"), ARRAYSIZE(szTempFile));
        hr = S_FALSE;
    }

    HRESULT hrTemp = SHStrDup(szTempFile, ppwszFile);
    if (FAILED(hrTemp))
        hr = hrTemp;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}

// IPersistStream::Load method for Intshcut

STDMETHODIMP Intshcut::Load(IStream *pstm)
{
    // to implement this: 
    //      save stream to temp.ini
    //      IPersistFile::Load() from that
    //      delete temp file
    return E_NOTIMPL;
}

// IPersistStream::Save method for Intshcut
STDMETHODIMP Intshcut::Save(IStream *pstm, BOOL bClearDirty)
{
    HRESULT hr = InitProp();
    if (SUCCEEDED(hr))
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        hr = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        if (SUCCEEDED(hr))
        {
            LPSTR pszContents;
            hr = CreateURLFileContents(szURL, &pszContents);
            if (SUCCEEDED(hr)) {
                ASSERT(hr == lstrlenA(pszContents));
                hr = pstm->Write(pszContents, hr + 1, NULL);
                GlobalFree(pszContents);
                pszContents = NULL;
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    
    return hr;
}

// IPersistStream::GetSizeMax method for Intshcut

STDMETHODIMP Intshcut::GetSizeMax(PULARGE_INTEGER puliSize)
{
    puliSize->LowPart = 0;
    puliSize->HighPart = 0;

    HRESULT hr = InitProp();
    if (SUCCEEDED(hr))
    {
        puliSize->LowPart = GetFileContentsAndSize(NULL);
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP Intshcut::_SetTempFileName(TCHAR *pszTempFileName)
{
    ASSERT(NULL == m_pszTempFileName);
    if (m_pszTempFileName)
        DeleteFile(m_pszTempFileName);
        
    Str_SetPtr(&m_pszTempFileName, pszTempFileName);
    return (m_pszTempFileName ? S_OK : E_OUTOFMEMORY);
}

STDMETHODIMP Intshcut::_CreateTemporaryBackingFile()
{
    HRESULT hres = E_FAIL;

    if (m_pszTempFileName)
        return S_OK;

    TCHAR szTempFileName[MAX_PATH];
    TCHAR szDirectory[MAX_PATH];
    
    DWORD dwRet = GetTempPath(ARRAYSIZE(szDirectory),  szDirectory);

    if ((FALSE == dwRet) || (FALSE == PathFileExists(szDirectory)))
    {
        szDirectory[0] = TEXT('\\');
        szDirectory[1] = TEXT('\0');
        dwRet = TRUE;
    }

    dwRet =  GetTempFileName(szDirectory, TEXT("www"), 0, szTempFileName);
    if (dwRet)
    {
        hres = _SetTempFileName(szTempFileName);
        // Now copy over the current file from which this was loaded and then save off
        // any changes
        if (S_OK == hres)
        {
            if (m_pszFile)
            {
                EVAL(CopyFile(m_pszFile, m_pszTempFileName, FALSE));
                SaveToFile(m_pszTempFileName, FALSE); // this flushes the file
            }
        }
    }

    return hres;
}

// Calculate the size of the contents to be transferred in a block.
STDMETHODIMP_(DWORD) Intshcut::GetFileContentsAndSize(LPSTR *ppszBuf)
{
    DWORD cbSize = 0;    // this is in bytes, not characters
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    BOOL fSuccess = FALSE;
    HRESULT hres;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(m_pprop);

    if (ppszBuf)
        *ppszBuf = NULL;
    
    // Create a temporary backing File here and save off everything that needs to be 
    // saved off there and use that to satisfy this request
    if (S_OK == _CreateTemporaryBackingFile())
    {
        ASSERT(m_pszTempFileName);
        
        WCHAR wszTemp[MAX_PATH];
        SHTCharToUnicode(m_pszTempFileName, wszTemp, ARRAYSIZE(wszTemp));
        
        hres = Save(wszTemp, FALSE); // So our temp file is now up to date
        
        // Just copy the file
        HANDLE hFile = CreateFile(m_pszTempFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwTemp = 0;
            cbSize = GetFileSize(hFile, &dwTemp);
            if (ppszBuf)
            {
                if (0xFFFFFFFF != cbSize)
                {
                    ASSERT(0 == dwTemp);
                    *ppszBuf = (LPSTR)LocalAlloc(LPTR, cbSize);
                    if (*ppszBuf)
                    {
                        dwTemp = 0;
                        if(ReadFile(hFile, *ppszBuf, cbSize, &dwTemp, NULL))
                        {
                            ASSERT(cbSize >= dwTemp);
                            fSuccess = TRUE;
                        }
                    }
                }
            }
            else
            {
                fSuccess = TRUE; // Just want the size - not contents
            }
            CloseHandle(hFile);
        }
        
        if (FALSE == fSuccess)
        {
            cbSize = 0;
            if(ppszBuf && (*ppszBuf))
            {
                LocalFree(*ppszBuf);
                *ppszBuf = NULL;
            }
        }
    }
    
    if (FALSE == fSuccess)
    {
        // if you couldn't read the file, then perhaps atleast this will work ?
        HRESULT hr = InitProp();
        if (SUCCEEDED(hr) && SUCCEEDED(m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL))))
        {
            hr = CreateURLFileContents(szURL, ppszBuf);

            // IEUNIX-This function should return the strlen not including the
            // null characters as this causes the shortcut file  having a null
            // character causing a crash in the execution of the link.
            // Fortunately, that's what CreateURLFileContents returns
            
            cbSize = SUCCEEDED(hr) ? hr : 0;
        }
    }
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    
    return cbSize;
}

#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS      0x00000400
#endif

// transfer the URL data in URL clipboard 
STDMETHODIMP Intshcut::TransferUniformResourceLocator(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
    ASSERT(pfmtetc->lindex == -1);

    if (pfmtetc->tymed & TYMED_HGLOBAL)
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        ASSERT(m_pprop);
        hr = InitProp();
        if (SUCCEEDED(hr))
        {
            hr = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
            if (SUCCEEDED(hr))
            {
                int cch = lstrlen(szURL) + 1;
                int cb = (cch-1) * 9 + 1; // the biggest result is an utf8 escaped version of the string
                                          // utf8 encoding can blow the size up to 3 times
                                          // escaping can blow each byte up to 3 times
                LPSTR pszURL = (LPSTR)GlobalAlloc(GPTR, cb);
                if (pszURL)
                {
                    if (pfmtetc->cfFormat == CF_UNICODETEXT || pfmtetc->cfFormat == g_cfURLW)
                    {
                        StrCpyN((LPWSTR)pszURL, szURL, cch);
                    }
                    else
                    {
                        BOOL bUsedDefaultChar = FALSE;
                        DWORD dwFlags = 0;
                        if (IsOS(OS_WIN2000ORGREATER) || IsOS(OS_WIN98ORGREATER))
                        {
                            dwFlags |= WC_NO_BEST_FIT_CHARS;
                        }
                        int wcResult = WideCharToMultiByte(CP_ACP,
                                            dwFlags,
                                            szURL,
                                            cch,
                                            pszURL,
                                            cb,
                                            NULL,
                                            &bUsedDefaultChar);
                        if ((0 == wcResult) || bUsedDefaultChar)
                        {
                            // the string is weird and can't be converted back to unicode
                            // we're going to utf8-escaped encode it
                            ConvertToUtf8Escaped(szURL, ARRAYSIZE(szURL));
                            SHUnicodeToAnsi(szURL, pszURL, cb);
                        }                    
                    }
                    pstgmed->tymed = TYMED_HGLOBAL;
                    pstgmed->hGlobal = pszURL;
                }
            }
        }
    }
    else
        hr = DV_E_TYMED;

    return hr;
}

// transfer the URL data in text
STDMETHODIMP Intshcut::TransferText(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    return TransferUniformResourceLocator(pfmtetc, pstgmed);
}

// assumes the current seek pos in the stream is at the start

BOOL GetStreamMimeAndExt(LPCWSTR pszURL, IStream *pstm, 
                         LPTSTR pszMime, UINT cchMime, LPTSTR pszExt, UINT cchExt)
{
    BYTE buf[256];
    ULONG cbRead;
    pstm->Read(buf, SIZEOF(buf), &cbRead);

    WCHAR *pwszMimeOut;
    if (SUCCEEDED(FindMimeFromData(NULL, pszURL, buf, cbRead, NULL, 0, &pwszMimeOut, 0)))
    {
        TCHAR szMimeTemp[MAX_PATH];

        if (pszMime == NULL)
        {
            pszMime = szMimeTemp;
            cchMime = ARRAYSIZE(szMimeTemp);
        }

        SHUnicodeToTChar(pwszMimeOut, pszMime, cchMime);
        CoTaskMemFree(pwszMimeOut);

        if (pszExt)
            MIME_GetExtension(pszMime, pszExt, cchExt);
    }

    // const LARGE_INTEGER c_li0 = {0, 0};
    pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);

    return TRUE;
}

// pszName is assumed to be MAX_PATH

STDMETHODIMP Intshcut::GetDocumentName(LPTSTR pszName)
{
    GetDescription(pszName, MAX_PATH);
                
    WCHAR *pszURL;
    if (S_OK == GetURLW(&pszURL))
    {
        IStream *pstm;
        if (SUCCEEDED(URLOpenBlockingStreamW(NULL, pszURL, &pstm, 0, NULL)))
        {
            TCHAR szExt[MAX_PATH];
            GetStreamMimeAndExt(pszURL, pstm, NULL, 0, szExt, ARRAYSIZE(szExt));

            PathRenameExtension(pszName, szExt);
            
            pstm->Release();
        }
        SHFree(pszURL);
    }
    return S_OK;
}

// transfer URL data in file-group-descriptor clipboard format.
STDMETHODIMP Intshcut::TransferFileGroupDescriptorA(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    if (pfmtetc->dwAspect != DVASPECT_COPY  &&
        pfmtetc->dwAspect != DVASPECT_LINK  &&
        pfmtetc->dwAspect != DVASPECT_CONTENT)
    {
        hr = DV_E_DVASPECT;
    }
    else if (pfmtetc->tymed & TYMED_HGLOBAL)
    {
        FILEGROUPDESCRIPTORA * pfgd = (FILEGROUPDESCRIPTORA *)GlobalAlloc(GPTR, SIZEOF(FILEGROUPDESCRIPTORA));
        if (pfgd)
        {
            FILEDESCRIPTORA * pfd = &(pfgd->fgd[0]);
            TCHAR szTemp[MAX_PATH]; 

            if (pfmtetc->dwAspect == DVASPECT_COPY)
            {
                pfd->dwFlags = FD_FILESIZE;
                GetDocumentName(szTemp);
            }
            else
            {
                pfd->dwFlags = FD_FILESIZE | FD_LINKUI;
                GetDescription(szTemp, ARRAYSIZE(szTemp));
            }
            SHTCharToAnsi(PathFindFileName(szTemp), pfd->cFileName, SIZECHARS(pfd->cFileName));

            pfd->nFileSizeHigh = 0;
            pfd->nFileSizeLow = GetFileContentsAndSize(NULL);

            pfgd->cItems = 1;

            pstgmed->tymed = TYMED_HGLOBAL;
            pstgmed->hGlobal = pfgd;

            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = DV_E_TYMED;

    return hr;
}

// transfer URL data in file-group-descriptor clipboard format.
STDMETHODIMP Intshcut::TransferFileGroupDescriptorW(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    if (pfmtetc->dwAspect != DVASPECT_COPY  &&
        pfmtetc->dwAspect != DVASPECT_LINK  &&
        pfmtetc->dwAspect != DVASPECT_CONTENT)
    {
        hr = DV_E_DVASPECT;
    }
    else if (pfmtetc->tymed & TYMED_HGLOBAL)
    {
        FILEGROUPDESCRIPTORW * pfgd = (FILEGROUPDESCRIPTORW *)GlobalAlloc(GPTR, SIZEOF(FILEGROUPDESCRIPTORW));
        if (pfgd)
        {
            FILEDESCRIPTORW * pfd = &(pfgd->fgd[0]);
            TCHAR szTemp[MAX_PATH];
            
            if (pfmtetc->dwAspect == DVASPECT_COPY)
            {
                pfd->dwFlags = FD_FILESIZE;
                GetDocumentName(szTemp);
            }
            else
            {
                pfd->dwFlags = FD_FILESIZE | FD_LINKUI;
                GetDescription(szTemp, ARRAYSIZE(szTemp));
            }

            SHTCharToUnicode(PathFindFileName(szTemp), pfd->cFileName, SIZECHARS(pfd->cFileName));

            pfd->nFileSizeHigh = 0;
            pfd->nFileSizeLow = GetFileContentsAndSize(NULL);

            pfgd->cItems = 1;

            pstgmed->tymed = TYMED_HGLOBAL;
            pstgmed->hGlobal = pfgd;

            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = DV_E_TYMED;

    return hr;
}

#if defined(BIG_ENDIAN) && defined(BYTE_ORDER)
#if BYTE_ORDER != BIG_ENDIAN
#undef BIG_ENDIAN
#endif
#endif

#ifdef BIG_ENDIAN
#define BOM 0xfffe
#else
#define BOM 0xfeff
#endif

STDMETHODIMP Intshcut::GetDocumentStream(IStream **ppstm)
{
    *ppstm = NULL;

    WCHAR *pszURL;
    HRESULT hres = GetURLW(&pszURL);
    if (S_OK == hres)
    {
        IStream *pstm;
        hres = URLOpenBlockingStreamW(NULL, pszURL, &pstm, 0, NULL);
        if (SUCCEEDED(hres))
        {
            TCHAR szMime[80];

            if (GetStreamMimeAndExt(pszURL, pstm, szMime, ARRAYSIZE(szMime), NULL, 0) &&
                StrCmpI(szMime, TEXT("text/html")) == 0)
            {
                IStream *aStreams[2];

                if(m_uiCodePage == 1200)    // Unicode
                {
                    WCHAR wzBaseTag[INTERNET_MAX_URL_LENGTH + 20];

                    wnsprintfW(wzBaseTag, ARRAYSIZE(wzBaseTag), TEXT("%wc<BASE HREF=\"%ws\">\n"), (WCHAR)BOM, pszURL);
                    aStreams[0] = SHCreateMemStream((BYTE *)wzBaseTag, lstrlenW(wzBaseTag) * SIZEOF(wzBaseTag[0]));
                }
                else
                {
                    CHAR szURL[INTERNET_MAX_URL_LENGTH], szBaseTag[INTERNET_MAX_URL_LENGTH + 20];

                    SHUnicodeToAnsi(pszURL, szURL, ARRAYSIZE(szURL));
                    wnsprintfA(szBaseTag, ARRAYSIZE(szBaseTag), "<BASE HREF=\"%s\">\n", szURL);

                    // NOTE: this is an ANSI stream

                    aStreams[0] = SHCreateMemStream((BYTE *)szBaseTag, lstrlenA(szBaseTag) * SIZEOF(szBaseTag[0]));
                }
                if (aStreams[0])
                {
                    aStreams[1] = pstm;
                    hres = SHCreateStreamWrapperCP(aStreams, ARRAYSIZE(aStreams), STGM_READ, m_uiCodePage, ppstm);
                    aStreams[0]->Release();
                }
                else
                    hres = E_OUTOFMEMORY;
                pstm->Release();
            }
            else
                *ppstm = pstm;
        }
        SHFree(pszURL);
    }
    else
        hres = E_FAIL;
    return hres;
}

// transfer URL data in file-contents clipboard format.
STDMETHODIMP Intshcut::TransferFileContents(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    if (pfmtetc->lindex != 0)
        return DV_E_LINDEX;

    if ((pfmtetc->dwAspect == DVASPECT_CONTENT ||
         pfmtetc->dwAspect == DVASPECT_LINK) && 
         (pfmtetc->tymed & TYMED_HGLOBAL))
    {
        LPSTR pszFileContents;
        DWORD cbSize = GetFileContentsAndSize(&pszFileContents);
        if (pszFileContents)
        {
            pstgmed->tymed = TYMED_HGLOBAL;
            pstgmed->hGlobal = pszFileContents;
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if ((pfmtetc->dwAspect == DVASPECT_COPY) && (pfmtetc->tymed & TYMED_ISTREAM))
    {
        hr = GetDocumentStream(&pstgmed->pstm);
        if (SUCCEEDED(hr))
        {
            pstgmed->tymed = TYMED_ISTREAM;
            hr = S_OK;
        }
    }
    else
        hr = DV_E_TYMED;

    return hr;
}



#ifdef DEBUG

STDMETHODIMP_(void) Intshcut::Dump(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

#define INDENT_STRING   "    "

    if (IsFlagSet(g_dwDumpFlags, DF_INTSHCUT))
    {
        TraceMsg(TF_ALWAYS, "%sm_dwFlags = %#08lx",
                   INDENT_STRING,
                   m_dwFlags);
        TraceMsg(TF_ALWAYS, "%sm_pszFile = \"%s\"",
                   INDENT_STRING,
                   Dbg_SafeStr(m_pszFile));

        if (m_pprop)
            m_pprop->Dump();
    }
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\isshlink.cpp ===
/*
 * isshlink.cpp - IShellLink implementation for Intshcut class.
 */



#include "priv.h"
#include "ishcut.h"
#include "resource.h"


#include <mluisupp.h>

/* Types
 ********/

typedef enum isl_getpath_flags
{
    // flag combinations

    ALL_ISL_GETPATH_FLAGS   = (SLGP_SHORTPATH |
                               SLGP_UNCPRIORITY)
}
ISL_GETPATH_FLAGS;

typedef enum isl_resolve_flags
{
    // flag combinations

    ALL_ISL_RESOLVE_FLAGS   = (SLR_NO_UI |
                               SLR_ANY_MATCH |
                               SLR_UPDATE)
}
ISL_RESOLVE_FLAGS;


/********************************** Methods **********************************/


/*----------------------------------------------------------
Purpose: IShellLink::SetPath method for Intshcut

Note:
    1. SetURL clears the internal pidl.

*/
STDMETHODIMP
Intshcut::SetPath(
    LPCTSTR pcszPath)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRING_PTR(pcszPath, -1));

    // Treat path as literal URL.

    hr = SetURL(pcszPath, 0);

    return(hr);
}


/*----------------------------------------------------------
Purpose: IShellLink::GetPath handler for Intshcut

*/
STDMETHODIMP
Intshcut::GetPath(
    IN  LPTSTR           pszBuf,        
    IN  int              cchBuf,
    OUT PWIN32_FIND_DATA pwfd,          OPTIONAL
    IN  DWORD            dwFlags)
{
    HRESULT hres = E_FAIL;

    // We make no distinction between raw paths and cooked paths
    dwFlags &= ~SLGP_RAWPATH;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf));
    ASSERT(NULL == pwfd || IS_VALID_WRITE_PTR(pwfd, WIN32_FIND_DATA));
    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_ISL_GETPATH_FLAGS));

    // Init to default values
    if (pwfd)
        ZeroMemory(pwfd, SIZEOF(*pwfd));

    if (cchBuf > 0)
        *pszBuf = '\0';

    // Ignore dwFlags.

    hres = InitProp();
    if (SUCCEEDED(hres))
        hres = m_pprop->GetProp(PID_IS_URL, pszBuf, cchBuf);
     
    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetRelativePath method for Intshcut

*/
STDMETHODIMP Intshcut::SetRelativePath(LPCTSTR pcszRelativePath, DWORD dwReserved)
{
    HRESULT hr;

    // dwReserved may be any value.

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRING_PTR(pcszRelativePath, -1));

    hr = E_NOTIMPL;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}


/*----------------------------------------------------------
Purpose: IShellLink::SetIDList method for Intshcut

Note:
    1. SetIDList also does SetPath implicitly to update the path (URL)
        to match the pidl.
    2. SetPath only clears the pidl to NULL, so internally we know
        if we really have a pidl for the shortcut. Although GetIDList
        will generate a pidl from path (URL) if we don't have a pidl.

*/
STDMETHODIMP Intshcut::SetIDList(LPCITEMIDLIST pcidl)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_READ_PTR(pcidl, ITEMIDLIST));

    hr = InitProp();
    if (SUCCEEDED(hr))
    {
        hr = m_pprop->SetIDListProp(pcidl);
        if (SUCCEEDED(hr))
        {
            // if the pidl was set successfully, update the path.
            TCHAR szURL[INTERNET_MAX_URL_LENGTH];
            
            hr = IEGetDisplayName(pcidl, szURL, SHGDN_FORPARSING);
            if (SUCCEEDED(hr))
                m_pprop->SetURLProp(szURL, 0);
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}


/*----------------------------------------------------------
Purpose: Get the original pidl set by SetIDList.

Note:
    1. Do not generate a pidl from path if we don't have a pidl.
    2. Return S_OK if we have a pidl, caller must NOT check for
        SUCCEEDED() return.

*/
STDMETHODIMP Intshcut::GetIDListInternal(LPITEMIDLIST *ppidl)
{
    HRESULT hres = InitProp();
    if (SUCCEEDED(hres))
    {
        IStream *pStream;
        hres = m_pprop->GetProp(PID_IS_IDLIST, &pStream);
        if ((hres == S_OK) && pStream)
        {
            const LARGE_INTEGER li = {0, 0};
            // reset the seek pointer                                           
            hres = pStream->Seek(li, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hres))
                hres = ILLoadFromStream(pStream, ppidl);
        
            pStream->Release();
        }
    }
    return hres;
}


    
/*----------------------------------------------------------
Purpose: IShellLink::GetIDList method for Intshcut

Note:
    1. If we don't have a pidl from SetIDList, generate a pidl
        from path.

*/
STDMETHODIMP Intshcut::GetIDList(LPITEMIDLIST *ppidl)
{
    HRESULT hres;
    ASSERT(IS_VALID_WRITE_PTR(ppidl, LPITEMIDLIST));
    
    if (!ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        // check if it already as a pidl.
        hres = GetIDListInternal(ppidl);
        if (hres != S_OK)
        {
            // it doesn't have a pidl, get the URL and make a pidl.
            TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    
            hres = m_pprop->GetProp(PID_IS_URL, szURL, ARRAYSIZE(szURL));
            if (SUCCEEDED(hres)) 
            {
                hres = IECreateFromPath(szURL, ppidl);
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetDescription method for Intshcut

*/
STDMETHODIMP Intshcut::SetDescription(LPCTSTR pcszDescription)
{
    HRESULT hr;
    BOOL bDifferent;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRING_PTR(pcszDescription, -1));

    // Set m_pszFile to description.

    bDifferent = (! m_pszDescription ||
                  StrCmp(pcszDescription, m_pszDescription) != 0);

    if (Str_SetPtr(&m_pszDescription, pcszDescription))
    {
        if (bDifferent)
           Dirty(TRUE);

        hr = S_OK;
    }
    else
        hr = E_OUTOFMEMORY;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}

STDMETHODIMP Intshcut::_ComputeDescription()
{
    HRESULT hres;
    BSTR bstrTitle = NULL;

    if (_punkSite)
    {
        // Get the title element
        IWebBrowser *pwb;
        hres = _punkSite->QueryInterface(IID_IWebBrowser, (void **)&pwb);
        if (S_OK == hres)
        {
            IDispatch *pDisp;
            hres = pwb->get_Document(&pDisp);
            if (S_OK == hres)
            {
                IHTMLDocument2 *pDoc;
                hres = pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc);
                if (S_OK == hres)
                {
                    hres = pDoc->get_title(&bstrTitle);
                    pDoc->Release();
                }
                pDisp->Release();
            }
            pwb->Release();
        }
    }
    
    TCHAR *pszUrl;  // The url for this shortcut
    hres = GetURL(&pszUrl);
    if (S_OK == hres)
    {
        TCHAR  szDescription[MAX_PATH] = TEXT("");

        // We gamble that the URL will always have displayable characters. 
        // This is a bad assumption but if this assumption is violated then
        // there is a good chance that the URL probably cannot even
        // be navigated to
        
        // This description is used as the name of the file verbatim
        // during drag drop - hence it should look like a .url file name

        GetShortcutFileName(pszUrl, bstrTitle, NULL, szDescription, ARRAYSIZE(szDescription));
        //PathYetAnotherMakeUniqueName(szTempFileName, szTempFileName, NULL, NULL);
        PathCleanupSpec(NULL, szDescription);

        // Sometimes PathCleanupSpec can end up simply mangling the description if
        // it cannot properly convert the title to ANSI
        // hence we check that we have a proper description

        
        
        if((0 == *szDescription) || (0 == StrCmp(szDescription,TEXT(".url"))))
        {
            // recompute the description without the title
            GetShortcutFileName(pszUrl, NULL, NULL, szDescription, ARRAYSIZE(szDescription));
            PathCleanupSpec(NULL, szDescription);
        }
        hres = SetDescription(szDescription);
        SHFree(pszUrl);
    }


    SysFreeString(bstrTitle);
        
    return hres;
}

// IShellLink::GetDescription method for Intshcut
STDMETHODIMP Intshcut::GetDescription(LPTSTR pszDescription, int cchBuf)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszDescription, TCHAR, cchBuf));

    // Get description from m_pszDescription.

    if (NULL == m_pszDescription)
    {
        _ComputeDescription();
    }

    if (m_pszDescription)
        StrCpyN(pszDescription, m_pszDescription, cchBuf);
    else if (m_pszFile)
    {
        StrCpyN(pszDescription, m_pszFile, cchBuf);
    }
    else
    {
        // use default shortcut name 
        MLLoadString(IDS_NEW_INTSHCUT, pszDescription, cchBuf);
    }

    hr = S_OK;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(hr == S_OK &&
           (cchBuf <= 0 ||
            (IS_VALID_STRING_PTR(pszDescription, -1) &&
             EVAL(lstrlen(pszDescription) < cchBuf))));

    return(hr);
}


// IShellLink::SetArguments method for Intshcut
STDMETHODIMP Intshcut::SetArguments(LPCTSTR pcszArgs)
{
    return E_NOTIMPL;
}

// IShellLink::GetArguments for Intshcut
STDMETHODIMP Intshcut::GetArguments(LPTSTR pszArgs, int cchBuf)
{
    return E_NOTIMPL;
}


// IShellLink::SetWorkingDirectory handler for Intshcut
STDMETHODIMP Intshcut::SetWorkingDirectory(LPCTSTR pcszWorkingDirectory)
{
    HRESULT hres = S_OK;
    TCHAR rgchNewPath[MAX_PATH];
    BOOL bChanged = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(! pcszWorkingDirectory ||
           IS_VALID_STRING_PTR(pcszWorkingDirectory, -1));

    if (! AnyMeat(pcszWorkingDirectory))
        pcszWorkingDirectory = NULL;

    if (pcszWorkingDirectory)
    {
        LPTSTR pszFileName;

        if (GetFullPathName(pcszWorkingDirectory, SIZECHARS(rgchNewPath),
                            rgchNewPath, &pszFileName) > 0)
            pcszWorkingDirectory = rgchNewPath;
        else
            hres = E_PATH_NOT_FOUND;
    }

    if (hres == S_OK)
    {
        TCHAR szDir[MAX_PATH];

        hres = InitProp();
        if (SUCCEEDED(hres))
        {
            hres = m_pprop->GetProp(PID_IS_WORKINGDIR, szDir, SIZECHARS(szDir));

            bChanged = ! ((! pcszWorkingDirectory && S_FALSE == hres) ||
                          (pcszWorkingDirectory && S_OK == hres &&
                           ! StrCmp(pcszWorkingDirectory, szDir)));

            hres = S_OK;
            if (bChanged)
            {
                hres = m_pprop->SetProp(PID_IS_WORKINGDIR, pcszWorkingDirectory);
            }
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::GetWorkingDirectory handler for Intshcut

*/
STDMETHODIMP
Intshcut::GetWorkingDirectory(
    IN LPTSTR pszBuf,
    IN int    cchBuf)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf));

    if (cchBuf > 0)
        *pszBuf = '\0';

    hres = InitProp();
    if (SUCCEEDED(hres))
        hres = m_pprop->GetProp(PID_IS_WORKINGDIR, pszBuf, cchBuf);

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetHotkey handler for Intshcut

*/
STDMETHODIMP
Intshcut::SetHotkey(
    IN WORD wHotkey)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    hres = InitProp();
    if (SUCCEEDED(hres))
        hres = m_pprop->SetProp(PID_IS_HOTKEY, wHotkey);

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::GetHotkey handler for Intshcut

*/
STDMETHODIMP
Intshcut::GetHotkey(
    PWORD pwHotkey)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_PTR(pwHotkey, WORD));

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        m_pprop->GetProp(PID_IS_HOTKEY, pwHotkey);
        hres = S_OK;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetShowCmd handler for Intshcut

*/
STDMETHODIMP
Intshcut::SetShowCmd(
    IN int nShowCmd)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IsValidShowCmd(nShowCmd));

    hres = InitProp();
    if (SUCCEEDED(hres))
        hres = m_pprop->SetProp(PID_IS_SHOWCMD, nShowCmd);

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::GetShowCmd handler for Intshcut

*/
STDMETHODIMP
Intshcut::GetShowCmd(
    OUT int *pnShowCmd)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_PTR(pnShowCmd, INT));

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        hres = m_pprop->GetProp(PID_IS_SHOWCMD, pnShowCmd);
        if (S_OK != hres)
            *pnShowCmd = SW_NORMAL;
        hres = S_OK;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetIconLocation handler for Intshcut

*/
STDMETHODIMP
Intshcut::SetIconLocation(
    IN LPCTSTR pszFile,
    IN int     niIcon)
{
    HRESULT hres = S_OK;
    BOOL bNewMeat;
    TCHAR szNewPath[MAX_PATH];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IsValidIconIndex(pszFile ? S_OK : S_FALSE, pszFile, MAX_PATH, niIcon));

    bNewMeat = AnyMeat(pszFile);

    if (bNewMeat)
    {
        if (PathSearchAndQualify(pszFile, szNewPath, SIZECHARS(szNewPath)))
        {
            hres = S_OK;
        }
        else
        {
            hres = E_FILE_NOT_FOUND;
        }
    }

    if (hres == S_OK)
    {
        TCHAR szOldPath[MAX_PATH];
        int niOldIcon;
        UINT uFlags;

        hres = GetIconLocation(0, szOldPath, SIZECHARS(szOldPath), &niOldIcon,
                             &uFlags);

        if (SUCCEEDED(hres))
        {
            BOOL bOldMeat;
            BOOL bChanged = FALSE;

            bOldMeat = AnyMeat(szOldPath);

            ASSERT(! *szOldPath ||
                   bOldMeat);

            bChanged = ((! bOldMeat && bNewMeat) ||
                        (bOldMeat && ! bNewMeat) ||
                        (bOldMeat && bNewMeat &&
                         (StrCmp(szOldPath, szNewPath) != 0 ||
                          niIcon != niOldIcon)));

            hres = S_OK;
            if (bChanged && bNewMeat)
            {
                hres = InitProp();
                if (SUCCEEDED(hres))
                {
                    hres = m_pprop->SetProp(PID_IS_ICONFILE, szNewPath);
                    if (SUCCEEDED(hres))
                        hres = m_pprop->SetProp(PID_IS_ICONINDEX, niIcon);
                }
            }
        }
    }

    return hres;
}

VOID UrlMunge(
    TCHAR *lpszSrc,
    TCHAR *lpszDest,
    UINT   cchDestBufSize,
    BOOL fRecentlyChanged)
{
   TCHAR *lpszTemp = lpszSrc;

   if(fRecentlyChanged)
        cchDestBufSize--; // Save up a character

   while(*lpszTemp != TEXT('\0') && (cchDestBufSize > 1)) // not End of line and save up one char for \0 in munged string
   {
        if(TEXT('/') == *lpszTemp)
        {
            *lpszDest = TEXT('\1');
        }
        else
        {
            *lpszDest = *lpszTemp;
        }
        lpszDest++;
        lpszTemp++;
        cchDestBufSize--;
   }
   if(fRecentlyChanged)
   {
        *lpszDest = TEXT('\2');  
        lpszDest++;
   }
   *lpszDest =  TEXT('\0');
   return;
}


HRESULT HelperForReadIconInfoFromPropStg(
    IN  LPTSTR pszBuf,
    IN  int    cchBuf,
    OUT int *  pniIcon,
    IPropertyStorage *pPropStg,
    PROPSPEC *ppropspec,
    IN  LPTSTR pszActualUrlBuf,
    IN INT cchActualUrlBuf,
    BOOL fRecentlyChanged)
{

    HRESULT hres;
    PROPVARIANT rgpropvar[2];


    ASSERT((0 == pszActualUrlBuf) || (cchActualUrlBuf >= MAX_URL_STRING));

    if(pszActualUrlBuf)
        *pszActualUrlBuf = TEXT('\0');
        
    // Init to default values
    *pniIcon = 0;
    if (cchBuf > 0)
        *pszBuf = TEXT('\0');

    

    hres = pPropStg->ReadMultiple(2, ppropspec, rgpropvar);
    if (SUCCEEDED(hres))
    {
        if (VT_LPWSTR == rgpropvar[1].vt)
        {
            if(FALSE == PathFileExistsW(rgpropvar[1].pwszVal))
            {
                UrlMunge(rgpropvar[1].pwszVal, pszBuf, cchBuf, fRecentlyChanged);  
            }
            else
            {
                // We will just send the icon file and index back with no attempt
                // to hash it or fill out the URL field
                if(lstrlenW(rgpropvar[1].pwszVal) >= cchBuf)
                {
                     // need a larger buf - simply fail it
                    hres = E_FAIL;
                }
                else
                {
                    StrCpyN(pszBuf, rgpropvar[1].pwszVal, cchBuf);
                }
            }
            if(SUCCEEDED(hres) && pszActualUrlBuf)
            {
                StrCpyN(pszActualUrlBuf, rgpropvar[1].pwszVal, cchActualUrlBuf);
            }
        }

        if (VT_I4 == rgpropvar[0].vt)
            *pniIcon = rgpropvar[0].lVal;

        FreePropVariantArray(ARRAYSIZE(rgpropvar), rgpropvar);
    }
    return hres;
}

//
// Functions from isexicon.cpp
//

/*----------------------------------------------------------
*
*
Purpose: IShellLink::GetIconLocation handler for Intshcut
*
*----------------------------------------------------------*/
STDMETHODIMP
Intshcut::_GetIconLocationWithURLHelper(
    IN  LPTSTR pszBuf,
    IN  int    cchBuf,
    OUT int *  pniIcon,
    IN  LPTSTR pszActualUrl,
    UINT cchActualUrlBuf,
    BOOL fRecentlyChanged)
{
    HRESULT hres;
    PROPSPEC rgpropspec[2];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, int));

    if(!pszBuf)
        return E_INVALIDARG;

    rgpropspec[0].ulKind = PRSPEC_PROPID;
    rgpropspec[1].ulKind = PRSPEC_PROPID;

    
    if(pszActualUrl)
        *pszActualUrl = TEXT('\0');
        
    *pszBuf = TEXT('\0');
    
    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        rgpropspec[0].propid = PID_IS_ICONINDEX;
        rgpropspec[1].propid = PID_IS_ICONFILE;
        hres = HelperForReadIconInfoFromPropStg(
                            pszBuf, cchBuf, pniIcon, m_pprop, 
                            rgpropspec, pszActualUrl, cchActualUrlBuf,
                            fRecentlyChanged);
        
    }

    if(TEXT('\0') == *pszBuf) 
    {
        // Didn't find it in the shortcut itself
        // Poke around the intsite database and if it is there,
        // simply stuff it into the shortcut file if you do find
        // one
        IPropertyStorage *ppropstg = NULL;
        hres = Open(FMTID_InternetSite, STGM_READWRITE, &ppropstg);
        if(S_OK == hres)
        {
            // Look for an icon for this specific url
            ASSERT(ppropstg);
            rgpropspec[0].propid = PID_INTSITE_ICONINDEX;
            rgpropspec[1].propid = PID_INTSITE_ICONFILE;
            hres = HelperForReadIconInfoFromPropStg(pszBuf, cchBuf, pniIcon, 
                                                    ppropstg, rgpropspec, pszActualUrl, 
                                                    cchActualUrlBuf, fRecentlyChanged);
            
            
            ppropstg->Release();
        }

        if((S_OK == hres) && (*pszBuf) && pszActualUrl && (*pszActualUrl))
        {
            // Write this info to the shortcut file
            WCHAR *pwszTempBuf;
            pwszTempBuf = pszActualUrl;
            PROPVARIANT var = {0};

            ASSERT(1 == *pniIcon);
            
            var.vt =  VT_BSTR;
            var.bstrVal = SysAllocString(pwszTempBuf);

            if(var.bstrVal)
            {
                hres = WritePropertyNPB(ISHCUT_INISTRING_SECTIONW, ISHCUT_INISTRING_ICONFILEW,
                                            &var);

                SysFreeString(var.bstrVal);
                if(S_OK == hres)
                {
                    var.bstrVal = SysAllocString(L"1");
                    if(var.bstrVal)
                    {
                        hres = WritePropertyNPB(ISHCUT_INISTRING_SECTIONW, ISHCUT_INISTRING_ICONINDEXW,
                                                    &var);
                        SysFreeString(var.bstrVal);
                    }
                }
            } 
            hres = S_OK; // retun OK if you found icon and could not write out for whatever reason
        }
    }

    return hres;
}

// IShellLink::GetIconLocation handler for Intshcut
STDMETHODIMP Intshcut::GetIconLocation(LPTSTR pszBuf, int cchBuf, int *pniIcon)
{
    UINT uTmp;
    return GetIconLocation(0, pszBuf, cchBuf, pniIcon, &uTmp);
}

// IShellLink::Resolve method for Intshcut
STDMETHODIMP Intshcut::Resolve(HWND hwnd,  DWORD dwFlags)
{
    return S_OK;
}

//====================================================================================
// Now the A or W functions that depend on unicode or ansi machines...
// Will setup forwarders to the native one for the OS...
//----------------------------------------------------------
STDMETHODIMP Intshcut::SetPath(LPCSTR pcszPath)
{
    WCHAR wszT[INTERNET_MAX_URL_LENGTH];

    if (!pcszPath)
        return SetPath((LPCWSTR)NULL);

    SHAnsiToUnicode(pcszPath, wszT, ARRAYSIZE(wszT));
    return SetPath(wszT);
}


STDMETHODIMP Intshcut::GetPath(LPSTR pszBuf, int cchBuf, PWIN32_FIND_DATAA pwfd, DWORD dwFlags)
{
    WCHAR wszT[INTERNET_MAX_URL_LENGTH];
    HRESULT hres;

    // Init to default values (Note pwfd is not actually set so don't worry about thunking...
    if (pwfd)
        ZeroMemory(pwfd, SIZEOF(*pwfd));

    hres = GetPath(wszT, ARRAYSIZE(wszT), NULL, dwFlags);
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszBuf, cchBuf);
    return hres;
}


STDMETHODIMP Intshcut::SetRelativePath(LPCSTR pcszRelativePath, DWORD dwReserved)
{
    WCHAR wszT[MAX_PATH];
    if (!pcszRelativePath)
        return SetRelativePath((LPCWSTR)NULL, dwReserved);

    SHAnsiToUnicode(pcszRelativePath, wszT, ARRAYSIZE(wszT));
    return SetRelativePath(wszT, dwReserved);
}


STDMETHODIMP Intshcut::SetDescription(LPCSTR pcszDescription)
{
    WCHAR wszT[MAX_PATH];
    if (!pcszDescription)
        return SetDescription((LPCWSTR)NULL);

    SHAnsiToUnicode(pcszDescription, wszT, ARRAYSIZE(wszT));
    return SetDescription(wszT);
}

STDMETHODIMP Intshcut::GetDescription(LPSTR pszDescription,int cchBuf)
{
    WCHAR wszT[MAX_PATH];
    HRESULT hres;

    hres = GetDescription(wszT, ARRAYSIZE(wszT));
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszDescription, cchBuf);
    return hres;
}

STDMETHODIMP Intshcut::SetArguments(LPCSTR pcszArgs)
{
    WCHAR wszT[2*MAX_PATH];
    if (!pcszArgs)
        return SetArguments((LPCWSTR)NULL);

    SHAnsiToUnicode(pcszArgs, wszT, ARRAYSIZE(wszT));
    return SetArguments(wszT);
}


STDMETHODIMP Intshcut::GetArguments(LPSTR pszArgs,int cchBuf)
{
    WCHAR wszT[2*MAX_PATH];
    HRESULT hres;

    hres = GetArguments(wszT, ARRAYSIZE(wszT));
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszArgs, cchBuf);
    return hres;
} 

STDMETHODIMP Intshcut::SetWorkingDirectory(LPCSTR pcszWorkingDirectory)
{
    WCHAR wszT[MAX_PATH];

    if (!pcszWorkingDirectory)
        return SetWorkingDirectory((LPCWSTR)NULL);

    SHAnsiToUnicode(pcszWorkingDirectory, wszT, ARRAYSIZE(wszT));
    return SetWorkingDirectory(wszT);
}

STDMETHODIMP Intshcut::GetWorkingDirectory(LPSTR pszBuf, int cchBuf)
{
    WCHAR wszT[MAX_PATH];
    HRESULT hres;

    hres = GetWorkingDirectory(wszT, ARRAYSIZE(wszT));
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszBuf, cchBuf);
    return hres;
}

STDMETHODIMP Intshcut::SetIconLocation(LPCSTR pszFile, int niIcon)
{
    WCHAR wszT[MAX_PATH];

    if (!pszFile)
        return SetIconLocation((LPCWSTR)NULL, niIcon);

    SHAnsiToUnicode(pszFile, wszT, ARRAYSIZE(wszT));
    return SetIconLocation(wszT, niIcon);
}

STDMETHODIMP Intshcut::GetIconLocation(LPSTR pszBuf, int cchBuf, int *pniIcon)
{
    WCHAR wszT[MAX_PATH];
    HRESULT hres;

    hres = GetIconLocation(wszT, ARRAYSIZE(wszT), pniIcon);
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszBuf, cchBuf);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\isprsht.cpp ===
/*
 * isprsht.cpp - IPropSheetExt implementation for URL class.
 */


#include "priv.h"
#include "ishcut.h"
#include <limits.h>
#include <trayp.h>          // for WMTRAY_ messages
#include <ntverp.h>         // VER_XXX for FaultInFeature
#include <webcheck.h>       // ISubscriptionMgrPriv

#include <mluisupp.h>

#undef NO_HELP              // for help.h
#include "resource.h"
#include <iehelpid.h>

#ifndef UNIX
const WCHAR c_szPropCrawlActualSize[] = L"ActualSizeKB";
const WCHAR c_szPropStatusString[] = L"StatusString";
const WCHAR c_szPropCompletionTime[] = L"CompletionTime";
#else
#include "unixstuff.h"
#include "shalias.h"
const LPCWSTR c_szPropCrawlActualSize = L"ActualSizeKB";
const LPCWSTR c_szPropStatusString = L"StatusString";
const LPCWSTR c_szPropCompletionTime = L"CompletionTime";
#endif

#include "apithk.h"

/* stuff a point value packed in an LPARAM into a POINT */

#define LPARAM_TO_POINT(lParam, pt)       ((pt).x = GET_X_LPARAM(lParam), \
                                           (pt).y = GET_Y_LPARAM(lParam))


#define ISF_STARTSUBSCRIBED     0x00010000      // URL was subscribed to start with
#define ISF_NOWEBCHECK          0x00020000      // Webcheck is not installed
#define ISF_DISABLEOFFLINE      0x00080000      // Disable "make available offline" menus/checkboxes
#define ISF_SUMMARYEXTRACTED    0x00100000      // Has the summary been extracted
#define ISF_HAVEINITED          0x00200000      // Has the subsmgr extension been inited?




/* Internet Shortcut property sheet data */

/*  
    Mental note(tnoonan): this helper class should be shared with the context menu 
    code soon.
*/

class CSubsHelper
{
    IUniformResourceLocatorW    *m_pIURLW;
    ISubscriptionMgr2           *m_pSubsMgr2;
    HINSTANCE                   m_hinstWebcheck;
    HWND                        m_hwndParent;
    
public:
    DWORD               m_dwFlags;

    ~CSubsHelper()
    {
        if (NULL != m_pSubsMgr2)
        {
            m_pSubsMgr2->Release();
        }

        if (NULL != m_pIURLW)
        {
            m_pIURLW->Release();
        }

        if (NULL != m_hinstWebcheck)
        {
            FreeLibrary(m_hinstWebcheck);
        }
    }

    void SetParentHwnd(HWND hwndParent)
    {
        m_hwndParent = hwndParent;
    }

    void SetIURLW(IUniformResourceLocatorW *pIURLW)
    {
        if (NULL != m_pIURLW)
        {
            m_pIURLW->Release();
        }

        if (NULL != pIURLW)
        {
            pIURLW->AddRef();
        }

        m_pIURLW = pIURLW;
    }

    HRESULT GetIURLW(IUniformResourceLocatorW **ppIURLW)
    {
        HRESULT hr;
        
        ASSERT(NULL != ppIURLW);

        if (NULL != m_pIURLW)
        {
            m_pIURLW->AddRef();
            *ppIURLW = m_pIURLW;
            hr = S_OK;
        }
        else
        {
            *ppIURLW = NULL;
            hr = E_FAIL;
        }

        return hr;
    }
   
    HRESULT Init()
    {
        HRESULT hr;
        WCHAR *pwszURL;

        ASSERT(NULL != m_pIURLW);

        hr = m_pIURLW->GetURL(&pwszURL);

        if (SUCCEEDED(hr))
        {

            hr = LoadSubsMgr2(FIEF_FLAG_PEEK | FIEF_FLAG_FORCE_JITUI);

            if (SUCCEEDED(hr))
            {
                BOOL bSubscribed; 

                if (SUCCEEDED(m_pSubsMgr2->IsSubscribed(pwszURL, &bSubscribed)) && 
                    (TRUE == bSubscribed))
                {
                    m_dwFlags |= ISF_STARTSUBSCRIBED;
                }
            }

            if (m_dwFlags & ISF_STARTSUBSCRIBED)
            {
                if (SHRestricted2W(REST_NoRemovingSubscriptions, pwszURL, 0))
                {
                    m_dwFlags |= ISF_DISABLEOFFLINE;
                }
            }
            else
            {
                if (SHRestricted2W(REST_NoAddingSubscriptions, pwszURL, 0))
                {
                    m_dwFlags |= ISF_DISABLEOFFLINE;
                }
            }

            SHFree(pwszURL);
        }

        return hr;
    }

    HRESULT LoadSubsMgr2(DWORD dwFaultInFlags)
    {
        HRESULT hr;
        uCLSSPEC ucs;
        QUERYCONTEXT qc = { 0 };

        ucs.tyspec = TYSPEC_CLSID;
        ucs.tagged_union.clsid = CLSID_SubscriptionMgr;

        hr = FaultInIEFeature(m_hwndParent, &ucs, &qc, dwFaultInFlags);

        if (SUCCEEDED(hr))
        {
            m_dwFlags &= ~ISF_NOWEBCHECK;
        }
        else
        {
            m_dwFlags |= ISF_NOWEBCHECK;

            if (E_ACCESSDENIED == hr)
            {
                //  Admin has disabled demand install
                m_dwFlags |= ISF_DISABLEOFFLINE;
            }
        }

        if (!(m_dwFlags & ISF_NOWEBCHECK))
        {
            ASSERT(NULL == m_pSubsMgr2)
            
            //  HACKHACKHACK
            hr = CoInitialize(NULL);
            if (SUCCEEDED(hr))
            {
                m_hinstWebcheck = SHPinDllOfCLSID(&CLSID_SubscriptionMgr);
                if (NULL != m_hinstWebcheck)
                {
                    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                          IID_PPV_ARG(ISubscriptionMgr2, &m_pSubsMgr2));
                }
                else
                {
                    m_dwFlags |= ISF_NOWEBCHECK;
                    hr = E_FAIL;
                }

                //  HACKHACKHACK
                CoUninitialize();
            }
        }

        return hr;
    }

    HRESULT GetSubsMgr2(ISubscriptionMgr2 **ppSubsMgr2, DWORD dwFaultInFlags)
    {
        HRESULT hr = E_FAIL;

        ASSERT(NULL != ppSubsMgr2);
        *ppSubsMgr2 = NULL;

        if ((NULL == m_pSubsMgr2) && (0xffffffff != dwFaultInFlags))
        {
            hr = LoadSubsMgr2(dwFaultInFlags);
        }
        
        if (NULL != m_pSubsMgr2)
        {
            m_pSubsMgr2->AddRef();
            *ppSubsMgr2 = m_pSubsMgr2;
            hr = S_OK;
        }
        return hr;
    }

    HRESULT DeleteSubscription()
    {
        HRESULT hr = S_FALSE;
        
        if (m_pSubsMgr2)
        {
            WCHAR *pwszURL;

            ASSERT(NULL != m_pIURLW);

            hr = m_pIURLW->GetURL(&pwszURL);

            if (SUCCEEDED(hr))
            {
                hr = m_pSubsMgr2->DeleteSubscription(pwszURL, NULL);
                SHFree(pwszURL);
            }
        }

        return hr;
    }

    HRESULT SaveSubscription()
    {
        HRESULT hr;
#ifndef UNIX
        ISubscriptionMgrPriv *psmp;

        if (m_pSubsMgr2)
        {

            hr = m_pSubsMgr2->QueryInterface(IID_PPV_ARG(ISubscriptionMgrPriv, &psmp));

            if (SUCCEEDED(hr))
            {
                hr = psmp->SaveSubscription();
                psmp->Release();
            }
        }
        else
#endif
        {
            hr = E_FAIL;
        }
        return hr;
    }

    HRESULT UpdateSubscription()
    {
        HRESULT hr;
        
        if (m_pSubsMgr2)
        {
            WCHAR *pwszURL;

            ASSERT(NULL != m_pIURLW);

            hr = m_pIURLW->GetURL(&pwszURL);
            if (SUCCEEDED(hr))
            {
                hr = m_pSubsMgr2->UpdateSubscription(pwszURL);
                SHFree(pwszURL);
            }
        }
        else
        {
            hr = E_FAIL;
        }

        return hr;
    }

    HRESULT DoShellExtInit(IDataObject *pdo)
    {
        HRESULT hr = E_FAIL;

        if (NULL != m_pSubsMgr2)
        {
            if (!(m_dwFlags & ISF_HAVEINITED))
            {
                IShellExtInit *psei;

                hr = m_pSubsMgr2->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei));

                if (SUCCEEDED(hr))
                {
                    hr = psei->Initialize(NULL, pdo, NULL);

                    if (SUCCEEDED(hr))
                    {
                        m_dwFlags |= ISF_HAVEINITED;
                    }
                    psei->Release();
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
        
        return hr;
    }


};

struct ISDATA
{
private:
    Intshcut            *m_pintshcut;
    
public:
    TCHAR               rgchIconFile[MAX_PATH];
    int                 niIcon;
    CSubsHelper         SubsHelper;
    BOOL                bUserEditedPage;

    inline void SetIntshcut(Intshcut *pintshcut)
    {
        IUniformResourceLocatorW *pIURLW;

        ASSERT(NULL == m_pintshcut);
        ASSERT(NULL != pintshcut);

        pintshcut->AddRef();

        if (SUCCEEDED(pintshcut->QueryInterface(IID_PPV_ARG(IUniformResourceLocatorW, &pIURLW))))
        {
            SubsHelper.SetIURLW(pIURLW);
            pIURLW->Release();
        }

        m_pintshcut = pintshcut;
    }

    inline Intshcut *GetIntshcut() const
    { 
        ASSERT(NULL != m_pintshcut);
        return m_pintshcut;
    }

    ~ISDATA()
    {
        if (NULL != m_pintshcut)
        {
            m_pintshcut->Release();
        }
    }
};

typedef ISDATA *PISDATA;


#ifdef DEBUG

BOOL
IsValidPISDATA(
    PISDATA pisdata)
{
    return(IS_VALID_READ_PTR(pisdata, ISDATA) &&
           IS_VALID_STRUCT_PTR(pisdata->GetIntshcut(), CIntshcut) &&
           EVAL(IsValidIconIndex(*(pisdata->rgchIconFile) ? S_OK : S_FALSE, pisdata->rgchIconFile, SIZECHARS(pisdata->rgchIconFile), pisdata->niIcon)));
}

PISDATA ISPS_GetPISDATA(HWND hdlg)
{
    PISDATA pd = (PISDATA) GetWindowLongPtr(hdlg, DWLP_USER);

    IS_VALID_STRUCT_PTR(pd, ISDATA);

    return pd;
}

Intshcut *ISPS_GetThisPtr(HWND hdlg)
{
    Intshcut *pintshcut = ISPS_GetPISDATA(hdlg)->GetIntshcut();

    IS_VALID_STRUCT_PTR(pintshcut, CIntshcut);

    return pintshcut;
}
#else
#define ISPS_GetPISDATA(hdlg)   ((PISDATA)GetWindowLongPtr(hdlg, DWLP_USER))
#define ISPS_GetThisPtr(hdlg)   (ISPS_GetPISDATA(hdlg)->GetIntshcut())
#endif

// help files

TCHAR const s_cszIEHelpFile[]   = TEXT("iexplore.hlp");

// help topics

DWORD const c_rgdwHelpIDs[] =
{
    IDC_ICON,                   IDH_FCAB_LINK_ICON,
    IDC_NAME,                   IDH_FCAB_LINK_NAME,
    IDC_URL_TEXT,               IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_URL,                    IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_HOTKEY_TEXT,            IDH_FCAB_LINK_HOTKEY,
    IDC_HOTKEY,                 IDH_FCAB_LINK_HOTKEY,
    IDC_CHANGE_ICON,            IDH_FCAB_LINK_CHANGEICON,
    IDC_VISITS_TEXT,            IDH_WEBDOC_VISITS,
    IDC_VISITS,                 IDH_WEBDOC_VISITS,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    IDC_SUMMARY,                IDH_GROUPBOX,
    IDC_LAST_SYNC_TEXT,         IDH_SUBPROPS_SUBTAB_LAST,
    IDC_LAST_SYNC,              IDH_SUBPROPS_SUBTAB_LAST,
    IDC_DOWNLOAD_SIZE_TEXT,     IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_SIZE,          IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_RESULT_TEXT,   IDH_SUBPROPS_SUBTAB_RESULT,
    IDC_DOWNLOAD_RESULT,        IDH_SUBPROPS_SUBTAB_RESULT,
    0,                          0
};


/***************************** Private Functions *****************************/

void SetEditFocus(HWND hwnd)
{
    SetFocus(hwnd);
    Edit_SetSel(hwnd, 0, -1);
}


#define SetDlgCtlText      SetDlgItemTextW

UINT
CALLBACK
ISPSCallback(
    HWND hwnd, 
    UINT uMsg, 
    LPPROPSHEETPAGE ppsp)
{
    UINT uResult = TRUE;
    PISDATA pisdata = (PISDATA)ppsp->lParam;

    // uMsg may be any value.

    ASSERT(! hwnd ||
           IS_VALID_HANDLE(hwnd, WND));

    switch (uMsg)
    {
        case PSPCB_CREATE:
            break;

        case PSPCB_RELEASE:
            TraceMsg(TF_INTSHCUT, "ISPSCallback(): Received PSPCB_RELEASE.");

            if (pisdata)
            {   
                delete pisdata;         
            }
            break;

        default:
            break;
    }

    return(uResult);
}

HRESULT
CopyDlgItemText(
    HWND hdlg,
    int nControlID, 
    TCHAR * UNALIGNED * ppszText)
{
    HRESULT hr;
    HWND hwndControl;

    // nContolID may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    ASSERT(IS_VALID_WRITE_PTR(ppszText, PTSTR));

    *ppszText = NULL;

    hwndControl = GetDlgItem(hdlg, nControlID);

    if (hwndControl)
    {
        int cchTextLen;

        cchTextLen = GetWindowTextLength(hwndControl);

        if (cchTextLen > 0)
        {
            LPTSTR pszText;

            ASSERT(cchTextLen < INT_MAX);
            cchTextLen++;
            ASSERT(cchTextLen > 0);

            pszText = (LPTSTR)LocalAlloc(LPTR, CbFromCch(cchTextLen));

            if (pszText)
            {
                int ncchCopiedLen;

                ncchCopiedLen = GetWindowText(hwndControl, pszText, cchTextLen);
                ASSERT(ncchCopiedLen == cchTextLen - 1);

                if (EVAL(ncchCopiedLen > 0))
                {
                    if (AnyMeat(pszText))
                    {
                        *ppszText = pszText;

                        hr = S_OK;
                    }
                    else
                        hr = S_FALSE;
                }
                else
                    hr = E_FAIL;

                if (hr != S_OK)
                {
                    LocalFree(pszText);
                    pszText = NULL;
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            // No text.
            hr = S_FALSE;
    }
    else
        hr = E_FAIL;

    return(hr);
}

void
SetISPSIcon(
    HWND hdlg, 
    HICON hicon)
{
    HICON hiconOld;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    ASSERT(IS_VALID_HANDLE(hicon, ICON));

    hiconOld = (HICON)SendDlgItemMessage(hdlg, IDC_ICON, STM_SETICON,
                                         (WPARAM)hicon, 0);

    if (hiconOld)
        DestroyIcon(hiconOld);

    TraceMsg(TF_INTSHCUT, "SetISPSIcon(): Set property sheet icon to %#lx.",
               hicon);

    return;
}

void
SetISPSFileNameAndIcon(
    HWND hdlg)
{
    HRESULT hr;
    PIntshcut pintshcut;
    TCHAR rgchFile[MAX_PATH];

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pintshcut = ISPS_GetThisPtr(hdlg);

    hr = pintshcut->GetCurFile(rgchFile, SIZECHARS(rgchFile));

    if (hr == S_OK)
    {
        SHFILEINFO shfi;
        DWORD_PTR dwResult;

        dwResult = SHGetFileInfo(rgchFile, 0, &shfi, SIZEOF(shfi),
                                 (SHGFI_DISPLAYNAME | SHGFI_ICON));

        if (dwResult)
        {
            LPTSTR pszFileName;

            pszFileName = (PTSTR)PathFindFileName(shfi.szDisplayName);

            EVAL(SetDlgItemText(hdlg, IDC_NAME, pszFileName));

            SetISPSIcon(hdlg, shfi.hIcon);
        }
        else
        {
           hr = E_FAIL;

           TraceMsg(TF_INTSHCUT, "SetISPSFileNameAndIcon(): SHGetFileInfo() failed, returning %lu.",
                      dwResult);
        }
    }
    else
        TraceMsg(TF_INTSHCUT, "SetISPSFileNameAndIcon(): GetCurFile() failed, returning %s.",
                   Dbg_GetHRESULTName(hr));

    if (hr != S_OK)
        EVAL(SetDlgItemText(hdlg, IDC_NAME, c_szNULL));

    return;
}

void
SetISPSURL(
    HWND hdlg,
    BOOL *pbSubscribable)
{
    PIntshcut pintshcut;
    HRESULT hr;
    PTSTR pszURL;

    *pbSubscribable = FALSE;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pintshcut = ISPS_GetThisPtr(hdlg);

    hr = pintshcut->GetURL(&pszURL);

    if (hr == S_OK)
    {
        TCHAR szVisits[256];
        EVAL(SetDlgItemText(hdlg, IDC_URL, pszURL));

        TraceMsg(TF_INTSHCUT, "SetISPSURL(): Set property sheet URL to \"%s\".",
                   pszURL);

        *pbSubscribable = IsSubscribable(pszURL);
        
        BYTE cei[MAX_CACHE_ENTRY_INFO_SIZE];
        LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;
        DWORD       cbcei = MAX_CACHE_ENTRY_INFO_SIZE;

#ifdef UNIX_FEATURE_ALIAS
        {
            HDPA  aliasList = GetGlobalAliasList();
            if( aliasList )
            {
#ifdef UNICODE
            // TODO :
#else
            CHAR szAlias[ MAX_ALIAS_LENGTH ];
            if(FindAliasByURLA( aliasList, pszURL, szAlias, sizeof(szAlias) ) )
                 SetDlgItemText(hdlg, IDC_ALIAS_NAME, szAlias);
#endif
            }
        }
#endif  /* UNIX_FEATURE_ALIAS */

        if (GetUrlCacheEntryInfo(pszURL, pcei, &cbcei))
        {
            wnsprintf(szVisits, ARRAYSIZE(szVisits), TEXT("%d"), pcei->dwHitRate);
        }
        else
        {
            MLLoadString(IDS_VALUE_UNKNOWN, szVisits, ARRAYSIZE(szVisits));
        }

        EVAL(SetDlgItemText(hdlg, IDC_VISITS, szVisits));

        SHFree(pszURL);
        pszURL = NULL;
    }
    else
        EVAL(SetDlgItemText(hdlg, IDC_URL, c_szNULL));

    return;
}

void 
InitISPSHotkey(
    HWND hdlg)
{
    PIntshcut pintshcut;
    WORD wHotkey;
    HRESULT hr;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    // Set hotkey combinations.

    SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_SETRULES,
                       (HKCOMB_NONE | HKCOMB_A | HKCOMB_C | HKCOMB_S),
                       (HOTKEYF_CONTROL | HOTKEYF_ALT));

    // Set current hotkey.

    pintshcut = ISPS_GetThisPtr(hdlg);
    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));

    hr = pintshcut->GetHotkey(&wHotkey);
    SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_SETHOTKEY, wHotkey, 0);

    return;
}


void ISPS_ShowOfflineSummary(HWND hdlg, BOOL bShow, PISDATA pisdata)
{
    static const int offSumIDs[] =
    {
        IDC_SUMMARY,
        IDC_LAST_SYNC_TEXT,
        IDC_LAST_SYNC,
        IDC_DOWNLOAD_SIZE_TEXT,
        IDC_DOWNLOAD_SIZE,
        IDC_DOWNLOAD_RESULT,
        IDC_DOWNLOAD_RESULT_TEXT,
        IDC_FREESPACE_TEXT
    };

    if (bShow)
    {
        IUniformResourceLocatorW *pIURLW;

        TCHAR szLastSync[128];
        TCHAR szDownloadSize[128];
        TCHAR szDownloadResult[128];

        MLLoadString(IDS_VALUE_UNKNOWN, szLastSync, ARRAYSIZE(szLastSync));
        StrCpyN(szDownloadSize, szLastSync, ARRAYSIZE(szDownloadSize));
        StrCpyN(szDownloadResult, szLastSync, ARRAYSIZE(szDownloadResult));

        if (SUCCEEDED(pisdata->SubsHelper.GetIURLW(&pIURLW)))
        {
            WCHAR *pwszURL;

            if (SUCCEEDED(pIURLW->GetURL(&pwszURL)))
            {            
                ISubscriptionMgr2 *pSubsMgr2;
               
                if (SUCCEEDED(pisdata->SubsHelper.GetSubsMgr2(&pSubsMgr2, FIEF_FLAG_PEEK | FIEF_FLAG_FORCE_JITUI)))
                {
                    ISubscriptionItem *psi;
                    
                    if (SUCCEEDED(pSubsMgr2->GetItemFromURL(pwszURL, &psi)))
                    {
                        enum { spLastSync, spDownloadSize, spDownloadResult };
                        static const LPCWSTR pProps[] =
                        { 
                            c_szPropCompletionTime,
                            c_szPropCrawlActualSize,
                            c_szPropStatusString
                        };
                        VARIANT vars[ARRAYSIZE(pProps)];

                        if (SUCCEEDED(psi->ReadProperties(ARRAYSIZE(pProps), pProps, vars)))
                        {
                            if (VT_DATE == vars[spLastSync].vt)
                            {
                                FILETIME ft, ft2;
                                DWORD dwFlags = FDTF_DEFAULT;
                                SYSTEMTIME st;

                                if (VariantTimeToSystemTime(vars[spLastSync].date, &st))
                                {
                                    SystemTimeToFileTime(&st, &ft);
                                    LocalFileTimeToFileTime(&ft, &ft2);
                                    SHFormatDateTime(&ft2, &dwFlags, szLastSync, ARRAYSIZE(szLastSync));
                                }
                            }

                            if (VT_I4 == vars[spDownloadSize].vt)
                            {
                                StrFormatByteSize(vars[spDownloadSize].lVal * 1024, 
                                                  szDownloadSize, ARRAYSIZE(szDownloadSize));
                            }

                            if (VT_BSTR == vars[spDownloadResult].vt)
                            {
                                wnsprintf(szDownloadResult, ARRAYSIZE(szDownloadResult),
                                          TEXT("%s"), vars[spDownloadResult].bstrVal);
                            }

                            for (int i = 0; i < ARRAYSIZE(pProps); i++)
                            {
                                VariantClear(&vars[i]);
                            }
                        }
                        
                        psi->Release();
                    }

                    pSubsMgr2->Release();
                }
                
                SHFree(pwszURL);
            }
            
            pIURLW->Release();
        }

        EVAL(SetDlgItemText(hdlg, IDC_LAST_SYNC, szLastSync));
        EVAL(SetDlgItemText(hdlg, IDC_DOWNLOAD_SIZE, szDownloadSize));
        EVAL(SetDlgItemText(hdlg, IDC_DOWNLOAD_RESULT, szDownloadResult));
    }

    for (int i = 0; i < ARRAYSIZE(offSumIDs); i++)
    {
        ShowWindow(GetDlgItem(hdlg, offSumIDs[i]), bShow ? SW_SHOW : SW_HIDE);
    }
}

BOOL ISPS_AddSubsPropsCallback(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    return BOOLFROMPTR(PropSheet_AddPage((HWND)lParam, hpage));
}

STDMETHODIMP ISPS_AddSubsProps(HWND hdlg, ISubscriptionMgr2 *pSubsMgr2, PISDATA pisdata)
{
    HRESULT hr = S_OK;
    IShellPropSheetExt *pspse;

    ASSERT(NULL != pisdata);
    ASSERT(NULL != pSubsMgr2);

    hr = pisdata->SubsHelper.DoShellExtInit(pisdata->GetIntshcut()->GetInitDataObject());

    if (SUCCEEDED(hr))
    {
        hr = pSubsMgr2->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));

        if (SUCCEEDED(hr))
        {
            hr = pspse->AddPages(ISPS_AddSubsPropsCallback,
                                 (LPARAM)GetParent(hdlg)) ? S_OK : E_FAIL;
            pspse->Release();
        }
    }

    return hr;
}

STDMETHODIMP ISPS_RemoveSubsProps(HWND hdlg, ISubscriptionMgr2 *pSubsMgr2)
{
    HRESULT hr;
    ISubscriptionMgrPriv *psmp;

    ASSERT(NULL != pSubsMgr2);

#ifndef UNIX
    hr = pSubsMgr2->QueryInterface(IID_PPV_ARG(ISubscriptionMgrPriv, &psmp));

    if (SUCCEEDED(hr))
    {
        hr = psmp->RemovePages(GetParent(hdlg));
        psmp->Release();
    }
#else
    hr = E_FAIL;
#endif

    return hr;
}

HRESULT ISPS_OnMakeOfflineClicked(HWND hdlg)
{
#ifndef UNIX
    HRESULT hr;
    BOOL bChecked = IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE);
    PISDATA pisdata = ISPS_GetPISDATA(hdlg);
    ISubscriptionMgr2 *pSubsMgr2;

    hr = pisdata->SubsHelper.GetSubsMgr2(&pSubsMgr2, FIEF_FLAG_FORCE_JITUI);

    ASSERT((SUCCEEDED(hr) && pSubsMgr2) || (FAILED(hr) && !pSubsMgr2));
        
    if (bChecked)
    {
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pSubsMgr2);
            
            hr = ISPS_AddSubsProps(hdlg, pSubsMgr2, pisdata);
        }
        else
        {
            //  Can't do this without subsmgr
            CheckDlgButton(hdlg, IDC_MAKE_OFFLINE, BST_UNCHECKED);
            bChecked = FALSE;
        }
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pSubsMgr2);
            hr = ISPS_RemoveSubsProps(hdlg, pSubsMgr2);
        }
    }

    if (NULL != pSubsMgr2)
    {
        pSubsMgr2->Release();
    }

    ISPS_ShowOfflineSummary(hdlg, bChecked, pisdata);

    return hr;
#else
    // IEUNIX : ( MAKE_OFFLINE disabled )
    return E_FAIL;
#endif
}


BOOL 
ISPS_InitDialog(
    HWND hdlg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;
    PIntshcut pintshcut;
    PISDATA pisdata;
    BOOL bSubscribable;
    
    // wParam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    
    pisdata = (PISDATA)ppsp->lParam;
    ASSERT(IS_VALID_STRUCT_PTR(pisdata, ISDATA));

    SetWindowLongPtr(hdlg, DWLP_USER, ppsp->lParam);

    pintshcut = pisdata->GetIntshcut();
    pisdata->SubsHelper.SetParentHwnd(hdlg);
    
    // Cross-lang platform support
    SHSetDefaultDialogFont(hdlg, IDC_START_IN);
    SHSetDefaultDialogFont(hdlg, IDC_URL); // for intra-net

    // Initialize control contents.
    SetISPSFileNameAndIcon(hdlg);

    InitISPSHotkey(hdlg);

    SendDlgItemMessage(hdlg, IDC_URL, EM_LIMITTEXT, INTERNET_MAX_URL_LENGTH - 1, 0);
    SetISPSURL(hdlg, &bSubscribable);

#ifndef UNIX
    // IEUNIX : ( MAKE_OFFLINE disabled )
    if (pisdata->SubsHelper.m_dwFlags & ISF_STARTSUBSCRIBED)
    {
        CheckDlgButton(hdlg, IDC_MAKE_OFFLINE, TRUE);
    }

    if (!bSubscribable)
    {
        pisdata->SubsHelper.m_dwFlags |= ISF_DISABLEOFFLINE;
    }

    if (pisdata->SubsHelper.m_dwFlags & ISF_DISABLEOFFLINE)
    {
        EnableWindow(GetDlgItem(hdlg, IDC_MAKE_OFFLINE), FALSE);
    }

    ISPS_ShowOfflineSummary(hdlg, 
                            pisdata->SubsHelper.m_dwFlags & ISF_STARTSUBSCRIBED, 
                            pisdata);
#endif

    // since we just finished initing the dialog, set pisdata->bUserEditedPage to
    // FALSE. If the user messes with the page (eg clicks a button or types in an edit box),
    // we will set it to TRUE so we know that we actually have changes to apply.
    //
    // NOTE: this must come last since when we call SetDlgItemText above, we will
    // generate WM_COMMAND messages that cause us to set bUserEditedPage to TRUE.
    pisdata->bUserEditedPage = FALSE;

    return(TRUE);
}


BOOL
ISPS_Destroy(
    HWND hdlg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    PISDATA pisdata = ISPS_GetPISDATA(hdlg);
    
#ifndef UNIX
    // IEUNIX : ( MAKE_OFFLINE disabled )
    if ((!(pisdata->SubsHelper.m_dwFlags & ISF_STARTSUBSCRIBED)) && 
        IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE))

    {
        pisdata->SubsHelper.UpdateSubscription();
    }
#endif
    

    SetWindowLongPtr(hdlg, DWLP_USER, NULL);
    SHRemoveDefaultDialogFont(hdlg);

    return(TRUE);
}

void
ISPSChanged(
    HWND hdlg)
{
    PISDATA pisdata;
    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pisdata = ISPS_GetPISDATA(hdlg);
    pisdata->bUserEditedPage = TRUE;
    
    PropSheet_Changed(GetParent(hdlg), hdlg);
    
    return;
}

HRESULT
ChooseIcon(
    HWND hdlg)
{
    HRESULT hr;
    PISDATA pisdata;
    PIntshcut pintshcut;
    TCHAR szPath[MAX_PATH], szExpandedPath[MAX_PATH];
    int niIcon;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pisdata = ISPS_GetPISDATA(hdlg);
    pintshcut = pisdata->GetIntshcut();

    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));

    szPath[0] = TEXT('\0');

    hr = pintshcut->GetIconLocation(szPath, MAX_PATH, (int *)(&niIcon));
                                             
    if((FAILED(hr)) || (FALSE == PathFileExists(szPath)))
    {
        hr = GetGenericURLIcon(szPath, MAX_PATH, (int *)(&niIcon));
        if(FAILED(hr))
        {
            szPath[0] = '\0';
            niIcon = 0;
        }
    }

    ASSERT(lstrlen(szPath) < SIZECHARS(szPath));

    if (PickIconDlg(hdlg, szPath, SIZECHARS(szPath), &niIcon) &&
        SHExpandEnvironmentStrings(szPath, szExpandedPath, SIZECHARS(szExpandedPath)))
    {
        ASSERT(lstrlen(szExpandedPath) < SIZECHARS(pisdata->rgchIconFile));
        StrCpyN(pisdata->rgchIconFile, szExpandedPath, ARRAYSIZE(pisdata->rgchIconFile));
        pisdata->niIcon = niIcon;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;

        TraceMsg(TF_INTSHCUT, "ChooseIcon(): PickIconDlg() failed.");
    }

    return(hr);
}

void
UpdateISPSIcon(
    HWND hdlg)
{
    PIntshcut pintshcut;
    PISDATA pisdata;
    HICON hicon;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pisdata = ISPS_GetPISDATA(hdlg);
    pintshcut = pisdata->GetIntshcut();

    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));

    ASSERT(pisdata->rgchIconFile[0]);

    // This icon does not have the link arrow overlayed.  shell32.dll's
    // Shortcut property sheet has the same bug.

    hicon = ExtractIcon(g_hinst, pisdata->rgchIconFile, pisdata->niIcon);

    if (hicon)
        SetISPSIcon(hdlg, hicon);
    else
        TraceMsg(TF_WARNING, "UpdateISPSIcon(): ExtractIcon() failed for icon %d in file %s.",
                 pisdata->niIcon,
                 pisdata->rgchIconFile);
}

BOOL 
ISPS_Command(
    HWND hdlg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;
    WORD wCmd;

    // wParam may be any value.
    // lParam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    wCmd = HIWORD(wParam);

    switch (LOWORD(wParam))
    {
        case IDC_URL:
        case IDC_HOTKEY:
            if (wCmd == EN_CHANGE)
            {
                ISPSChanged(hdlg);

                bMsgHandled = TRUE;
            }
            break;

#ifndef UNIX
        // IEUNIX : ( MAKE_OFFLINE disabled )
        case IDC_MAKE_OFFLINE:
            if (wCmd == BN_CLICKED)
            {
                ISPS_OnMakeOfflineClicked(hdlg);

                ISPSChanged(hdlg);

                bMsgHandled = TRUE;
            }
            break;


        case IDC_CHANGE_ICON:
            // Ignore return value.
            if (ChooseIcon(hdlg) == S_OK)
            {
                UpdateISPSIcon(hdlg);
                ISPSChanged(hdlg);
            }
            bMsgHandled = TRUE;
            break;
#endif

        default:
            break;
    }

    return(bMsgHandled);
}

HRESULT 
ComplainAboutURL(
    HWND hwndParent, 
    LPCTSTR pcszURL, 
    HRESULT hrError)
{
    HRESULT hr;
    int nResult;

    // Validate hrError below.

    ASSERT(IS_VALID_HANDLE(hwndParent, WND));
    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));

    switch (hrError)
    {
        case URL_E_UNREGISTERED_PROTOCOL:
        {
            LPTSTR pszProtocol;

            hr = CopyURLProtocol(pcszURL, &pszProtocol, NULL);

            if (hr == S_OK)
            {
                nResult = MLShellMessageBox(
                                          hwndParent, 
                                          MAKEINTRESOURCE(IDS_UNREGISTERED_PROTOCOL),
                                          MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                          (MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION),
                                          pszProtocol);

                if (-1 != nResult)
                {
                    switch (nResult)
                    {
                        case IDYES:
                            hr = S_OK;
                            TraceMsg(TF_INTSHCUT, "ComplainAboutURL(): Allowing URL %s despite unregistered protocol %s, by request.",
                                       pcszURL,
                                       pszProtocol);
                            break;

                        default:
                            ASSERT(nResult == IDNO);
                            hr = E_FAIL;
                            TraceMsg(TF_INTSHCUT, "ComplainAboutURL(): Not allowing URL %s because of unregistered protocol %s, as directed.",
                                       pcszURL,
                                       pszProtocol);
                            break;
                    }
                }

                LocalFree(pszProtocol);
                pszProtocol = NULL;
            }

            break;
        }

        default:
            ASSERT(hrError == URL_E_INVALID_SYNTAX);

            MLShellMessageBox(
                            hwndParent, 
                            MAKEINTRESOURCE(IDS_INVALID_URL_SYNTAX),
                            MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                            MB_OK | MB_ICONEXCLAMATION,
                            pcszURL);

            hr = E_FAIL;

            TraceMsg(TF_INTSHCUT, "ComplainAboutURL(): Not allowing URL %s because of invalid syntax.",
                       pcszURL);

            break;
    }

    return(hr);
}

HRESULT 
InjectISPSData(
    HWND hdlg)
{
    HRESULT hr;
    PISDATA pisdata;
    PIntshcut pintshcut;
    PTSTR pszURL;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pisdata = ISPS_GetPISDATA(hdlg);
    pintshcut = pisdata->GetIntshcut();

    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));

    //  TODO: Inform the subsmgr of any URL changes!  IE 4 didn't handle this...

    hr = CopyDlgItemText(hdlg, IDC_URL, &pszURL);

    if (SUCCEEDED(hr))
    {
        LPCTSTR pcszURLToUse;
        TCHAR szURL[MAX_URL_STRING];

        pcszURLToUse = pszURL;

        if (hr == S_OK)
        {
            hr = IURLQualify(pszURL, UQF_DEFAULT, szURL, NULL, NULL);

            if (SUCCEEDED(hr))
            {
                pcszURLToUse = szURL;

                hr = ValidateURL(pcszURLToUse);

                if (FAILED(hr))
                {
                    hr = ComplainAboutURL(hdlg, pcszURLToUse, hr);
                  
                    if (FAILED(hr))
                        SetEditFocus(GetDlgItem(hdlg, IDC_URL));
                }
            }
        }
        else
        {
            // A blank URL is not OK.
            ASSERT(hr == S_FALSE);

            hr = ComplainAboutURL(hdlg, TEXT(""), URL_E_INVALID_SYNTAX);

            if (FAILED(hr))
                SetEditFocus(GetDlgItem(hdlg, IDC_URL));

        }

        if (SUCCEEDED(hr))
        {
            hr = pintshcut->SetURL(pcszURLToUse, 0);

            if (hr == S_OK)
            {
                WORD wHotkey;
                WORD wOldHotkey;
                BOOL bSubscribable;

                // Refresh URL in case it was changed by IURLQualify().

                SetISPSURL(hdlg, &bSubscribable);

#ifndef UNIX
                // IEUNIX : ( MAKE_OFFLINE disabled )
                if (!bSubscribable)
                {
                    EnableWindow(GetDlgItem(hdlg, IDC_MAKE_OFFLINE), FALSE);
                }

                // IEUNIX : Hot key and working directory are N/A on UNIX.
                wHotkey = (WORD)SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_GETHOTKEY, 0, 0);

                hr = pintshcut->GetHotkey(&wOldHotkey);
                if (hr == S_OK)
                {
                    hr = pintshcut->SetHotkey(wHotkey);
                    if (hr == S_OK)
                    {
                        TCHAR szFile[MAX_PATH];
                        hr = pintshcut->GetCurFile(szFile, SIZECHARS(szFile));
                        if (hr == S_OK)
                        {
                            if (RegisterGlobalHotkey(wOldHotkey, wHotkey, szFile))
                            {
                                if (pisdata->rgchIconFile[0])
                                {
                                    hr = pintshcut->SetIconLocation(pisdata->rgchIconFile, pisdata->niIcon);
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                }
#endif //!UNIX
                pintshcut->ChangeNotify(SHCNE_UPDATEITEM, 0);
            }
        }

        if (pszURL)
        {
            LocalFree(pszURL);
            pszURL = NULL;
        }
    }

    if (hr == S_OK)
        TraceMsg(TF_INTSHCUT, "InjectISPSData(): Injected property sheet data into Internet Shortcut successfully.");
    else
        TraceMsg(TF_WARNING, "InjectISPSData(): Failed to inject property sheet data into Internet Shortcut, returning %s.",
                     Dbg_GetHRESULTName(hr));

    return(hr);
}

HRESULT 
ISPSSave(
    HWND hdlg)
{
    HRESULT hr;
    PIntshcut pintshcut;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pintshcut = ISPS_GetThisPtr(hdlg);

    if (pintshcut->IsDirty() == S_OK)
    {
        hr = pintshcut->Save((LPCOLESTR)NULL, FALSE);

        if (hr == S_OK)
        {
            TraceMsg(TF_INTSHCUT, "ISPSSave(): Saved Internet Shortcut successfully.");
        }
        else
        {
            TraceMsg(TF_WARNING, "ISPSSave(): Save() failed, returning %s.",
                         Dbg_GetHRESULTName(hr));
            MLShellMessageBox(
                            hdlg,
                            MAKEINTRESOURCE(IDS_IS_APPLY_FAILED),
                            MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                            (MB_OK | MB_ICONEXCLAMATION));
        }
    }
    else
    {
        TraceMsg(TF_INTSHCUT, "ISPSSave(): Internet Shortcut unchanged.  No save required.");

        hr = S_OK;
    }

    return(hr);
}

BOOL 
ISPS_Notify(
    HWND hdlg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;

    // wParam may be any value.
    // lParam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    switch (((NMHDR *)lParam)->code)
    {
        case PSN_APPLY:
        {
#ifndef UNIX
            // IEUNIX : ( MAKE_OFFLINE disabled )
            BOOL bSubscribed = IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE);
            PISDATA pisdata = ISPS_GetPISDATA(hdlg);
            
            if (!bSubscribed)
            {
                pisdata->SubsHelper.DeleteSubscription();
            }
            else
            {
                pisdata->SubsHelper.SaveSubscription();
            }

#endif /* !UNIX */

            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, ISPSSave(hdlg) == S_OK ?
                                                   PSNRET_NOERROR :
                                                   PSNRET_INVALID_NOCHANGEPAGE);
            bMsgHandled = TRUE;
            break;
        }

        case PSN_KILLACTIVE:
        {
            PISDATA pisdata = ISPS_GetPISDATA(hdlg);

            if (pisdata->bUserEditedPage)
            {
                // only try to inject the data if the user actually changed something
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FAILED(InjectISPSData(hdlg)));
            }
            bMsgHandled = TRUE;
            break;
        }

        default:
            break;
    }

    return(bMsgHandled);
}

LPCTSTR 
ISPS_GetHelpFileFromControl(
    HWND hwndControl)
{
    LPCTSTR pcszHelpFile = NULL;
    int nControlID = 0;

    ASSERT(! hwndControl ||
           IS_VALID_HANDLE(hwndControl, WND));

    if (hwndControl)
    {
        nControlID = GetDlgCtrlID(hwndControl);

        switch (nControlID)
        {
            default:
                // URL help comes from the iexplore.hlp
                pcszHelpFile = s_cszIEHelpFile;
                break;

            // Other help is borrowed from the default Win95 help file.
            case IDC_ICON:
            case IDC_NAME:
            case IDC_HOTKEY_TEXT:
            case IDC_HOTKEY:
            case IDC_CHANGE_ICON:
                break;
        }
    }

    TraceMsg(TF_INTSHCUT, "ISPS_GetHelpFileFromControl(): Using %s for control %d (HWND %#lx).",
               pcszHelpFile ? pcszHelpFile : TEXT("default Win95 help file"),
               nControlID,
               hwndControl);

    ASSERT(! pcszHelpFile ||
           IS_VALID_STRING_PTR(pcszHelpFile, -1));

    return(pcszHelpFile);
}

INT_PTR 
CALLBACK 
ISPS_DlgProc(
    HWND hdlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;

    // uMsg may be any value.
    // wParam may be any value.
    // lParam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            bMsgHandled = ISPS_InitDialog(hdlg, wParam, lParam);
            break;

        case WM_DESTROY:
            bMsgHandled = ISPS_Destroy(hdlg, wParam, lParam);
            break;

        case WM_COMMAND:
            bMsgHandled = ISPS_Command(hdlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            bMsgHandled = ISPS_Notify(hdlg, wParam, lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lParam)->hItemHandle),
                    ISPS_GetHelpFileFromControl((HWND)(((LPHELPINFO)lParam)->hItemHandle)),
                    HELP_WM_HELP, (DWORD_PTR)(PVOID)c_rgdwHelpIDs);
            bMsgHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
        {
            HWND hwnd;

            if (!IS_WM_CONTEXTMENU_KEYBOARD(lParam))
            {
                POINT pt;
                LPARAM_TO_POINT(lParam, pt);
                EVAL(ScreenToClient(hdlg, &pt));
                hwnd = ChildWindowFromPoint(hdlg, pt);
            }
            else
            {
                // For some reason on the keyboard case we don't actually
                // come to this WM_CONTEXTMENU handler -- someone somewhere
                // else is popping up the menu at the cursor instead of on
                // this hwnd...
                //
                hwnd = GetFocus();
            }

            SHWinHelpOnDemandWrap((HWND)wParam,
                    ISPS_GetHelpFileFromControl(hwnd),
                    HELP_CONTEXTMENU, (DWORD_PTR)(PVOID)c_rgdwHelpIDs);
            bMsgHandled = TRUE;
            break;
        }
        
        default:
           break;
    }

    return(bMsgHandled);
}

HRESULT AddISPage(HPROPSHEETPAGE * phpsp,
                  PROPSHEETPAGE * ppsp,
                  LPFNADDPROPSHEETPAGE pfnAddPage,
                  LPARAM lParam)
{
    HRESULT hres;
    
    ASSERT(phpsp);
    ASSERT(ppsp);
    
    *phpsp = Whistler_CreatePropertySheetPageW(ppsp);
    
    if (NULL == *phpsp)
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        if ( !(*pfnAddPage)(*phpsp, lParam) )
        {
            DestroyPropertySheetPage(*phpsp);
            *phpsp = NULL;
            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = NO_ERROR;
        }
    }
    return hres;
}

HRESULT AddISPS(PIntshcut pintshcut, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HRESULT hr;
    PISDATA pisdata;
    
    // lParam may be any value.
    
    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));
    ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));
    
    // Initialize instance data between property pages
    
    pisdata = new ISDATA;
    if ( !pisdata )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        PROPSHEETPAGE psp;
        HPROPSHEETPAGE hpsp;
        WCHAR *pwszURL;

        hr = pintshcut->GetURLW(&pwszURL);

        if (SUCCEEDED(hr))
        {
            pisdata->SetIntshcut(pintshcut);
            pisdata->SubsHelper.Init();
            SHFree(pwszURL);
            
            ASSERT(IS_VALID_STRUCT_PTR(pisdata, ISDATA));
            
            // Add the Internet Shortcut page
            
            ZeroMemory(&psp, SIZEOF(psp));
            psp.dwSize       = SIZEOF(psp);
            psp.dwFlags      = PSP_DEFAULT | PSP_USECALLBACK;
            psp.hInstance    = MLGetHinst();
            psp.pszTemplate  = MAKEINTRESOURCE(IDD_INTSHCUT_PROP);
            psp.pfnDlgProc   = &ISPS_DlgProc;
            psp.lParam       = (LPARAM)pisdata;
            psp.pfnCallback  = &ISPSCallback;
            
            hr = AddISPage(&hpsp, &psp, pfnAddPage, lParam);

            if (SUCCEEDED(hr) && (pisdata->SubsHelper.m_dwFlags & ISF_STARTSUBSCRIBED))
            {
                HRESULT hrTmp = pisdata->SubsHelper.DoShellExtInit(pisdata->GetIntshcut()->GetInitDataObject());

                if (SUCCEEDED(hrTmp))
                {
                    ISubscriptionMgr2 *pSubsMgr2;

                    hrTmp = pisdata->SubsHelper.GetSubsMgr2(&pSubsMgr2, FIEF_FLAG_PEEK | FIEF_FLAG_FORCE_JITUI);

                    if (SUCCEEDED(hrTmp))
                    {
                        IShellPropSheetExt *pspse;

                        hrTmp = pSubsMgr2->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));

                        if (SUCCEEDED(hrTmp))
                        {
                            hrTmp = pspse->AddPages(pfnAddPage, lParam);
                            pspse->Release();
                        }

                        pSubsMgr2->Release();
                    }
                }
            }
        }
        
        if (FAILED(hr))
        {
            delete pisdata;
            pisdata = NULL;
        }
    }
    
    return hr;
}

// IShellExtInit::Initialize method for Intshcut

STDMETHODIMP Intshcut::Initialize(LPCITEMIDLIST pcidlFolder, IDataObject * pido, HKEY hkeyProgID)
{
    HRESULT hr;
    STGMEDIUM stgmed;
    FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    ASSERT(NULL != pido);
    
    if (m_pInitDataObject)
    {
        m_pInitDataObject->Release();
    }
    m_pInitDataObject = pido;
    m_pInitDataObject->AddRef();

    hr = pido->GetData(&fmtetc, &stgmed);
    if (hr == S_OK)
    {
        TCHAR szPath[MAX_PATH];
        if (DragQueryFile((HDROP)stgmed.hGlobal, 0, szPath, SIZECHARS(szPath)))
        {
            m_fProbablyDefCM = TRUE;
            hr = LoadFromFile(szPath);
        }

        ReleaseStgMedium(&stgmed);
    }

    return(hr);
}

// IShellPropSheetExt::AddPages method for Intshcut

STDMETHODIMP Intshcut::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

    HRESULT hres = AddISPS(this, pfnAddPage, lParam);
    if (SUCCEEDED(hres))
    {
        // Make the Internet Shortcut page be the default page
        hres = ResultFromShort(1);  
    }

    return hres;
}

STDMETHODIMP Intshcut::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\isurl.cpp ===
/*
 * isurl.cpp - IUniformResourceLocator implementation for Intshcut class.
 */
#include "priv.h"
#include "ishcut.h"
#include "urlprop.h"
#include "assocurl.h"
#include "shlwapi.h"
#include "infotip.h"
#include "resource.h"
#include <intshctp.h>

#include <mluisupp.h>

#define DM_PLUGGABLE DM_TRACE
#define DM_SHELLEXECOBJECT         0x80000000

extern HRESULT CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN /*IN,OUT*/ *ppunk);

const TCHAR c_szDefaultVerbSubKeyFmt[]  = TEXT("%s\\Shell");

const TCHAR c_szAppCmdLineFmt[]         = TEXT(" %s");
const TCHAR c_szQuotesAppCmdLineFmt[]   = TEXT(" \"%s\"");


/***************************** Private Functions *****************************/


/* input flags to MyExecute() */

typedef enum myexecute_in_flags
{
    /*
     * Adds double quotes around the given argument string on the generated
     * command line if the argument string contains any white space.
     */

    ME_IFL_QUOTE_ARGS    = 0x0001,

    /* flag combinations */

    ALL_ME_IN_FLAGS      = ME_IFL_QUOTE_ARGS
}
MYEXECUTE_IN_FLAGS;


/*----------------------------------------------------------
Purpose: Calls CreateProcess() politely

Returns:
Cond:    --
*/
HRESULT
MyExecute(
    LPCTSTR pcszApp,
    LPCTSTR pcszArgs,
    DWORD dwInFlags)
{
    HRESULT hr;
    TCHAR szFullApp[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTR(pcszApp, -1));
    ASSERT(IS_VALID_STRING_PTR(pcszArgs, -1));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_ME_IN_FLAGS));

    hr = PathSearchAndQualify(pcszApp, szFullApp, SIZECHARS(szFullApp));
    if (hr == S_OK)
    {
        DWORD cbSize;
        LPTSTR pszCmdLine;

        // (+ 1) for null terminator.
        cbSize = max(SIZEOF(c_szAppCmdLineFmt),
                         SIZEOF(c_szQuotesAppCmdLineFmt)) +
                         + CbFromCch(lstrlen(szFullApp) + lstrlen(pcszArgs) + 1);

        pszCmdLine = (LPTSTR)LocalAlloc(LPTR, cbSize);

        if (pszCmdLine)
        {
            LPCTSTR pcszFmt;
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            // Execute URL via one-shot app.
            pcszFmt = (IsFlagSet(dwInFlags, ME_IFL_QUOTE_ARGS) &&
                       StrPBrk(pcszArgs, TEXT(" \t")) != NULL)
                       ? c_szQuotesAppCmdLineFmt : c_szAppCmdLineFmt;

            wnsprintf(pszCmdLine, cbSize / sizeof(TCHAR), pcszFmt, pcszArgs);

            ZeroMemory(&si, SIZEOF(si));
            si.cb = SIZEOF(si);

            // Specify command line exactly as given to app.
            if (CreateProcess(szFullApp, pszCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
            {
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);

                hr = S_OK;

                TraceMsg(TF_INTSHCUT, "MyExecute(): CreateProcess() \"%s\" succeeded.", pszCmdLine);
            }
            else
            {
                hr = E_FAIL;

                TraceMsg(TF_WARNING, "MyExecute(): CreateProcess() \"%s\" failed.", pszCmdLine);
            }

            LocalFree(pszCmdLine);
            pszCmdLine = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "MyExecute(): Unable to find app %s.", pcszApp);
    }

    return(hr);
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the given internet shortcut points
         to a website (as opposed to an ftp site, etc).

Returns: see above
*/
BOOL IsWebsite(IN Intshcut * pintshcut)
{
    ASSERT(pintshcut);
    
    //   (scotth): we are assuming that file: schemes are
    //   generally web pages.  This is not true.  For file: schemes,
    //   we should first verify that it is an htm filetype.)
    
    return (URL_SCHEME_HTTP == pintshcut->GetScheme() ||
        URL_SCHEME_FILE == pintshcut->GetScheme());
}



BOOL
GetClassDefaultVerb(
    LPCTSTR pcszClass,
    LPTSTR  pszDefaultVerbBuf,
    UINT    cchBufLen)
{
    // No; get the default verb
    TCHAR szKey[MAX_PATH];

    StrCpyN(szKey, pcszClass, SIZECHARS(szKey));
    StrCatBuff(szKey, TEXT("\\"), SIZECHARS(szKey));
    StrCatBuff(szKey, TEXT("shell"), SIZECHARS(szKey));
    DWORD cbSize = CbFromCch(cchBufLen);

    if (NO_ERROR != SHGetValue(HKEY_CLASSES_ROOT, szKey, NULL, NULL, pszDefaultVerbBuf, &cbSize) 
    || !*pszDefaultVerbBuf)
    {
        // Default to "open" if the registry doesn't specify one
        StrCpyN(pszDefaultVerbBuf, TEXT("open"), cchBufLen);
    }

    return TRUE;
}


#ifdef DEBUG

BOOL
IsValidPCPARSEDURL(
    LPCTSTR pcszURL,
    PCPARSEDURL pcpu)
{
    return(IS_VALID_READ_PTR(pcpu, CPARSEDURL) &&
           (IS_VALID_STRING_PTR(pcpu->pszProtocol, -1) &&
            EVAL(IsStringContained(pcszURL, pcpu->pszProtocol)) &&
            EVAL(pcpu->cchProtocol < (UINT)lstrlen(pcpu->pszProtocol))) &&
           (IS_VALID_STRING_PTR(pcpu->pszSuffix, -1) &&
            EVAL(IsStringContained(pcszURL, pcpu->pszSuffix)) &&
            EVAL(pcpu->cchSuffix <= (UINT)lstrlen(pcpu->pszSuffix))) &&
           EVAL(pcpu->cchProtocol + pcpu->cchSuffix < (UINT)lstrlen(pcszURL)));
}


BOOL
IsValidPCURLINVOKECOMMANDINFO(
    PCURLINVOKECOMMANDINFO pcurlici)
{
    return(IS_VALID_READ_PTR(pcurlici, CURLINVOKECOMMANDINFO) &&
           EVAL(pcurlici->dwcbSize >= SIZEOF(*pcurlici)) &&
           FLAGS_ARE_VALID(pcurlici->dwFlags, ALL_IURL_INVOKECOMMAND_FLAGS) &&
           (IsFlagClear(pcurlici->dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI) ||
            NULL == pcurlici->hwndParent || 
            IS_VALID_HANDLE(pcurlici->hwndParent, WND)) &&
           (IsFlagSet(pcurlici->dwFlags, IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB) ||
            IS_VALID_STRING_PTR(pcurlici->pcszVerb, -1)));
}

#endif

BOOL IsValidProtocolChar(TCHAR ch)
{
    if ((ch>=TEXT('a') && ch<=TEXT('z')) ||
        (ch>=TEXT('A') && ch<=TEXT('Z')) ||
        (ch>=TEXT('0') && ch<=TEXT('9')) ||
        (ch == TEXT('+')) ||
        (ch == TEXT('-')) ||
        (ch == TEXT('.'))   )
    {
        return TRUE;
    }
    return FALSE;
}


/********************************** Methods **********************************/

typedef struct
{
    UINT idsVerb;
    UINT idsMenuHelp;
    LPCTSTR pszVerb;
} ISCM;

const static ISCM g_rgiscm[] =
{
    { IDS_MENUOPEN,         IDS_MH_OPEN,            TEXT("open") },         //  IDCMD_ISCM_OPEN 
    { IDS_SYNCHRONIZE,      IDS_MH_SYNCHRONIZE,     TEXT("update now")},    //  IDCMD_ISCM_SYNC 
    { IDS_MAKE_OFFLINE,     IDS_MH_MAKE_OFFLINE,    TEXT("subscribe")},     //  IDCMD_ISCM_SUB  
};

//  WARNING - these must match their index into g_rgiscm
#define IDCMD_ISCM_OPEN   0
#define IDCMD_ISCM_SYNC   1
#define IDCMD_ISCM_SUB    2

BOOL _IsSubscribed(LPCWSTR pszUrl, BOOL *pfSubscribable)
{
    BOOL fRet = FALSE;
    ISubscriptionMgr * pMgr;
    
    *pfSubscribable = FALSE;
    
    if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ISubscriptionMgr, &pMgr))))
    {
        pMgr->IsSubscribed(pszUrl, &fRet);

                        
        pMgr->Release();
    }

    if (!fRet)
    {
        //test if we CAN subscribe to this thing
        if (!SHRestricted2W(REST_NoAddingSubscriptions, pszUrl, 0) &&
            IsFeaturePotentiallyAvailable(CLSID_SubscriptionMgr))
        {
            *pfSubscribable = IsSubscribableW(pszUrl);
        }
    }
    else
        *pfSubscribable = TRUE;
    
    return fRet;
}

void _InsertISCM(UINT indexISCM, HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT uFlags)
{
    TCHAR szMenu[CCH_MENUMAX];
    uFlags |= MF_BYPOSITION | MF_STRING;

    MLLoadShellLangString(g_rgiscm[indexISCM].idsVerb, szMenu, SIZECHARS(szMenu));
    InsertMenu_PrivateNoMungeW(hmenu, indexMenu, uFlags, idCmdFirst + indexISCM, szMenu);
}

// IContextMenu::QueryContextMenu handler for Intshcut
// The context menu handler adds the open verb for .url
// files.  This is because we remove the shell\open\command
// key in Nashville for this file type.

STDMETHODIMP Intshcut::QueryContextMenu(
    IN HMENU hmenu,
    IN UINT  indexMenu,
    IN UINT  idCmdFirst,
    IN UINT  idCmdLast,
    IN UINT  uFlags)
{
    //
    //  LEGACY - .URL files have to maintain an open verb in the registry - ZekeL - 14-APR-99
    //  we would like to just use the "open" verb here in the context menu extension,
    //  but we need to not duplicate the open verb that is added by DefCM
    //  on NT5+ shell32 we disable that verb so we can add it here.
    //  on earlier shell32 we want to add "open" any time we arent
    //  initialized by DefCM.  if we think that DefCM added us, 
    //  then we go ahead and allow the DefCM's open from the registry.
    //
    if (!m_fProbablyDefCM || GetUIVersion() >= 5)
    {
        _InsertISCM(IDCMD_ISCM_OPEN, hmenu, indexMenu, idCmdFirst, 0);
        if (-1 == GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0))
            SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);
        indexMenu++;
    }

#ifndef UNIX
    /* v-sriran: 12/8/97
     * disabling the context menu item for subscribe, separators etc.
     * because we are not supporting subscriptions right now
     */

    // skip this if we only want default or if there is no room for more.
    if (!(uFlags & CMF_DEFAULTONLY) && (idCmdLast - idCmdFirst >= ARRAYSIZE(g_rgiscm)))
    {
        WCHAR *pwszURL;
        if (SUCCEEDED(GetURLW(&pwszURL)))
        {
            BOOL bSubscribable = FALSE;             //can be subscribed to
            BOOL bSub = _IsSubscribed(pwszURL, &bSubscribable);
            m_bCheckForDelete = bSub && m_pszFile;

            if (bSubscribable || bSub)
            {
                //  add a separator for our subscription stuff
                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
                UINT uMenuFlags = 0;

                if (bSub)
                {
                    uMenuFlags |= MF_CHECKED;

                    if (SHRestricted2W(REST_NoRemovingSubscriptions, pwszURL, 0))
                    {
                        uMenuFlags |= MF_GRAYED;
                    }
                }

                _InsertISCM(IDCMD_ISCM_SUB, hmenu, indexMenu++, idCmdFirst, uMenuFlags);

                if (bSub)
                {
                    uMenuFlags = 0;

                    if (SHRestricted2W(REST_NoManualUpdates, NULL, 0))
                    {
                        uMenuFlags |= MF_GRAYED;
                    }
                    _InsertISCM(IDCMD_ISCM_SYNC, hmenu, indexMenu++, idCmdFirst, uMenuFlags);
                } 
            }
            
            SHFree(pwszURL);
        }
    }

#endif /* UNIX */

    return ResultFromShort(ARRAYSIZE(g_rgiscm));
}

STDMETHODIMP Intshcut::InvokeCommand(IN LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(pici);

    if (pici && SIZEOF(*pici) <= pici->cbSize)
    {
        UINT idCmd;

        if (0 == HIWORD(pici->lpVerb))      // Is the ID cmd given?
        {
            idCmd = LOWORD(pici->lpVerb);   // Yes

            //  Old versions of ShellExec() didnt get the right default command - Zekel - 15-MAR-99
            //  since our QCM implementation doesnt add anything to the menu
            //  if we fix the QCM to work correctly, then this problem will go away.
            //  it sent 0xfffe instead.  so just adjust here.
            if (idCmd == 0xfffe && GetUIVersion() <= 4)
                idCmd = IDCMD_ISCM_OPEN;
        }
        else
        {
            // No; a language-independent verb was supplied
            int i;
            LPCTSTR pszVerb;
            LPCMINVOKECOMMANDINFOEX piciex = (LPCMINVOKECOMMANDINFOEX)pici;
            ASSERT(SIZEOF(*piciex) <= piciex->cbSize);

            WCHAR szVerb[40];

            if (piciex->lpVerbW)
            {
                pszVerb = piciex->lpVerbW;
            }
            else
            {
                if (piciex->lpVerb)
                {
                    ASSERT(lstrlenA(piciex->lpVerb) < ARRAYSIZE(szVerb));
                    SHAnsiToUnicode(piciex->lpVerb, szVerb, ARRAYSIZE(szVerb));    
                }
                else
                {
                    szVerb[0] = L'\0';
                }
                    
                pszVerb = szVerb;
            }

            idCmd = (UINT)-1;
            for (i = 0; i < ARRAYSIZE(g_rgiscm); i++)
            {
                if (0 == StrCmpI(g_rgiscm[i].pszVerb, pszVerb))
                {
                    idCmd = i;
                    break;
                }
            }
        }

        switch (idCmd)
        {
        case IDCMD_ISCM_OPEN: 
            {
                URLINVOKECOMMANDINFO urlici;

                urlici.dwcbSize = SIZEOF(urlici);
                urlici.hwndParent = pici->hwnd;
                urlici.pcszVerb = NULL;
                urlici.dwFlags = IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB;

                if (IsFlagClear(pici->fMask, CMIC_MASK_FLAG_NO_UI))
                {
                    SetFlag(urlici.dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI);
                }
                if (IsFlagSet(pici->fMask, SEE_MASK_FLAG_DDEWAIT))
                {
                    SetFlag(urlici.dwFlags, IURL_INVOKECOMMAND_FL_DDEWAIT);
                }
                hres = InvokeCommand(&urlici);
                m_bCheckForDelete = FALSE;
            }
            break;

        case IDCMD_ISCM_SUB:
        case IDCMD_ISCM_SYNC:
        {
            hres = S_OK;

            WCHAR *pwszURL;
            if (SUCCEEDED(GetURLW(&pwszURL)))
            {
                ISubscriptionMgr * pMgr;
                if (SUCCEEDED(JITCoCreateInstance(CLSID_SubscriptionMgr, 
                                                  NULL, 
                                                  CLSCTX_INPROC_SERVER, 
                                                  IID_PPV_ARG(ISubscriptionMgr, &pMgr),
                                                  pici->hwnd,
                                                  FIEF_FLAG_FORCE_JITUI))) 
                {
                    if (idCmd == IDCMD_ISCM_SUB)  
                    {
                        BOOL bSubscribed;

                        pMgr->IsSubscribed(pwszURL, &bSubscribed);

                        if (!bSubscribed)
                        {
                            SHFILEINFO  sfi = {0};
                            WCHAR wszName[MAX_PATH];
                            wszName[0] = 0;
                            if (SHGetFileInfo(m_pszFile, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
                            {
                                SHTCharToUnicode(sfi.szDisplayName, wszName, ARRAYSIZE(wszName));
                            }

                            if (!wszName[0])
                                StrCpyNW(wszName, pwszURL, ARRAYSIZE(wszName));

                            //all subscriptions to local .urls are treated as subscribing something
                            //that's already in Favorites, so user isn't forced to add it to their
                            //favorites as they subscribe.
                            if (SUCCEEDED(pMgr->CreateSubscription(pici->hwnd, pwszURL, wszName,
                                                                   CREATESUBS_FROMFAVORITES, 
                                                                   SUBSTYPE_URL, 
                                                                   NULL)))
                            {
                                pMgr->UpdateSubscription(pwszURL);
                            }
                        }
                        else
                        {
                            pMgr->DeleteSubscription(pwszURL, pici->hwnd);
                        }
                    } 
                    else if (idCmd == IDCMD_ISCM_SYNC)
                    {
                        pMgr->UpdateSubscription(pwszURL);
                    }
                    pMgr->Release();    
                }
                SHFree(pwszURL);
                m_bCheckForDelete = FALSE;
            }
            break;
        }

        default:
            hres = E_INVALIDARG;
            break;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IContextMenu::GetCommandString handler for Intshcut

*/
STDMETHODIMP Intshcut::GetCommandString(
    IN     UINT_PTR idCmd,
    IN     UINT     uType,
    IN OUT UINT*    puReserved,
    IN OUT LPSTR    pszName,
    IN     UINT     cchMax)
{
    HRESULT hres;
    TCHAR szMenu[CCH_MENUMAX];

    ASSERT(NULL == puReserved);
    ASSERT(IS_VALID_WRITE_BUFFER(pszName, char, cchMax));

    switch (uType)
    {
    case GCS_HELPTEXTA:
    case GCS_HELPTEXTW:
        if (idCmd < ARRAYSIZE(g_rgiscm))
        {
            MLLoadString(g_rgiscm[idCmd].idsMenuHelp, szMenu, SIZECHARS(szMenu));

            if (GCS_HELPTEXTA == uType)
            {
                UnicodeToAnsi(szMenu, pszName, cchMax);
            }
            else
            {
                StrCpyN((LPWSTR)pszName, szMenu, cchMax);
            }
            hres = NOERROR;
        }
        else
        {
            ASSERT(0);
            hres = E_INVALIDARG;
        }
        break;

    case GCS_VALIDATEA:
    case GCS_VALIDATEW:
        hres = idCmd < ARRAYSIZE(g_rgiscm) ? S_OK : S_FALSE;
        break;

    case GCS_VERBA:
    case GCS_VERBW:
        if (idCmd < ARRAYSIZE(g_rgiscm))
        {
            LPCTSTR pszVerb = g_rgiscm[idCmd].pszVerb;

            if (GCS_VERBA == uType)
            {
                UnicodeToAnsi(pszVerb, pszName, cchMax);
            }
            else
            {
                StrCpyN((LPWSTR)pszName, pszVerb, cchMax);
            }
            hres = NOERROR;
        }
        else
        {
            ASSERT(0);
            hres = E_INVALIDARG;
        }
        break;

    default:
        hres = E_NOTIMPL;
        break;
    }

    return hres;
}


// IContextMenu2::HandleMenuMsg handler for Intshcut
STDMETHODIMP Intshcut::HandleMenuMsg(IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam)
{
    return S_OK;
}


/*----------------------------------------------------------
Purpose: Bring up UI to ask the user what to associate this 
         URL protocol to.

*/
STDMETHODIMP
Intshcut::RegisterProtocolHandler(
    HWND hwndParent,
    LPTSTR pszAppBuf,
    UINT cchBuf)
{
    HRESULT hr;
    DWORD dwFlags = 0;
    TCHAR szURL[MAX_URL_STRING];

    ASSERT(! hwndParent ||
           IS_VALID_HANDLE(hwndParent, WND));
    ASSERT(IS_VALID_WRITE_BUFFER(pszAppBuf, TCHAR, cchBuf));
    ASSERT(m_pprop);

    hr = InitProp();
    if (SUCCEEDED(hr))
    {
        hr = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        ASSERT(S_OK == hr);
        
        SetFlag(dwFlags, URLASSOCDLG_FL_REGISTER_ASSOC);

        if (! m_pszFile)
            SetFlag(dwFlags, URLASSOCDLG_FL_USE_DEFAULT_NAME);

        hr = AssociateURL(hwndParent, dwFlags, m_pszFile, szURL, pszAppBuf, cchBuf);

        switch (hr)
        {
        case S_FALSE:
            TraceMsg(TF_INTSHCUT, "Intshcut::RegisterProtocolHandler(): One time execution of %s via %s requested.",
                        szURL, pszAppBuf);
            break;

        case S_OK:
            TraceMsg(TF_INTSHCUT, "Intshcut::RegisterProtocolHandler(): Protocol handler registered for %s.",
                        szURL);
            break;

        default:
            ASSERT(FAILED(hr));
            break;
        }

        ASSERT(! cchBuf ||
               (IS_VALID_STRING_PTR(pszAppBuf, -1) &&
                (UINT)lstrlen(pszAppBuf) < cchBuf));
    }
    return(hr);
}


// Returns the protocol scheme value (URL_SCHEME_*).

STDMETHODIMP_(DWORD)
Intshcut::GetScheme(void)
{
    DWORD dwScheme = URL_SCHEME_UNKNOWN;

    if (SUCCEEDED(InitProp()))
    {
        m_pprop->GetProp(PID_IS_SCHEME, &dwScheme);
    }
    return dwScheme;
}


// IUniformResourceLocator::SetURL handler for Intshcut
//
// Note:
//    1. SetURL clears the IDList, so that when we launch this shortcut,
//        we will use the URL.

STDMETHODIMP
Intshcut::SetURL(
    IN LPCTSTR pszURL,      OPTIONAL
    IN DWORD   dwFlags)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(! pszURL ||
           IS_VALID_STRING_PTR(pszURL, -1));
    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_IURL_SETURL_FLAGS));

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        hres = m_pprop->SetURLProp(pszURL, dwFlags);
        if (SUCCEEDED(hres))
        {
            // if the path was set successfully, clear the pidl.
            m_pprop->SetIDListProp(NULL);
        }
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: IUniformResourceLocatorA::SetURL handler for Intshcut

         Ansi version

*/
STDMETHODIMP
Intshcut::SetURL(
    IN LPCSTR pcszURL,      OPTIONAL
    IN DWORD  dwInFlags)
{
    if ( !pcszURL )
    {
        return SetURL((LPCTSTR)NULL, dwInFlags);
    }
    else
    {
        WCHAR wszURL[MAX_URL_STRING];

        ASSERT(IS_VALID_STRING_PTRA(pcszURL, -1));

        AnsiToUnicode(pcszURL, wszURL, SIZECHARS(wszURL));

        return SetURL(wszURL, dwInFlags);
    }
}


STDMETHODIMP Intshcut::GetURLW(WCHAR **ppwsz)
{
    LPTSTR  pszURL;
    HRESULT hres = GetURL(&pszURL);
    if (S_OK == hres)
    {
        hres = SHStrDup(pszURL, ppwsz);
        SHFree(pszURL);
    }
    else
        hres = E_FAIL;  // map S_FALSE to FAILED()
    return hres;
}

// IUniformResourceLocator::GetURL handler for Intshcut

STDMETHODIMP Intshcut::GetURL(LPTSTR * ppszURL)
{
    HRESULT hres;
    TCHAR szURL[MAX_URL_STRING];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_PTR(ppszURL, PTSTR));

    *ppszURL = NULL;

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        hres = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        if (S_OK == hres)
        {
            // (+ 1) for null terminator.
            int cch = lstrlen(szURL) + 1;
            *ppszURL = (PTSTR)SHAlloc(CbFromCch(cch));
            if (*ppszURL)
                StrCpyN(*ppszURL, szURL, cch);
            else
                hres = E_OUTOFMEMORY;
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT((hres == S_OK &&
            IS_VALID_STRING_PTR(*ppszURL, -1)) ||
           ((hres == S_FALSE ||
             hres == E_OUTOFMEMORY) &&
            ! *ppszURL));

    return hres;
}



/*----------------------------------------------------------
Purpose: IUniformResourceLocatorA::GetURL handler for Intshcut

         Ansi version

*/
STDMETHODIMP Intshcut::GetURL(LPSTR * ppszURL)
{
    HRESULT hres;
    TCHAR szURL[MAX_URL_STRING];

    ASSERT(IS_VALID_WRITE_PTR(ppszURL, PSTR));

    *ppszURL = NULL;

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        hres = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));

        if (S_OK == hres)
        {
            DWORD cch = WideCharToMultiByte(CP_ACP, 0, szURL, -1, NULL, 0, NULL, NULL);
            *ppszURL = (LPSTR)SHAlloc(CbFromCchA(cch + 1));

            if (*ppszURL)
                UnicodeToAnsi(szURL, *ppszURL, cch);
            else
                hres = E_OUTOFMEMORY;
        }
    }

    return hres;
}


HRESULT HandlePluggableProtocol(LPCTSTR pszURL, LPCTSTR pszProtocol)
{
    HRESULT hres = E_UNEXPECTED;
    HKEY hkey;
    TraceMsg(DM_PLUGGABLE, "HandlePluggableProtocol called");

    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("PROTOCOLS\\Handler"), &hkey) == ERROR_SUCCESS) {
        HKEY hkeyProtocol;
        if (RegOpenKey(hkey, pszProtocol, &hkeyProtocol) == ERROR_SUCCESS) {
            TraceMsg(DM_PLUGGABLE, "HandlePluggableProtocol found %s", pszProtocol);
            IUnknown* punk = NULL; // CreateTargetFrame's ppunk is [IN][OUT]
            hres = CreateTargetFrame(NULL, &punk);
            if (SUCCEEDED(hres)) {
                IWebBrowser2* pauto;
                hres = punk->QueryInterface(IID_IWebBrowser2, (LPVOID*)&pauto);
                if (SUCCEEDED(hres))
                {
                    TraceMsg(DM_PLUGGABLE, "HandlePluggableProtocol calling navigate with %s", pszURL);

                    LBSTR::CString          strUrl;

                    LPTSTR          pstrUrl = strUrl.GetBuffer( MAX_URL_STRING );

                    if ( strUrl.GetAllocLength() < MAX_URL_STRING )
                    {
                        TraceMsg( TF_WARNING, "HandlePluggableProtocol() - strUrl Allocation Failed!" );

                        strUrl.Empty();
                    }
                    else
                    {
                        SHTCharToUnicode( pszURL, pstrUrl, MAX_URL_STRING );

                        // Let CString class own the buffer again.
                        strUrl.ReleaseBuffer();
                    }

                    pauto->Navigate( strUrl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY );
                    pauto->put_Visible(TRUE);
                    pauto->Release();
                }
                punk->Release();
            }
            RegCloseKey(hkeyProtocol);
        } else {
            TraceMsg(DM_WARNING, "HandlePluggableProtocol can't find %s", pszProtocol);
        }
        RegCloseKey(hkey);
    } else {
        ASSERT(0);
    }
    return hres;
}

HRESULT _IEExecFile_TryRunningWindow(VARIANT *pvarIn, DWORD cid)
{
    HRESULT hr = E_FAIL;
    ASSERT(pvarIn);

    IShellWindows *psw = WinList_GetShellWindows(TRUE);
    if (psw)
    {
        IUnknown *punk;
        if (SUCCEEDED(psw->_NewEnum(&punk)))
        {
            VARIANT var = {0};
            IEnumVARIANT *penum;

            //
            //  its too bad _NewEnum doesnt return an penum....
            //  this should never fail.
            //
            punk->QueryInterface(IID_PPV_ARG(IEnumVARIANT, &penum));
            ASSERT(penum);

            //
            //  this can be super spendy since every one of these
            //  items is marshalled.
            //
            //  should we clone the stream here??
            //
            while (FAILED(hr) && S_OK == penum->Next(1, &var, NULL))
            {
                ASSERT(var.vt == VT_DISPATCH);
                ASSERT(var.pdispVal);
                IOleCommandTarget *poct;
                
                if (SUCCEEDED(var.pdispVal->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poct))))
                {
                    CoAllowSetForegroundWindow(poct, NULL);
                    
                    hr = poct->Exec(&CGID_Explorer, cid, 0, pvarIn, NULL);

                    poct->Release();
                }
                
                //  this should release the pdisp
                VariantClear(&var);
            }

            punk->Release();
            penum->Release();
        }
        
        psw->Release();
    }


    TraceMsgW(DM_SHELLEXECOBJECT, "IEExecFile_Running returns 0x%X", hr);
    return hr;
}

BOOL IsIESchemeHandler(LPTSTR pszVerb, LPTSTR pszScheme)
{
    //  if we fail to get any value at all, the we must assume that it
    //  is some protocol like about: or res: that is not in the registry
    //  so we default to success.
    BOOL fRet = FALSE;
    TCHAR szExe[MAX_PATH];

    if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_EXECUTABLE, pszScheme, pszVerb, szExe, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szExe)))))
    {
        //  if we find something and it aint us, then fail.
        if ((StrStrI(szExe, TEXT("iexplore.exe")) || StrStrI(szExe, TEXT("explorer.exe"))))
        {
            fRet = TRUE;

            TraceMsg(DM_SHELLEXECOBJECT, "IsIEScheme() found %s", szExe);
        }
    }
    else
    {
        // these are unregistered schemes, we are the only ones that 
        //  should ever even use the unregistered schemes like
        //  res: or shell: so return TRUE here too.
        fRet = *pszScheme && *pszScheme != TEXT('.');
    }
    
    TraceMsg(DM_SHELLEXECOBJECT, "IsIEScheme() returns %d for %s", fRet, pszScheme);
    return fRet;
}    

HRESULT IEExecFile(LPTSTR pszVerb, LPTSTR pszScheme, DWORD cid, LPTSTR pszPath)
{
    HRESULT hr = E_FAIL;
    ASSERT(pszVerb);
    ASSERT(pszScheme);
    ASSERT(pszPath);
    
    if (IsIESchemeHandler(pszVerb, pszScheme))
    {
        VARIANT varIn = {0};
        varIn.vt = VT_BSTR;

        SHSTRW str;
        str.SetStr(pszPath);
        varIn.bstrVal = SysAllocString(str.GetStr());
        if (varIn.bstrVal)
        {
            if (!SHRegGetBoolUSValue(REGSTR_PATH_MAIN, TEXT("AllowWindowReuse"), FALSE, TRUE)
            || FAILED(hr = _IEExecFile_TryRunningWindow(&varIn, cid)))
            {
                IOleCommandTarget *poct;
    
                if (SUCCEEDED(CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_ALL, 
                        IID_PPV_ARG(IOleCommandTarget, &poct))))
                {
                    hr = poct->Exec(&CGID_Explorer, cid, 0, &varIn, NULL);
                    poct->Release();
                }
            }

            SysFreeString(varIn.bstrVal);
        }

    }

    TraceMsg(DM_SHELLEXECOBJECT, "IEExecFile returns 0x%X for %s", hr, pszPath);

    return hr;
}
                
            
/*----------------------------------------------------------
Purpose: IUniformResourceLocator::InvokeCommand for Intshcut

Note:
    1. If the internet shortcut comes with a pidl, use it to ShellExec,
        otherwise use the URL.

*/
STDMETHODIMP Intshcut::InvokeCommand(PURLINVOKECOMMANDINFO purlici)
{
    HRESULT hr = E_INVALIDARG;
    BOOL bExecFailedWhine = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRUCT_PTR(purlici, CURLINVOKECOMMANDINFO));

    if (purlici && EVAL(SIZEOF(*purlici) == purlici->dwcbSize))
    {
        //
        // App compat.  Don't use stack space for the URL.  We use up 16-bit app
        // stack space when we they shell exec urls.
        //

        LPWSTR pszURL = (LPWSTR)LocalAlloc(LPTR, MAX_URL_STRING * sizeof(WCHAR));

        if (pszURL)
        {
            hr = InitProp();
            if (SUCCEEDED(hr))
            {
                //
                // App Compat: Don't use up stack space.
                //

                LPWSTR pszT = (LPWSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));

                if (pszT)
                {
                    SHELLEXECUTEINFO sei = {0};
                    LPITEMIDLIST pidl = NULL;
                    LPTSTR pszProtocol = NULL;
                    PARSEDURL pu;
                    pu.nScheme = 0; // init to avoid bogus C4701 warning

                    sei.fMask = SEE_MASK_NO_HOOKS;


                    // check if we have a pidl for the target.        
                    hr = GetIDListInternal(&pidl);
                    if ((hr == S_OK) && pidl)
                    {
                        // yse, use the pidl to ShellExec.
                        sei.fMask |= SEE_MASK_INVOKEIDLIST;
                        sei.lpIDList = pidl;
                    }
                    else
                    {
                        // no, get the URL and invoke class handler.
                        hr = InitProp();
                        if (SUCCEEDED(hr))
                        {
                            hr = m_pprop->GetProp(PID_IS_URL, pszURL, MAX_URL_STRING);
                        }
                        if (S_OK == hr)
                        {
                            hr = CopyURLProtocol(pszURL, &pszProtocol, &pu);
               
                            if (hr == S_OK)
                            {
                                hr = IsProtocolRegistered(pszProtocol);
               
                                if (hr == URL_E_UNREGISTERED_PROTOCOL &&
                                    IsFlagSet(purlici->dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI))
                                {
                                    TraceMsg(TF_INTSHCUT, "Intshcut::InvokeCommand(): Unregistered URL protocol %s.  Invoking URL protocol handler association dialog.",
                                               pszProtocol);
               
                                    hr = RegisterProtocolHandler(purlici->hwndParent, pszT,
                                                                 MAX_PATH);
                                    if (FAILED(hr))
                                        hr = URL_E_UNREGISTERED_PROTOCOL;
                                }

                                //
                                // I have no idea what this RegisterProtocolHandler
                                // does (it looks too complicated). I, however, know
                                // that we come here if the user type one of pluggable
                                // protocol. And RegisterProtocolHandler returns E_FAIL.
                                // (SatoNa)
                                //
                                if (FAILED(hr)) {
                                    if (SUCCEEDED(HandlePluggableProtocol(pszURL, pszProtocol))) {
                                        hr = S_OK;
                                        goto done;
                                    }
                                }

                                if (SUCCEEDED(hr))
                                {
                                    hr = ResultFromWin32(RegOpenKeyExW(HKEY_CLASSES_ROOT, pszProtocol, 0, KEY_READ, &sei.hkeyClass));
                                    sei.fMask |= SEE_MASK_CLASSKEY;
                                }
                            }
                        }
                    }
                
                    switch (hr)
                    {
                        case S_OK:
                        {
                            //
                            // App Compat: Don't use up stack space.
                            //

                            LPWSTR pszVerb = (LPWSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));

                            if (pszVerb)
                            {
                                int nShowCmd;
   
                                // Execute URL via registered protocol handler.
   
                                if (IsFlagClear(purlici->dwFlags,
                                                IURL_INVOKECOMMAND_FL_ALLOW_UI))
                                    SetFlag(sei.fMask, SEE_MASK_FLAG_NO_UI);

                                if (purlici->dwFlags & IURL_INVOKECOMMAND_FL_DDEWAIT)
                                    SetFlag(sei.fMask, SEE_MASK_FLAG_DDEWAIT);
                        
                                if (IsFlagClear(purlici->dwFlags,
                                                IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB))
                                {
                                    sei.lpVerb = purlici->pcszVerb;
                                }
                                else
                                {
                                    if (pszProtocol &&
                                        GetClassDefaultVerb(pszProtocol, pszVerb,
                                                            MAX_PATH))
                                        sei.lpVerb = pszVerb;
                                    else
                                        ASSERT(! sei.lpVerb);
                                }

                                ASSERT(m_pprop);
                                hr = InitProp();
                                if (SUCCEEDED(hr))
                                {
                                    m_pprop->GetProp(PID_IS_WORKINGDIR, pszT, MAX_PATH);
                                    m_pprop->GetProp(PID_IS_SHOWCMD, &nShowCmd); // inits to zero if not found
                                
                                    //  if we have a file try using a direct connection
                                    //  to the shell to give the whole shortcut
                                    if (m_pszFile && ((IsIEDefaultBrowser()) || (_IsInFavoritesFolder())))
                                    {
                                        LPTSTR pszType = pszProtocol;
                                        if (pu.nScheme == URL_SCHEME_FILE)
                                            pszType = PathFindExtension(pszURL);
                                            
                                        hr = IEExecFile(pszVerb, pszType, SBCMDID_IESHORTCUT, m_pszFile);
                                    }
                                    else 
                                        hr = E_FAIL;

                                    //  if we failed to pass it to IE, then we should just default 
                                    //  to the old behavior
                                    if (FAILED(hr))
                                    {

                                        sei.cbSize = SIZEOF(sei);
                                        sei.hwnd = purlici->hwndParent;
                                        sei.lpFile = pszURL;
                                        sei.lpDirectory = pszT;
                                        sei.nShow = nShowCmd ? nShowCmd : SW_NORMAL;
                                        // We have to special case "file:" URLs,
                                        // because Nashville's Explorer typically handles 
                                        // file: URLs via DDE, which fails for executables
                                        // (eg, "file://c:\windows\notepad.exe") and
                                        // non-hostable docs (like text files).
                                        //
                                        // So in this case, we remove the protocol class
                                        // and execute the suffix.

                                        // App Compat: Don't use up stack space.
                                        DWORD cchPath = MAX_PATH;
                                        LPWSTR  pszPath = (LPWSTR)LocalAlloc(LPTR, cchPath * sizeof(WCHAR));

                                        if (pszPath)
                                        {
                                            if (IsFlagSet(sei.fMask, SEE_MASK_CLASSKEY) &&
                                                (URL_SCHEME_FILE == pu.nScheme) &&
                                                SUCCEEDED(PathCreateFromUrl(pszURL, pszPath, &cchPath, 0)))
                                            {
                                                sei.hkeyClass = NULL;
                                                ClearFlag(sei.fMask, SEE_MASK_CLASSKEY);
                                                sei.lpFile = pszPath;
                                                
                                            }

                                            if (m_pszFile && IsOS(OS_WHISTLERORGREATER))
                                            {
                                                //  this is the security context
                                                //  so that shellexec() can do zone checks
                                                sei.lpClass = m_pszFile;
                                                sei.fMask |= SEE_MASK_HASTITLE | SEE_MASK_HASLINKNAME;
                                            }


                                            TraceMsg(TF_INTSHCUT, "Intshcut::InvokeCommand(): Invoking %s verb on URL %s.",
                                                       sei.lpVerb ? sei.lpVerb : TEXT("open"),
                                                       sei.lpFile);
           
                                            hr = ShellExecuteEx(&sei) ? S_OK : IS_E_EXEC_FAILED;

                                            LocalFree(pszPath);
                                            pszPath = NULL;
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                    }
                                }
                                if (hr != S_OK)
                                    TraceMsg(TF_WARNING, "Intshcut::InvokeCommand(): ShellExecuteEx() via registered protcol handler failed for %s.",
                                             pszURL);

                                LocalFree(pszVerb);
                                pszVerb = NULL;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
   
                            break;
                        }
   
                        case S_FALSE:
                            hr = MyExecute(pszT, pszURL, 0);
                            switch (hr)
                            {
                                case E_FAIL:
                                    bExecFailedWhine = TRUE;
                                    hr = IS_E_EXEC_FAILED;
                                    break;
   
                                default:
                                    break;
                            }
                            break;
   
                        default:
                            ASSERT(FAILED(hr));
                            break;
                    }

        done:
                    if (pszProtocol)
                    {
                        LocalFree(pszProtocol);
                        pszProtocol = NULL;
                    }
                
                    if (pidl)
                        ILFree(pidl);

                    if (sei.hkeyClass)
                        RegCloseKey(sei.hkeyClass);
                    
                    if (FAILED(hr) &&
                        IsFlagSet(purlici->dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI))
                    {
                        switch (hr)
                        {
                            case IS_E_EXEC_FAILED:
                                if (bExecFailedWhine)
                                {
                                    ASSERT(IS_VALID_STRING_PTR(pszT, -1));

                                    MLShellMessageBox(
                                                    purlici->hwndParent,
                                                    MAKEINTRESOURCE(IDS_IS_EXEC_FAILED),
                                                    MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                                    (MB_OK | MB_ICONEXCLAMATION),
                                                    pszT);
                                }
                                break;
            
                            case URL_E_INVALID_SYNTAX:
                                MLShellMessageBox(
                                                purlici->hwndParent,
                                                MAKEINTRESOURCE(IDS_IS_EXEC_INVALID_SYNTAX),
                                                MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                                (MB_OK | MB_ICONEXCLAMATION),
                                                pszURL);
            
                                break;
            
                            case URL_E_UNREGISTERED_PROTOCOL:
                            {
                                LPTSTR pszProtocol;
            
                                if (CopyURLProtocol(pszURL, &pszProtocol, NULL) == S_OK)
                                {
                                    MLShellMessageBox(
                                                    purlici->hwndParent,
                                                    MAKEINTRESOURCE(IDS_IS_EXEC_UNREGISTERED_PROTOCOL),
                                                    MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                                    (MB_OK | MB_ICONEXCLAMATION),
                                                    pszProtocol);
            
                                    LocalFree(pszProtocol);
                                    pszProtocol = NULL;
                                }
            
                                break;
                            }
            
                            case E_OUTOFMEMORY:
                                MLShellMessageBox(
                                                purlici->hwndParent,
                                                MAKEINTRESOURCE(IDS_IS_EXEC_OUT_OF_MEMORY),
                                                MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                                (MB_OK | MB_ICONEXCLAMATION));
                                break;
            
                            default:
                                ASSERT(hr == E_ABORT);
                                break;
                        }
                    }

                    LocalFree(pszT);
                    pszT = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

           LocalFree(pszURL);
           pszURL = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(hr == S_OK ||
           hr == E_ABORT ||
           hr == E_OUTOFMEMORY ||
           hr == URL_E_INVALID_SYNTAX ||
           hr == URL_E_UNREGISTERED_PROTOCOL ||
           hr == IS_E_EXEC_FAILED ||
           hr == E_INVALIDARG);
    
    return(hr);
}



/*----------------------------------------------------------
Purpose: IUniformResourceLocatorA::InvokeCommand for Intshcut

         Ansi version

*/
STDMETHODIMP
Intshcut::InvokeCommand(
    IN PURLINVOKECOMMANDINFOA purlici)

{
    HRESULT hres = E_INVALIDARG;

    ASSERT(purlici);
    ASSERT(SIZEOF(*purlici) == purlici->dwcbSize);

    if (SIZEOF(*purlici) == purlici->dwcbSize)
    {
        URLINVOKECOMMANDINFOW ici;

        ici.dwcbSize = SIZEOF(ici);
        ici.dwFlags  = purlici->dwFlags;
        ici.hwndParent = purlici->hwndParent;

        ici.pcszVerb = NULL;

        if (purlici->pcszVerb)
        {
            //
            // App compat hack.
            //
            // Note: use local alloc here instead of the stack since 16-bit code
            // can shell exec urls and we don't want to use up their stack.
            //

            int cch = lstrlenA(purlici->pcszVerb) + 1;

            ici.pcszVerb = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));

            if (ici.pcszVerb)
            {
                AnsiToUnicode(purlici->pcszVerb, (LPWSTR)ici.pcszVerb, cch);
            }
        }

        hres = InvokeCommand(&ici);

        if (ici.pcszVerb)
        {
            LocalFree((void*)ici.pcszVerb);
            ici.pcszVerb = NULL;
        }
    }

    return hres;
}



STDMETHODIMP Intshcut::Create(REFFMTID fmtid, const CLSID *pclsid,
                              DWORD grfFlags, DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = NULL;
    return E_NOTIMPL;
}


STDMETHODIMP Intshcut::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage **pppropstg)
{
    HRESULT hres = E_FAIL;      // assume failure

    *pppropstg = NULL;

    if (IsEqualGUID(fmtid, FMTID_Intshcut))
    {
        // Create a URLProp object for this format ID
        hres = CIntshcutProp_CreateInstance(NULL, IID_PPV_ARG(IPropertyStorage, pppropstg));
        if (SUCCEEDED(hres))
        {
            // Initialize this object
            IntshcutProp * pisprop = (IntshcutProp *)*pppropstg;
            hres = pisprop->InitFromFile(m_pszFile);
        }
    }
    else if (IsEqualGUID(fmtid, FMTID_InternetSite))
    {
        // Create a URLProp object for this format ID
        hres = CIntsiteProp_CreateInstance(NULL, IID_PPV_ARG(IPropertyStorage, pppropstg));
        if (SUCCEEDED(hres))
        {
            hres = InitProp();
            if (SUCCEEDED(hres))
            {
                TCHAR szURL[MAX_URL_STRING];
                hres = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
                if (SUCCEEDED(hres))
                {
                    IntsiteProp * pisprop = (IntsiteProp *)*pppropstg;
                    hres = pisprop->InitFromDB(szURL, this, FALSE);
                }
            }

            if (FAILED(hres))
            {
                (*pppropstg)->Release();
                *pppropstg = NULL;
            }
        }
    }

    return hres;
}


STDMETHODIMP Intshcut::Delete(REFFMTID fmtid)
{
    return STG_E_ACCESSDENIED;
}


STDMETHODIMP Intshcut::Enum(OUT IEnumSTATPROPSETSTG ** ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

// get the required propery that indicates the item has been changed

STDAPI GetRecentlyChanged(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf)
{
    PROPVARIANT propvar;
    HRESULT hres = E_FAIL;  // assume not there
    PROPSPEC prspec = { PRSPEC_PROPID, propid };

    if (S_OK == ppropstg->ReadMultiple(1, &prspec, &propvar))
    {
        if ((VT_UI4 == propvar.vt) && (PIDISF_RECENTLYCHANGED & propvar.lVal))
            hres = S_FALSE;     // we've got it, skip this property

        PropVariantClear(&propvar);
    }
    return hres;
}

STDAPI GetStringPropURL(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf)
{
    HRESULT hres = GetStringProp(ppropstg, propid, pszBuf, cchBuf);
    if (SUCCEEDED(hres))
    {
        // get rid of the query string for display
        if (UrlIs(pszBuf, URLIS_HASQUERY))
            UrlCombine(pszBuf, TEXT("?..."), pszBuf, &cchBuf, 0);
    }
    return hres;
}

BOOL Intshcut::_TryLink(REFIID riid, void **ppvOut)
{
    HRESULT hr = InitProp();

    if (SUCCEEDED(hr) && URL_SCHEME_FILE == GetScheme())
    {
        // This shortcut is not in the favorites folder as far as we know 
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        DWORD cch = SIZECHARS(szURL);

        *szURL = 0;

        m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));

        if (*szURL && SUCCEEDED(PathCreateFromUrl(szURL, szURL, &cch, 0)))
        {
            if (!_punkLink)
            {
                hr = _CreateShellLink(szURL, &_punkLink);
            }

            if (_punkLink)
            {
                if (SUCCEEDED(_punkLink->QueryInterface(riid, ppvOut)))
                    return TRUE;
            }
        }

        if (FAILED(hr))
            ATOMICRELEASE(_punkLink);
    }

    return FALSE;
}

STDMETHODIMP Intshcut::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    HRESULT hr = E_FAIL;
    IQueryInfo *pqi;

    if (_TryLink(IID_PPV_ARG(IQueryInfo, &pqi)))
    {
        hr = pqi->GetInfoTip(dwFlags, ppwszTip);
        pqi->Release();
    }
    
    if (FAILED(hr))
    {
        static const ITEM_PROP c_rgTitleAndURL[] = {
            { &FMTID_InternetSite, PID_INTSITE_TITLE,   GetStringProp, IDS_FAV_STRING },
            { &FMTID_Intshcut, PID_IS_URL,              GetStringPropURL, IDS_FAV_STRING },
            { NULL, 0, 0, 0 },
        };

        hr = GetInfoTipFromStorage(SAFECAST(this, IPropertySetStorage *), c_rgTitleAndURL, ppwszTip);
    }

    return hr;

}

STDMETHODIMP Intshcut::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
#if 0    
// This Function is commented out since it has not been tested.
// It can be uncommented if we provide support for providing offline cursor
// for shortucts. I think this needs updates to listview in comctl -- BharatS
        
    LPSTR pszURL;
    if (S_OK == GetURL(&pszURL))
    {
        BOOL fCached = UrlIsCached(pszUrl);
        if (!fCached)
        {
            CHAR szCanonicalizedUrlA[MAX_URL_STRING];
            DWORD dwLen = ARRAYSIZE(szCanonicalizedUrlA);
            InternetCanonicalizeUrlA(pszURL, szCanonicalizedUrlA, &dwLen, 0);
            fCached = UrlIsMappedOrInCache(szCanonicalizedUrlA);
        }
        if (fCached)
            *pdwFlags |= QIF_CACHED;
        SHFree(pszURL);
    }
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}

/*----------------------------------------------------------
IQueryCodePage:
*/
STDMETHODIMP Intshcut::GetCodePage(UINT * puiCodePage)
{
    HRESULT hres = E_FAIL;
    *puiCodePage = 0;     // NULL out the code page. 
    if (IsFlagSet(m_dwFlags, ISF_CODEPAGE))
    {
        *puiCodePage = m_uiCodePage;
        hres = S_OK;
    }

    return hres;
}

STDMETHODIMP Intshcut::SetCodePage(UINT uiCodePage)
{
    SetFlag(m_dwFlags, ISF_CODEPAGE);
    m_uiCodePage = uiCodePage;
    return S_OK;
}

/***************************** Exported Functions ****************************/


// This function was ported from URL.DLL.  Normally, since our
// internet shortcut object has a context menu handler, we don't
// call this function.
//
// Only one thing needs this entry point: Exchange.  Sigh.
//
// Instead of simply calling ShellExecuteEx to handle opening file
// attachments, they grovel thru the registry themselves. Of course,
// their code is incomplete and thinks a file-association needs to
// have an explicit \shell\open\command that works before it executes
// it.  Hmm, it brings to mind a phrase, like:
//
// 
//
// So, we export this API so they will work.  But really the invoke
// occurs in the context menu handler for normal cases.
//


STDAPI_(void) OpenURL(HWND hwndParent, HINSTANCE hinst, LPSTR pszCmdLine, int nShowCmd)
{
   HRESULT hr;
   HRESULT hrCoInit;

   

   Intshcut * pIntshcut = new Intshcut;     // This must be a 0 INITed memory allocation
   WCHAR wszPath[MAX_PATH];

    if (!pIntshcut)
        return;

   hrCoInit = SHCoInitialize(); // gets called from rundll32 in browser only mode - hence we need to
                                // make sure that OLE has been init'ed

 

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
   ASSERT(IS_VALID_STRING_PTRA(pszCmdLine, -1));
   ASSERT(IsValidShowCmd(nShowCmd));

   // Assume the entire command line is an Internet Shortcut file path.

   TrimWhiteSpaceA(pszCmdLine);

   TraceMsgA(TF_INTSHCUT, "OpenURL(): Trying to open Internet Shortcut %s.",
              pszCmdLine);

#ifndef UNIX

   AnsiToUnicode(pszCmdLine, wszPath, SIZECHARS(wszPath));
   hr = pIntshcut->LoadFromFile(wszPath);

#else /* UNIX */

#ifndef ANSI_SHELL32_ON_UNIX
   // IEUNIX : Our Shell32 calls this function with unicode command line
   hr = pIntshcut->LoadFromFile((LPWSTR)pszCmdLine);
#else
   hr = pIntshcut->LoadFromFile(pszCmdLine);
#endif

#endif /* !UNIX */

   if (hr == S_OK)
   {
      URLINVOKECOMMANDINFO urlici;

      urlici.dwcbSize = SIZEOF(urlici);
      urlici.hwndParent = hwndParent;
      urlici.pcszVerb = NULL;
      urlici.dwFlags = (IURL_INVOKECOMMAND_FL_ALLOW_UI |
                        IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB);

      hr = pIntshcut->InvokeCommand(&urlici);
   }

   if (hr != S_OK)
   {
      MLShellMessageBox(
                      hwndParent,
                      MAKEINTRESOURCE(IDS_IS_LOADFROMFILE_FAILED),
                      MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                      (MB_OK | MB_ICONEXCLAMATION),
                      wszPath);
   }

   pIntshcut->Release();

   SHCoUninitialize(hrCoInit);

}

// INamedPropertyBag Methods
//
// Reads & writes properties from a section in the shortcut ini file


const TCHAR  c_szSizeSuffix[] = TEXT("__Size");


STDMETHODIMP Intshcut::WritePropertyNPB(
                                       LPCOLESTR pszSectionNameW, 
                            /* [in] */ LPCOLESTR pszPropNameW, 
                       /* [out][in] */ PROPVARIANT  *pVar)
{
    const TCHAR *pszSectionName;
    const TCHAR *pszPropName;
    HRESULT hr;
    if((NULL == pszSectionNameW) || (NULL == pszPropNameW) || (NULL == pVar))
    {
        return E_FAIL;
    }


    if(S_OK != _CreateTemporaryBackingFile())
    {
        ASSERT(NULL == m_pszTempFileName);
        return E_FAIL;
    }


    ASSERT(m_pszTempFileName);
    
    pszSectionName = pszSectionNameW;
    pszPropName = pszPropNameW;
    // Write the appropriate value in depending on the type

    switch(pVar->vt)
    {
        // NOTE: (andrewgu) these types we also can round-trip using the same code pass as for
        // unsigned types, except bharats in a codereview recommended we comment these out because
        // they'll look goofy in the *.ini file (you wrote -5 but see 4294967290 junk instead).
        // VT_UINT is not listed as "may appear in an OLE property set" in <wtypes.h>.
     /* case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_INT:
        case VT_UINT: */

        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
            hr = WriteUnsignedToFile(m_pszTempFileName, pszSectionName, pszPropName, pVar->ulVal);
            break;

        case VT_BSTR:
            hr = WriteGenericString(m_pszTempFileName, pszSectionName, pszPropName, pVar->bstrVal);
            break;

        case VT_BLOB:
            {
                TCHAR *pszSizePropName = NULL;
                int  cchPropName = lstrlen(pszPropName) + ARRAYSIZE(c_szSizeSuffix) + 1;
                DWORD dwAllocSize = cchPropName * sizeof(TCHAR);
                
                pszSizePropName = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, dwAllocSize);
                if(pszSizePropName)
                {
                    DWORD dwBufferSize;
                    StrCpyN(pszSizePropName, pszPropName, cchPropName);
                    StrCatBuff(pszSizePropName, c_szSizeSuffix, cchPropName);

                    // OK Now - we have the name for the size
                    // we write it out

                    dwBufferSize = pVar->blob.cbSize;
                    hr = WriteBinaryToFile(m_pszTempFileName, pszSectionName, pszSizePropName, 
                                                (LPVOID)(&dwBufferSize), sizeof(DWORD));

                    if(S_OK == hr)
                    {
                        // Write out the buffer
                        hr = WriteBinaryToFile(m_pszTempFileName, pszSectionName, pszPropName, 
                                                (LPVOID)(pVar->blob.pBlobData), dwBufferSize);
                    }

                    LocalFree((LPVOID)pszSizePropName);
                    pszSizePropName = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                
                break;
            }
        default:
            hr = WriteBinaryToFile(m_pszTempFileName, pszSectionName, pszPropName, (LPVOID)pVar, sizeof(PROPVARIANT));
            break;
    }

   
    return hr;
}

STDMETHODIMP Intshcut::ReadPropertyNPB(
                       /* [in] */ LPCOLESTR pszSectionNameW,
                       /* [in] */ LPCOLESTR pszPropNameW,
                       /* [out][in] */ PROPVARIANT  *pVar)
{
    const TCHAR *pszSectionName;
    const TCHAR *pszPropName;
    TCHAR       *pszFileToReadFrom;
    HRESULT hr;

    if((NULL == pszSectionNameW) || (NULL == pszPropNameW) || (NULL == pVar))
    {
        if (NULL != pVar)
            pVar->vt = VT_ERROR;

        return E_FAIL;
    }


    if(m_pszTempFileName)
    {
        pszFileToReadFrom = m_pszTempFileName;
    } 
    else if(m_pszFile)
    {
        pszFileToReadFrom = m_pszFile;
    }
    else
    {
        pVar->vt = VT_EMPTY;
        return S_FALSE;
    }

    pszSectionName = pszSectionNameW;
    pszPropName = pszPropNameW;

    switch(pVar->vt)
    {
        // NOTE: (andrewgu) these types we also can round-trip using the same code pass as for
        // unsigned types, except bharats in a codereview recommended we comment these out because
        // they'll look goofy in the *.ini file (you wrote -5 but see 4294967290 junk instead).
        // VT_UINT is not listed as "may appear in an OLE property set" in <wtypes.h>.
     /* case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_INT:
        case VT_UINT: */

        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
            pVar->ulVal = 0;
            hr          = ReadUnsignedFromFile(pszFileToReadFrom, pszSectionName, pszPropName, &(pVar->ulVal));
            break;

        case VT_BSTR:   
             // It is a string
           pVar->vt = VT_BSTR;
           pVar->bstrVal = NULL;
           hr = ReadBStrFromFile(pszFileToReadFrom, pszSectionName, pszPropName, &(pVar->bstrVal));            
           break;

        case VT_BLOB:
            {
                TCHAR *pszSizePropName = NULL;
                int  cchPropName = lstrlen(pszPropName) + ARRAYSIZE(c_szSizeSuffix) + 1;
                DWORD dwAllocSize = cchPropName * sizeof(TCHAR);
                
                pszSizePropName = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, dwAllocSize);
                if(pszSizePropName)
                {
                    DWORD dwBufferSize;
                    StrCpyN(pszSizePropName, pszPropName, cchPropName);
                    StrCatBuff(pszSizePropName, c_szSizeSuffix, cchPropName);
                    // Read the Size first
                    hr = ReadBinaryFromFile(pszFileToReadFrom, pszSectionName, pszSizePropName, 
                                            &dwBufferSize, sizeof(DWORD));
                    if(S_OK == hr)
                    {
                        
                        pVar->blob.pBlobData = (unsigned char *)CoTaskMemAlloc(dwBufferSize);
                        if(pVar->blob.pBlobData)
                        {
                            hr = ReadBinaryFromFile(pszFileToReadFrom, pszSectionName, pszPropName, 
                                            pVar->blob.pBlobData, dwBufferSize);

                            if(S_OK == hr)
                            {
                                pVar->blob.cbSize = dwBufferSize;
                            }
                            else
                            {
                                CoTaskMemFree(pVar->blob.pBlobData);
                            }
                        }
                    }

                    LocalFree(pszSizePropName);
                    pszSizePropName = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

               break;
            }
        default:
            {
                // all else
                PROPVARIANT tmpPropvar = {0};
                
                hr = ReadBinaryFromFile(pszFileToReadFrom, pszSectionName, pszPropName, &tmpPropvar, sizeof(PROPVARIANT));
                if((S_OK == hr) && (tmpPropvar.vt == pVar->vt))
                {
                    memcpy(pVar, &tmpPropvar, sizeof(PROPVARIANT));
                }
                else
                {
                    pVar->vt = VT_ERROR;
                }
                break;
            }

    }

   if(hr != S_OK)
   {
        memset(pVar, 0, sizeof(PROPVARIANT));
        pVar->vt = VT_EMPTY;
   }   

   return hr;
}

STDMETHODIMP Intshcut::RemovePropertyNPB (
                            /* [in] */ LPCOLESTR pszSectionNameW,
                            /* [in] */ LPCOLESTR pszPropNameW)
{
    const TCHAR *pszSectionName;
    const TCHAR *pszPropName;
    HRESULT hr;
    TCHAR *pszFileToDeleteFrom;

    // Return if there is no file name
    if((NULL == pszSectionNameW) || (NULL == pszPropNameW)) 
    {
        return E_FAIL;
    }

     if(m_pszTempFileName)
     {
        pszFileToDeleteFrom = m_pszTempFileName;
     }
     else if(m_pszFile)
     {
        pszFileToDeleteFrom = m_pszFile;
     }
     else
     {
        return E_FAIL;
     }
     
    
    // Just delete the key corresponding to this property name
    pszSectionName = pszSectionNameW;
    pszPropName = pszPropNameW;

    hr = SHDeleteIniString(pszSectionName, pszPropName, pszFileToDeleteFrom)? S_OK : E_FAIL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\multimon.cpp ===
#include "priv.h"
//=============================================================================
//
// This function defines the MULTIMON stub module that fakes multiple monitor 
// apis on pre Memphis Win32 OSes
// this is the only file that defines COMPILE_MULTIMON_STUBS 
//=============================================================================

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\mime64.h ===
// Are there such things as UNICODE MIME64 files?  That would be very inefficient
#define LPMSTR LPSTR
#define LPCMSTR LPCSTR
#define MCHAR char

HRESULT Mime64Decode(LPCMSTR pStrData, LPSTREAM *ppstm);
HRESULT Mime64Encode(LPBYTE pData, UINT cbData, LPSTREAM *ppstm);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\mime64.cpp ===
/* mime64 */
/* MIME base64 encoder/decoder by Karl Hahn  hahn@lds.loral.com  3-Aug-94 */
/* Modified into an API by georgep@microsoft.com 8-Jan-96 */

#include "priv.h"

#include "mime64.h"

#define INVALID_CHAR (ULONG)-2
#define IGNORE_CHAR (ULONG)-1

extern "C" void DllAddRef();
extern "C" void DllRelease();

class CRefDll
{
public:
    CRefDll() {DllAddRef();}
    ~CRefDll() {DllRelease();}
} ;


HRESULT CopyTo(IStream* pstmIn, 
    /* [unique][in] */ IStream *pstm,
    /* [in] */ ULARGE_INTEGER cb,
    /* [out] */ ULARGE_INTEGER *pcbRead,
    /* [out] */ ULARGE_INTEGER *pcbWritten)
{
    if (cb.HighPart != 0)
        return E_INVALIDARG;

    DWORD dwBytes = cb.LowPart;
    DWORD dwStep = dwBytes;
    if (dwStep >= 0x8000)
        dwStep = 0x8000;

    LPVOID pv = GlobalAlloc(GPTR, dwStep);
    if (!pv)
        return E_OUTOFMEMORY;

    DWORD dwTotRead = 0;
    DWORD dwTotWrite = 0;
    HRESULT hres = NOERROR;

    for (dwBytes; dwBytes!=0; )
    {
        DWORD dwThisRead = dwStep;
        if (dwThisRead > dwBytes)
        {
            dwThisRead = dwBytes;
        }

        if (NOERROR!=pstmIn->Read(pv, dwThisRead, &dwThisRead) || !dwThisRead)
        {
            // Must be the end of the file
            break;
        }
        dwTotRead += dwThisRead;

        DWORD dwWrite;
        hres = pstm->Write(pv, dwThisRead, &dwWrite);
        if (FAILED(hres))
        {
            break;
        }
        dwTotWrite += dwWrite;

        if (dwWrite != dwThisRead)
        {
            hres = E_UNEXPECTED;
            break;
        }

        dwBytes -= dwThisRead;
    }

    GlobalFree(pv);
    pv = NULL;

    if (pcbRead)
    {
        pcbRead->HighPart = 0;
        pcbRead->LowPart = dwTotRead;
    }

    if (pcbWritten)
    {
        pcbWritten->HighPart = 0;
        pcbWritten->LowPart = dwTotWrite;
    }

    return(hres);
}

#undef new  // Hack! need to resolve this (edwardp)

class CStreamMem : public IStream
{
private:
    CStreamMem(UINT cbSize) : m_cbSize(cbSize), m_cRef(1), m_cbPos(0) {}
    void* operator new(size_t cbClass, UINT cbSize)
    {
        return(::operator new(cbClass + cbSize - 1));
    }


public:
    static CStreamMem *Construct(UINT cbSize)
    {
        return(new(cbSize) CStreamMem(cbSize));
    }

    LPVOID GetPtr() { return(m_vData); }
    void SetSize(UINT cbSize) { m_cbSize = cbSize; }

    // IUnknown
        virtual STDMETHODIMP QueryInterface( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return(++m_cRef); }
        
        virtual STDMETHODIMP_(ULONG) Release(void);

    // IStream
        virtual STDMETHODIMP Read( 
            /* [out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        virtual STDMETHODIMP Write( 
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten)
        { return(E_NOTIMPL); }
        
        virtual STDMETHODIMP Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        virtual STDMETHODIMP SetSize( 
            /* [in] */ ULARGE_INTEGER libNewSize)
        { return(E_NOTIMPL); }
        
        virtual STDMETHODIMP CopyTo( 
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten)
        { return (::CopyTo(this, pstm, cb, pcbRead, pcbWritten)); }
        
        virtual STDMETHODIMP Commit( 
            /* [in] */ DWORD grfCommitFlags)
        { return(E_NOTIMPL); }
        
        virtual STDMETHODIMP Revert( void)
        { return(E_NOTIMPL); }
        
        virtual STDMETHODIMP LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
        { return(E_NOTIMPL); }
        
        virtual STDMETHODIMP UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
        { return(E_NOTIMPL); }
        
        virtual STDMETHODIMP Stat( 
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag)
        { return(E_NOTIMPL); }
        
        virtual STDMETHODIMP Clone( 
            /* [out] */ IStream **ppstm)
        { return(E_NOTIMPL); }

private:
    CRefDll m_cRefDll;

    ULONG m_cRef;

    UINT m_cbSize;
    UINT m_cbPos;

    // Must be the last field in the class
    BYTE m_vData[1];
} ;

STDMETHODIMP CStreamMem::QueryInterface( 
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObject)
{
    if (riid==IID_IUnknown || riid==IID_IStream)
    {
        AddRef();
        *ppvObject = (LPVOID)(IStream*)this;
        return(NOERROR);
    }

    *ppvObject = NULL;
    return(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CStreamMem::Release( void)
{
    --m_cRef;
    if (!m_cRef)
    {
        delete this;
        return(0);
    }

    return(m_cRef);
}


// IStream
STDMETHODIMP CStreamMem::Read( 
    /* [out] */ void *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG *pcbRead)
{
    if (pcbRead)
    {
        *pcbRead = 0;
    }

    if (m_cbPos >= m_cbSize)
    {
        return(S_FALSE);
    }

    ULONG cbRest = m_cbSize - m_cbPos;
    if (cb > cbRest)
    {
        cb = cbRest;
    }

    CopyMemory(pv, m_vData + m_cbPos, cb);
    m_cbPos += cb;

    if (pcbRead)
    {
        *pcbRead = cb;
    }

    return(S_OK);
}


STDMETHODIMP CStreamMem::Seek( 
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER *plibNewPosition)
{
    LONG lOffset = (LONG)dlibMove.LowPart;

    // Make sure we are only using 32 bits
    if (dlibMove.HighPart==0 && lOffset>=0)
    {
    }
    else if (dlibMove.HighPart==-1 && lOffset<0)
    {
    }
    else
    {
        return(E_INVALIDARG);
    }

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        break;

    case STREAM_SEEK_CUR:
        lOffset = (LONG)m_cbPos + lOffset;
        break;

    case STREAM_SEEK_END:
        lOffset = (LONG)m_cbSize + lOffset;
        break;

    default:
        return(E_INVALIDARG);
    }

    // Check the new offset is in range (NOTE: it is valid to seek past "end of file")
    if (lOffset < 0)
    {
        return(E_INVALIDARG);
    }

    // Store the new offset and return it
    m_cbPos = (ULONG)lOffset;

    if (plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart = m_cbPos;
    }

    return(S_OK);
}


ULONG _BinaryFromASCII2( unsigned char alpha )
{
    switch (alpha)
    {
    case ' ':
    case '\t':
    case '\n':
    case '\r':
        return(IGNORE_CHAR);

    default:
        if      ( (alpha >= 'A') && (alpha <= 'Z') )
        {
            return (int)(alpha - 'A');
        }
        else if ( (alpha >= 'a') && (alpha <= 'z') )
        {
            return 26 + (int)(alpha - 'a');
        }
        else if ( (alpha >= '0') && (alpha <= '9' ) )
        {
            return 52 + (int)(alpha - '0');
        }

        return(INVALID_CHAR);

    case '+':
        return 62;

    case '/':
        return 63;
    }
}

#if 0
struct _BinASCIIData
{
    BOOL m_bInited;
    ULONG m_anBinary[256];
} g_cBinASCIIData = { FALSE } ;

void _InitTables()
{
    if (g_cBinASCIIData.m_bInited)
    {
        return;
    }

    for (int i=0; i<256; ++i)
    {
        // Note this is thread-safe, since we always set to the same value
        g_cBinASCIIData.m_anBinary[i] = _BinaryFromASCII2((unsigned char)i);
    }

    // Set after initing other values to make thread-safe
    g_cBinASCIIData.m_bInited = TRUE;
}


inline ULONG _BinaryFromASCII( unsigned char alpha )
{
    return(g_cBinASCIIData.m_anBinary[alpha]);
}


HRESULT Mime64Decode(LPCMSTR pStrData, IStream **ppstm)
{
    *ppstm = NULL;

    _InitTables();

    // Waste some bytes so I don't have to worry about overflow
    CStreamMem *pstm = CStreamMem::Construct((lstrlen(pStrData)*3)/4 + 2);
    if (!pstm)
    {
        return(E_OUTOFMEMORY);
    }

    LPBYTE pData = (LPBYTE)pstm->GetPtr();
    int cbData = 0;

    int shift = 0;
    unsigned long accum = 0;

    BOOL quit = FALSE;

    // This loop will ignore white space, but quit at any other invalid characters
    for ( ; ; ++pStrData)
    {
        unsigned long value = _BinaryFromASCII(*pStrData);

        if ( value < 64 )
        {
            accum <<= 6;
            shift += 6;
            accum |= value;

            if ( shift >= 8 )
            {
                shift -= 8;
                value = accum >> shift;
                pData[cbData++] = (BYTE)value & 0xFF;
            }
        }
        else if (IGNORE_CHAR == value)
        {
            continue;
        }
        else
        {
            break;
        }
    }

    pstm->SetSize(cbData);
    *ppstm = pstm;

    return(NOERROR);
}
#endif

#define CHARS_PER_LINE 60


class COutputChars
{
public:
    COutputChars(LPMSTR pStrData) : m_pStrData(pStrData), m_cbLine(0) {}
    void AddChar(MCHAR cAdd)
    {
        *m_pStrData++ = cAdd;
        if (++m_cbLine == CHARS_PER_LINE)
        {
            *m_pStrData++ = '\n';
            m_cbLine = 0;
        }
    }
    LPMSTR GetPtr() { return(m_pStrData); }

private:
    LPMSTR m_pStrData;
    UINT m_cbLine;
} ;


HRESULT Mime64Encode(LPBYTE pData, UINT cbData, IStream **ppstm)
{
    static char const alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
                      "0123456789+/";

    *ppstm = NULL;

    // Waste some bytes so I don't have to worry about overflow
    // The 81/80 is to add a '\n' at the end of every 80 characters
    CStreamMem *pstm = CStreamMem::Construct((((cbData*4)/3 + 4)
        *(CHARS_PER_LINE+1)/CHARS_PER_LINE+2)*sizeof(MCHAR));
    if (!pstm)
    {
        return(E_OUTOFMEMORY);
    }

    COutputChars cStrData((LPMSTR)pstm->GetPtr());
    LPMSTR pSaveData = cStrData.GetPtr();

    int shift = 0;
    int save_shift = 0;
    unsigned long accum = 0;
    int index = 0;
    unsigned char blivit;
    unsigned long value;
    BOOL quit = FALSE;

    while ( ( cbData ) || (shift != 0) )
    {
        if ( ( cbData ) && ( quit == FALSE ) )
        {
            blivit = *pData++;
            --cbData;
        }
        else
        {
            quit = TRUE;
            save_shift = shift;
            blivit = 0;
        }

        if ( (quit == FALSE) || (shift != 0) )
        {
            value = (unsigned long)blivit;
            accum <<= 8;
            shift += 8;
            accum |= value;
        } /* ENDIF */

        while ( shift >= 6 )
        {
            shift -= 6;
            value = (accum >> shift) & 0x3Fl;
            blivit = alphabet[value];

            cStrData.AddChar(blivit);

            if ( quit != FALSE )
            {
                shift = 0;
            }
        }
    }

    if ( save_shift == 2 )
    {
        cStrData.AddChar('=');
        cStrData.AddChar('=');
    }
    else if ( save_shift == 4 )
    {
        cStrData.AddChar('=');
    }

    cStrData.AddChar('\n');
    cStrData.AddChar('\0');

    pstm->SetSize((int)(cStrData.GetPtr()-pSaveData) * sizeof(MCHAR));
    *ppstm = pstm;

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\mainloop.cpp ===
#include "priv.h"
#include <iethread.h>
#include "winlist.h"
#include "htregmng.h"
#include "resource.h"
#include "inetnot.h"

#include <mluisupp.h>

// Inststub uses kernel string funcions and unbounded buffer functions
#undef lstrcpyn
#undef lstrcmp
#undef lstrcpy
#undef lstrcmpi

#undef  StrCpyW
#define lstrcpy    StrCpyW
#define lstrcpyn   StrCpyNW
#define lstrcmp    StrCmpW
#define lstrcmpi   StrCmpIW

// need these defined before including <runonce.c> which is included by <inststub.h>
BOOL g_fCleanBoot = FALSE;
BOOL g_fEndSession = FALSE;
#include <inststub.h>

#undef lstrcpyn
#undef lstrcmp
#undef lstrcpy
#undef lstrcmpi

#define lstrcpyn       Do_not_use_lstrcpyn_use_StrCpyN
#define lstrcmp        Do_not_use_lstrcmp_use_StrCmp
#define lstrcpy        Do_not_use_lstrcpy_use_StrCpyN
#define lstrcmpi       Do_not_use_lstrcmpi_use_StrCmpI

#define StrCpyW        Do_not_use_StrCpyW_use_StrCpyNW

#ifdef UNIX
#include "unixstuff.h"
#endif

/* Old install stub API (no parameters) for compatibility for a few builds */
EXTERN_C void RunInstallUninstallStubs(void)
{
    RunInstallUninstallStubs2(NULL);
}


void IERevokeClassFactoryObject(void);

#ifndef POSTPOSTSPLIT
// This value will be initialized to 0 only when we are under IExplorer.exe
UINT g_tidParking = 0;
#endif


#define DM_FAVORITES 0

#ifdef BETA_WARNING
#pragma message("buidling with time bomb enabled")
void DoTimebomb(HWND hwnd)
{
    SYSTEMTIME st;
    GetSystemTime(&st);

    //
    // Revision History:
    //  End of October, 1996
    //  April, 1997
    //  September, 1997 (for beta-1)
    //  November 15th, 1997 (for beta-2)
    //
    if (st.wYear > 1997 || (st.wYear==1997 && st.wMonth > 11) ||
            (st.wYear==1997 && st.wMonth == 11 && st.wDay > 15))
    {
        TCHAR szTitle[128];
        TCHAR szBeta[512];

        MLLoadShellLangString(IDS_CABINET, szTitle, ARRAYSIZE(szTitle));
        MLLoadShellLangString(IDS_BETAEXPIRED, szBeta, ARRAYSIZE(szBeta));

        MessageBox(hwnd, szBeta, szTitle, MB_OK);
    }
}
#else
#define DoTimebomb(hwnd)
#endif


/*----------------------------------------------------------
Purpose: Initialize the favorites folder if it doesn't exist.

Returns: --

Cond:    As a side-effect, SHGetSpecialFolderPath calls Ole
         functions.  So this function must be called after
         OleInitialize has been called.

Note:    This is only really required on win95 / NT4 in
         browser only mode.  The shell32.dll that ships
         with IE4 can handle CSIDL_FAVORITES with fCreate=TRUE.
*/
void InitFavoritesDir()
{
    TCHAR szPath[MAX_PATH];

    if (!SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE))
    {
        TCHAR szFavorites[80];

        TraceMsg(DM_FAVORITES, "InitFavoritesDir -- no favorites");

        // if this failed, that means we need to create it ourselves
        GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
        MLLoadString(IDS_FAVORITES, szFavorites, ARRAYSIZE(szFavorites));
        PathCombine(szPath, szPath, szFavorites);
        SHCreateDirectory(NULL, szPath);

        HKEY hkExplorer;
        if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, &hkExplorer) == ERROR_SUCCESS)
        {
            HKEY hkUSF;

            if (RegCreateKey(hkExplorer, TEXT("User Shell Folders"), &hkUSF) == ERROR_SUCCESS)
            {
                BOOL f;

                TraceMsg(DM_FAVORITES, "InitFavoritesDir -- created in %s", szPath);

                RegSetValueEx(hkUSF, TEXT("Favorites"), 0, REG_SZ, (LPBYTE)szPath, (1 + lstrlen(szPath)) * SIZEOF(TCHAR));
                f = SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE);
                TraceMsg(DM_FAVORITES, "InitFavoritesDir -- cached at %d %s", f, szPath);

                ASSERT(f);
                RegCloseKey(hkUSF);
            }

            RegCloseKey(hkExplorer);
        }
    }
}


#ifdef ENABLE_CHANNELS
//
// Copy ChanBarSetAutoLaunchRegValue from browseui.
//
//extern void ChanBarSetAutoLaunchRegValue(BOOL fAutoLaunch);
void ChanBarSetAutoLaunchRegValue(BOOL fAutoLaunch)
{
    SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), 
                    TEXT("Show_ChannelBand"), REG_SZ, 
                    fAutoLaunch ? TEXT("yes") : TEXT("no"),
                    sizeof(fAutoLaunch ? TEXT("yes") : TEXT("no")), 
                    SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
}

#endif  // ENABLE_CHANNELS

STDAPI SHCreateSplashScreen(ISplashScreen ** pSplash);
typedef BOOL (*PFNISDEBUGGERPRESENT)(void);
void CUrlHistory_CleanUp();

//
// Mean Time To Failure check routines
//
#define REG_STR_IE    TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main")
#define REG_STR_CLEAN TEXT("CleanBrowserShutdown")

LONG GetSessionCount();

void WriteCleanBrowserShutdown(BOOL fClean)
{
    HKEY hkey;
    DWORD dwValue = (DWORD)fClean;

    //
    // Only do MTTF on the first browser session
    //
    if (GetSessionCount() != 0)
        return;
    
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_STR_IE, 0, KEY_WRITE, &hkey) 
        == ERROR_SUCCESS)
    {
        RegSetValueEx(hkey, REG_STR_CLEAN, 
            0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
        RegCloseKey(hkey);
    }
}

BOOL ReadCleanBrowserShutdown()
{
    HKEY hkey;
    DWORD dwValue = 1; // default to clean shutdown
    DWORD dwSize;

    //
    // Only do MTTF on the first browser session
    //
    if (GetSessionCount() != 0)
        return TRUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_STR_IE, 0, KEY_READ, &hkey) 
        == ERROR_SUCCESS)
    {
        RegQueryValueEx(hkey, REG_STR_CLEAN, NULL, NULL, (LPBYTE)&dwValue, &dwSize);
        RegCloseKey(hkey);
    }
    return (BOOL)dwValue;
}

void _TweakCurrentDirectory()
{
#ifndef UNIX
    TCHAR szPath[MAX_PATH];
    if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
        SetCurrentDirectory(szPath);
#endif
}

BOOL _IsDebuggerPresent()
{
    static BOOL bDebugger = -1;
    if (bDebugger == -1)
    {
        bDebugger = FALSE;
        // See if a debugger is present and bail on splash screen
        // so we don't get in the way of people... This api is only
        // present on NT...
        if (g_fRunningOnNT)
        {
            PFNISDEBUGGERPRESENT pfndebugger = (PFNISDEBUGGERPRESENT)GetProcAddress(GetModuleHandle(TEXT("KERNEL32")), "IsDebuggerPresent");
            if (pfndebugger)
                bDebugger = pfndebugger();
        }
    }
    return bDebugger;
}

PCWSTR IEGetArgs(PCWSTR pszCmd)
{
    if (*pszCmd == TEXT('\"'))
    {
        //  just strip the first quoted string
        while (*++pszCmd)
        {
            if (*pszCmd == L'\"')
            {
                pszCmd++;
                break;
            }
        }
    }
    else
    {
         while (*pszCmd > TEXT(' '))
            pszCmd++;
    }

    // strip the leading spaces
    while (*pszCmd && *pszCmd <= L' ')
        pszCmd++;

    return pszCmd;
}

PCWSTR EatIExploreArgs(PCWSTR pszArgs)
{
    //  this switches match the switches that are conumed/checked
    //  in iexplore\mainloop.cpp.  most params are in SHParseIECommandLine
    //  but these few apply only to IExplore.exe
    static const PCWSTR s_pszEatArgs[] = 
    {
        L"-eval",
        L"-new",
        L"-nowait"
    };

    pszArgs = IEGetArgs(pszArgs);

    for (int i = 0; i < ARRAYSIZE(s_pszEatArgs); i++)
    {
        int cch = lstrlenW(s_pszEatArgs[i]);
        if (0 == StrCmpNIW(s_pszEatArgs[i], pszArgs, cch))
        {
            if (!pszArgs[cch] || pszArgs[cch] == L' ')
                pszArgs += cch;
            //  strip the spaces
            while (pszArgs[0] == L' ')
                pszArgs++;

            //  start over, we need to go through this list until we get them all
            i = -1;
        }

    }
    return pszArgs;
}

BOOL g_fBrowserOnlyProcess = FALSE;

// this entry is used by IEXPLORE.EXE to run the browser in a separate process. this is the
// standard setting, but browsers (IE) can also be run in the same process if BrowseInSeparateProcess
// is turned off (for better perf, worse stability)

STDAPI_(int) IEWinMain(LPSTR pszCmdLine, int nCmdShow)
{
    //  this flag indicates that this
    //  browser is running in its own process
    //  and is not integrated with the shell
    //  even if it is running on an intgrated shell
    g_fBrowserOnlyProcess = TRUE;

    _TweakCurrentDirectory();

    if (g_dwProfileCAP & 0x00000001)
        StartCAP();

#ifdef FULL_DEBUG
    // Turn off GDI batching so that paints are performed immediately
    GdiSetBatchLimit(1);
#endif

    ASSERT(g_tidParking == 0);

    g_tidParking = GetCurrentThreadId();

    ISplashScreen *pSplash = NULL;
        
#ifndef UNIX
    // Show splash screen, be simple for beta 1...
    if (!_IsDebuggerPresent())
    {
        if (SUCCEEDED(SHCreateSplashScreen(&pSplash)))
        {
            HWND hSplash;
            pSplash->Show( HINST_THISDLL, -1, -1, &hSplash );
        }
    }            
#endif

    if (SUCCEEDED(OleInitialize(NULL)))
    {
        BOOL fWeOwnWinList = WinList_Init();
        IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, nCmdShow, NULL, NULL);
        if (piei) 
        {
            //
            // Create favorites dir (by hand if necessary).
            //
            InitFavoritesDir();

            //
            //  If we are opening IE with no parameter, check if this is
            // the very first open.
            //
            piei->pSplash = pSplash;
            if (pszCmdLine && pszCmdLine[0])
            {
                USES_CONVERSION;
                //  we are passed the an ANSI cmd line from IExplore.exe
                //  this is lame on NT when we can have UNICODE file names.
                //  on win9x, of course, GetCommandLineW() will return NULL
                //  so we use the one passed to use from IExplore.exe
                LPCWSTR pwszCmdLine;
                if (IsOS(OS_NT))
                    pwszCmdLine = EatIExploreArgs(GetCommandLineW());
                else
                    pwszCmdLine = A2W(pszCmdLine);
                    
                SHParseIECommandLine(&pwszCmdLine, piei);
                // If the "-channelband" option is selected, turn it ON by default
#ifdef ENABLE_CHANNELS
                if (piei->fDesktopChannel)
                    ChanBarSetAutoLaunchRegValue(TRUE);
#endif  // ENABLE_CHANNELS
                piei->pszCmdLine = StrDupW(pwszCmdLine);
            }
            else
            {
                piei->fCheckFirstOpen = TRUE;
            }

#ifdef UNIX
            if ( piei->fShouldStart && CheckAndDisplayEULA() )
            {
#ifndef NO_SPLASHSCREEN
                // IEUNIX - should show after parsing the commandline options.
                if (!_IsDebuggerPresent())
                {
                    if (SUCCEEDED(SHCreateSplashScreen(&pSplash)))
                    {
                        HWND hSplash;
                        pSplash->Show( HINST_THISDLL, -1, -1, &hSplash );
                    }
                }            
#endif
#endif
                DoTimebomb(NULL);
                piei->uFlags |= (COF_CREATENEWWINDOW | COF_NOFINDWINDOW | COF_INPROC | COF_IEXPLORE);
                
                SHOpenFolderWindow(piei);
#ifdef UNIX
            } // Start browser only if user accepts the license.
#endif
        }

        IERevokeClassFactoryObject();
        CUrlHistory_CleanUp();

        if (fWeOwnWinList)
            WinList_Terminate();

        CWinInetNotify::GlobalDisable();
        InternetSetOption(NULL, INTERNET_OPTION_DIGEST_AUTH_UNLOAD, NULL, 0);

        OleUninitialize();
    }

    ATOMICRELEASE(g_psfInternet);

#ifdef DEBUG
    CoFreeUnusedLibraries();
#endif

    TraceMsg(TF_SHDTHREAD, "IEWinMain about to call ExitProcess");

    if (g_dwProfileCAP & 0x00020000)
        StopCAP();

#ifdef UNIX
    MwExecuteAtExit();
    if (g_dwStopWatchMode)
        StopWatchFlush();
#endif

    ExitProcess(0);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\msstkppg.h ===
//=--------------------------------------------------------------------------=
// MSStkPPg.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for msprop32's property pages.
//
#ifndef _MS_STOCK_PROP_PAGES_H_

// {7EBDAAE0-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockFontPage, 0x7ebdaae0, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE1-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockColorPage, 0x7ebdaae1, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE2-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockPicturePage, 0x7ebdaae2, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

#define _MS_STOCK_PROP_PAGES_H_
#endif // _MS_STOCK_PROP_PAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\mruex.cpp ===
#include "priv.h"
#pragma hdrstop

// this is swiped from comctl32\mru.c

#define SLOT_LOADED     0x01
#define SLOT_USED       0x02

typedef struct _SLOTITEMDATA
{
    DWORD state;
    DWORD cb;
    BYTE  *p;
} SLOTITEMDATA;


class CMruBase : public IMruDataList
{
public:
    CMruBase() : _cRef(1) {}
    //  IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvOut);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  IMruDataList (maybe?)
    STDMETHODIMP InitData(
        UINT uMax,
        MRULISTF flags,
        HKEY hKey,
        LPCWSTR pszSubKey,
        MRUDATALISTCOMPARE pfnCompare);
        
    STDMETHODIMP AddData(const BYTE *pData, DWORD cbData, DWORD *pdwSlot);
    STDMETHODIMP FindData(const BYTE *pData, DWORD cbData, int *piIndex);
    STDMETHODIMP GetData(int iIndex, BYTE *pData, DWORD cbData);
    STDMETHODIMP QueryInfo(int iIndex, DWORD *pdwSlot, DWORD *pcbData);
    STDMETHODIMP Delete(int iItem);
    
protected:
    virtual ~CMruBase();

    HRESULT _GetItem(int iIndex, SLOTITEMDATA **ppitem);
    HRESULT _GetSlotItem(DWORD dwSlot, SLOTITEMDATA **ppitem);
    HRESULT _LoadItem(DWORD dwSlot);
    HRESULT _AddItem(DWORD dwSlot, const BYTE *pData, DWORD cbData);
    void _DeleteItem(DWORD dwSlot);
    HRESULT _UseEmptySlot(DWORD *pdwSlot);
    void _CheckUsedSlots();

    //  virtuals that are optionally implemented
    virtual BOOL _IsEqual(SLOTITEMDATA *pitem, const BYTE *pData, DWORD cbData);
    virtual void _DeleteValue(LPCWSTR psz);

    //  virtuals that must be implemented
    virtual HRESULT _InitSlots() = 0;
    virtual void _SaveSlots() = 0;
    virtual DWORD _UpdateSlots(int iIndex) = 0;
    virtual void _SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch) = 0;
    virtual HRESULT _GetSlot(int iIndex, DWORD *pdwSlot) = 0;
    virtual HRESULT _RemoveSlot(int iIndex, DWORD *pdwSlot) = 0;

protected:
    LONG _cRef;
    MRULISTF _flags;
    BOOL _fDirty;
    BOOL _fSlotsChecked;
    HKEY _hkMru;
    int _cMaxSlots;
    int _cUsedSlots;
    MRUDATALISTCOMPARE _pfnCompare;
    SLOTITEMDATA *_pItems;
};

class CMruLongList : public CMruBase
{

protected:
    virtual ~CMruLongList() { if (_rgdwSlots) { LocalFree(_rgdwSlots); _rgdwSlots = NULL; } }

    void _ImportShortList();

    virtual HRESULT _InitSlots();
    virtual void _SaveSlots();
    virtual DWORD _UpdateSlots(int iIndex);
    virtual void _SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch);
    virtual HRESULT _GetSlot(int iIndex, DWORD *pdwSlot);
    virtual HRESULT _RemoveSlot(int iIndex, DWORD *pdwSlot);

private:
    DWORD *_rgdwSlots;
};

STDMETHODIMP_(ULONG) CMruBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

#define szMRUEX         TEXT("MRUListEx")
#define szMRUEX_OLD     TEXT("MRUList")

STDMETHODIMP_(ULONG) CMruBase::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    _SaveSlots();

    delete this;
    return 0;
}

STDMETHODIMP CMruBase::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMruBase, IMruDataList),                      // IID_IMruDataList
        { 0 },                             
    };

    return QISearch(this, qit, riid, ppvObj);
}

CMruBase::~CMruBase()
{
    if (_hkMru)
        RegCloseKey(_hkMru);

    if (_pItems)
    {
        for (int i = 0; i < _cUsedSlots; i++)
        {
            if (_pItems[i].p)
            {
                LocalFree(_pItems[i].p);
                _pItems[i].p = NULL;
            }
        }

        LocalFree(_pItems);
        _pItems = NULL;
    }
}

class CMruShortList : public CMruBase
{
protected:
    virtual ~CMruShortList() { if (_rgchSlots) { LocalFree(_rgchSlots); _rgchSlots = NULL; } }

    virtual HRESULT _InitSlots();
    virtual void _SaveSlots();
    virtual DWORD _UpdateSlots(int iIndex);
    virtual void _SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch);
    virtual HRESULT _GetSlot(int iIndex, DWORD *pdwSlot);
    virtual HRESULT _RemoveSlot(int iIndex, DWORD *pdwSlot);

    friend class CMruLongList;
    
private:
    WCHAR *_rgchSlots;
};

HRESULT CMruShortList::_InitSlots()
{
    HRESULT hr = E_OUTOFMEMORY;
    
    DWORD cb = (_cMaxSlots + 1) * sizeof(_rgchSlots[0]);
    _rgchSlots = (WCHAR *) LocalAlloc(LPTR, cb);

    if (_rgchSlots)
    {
        // Do we already have the new MRU Index?
        // Then validate it.  You can never trust the registry not to be corrupted.
        // Must be at least the size of a DWORD
        // Must be a multiple of DWORD in length
        // Must end in a -1
        if (NOERROR == SHGetValue(_hkMru, NULL, szMRUEX_OLD, NULL, (LPBYTE)_rgchSlots, &cb))
        {
            ASSERT(!(cb % 2));
            _cUsedSlots = (cb / sizeof(_rgchSlots[0])) - 1;
            ASSERT(_rgchSlots[_cUsedSlots] == 0);
        }

        _rgchSlots[_cUsedSlots] = 0;
        hr = S_OK;
    }

    return hr;
}

void CMruShortList::_SaveSlots()
{
    if (_fDirty)
    {
        SHSetValue(_hkMru, NULL, szMRUEX_OLD, REG_SZ, (BYTE *)_rgchSlots, sizeof(_rgchSlots[0]) * (_cUsedSlots + 1));
        _fDirty = FALSE;
    }
}

#define BASE_CHAR TEXT('a')
void CMruShortList::_SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch)
{
    if (cch > 1)
    {
        psz[0] = (WCHAR) dwSlot + BASE_CHAR;
        psz[1] = 0;
    }
}

HRESULT CMruShortList::_GetSlot(int iIndex, DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;
    
    if (iIndex < _cUsedSlots)
    {
        //  its in our range of allocated slots
        if (_rgchSlots[iIndex] - BASE_CHAR < _cMaxSlots)
        {
            *pdwSlot = _rgchSlots[iIndex] - BASE_CHAR;
            _pItems[*pdwSlot].state |= SLOT_USED;
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CMruShortList::_RemoveSlot(int iIndex, DWORD *pdwSlot)
{
    HRESULT hr = _GetSlot(iIndex, pdwSlot);

    if (SUCCEEDED(hr))
    {
        //  MoveMemory() handles overlapping ranges
        MoveMemory(&_rgchSlots[iIndex], &_rgchSlots[iIndex+1], (_cUsedSlots - iIndex) * sizeof(_rgchSlots[0]));
        _cUsedSlots--;
        //  unuse the slot
        _pItems->state &= ~SLOT_USED;
        _fDirty = TRUE;
    }
    return hr;
}

DWORD CMruShortList::_UpdateSlots(int iIndex)
{
    //  need to move this away
    DWORD dwSlot;
    DWORD cb = iIndex * sizeof(_rgchSlots[0]);

    if (iIndex != _cUsedSlots)
        dwSlot = _rgchSlots[iIndex] - BASE_CHAR;
    else
    {
        //  we are at the end of the list
        //  see if we can grow
        //  find the first unused slot
        if (SUCCEEDED(_UseEmptySlot(&dwSlot)))
        {
            //  need to move the terminator
            cb += sizeof(_rgchSlots[0]);
        }
        else
        {
            //  dont move the the terminator
            //  and dont move the last slot
            dwSlot = _rgchSlots[_cUsedSlots - 1] - BASE_CHAR;
            cb -= sizeof(_rgchSlots[0]);
        }
    }

    if (cb)
    {
        //  MoveMemory() handles overlapping ranges
        MoveMemory(&_rgchSlots[1], &_rgchSlots[0], cb);
        _rgchSlots[0] = (WCHAR) dwSlot + BASE_CHAR;
        _fDirty = TRUE;
    }

    return dwSlot;
}

HRESULT CMruBase::InitData(
        UINT uMax,
        MRULISTF flags,
        HKEY hKey,
        LPCWSTR pszSubKey,
        MRUDATALISTCOMPARE pfnCompare)
{
    HRESULT hr = E_FAIL;
    _flags = flags;
    _pfnCompare = pfnCompare;
    _cMaxSlots = uMax;

    if (pszSubKey)
    {
        RegCreateKeyEx(hKey, pszSubKey, 0L, NULL, 0, MAXIMUM_ALLOWED, NULL, &_hkMru, NULL);
    }
    else
        _hkMru = SHRegDuplicateHKey(hKey);

    if (_hkMru)
    {
        _pItems = (SLOTITEMDATA *) LocalAlloc(LPTR, sizeof(SLOTITEMDATA) * _cMaxSlots);
        if (_pItems)
            hr = _InitSlots();
        else    
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

void CMruBase::_CheckUsedSlots()
{
    ASSERT(!_fSlotsChecked);
    DWORD dwSlot;
    for (int i = 0; i < _cUsedSlots; i++)
    {
        _GetSlot(i, &dwSlot);
    }
    
    _fSlotsChecked = TRUE;
}

HRESULT CMruBase::_AddItem(DWORD dwSlot, const BYTE *pData, DWORD cbData)
{
    SLOTITEMDATA *pitem = &_pItems[dwSlot];
    WCHAR szSlot[12];
    _SlotString(dwSlot, szSlot, ARRAYSIZE(szSlot));

    HRESULT hr = E_OUTOFMEMORY;
    
    if (NOERROR == SHSetValue(_hkMru, NULL, szSlot, REG_BINARY, pData, cbData))
    {
        if (cbData >= pitem->cb || !pitem->p)
        {
            if (pitem->p)
                LocalFree(pitem->p);

            // Binary data has the size at the begining so we'll need a little extra room.
            pitem->p = (BYTE *)LocalAlloc(LPTR, cbData);
        }

        if (pitem->p)
        {
            pitem->cb = cbData;
            pitem->state = (SLOT_LOADED | SLOT_USED);
            memcpy(pitem->p, pData, cbData);
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CMruBase::AddData(const BYTE *pData, DWORD cbData, DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;
    int iIndex;
    DWORD dwSlot;
    if (SUCCEEDED(FindData(pData, cbData, &iIndex)))
    {
        dwSlot = _UpdateSlots(iIndex);
        hr = S_OK;
    }
    else
    {
        dwSlot = _UpdateSlots(_cUsedSlots);

        hr = _AddItem(dwSlot, pData, cbData);
    }

    if (SUCCEEDED(hr) && pdwSlot)
        *pdwSlot = dwSlot;

    return hr;
}

BOOL CMruBase::_IsEqual(SLOTITEMDATA *pitem, const BYTE *pData, DWORD cbData)
{
    BOOL fRet = FALSE;
    if (_pfnCompare)
    {
        fRet = (0 == _pfnCompare(pData, pitem->p, cbData));
    }
    else
    {
        switch (_flags & 0xf)
        {
        case MRULISTF_USE_MEMCMP:
            if (pitem->cb == cbData)
                fRet = (0 == memcmp(pData, pitem->p, min(cbData, pitem->cb)));
            break;

        case MRULISTF_USE_STRCMPIW:
            fRet = (0 == StrCmpIW((LPCWSTR)pData, (LPCWSTR)pitem->p));
            break;
            
        case MRULISTF_USE_STRCMPW:
            fRet = (0 == StrCmpW((LPCWSTR)pData, (LPCWSTR)pitem->p));
            break;
            
        case MRULISTF_USE_ILISEQUAL:
            fRet = ILIsEqual((LPCITEMIDLIST)pData, (LPCITEMIDLIST)pitem->p);
            break;
        }
    }

    return fRet;
}

HRESULT CMruBase::FindData(const BYTE *pData, DWORD cbData, int *piIndex)
{
    HRESULT hr = E_FAIL;
    
    for (int iIndex = 0; iIndex < _cUsedSlots ; iIndex++)
    {
        SLOTITEMDATA *pitem;
        if (SUCCEEDED(_GetItem(iIndex, &pitem)))
        {
            if (_IsEqual(pitem, pData, cbData))
            {
                hr = S_OK;
                *piIndex = iIndex;
                break;
            }
        }
    }

    return hr;
}

HRESULT CMruBase::_LoadItem(DWORD dwSlot)
{
    SLOTITEMDATA *pitem = &_pItems[dwSlot];
    DWORD cb;
    WCHAR szSlot[12];
    _SlotString(dwSlot, szSlot, ARRAYSIZE(szSlot));

    ASSERT(!(pitem->state & SLOT_LOADED));
    ASSERT(pitem->state & SLOT_USED);
    
    if (NOERROR == SHGetValue(_hkMru, NULL, szSlot, NULL, NULL, &cb) && cb)
    {
        // Binary data has the size at the begining so we'll need a little extra room.
        pitem->p = (BYTE *)LocalAlloc(LPTR, cb);

        if (pitem->p)
        {
            pitem->cb = cb;

            if (NOERROR != SHGetValue(_hkMru, NULL, szSlot, NULL, pitem->p, &cb))
            {
                LocalFree(pitem->p);
                pitem->p = NULL;
            }
        }
    }
    pitem->state |= SLOT_LOADED;

    return pitem->p ? S_OK : E_FAIL;
}

HRESULT CMruBase::_GetSlotItem(DWORD dwSlot, SLOTITEMDATA **ppitem)
{
    HRESULT hr = S_OK;
    ASSERT(dwSlot < (DWORD)_cMaxSlots);
    
    if (!(_pItems[dwSlot].state & SLOT_LOADED))
        _LoadItem(dwSlot);

    if (_pItems[dwSlot].p)
    {
        *ppitem = &_pItems[dwSlot];
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

HRESULT CMruBase::_GetItem(int iIndex, SLOTITEMDATA **ppitem)
{
    DWORD dwSlot;
    HRESULT hr = _GetSlot(iIndex, &dwSlot);

    if (SUCCEEDED(hr))
    {
        hr = _GetSlotItem(dwSlot, ppitem);
    }

    return hr;
}
        
HRESULT CMruBase::GetData(int iIndex, BYTE *pData, DWORD cbData)
{
    SLOTITEMDATA *pitem;
    HRESULT hr = _GetItem(iIndex, &pitem);
    if (SUCCEEDED(hr))
    {
        if (pitem->cb <= cbData)
        {
            memcpy(pData, pitem->p, min(cbData, pitem->cb));
        }
        else
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}

HRESULT CMruBase::QueryInfo(int iIndex, DWORD *pdwSlot, DWORD *pcbData)
{
    DWORD dwSlot;
    HRESULT hr = _GetSlot(iIndex, &dwSlot);

    if (SUCCEEDED(hr))
    {
        if (pdwSlot)
            *pdwSlot = dwSlot;
            
        if (pcbData)
        {
            SLOTITEMDATA *pitem;
            hr = _GetSlotItem(dwSlot, &pitem);
            if (SUCCEEDED(hr))
            {
                *pcbData = pitem->cb;
            }
        }
    }

    return hr;
}
        
HRESULT CMruBase::_UseEmptySlot(DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;

    if (!_fSlotsChecked)
        _CheckUsedSlots();
        
    for (DWORD dw = 0; dw < (DWORD) _cMaxSlots; dw++)
    {
        if (!(_pItems[dw].state & SLOT_USED))
        {
            _pItems[dw].state |= SLOT_USED;
            *pdwSlot = dw;
            _cUsedSlots++;
            hr = S_OK;
            break;
        }
    }

    return hr;
}

void CMruBase::_DeleteValue(LPCWSTR psz)
{
    SHDeleteValue(_hkMru, NULL, psz);
}

void CMruBase::_DeleteItem(DWORD dwSlot)
{
    ASSERT(dwSlot < (DWORD) _cMaxSlots);

    WCHAR szSlot[12];
    _SlotString(dwSlot, szSlot, ARRAYSIZE(szSlot));
    _DeleteValue(szSlot);

    if (_pItems[dwSlot].p)
    {
        LocalFree(_pItems[dwSlot].p);
        _pItems[dwSlot].p = NULL;
    }
}
    
HRESULT CMruBase::Delete(int iIndex)
{
    DWORD dwSlot;
    HRESULT hr = _RemoveSlot(iIndex, &dwSlot);

    if (SUCCEEDED(hr))
    {
        _DeleteItem(dwSlot);
    }

    return hr;
}

void CMruLongList::_ImportShortList()
{
    CMruShortList *pmru = new CMruShortList();

    if (pmru)
    {
        if (SUCCEEDED(pmru->InitData(_cMaxSlots, 0, _hkMru, NULL, NULL)))
        {
            //  we need to walk the list
            DWORD dwSlot;
            SLOTITEMDATA *pitem;
            
            while (SUCCEEDED(pmru->_GetSlot(_cUsedSlots, &dwSlot))
            &&  SUCCEEDED(pmru->_GetSlotItem(dwSlot, &pitem)))
            {
                //  we just copy to ourselves
                _AddItem(dwSlot, pitem->p, pitem->cb);
                pmru->_DeleteItem(dwSlot);

                //  dont use _UpdateSlots() here
                _rgdwSlots[_cUsedSlots] = dwSlot;
                _cUsedSlots++;
            }

            _fDirty = TRUE;
        }

        pmru->Release();

        //  wipe it out
        SHDeleteValue(_hkMru, NULL, szMRUEX_OLD);
    }
}


HRESULT CMruLongList::_InitSlots()
{
    HRESULT hr = E_OUTOFMEMORY;
    
    DWORD cb = (_cMaxSlots + 1) * sizeof(_rgdwSlots[0]);
    _rgdwSlots = (DWORD *) LocalAlloc(LPTR, cb);

    if (_rgdwSlots)
    {
        // Do we already have the new MRU Index?
        // Then validate it.  You can never trust the registry not to be corrupted.
        // Must be at least the size of a DWORD
        // Must be a multiple of DWORD in length
        // Must end in a -1
        if (NOERROR == SHGetValue(_hkMru, NULL, szMRUEX, NULL, (LPBYTE)_rgdwSlots, &cb))
        {
            ASSERT(!(cb % 4));
            _cUsedSlots = (cb / sizeof(_rgdwSlots[0])) - 1;
            ASSERT(_rgdwSlots[_cUsedSlots] == -1);
        }
        else
        {
            _ImportShortList();
        }

        _rgdwSlots[_cUsedSlots] = (DWORD)-1;
        hr = S_OK;
    }

    return hr;
}

void CMruLongList::_SaveSlots()
{
    if (_fDirty)
    {
        SHSetValue(_hkMru, NULL, szMRUEX, REG_BINARY, (BYTE *)_rgdwSlots, sizeof(_rgdwSlots[0]) * (_cUsedSlots + 1));
        _fDirty = FALSE;
    }
}

void CMruLongList::_SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch)
{
    wnsprintfW(psz, cch, L"%d", dwSlot);
}

HRESULT CMruLongList::_GetSlot(int iIndex, DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;
    
    ASSERT(iIndex < _cMaxSlots);
    if (iIndex < _cUsedSlots)
    {
        //  its in our range of allocated slots
        if (_rgdwSlots[iIndex] < (DWORD) _cMaxSlots)
        {
            *pdwSlot = _rgdwSlots[iIndex];
            _pItems[*pdwSlot].state |= SLOT_USED;
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CMruLongList::_RemoveSlot(int iIndex, DWORD *pdwSlot)
{
    HRESULT hr = _GetSlot(iIndex, pdwSlot);

    if (SUCCEEDED(hr))
    {
        //  MoveMemory() handles overlapping ranges
        MoveMemory(&_rgdwSlots[iIndex], &_rgdwSlots[iIndex+1], (_cUsedSlots - iIndex) * sizeof(_rgdwSlots[0]));
        _cUsedSlots--;
        //  unuse the slot
        _pItems->state &= ~SLOT_USED;
        _fDirty = TRUE;
    }
    return hr;
}

DWORD CMruLongList::_UpdateSlots(int iIndex)
{
    //  need to move this away
    DWORD dwSlot;
    DWORD cb = iIndex * sizeof(_rgdwSlots[0]);

    if (iIndex != _cUsedSlots)
        dwSlot = _rgdwSlots[iIndex];
    else
    {
        //  we are at the end of the list
        //  see if we can grow
        //  find the first unused slot
        if (SUCCEEDED(_UseEmptySlot(&dwSlot)))
        {
            //  need to move the terminator
            cb += sizeof(_rgdwSlots[0]);
        }
        else
        {
            //  dont move the the terminator
            //  and dont move the last slot
            dwSlot = _rgdwSlots[_cUsedSlots - 1];
            cb -= sizeof(_rgdwSlots[0]);
        }
    }

    if (cb)
    {
        //  MoveMemory() handles overlapping ranges
        MoveMemory(&_rgdwSlots[1], &_rgdwSlots[0], cb);
        _rgdwSlots[0] = dwSlot;
        _fDirty = TRUE;
    }

    return dwSlot;
}

STDAPI  CMruLongList_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CMruLongList *p = new CMruLongList();
    if (p != NULL)
    {
        *ppunk = SAFECAST(p, IMruDataList *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


class CMruPidlList;

class CMruNode : public CMruLongList
{
public:
    CMruNode(CMruNode *pnodeParent, DWORD dwSlot);
    HRESULT GetNode(BOOL fCreate, LPCITEMIDLIST pidlChild, CMruNode **ppnode);
    HRESULT RemoveLeast(DWORD *pdwSlotLeast);
    HRESULT BindToSlot(DWORD dwSlot, IShellFolder **ppsf);
    HRESULT Clear(CMruPidlList *proot);

    CMruNode *GetParent() 
        { if (_pnodeParent) _pnodeParent->AddRef(); return _pnodeParent;}

    HRESULT GetNodeSlot(DWORD *pdwNodeSlot)
        {
            DWORD cb = sizeof(*pdwNodeSlot);
            return NOERROR == SHGetValue(_hkMru, NULL, L"NodeSlot", NULL, pdwNodeSlot, pdwNodeSlot ? &cb : NULL) ? S_OK : E_FAIL;
        }

    HRESULT SetNodeSlot(DWORD dwNodeSlot)
        { return NOERROR == SHSetValue(_hkMru, NULL, L"NodeSlot", REG_DWORD, &dwNodeSlot, sizeof(dwNodeSlot)) ? S_OK : E_FAIL; }

protected:
    CMruNode() {}
    virtual ~CMruNode();
    virtual BOOL _IsEqual(SLOTITEMDATA *pitem, const BYTE *pData, DWORD cbData);
    virtual void _DeleteValue(LPCWSTR psz);

    HRESULT _GetPidlSlot(LPCITEMIDLIST pidlChild, BOOL fCreate, DWORD *pdwKidSlot);
    HRESULT _CreateNode(DWORD dwSlot, CMruNode **ppnode);
    BOOL _InitLate();

    HRESULT _FindPidl(LPCITEMIDLIST pidl, int *piIndex)
        { return FindData((LPBYTE)pidl, pidl->mkid.cb + sizeof(pidl->mkid.cb), piIndex); }

    HRESULT _AddPidl(DWORD dwSlot, LPCITEMIDLIST pidl)
        { return _AddItem(dwSlot, (LPBYTE)pidl, pidl->mkid.cb + sizeof(pidl->mkid.cb)); }

#ifdef DEBUG
    HRESULT _GetSlotName(DWORD dwSlot, LPWSTR psz, DWORD cch);
#endif

protected:
    DWORD _dwSlotSelf;
    CMruNode *_pnodeParent;
    IShellFolder *_psf;
};

class CMruPidlList  : public CMruNode
                    , public IMruPidlList
{
public:
    CMruPidlList() {}
    //  IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvOut);
    STDMETHODIMP_(ULONG) AddRef()
    {
        return CMruBase::AddRef();
    }

    STDMETHODIMP_(ULONG) Release()
    {
        return CMruBase::Release();
    }

    //  IMruPidlList
    STDMETHODIMP InitList(UINT uMax, HKEY hKey, LPCWSTR pszSubKey);
    STDMETHODIMP UsePidl(LPCITEMIDLIST pidl, DWORD *pdwSlot);
    STDMETHODIMP QueryPidl(LPCITEMIDLIST pidl, DWORD cSlots, DWORD *rgdwSlots, DWORD *pcSlotsFetched);
    STDMETHODIMP PruneKids(LPCITEMIDLIST pidl);

    HRESULT GetEmptySlot(DWORD *pdwSlot);
    void EmptyNodeSlot(DWORD dwNodeSlot);

protected:
    ~CMruPidlList() 
    { 
        if (_rgbNodeSlots) 
        { 
            LocalFree(_rgbNodeSlots); 
            _rgbNodeSlots = NULL; 
        } 

        if (_hMutex)
            CloseHandle(_hMutex);
    }
    
    BOOL _LoadNodeSlots();
    void _SaveNodeSlots();
    HRESULT _InitNodeSlots();

protected:
    BYTE *_rgbNodeSlots;
    int _cUsedNodeSlots ;
    HANDLE _hMutex;
};

CMruNode::CMruNode(CMruNode *pnodeParent, DWORD dwSlot)
    : _pnodeParent(pnodeParent), _dwSlotSelf(dwSlot)
{
    ASSERT(_cRef);
    _pnodeParent->AddRef();
}

CMruNode::~CMruNode()
{
    if (_pnodeParent)
        _pnodeParent->Release();
    if (_psf)
        _psf->Release();
}


HRESULT CMruNode::BindToSlot(DWORD dwSlot, IShellFolder **ppsf)
{
    SLOTITEMDATA *pitem;
    HRESULT hr = _GetSlotItem(dwSlot, &pitem);
    if (SUCCEEDED(hr))
    {
        hr = _psf->BindToObject((LPCITEMIDLIST)pitem->p, NULL, IID_PPV_ARG(IShellFolder, ppsf));
    }
    return hr;
}

#ifdef DEBUG
HRESULT CMruNode::_GetSlotName(DWORD dwSlot, LPWSTR psz, DWORD cch)
{
    SLOTITEMDATA *pitem;
    HRESULT hr = _GetSlotItem(dwSlot, &pitem);
    if (SUCCEEDED(hr))
    {
        hr = DisplayNameOf(_psf, (LPCITEMIDLIST)pitem->p, 0, psz, cch);
    }
    return hr;
}
#endif 

BOOL CMruNode::_IsEqual(SLOTITEMDATA *pitem, const BYTE *pData, DWORD cbData)
{
    return S_OK == IShellFolder_CompareIDs(_psf, SHCIDS_CANONICALONLY, (LPCITEMIDLIST)pitem->p, (LPCITEMIDLIST)pData);
}

HRESULT CMruNode::_CreateNode(DWORD dwSlot, CMruNode **ppnode)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMruNode *pnode = new CMruNode(this, dwSlot);
    if (pnode)
    {
        WCHAR szSlot[12];
        _SlotString(dwSlot, szSlot, ARRAYSIZE(szSlot));
        hr = pnode->InitData(_cMaxSlots, 0, _hkMru, szSlot, NULL);
        if (SUCCEEDED(hr))
            *ppnode = pnode;
        else
            pnode->Release();
    }
    return hr;
}

BOOL CMruNode::_InitLate()
{
    if (!_psf)
    {
        if (_pnodeParent)
        {
            _pnodeParent->BindToSlot(_dwSlotSelf, &_psf);
#ifdef DEBUG            
            WCHAR sz[MAX_PATH];
            if (SUCCEEDED(_pnodeParent->_GetSlotName(_dwSlotSelf, sz, ARRAYSIZE(sz))))
                SHSetValue(_hkMru, NULL, L"SlotName", REG_SZ, sz, CbFromCchW(lstrlen(sz) + 1));
#endif                
        }
        else
            SHGetDesktopFolder(&_psf);
    }
    return (_psf != NULL);
}

HRESULT CMruNode::_GetPidlSlot(LPCITEMIDLIST pidlChild, BOOL fCreate, DWORD *pdwKidSlot)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidlFirst = ILCloneFirst(pidlChild);
    if (pidlFirst)
    {
        int iIndex;
        if (SUCCEEDED(_FindPidl(pidlFirst, &iIndex)))
        {
            *pdwKidSlot = _UpdateSlots(iIndex);
            hr = S_OK;
        }
        else if (fCreate)
        {
            *pdwKidSlot = _UpdateSlots(_cUsedSlots);
            hr = _AddPidl(*pdwKidSlot, pidlFirst);
        }
        ILFree(pidlFirst);
    }
    return hr;
}

HRESULT CMruNode::GetNode(BOOL fCreate, LPCITEMIDLIST pidlChild, CMruNode **ppnode)
{
    HRESULT hr = E_FAIL;
    if (ILIsEmpty(pidlChild))
    {
        *ppnode = this;
        AddRef();
        hr = S_OK;
    }
    else  if (_InitLate())
    {
        DWORD dwKidSlot;
        hr = _GetPidlSlot(pidlChild, fCreate, &dwKidSlot);

        if (SUCCEEDED(hr))
        {
            //  need to make another CMruNode
            CMruNode *pnode;
            hr = _CreateNode(dwKidSlot, &pnode);
            if (SUCCEEDED(hr))
            {
                //  need to save so that this node
                //  is updated so that it doesnt get
                //  deleted from under us.
                _SaveSlots();
                hr = pnode->GetNode(fCreate, _ILNext(pidlChild), ppnode);
                pnode->Release();
            }
        }

        if (FAILED(hr) && !fCreate)
        {
            *ppnode = this;
            AddRef();
            hr = S_FALSE;
        }
    }
    
    return hr;
}

void CMruNode::_DeleteValue(LPCWSTR psz)
{
    CMruBase::_DeleteValue(psz);
    SHDeleteKey(_hkMru, psz);
}

HRESULT CMruNode::RemoveLeast(DWORD *pdwSlotLeast)
{
    //  if this node has children
    //  then we attempt to call RemoveLeast on them
    ASSERT(_cUsedSlots >= 0);
    HRESULT hr = S_FALSE;
    if (_cUsedSlots)
    {
        DWORD dwLocalSlot;
        hr = _GetSlot(_cUsedSlots - 1, &dwLocalSlot);
        if (SUCCEEDED(hr))
        {
            CMruNode *pnode;
            hr = _CreateNode(dwLocalSlot, &pnode);
            if (SUCCEEDED(hr))
            {
                hr = pnode->RemoveLeast(pdwSlotLeast);
                pnode->Release();
            }

            //  S_FALSE means that this node needs
            //  needs deleting.  it is empty.
            if (hr == S_FALSE)
            {
                Delete(_cUsedSlots - 1);

                //  if we still have kids, or have a NodeSlot
                //  then we dont want to be deleted
                if (_cUsedSlots || SUCCEEDED(GetNodeSlot(NULL)))
                    hr = S_OK;
            }
        }
    }
    else
    {
        //  this is the empty node
        //  delete me if you can
        ASSERT(!*pdwSlotLeast);
        GetNodeSlot(pdwSlotLeast);
    }
    return hr;
}

HRESULT CMruNode::Clear(CMruPidlList *proot)
{
    DWORD dwLocalSlot;
    while (SUCCEEDED(_GetSlot(0, &dwLocalSlot)))
    {
        CMruNode *pnode;
        if (SUCCEEDED(_CreateNode(dwLocalSlot, &pnode)))
        {
            //  tell the root about it
            DWORD dwNodeSlot;
            if (SUCCEEDED(pnode->GetNodeSlot(&dwNodeSlot)))
                proot->EmptyNodeSlot(dwNodeSlot);

            pnode->Clear(proot);
            pnode->Release();
        }

        Delete(0);

    }
    return S_OK;
}

class CSafeMutex
{
public:
    CSafeMutex() : _h(0) {}
    ~CSafeMutex() { if (_h) ReleaseMutex(_h); }
    
    HRESULT Enter(HANDLE hMutex)
    {
        //  this is usually done on the UI thread
        //  wait for half a second or dont bother
        HRESULT hr;
        DWORD dwWait = WaitForSingleObject(hMutex, 500);
        if (dwWait == WAIT_OBJECT_0)
        {
            _h = hMutex;
            hr = S_OK;
        }
        else
            hr = E_FAIL;
            
        return hr;
    }
private:
    HANDLE _h;
};
    

HRESULT CMruPidlList::UsePidl(LPCITEMIDLIST pidl, DWORD *pdwSlot)
{
    CSafeMutex sm;
    HRESULT hr = sm.Enter(_hMutex);
    if (SUCCEEDED(hr))
    {
        CMruNode *pnode;
        hr = GetNode(TRUE, pidl, &pnode);
        *pdwSlot = 0;
        if (SUCCEEDED(hr))
        {
            ASSERT(hr == S_OK);
            hr = pnode->GetNodeSlot(pdwSlot);

            if (FAILED(hr))
            {
                hr = GetEmptySlot(pdwSlot);
                if (SUCCEEDED(hr))
                {
                    hr = pnode->SetNodeSlot(*pdwSlot);
                }
            }
            pnode->Release();
        }
    }
    return hr;
}
       
HRESULT CMruPidlList::QueryPidl(LPCITEMIDLIST pidl, DWORD cSlots, DWORD *rgdwSlots, DWORD *pcSlotsFetched)
{
    CSafeMutex sm;
    HRESULT hr = sm.Enter(_hMutex);
    if (SUCCEEDED(hr))
    {
        CMruNode *pnode;
        hr = GetNode(FALSE, pidl, &pnode);
        *pcSlotsFetched = 0;
        if (SUCCEEDED(hr))
        {
            while (*pcSlotsFetched < cSlots && pnode)
            {
                CMruNode *pnodeParent = pnode->GetParent();
                if (SUCCEEDED(pnode->GetNodeSlot(&rgdwSlots[*pcSlotsFetched])))
                {
                    (*pcSlotsFetched)++;
                }
                else if (hr == S_OK && !*pcSlotsFetched)
                {
                    //  we found the exact node
                    //  but we couldnt get the NodeSlot from it
                    hr = S_FALSE;
                }
                    
                pnode->Release();
                pnode = pnodeParent;
            }

            if (pnode)
                pnode->Release();
        }

        if (SUCCEEDED(hr) && !*pcSlotsFetched)
            hr = E_FAIL;
    }
    return hr;
}

HRESULT CMruPidlList::PruneKids(LPCITEMIDLIST pidl)
{
    CSafeMutex sm;
    HRESULT hr = sm.Enter(_hMutex);
    if (SUCCEEDED(hr))
    {
        if (_LoadNodeSlots())
        {
            CMruNode *pnode;
            hr = GetNode(FALSE, pidl, &pnode);
            if (SUCCEEDED(hr))
            {    
                if (hr == S_OK)
                {
                    hr = pnode->Clear(this);
                }
                else
                    hr = E_FAIL;
                    
                pnode->Release();
            }
            _SaveNodeSlots();
        }
    }
    return hr;
}

            
STDMETHODIMP CMruPidlList::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMruPidlList, IMruPidlList),                      // IID_IMruDataList
        { 0 },                             
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CMruPidlList::InitList(UINT uMax, HKEY hKey, LPCWSTR pszSubKey)
{
    HRESULT hr = InitData(uMax, 0, hKey, pszSubKey, NULL);
    if (SUCCEEDED(hr))
    {
        hr = _InitNodeSlots();
        if (SUCCEEDED(hr))
        {
            _hMutex = CreateMutex(NULL, FALSE, TEXT("Shell.CMruPidlList"));
            if (!_hMutex)
                hr = ResultFromLastError();
        }
    }
    return hr;
}

BOOL CMruPidlList::_LoadNodeSlots()
{
    DWORD cb = (_cMaxSlots) * sizeof(_rgbNodeSlots[0]);
    if (NOERROR == SHGetValue(_hkMru, NULL, L"NodeSlots", NULL, _rgbNodeSlots , &cb))
    {
        _cUsedNodeSlots = (cb / sizeof(_rgbNodeSlots[0]));
        return TRUE;
    }
    return FALSE;
}

void CMruPidlList::_SaveNodeSlots()
{
    SHSetValue(_hkMru, NULL, L"NodeSlots", REG_BINARY, _rgbNodeSlots , _cUsedNodeSlots);
}

HRESULT CMruPidlList::_InitNodeSlots()
{
    HRESULT hr = E_OUTOFMEMORY;
    
    DWORD cb = (_cMaxSlots) * sizeof(_rgbNodeSlots[0]);
    _rgbNodeSlots = (BYTE *) LocalAlloc(LPTR, cb);

    if (_rgbNodeSlots)
    {
        _LoadNodeSlots();
        _fDirty = TRUE;
        _SaveNodeSlots();
        hr = S_OK;
    }

    return hr;
}

void CMruPidlList::EmptyNodeSlot(DWORD dwNodeSlot)
{
    ASSERT(dwNodeSlot <= (DWORD)_cMaxSlots);
    _rgbNodeSlots[dwNodeSlot-1] = FALSE;
    _fDirty = TRUE;
}

HRESULT CMruPidlList::GetEmptySlot(DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;
    *pdwSlot = 0;
    if (_LoadNodeSlots())
    {
        if (_cUsedNodeSlots < _cMaxSlots)
        {
            //  then we can just use the next most natural 
            //  node slot
            _rgbNodeSlots[_cUsedNodeSlots] = SLOT_USED;
            *pdwSlot = ++_cUsedNodeSlots;
            hr = S_OK;
        }
        else
        {
            //  if we can find an empty in the list...

            for (int i = 0; i < _cUsedNodeSlots; i++)
            {
                if (!(_rgbNodeSlots[i] & SLOT_USED))
                {
                    _rgbNodeSlots[i] = SLOT_USED;
                    *pdwSlot = i+1;
                    hr = S_OK;
                    break;
                }
            }

            if (FAILED(hr))
            {
                //  we need to find the LRU slot
                if (SUCCEEDED(RemoveLeast(pdwSlot)) && *pdwSlot)
                    hr = S_OK;
            }
        }
        _SaveNodeSlots();
    }

    return hr;
}

STDAPI  CMruPidlList_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CMruPidlList *p = new CMruPidlList();
    if (p != NULL)
    {
        *ppunk = SAFECAST(p, IMruPidlList *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\multinfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Mar 29 16:59:57 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __multinfo_h__
#define __multinfo_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideClassInfo_FWD_DEFINED__
#define __IProvideClassInfo_FWD_DEFINED__
typedef interface IProvideClassInfo IProvideClassInfo;
#endif 	/* __IProvideClassInfo_FWD_DEFINED__ */


#ifndef __IProvideClassInfo2_FWD_DEFINED__
#define __IProvideClassInfo2_FWD_DEFINED__
typedef interface IProvideClassInfo2 IProvideClassInfo2;
#endif 	/* __IProvideClassInfo2_FWD_DEFINED__ */


#ifndef __IProvideMultipleClassInfo_FWD_DEFINED__
#define __IProvideMultipleClassInfo_FWD_DEFINED__
typedef interface IProvideMultipleClassInfo IProvideMultipleClassInfo;
#endif 	/* __IProvideMultipleClassInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif
#if 0


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IProvideClassInfo_INTERFACE_DEFINED__
#define __IProvideClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IProvideClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideClassInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetClassInfo( 
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideClassInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideClassInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideClassInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfo )( 
            IProvideClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
    } IProvideClassInfoVtbl;

    interface IProvideClassInfo
    {
        CONST_VTBL struct IProvideClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideClassInfo_GetClassInfo_Proxy( 
    IProvideClassInfo __RPC_FAR * This,
    /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);


void __RPC_STUB IProvideClassInfo_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo_INTERFACE_DEFINED__ */


#ifndef __IProvideClassInfo2_INTERFACE_DEFINED__
#define __IProvideClassInfo2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo2
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IProvideClassInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideClassInfo2 : public IProvideClassInfo
    {
    public:
        virtual HRESULT __stdcall GetGUID( 
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideClassInfo2Vtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideClassInfo2 __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideClassInfo2 __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfo )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
    } IProvideClassInfo2Vtbl;

    interface IProvideClassInfo2
    {
        CONST_VTBL struct IProvideClassInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideClassInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo2_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideClassInfo2_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideClassInfo2_GetGUID_Proxy( 
    IProvideClassInfo2 __RPC_FAR * This,
    /* [in] */ DWORD dwGuidKind,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB IProvideClassInfo2_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo2_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0053
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#endif // 0
// {A7ABA9C1-8983-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IProvideMultipleClassInfo,
0xa7aba9c1, 0x8983, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);


extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_s_ifspec;

#ifndef __IProvideMultipleClassInfo_INTERFACE_DEFINED__
#define __IProvideMultipleClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideMultipleClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


#define MULTICLASSINFO_GETTYPEINFO           0x00000001
#define MULTICLASSINFO_GETNUMRESERVEDDISPIDS 0x00000002
#define MULTICLASSINFO_GETIIDPRIMARY         0x00000004
#define MULTICLASSINFO_GETIIDSOURCE          0x00000008
#define TIFLAGS_EXTENDDISPATCHONLY           0x00000001

EXTERN_C const IID IID_IProvideMultipleClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideMultipleClassInfo : public IProvideClassInfo2
    {
    public:
        virtual HRESULT __stdcall GetMultiTypeInfoCount( 
            /* [out] */ ULONG __RPC_FAR *pcti) = 0;
        
        virtual HRESULT __stdcall GetInfoOfIndex( 
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideMultipleClassInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfo )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( __stdcall __RPC_FAR *GetMultiTypeInfoCount )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcti);
        
        HRESULT ( __stdcall __RPC_FAR *GetInfoOfIndex )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource);
        
    } IProvideMultipleClassInfoVtbl;

    interface IProvideMultipleClassInfo
    {
        CONST_VTBL struct IProvideMultipleClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideMultipleClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideMultipleClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideMultipleClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideMultipleClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideMultipleClassInfo_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideMultipleClassInfo_GetMultiTypeInfoCount(This,pcti)	\
    (This)->lpVtbl -> GetMultiTypeInfoCount(This,pcti)

#define IProvideMultipleClassInfo_GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)	\
    (This)->lpVtbl -> GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideMultipleClassInfo_GetMultiTypeInfoCount_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcti);


void __RPC_STUB IProvideMultipleClassInfo_GetMultiTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IProvideMultipleClassInfo_GetInfoOfIndex_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [in] */ ULONG iti,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
    /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
    /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
    /* [out] */ IID __RPC_FAR *piidPrimary,
    /* [out] */ IID __RPC_FAR *piidSource);


void __RPC_STUB IProvideMultipleClassInfo_GetInfoOfIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideMultipleClassInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\mypics.h ===
#ifndef __IEMYPICS_H_
#define __IEMYPICS_H_

// other constants: 
#define MP_BMP_CX                       16      // bitmap size
#define MP_BMP_CY                       16
#define MP_NUM_TBBUTTONS                4       // number buttons
#define MP_NUM_TBBITMAPS                4       
#define MP_MIN_CX                       114     // minimum x size of toolbar
#define MP_MIN_CY                       28      // minimum y size of toolbar
#define MP_MIN_SIZE                     200     // minimum square size in pixels for hoverbar to appear
#define MP_HOVER_OFFSET                 10      // offset +x +y from (x,y) of image's upper lefthand corner
#define MP_TIMER                        700     // time in milliseconds to delay on the mouseover/out events
#define MP_SCROLLBAR_SIZE               GetSystemMetrics(SM_CXVSCROLL)      // size of the scrollbars in pixels

// e-mail picture stuff called via ITridentService2
HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState);
HRESULT CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(LPCITEMIDLIST pidl, IUnknown *pUnkSite, IUniformResourceLocator **ppUrlOut, IDataObject **ppdtobj);
HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite);

// need this to get scroll event, it lives in iforms.cpp...
void Win3FromDoc2(IHTMLDocument2 *pDoc2, IHTMLWindow3 **ppWin3);

// well, yeah.
BOOL    MP_IsEnabledInRegistry();
BOOL    MP_IsEnabledInIEAK();
DWORD   MP_GetFilterInfoFromRegistry();

// EventSink Callback Class (glorified array)...
class CMyPicsEventSinkCallback
{
public:
    typedef enum
    {
        EVENT_BOGUS     = 100,
        EVENT_MOUSEOVER = 0,
        EVENT_MOUSEOUT,
        EVENT_SCROLL,
        EVENT_RESIZE
    }
    EVENTS;

    typedef struct
    {
        EVENTS  Event;
        LPCWSTR pwszEventSubscribe;
        LPCWSTR pwszEventName;
    }
    EventSinkEntry;

    virtual HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) = 0;

    static  EventSinkEntry EventsToSink[];
};

class CMyPics : public CMyPicsEventSinkCallback
{
    long   m_cRef;

public:
    class CEventSink;
    
    CMyPics();
   ~CMyPics();

    // IUnknown...
    virtual STDMETHODIMP QueryInterface(REFIID, void **);
    virtual ULONG __stdcall AddRef();
    virtual ULONG __stdcall Release();

    // CMyPicsEventSinkCallback...
    HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj);

    HRESULT Init(IHTMLDocument2 *pDoc2);

    HRESULT UnInit();

    static  HRESULT GetName(IHTMLInputTextElement *pTextEle, BSTR *pbstrName);

    static  BOOL    IsAdminRestricted(LPCTSTR pszRegVal);

    typedef HRESULT (*PFN_ENUM_CALLBACK)(IDispatch *pDispEle, DWORD_PTR dwCBData);

    BOOL    IsOff();

    static  VOID CALLBACK s_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    void    IsGalleryMeta(BOOL bFlag);

protected:

    // Methods for managing the Hover bar
    HRESULT CreateHover();
    HRESULT DestroyHover();
    HRESULT HideHover();
    HRESULT ShowHover();

    // Event handlers
    HRESULT HandleScroll();
    HRESULT HandleMouseout();
    HRESULT HandleMouseover(IHTMLElement *pEle);
    HRESULT HandleResize();
        
    static  LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT CALLBACK DisableWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);    

    BOOL ShouldAppearOnThisElement(IHTMLElement *pEle);

    HRESULT GetRealCoords(IHTMLElement2 *pEle2, HWND hwnd, LONG *plLeft, LONG *plTop, LONG *plRight, LONG *plBottom);

    IHTMLElement *GetIMGFromArea(IHTMLElement *pEleIn, POINT ptEvent);

private:
    // CMyPics member variables
    CEventSink     *m_pSink;
        
    // Floating Toolbar stuff...
    HWND            m_Hwnd,                  // Hwnd for the m_pdoc2
                    m_hWndHover,             // Hover rebar thing
                    m_hWndMyPicsToolBar;     // Toolbar that lives in the hover thing
                    
    UINT            m_hoverState;            // Current state of the HoverBar thing 
                                             
    UINT_PTR        m_uidTimer;              // The Timer
    WNDPROC         m_wndprocOld;            // For stuff
    HIMAGELIST      m_himlHover;             // For the image list
    HIMAGELIST      m_himlHoverHot;          // for the hot images
    
    // Useful stuff for the attached document
    IHTMLDocument2         *m_pDoc2;
    IHTMLElement           *m_pEleCurr;              // current element we are hovering over
    IHTMLWindow3           *m_pWin3;                 // for unsinking scroll event
    EVENTS                  m_eventsCurr;            // event currently being processed
    BOOL                    m_bIsOffForSession : 1;  // have we disabled feature for this session?
    BOOL                    m_bGalleryMeta : 1;      // TRUE if there was a META tag disabling image bar for this doc
    BOOL                    m_bGalleryImg : 1;       // TRUE if the current element has a galleryimg value set to TRUE

public:

    // Sinks regular Trident events. Calls back via CMyPicsEventSinkCallback...
    class CEventSink : public IDispatch
    {
        ULONG   m_cRef;

    public:

        CEventSink(CMyPicsEventSinkCallback *pParent);
       ~CEventSink();

        HRESULT SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);

        void SetParent(CMyPicsEventSinkCallback *pParent) { m_pParent = pParent; }

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
        STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
            LCID lcid, DISPID *rgDispId);
        STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
            EXCEPINFO *pExcepInfo, UINT *puArgErr);

    private:
        CMyPicsEventSinkCallback *m_pParent;
    };

};

#endif //__IEMYPICS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\nsc.h ===
#ifndef _NSC_C
#define _NSC_C

#include "droptgt.h"
#include "iface.h"
#include "dpastuff.h"
#include "cwndproc.h"
#include "resource.h"
#include "inetnot.h"
#include "cowsite.h"
#include <shlobj.h>
#include <cfdefs.h> // LPCOBJECTINFO

#define ID_CONTROL  100  
#define ID_HEADER   101

typedef enum
{
    NSIF_HITEM              = 0x0001,
    NSIF_FOLDER             = 0x0002,
    NSIF_PARENTFOLDER       = 0x0004,
    NSIF_IDLIST             = 0x0008,
    NSIF_FULLIDLIST         = 0x0010,
    NSIF_ATTRIBUTES         = 0x0020
} NSI_FLAGS;

typedef enum
{
    NSSR_ENUMBELOWROOT  = 0x0001,
    NSSR_CREATEPIDL     = 0x0002
} NSSR_FLAGS;

typedef struct
{
    PORDERITEM  poi;
    DWORD       dwSig;          // Signature of the item, so we can find it back after async processing
    BITBOOL     fPinned:1;      // is this url pinned in the cache?
    BITBOOL     fGreyed:1;      // draw the item greyed (if offline & not in cache)
    BITBOOL     fFetched:1;     // have we fetched the pinned/greyed state?
    BITBOOL     fDontRefetch:1; // can't be cached by wininet
    BOOL        fNavigable:1;   // item can be navigated to
} ITEMINFO;

typedef struct
{
    const SHCOLUMNID  *pscid;
    int               iFldrCol;       // index for this column in GetDetailsOf
    TCHAR             szName[MAX_COLUMN_NAME_LEN];
    DWORD             fmt;
    int               cxChar;
} HEADERINFO;

// Forward decls
struct NSC_BKGDENUMDONEDATA;

// _FrameTrack flags
#define TRACKHOT        0x0001
#define TRACKEXPAND     0x0002
#define TRACKNOCHILD    0x0004

// _DrawItem flags
#define DIICON          0x0001
#define DIRTLREADING    0x0002
#define DIHOT           0x0004
#define DIFIRST         0x0020
#define DISUBITEM       0x0040
#define DILAST          0x0080
#define DISUBLAST       (DISUBITEM | DILAST)
#define DIACTIVEBORDER  0x0100
#define DISUBFIRST      (DISUBITEM | DIFIRST)
#define DIPINNED        0x0400                  // overlay pinned glyph
#define DIGREYED        0x0800                  // draw greyed
#define DIFOLDEROPEN    0x1000      
#define DIFOLDER        0x2000      //item is a folder
#define DIFOCUSRECT     0x4000
#define DIRIGHT         0x8000      //right aligned

#define NSC_TVIS_MARKED 0x1000

// async icon/url extract flags
#define NSCICON_GREYED      0x0001
#define NSCICON_PINNED      0x0002
#define NSCICON_DONTREFETCH 0x0004

#define WM_NSCUPDATEICONINFO       WM_USER + 0x700
#define WM_NSCBACKGROUNDENUMDONE   WM_USER + 0x701
#define WM_NSCUPDATEICONOVERLAY    WM_USER + 0x702

HRESULT GetNavTargetName(IShellFolder* pFolder, LPCITEMIDLIST pidl, LPTSTR pszUrl, UINT cMaxChars);
BOOL    MayBeUnavailableOffline(LPTSTR pszUrl);
INSCTree2 * CNscTree_CreateInstance(void);
STDAPI CNscTree_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
BOOL IsExpandableChannelFolder(IShellFolder *psf, LPCITEMIDLIST pidl);

// class wrapper for tree control component of nscband.
class ATL_NO_VTABLE CNscTree :    
                    public CComObjectRootEx<CComMultiThreadModelNoCS>,
                    public CComCoClass<CNscTree, &CLSID_ShellNameSpace>,
                    public CComControl<CNscTree>,
                    public IDispatchImpl<IShellNameSpace, &IID_IShellNameSpace, &LIBID_SHDocVw, 1, 0, CComTypeInfoHolder>,
                    public IProvideClassInfo2Impl<&CLSID_ShellNameSpace, &DIID_DShellNameSpaceEvents, &LIBID_SHDocVw, 1, 0, CComTypeInfoHolder>,
                    public IPersistStreamInitImpl<CNscTree>,
                    public IPersistPropertyBagImpl<CNscTree>,
                    public IQuickActivateImpl<CNscTree>,
                    public IOleControlImpl<CNscTree>,
                    public IOleObjectImpl<CNscTree>,
                    public IOleInPlaceActiveObjectImpl<CNscTree>,
                    public IViewObjectExImpl<CNscTree>,
                    public IOleInPlaceObjectWindowlessImpl<CNscTree>,
                    public ISpecifyPropertyPagesImpl<CNscTree>,
                    public IConnectionPointImpl<CNscTree, &DIID_DShellNameSpaceEvents, CComDynamicUnkArray>,
                    public IConnectionPointContainerImpl<CNscTree>,
                    public IShellChangeNotify, 
                    public CDelegateDropTarget, 
                    public CNotifySubclassWndProc, 
                    public CObjectWithSite,
                    public INSCTree2, 
                    public IWinEventHandler, 
                    public IShellBrowser,
                    public IFolderFilterSite
{
public:

DECLARE_WND_CLASS(TEXT("NamespaceOC Window"))
DECLARE_NO_REGISTRY();

BEGIN_COM_MAP(CNscTree)
    COM_INTERFACE_ENTRY(IShellNameSpace)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IShellChangeNotify)         // IID_IShellChangeNotify
    COM_INTERFACE_ENTRY(INSCTree)                   // IID_INSCTree
    COM_INTERFACE_ENTRY(INSCTree2)                  // IID_INSCTree2
    COM_INTERFACE_ENTRY(IShellFavoritesNameSpace)   // IID_IShellFavoritesNameSpace
    COM_INTERFACE_ENTRY(IShellNameSpace)            // IID_IShellNameSpace
    COM_INTERFACE_ENTRY(IWinEventHandler)           // IID_IWinEventHandler
    COM_INTERFACE_ENTRY(IDropTarget)                // IID_IDropTarget
    COM_INTERFACE_ENTRY(IObjectWithSite)            // IID_IObjectWithSite
    COM_INTERFACE_ENTRY(IShellBrowser)              // IID_IShellBrowser
    COM_INTERFACE_ENTRY(IFolderFilterSite)          // IID_IFolderFilterSite

END_COM_MAP()

BEGIN_PROPERTY_MAP(CNscTree)
    PROP_ENTRY("Root", DISPID_ROOT, CLSID_NULL)
    PROP_ENTRY("EnumOptions", DISPID_ENUMOPTIONS, CLSID_NULL)
    PROP_ENTRY("Flags", DISPID_FLAGS, CLSID_NULL)
    PROP_ENTRY("Depth", DISPID_DEPTH, CLSID_NULL)
    PROP_ENTRY("Mode", DISPID_MODE, CLSID_NULL)
    PROP_ENTRY("TVFlags", DISPID_TVFLAGS, CLSID_NULL)
    PROP_ENTRY("Columns", DISPID_NSCOLUMNS, CLSID_NULL)
END_PROPERTY_MAP()

BEGIN_MSG_MAP(CNscTree)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(CWM_GETISHELLBROWSER, OnGetIShellBrowser)
END_MSG_MAP()

BEGIN_CONNECTION_POINT_MAP(CNscTree)
    CONNECTION_POINT_ENTRY(DIID_DShellNameSpaceEvents)
END_CONNECTION_POINT_MAP()

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite);

    // INSCTree
    STDMETHODIMP CreateTree(HWND hwndParent, DWORD dwStyles, HWND *phwnd);         // create window of tree view.
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlRoot, DWORD grfFlags, DWORD dwFlags);           // init the treeview control with data.
    STDMETHODIMP ShowWindow(BOOL fShow);
    STDMETHODIMP Refresh(void);
    STDMETHODIMP GetSelectedItem(LPITEMIDLIST * ppidl, int nItem);
    STDMETHODIMP SetSelectedItem(LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert, int nItem);
    STDMETHODIMP GetNscMode(UINT * pnMode) { *pnMode = _mode; return S_OK;};
    STDMETHODIMP SetNscMode(UINT nMode) { _mode = nMode; return S_OK;};
    STDMETHODIMP GetSelectedItemName(LPWSTR pszName, DWORD cchName);
    STDMETHODIMP BindToSelectedItemParent(REFIID riid, void **ppv, LPITEMIDLIST *ppidl);
    STDMETHODIMP_(BOOL) InLabelEdit(void) {return _fInLabelEdit;};
    // INSCTree2
    STDMETHODIMP RightPaneNavigationStarted(LPITEMIDLIST pidl);
    STDMETHODIMP RightPaneNavigationFinished(LPITEMIDLIST pidl);
    STDMETHODIMP CreateTree2(HWND hwndParent, DWORD dwStyle, DWORD dwExStyle, HWND *phwnd);         // create window of tree view.

    // IShellBrowser (Hack)
    STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) {return E_NOTIMPL;};
    STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd) {return E_NOTIMPL;};
    STDMETHODIMP RemoveMenusSB(HMENU hmenuShared) {return E_NOTIMPL;};
    STDMETHODIMP SetStatusTextSB(LPCOLESTR lpszStatusText) {return E_NOTIMPL;};
    STDMETHODIMP EnableModelessSB(BOOL fEnable) {return E_NOTIMPL;};
    STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID) {return E_NOTIMPL;};
    STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags) {return E_NOTIMPL;};
    STDMETHODIMP GetViewStateStream(DWORD grfMode, LPSTREAM  *ppStrm) {return E_NOTIMPL; };
    STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd) {return E_NOTIMPL;};
    STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret) {return E_NOTIMPL;};
    STDMETHODIMP QueryActiveShellView(struct IShellView ** ppshv) {return E_NOTIMPL;};
    STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv) {return E_NOTIMPL;};
    STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags) {return E_NOTIMPL;};
    //STDMETHODIMP GetWindow(HWND * lphwnd) {return E_NOTIMPL;}; //already defined in IOleWindow
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) {return E_NOTIMPL;};

    // IWinEventHandler
    STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    STDMETHODIMP IsWindowOwner(HWND hwnd) {return E_NOTIMPL;};

    // IShellChangeNotify
    STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // IShellNameSpace
    STDMETHODIMP get_SubscriptionsEnabled(VARIANT_BOOL *pVal);
    STDMETHODIMP Import() {return DoImportOrExport(TRUE);};
    STDMETHODIMP Export() {return DoImportOrExport(FALSE);};
    STDMETHODIMP Synchronize();
    STDMETHODIMP NewFolder();
    STDMETHODIMP ResetSort();
    STDMETHODIMP MoveSelectionDown() {MoveItemUpOrDown(FALSE); return S_OK;};
    STDMETHODIMP MoveSelectionUp() {MoveItemUpOrDown(TRUE); return S_OK;};
    STDMETHODIMP InvokeContextMenuCommand(BSTR strCommand);
    STDMETHODIMP MoveSelectionTo();
    STDMETHODIMP CreateSubscriptionForSelection(/*[out, retval]*/ VARIANT_BOOL *pBool);    
    STDMETHODIMP DeleteSubscriptionForSelection(/*[out, retval]*/ VARIANT_BOOL *pBool);    
    STDMETHODIMP get_EnumOptions(LONG *pVal);
    STDMETHODIMP put_EnumOptions(LONG lVal);
    STDMETHODIMP get_SelectedItem(IDispatch **ppItem);
    STDMETHODIMP put_SelectedItem(IDispatch *pItem);
    STDMETHODIMP get_Root(VARIANT *pvar);
    STDMETHODIMP put_Root(VARIANT pItem);
    STDMETHODIMP SetRoot(BSTR bstrRoot);
    STDMETHODIMP put_Depth(int iDepth){ return S_OK;};
    STDMETHODIMP get_Depth(int *piDepth){ *piDepth = 1; return S_OK;};
    STDMETHODIMP put_Mode(UINT uMode);
    STDMETHODIMP get_Mode(UINT *puMode) { *puMode = _mode; return S_OK;};
    STDMETHODIMP put_Flags(DWORD dwFlags);
    STDMETHODIMP get_Flags(DWORD *pdwFlags) { *pdwFlags = _dwFlags; return S_OK;};
    STDMETHODIMP put_TVFlags(DWORD dwFlags) { _dwTVFlags = dwFlags; return S_OK;};
    STDMETHODIMP get_TVFlags(DWORD *dwFlags) { *dwFlags = _dwTVFlags; return S_OK;};
    STDMETHODIMP put_Columns(BSTR bstrColumns);
    STDMETHODIMP get_Columns(BSTR *bstrColumns);
    STDMETHODIMP get_CountViewTypes(int *piTypes);
    STDMETHODIMP SetViewType(int iType);
    STDMETHODIMP SelectedItems(IDispatch **ppItems);
    STDMETHODIMP Expand(VARIANT var, int iDepth);
    //STDMETHODIMP get_ReadyState(READYSTATE *plReady);
    STDMETHODIMP UnselectAll();

    // IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    // IOleInPlaceObject
    STDMETHODIMP SetObjectRects(LPCRECT prcPos, LPCRECT prcClip);

    // IOleInPlaceActiveObjectImpl
    STDMETHODIMP TranslateAccelerator(MSG *pMsg);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd);

    // IOleObject
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // CDelegateDropTarget
    virtual HRESULT GetWindowsDDT(HWND * phwndLock, HWND * phwndScroll);
    virtual HRESULT HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD * pdwDropEffect);
    virtual HRESULT GetObjectDDT(DWORD_PTR dwId, REFIID riid, void ** ppvObj);
    virtual HRESULT OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    // IFolderFilterSite
    STDMETHODIMP SetFilter(IUnknown* punk);

    CNscTree();

    // override ATL default handlers
    HRESULT OnDraw(ATL_DRAWINFO& di);
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnGetIShellBrowser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);
    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR pszWindowName = NULL, 
                DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                DWORD dwExStyle = 0, UINT nID = 0);
    HRESULT GetEventInfo(IShellFolder *psf, LPCITEMIDLIST pidl,
                         UINT *pcItems, LPWSTR pszUrl, DWORD cchUrl, 
                         UINT *pcVisits, LPWSTR pszLastVisited, BOOL *pfAvailableOffline);


protected:
    ~CNscTree();

    class CSelectionContextMenu : public IContextMenu2
    {
        friend CNscTree;
    protected:
        // IUnknown
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void) ;
        STDMETHODIMP_(ULONG) Release(void);

        // IContextMenu
        STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
        STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
        STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,
                                UINT * pwRes, LPSTR pszName, UINT cchMax) { return E_NOTIMPL; };
        // IContextMenu2
        STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);


    protected:
        ~CSelectionContextMenu();
        IContextMenu *_QuerySelection();

        IContextMenu *_pcmSelection;
        IContextMenu2 *_pcm2Selection;
        ULONG         _ulRefs;
    public:
        CSelectionContextMenu() : _pcmSelection(NULL),_ulRefs(0) {}
    };

    friend class CSelectionContextMenu;
    CSelectionContextMenu _scm;

private:
    void _FireFavoritesSelectionChange(long cItems, long hItem, BSTR strName,
        BSTR strUrl, long cVisits, BSTR strDate, long fAvailableOffline);
    HRESULT _InvokeContextMenuCommand(BSTR strCommand);
    void _InsertMarkedChildren(HTREEITEM htiParent, LPCITEMIDLIST pidlParent, IInsertItem *pii);
    HRESULT _GetEnumFlags(IShellFolder *psf, LPCITEMIDLIST pidlFolder, DWORD *pgrfFlags, HWND *phwnd);
    HRESULT _GetEnum(IShellFolder *psf, LPCITEMIDLIST pidlFolder, IEnumIDList **ppenum);
    BOOL _ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
    HWND _CreateTreeview();
    HWND _CreateHeader();
    void _SubClass(LPCITEMIDLIST pidlRoot);
    void _UnSubClass(void);
    int _GetChildren(IShellFolder *psf, LPCITEMIDLIST pidl, ULONG ulAttrs);
    HRESULT _LoadSF(HTREEITEM htiRoot, LPCITEMIDLIST pidl, BOOL * pfOrdered);
    HRESULT _StartBackgroundEnum(HTREEITEM htiRoot, LPCITEMIDLIST pidl,
        BOOL * pfOrdered, BOOL fUpdatePidls);
    void _GetDefaultIconIndex(LPCITEMIDLIST pidl, ULONG ulAttrs, TVITEM *pitem, BOOL fFolder);
    BOOL _LabelEditIsNewValueValid(TV_DISPINFO *ptvdi);
    LRESULT _OnEndLabelEdit(TV_DISPINFO *ptvdi);
    LRESULT _OnBeginLabelEdit(TV_DISPINFO *ptvdi);
    LPITEMIDLIST _CacheParentShellFolder(HTREEITEM hti, LPITEMIDLIST pidl);
    BOOL _CacheShellFolder(HTREEITEM hti);
    void _CacheDetails();
    void _ReleaseRootFolder(void );
    void _ReleasePidls(void);
    void _ReleaseCachedShellFolder(void);
    void _TvOnHide();
    void _TvOnShow();
    BOOL _ShouldAdd(LPCITEMIDLIST pidl);
    void _ReorderChildren(HTREEITEM htiParent);
    void _Sort(HTREEITEM hti, IShellFolder *psf);
    void MoveItemUpOrDown(BOOL fUp);
    LPITEMIDLIST _FindHighestDeadItem(LPCITEMIDLIST pidl);
    void _RemoveDeadBranch(LPCITEMIDLIST pidl);
    HRESULT CreateNewFolder(HTREEITEM hti);
    BOOL MoveItemsIntoFolder(HWND hwndParent);
    HRESULT DoImportOrExport(BOOL fImport);
    HRESULT DoSubscriptionForSelection(BOOL fCreate);
    LRESULT _OnNotify(LPNMHDR pnm);
    HRESULT _OnPaletteChanged(WPARAM wPAram, LPARAM lParam);
    HRESULT _OnWindowCleanup(void);
    HRESULT _HandleWinIniChange(void);
    HRESULT _EnterNewFolderEditMode(LPCITEMIDLIST pidlNewFolder);
    HTREEITEM _AddItemToTree(HTREEITEM htiParent, LPITEMIDLIST pidl, int cChildren, int iPos, 
        HTREEITEM htiAfter = TVI_LAST, BOOL fCheckForDups = TRUE, BOOL fMarked = FALSE);
    HTREEITEM _FindChild(IShellFolder *psf, HTREEITEM htiParent, LPCITEMIDLIST pidlChild);
    LPITEMIDLIST _GetFullIDList(HTREEITEM hti);
    ITEMINFO *_GetTreeItemInfo(HTREEITEM hti);
    PORDERITEM _GetTreeOrderItem(HTREEITEM hti);
    BOOL _SetRoot(LPCITEMIDLIST pidlRoot, int iExpandDepth, LPCITEMIDLIST pidlExpandTo, NSSR_FLAGS flags);
    DWORD _SetStyle(DWORD dwStyle);
    DWORD _SetExStyle(DWORD dwExStyle);
    void _OnGetInfoTip(NMTVGETINFOTIP *pnm);
    LRESULT _OnSetCursor(NMMOUSE* pnm);
    void _ApplyCmd(HTREEITEM hti, IContextMenu *pcm, UINT cmdId);
    HRESULT _QuerySelection(IContextMenu **ppcm, HTREEITEM *phti);
    HMENU   _CreateContextMenu(IContextMenu *pcm, HTREEITEM hti);
    LRESULT _OnContextMenu(short x, short y);
    void _OnBeginDrag(NM_TREEVIEW *pnmhdr);
    void _OnChangeNotify(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
    HRESULT _OnDeleteItem(NM_TREEVIEW *pnm);
    void _OnGetDisplayInfo(TV_DISPINFO *pnm);
    HRESULT _ChangePidlRoot(LPCITEMIDLIST pidl);
    BOOL _IsExpandable(HTREEITEM hti);
    BOOL _OnItemExpandingMsg(NM_TREEVIEW *pnm);
    BOOL _OnItemExpanding(HTREEITEM htiToActivate, UINT action, BOOL fExpandedOnce, BOOL fIsExpandPartial);
    BOOL _OnSelChange(BOOL fMark);
    void _OnSetSelection();
    BOOL _FIsItem(IShellFolder * psf, LPCITEMIDLIST pidlTarget, HTREEITEM hti);
    HTREEITEM _FindFromRoot(HTREEITEM htiRoot, LPCITEMIDLIST pidl);
    HRESULT _OnSHNotifyRename(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNew);
    HRESULT _OnSHNotifyDelete(LPCITEMIDLIST pidl, int *piPosDeleted, HTREEITEM *phtiParent);
    void _OnSHNotifyUpdateItem(LPCITEMIDLIST pidl, LPITEMIDLIST pidlReal);
    HRESULT _OnSHNotifyUpdateDir(LPCITEMIDLIST pidl);
    HRESULT _OnSHNotifyCreate(LPCITEMIDLIST pidl, int iPosition, HTREEITEM htiParent);
    void _OnSHNotifyOnlineChange(HTREEITEM htiRoot, BOOL fGoingOnline);
    void _OnSHNotifyCacheChange(HTREEITEM htiRoot, DWORD_PTR dwChanged);

    HRESULT _IdlRealFromIdlSimple(IShellFolder * psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST * ppidlReal);
    void _DtRevoke();
    void _DtRegister();
    int _TreeItemIndexInHDPA(HDPA hdpa, IShellFolder *psfParent, HTREEITEM hti, int iReverseStart);
    BOOL _IsItemExpanded(HTREEITEM hti);
    HRESULT _UpdateDir(HTREEITEM hti, BOOL bUpdatePidls);

    HRESULT _GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSHELLDETAILS pdetails);
    HRESULT _ParentFromItem(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild);
    HRESULT _CompareIDs(IShellFolder *psf, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
    static int CALLBACK _TreeCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
    static LRESULT CALLBACK s_SubClassTreeWndProc(
                                  HWND hwnd, UINT uMsg, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    LRESULT _SubClassTreeWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _InitHeaderInfo();
    HRESULT    _Expand(LPCITEMIDLIST pidl, int iDepth);
    HTREEITEM  _ExpandToItem(LPCITEMIDLIST pidl, BOOL fCreate = TRUE, BOOL fReinsert = FALSE);
    HRESULT    _ExpandNode(HTREEITEM htiParent, int iCode, int iDepth);

    HRESULT _PutRootVariant(VARIANT *pvar);
    BOOL _IsItemNameInTree(LPCITEMIDLIST pidl);
    COLORREF _GetRegColor(COLORREF clrDefault, LPCTSTR pszName);
    void _AssignPidl(PORDERITEM poi, LPITEMIDLIST pidlNew);

protected:
    // used for background thread icon + draw info extraction
    static void s_NscIconCallback(CNscTree *pns, UINT_PTR uId, int iIcon, int iOpenIcon, DWORD dwFlags, UINT uMagic);
    static void s_NscOverlayCallback(CNscTree *pns, UINT_PTR uId, int iOverlayIndex, UINT uMagic);

    // used for background enumeration
    static void s_NscEnumCallback(CNscTree *pns, LPITEMIDLIST pidl, UINT_PTR uId, DWORD dwSig, HDPA hdpa, 
                                    LPITEMIDLIST pidlExpandingTo, DWORD dwOrderSig, 
                                    UINT uDepth, BOOL fUpdate, BOOL fUpdatePidls);

private:
    void _EnumBackgroundDone(NSC_BKGDENUMDONEDATA *pbedd);

#ifdef DEBUG
    void TraceHTREE(HTREEITEM hti, LPCTSTR pszDebugMsg);
    void TracePIDL(LPCITEMIDLIST pidl, LPCTSTR pszDebugMsg);
    void TracePIDLAbs(LPCITEMIDLIST pidl, LPCTSTR pszDebugMsg);
#endif

    static int CALLBACK _TreeOrder(LPARAM lParam1, LPARAM lParam2
                                            , LPARAM lParamSort);
    BOOL _IsOrdered(HTREEITEM htiRoot);
    void _SelectPidl(LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert = FALSE);
    void _SelectNoExpand(HWND hwnd, HTREEITEM hti);
    HRESULT _InsertChild(HTREEITEM htiParent, IShellFolder *psfParent, LPCITEMIDLIST pidlChild, BOOL fExpand, BOOL fSimpleToRealIDL, int iPosition, HTREEITEM *phti);
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);

    IStream *GetOrderStream(LPCITEMIDLIST pidl, DWORD grfMode);
    HRESULT _PopulateOrderList(HTREEITEM htiRoot);
    void _FreeOrderList(HTREEITEM htiRoot);

    void _Dropped(void);

    LRESULT _OnCDNotify(LPNMCUSTOMDRAW pnm);
    BOOL _IsTopParentItem(HTREEITEM hti);
    BOOL _MoveNode(int _iDragSrc, int iNewPos, LPITEMIDLIST pidl);
    void _TreeInvalidateItemInfo(HTREEITEM hItem, UINT mask);
    void _InvalidateImageIndex(HTREEITEM hItem, int iImage);

    void _DrawItem(HTREEITEM hti, TCHAR * psz, HDC hdc, LPRECT prc, 
        DWORD dwFlags, int iLevel, COLORREF clrbk, COLORREF clrtxt);
    void _DrawIcon(HTREEITEM hti,HDC hdc, int iLevel, RECT *prc, DWORD dwFlags);
    void _DrawActiveBorder(HDC hdc, LPRECT prc);

    void _UpdateActiveBorder(HTREEITEM htiSelected);
    void _MarkChildren(HTREEITEM htiParent, BOOL fOn);
    BOOL _IsMarked(HTREEITEM hti);

    void _UpdateItemDisplayInfo(HTREEITEM hti);
    void _TreeSetItemState(HTREEITEM hti, UINT stateMask, UINT state);
    void _TreeNukeCutState();
    BOOL _IsChannelFolder(HTREEITEM hti);

    BOOL _LoadOrder(HTREEITEM hti, LPCITEMIDLIST pidl, IShellFolder* psf, HDPA* phdpa);

    HWND                _hwndParent;            // parent window to notify
    HWND                _hwndTree;              // tree or combo box
    HWND                _hwndNextViewer;
    HWND                _hwndHdr;
    DWORD               _style;
    DWORD               _dwExStyle;
    DWORD              _grfFlags;              // Flags to filter what goes in the tree.
    DWORD              _dwFlags;               // Behavior Flags (NSS_*)
    DWORD              _dwTVFlags;
    BITBOOL             _fInitialized : 1;      // Has INSCTree::Initialize() been called at least once yet?
    BITBOOL             _fIsSelectionCached: 1; // If the WM_NCDESTROY has been processed, then we squired the selected pidl(s) in _pidlSelected
    BITBOOL             _fCacheIsDesktop : 1;   // state flags
    BITBOOL             _fAutoExpanding : 1;    // tree is auto-expanding
    BITBOOL             _fDTRegistered:1;       // have we registered as droptarget?
    BITBOOL             _fpsfCacheIsTopLevel : 1;   // is the cached psf a root channel ?
    BITBOOL             _fDragging : 1;         // one o items being dragged
    BITBOOL             _fStartingDrag : 1;     // starting to drag an item
    BITBOOL             _fDropping : 1;         // a drop occurred in the nsc
    BITBOOL             _fInSelectPidl : 1;     // we are performing a SelectPidl
    BITBOOL             _fInserting : 1;        // we're on the insertion edge.
    BITBOOL             _fInsertBefore : 1;     // a drop occurred in the nsc
    BITBOOL             _fClosing : 1;          // are we closing ?
    BITBOOL             _fOkToRename : 1;           // are we right clicking.
    BITBOOL             _fInLabelEdit:1;
    BITBOOL             _fCollapsing:1;         // is a node collapsing.
    BITBOOL             _fOnline:1;             // is inet online?
    BITBOOL             _fWeChangedOrder:1;     // did we change the order?
    BITBOOL             _fHandlingShellNotification:1; //are we handing a shell notification?
    BITBOOL             _fSingleExpand:1;       // are we in single expand mode
    BITBOOL             _fHasFocus:1;           // does nsc have the focus?
    BITBOOL             _fIgnoreNextSelChange:1;// hack to get around treeview keydown bug
    BITBOOL             _fIgnoreNextItemExpanding:1; //hack to get around annoying single expand behavior
    BITBOOL             _fInExpand:1;           // TRUE while we are doing delayed expansion (called back from the secondary thread)
    BITBOOL             _fSubClassed:1;         // Have we subclassed the window yet?
    BITBOOL             _fAsyncDrop:1;          // async drop from outside or another inside folder.
    BITBOOL             _fOrdered:1;              // is root folder ordered.
    BITBOOL             _fExpandNavigateTo:1;     //  Do we need to expand when the right pane navigation comes back?
    BITBOOL             _fNavigationFinished:1;   // TRUE when the right hand pane has finished its navigation
    BITBOOL             _fSelectFromMouseClick:1; //  Did we use the mouse to select the item? (as opposed to the keyboard)
    BITBOOL             _fShouldShowAppStartCursor:1; // TRUE to show the appstart cursor while there is a background task going
    BOOL                _fUpdate; // true if we are enumerating so that we can update the tree (refresh)
    int                 _cxOldWidth;
    UINT                _mode;
    UINT                _csidl;
    IContextMenu*       _pcm;                  // context menu currently being displayed
    IContextMenu2*      _pcmSendTo;            // deal with send to hack so messages tgo right place.
    LPITEMIDLIST        _pidlRoot;
    LPITEMIDLIST        _pidlSelected;          // Valid if _fIsSelectionCached is true.  Used for INSCTree::GetSelectedItem() after tree is gone.
    HTREEITEM           _htiCache;              // tree item associated with Current shell folder
    IShellFolder*       _psfCache;             // cache of the last IShellFolder I needed...
    IShellFolder2*      _psf2Cache;             // IShellDetails2 for _psfISD2Cache
    IFolderFilter*      _pFilter;    
    INamespaceProxy*    _pnscProxy;
    ULONG               _ulDisplayCol;          // Default display col for _psfCache
    ULONG               _ulSortCol;             // Default sort col for _psfCache
    ULONG               _nChangeNotifyID;       // SHChangeNotify registration ID
    HDPA                _hdpaOrd;               // dpa order for current shell folder.
// drop target privates
    HTREEITEM           _htiCur;                // current tree item (dragging over)
    DWORD               _dwLastTime;
    DWORD               _dwEffectCur;           // current drag effect
    int                 _iDragSrc;              // dragging from this pos.
    int                 _iDragDest;             // destination drag point
    HTREEITEM           _htiDropInsert;         // parent of inserted item.
    HTREEITEM           _htiDragging;           // the tree item being dragged during D&D.
    HTREEITEM           _htiCut;                // Used for Clipboard and Visuals    
    LPITEMIDLIST        _pidlDrag;              // pidl of item being dragged from within.
    HTREEITEM           _htiFolderStart;        // what folder do we start in.
    HICON               _hicoPinned;            // drawn over items that are sticky in the inet cache
    HWND                _hwndDD;                // window to draw custom drag cursors on.
    HTREEITEM           _htiActiveBorder;       // the folder to draw the active border around
    CWinInetNotify      _inetNotify;            // hooks up wininet notifications (online/offline, etc)
    IShellTaskScheduler* _pTaskScheduler;       // background task icon/info extracter
    int                 _iDefaultFavoriteIcon;  // index of default favorite icon in system image list
    int                 _iDefaultFolderIcon;    // index of default folder icon in system image list
    HTREEITEM           _htiRenaming;           // hti of item being renamed in rename mode
    LPITEMIDLIST        _pidlNewFolderParent;   // where the new folder will be arriving (when user picks "Create New Folder")

    DWORD               _dwSignature;           // Signature used to track items in the tree, even after they've moved
    DWORD               _dwOrderSig;            // Signature that lets us detect changes in ordering of items
    BYTE                _bSynchId;              // magic number for validating tree during background icon extraction
    HDPA                _hdpaColumns;           // visible columns when NSS_HEADER is set
    HDPA                _hdpaViews; // ishellfolderviewtype view pidls

    LPITEMIDLIST        _pidlExpandingTo;       // During expansion of the tree, this is the pidl of the item we want to reach.
    LPITEMIDLIST        _pidlNavigatingTo;      // This is the pidl to which the right pane is currently navigating to
    UINT                _uDepth;                // depth of recursive expansion
    CRITICAL_SECTION    _csBackgroundData;      // protects the data from the background tasks.
    NSC_BKGDENUMDONEDATA * _pbeddList;          // List of tasks that are done.

    BITBOOL             _fShowCompColor:1;      // Show compressed files in different color

    enum 
    {
        RSVIDM_CONTEXT_START    = RSVIDM_LAST + 1,        // our private menu items end here
    };

};

int DPADeleteItemCB(void *pItem, void *pData);
int DPADeletePidlsCB(void *pItem, void *pData);
// util macros.

#define GetPoi(p)   (((ITEMINFO *)p)->poi)
#define GetPii(p)   ((ITEMINFO *)p)

#include "nscband.h"

#endif  // _NSC_C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\nsc.cpp ===
#include "priv.h"
#include "nsc.h"
#include "resource.h"
#include "subsmgr.h"
#include "favorite.h" //for IsSubscribed()
#include "chanmgr.h"
#include "chanmgrp.h"
#include <mstask.h>    // TASK_TRIGGER
#include "dpastuff.h"
#include <findhlp.h>
#include <ntquery.h>    // defines some values used for fmtid and pid
#include "nsctask.h"
#include <mluisupp.h>
#include <varutil.h>
#include <dobjutil.h>

#define IDH_ORGFAVS_LIST    50490   // defined in iehelpid.h (can't include due to conflicts)

#define TF_NSC      0x00002000

#define ID_NSC_SUBCLASS 359
#define ID_NSCTREE  (DWORD)'NSC'

#define IDT_SELECTION 135

#ifndef UNIX
#define DEFAULT_PATHSTR "C:\\"
#else
#define DEFAULT_PATHSTR "/"
#endif

#define LOGOGAP 2   // all kinds of things 
#define DYITEM  17
#define DXYFRAMESEL 1                             
const DEFAULTORDERPOSITION = 32000;

// HTML displays hard scripting errors if methods on automation interfaces
// return FAILED().  This macro will fix these.
#define FIX_SCRIPTING_ERRORS(hr)        (FAILED(hr) ? S_FALSE : hr)

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

DEFINE_SCID(SCID_NAME,          PSGUID_STORAGE, PID_STG_NAME); // defined in shell32!prop.cpp
DEFINE_SCID(SCID_ATTRIBUTES,    PSGUID_STORAGE, PID_STG_ATTRIBUTES);
DEFINE_SCID(SCID_TYPE,          PSGUID_STORAGE, PID_STG_STORAGETYPE);
DEFINE_SCID(SCID_SIZE,          PSGUID_STORAGE, PID_STG_SIZE);
DEFINE_SCID(SCID_CREATETIME,    PSGUID_STORAGE, PID_STG_CREATETIME);

#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid))

HRESULT CheckForExpandOnce(HWND hwndTree, HTREEITEM hti);

// from util.cpp
// same guid as in bandisf.cpp
// {F47162A0-C18F-11d0-A3A5-00C04FD706EC}
static const GUID TOID_ExtractImage = { 0xf47162a0, 0xc18f, 0x11d0, { 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec } };
//from nsctask.cpp
EXTERN_C const GUID TASKID_IconExtraction; // = { 0xeb30900c, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };


BOOL IsChannelFolder(LPCWSTR pwzPath, LPWSTR pwzChannelURL);

typedef struct
{
    DWORD   iIcon     : 12;
    DWORD   iOpenIcon : 12;
    DWORD   nFlags    : 4;
    DWORD   nMagic    : 4;
} NSC_ICONCALLBACKINFO;

typedef struct
{
    DWORD   iOverlayIndex : 28;
    DWORD   nMagic       : 4;
} NSC_OVERLAYCALLBACKINFO;

struct NSC_BKGDENUMDONEDATA
{
    ~NSC_BKGDENUMDONEDATA()
    {
        ILFree(pidl);
        ILFree(pidlExpandingTo);
        OrderList_Destroy(&hdpa, TRUE);
    }

    NSC_BKGDENUMDONEDATA * pNext;

    LPITEMIDLIST pidl;
    HTREEITEM    hitem;
    DWORD        dwSig;
    HDPA         hdpa;
    LPITEMIDLIST pidlExpandingTo;
    DWORD        dwOrderSig;
    UINT         uDepth;
    BOOL         fUpdate;
    BOOL         fUpdatePidls;
};

//if you don't remove the selection, treeview will expand everything below the current selection
void TreeView_DeleteAllItemsQuickly(HWND hwnd)
{
    TreeView_SelectItem(hwnd, NULL);
    TreeView_DeleteAllItems(hwnd);
}

#define NSC_CHILDREN_REMOVE     0
#define NSC_CHILDREN_ADD        1
#define NSC_CHILDREN_FORCE      2
#define NSC_CHILDREN_CALLBACK   3

void TreeView_SetChildren(HWND hwnd, HTREEITEM hti, UINT uFlag)
{
    TV_ITEM tvi;
    tvi.mask = TVIF_CHILDREN | TVIF_HANDLE;   // only change the number of children
    tvi.hItem = hti;

    switch (uFlag)
    {
    case NSC_CHILDREN_REMOVE:
        tvi.cChildren = IsOS(OS_WHISTLERORGREATER) ? I_CHILDRENAUTO : 0;
        break;
        
    case NSC_CHILDREN_ADD:
        tvi.cChildren = IsOS(OS_WHISTLERORGREATER) ? I_CHILDRENAUTO : 1;
        break;

    case NSC_CHILDREN_FORCE:
        tvi.cChildren = 1;
        break;

    case NSC_CHILDREN_CALLBACK:
        tvi.cChildren = I_CHILDRENCALLBACK;
        break;

    default:
        ASSERTMSG(FALSE, "wrong parameter passed to TreeView_SetChildren in nsc");
        break;
    }

    TreeView_SetItem(hwnd, &tvi);
}

void TreeView_DeleteChildren(HWND hwnd, HTREEITEM hti)
{
    for (HTREEITEM htiTemp = TreeView_GetChild(hwnd, hti); htiTemp;)
    {
        HTREEITEM htiDelete = htiTemp;
        htiTemp = TreeView_GetNextSibling(hwnd, htiTemp);
        TreeView_DeleteItem(hwnd, htiDelete);
    }
}

BOOL IsParentOfItem(HWND hwnd, HTREEITEM htiParent, HTREEITEM htiChild)
{
    for (HTREEITEM hti = htiChild; (hti != TVI_ROOT) && (hti != NULL); hti = TreeView_GetParent(hwnd, hti))
        if (hti == htiParent)
            return TRUE;

    return FALSE;
}

STDAPI CNscTree_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr;
    CComObject<CNscTree> *pnsct;

    CComObject<CNscTree>::CreateInstance(&pnsct);
    if (pnsct)
    {
        hr = S_OK;
        *ppunk = pnsct->GetUnknown();
        ASSERT(*ppunk);
        (*ppunk)->AddRef(); // atl doesn't addref in create instance or getunknown about 
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

INSCTree2 *CNscTree_CreateInstance(void)
{
    INSCTree2 *pnsct = NULL;
    IUnknown *punk;
    if (SUCCEEDED(CNscTree_CreateInstance(NULL, &punk, NULL)))
    {
        punk->QueryInterface(IID_PPV_ARG(INSCTree2, &pnsct));
        punk->Release();
    }
    return pnsct;
}

//////////////////////////////////////////////////////////////////////////////

CNscTree::CNscTree() : _iDragSrc(-1), _iDragDest(-1), _fOnline(!SHIsGlobalOffline())
{
    // This object is a COM object so it will always be on the heap.
    // ASSERT that our member variables were zero initialized.
    ASSERT(!_fInitialized);
    ASSERT(!_dwTVFlags);
    ASSERT(!_hdpaColumns);
    ASSERT(!_hdpaViews);
    
    m_bWindowOnly = TRUE;

    _mode = MODE_FAVORITES | MODE_CONTROL; //everyone sets the mode except organize favorites
    _csidl = CSIDL_FAVORITES;
    _dwFlags = NSS_DROPTARGET | NSS_BROWSERSELECT; //this should be default only in control mode
    _grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;

    _ulSortCol = _ulDisplayCol = (ULONG)-1;

    // Enable the notifications from wininet that tell us when to gray items 
    // or update a pinned glyph
    _inetNotify.Enable();

    InitializeCriticalSection(&_csBackgroundData);
}

CNscTree::~CNscTree()
{
    Pidl_Set(&_pidlSelected, NULL);

    // This needs to be destroyed or we leak the icon handle.
    if (_hicoPinned) 
        DestroyIcon(_hicoPinned);

    if (_hdpaColumns)
    {
        DPA_DestroyCallback(_hdpaColumns, DPADeleteItemCB, NULL);
        _hdpaColumns = NULL;
    }

    if (_hdpaViews)
    {
        DPA_DestroyCallback(_hdpaViews, DPADeletePidlsCB, NULL);
        _hdpaViews = NULL;
    }

    EnterCriticalSection(&_csBackgroundData);
    while (_pbeddList)
    {
        // Extract the first element of the list
        NSC_BKGDENUMDONEDATA * pbedd = _pbeddList;
        _pbeddList = pbedd->pNext;
        delete pbedd;
    }
    LeaveCriticalSection(&_csBackgroundData);

    DeleteCriticalSection(&_csBackgroundData);
}

void CNscTree::_ReleaseCachedShellFolder()
{
    ATOMICRELEASE(_psfCache);
    ATOMICRELEASE(_psf2Cache);
    _ulSortCol = _ulDisplayCol = (ULONG)-1;
    _htiCache = NULL;
}

#ifdef DEBUG
void CNscTree::TraceHTREE(HTREEITEM hti, LPCTSTR pszDebugMsg)
{
    TCHAR szDebug[MAX_PATH] = TEXT("Root");

    if (hti != TVI_ROOT && hti)
    {
        TVITEM tvi;
        tvi.mask = TVIF_TEXT | TVIF_HANDLE;
        tvi.hItem = hti;
        tvi.pszText = szDebug;
        tvi.cchTextMax = MAX_PATH;
        TreeView_GetItem(_hwndTree, &tvi);
    }

    TraceMsg(TF_NSC, "NSCBand: %s - %s", pszDebugMsg, szDebug);
}

void CNscTree::TracePIDL(LPCITEMIDLIST pidl, LPCTSTR pszDebugMsg)
{
    TCHAR szDebugName[MAX_URL_STRING] = TEXT("Desktop");
    STRRET str;
    if (_psfCache &&
        SUCCEEDED(_psfCache->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
    {
        StrRetToBuf(&str, pidl, szDebugName, ARRAYSIZE(szDebugName));
    }
    TraceMsg(TF_NSC, "NSCBand: %s - %s", pszDebugMsg, szDebugName);
}

void CNscTree::TracePIDLAbs(LPCITEMIDLIST pidl, LPCTSTR pszDebugMsg)
{
    TCHAR szDebugName[MAX_URL_STRING] = TEXT("Desktop");
    IEGetDisplayName(pidl, szDebugName, SHGDN_FORPARSING);
    TraceMsg(TF_NSC, "NSCBand: %s - %s", pszDebugMsg, szDebugName);
}
#endif

void CNscTree::_AssignPidl(PORDERITEM poi, LPITEMIDLIST pidlNew)
{
    if (poi && pidlNew)
    {    
        // We are assuming that its only replacing the last element...
        ASSERT(ILFindLastID(pidlNew) == pidlNew);

        LPITEMIDLIST pidlParent = ILCloneParent(poi->pidl);
        if (pidlParent)
        { 
            LPITEMIDLIST pidlT = ILCombine(pidlParent, pidlNew);
            if (pidlT)
            {
                Pidl_Set(&poi->pidl, pidlT);
                ILFree(pidlT);
            }
            ILFree(pidlParent);
        }
    }
}

/*****************************************************\
    DESCRIPTION:
        We want to unsubclass/subclass everytime we
    change roots so we get the correct notifications
    for everything in that subtree of the shell
    name space.
\*****************************************************/
void CNscTree::_SubClass(LPCITEMIDLIST pidlRoot)
{
    LPITEMIDLIST pidlToFree = NULL;
    
    if (NULL == pidlRoot)       // (NULL == CSIDL_DESKTOP)
    {
        SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, (LPITEMIDLIST *) &pidlRoot);
        pidlToFree = (LPITEMIDLIST) pidlRoot;
    }
        
    // It's necessary 
    if (!_fSubClassed && pidlRoot)
    {
        if (_SubclassWindow(_hwndTree))
        {
            _RegisterWindow(_hwndTree, pidlRoot,
                SHCNE_DRIVEADD|SHCNE_CREATE|SHCNE_MKDIR|SHCNE_DRIVEREMOVED|
                SHCNE_DELETE|SHCNE_RMDIR|SHCNE_RENAMEITEM|SHCNE_RENAMEFOLDER|
                SHCNE_MEDIAINSERTED|SHCNE_MEDIAREMOVED|SHCNE_NETUNSHARE|SHCNE_NETSHARE|
                SHCNE_UPDATEITEM|SHCNE_UPDATEIMAGE|SHCNE_ASSOCCHANGED|
                SHCNE_UPDATEDIR | SHCNE_EXTENDED_EVENT, 
                ((_mode & MODE_HISTORY) ? SHCNRF_ShellLevel : SHCNRF_ShellLevel | SHCNRF_InterruptLevel));
        }

        ASSERT(_hwndTree);
        _fSubClassed = SetWindowSubclass(_hwndTree, s_SubClassTreeWndProc, 
            ID_NSCTREE, (DWORD_PTR)this);
    }

    if (pidlToFree) // Did we have to alloc our own pidl?
        ILFree(pidlToFree); // Yes.
}


/*****************************************************\
    DESCRIPTION:
        We want to unsubclass/subclass everytime we
    change roots so we get the correct notifications
    for everything in that subtree of the shell
    name space.
\*****************************************************/
void CNscTree::_UnSubClass(void)
{
    if (_fSubClassed)
    {
        _fSubClassed = FALSE;
        RemoveWindowSubclass(_hwndTree, s_SubClassTreeWndProc, ID_NSCTREE);
        _UnregisterWindow(_hwndTree);
        _UnsubclassWindow(_hwndTree);
    }
}


void CNscTree::_ReleasePidls(void)
{
    Pidl_Set(&_pidlRoot, NULL);
    Pidl_Set(&_pidlNavigatingTo, NULL);
}


HRESULT CNscTree::ShowWindow(BOOL fShow)
{
    if (fShow)
        _TvOnShow();
    else
        _TvOnHide();

    return S_OK;
}


HRESULT CNscTree::SetSite(IUnknown *punkSite)
{
    ATOMICRELEASE(_pnscProxy);

    if (!punkSite)
    {
        // We need to prepare to go away and squirel
        // away the currently selected pidl(s) because
        // the caller may call INSCTree::GetSelectedItem()
        // after the tree is gone.
        _OnWindowCleanup();
    }
    else
    {
        punkSite->QueryInterface(IID_PPV_ARG(INamespaceProxy, &_pnscProxy));
    }
    
    return CObjectWithSite::SetSite(punkSite);
}

DWORD BackgroundDestroyScheduler(void *pvData)
{
    IShellTaskScheduler *pTaskScheduler = (IShellTaskScheduler *)pvData;

    pTaskScheduler->Release();
    return 0;
}

EXTERN_C const GUID TASKID_BackgroundEnum;

HRESULT CNscTree::_OnWindowCleanup(void)
{
    _fClosing = TRUE;

    if (_hwndTree)
    {
        ASSERT(::IsWindow(_hwndTree));    // make sure it has not been destroyed (it is a child)
        _TvOnHide();

        ::KillTimer(_hwndTree, IDT_SELECTION);
        ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);
        TreeView_DeleteAllItemsQuickly(_hwndTree);
        _UnSubClass();

        _hwndTree = NULL;
    }

    // Squirel away the selected pidl in case the caller asks for it after the
    // treeview is gone.
    if (!_fIsSelectionCached)
    {
        _fIsSelectionCached = TRUE;
        Pidl_Set(&_pidlSelected, NULL);
        GetSelectedItem(&_pidlSelected, 0);
    }

    ATOMICRELEASE(_pFilter);
    
    if (_pTaskScheduler)
    {
        _pTaskScheduler->RemoveTasks(TOID_NULL, ITSAT_DEFAULT_LPARAM, FALSE);
        if (_pTaskScheduler->CountTasks(TASKID_BackgroundEnum) == 0)
        {
            _pTaskScheduler->Release();
        }
        // We need to keep Browseui loaded because we depend on the CShellTaskScheduler
        // to be still around when our background task executes. Browseui can be unloaded by COM when
        // we CoUninit from this thread.
        else if (!SHQueueUserWorkItem(BackgroundDestroyScheduler, (void *)_pTaskScheduler, 0, NULL, NULL, "browseui.dll", 0))
        {
            _pTaskScheduler->Release();
        }

        _pTaskScheduler = NULL;
    }

    _ReleasePidls();
    _ReleaseCachedShellFolder();

    return S_OK;
}

ITEMINFO *CNscTree::_GetTreeItemInfo(HTREEITEM hti)
{
    TV_ITEM tvi;
    
    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
    tvi.hItem = hti;
    if (!TreeView_GetItem(_hwndTree, &tvi))
        return NULL;
    return (ITEMINFO *)tvi.lParam;
}

PORDERITEM CNscTree::_GetTreeOrderItem(HTREEITEM hti)
{
    ITEMINFO *pii = _GetTreeItemInfo(hti);
    return pii ? pii->poi : NULL;
}

// builds a fully qualified IDLIST from a given tree node by walking up the tree
// be sure to free this when you are done!

LPITEMIDLIST CNscTree::_GetFullIDList(HTREEITEM hti)
{
    LPITEMIDLIST pidl, pidlT = NULL;

    if ((hti == TVI_ROOT) || (hti == NULL)) // evil root
    {
        pidlT = ILClone(_pidlRoot);
        return pidlT;
    }
    // now lets get the information about the item
    PORDERITEM poi = _GetTreeOrderItem(hti);
    if (!poi)
    {
        return NULL;
    }
    
    pidl = ILClone(poi->pidl);
    if (pidl && _pidlRoot)
    {
        while ((hti = TreeView_GetParent(_hwndTree, hti)))
        {
            poi = _GetTreeOrderItem(hti);
            if (!poi)
                return pidl;   // will assume I messed up...
            
            if (poi->pidl)
                pidlT = ILCombine(poi->pidl, pidl);
            else 
                pidlT = NULL;
            
            ILFree(pidl);
            pidl = pidlT;
            if (pidl == NULL)
                break;          // outta memory
        }
        if (pidl) 
        {
            // MODE_NORMAL has the pidl root in the tree
            if (_mode != MODE_NORMAL)
            {
                pidlT = ILCombine(_pidlRoot, pidl);    // gotta get the silent root
                ILFree(pidl);
            }
            else
                pidlT = pidl;
        }
    }
    return pidlT;
}


BOOL _IsItemFileSystem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return (SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_FILESYSTEM) == (SFGAO_FOLDER | SFGAO_FILESYSTEM));
}

HTREEITEM CNscTree::_AddItemToTree(HTREEITEM htiParent, LPITEMIDLIST pidl, 
                                   int cChildren, int iPos, HTREEITEM htiAfter, /* = TVI_LAST*/
                                   BOOL fCheckForDups, /* = TRUE */ BOOL fMarked /*= FALSE */)
{
    HTREEITEM htiRet = NULL;

    BOOL fCached;
    
    // So we need to cached the shell folder of the parent item. But, this is a little interesting:
    if (_mode == MODE_NORMAL && htiParent == TVI_ROOT)
    {
        // In "Normal" mode, or "Display root in NSC" mode, there is only 1 item that is parented to
        // TVI_ROOT. So when we do an _AddItemToTree, we need the shell folder that contains _pidlRoot or
        // the Parent of TVI_ROOT.
        fCached = (NULL != _CacheParentShellFolder(htiParent, NULL));
    }
    else
    {
        // But, in the "Favorites, Control or History" if htiParent is TVI_ROOT, then we are not adding _pidlRoot,
        // so we actually need the folder that IS TVI_ROOT.
        fCached = _CacheShellFolder(htiParent);
    }

    if (fCached)
    {
        LPITEMIDLIST pidlNew = ILClone(pidl);
        if (pidlNew)
        {
            PORDERITEM poi = OrderItem_Create(pidlNew, iPos);
            if (poi)
            {
                ITEMINFO *pii = (ITEMINFO *)LocalAlloc(LPTR, sizeof(*pii));
                if (pii)
                {
                    pii->dwSig = _dwSignature++;
                    pii->poi = poi;

                    // For the normal case, we need a relative pidl for this add, but the lParam needs to have a full
                    // pidl (This is so that arbitrary mounting works, as well as desktop case).
                    pidl = pidlNew; //reuse variable
                    if (_mode == MODE_NORMAL && htiParent == TVI_ROOT)
                    {
                        pidl = ILFindLastID(pidl);
                    }

                    if (!fCheckForDups || (NULL == (htiRet = _FindChild(_psfCache, htiParent, pidl))))
                    {
                        TV_INSERTSTRUCT tii;
                        // Initialize item to add with callback for everything
                        tii.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_CHILDREN | TVIF_STATE;
                        tii.hParent = htiParent;
                        tii.hInsertAfter = htiAfter;
                        tii.item.iImage = I_IMAGECALLBACK;
                        tii.item.iSelectedImage = I_IMAGECALLBACK;
                        tii.item.pszText = LPSTR_TEXTCALLBACK;
                        tii.item.cChildren = cChildren;
                        tii.item.lParam = (LPARAM)pii;
                        tii.item.stateMask = TVIS_STATEIMAGEMASK;
                        tii.item.state = (fMarked ? NSC_TVIS_MARKED : 0);

#ifdef DEBUG
                        TracePIDL(pidl, TEXT("Inserting"));
                        TraceMsg(TF_NSC, "_AddItemToTree(htiParent=%#08lx, htiAfter=%#08lx, fCheckForDups=%d, _psfCache=%#08lx)", 
                                    htiParent, htiAfter, fCheckForDups, _psfCache);
                    
#endif // DEBUG

                        pii->fNavigable = !_IsItemFileSystem(_psfCache, pidl);

                        htiRet = TreeView_InsertItem(_hwndTree, &tii);
                        if (htiRet)
                        {
                            pii = NULL;        // don't free
                            poi = NULL;        // don't free
                            pidlNew = NULL;
                        }
                    }
                    if (pii)
                    {
                        LocalFree(pii);
                        pii = NULL;
                    }
                }
                if (poi)
                    OrderItem_Free(poi, FALSE);
            }
            ILFree(pidlNew);
        }
    }
    
    return htiRet;
}

DWORD CNscTree::_SetExStyle(DWORD dwExStyle)
{
    DWORD dwOldStyle = _dwExStyle;

    _dwExStyle = dwExStyle;
    return dwOldStyle;
}

DWORD CNscTree::_SetStyle(DWORD dwStyle)
{
    dwStyle |= TVS_EDITLABELS | TVS_SHOWSELALWAYS | TVS_NONEVENHEIGHT;

    if (dwStyle & WS_HSCROLL)
        dwStyle &= ~WS_HSCROLL;
    else
        dwStyle |= TVS_NOHSCROLL;


    if (TVS_HASLINES & dwStyle)
        dwStyle &= ~TVS_FULLROWSELECT;       // If it has TVS_HASLINES, it can't have TVS_FULLROWSELECT

    // If the parent window is mirrored then the treeview window will inheret the mirroring flag
    // And we need the reading order to be Left to right, which is the right to left in the mirrored mode.

    if (((_mode & MODE_HISTORY) || (MODE_NORMAL == _mode)) && IS_WINDOW_RTL_MIRRORED(_hwndParent)) 
    {
        // This means left to right reading order because this window will be mirrored.
        dwStyle |= TVS_RTLREADING;
    }

    // According to Bug#241601, Tooltips display too quickly. The problem is
    // the original designer of the InfoTips in the Treeview merged the "InfoTip" tooltip and
    // the "I'm too small to display correctly" tooltips. This is really unfortunate because you
    // cannot control the display of these tooltips independantly. Therefore we are turning off
    // infotips in normal mode. (lamadio) 4.7.99
    AssertMsg(_mode != MODE_NORMAL || !(dwStyle & TVS_INFOTIP), TEXT("can't have infotip with normal mode in nsc"));

    DWORD dwOldStyle = _style;
    _style = dwStyle | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VSCROLL | WS_TABSTOP;
    _fSingleExpand = BOOLIFY(_style & TVS_SINGLEEXPAND);

    return dwOldStyle;

}

HRESULT CNscTree::CreateTree(HWND hwndParent, DWORD dwStyles, HWND *phwnd)
{
    return CreateTree2(hwndParent, dwStyles, 0, phwnd);
}

HRESULT CNscTree::CreateTree2(HWND hwndParent, DWORD dwStyle, DWORD dwExStyle, HWND *phwnd)
{
    _fIsSelectionCached = FALSE;
    if (*phwnd)
        return S_OK;                                

    _hwndParent = hwndParent;
    _SetStyle(dwStyle);
    _SetExStyle(dwExStyle);
    *phwnd = _CreateTreeview();
    if (*phwnd == NULL)
    {
        return E_OUTOFMEMORY;
    }
    ::ShowWindow(_hwndTree, SW_SHOW);
    return S_OK;
}

HWND CNscTree::_CreateTreeview()
{
    ASSERT(_hwndTree == NULL);

    LONG lTop = 0;
    RECT rcParent;
    ::GetClientRect(_hwndParent, &rcParent);
#if 0
    if ((_dwFlags & NSS_HEADER) && _hwndHdr)
    {
        RECT rc;

        GetWindowRect(_hwndHdr, &rc);
        lTop = RECTHEIGHT(rc);
    }
#endif

    TCHAR szTitle[40];
    if (_mode & (MODE_HISTORY | MODE_FAVORITES))
    {
        // create with a window title so that msaa can expose name
        int id = (_mode & MODE_HISTORY) ? IDS_BAND_HISTORY : IDS_BAND_FAVORITES;
        MLLoadString(id, szTitle, ARRAYSIZE(szTitle));
    }
    else
    {
        szTitle[0] = 0;
    }

    _hwndTree = CreateWindowEx(0, WC_TREEVIEW, szTitle, _style | WS_VISIBLE,
        0, lTop, rcParent.right, rcParent.bottom, _hwndParent, (HMENU)ID_CONTROL, HINST_THISDLL, NULL);
    
    if (_hwndTree)
    {
        ::SendMessage(_hwndTree, TVM_SETSCROLLTIME, 100, 0);
        ::SendMessage(_hwndTree, CCM_SETUNICODEFORMAT, DLL_IS_UNICODE, 0);
        if (_dwExStyle)
            TreeView_SetExtendedStyle(_hwndTree, _dwExStyle, _dwExStyle);
    }
    else
    {
        TraceMsg(TF_ERROR, "_hwndTree failed");
    }

    return _hwndTree;
} 

UINT GetControlCharWidth(HWND hwnd)
{
    SIZE siz = {0};
    CClientDC       dc(HWND_DESKTOP);

    if (dc.m_hDC)
    {
        HFONT hfOld = dc.SelectFont(FORWARD_WM_GETFONT(hwnd, SendMessage));

        if (hfOld)
        {
            GetTextExtentPoint(dc.m_hDC, TEXT("0"), 1, &siz);

            dc.SelectFont(hfOld);
        }
    }

    return siz.cx;
}

HWND CNscTree::_CreateHeader()
{
    if (!_hwndHdr)
    {
        _hwndHdr = CreateWindowEx(0, WC_HEADER, NULL, HDS_HORZ | WS_CHILD, 0, 0, 0, 0, 
                                  _hwndParent, (HMENU)ID_HEADER, HINST_THISDLL, NULL);
        if (_hwndHdr)
        {
            HD_LAYOUT layout;
            WINDOWPOS wpos;
            RECT rcClient;
            int  cxChar = GetControlCharWidth(_hwndTree);

            layout.pwpos = &wpos;
            ::GetClientRect(_hwndParent, &rcClient);
            layout.prc = &rcClient;
            if (Header_Layout(_hwndHdr, &layout))
            {
                ::MoveWindow(_hwndTree, 0, wpos.cy, RECTWIDTH(rcClient), RECTHEIGHT(rcClient)-wpos.cy, TRUE);
                for (int i = 0; i < DPA_GetPtrCount(_hdpaColumns);)
                {
                    HEADERINFO *phinfo = (HEADERINFO *)DPA_GetPtr(_hdpaColumns, i);
                    if (EVAL(phinfo))
                    {
                        HD_ITEM item;
          
                        item.mask = HDI_TEXT | HDI_FORMAT | HDI_WIDTH;
                        item.pszText = phinfo->szName;
                        item.fmt = phinfo->fmt;
                        item.cxy = cxChar * phinfo->cxChar;

                        if (Header_InsertItem(_hwndHdr, i, &item) == -1)
                        {
                            DPA_DeletePtr(_hdpaColumns, i);
                            LocalFree(phinfo);
                            phinfo = NULL;
                        }
                        else
                        {
                            i++;
                        }
                    }
                }
                if (_hwndTree)
                {
                    HFONT hfont = (HFONT)::SendMessage(_hwndTree, WM_GETFONT, 0, 0);

                    if (hfont)
                        ::SendMessage(_hwndHdr, WM_SETFONT, (WPARAM)hfont, MAKELPARAM(TRUE, 0));
                }
                ::SetWindowPos(_hwndHdr, wpos.hwndInsertAfter, wpos.x, wpos.y,
                             wpos.cx, wpos.cy, wpos.flags | SWP_SHOWWINDOW);
            }
        }
    }

    return _hwndHdr;
}

void CNscTree::_TvOnHide()
{
    _DtRevoke();
    ::SetWindowPos(_hwndTree, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
}

void CNscTree::_TvOnShow()
{
    ::SetWindowPos(_hwndTree, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
    _DtRegister();
}

HRESULT IUnknown_GetAmbientProperty(IUnknown *punk, DISPID dispid, VARTYPE vt, void *pData)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDispatch *pdisp;
        hr = punk->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp));
        if (SUCCEEDED(hr))
        {
            DISPPARAMS dp = {0};
            VARIANT v;
            VariantInit(&v);
            hr = pdisp->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dp, &v, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                VARIANT vDest;
                VariantInit(&vDest);
                // we've got the variant, so now go an coerce it to the type
                // that the user wants.
                //
                hr = VariantChangeType(&vDest, &v, 0, vt);
                if (SUCCEEDED(hr))
                {
                    *((DWORD *)pData) = *((DWORD *)&vDest.lVal);
                    VariantClear(&vDest);
                }
                VariantClear(&v);
            }
            pdisp->Release();
        }
    }
    return hr;
}

HRESULT CNscTree::_HandleWinIniChange()
{
    COLORREF clrBk;

    if (FAILED(IUnknown_GetAmbientProperty(_punkSite, DISPID_AMBIENT_BACKCOLOR, VT_I4, &clrBk)))
        clrBk = GetSysColor(COLOR_WINDOW);

    TreeView_SetBkColor(_hwndTree, clrBk);
    
    if (!(_dwFlags & NSS_NORMALTREEVIEW))
    {
        // make things a bit more spaced out
        int cyItem = TreeView_GetItemHeight(_hwndTree);
        cyItem += LOGOGAP + 1;
        TreeView_SetItemHeight(_hwndTree, cyItem);
    }

    // Show compressed files in different color...
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWCOMPCOLOR, FALSE);
    _fShowCompColor = ss.fShowCompColor;

    return S_OK;
}

HRESULT CNscTree::Initialize(LPCITEMIDLIST pidlRoot, DWORD grfEnumFlags, DWORD dwFlags)
{
    HRESULT hr;

    _grfFlags = grfEnumFlags;       // IShellFolder::EnumObjects() flags.
    if (!(_mode & MODE_CUSTOM))
    {
        if (_mode != MODE_NORMAL)
        {
            dwFlags |= NSS_BORDER;
        }
        else
        {
            dwFlags |= NSS_NORMALTREEVIEW;
        }
    }
    _dwFlags = dwFlags;             // Behavior Flags
    if (_dwFlags & NSS_NORMALTREEVIEW)
        _dwFlags &= ~NSS_HEADER;// multi-select requires owner draw

    if (!_fInitialized)
    {
        ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);

        _fInitialized = TRUE;
    
        SHFILEINFO sfi;
        HIMAGELIST himl = (HIMAGELIST)SHGetFileInfo(TEXT(DEFAULT_PATHSTR), 0, &sfi, 
            sizeof(SHFILEINFO),  SHGFI_SYSICONINDEX | SHGFI_SMALLICON);
    
        TreeView_SetImageList(_hwndTree, himl, TVSIL_NORMAL);
        _DtRegister();
    
        //failure ignored intentionally
        THR(CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC,
                             IID_PPV_ARG(IShellTaskScheduler, &_pTaskScheduler)));
        if (_pTaskScheduler)
            _pTaskScheduler->Status(ITSSFLAG_KILL_ON_DESTROY, ITSS_THREAD_TIMEOUT_NO_CHANGE);

        hr = Init();  // init lock and scroll handles for CDelegateDropTarget
    
        ASSERT(SUCCEEDED(hr));
    
        if (_dwFlags & NSS_BORDER)
        {
            // set borders and space out for all, much cleaner.
            TreeView_SetBorder(_hwndTree, TVSBF_XBORDER, 2 * LOGOGAP, 0);   
        }
    
        // init some settings
        _HandleWinIniChange();

        // pidlRoot may equal NULL because that is equal to CSIDL_DESKTOP.
        if ((LPITEMIDLIST)INVALID_HANDLE_VALUE != pidlRoot)
        {
            _UnSubClass();
            _SetRoot(pidlRoot, 1, NULL, NSSR_CREATEPIDL);
            _SubClass(pidlRoot);
        }
    
        // need top level frame available for D&D if possible.
    
        _hwndDD = ::GetParent(_hwndTree);
        IOleWindow *pOleWindow;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow))))
        { 
            pOleWindow->GetWindow(&_hwndDD);
            pOleWindow->Release();
        }

        //this is a non-ML resource
        _hicoPinned = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_PINNED), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
        ASSERT(_hicoPinned);

        ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);
    }
    else
        hr = _ChangePidlRoot(pidlRoot);

    return hr;
}

// set the root of the name space control.
//
// in:
//  pidlRoot    NULL means the desktop
//    HIWORD 0 -> LOWORD == ID of special folder (CSIDL_* values)
//
//  flags,
//  pidlRoot,       PIDL, NULL for desktop, or CSIDL for shell special folder
//  iExpandDepth,   how many levels to expand the tree
//  pidlExpandTo    NULL, or PIDL to expand to
//

BOOL CNscTree::_SetRoot(LPCITEMIDLIST pidlRoot, int iExpandDepth, LPCITEMIDLIST pidlExpandTo, NSSR_FLAGS flags)
{
    _ReleasePidls();
    // review chrisny:  clean up this psr stuff.
    // HIWORD/LOWORD stuff is to support pidl IDs instead of full pidl here
    if (HIWORD(pidlRoot))
    {
        _pidlRoot = ILClone(pidlRoot);
    }
    else
    {
        SHGetSpecialFolderLocation(NULL, LOWORD(pidlRoot) ? LOWORD(pidlRoot) : CSIDL_DESKTOP, &_pidlRoot);
    }
    
    if (_pidlRoot)
    {
        HTREEITEM htiRoot = TVI_ROOT;
        if (_mode == MODE_NORMAL)
        {
            // Since we'll be adding this into the tree, we need
            // to clone it: We have a copy for the class, and we
            // have one for the tree itself (Makes life easier so
            // we don't have to special case TVI_ROOT).
            htiRoot = _AddItemToTree(TVI_ROOT, _pidlRoot, 1, 0);
            if (htiRoot)
            {
                TreeView_SelectItem(_hwndTree, htiRoot);
                TraceMsg(TF_NSC, "NSCBand: Setting Root to \"Desktop\"");
            }
            else
            {
                htiRoot = TVI_ROOT;
            }
        }

        BOOL fOrdered = _fOrdered;
        _LoadSF(htiRoot, _pidlRoot, &fOrdered);   // load the roots (actual children of _pidlRoot.
        // this is probably redundant since _LoadSF->_LoadOrder sets this
        _fOrdered = BOOLIFY(fOrdered);

#ifdef DEBUG
        TracePIDLAbs(_pidlRoot, TEXT("Setting Root to"));
#endif // DEBUG

        return TRUE;
    }

    TraceMsg(DM_ERROR, "set root failed");
    _ReleasePidls();
    return FALSE;
}


// cache the shell folder for a given tree item
// in:
//  hti tree node to cache shell folder for. this my be
//      NULL indicating the root item.
//

BOOL CNscTree::_CacheShellFolder(HTREEITEM hti)
{
    // in the cache?
    if ((hti != _htiCache) || (_psfCache == NULL))
    {
        // cache miss, do the work
        LPITEMIDLIST pidl;
        BOOL fRet = FALSE;
        
        _fpsfCacheIsTopLevel = FALSE;
        _ReleaseCachedShellFolder();
        
        if ((hti == NULL) || (hti == TVI_ROOT))
        {
            pidl = ILClone(_pidlRoot);
        }
        else
        {
            pidl = _GetFullIDList(hti);
        }
            
        if (pidl)
        {
            if (SUCCEEDED(IEBindToObject(pidl, &_psfCache)))
            {
                if (_pnscProxy)
                    _pnscProxy->CacheItem(pidl);
                ASSERT(_psfCache);
                _htiCache = hti;    // this is for the cache match
                _fpsfCacheIsTopLevel = (hti == TVI_ROOT || hti == NULL);
                _psfCache->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf2Cache));
                fRet = TRUE;
            }      
            
            ILFree(pidl);
        }
        
        return fRet;
    }
    return TRUE;
}

#define TVI_ROOTPARENT ((HTREEITEM)(ULONG_PTR)-0xF000)

// pidlItem is typically a relative pidl, except in the case of the root where
// it can be a fully qualified pidl

LPITEMIDLIST CNscTree::_CacheParentShellFolder(HTREEITEM hti, LPITEMIDLIST pidl)
{
    // need parent shell folder of TVI_ROOT, special case for drop insert into root level of tree.
    if (hti == TVI_ROOT || 
        hti == NULL || 
        (_mode == MODE_NORMAL &&
        TreeView_GetParent(_hwndTree, hti) == NULL))    // If we have a null parent and we're a normal, 
                                                        // than that's the same as root.
    {
        if (_htiCache != TVI_ROOTPARENT) 
        {
            _ReleaseCachedShellFolder();
            IEBindToParentFolder(_pidlRoot, &_psfCache, NULL);

            if (!ILIsEmpty(_pidlRoot))
                _htiCache = TVI_ROOTPARENT;
        }
        return ILFindLastID(_pidlRoot);
    }

    if (_CacheShellFolder(TreeView_GetParent(_hwndTree, hti)))
    {
        if (pidl == NULL)
        {
            PORDERITEM poi = _GetTreeOrderItem(hti);
            if (!poi)
                return NULL;

            pidl = poi->pidl;
        }
        
        return ILFindLastID(pidl);
    }
    
    return NULL;
}

typedef struct _SORTPARAMS
{
    CNscTree *pnsc;
    IShellFolder *psf;
} SORTPARAMS;

int CALLBACK CNscTree::_TreeCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    SORTPARAMS *pSortParams = (SORTPARAMS *)lParamSort;
    PORDERITEM poi1 = GetPoi(lParam1), poi2 = GetPoi(lParam2);
    
    HRESULT hr = pSortParams->pnsc->_CompareIDs(pSortParams->psf, poi1->pidl, poi2->pidl);
    return (short)SCODE_CODE(hr);
}

int CALLBACK CNscTree::_TreeOrder(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    HRESULT hr;
    PORDERITEM poi1 = GetPoi(lParam1), poi2 = GetPoi(lParam2);
    
    ASSERT((poi1 != NULL) && (poi1 != NULL));
    if (poi1->nOrder == poi2->nOrder)
        hr = 0;
    else
        // do unsigned compare so -1 goes to end of list
        hr = (poi1->nOrder < poi2->nOrder ? -1 : 1);
    
    return (short)SCODE_CODE(hr);
}
// review chrisny:  instead of sort, insert items on the fly.
void CNscTree::_Sort(HTREEITEM hti, IShellFolder *psf)
{
    TV_SORTCB   scb;
    SORTPARAMS  SortParams = {this, psf};
    BOOL        fOrdering = _IsOrdered(hti);
#ifdef DEBUG
    TraceHTREE(hti, TEXT("Sorting"));
#endif
    
    scb.hParent = hti;
    scb.lpfnCompare = !fOrdering ? _TreeCompare : _TreeOrder;
    
    scb.lParam = (LPARAM)&SortParams;
    TreeView_SortChildrenCB(_hwndTree, &scb, FALSE);
}

BOOL CNscTree::_IsOrdered(HTREEITEM htiRoot)
{
    if ((htiRoot == TVI_ROOT) || (htiRoot == NULL))
        return _fOrdered;
    else
    {
        PORDERITEM poi = _GetTreeOrderItem(htiRoot);
        if (poi)
        {
            // LParam Is a Boolean: 
            // TRUE: It has an order.
            // FALSE: It does not have an order.
            // Question: Where is that order stored? _hdpaOrder?
            return poi->lParam;
        }
    }
    return FALSE;
}

//helper function to init _hdpaOrd
//MUST be followed by a call to _FreeOrderList
HRESULT CNscTree::_PopulateOrderList(HTREEITEM htiRoot)
{
    int        i = 0;
    HTREEITEM  hti = NULL;
#ifdef DEBUG
    TraceHTREE(htiRoot, TEXT("Populating Order List from tree node"));
#endif
    
    if (_hdpaOrd)
        DPA_Destroy(_hdpaOrd);
    
    _hdpaOrd = DPA_Create(4);
    if (_hdpaOrd == NULL)
        return E_FAIL;
    
    for (hti = TreeView_GetChild(_hwndTree, htiRoot); hti; hti = TreeView_GetNextSibling(_hwndTree, hti))
    {
        PORDERITEM poi = _GetTreeOrderItem(hti);
        if (poi)
        {
            poi->nOrder = i;        // reset the positions of the nodes.
            DPA_SetPtr(_hdpaOrd, i++, (void *)poi);
        }
    }
    
    //set the root's ordered flag
    if (htiRoot == TVI_ROOT)
    {
        _fOrdered = TRUE;
    }
    else
    {
        PORDERITEM poi = _GetTreeOrderItem(htiRoot);
        if (poi)
        {
            poi->lParam = TRUE;
        }
    }
    
    return S_OK;
}

//helper function to free _hdpaOrd
//MUST be preceded by a call to _PopulateOrderList

void CNscTree::_FreeOrderList(HTREEITEM htiRoot)
{
    ASSERT(_hdpaOrd);
#ifdef DEBUG
    TraceHTREE(htiRoot, TEXT("Freeing OrderList"));
#endif

    _ReleaseCachedShellFolder();
    
    // Persist the new order out to the registry
    LPITEMIDLIST pidl = _GetFullIDList(htiRoot);
    if (pidl)
    {
        IStream* pstm = GetOrderStream(pidl, STGM_WRITE | STGM_CREATE);
        if (pstm)
        {
            if (_CacheShellFolder(htiRoot))
            {
#ifdef DEBUG
                for (int i=0; i<DPA_GetPtrCount(_hdpaOrd); i++)
                {
                    PORDERITEM poi = (PORDERITEM)DPA_GetPtr(_hdpaOrd, i);
                    if (poi)
                    {
                        ASSERTMSG(poi->nOrder >= 0, "nsc saving bogus order list nOrder (%d), get reljai", poi->nOrder);
                    }
                }
#endif
                OrderList_SaveToStream(pstm, _hdpaOrd, _psfCache);
                pstm->Release();
                
                // Notify everyone that the order changed
                SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, SHCNF_FLUSH, _pidlRoot);
                _dwOrderSig++;

                TraceMsg(TF_NSC, "NSCBand: Sent SHCNE_EXTENDED_EVENT : SHCNEE_ORDERCHANGED");
                
                // Remove this notify message immediately (so _fDropping is set
                // and we'll ignore this event in above OnChange method)
                //
                // _FlushNotifyMessages(_hwndTree);
            }
            else
                pstm->Release();
        }
        ILFree(pidl);
    }
    
    DPA_Destroy(_hdpaOrd);
    _hdpaOrd = NULL;
}

//removes any order the user has set and goes back to alphabetical sort
HRESULT CNscTree::ResetSort(void)
{
    HRESULT hr = S_OK;
#ifdef UNUSED
    ASSERT(_psfCache);
    ASSERT(_pidlRoot);
    
    int cAdded = 0;
    IStream* pstm = NULL;
    
    _fWeChangedOrder = TRUE;
    if (FAILED(hr = _PopulateOrderList(TVI_ROOT)))
        return hr;
    
    pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, _pidlRoot, REG_SUBKEY_FAVORITESA, STGM_CREATE | STGM_WRITE);
    
    _CacheShellFolder(TVI_ROOT);
    
    if (pstm == NULL || _psfCache == NULL)
    {
        ATOMICRELEASE(pstm);
        _FreeOrderList(TVI_ROOT);
        return S_OK;
    }
    _fOrdered = FALSE;
    
    ORDERINFO   oinfo;
    oinfo.psf = _psfCache;
    (oinfo.psf)->AddRef();
    oinfo.dwSortBy = OI_SORTBYNAME;
    DPA_Sort(_hdpaOrd, OrderItem_Compare,(LPARAM)&oinfo);
    ATOMICRELEASE(oinfo.psf);
    
    OrderList_Reorder(_hdpaOrd);
    
    OrderList_SaveToStream(pstm, _hdpaOrd, _psfCache);
    ATOMICRELEASE(pstm);
    
    _FreeOrderList(TVI_ROOT);
    Refresh();
    
    _fWeChangedOrder = FALSE;
#endif

    return hr;
}

void CNscTree::MoveItemUpOrDown(BOOL fUp)
{
    HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
    HTREEITEM htiToSwap = (fUp) ? TreeView_GetPrevSibling(_hwndTree, htiSelected) : 
                        TreeView_GetNextSibling(_hwndTree, htiSelected);
    HTREEITEM htiParent = TreeView_GetParent(_hwndTree, htiSelected);
    if (htiParent == NULL)
        htiParent = TVI_ROOT;
    ASSERT(htiSelected);
    
    _fWeChangedOrder = TRUE;
    if (FAILED(_PopulateOrderList(htiParent)))
        return;
    
    if (htiSelected && htiToSwap)
    {
        PORDERITEM poiSelected = _GetTreeOrderItem(htiSelected);
        PORDERITEM poiToSwap   = _GetTreeOrderItem(htiToSwap);
    
        if (poiSelected && poiToSwap)
        {
            int iOrder = poiSelected->nOrder;
            poiSelected->nOrder = poiToSwap->nOrder;
            poiToSwap->nOrder   = iOrder;
        }
        
        _CacheShellFolder(htiParent);
        
        if (_psfCache)
            _Sort(htiParent, _psfCache);
    }
    TreeView_SelectItem(_hwndTree, htiSelected);
    
    _FreeOrderList(htiParent);
    _fWeChangedOrder = FALSE;
}

// filter function... let clients filter what gets added here

BOOL CNscTree::_ShouldAdd(LPCITEMIDLIST pidl)
{
    // send notify up to parent to let them filter
    return TRUE;
}

BOOL CNscTree::_OnItemExpandingMsg(NM_TREEVIEW *pnm)
{
    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    BOOL bRet = _OnItemExpanding(pnm->itemNew.hItem, pnm->action, 
        (pnm->itemNew.state & TVIS_EXPANDEDONCE), (pnm->itemNew.state & TVIS_EXPANDPARTIAL));

    SetCursor(hCursorOld);

    return bRet;
}

//
//  The NSC item is expandable if it is a regular folder and it's not one
//  of those funky non-expandable channel folders.
//
BOOL CNscTree::_IsExpandable(HTREEITEM hti)
{
    BOOL fExpandable = FALSE;
    LPCITEMIDLIST pidlItem = _CacheParentShellFolder(hti, NULL);
    if (pidlItem)
    {
        // make sure item is actually a folder and not a non-expandable channel folder
        // except: in org favs, never expand channel folders
        ULONG ulAttr = SFGAO_FOLDER;
        LPITEMIDLIST pidlTarget = NULL;
        if (SUCCEEDED(_psfCache->GetAttributesOf(1, &pidlItem, &ulAttr)) &&
            (ulAttr & SFGAO_FOLDER) &&
            !(SUCCEEDED(SHGetNavigateTarget(_psfCache, pidlItem, &pidlTarget, &ulAttr)) &&
                  ((_mode & MODE_CONTROL) ?
                        TRUE :
                        !IsExpandableChannelFolder(_psfCache, pidlItem))))
        {
            fExpandable = TRUE;
        }
        ILFree(pidlTarget);
    }
    return fExpandable;
}

BOOL CNscTree::_OnItemExpanding(HTREEITEM htiToActivate, UINT action, BOOL fExpandedOnce, BOOL fIsExpandPartial)
{
    BOOL fReturn = FALSE; // false means let treeview proceed
    if (action != TVE_EXPAND)
    {
        htiToActivate = TreeView_GetParent(_hwndTree, htiToActivate);
    }
    else if (fExpandedOnce && !fIsExpandPartial)
    {
        // Do nothing
    }
    else
    {
        if (_IsExpandable(htiToActivate))
        {
            LPITEMIDLIST pidlParent = _GetFullIDList(htiToActivate);
            if (pidlParent)
            {
                BOOL fOrdered;
                // If we were previously partially expanded, then we need to do a full expand
                _LoadSF(htiToActivate, pidlParent, &fOrdered);
               ILFree(pidlParent);
            }
        }

        // do not remove + on downlevel because inserting items would not expand htiToActivate
        // instead we will remove the plus if nothing gets added
        if (!fIsExpandPartial && MODE_NORMAL == _mode && IsOS(OS_WHISTLERORGREATER))
        {
            // If we did not add anything we should update this item to let
            // the user know something happened.
            TreeView_SetChildren(_hwndTree, htiToActivate, NSC_CHILDREN_REMOVE);
        }

        // keep the old behavior for favorites/history/...
        if (MODE_NORMAL == _mode)
        {
            // cannot let treeview proceed with expansion, nothing will be added
            // until background thread is done enumerating
            fReturn = TRUE; 
        }
    }
    
    _UpdateActiveBorder(htiToActivate);
    return fReturn; 
}

HTREEITEM CNscTree::_FindFromRoot(HTREEITEM htiRoot, LPCITEMIDLIST pidl)
{
    HTREEITEM    htiRet = NULL;
    LPITEMIDLIST pidlParent, pidlChild;
    BOOL         fFreePidlParent = FALSE;
#ifdef DEBUG
    TracePIDLAbs(pidl, TEXT("Finding this pidl"));
    TraceHTREE(htiRoot, TEXT("from this root"));
#endif
    
    if (!htiRoot) 
    {
        // When in "Normal" mode, we need to use the first child, not the root
        // in order to calculate, because there is no "Invisible" root. On the
        // other hand, History and Favorites have an invisible root: Their
        // parent folder, so they need this fudge.
        htiRoot = (MODE_NORMAL == _mode) ? TreeView_GetChild(_hwndTree, 0) : TVI_ROOT;
        pidlParent = _pidlRoot;    // the invisible root.
    }
    else 
    {
        pidlParent = _GetFullIDList(htiRoot);
        fFreePidlParent = TRUE;
    }
    
    if (pidlParent == NULL)
        return NULL;
    
    if (ILIsEqual(pidlParent, pidl)) 
    {
        if (fFreePidlParent)
            ILFree(pidlParent);
        return htiRoot;
    }
    
    pidlChild = ILFindChild(pidlParent, pidl);
    if (pidlChild == NULL) 
    {
        if (fFreePidlParent)
            ILFree(pidlParent);
        return NULL;    // not root match, no hti
    }
    
    // root match, carry on . . .
    
    // Are we rooted under the Desktop (i.e. Empty pidl or ILIsEmpty(_pidlRoot))
    IShellFolder *psf = NULL;
    HRESULT hr = IEBindToObject(pidlParent, &psf);

    if (FAILED(hr))
    {
        if (fFreePidlParent)
            ILFree(pidlParent);
        return htiRet;
    }
    
    while (htiRoot && psf)
    {
        LPITEMIDLIST pidlItem = ILCloneFirst(pidlChild);
        if (!pidlItem)
            break;
        
        htiRoot = _FindChild(psf, htiRoot, pidlItem);
        IShellFolder *psfNext = NULL;
        hr = psf->BindToObject(pidlItem, NULL, IID_PPV_ARG(IShellFolder, &psfNext));
        ILFree(pidlItem);
        if (!htiRoot)
        {
            ATOMICRELEASE(psfNext);
            break;
        }
        psf->Release();
        psf = psfNext;
        pidlChild = _ILNext(pidlChild);
        // if we're down to an empty pidl, we've found it!
        if (ILIsEmpty(pidlChild)) 
        {
            htiRet = htiRoot;
            break;
        }
        if (FAILED(hr))
        {
            ASSERT(psfNext == NULL);
            break;
        }
    }
    if (psf) 
        psf->Release();
    if (fFreePidlParent)
        ILFree(pidlParent);
#ifdef DEBUG
    TraceHTREE(htiRet, TEXT("Found at"));
#endif

    return htiRet;
}

BOOL CNscTree::_FIsItem(IShellFolder *psf, LPCITEMIDLIST pidl, HTREEITEM hti)
{
    PORDERITEM poi = _GetTreeOrderItem(hti);
    return poi && poi->pidl && psf->CompareIDs(0, poi->pidl, pidl) == 0;
}

HRESULT CNscTree::_OnSHNotifyDelete(LPCITEMIDLIST pidl, int *piPosDeleted, HTREEITEM *phtiParent)
{
    HRESULT hr = S_FALSE;
    HTREEITEM hti = _FindFromRoot(NULL, pidl);
    
    if (hti == TVI_ROOT)
        return E_INVALIDARG;        // invalid arg, DELETION OF TVI_ROOT
    // need to clear _pidlDrag if the one being deleted is _pidlDrag.
    // handles case where dragging into another folder from within or dragging out.
    if (_pidlDrag)
    {
        LPCITEMIDLIST pidltst = _CacheParentShellFolder(hti, NULL);
        if (pidltst)
        {
            if (!_psfCache->CompareIDs(0, pidltst, _pidlDrag))
                _pidlDrag = NULL;
        }
    }

    if (pidl && (hti != NULL))
    {
        _fIgnoreNextItemExpanding = TRUE;

        HTREEITEM htiParent = TreeView_GetParent(_hwndTree, hti);
        
        if (phtiParent)
            *phtiParent = htiParent;

        //if caller wants the position of the deleted item, don't reorder the other items
        if (piPosDeleted)
        {
            PORDERITEM poi = _GetTreeOrderItem(hti);
            if (poi)
            {
                *piPosDeleted = poi->nOrder;
                hr = S_OK;
            }
            TreeView_DeleteItem(_hwndTree, hti);
        }
        else
        {
            if (htiParent == NULL)
                htiParent = TVI_ROOT;
            if (TreeView_DeleteItem(_hwndTree, hti))
            {
                _ReorderChildren(htiParent);
                hr = S_OK;
            }
        }

        // Update the + next to the parent folder. Note that History and Favorites
        // set ALL of their items to be Folder items, so this is not needed for
        // favorites.
        // do this only on downlevel as comctl v6 takes care of pluses
        if (_mode == MODE_NORMAL && !IsOS(OS_WHISTLERORGREATER))
        {
            LPCITEMIDLIST pidl = _CacheParentShellFolder(htiParent, NULL);
            if (pidl && !ILIsEmpty(pidl))
            {
                DWORD dwAttrib = SFGAO_HASSUBFOLDER;
                if (SUCCEEDED(_psfCache->GetAttributesOf(1, &pidl, &dwAttrib)) &&
                    !(dwAttrib & SFGAO_HASSUBFOLDER))
                {
                    TV_ITEM tvi;
                    tvi.mask = TVIF_CHILDREN | TVIF_HANDLE;
                    tvi.hItem = htiParent;
                    tvi.cChildren = 0;
                    TreeView_SetItem(_hwndTree, &tvi);
                }
            }
        }

        _fIgnoreNextItemExpanding = FALSE;

        if (hti == _htiCut)
        {
            _htiCut = NULL;
            _TreeNukeCutState();
        }

    }
    return hr;
}

BOOL CNscTree::_IsItemNameInTree(LPCITEMIDLIST pidl)
{
    BOOL fReturn = FALSE;
    HTREEITEM hti = _FindFromRoot(NULL, pidl);
    if (hti)
    {
        WCHAR szTree[MAX_PATH];
        TV_ITEM tvi;
        
        tvi.mask       = TVIF_TEXT;
        tvi.hItem      = hti;
        tvi.pszText    = szTree;
        tvi.cchTextMax = ARRAYSIZE(szTree);
        if (TreeView_GetItem(_hwndTree, &tvi))
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(_ParentFromItem(pidl, &psf, &pidlChild)))
            {
                WCHAR szName[MAX_PATH];
                if (SUCCEEDED(DisplayNameOf(psf, pidlChild, SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
                {
                    fReturn = (StrCmp(szName, szTree) == 0);
                }
                psf->Release();
            }
        }
    }

    return fReturn;
}
//
//  Attempt to perform a rename-in-place.  Returns
//
//  S_OK - rename succeeded
//  S_FALSE - original object not found
//  error - rename failed
//

HRESULT CNscTree::_OnSHNotifyRename(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNew)
{
    HTREEITEM hti, htiParent = NULL;
    HRESULT hr = S_FALSE;

    //
    //  If the source and destination belong to the same folder, then
    //  it's an in-folder rename.
    //
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    LPITEMIDLIST pidlNewParent = ILCloneParent(pidlNew);

    if (pidlParent && pidlNewParent && IEILIsEqual(pidlParent, pidlNewParent, TRUE) && (hti = _FindFromRoot(NULL, pidl)))
    {
        // to avoid reentering problems
        if (!_IsItemNameInTree(pidlNew))
        {
            HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);

            ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);
            if ((_OnSHNotifyDelete(pidl, NULL, &htiParent) != E_INVALIDARG)   // invalid arg indication of bogus rename, do not continue.
                && (_OnSHNotifyCreate(pidlNew, DEFAULTORDERPOSITION, htiParent) == S_OK))
            {
                if (hti == htiSelected)
                {
                    hti = _FindFromRoot(NULL, pidlNew);
                    _SelectNoExpand(_hwndTree, hti); // do not expand this guy
                }
                // NTRAID 89444: If we renamed the item the user is sitting on,
                // SHBrowseForFolder doesn't realize it and doesn't update the
                // edit control.

                hr = S_OK;
            }
            ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);
        }
    }
    // rename can be a move, so do not depend on the delete happening successfully.
    else if ((_OnSHNotifyDelete(pidl, NULL, &htiParent) != E_INVALIDARG)   // invalid arg indication of bogus rename, do not continue.
        && (_OnSHNotifyCreate(pidlNew, DEFAULTORDERPOSITION, htiParent) == S_OK))
    {
        hr = S_OK;
    }

    ILFree(pidlParent);
    ILFree(pidlNewParent);

    // if user created a new folder and changed the default name but is still in edit mode in defview
    // and then clicked on the + of the parent folder we start enumerating the folder (or stealing items
    // from defview) before defview had time to change the name of the new folder.  The result is
    // we enumerate the old name and before we transfer it to the foreground thread shell change notify rename
    // kicks in and we change the item already in the tree.  We then merge the items from the enumeration
    // which results in extra folder with the old name.
    // to avoid this we force the reenumeration...
    _dwOrderSig++;

    return hr;
    
}

//
//  To update an item, just find it and invalidate it.
//
void CNscTree::_OnSHNotifyUpdateItem(LPCITEMIDLIST pidl, LPITEMIDLIST pidlReal)
{
    HTREEITEM hti = _FindFromRoot(NULL, pidl);
    if (hti)
    {
        _TreeInvalidateItemInfo(hti, TVIF_TEXT);

        if (pidlReal && hti != TVI_ROOT)
        {
            PORDERITEM poi = _GetTreeOrderItem(hti);
            _AssignPidl(poi, pidlReal);
        }
    }
}

LPITEMIDLIST CNscTree::_FindHighestDeadItem(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlRet    = NULL;

    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent)
    {
        IShellFolder* psf;
        LPCITEMIDLIST pidlChild;
        if (SUCCEEDED(_ParentFromItem(pidlParent, &psf, &pidlChild)))
        {
            DWORD dwAttrib = SFGAO_VALIDATE;
            if (FAILED(psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlChild, &dwAttrib)))
            {
                pidlRet = _FindHighestDeadItem(pidlParent);
            }

            psf->Release();
        }

        ILFree(pidlParent);
    }
    
    return pidlRet ? pidlRet : ILClone(pidl);
}

void CNscTree::_RemoveDeadBranch(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlTop = _FindHighestDeadItem(pidl);

    if (pidlTop)
    {
        HTREEITEM hti = _FindFromRoot(NULL, pidlTop);
        if (hti)
        {
            if (!TreeView_DeleteItem(_hwndTree, hti))
            {
                ASSERTMSG(FALSE, "CNscTree::_OnSHNotifyUpdateDir: DeleteItem failed in tree control");       // somethings hosed in the tree.
            }
        }

        ILFree(pidlTop);
    }
}

HRESULT CNscTree::_OnSHNotifyUpdateDir(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    HTREEITEM hti = _FindFromRoot(NULL, pidl);
    if (hti)
    {   // folder exists in tree refresh folder now if had been loaded by expansion.
        IShellFolder* psf = NULL;
        LPCITEMIDLIST pidlChild;
        if (SUCCEEDED(_ParentFromItem(pidl, &psf, &pidlChild)))
        {
            LPITEMIDLIST pidlReal;
            DWORD dwAttrib = SFGAO_VALIDATE;
            //  pidlChild is read-only, so we start
            //  off our double validation with getting the "real"
            //  pidl which will fall back to a clone 
            if (SUCCEEDED(_IdlRealFromIdlSimple(psf, pidlChild, &pidlReal))
            &&  SUCCEEDED(psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlReal, &dwAttrib)))
            {
                TV_ITEM tvi;
                tvi.mask = TVIF_STATE;
                tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                tvi.hItem = (HTREEITEM)hti;
                if (hti != TVI_ROOT)
                {
                    if (!TreeView_GetItem(_hwndTree, &tvi))
                        tvi.state = 0;
                }

                if (hti == TVI_ROOT || tvi.state & TVIS_EXPANDEDONCE)
                {
                    hr = _UpdateDir(hti, TRUE);
                }
                else if (!(tvi.state & TVIS_EXPANDEDONCE))
                {
                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_CALLBACK);
                }

                if (hti != TVI_ROOT)
                {
                    PORDERITEM poi = _GetTreeOrderItem(hti);
                    _AssignPidl(poi, pidlReal);
                }

                ILFree(pidlReal);
            }
            else
            {
                _RemoveDeadBranch(pidl);
            }

            psf->Release();
        }
    }
    return hr;
}

HRESULT CNscTree::_GetEnumFlags(IShellFolder *psf, LPCITEMIDLIST pidlFolder, DWORD *pgrfFlags, HWND *phwnd)
{
    HWND hwnd = NULL;
    DWORD grfFlags = _grfFlags;

    if (_pFilter)
    {
        LPITEMIDLIST pidlFree = NULL;
        if (pidlFolder == NULL)
        {
            SHGetIDListFromUnk(psf, &pidlFree);
            pidlFolder = pidlFree;
        }
        _pFilter->GetEnumFlags(psf, pidlFolder, &hwnd, &grfFlags);

        ILFree(pidlFree);
    }
    *pgrfFlags = grfFlags;
    
    if (phwnd)
        *phwnd = hwnd;
    
    return S_OK;
}

HRESULT CNscTree::_GetEnum(IShellFolder *psf, LPCITEMIDLIST pidlFolder, IEnumIDList **ppenum)
{
    HWND hwnd = NULL;
    DWORD grfFlags;

    _GetEnumFlags(psf, pidlFolder, &grfFlags, &hwnd);

    // get the enumerator and add the child items for any given pidl
    // REARCHITECT: right now, we don't detect if we actually are dealing with a folder (shell32.dll
    // allows you to create an IShellfolder to a non folder object, so we get bad
    // dialogs, by not passing the hwnd, we don't get the dialogs. we should fix this better. by caching
    // in the tree whether it is a folder or not.
    return psf->EnumObjects(/* _fAutoExpanding ?*/ hwnd, grfFlags, ppenum);
}

BOOL CNscTree::_ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    BOOL bRet = TRUE;
    if (_pFilter)
    {
        LPITEMIDLIST pidlFree = NULL;
        if (pidlFolder == NULL)
        {
            SHGetIDListFromUnk(psf, &pidlFree);
            pidlFolder = pidlFree;
        }
        bRet = (S_OK == _pFilter->ShouldShow(psf, pidlFolder, pidlItem));

        if (pidlFree)
            ILFree(pidlFree);
    }
    return bRet;
}

// updates existing dir only.  Not new load.
HRESULT CNscTree::_UpdateDir(HTREEITEM hti, BOOL fUpdatePidls)
{
    HRESULT hr = S_FALSE;
    LPITEMIDLIST pidlParent = _GetFullIDList(hti);
    if (pidlParent)
    {
        BOOL fOrdered;
        _fUpdate = TRUE;
        hr = _StartBackgroundEnum(hti, pidlParent, &fOrdered, fUpdatePidls);
        _fUpdate = FALSE;
        ILFree(pidlParent);
    }
    return hr;
}

int CNscTree::_TreeItemIndexInHDPA(HDPA hdpa, IShellFolder *psfParent, HTREEITEM hti, int iReverseStart)
{
    int iIndex = -1;
    
    ASSERT(hti);

    PORDERITEM poi = _GetTreeOrderItem(hti);
    if (poi)
    {
        int celt = DPA_GetPtrCount(hdpa);
        ASSERT(iReverseStart <= celt && iReverseStart >= 0);
        for (int i = iReverseStart-1; i >= 0; i--)
        {
            PORDERITEM poi2 = (PORDERITEM)DPA_GetPtr(hdpa, i);
            if (poi2)
            {
                if (_psfCache->CompareIDs(0, poi->pidl, poi2->pidl) == 0)
                {
                    iIndex = i;
                    break;
                }
            }
        }
    }
    
    return iIndex;
}

HRESULT CNscTree::_Expand(LPCITEMIDLIST pidl, int iDepth)
{
    HRESULT hr = E_FAIL;
    HTREEITEM hti = _ExpandToItem(pidl);
    if (hti)
    {
        hr = _ExpandNode(hti, TVE_EXPAND, iDepth);
        // tvi_root is not a pointer and treeview doesn't check for special
        // values so don't select root to prevent fault
        if (hti != TVI_ROOT)
            _SelectNoExpand(_hwndTree, hti);
    }

    return hr;
}

HRESULT CNscTree::_ExpandNode(HTREEITEM htiParent, int iCode, int iDepth)
{
    // nothing to expand
    if (!iDepth)
        return S_OK;

    _fInExpand = TRUE;
    _uDepth = (UINT)iDepth-1;
    HRESULT hr = TreeView_Expand(_hwndTree, htiParent, iCode) ? S_OK : E_FAIL;
    _uDepth = 0;
    _fInExpand = FALSE;

    return hr;
}

HTREEITEM CNscTree::_FindChild(IShellFolder *psf, HTREEITEM htiParent, LPCITEMIDLIST pidlChild)
{
    HTREEITEM hti;
    for (hti = TreeView_GetChild(_hwndTree, htiParent); hti; hti = TreeView_GetNextSibling(_hwndTree, hti))
    {
        if (_FIsItem(psf, pidlChild, hti))
            break;
    }
    return hti;
}

void CNscTree::_ReorderChildren(HTREEITEM htiParent)
{
    int i = 0;
    HTREEITEM hti;
    for (hti = TreeView_GetChild(_hwndTree, htiParent); hti; hti = TreeView_GetNextSibling(_hwndTree, hti))
    {
        PORDERITEM poi = _GetTreeOrderItem(hti);
        if (poi)
        {
            poi->nOrder = i++;        // reset the positions of the nodes.
        }
    }
}


HRESULT CNscTree::_InsertChild(HTREEITEM htiParent, IShellFolder *psfParent, LPCITEMIDLIST pidlChild, 
                               BOOL fExpand, BOOL fSimpleToRealIDL, int iPosition, HTREEITEM *phti)
{
    LPITEMIDLIST pidlReal;
    HRESULT hr;
    HTREEITEM   htiNew = NULL;
    
    if (fSimpleToRealIDL)
    {
        hr = _IdlRealFromIdlSimple(psfParent, pidlChild, &pidlReal);
    }
    else
    {
        hr = SHILClone(pidlChild, &pidlReal);
    }

    // review chrisny:  no sort here, use compareitems to insert item instead.
    if (SUCCEEDED(hr))
    {
        HTREEITEM htiAfter = TVI_LAST;
        BOOL fOrdered = _IsOrdered(htiParent);
        if (iPosition != DEFAULTORDERPOSITION || !fOrdered)
        {
            if (iPosition == 0)
                htiAfter = TVI_FIRST;
            else
            {
                if (!fOrdered)
                    htiAfter = TVI_FIRST;
                
                for (HTREEITEM hti = TreeView_GetChild(_hwndTree, htiParent); hti; hti = TreeView_GetNextSibling(_hwndTree, hti))
                {
                    PORDERITEM poi = _GetTreeOrderItem(hti);
                    if (poi)
                    {
                        if (fOrdered)
                        {
                            if (poi->nOrder == iPosition-1)
                            {
                                htiAfter = hti;
#ifdef DEBUG
                                TraceHTREE(htiAfter, TEXT("Inserting After"));
#endif
                                break;
                            }
                        }
                        else
                        {
                            if ((short)SCODE_CODE(_CompareIDs(psfParent, pidlReal, poi->pidl)) > 0)
                                htiAfter = hti;
                            else
                                break;
                        }
                    }
                }
            }
        }

        if ((_FindChild(psfParent, htiParent, pidlReal) == NULL))
        {
            int cChildren = 1;
            if (MODE_NORMAL == _mode)
            {
                DWORD dwAttrib = SFGAO_FOLDER | SFGAO_STREAM;
                hr = psfParent->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlReal, &dwAttrib);
                if (SUCCEEDED(hr))
                    cChildren = _GetChildren(psfParent, pidlReal, dwAttrib);
            }

            if (SUCCEEDED(hr))
            {
                htiNew = _AddItemToTree(htiParent, pidlReal, cChildren, iPosition, htiAfter, TRUE, _IsMarked(htiParent));
                if (htiNew)
                {
                    _ReorderChildren(htiParent);

                    if (fExpand) 
                        _ExpandNode(htiParent, TVE_EXPAND, 1);    // force expansion to show new item.

                    //ensure the item is visible after a rename (or external drop, but that should always be a noop)
                    if (iPosition != DEFAULTORDERPOSITION)
                        TreeView_EnsureVisible(_hwndTree, htiNew);

                    hr = S_OK;
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }
        ILFree(pidlReal);
    }
    
    if (phti)
        *phti = htiNew;
    
    return hr;
}


HRESULT CheckForExpandOnce(HWND hwndTree, HTREEITEM hti)
{
    // Root node always expanded.
    if (hti == TVI_ROOT)
        return S_OK;
    
    TV_ITEM tvi;
    tvi.mask = TVIF_STATE | TVIF_CHILDREN;
    tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
    tvi.hItem = (HTREEITEM)hti;
    
    if (TreeView_GetItem(hwndTree, &tvi))
    {
        if (!(tvi.state & TVIS_EXPANDEDONCE) && (tvi.cChildren == 0))
        {
            TreeView_SetChildren(hwndTree, hti, NSC_CHILDREN_FORCE);
        }
    }
    
    return S_OK;
}


HRESULT _InvokeCommandThunk(IContextMenu * pcm, HWND hwndParent)
{
    HRESULT hr;

    if (g_fRunningOnNT)
    {
        CMINVOKECOMMANDINFOEX ici = {0};

        ici.cbSize = sizeof(ici);
        ici.hwnd = hwndParent;
        ici.nShow = SW_NORMAL;
        ici.lpVerb = CMDSTR_NEWFOLDERA;
        ici.fMask = CMIC_MASK_UNICODE | CMIC_MASK_FLAG_NO_UI;
        ici.lpVerbW = CMDSTR_NEWFOLDERW;

        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)(&ici));
    }
    else
    {
        CMINVOKECOMMANDINFO ici = {0};

        ici.cbSize = sizeof(ici);
        ici.hwnd = hwndParent;
        ici.nShow = SW_NORMAL;
        ici.lpVerb = CMDSTR_NEWFOLDERA;
        ici.fMask = CMIC_MASK_FLAG_NO_UI;
        // Win95 doesn't work with CMIC_MASK_UNICODE & CMDSTR_NEWFOLDERW
        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)(&ici));
    }

    return hr;
}

BOOL CNscTree::_IsItemExpanded(HTREEITEM hti)
{
    // if it's not open, then use it's parent
    TV_ITEM tvi;
    tvi.mask = TVIF_STATE;
    tvi.stateMask = TVIS_EXPANDED;
    tvi.hItem = (HTREEITEM)hti;
    
    return (TreeView_GetItem(_hwndTree, &tvi) && (tvi.state & TVIS_EXPANDED));
}

HRESULT CNscTree::CreateNewFolder(HTREEITEM hti)
{
    HRESULT hr = E_FAIL;

    if (hti)
    {
        // If the user selected a folder item (file), we need
        // to bind set the cache to the parent folder.
        LPITEMIDLIST pidl = _GetFullIDList(hti);
        if (pidl)
        {
            ULONG ulAttr = SFGAO_FOLDER;    // make sure item is actually a folder
            if (SUCCEEDED(IEGetAttributesOf(pidl, &ulAttr)))
            {
                HTREEITEM htiTarget;   // tree item in which new folder is created
                
                // Is it a folder?
                if (ulAttr & SFGAO_FOLDER)
                {
                    // non-Normal modes (!MODE_NORMAL) wants the new folder to be created as
                    // a sibling instead of as a child of the selected folder if it's
                    // closed.  I assume their reasoning is that closed folders are often
                    // selected by accident/default because these views are mostly 1 level.
                    // We don't want this functionality for the normal mode.
                    if ((MODE_NORMAL != _mode) && !_IsItemExpanded(hti))
                    {
                        htiTarget = TreeView_GetParent(_hwndTree, hti);  // yes, so fine.
                    }
                    else
                    {
                        htiTarget = hti;
                    }
                }
                else
                {
                    htiTarget = TreeView_GetParent(_hwndTree, hti); // No, so bind to the parent.
                }

                if (NULL == htiTarget)
                {
                    htiTarget = TVI_ROOT;  // should be synonymous
                }
                
                // ensure that this pidl has MenuOrder information (see IE55 #94868)
                if (!_IsOrdered(htiTarget) && _mode != MODE_NORMAL)
                {
                    // its not "ordered" (doesn't have reg key persisting order of folder)
                    //   then create make it ordered
                    if (SUCCEEDED(_PopulateOrderList(htiTarget)))
                    {
                        ASSERT(_hdpaOrd);
                        
                        _FreeOrderList(htiTarget);
                    }
                }

                _CacheShellFolder(htiTarget);
            }

            ILFree(pidl);
        }
    }

    // If no item is selected, we should still create a folder in whatever
    // the user most recently dinked with.  This is important if the
    // Favorites folder is completely empty.

    if (_psfCache)
    {
        IContextMenu *pcm;
        if (GetUIVersion() < 5)
        {
            IShellView *psv;
            hr = _psfCache->CreateViewObject(_hwndTree, IID_PPV_ARG(IShellView, &psv));
            if (SUCCEEDED(hr))
            {
                hr = psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IContextMenu, &pcm));
                if (SUCCEEDED(hr))
                {
                    IUnknown_SetSite(pcm, psv);
                }
                psv->Release();
            }
        }
        else
        {
            hr = CoCreateInstance(CLSID_NewMenu, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IContextMenu, &pcm));
        }
        
        if (SUCCEEDED(hr))
        {
            HMENU hmContext = CreatePopupMenu();
            hr = pcm->QueryContextMenu(hmContext, 0, 1, 256, 0);
            if (SUCCEEDED(hr))
            {
                _pidlNewFolderParent = _GetFullIDList(_htiCache);

                IShellExtInit *psei;
                if (SUCCEEDED(pcm->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei))))
                {
                    psei->Initialize(_pidlNewFolderParent, NULL, NULL);
                    psei->Release();
                }
                hr = _InvokeCommandThunk(pcm, _hwndParent);
                SHChangeNotifyHandleEvents(); // Flush the events to it doesn't take forever to shift into edit mode
                Pidl_Set(&_pidlNewFolderParent, NULL);
            }

            IUnknown_SetSite(pcm, NULL);
            DestroyMenu(hmContext);
            pcm->Release();
        }
    }

    return hr;
}


HRESULT CNscTree::_EnterNewFolderEditMode(LPCITEMIDLIST pidlNewFolder)
{
    HTREEITEM htiNewFolder = _FindFromRoot(NULL, pidlNewFolder);
    LPITEMIDLIST pidlParent = NULL;
    
    // 1. Flush all the notifications.
    // 2. Find the new dir in the tree.
    //    Expand the parent if needed.
    // 3. Put it into the rename mode.     
    EVAL(SUCCEEDED(SetSelectedItem(pidlNewFolder, FALSE, FALSE, 0)));

    if (htiNewFolder == NULL) 
    {
        pidlParent = ILClone(pidlNewFolder);
        ILRemoveLastID(pidlParent);
        HTREEITEM htiParent = _FindFromRoot(NULL, pidlParent);

        // We are looking for the parent folder. If this is NOT
        // the root, then we need to expand it to show it.

        // NOTE: If it is root, Tree view will
        // try and deref TVI_ROOT and faults.
        if (htiParent != TVI_ROOT)
        {
            // Try expanding the parent and finding again.
            CheckForExpandOnce(_hwndTree, htiParent);
            TreeView_SelectItem(_hwndTree, htiParent);
            _ExpandNode(htiParent, TVE_EXPAND, 1);
        }
        
        htiNewFolder = _FindFromRoot(NULL, pidlNewFolder);
    }

    if (htiNewFolder == NULL) 
    {
        // Something went very wrong here. We are not able to find newly added node.
        // One last try after refreshing the entire tree. (slow)
        // May be we didn't get notification.
        Refresh();

        htiNewFolder = _FindFromRoot(NULL, pidlNewFolder);
        if (htiNewFolder && (htiNewFolder != TVI_ROOT))
        {
            HTREEITEM htiParent = _FindFromRoot(NULL, pidlParent);

            // We are looking for the parent folder. If this is NOT
            // the root, then we need to expand it to show it.

            // NOTE: If it is root, Tree view will
            // try and deref TVI_ROOT and faults.
            if (htiParent != TVI_ROOT)
            {
                CheckForExpandOnce(_hwndTree, htiParent);
                TreeView_SelectItem(_hwndTree, htiParent);
                _ExpandNode(htiParent, TVE_EXPAND, 1);
            }
        }

        htiNewFolder = _FindFromRoot(NULL, pidlNewFolder);
    }

    // Put Edit label on the item for possible renaming by user.
    if (htiNewFolder) 
    {
        _fOkToRename = TRUE;  //otherwise label editing is canceled
        TreeView_EditLabel(_hwndTree, htiNewFolder);
        _fOkToRename = FALSE;
    }

    if (pidlParent)
        ILFree(pidlParent);

    return S_OK;
}


HRESULT CNscTree::_OnSHNotifyCreate(LPCITEMIDLIST pidl, int iPosition, HTREEITEM htiParent)
{
    HRESULT hr = S_OK;
    HTREEITEM hti = NULL;
    
    if (ILIsParent(_pidlRoot, pidl, FALSE))
    {
        LPITEMIDLIST pidlParent = ILCloneParent(pidl);
        if (pidlParent)
        {
            hti = _FindFromRoot(NULL, pidlParent);
            ILFree(pidlParent);
        }

        if (hti)
        {   
            // folder exists in tree, if item expanded, load the node, else bag out.
            if (_mode != MODE_NORMAL)
            {
                TV_ITEM tvi;
                if (hti != TVI_ROOT)
                {
                    tvi.mask = TVIF_STATE | TVIF_CHILDREN;
                    tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                    tvi.hItem = (HTREEITEM)hti;
                
                    if (!TreeView_GetItem(_hwndTree, &tvi))
                        return hr;
                
                    // If we drag and item over to a node which has never beem expanded
                    // before we will always fail to add the new node.
                    if (!(tvi.state & TVIS_EXPANDEDONCE)) 
                    {
                        CheckForExpandOnce(_hwndTree, hti);
                    
                        tvi.mask = TVIF_STATE;
                        tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                        tvi.hItem = (HTREEITEM)hti;

                        // We need to reset this. This is causing some weird behaviour during drag and drop.
                        _fAsyncDrop = FALSE;
                    
                        if (!TreeView_GetItem(_hwndTree, &tvi))
                            return hr;
                    }
                }
                else
                    tvi.state = (TVIS_EXPANDEDONCE);    // evil root is always expanded.
            
                if (tvi.state & TVIS_EXPANDEDONCE)
                {
                    LPCITEMIDLIST   pidlChild;
                    IShellFolder    *psf;
                    hr = _ParentFromItem(pidl, &psf, &pidlChild);
                    if (SUCCEEDED(hr))
                    {
                        if (_fAsyncDrop)    // inserted via drag/drop
                        {
                            int iNewPos =   _fInsertBefore ? (_iDragDest - 1) : _iDragDest;
                            LPITEMIDLIST pidlReal;
                            if (SUCCEEDED(_IdlRealFromIdlSimple(psf, pidlChild, &pidlReal)))
                            {
                                if (_MoveNode(_iDragSrc, iNewPos, pidlReal))
                                {
                                    TraceMsg(TF_NSC, "NSCBand:  Reordering Item");
                                    _fDropping = TRUE;
                                    _Dropped();
                                    _fAsyncDrop = FALSE;
                                    _fDropping = FALSE;
                                }
                                ILFree(pidlReal);
                            }
                            _htiCur = NULL;
                            _fDragging = _fInserting = _fDropping = FALSE;
                            _iDragDest = _iDragSrc = -1;
                        }
                        else   // standard shell notify create or drop with no insert, rename.
                        {
                            if (SUCCEEDED(hr))
                            {
                                if (_iDragDest >= 0)
                                    iPosition = _iDragDest;
                                hr = _InsertChild(hti, psf, pidlChild, BOOLIFY(tvi.state & TVIS_SELECTED), TRUE, iPosition, NULL);
                                if (_iDragDest >= 0 &&
                                    SUCCEEDED(_PopulateOrderList(hti)))
                                {
                                    _fDropping = TRUE;
                                    _Dropped();
                                    _fDropping = FALSE;
                                }
                            }
                        }
                        psf->Release();
                    }
                }
            }
            else    // MODE_NORMAL
            {
                // no need to do anything, this item hasn't been expanded yet
                if (TreeView_GetItemState(_hwndTree, hti, TVIS_EXPANDEDONCE) & TVIS_EXPANDEDONCE)
                {
                    LPCITEMIDLIST   pidlChild;
                    IShellFolder    *psf;
                    if (SUCCEEDED(_ParentFromItem(pidl, &psf, &pidlChild)))
                    {
                        LPITEMIDLIST pidlReal;
                        if (SUCCEEDED(_IdlRealFromIdlSimple(psf, pidlChild, &pidlReal)))
                        {
                            do // scope
                            {
                                DWORD dwEnumFlags;
                                _GetEnumFlags(psf, pidlChild, &dwEnumFlags, NULL);

                                DWORD dwAttributes = SHGetAttributes(psf, pidlReal, SFGAO_FOLDER | SFGAO_HIDDEN | SFGAO_STREAM);
                                // filter out zip files (they are both folders and files but we treat them as files)
                                // on downlevel SFGAO_STREAM is the same as SFGAO_HASSTORAGE so we'll let zip files slide through (oh well)
                                // better than not adding filesystem folders (that have storage)
                                DWORD dwFlags = SFGAO_FOLDER;
                                if (IsOS(OS_WHISTLERORGREATER))
                                    dwFlags |= SFGAO_STREAM;
                                
                                if ((dwAttributes & dwFlags) == SFGAO_FOLDER)
                                {
                                    if (!(dwEnumFlags & SHCONTF_FOLDERS))
                                        break;   // item is folder but client does not want folders
                                }
                                else if (!(dwEnumFlags & SHCONTF_NONFOLDERS))
                                    break;   // item is file, but client only wants folders

                                if (!(dwEnumFlags & SHCONTF_INCLUDEHIDDEN) &&
                                     (dwAttributes & SFGAO_HIDDEN))
                                     break;

                                hr = _InsertChild(hti, psf, pidlReal, FALSE, TRUE, iPosition, NULL);
                                if (S_OK == hr)
                                {
                                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_ADD);
                                }
                            } while (0); // Execute the block only once

                            ILFree(pidlReal);
                        }
                        psf->Release();
                    }
                }
                else
                {
                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_CALLBACK);
                }
            }
        }
    }

    //if the item is being moved from a folder and we have it's position, we need to fix up the order in the old folder
    if (_mode != MODE_NORMAL && iPosition >= 0) //htiParent && (htiParent != hti) && 
    {
        //item was deleted, need to fixup order info
        _ReorderChildren(htiParent);
    }

    _UpdateActiveBorder(_htiActiveBorder);
    return hr;
}

//FEATURE: make this void
HRESULT CNscTree::_OnDeleteItem(NM_TREEVIEW *pnm)
{
    if (_htiActiveBorder == pnm->itemOld.hItem)
        _htiActiveBorder = NULL;

    ITEMINFO *  pii = (ITEMINFO *) pnm->itemOld.lParam;
    pnm->itemOld.lParam = NULL;

    OrderItem_Free(pii->poi, TRUE);
    LocalFree(pii);
    pii = NULL;

    return S_OK;
}

void CNscTree::_GetDefaultIconIndex(LPCITEMIDLIST pidl, ULONG ulAttrs, TVITEM *pitem, BOOL fFolder)
{
    if (_iDefaultFavoriteIcon == 0)
    {
        WCHAR psz[MAX_PATH];
        int iTemp = 0;
        DWORD cbSize = ARRAYSIZE(psz);
    
        if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_DEFAULTICON, TEXT("InternetShortcut"), NULL, psz, &cbSize)))
            iTemp = PathParseIconLocation(psz);

        _iDefaultFavoriteIcon = Shell_GetCachedImageIndex(psz, iTemp, 0);

        cbSize = ARRAYSIZE(psz);

        if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_DEFAULTICON, TEXT("Folder"), NULL, psz, &cbSize)))
            iTemp = PathParseIconLocation(psz);

        _iDefaultFolderIcon = Shell_GetCachedImageIndex(psz, iTemp, 0);
    }

    pitem->iImage = pitem->iSelectedImage = (fFolder) ? _iDefaultFolderIcon : _iDefaultFavoriteIcon;
}

BOOL CNscTree::_LoadOrder(HTREEITEM hti, LPCITEMIDLIST pidl, IShellFolder* psf, HDPA* phdpa)
{
    BOOL fOrdered = FALSE;
    HDPA hdpaOrder = NULL;
    IStream *pstm = GetOrderStream(pidl, STGM_READ);
    if (pstm)
    {
        OrderList_LoadFromStream(pstm, &hdpaOrder, psf);
        pstm->Release();
    }

    fOrdered = !((hdpaOrder == NULL) || (DPA_GetPtrCount(hdpaOrder) == 0));

    //set the tree item's ordered flag
    PORDERITEM poi;
    if (hti == TVI_ROOT)
    {
        _fOrdered = fOrdered;
    }
    else if ((poi = _GetTreeOrderItem(hti)) != NULL)
    {
        poi->lParam = fOrdered;
    }

    *phdpa = hdpaOrder;

    return fOrdered;
}

// load shell folder and deal with persisted ordering.
HRESULT CNscTree::_LoadSF(HTREEITEM htiRoot, LPCITEMIDLIST pidl, BOOL *pfOrdered)
{
    ASSERT(pfOrdered);
#ifdef DEBUG
    TraceHTREE(htiRoot, TEXT("Loading the Shell Folder for"));
#endif
    HRESULT hr = S_OK;
    IDVGetEnum *pdvge;
    if (_pidlNavigatingTo && ILIsEqual(pidl, _pidlNavigatingTo) && SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IDVGetEnum, &pdvge))))
    {
        pdvge->Release(); // we don't need this, just checking if view supports enumeration stealing
        // If we want to expand the item that we are navigating to,
        // then let's wait for the CDefView to populate so that we
        // can go steal its contents
        _fExpandNavigateTo = TRUE;
        if (_fNavigationFinished)
        {
            _CacheShellFolder(htiRoot); // make sure we cache folder in case it is misbehaving shell extension
            LPITEMIDLIST pidlClone;
            hr = SHILClone(pidl, &pidlClone);
            if (SUCCEEDED(hr))
                hr = RightPaneNavigationFinished(pidlClone); // function takes ownership of pidl
        }
    }
    else
    {
        hr = _StartBackgroundEnum(htiRoot, pidl, pfOrdered, FALSE);
    }
    
    return hr;
}

HRESULT CNscTree::_StartBackgroundEnum(HTREEITEM htiRoot, LPCITEMIDLIST pidl, 
    BOOL *pfOrdered, BOOL fUpdatePidls)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (_CacheShellFolder(htiRoot))
    {    
        HDPA hdpaOrder = NULL;
        IShellFolder *psfItem = _psfCache;

        psfItem->AddRef();  // hang on as adding items may change the cached psfCache

        *pfOrdered = _LoadOrder(htiRoot, pidl, psfItem, &hdpaOrder);
        DWORD grfFlags;
        DWORD dwSig = 0;
        _GetEnumFlags(psfItem, pidl, &grfFlags, NULL);
        if (htiRoot && htiRoot != TVI_ROOT)
        {
            ITEMINFO *pii = _GetTreeItemInfo(htiRoot);
            if (pii)
                dwSig = pii->dwSig;
        }
        else
        {
            htiRoot = TVI_ROOT;
        }

        if (_pTaskScheduler)
        {
            // AddNscEnumTask takes ownership of hdpaOrder, but not the pidls
            hr = AddNscEnumTask(_pTaskScheduler, pidl, s_NscEnumCallback, this,
                                    (UINT_PTR)htiRoot, dwSig, grfFlags, hdpaOrder, 
                                    _pidlExpandingTo, _dwOrderSig, !_fInExpand, 
                                    _uDepth, _fUpdate, fUpdatePidls);
            if (SUCCEEDED(hr) && !_fInExpand)
            {
                _fShouldShowAppStartCursor = TRUE;
            }
        }

        psfItem->Release();
    }
    return hr;
}


// s_NscEnumCallback : Callback function for the background enumration.
//           This function takes ownership of the hdpa and the pidls.
void CNscTree::s_NscEnumCallback(CNscTree *pns, LPITEMIDLIST pidl, UINT_PTR uId, DWORD dwSig, HDPA hdpa, 
                                 LPITEMIDLIST pidlExpandingTo, DWORD dwOrderSig, UINT uDepth, 
                                 BOOL fUpdate, BOOL fUpdatePidls)
{
    NSC_BKGDENUMDONEDATA * pbedd = new NSC_BKGDENUMDONEDATA;
    if (pbedd)
    {
        pbedd->pidl = pidl;
        pbedd->hitem = (HTREEITEM)uId;
        pbedd->dwSig = dwSig;
        pbedd->hdpa = hdpa;
        pbedd->pidlExpandingTo = pidlExpandingTo;
        pbedd->dwOrderSig = dwOrderSig;
        pbedd->uDepth = uDepth;
        pbedd->fUpdate = fUpdate;
        pbedd->fUpdatePidls = fUpdatePidls;

        // get the lock so that we can add the data to the end of the list
        NSC_BKGDENUMDONEDATA **ppbeddWalk = NULL;
        EnterCriticalSection(&pns->_csBackgroundData);

        // Start at the head. We use a pointer to pointer here to eliminate special cases
        ppbeddWalk = &pns->_pbeddList;

        // First walk to the end of the list
        while (*ppbeddWalk)
            ppbeddWalk = &(*ppbeddWalk)->pNext;

        *ppbeddWalk = pbedd;
        LeaveCriticalSection(&pns->_csBackgroundData);

        // It's ok to ignore the return value here. The data will be cleaned up when the
        // CNscTree object gets destroyed
        if (::IsWindow(pns->_hwndTree))
            ::PostMessage(pns->_hwndTree, WM_NSCBACKGROUNDENUMDONE, (WPARAM)NULL, (LPARAM)NULL);
    }
    else
    {
        ILFree(pidl);
        ILFree(pidlExpandingTo);
        OrderList_Destroy(&hdpa, TRUE);
    }
}

BOOL OrderList_Insert(HDPA hdpa, int iIndex, LPITEMIDLIST pidl, int nOrder)
{
    PORDERITEM poi = OrderItem_Create(pidl, nOrder);
    if (poi)
    {
        if (-1 != DPA_InsertPtr(hdpa, iIndex, poi))
            return TRUE;

        OrderItem_Free(poi, TRUE); // free pid
    }
    return FALSE;
}

void CNscTree::_EnumBackgroundDone(NSC_BKGDENUMDONEDATA *pbedd)
{
    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    HTREEITEM hti = pbedd->hitem;
    TVITEM    tvi;
    tvi.mask = TVIF_PARAM;
    tvi.hItem = hti;

    // This can fail if the item was moved before the async icon
    // extraction finished for that item.
    ITEMINFO* pii = NULL;
    if (hti != TVI_ROOT && TreeView_GetItem(_hwndTree, &tvi))
    {
        pii = GetPii(tvi.lParam);

        // Check if we have the right guy
        if (pii->dwSig != pbedd->dwSig)
        {
            // Try to find it using the pidl
            hti = _FindFromRoot(NULL, pbedd->pidl);
            if (hti)
                pii = _GetTreeItemInfo(hti);
        }
    }

    if ((hti == TVI_ROOT || (pii && pii->dwSig == pbedd->dwSig)) && _CacheShellFolder(hti))
    {
        // Check if the ordering has changed while we were doing the background enumeration
        if (pbedd->dwOrderSig == _dwOrderSig)
        {
            IShellFolder *psfItem = _psfCache;
            psfItem->AddRef(); // hang on as adding items may change the cached psfCache

            BOOL fInRename = _fInLabelEdit;
            HTREEITEM htiWasRenaming = fInRename ? _htiRenaming : NULL;

            HTREEITEM htiExpandTo = NULL;
            if (pbedd->pidlExpandingTo)
                htiExpandTo = _FindChild(psfItem, hti, pbedd->pidlExpandingTo);

            BOOL fParentMarked = _IsMarked(hti);
            BOOL fItemWasAdded = FALSE;
            BOOL fItemAlreadyIn = FALSE;

            ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);

            HTREEITEM htiTemp;
            HTREEITEM htiLast = NULL;
            // find last child
            for (htiTemp = TreeView_GetChild(_hwndTree, hti); htiTemp;)
            {
                htiLast = htiTemp;
                htiTemp = TreeView_GetNextSibling(_hwndTree, htiTemp);
            }

            HTREEITEM htiCur = htiLast;
            BOOL bReorder = FALSE;
            int iCur = DPA_GetPtrCount(pbedd->hdpa);
            for (htiTemp = htiLast; htiTemp;)
            {
                HTREEITEM htiNextChild = TreeView_GetPrevSibling(_hwndTree, htiTemp);
                // must delete in this way or break the linkage of tree.
                int iIndex = _TreeItemIndexInHDPA(pbedd->hdpa, psfItem, htiTemp, iCur);
                if (-1 == iIndex)
                {
                    PORDERITEM poi = _GetTreeOrderItem(htiTemp);
                    if (poi)
                    {
                        DWORD dwAttrib = SFGAO_VALIDATE;
                        if (FAILED(psfItem->GetAttributesOf(1, (LPCITEMIDLIST*)&poi->pidl, &dwAttrib)))
                        {
                            TreeView_DeleteItem(_hwndTree, htiTemp);
                            if (htiCur == htiTemp)
                            {
                                htiCur = htiNextChild;
                            }
                        }
                        else
                        {
                            // the item is valid but it didn't get enumerated (possible in partial network enumeration)
                            // we need to add it to our list of new items
                            LPITEMIDLIST pidl = ILClone(poi->pidl);
                            if (pidl)
                            {
                                if (!OrderList_Insert(pbedd->hdpa, iCur, pidl, -1)) //frees the pidl
                                {
                                    // must delete item or our insertion below will be out of whack
                                    TreeView_DeleteItem(_hwndTree, htiTemp);
                                    if (htiCur == htiTemp)
                                    {
                                        htiCur = htiNextChild;
                                    }
                                }
                                else
                                {
                                    bReorder = TRUE; // we reinserted the item into the order list, must reorder
                                }
                            }
                        }
                    }
                }
                else
                {
                    iCur = iIndex; // our next orderlist insertion point
                }

                htiTemp = htiNextChild;
            }

            if (!_fOrdered)
            {
                int cAdded = DPA_GetPtrCount(pbedd->hdpa);

                // htiCur contains the last sibling in that branch
                HTREEITEM htiInsertPosition = htiCur ? htiCur : TVI_FIRST;

                // Now adding all the new elements starting from the last, since adding at the end of the tree
                // is very slow
                for (int i = cAdded-1; i >= 0; i--)
                {
                    PORDERITEM pitoi = (PORDERITEM)DPA_FastGetPtr(pbedd->hdpa, i);
                    if (pitoi == NULL)
                        break;

                    if (htiCur)
                    {
                        PORDERITEM poi = _GetTreeOrderItem(htiCur);
                        if (poi)
                        {
                            HRESULT hr = psfItem->CompareIDs(0, pitoi->pidl, poi->pidl);
                            // If the item is already there, let's not add it again
                            if (HRESULT_CODE(hr) == 0)
                            {
                                fItemAlreadyIn = TRUE;
                                if (pbedd->fUpdatePidls)
                                {
                                    _AssignPidl(poi, pitoi->pidl);
                                }
                                // Get to the next item
                                htiCur = TreeView_GetPrevSibling(_hwndTree, htiCur);
                                htiInsertPosition = htiCur;
                                if (!htiCur)
                                    htiInsertPosition = TVI_FIRST;

                                continue;
                            }
                        }
                    }

                    if (_ShouldShow(psfItem, pbedd->pidl, pitoi->pidl))
                    {
                        int cChildren = 1;
                        if (MODE_NORMAL == _mode)
                        {
                            DWORD dwAttrib = SHGetAttributes(psfItem, pitoi->pidl, SFGAO_FOLDER | SFGAO_STREAM);
                            cChildren = _GetChildren(psfItem, pitoi->pidl, dwAttrib);
                        }

                        // If this is a normal NSC, we need to display the plus sign correctly.
                        if (_AddItemToTree(hti, pitoi->pidl, cChildren, pitoi->nOrder, htiInsertPosition, FALSE, fParentMarked))
                        {
                            fItemWasAdded = TRUE;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
            else  // _fOrdered
            {
                if (bReorder)
                {
                    OrderList_Reorder(pbedd->hdpa);
                }
                
                LPITEMIDLIST pidlParent = _GetFullIDList(hti);
                if (pidlParent)
                {
                    int celt = DPA_GetPtrCount(pbedd->hdpa);
                    for (int i = 0; i < celt; i++)
                    {
                        PORDERITEM pitoi = (PORDERITEM)DPA_FastGetPtr(pbedd->hdpa, i);
                        if (pitoi == NULL)
                            break;

                        LPITEMIDLIST pidlFull = ILCombine(pidlParent, pitoi->pidl);
                        if (pidlFull)
                        {
                            htiTemp = _FindFromRoot(hti, pidlFull);
                            // if we DON'T FIND IT add it to the tree . . .
                            if (!htiTemp)
                            {
                                if (_AddItemToTree(hti, pitoi->pidl, 1, pitoi->nOrder, TVI_LAST, FALSE, fParentMarked))
                                {
                                    fItemWasAdded = TRUE;
                                }
                                else
                                {
                                    break;
                                }
                            }
                            else
                            {
                                PORDERITEM poiItem = _GetTreeOrderItem(htiTemp);
                                if (poiItem)
                                {
                                    poiItem->nOrder = pitoi->nOrder;
                                }
                                fItemAlreadyIn = TRUE;
                            }
                            ILFree(pidlFull);
                        }
                    }
                    ILFree(pidlParent);
                }
                _Sort(hti, _psfCache);
            }

            if (fItemWasAdded || fItemAlreadyIn)
            {
                //make sure something is selected, otherwise first click selects instead of expanding/collapsing/navigating
                HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
                if (!htiSelected)
                {
                    htiSelected = TreeView_GetFirstVisible(_hwndTree);
                    _SelectNoExpand(_hwndTree, htiSelected); // do not expand this guy
                }
                
                if (hti != TVI_ROOT)
                {
                    // if this is updatedir, don't expand the node
                    if (!pbedd->fUpdate)
                    {
                        // Check to see if it's expanded.
                        tvi.mask = TVIF_STATE;
                        tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                        tvi.hItem = hti;
                        if (TreeView_GetItem(_hwndTree, &tvi))
                        {
                            if (!(tvi.state & TVIS_EXPANDED) || (tvi.state & TVIS_EXPANDPARTIAL))
                            {
                                _fIgnoreNextItemExpanding = TRUE;
                                _ExpandNode(hti, TVE_EXPAND, 1);
                                _fIgnoreNextItemExpanding = FALSE;
                            }
                        }
                    }

                    // Handle full recursive expansion case.
                    if (pbedd->uDepth)
                    {
                        for (htiTemp = TreeView_GetChild(_hwndTree, hti); htiTemp;) 
                        {
                            HTREEITEM htiNextChild = TreeView_GetNextSibling(_hwndTree, htiTemp);
                            _ExpandNode(htiTemp, TVE_EXPAND, pbedd->uDepth);
                            htiTemp = htiNextChild;
                        }

                        if (TVI_ROOT != htiSelected)
                            TreeView_EnsureVisible(_hwndTree, htiSelected);
                    }
                }
            }
            else if (MODE_NORMAL == _mode && !IsOS(OS_WHISTLERORGREATER)) //see comment in OnItemExpanding
            {
                // we didn't add anything, we better remove +
                TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_REMOVE);
            }
            
            // we're doing refresh/update dir, we don't care if items were added or not
            if (pbedd->fUpdate)
            {
                for (htiTemp = TreeView_GetChild(_hwndTree, hti); htiTemp; htiTemp = TreeView_GetNextSibling(_hwndTree, htiTemp))
                {
                    PORDERITEM pitoi = _GetTreeOrderItem(htiTemp);
                    if (!pitoi)
                        break;
                
                    if (SHGetAttributes(psfItem, pitoi->pidl, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER)
                    {
                        UINT uState = TVIS_EXPANDED;
                        if (TVI_ROOT != htiTemp)
                            uState = TreeView_GetItemState(_hwndTree, htiTemp, TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                            
                        if (uState & TVIS_EXPANDED)
                        {
                            LPITEMIDLIST pidlFull = ILCombine(pbedd->pidl, pitoi->pidl);
                            if (pidlFull)
                            {
                                BOOL fOrdered;
                                _fUpdate = TRUE;
                                _fInExpand = BOOLIFY(uState & TVIS_EXPANDPARTIAL);
                                _StartBackgroundEnum(htiTemp, pidlFull, &fOrdered, pbedd->fUpdatePidls);
                                _fInExpand = FALSE;
                                _fUpdate = FALSE;
                                ILFree(pidlFull);
                            }
                        }
                        else if (uState & TVIS_EXPANDEDONCE)
                        {
                            TreeView_DeleteChildren(_hwndTree, htiTemp);
                            TreeView_SetChildren(_hwndTree, htiTemp, NSC_CHILDREN_CALLBACK);
                        }
                    }
                }
            }

            ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);
            if (htiExpandTo)
                TreeView_EnsureVisible(_hwndTree, htiExpandTo);

            if (fItemWasAdded && fInRename)
            {
                _fOkToRename = TRUE;  //otherwise label editing is canceled
                TreeView_EditLabel(_hwndTree, htiWasRenaming);
                _fOkToRename = FALSE;
            }


            psfItem->Release();
        }
        else
        {
            BOOL fOrdered;
            // The order has changed, we need start over again using the new order
            _StartBackgroundEnum(hti, pbedd->pidl, &fOrdered, pbedd->fUpdatePidls);
        }
    }

    delete pbedd;

    SetCursor(hCursorOld);
}


// review chrisny:  get rid of this function.
int CNscTree::_GetChildren(IShellFolder *psf, LPCITEMIDLIST pidl, ULONG ulAttrs)
{
    int cChildren = 0;  // assume none

    // treat zip folders as files (they are both folders and files but we treat them as files)
    // on downlevel SFGAO_STREAM is the same as SFGAO_HASSTORAGE so we'll let zip files slide through (oh well)
    // better than not adding filesystem folders (that have storage)

    if ((ulAttrs & SFGAO_FOLDER))
    {
        if (IsOS(OS_WHISTLERORGREATER))
            cChildren = I_CHILDRENAUTO; // let treeview handle +'s
            
        if (_grfFlags & SHCONTF_FOLDERS)
        {
            // if just folders we can peek at the attributes
            if (SHGetAttributes(psf, pidl, SFGAO_HASSUBFOLDER))
                cChildren = 1;
        }
        
        if (cChildren != 1 && (_grfFlags & SHCONTF_NONFOLDERS))
        {
            // there is no SFGAO_ bit that includes non folders so we need to enum
            IShellFolder *psfItem;
            if (SUCCEEDED(psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psfItem))))
            {
                // if we are showing non folders we have to do an enum to peek down at items below
                IEnumIDList *penum;
                if (S_OK == _GetEnum(psfItem, NULL, &penum))
                {
                    ULONG celt;
                    LPITEMIDLIST pidlTemp;
                    
                    if (penum->Next(1, &pidlTemp, &celt) == S_OK && celt == 1)
                    {
                        //do not call ShouldShow here because we will end up without + if the item is filtered out
                        //it's better to have an extra + that is going to go away when user clicks on it
                        //than to not be able to expand item with valid children
                        cChildren = 1;
                        ILFree(pidlTemp);
                    }
                    penum->Release();
                }
                psfItem->Release();
            }
        }
    }
    
    return cChildren;
}

void CNscTree::_OnGetDisplayInfo(TV_DISPINFO *pnm)
{
    PORDERITEM poi = GetPoi(pnm->item.lParam);
    LPCITEMIDLIST pidl = _CacheParentShellFolder(pnm->item.hItem, poi->pidl);
    ASSERT(pidl);
    if (pidl == NULL)
        return;
    ASSERT(_psfCache);
    ASSERT(pnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN));
    if (pnm->item.mask & TVIF_TEXT)
    {
        SHELLDETAILS details;
        if (SUCCEEDED(_GetDisplayNameOf(pidl, SHGDN_INFOLDER, &details)))
            StrRetToBuf(&details.str, pidl, pnm->item.pszText, pnm->item.cchTextMax);
    }
    // make sure we set the attributes for those flags that need them
    if (pnm->item.mask & (TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE))
    {
        ULONG ulAttrs = SHGetAttributes(_psfCache, pidl, SFGAO_FOLDER | SFGAO_STREAM | SFGAO_NEWCONTENT);
        // review chrisny:  still need to handle notify of changes from
        //  other navs.
        
        // HACKHACK!!!  we're using the TVIS_FOCUSED bit to stored whether there's
        // new content or not. 
        if (ulAttrs & SFGAO_NEWCONTENT)
        {
            pnm->item.mask |= TVIF_STATE;
            pnm->item.stateMask = TVIS_FOCUSED;  // init state mask to bold
            pnm->item.state = TVIS_FOCUSED;  // init state mask to bold
        }
        // Also see if this guy has any child folders
        if (pnm->item.mask & TVIF_CHILDREN)
            pnm->item.cChildren = _GetChildren(_psfCache, pidl, ulAttrs);
        
        if (pnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE))
            // We now need to map the item into the right image index.
            _GetDefaultIconIndex(pidl, ulAttrs, &pnm->item, (ulAttrs & SFGAO_FOLDER));

        _UpdateItemDisplayInfo(pnm->item.hItem);
    }
    // force the treeview to store this so we don't get called back again
    pnm->item.mask |= TVIF_DI_SETITEM;
}

#define SZ_CUTA                 "cut"
#define SZ_CUT                  TEXT(SZ_CUTA)
#define SZ_RENAMEA              "rename"
#define SZ_RENAME               TEXT(SZ_RENAMEA)

void CNscTree::_ApplyCmd(HTREEITEM hti, IContextMenu *pcm, UINT idCmd)
{
    TCHAR szCommandString[40];
    BOOL fHandled = FALSE;
    BOOL fCutting = FALSE;
    
    // We need to special case the rename command
    if (SUCCEEDED(ContextMenu_GetCommandStringVerb(pcm, idCmd, szCommandString, ARRAYSIZE(szCommandString))))
    {
        if (StrCmpI(szCommandString, SZ_RENAME)==0) 
        {
            TreeView_EditLabel(_hwndTree, hti);
            fHandled = TRUE;
        } 
        else if (!StrCmpI(szCommandString, SZ_CUT)) 
        {
            fCutting = TRUE;
        }
    }
    
    if (!fHandled)
    {
        CMINVOKECOMMANDINFO ici = {
            sizeof(CMINVOKECOMMANDINFO),
                0,
                _hwndTree,
                MAKEINTRESOURCEA(idCmd),
                NULL, NULL,
                SW_NORMAL,
        };
        
        HRESULT hr = pcm->InvokeCommand(&ici);
        if (fCutting && SUCCEEDED(hr))
        {
            TV_ITEM tvi;
            tvi.mask = TVIF_STATE;
            tvi.stateMask = TVIS_CUT;
            tvi.state = TVIS_CUT;
            tvi.hItem = hti;
            TreeView_SetItem(_hwndTree, &tvi);
            
            // _hwndNextViewer = SetClipboardViewer(_hwndTree);
            // _htiCut = hti;
        }
        
        //hack to force a selection update, so oc can update it's status text
        if (_mode & MODE_CONTROL)
        {
            HTREEITEM hti = TreeView_GetSelection(_hwndTree);
            
            ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);
            TreeView_SelectItem(_hwndTree, NULL);
            
            //only select the item if the handle is still valid
            if (hti)
                TreeView_SelectItem(_hwndTree, hti);
            ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);
        }
    }
}


// perform actions like they were chosen from the context menu, but without showing the menu
HRESULT CNscTree::_InvokeContextMenuCommand(BSTR strCommand)
{
    ASSERT(strCommand);
    HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
    
    if (htiSelected)
    {
        if (StrCmpIW(strCommand, L"rename") == 0) 
        {
            _fOkToRename = TRUE;  //otherwise label editing is canceled
            TreeView_EditLabel(_hwndTree, htiSelected);
            _fOkToRename = FALSE;
        }
        else
        {
            LPCITEMIDLIST pidl = _CacheParentShellFolder(htiSelected, NULL);
            if (pidl)
            {
                IContextMenu *pcm;
                if (SUCCEEDED(_psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, IID_PPV_ARG_NULL(IContextMenu, &pcm))))
                {
                    CHAR szCommand[MAX_PATH];
                    SHUnicodeToAnsi(strCommand, szCommand, ARRAYSIZE(szCommand));
                    
                    // QueryContextMenu, even though unused, initializes the folder properly (fixes delete subscription problems)
                    HMENU hmenu = CreatePopupMenu();
                    if (hmenu)
                        pcm->QueryContextMenu(hmenu, 0, 0, 0x7fff, CMF_NORMAL);

                    /* Need to try twice, in case callee is ANSI-only */
                    CMINVOKECOMMANDINFOEX ici = 
                    {
                        CMICEXSIZE_NT4,         /* Be NT4-compat */
                        CMIC_MASK_UNICODE,
                        _hwndTree,
                        szCommand,
                        NULL, NULL,
                        SW_NORMAL,
                        0, NULL,
                        NULL,
                        strCommand,
                        NULL, NULL,
                        NULL,
                    };
                    
                    HRESULT hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
                    if (hr == E_INVALIDARG) 
                    {
                        // Recipient didn't like the unicode command; send an ANSI one
                        ici.cbSize = sizeof(CMINVOKECOMMANDINFO);
                        ici.fMask &= ~CMIC_MASK_UNICODE;
                        pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
                    }

                    // do any visuals for cut state
                    if (SUCCEEDED(hr) && StrCmpIW(strCommand, L"cut") == 0) 
                    {
                        HTREEITEM hti = TreeView_GetSelection(_hwndTree);
                        if (hti) 
                        {
                            _TreeSetItemState(hti, TVIS_CUT, TVIS_CUT);
                            ASSERT(!_hwndNextViewer);
                            _hwndNextViewer = ::SetClipboardViewer(_hwndTree);
                            _htiCut = hti;
                        }
                    }
                    if (hmenu)
                        DestroyMenu(hmenu);
                    pcm->Release();
                }
            }
        }
        
        //if properties was invoked, who knows what might have changed, so force a reselect
        if (StrCmpNW(strCommand, L"properties", 10) == 0)
        {
            TreeView_SelectItem(_hwndTree, htiSelected);
        }
    }

    return S_OK;
}

//
//  pcm = IContextMenu for the item the user selected
//  hti = the item the user selected
//
//  Okay, this menu thing is kind of funky.
//
//  If "Favorites", then everybody gets "Create new folder".
//
//  If expandable:
//      Show "Expand" or "Collapse"
//      (accordingly) and set it as the default.
//
//  If not expandable:
//      The default menu of the underlying context menu is
//      used as the default; or use the first item if nobody
//      picked a default.
//
//      We replace the existing "Open" command with our own.
//

HMENU CNscTree::_CreateContextMenu(IContextMenu *pcm, HTREEITEM hti)
{
    BOOL fExpandable = _IsExpandable(hti);
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        pcm->QueryContextMenu(hmenu, 0, RSVIDM_CONTEXT_START, 0x7fff, CMF_EXPLORE | CMF_CANRENAME);

        //  Always delete "Create shortcut" from the context menu.
        ContextMenu_DeleteCommandByName(pcm, hmenu, RSVIDM_CONTEXT_START, L"link");
        
        //  Sometimes we need to delete "Open":
        //
        //  History mode always.  The context menu for history mode folders
        //  has "Open" but it doesn't work, so we need to replace it with
        //  Expand/Collapse.  And the context menu for history mode items
        //  has "Open" but it opens in a new window.  We want to navigate.
        //
        //  Favorites mode, expandable:  Leave "Open" alone -- it will open
        //  the expandable thing in a new window.
        //
        //  Favorites mode, non-expandable: Delete the original "Open" and
        //  replace it with ours that does a navigate.
        //
        BOOL fReplaceOpen = (_mode & MODE_HISTORY) || (!fExpandable && (_mode & MODE_FAVORITES));
        if (fReplaceOpen)
            ContextMenu_DeleteCommandByName(pcm, hmenu, RSVIDM_CONTEXT_START, L"open");

        // Load the NSC part of the context menu and party on it separately.
        // By doing this, we save the trouble of having to do a SHPrettyMenu
        // after we dork it -- Shell_MergeMenus does all the prettying
        // automatically.  NOTE: this is totally bogus reasoning - cleaner code the other way around...

        HMENU hmenuctx = LoadMenuPopup_PrivateNoMungeW(POPUP_CONTEXT_NSC);
        if (hmenuctx)
        {
            // create new folder doesn't make sense outside of favorites
            // (actually, it does, but there's no interface to it)
            if (!(_mode & MODE_FAVORITES))
                DeleteMenu(hmenuctx, RSVIDM_NEWFOLDER, MF_BYCOMMAND);

            //  Of "Expand", "Collapse", or "Open", we will keep at most one of
            //  them.  idmKeep is the one we choose to keep.
            //
            UINT idmKeep;
            if (fExpandable)
            {
                // Even if the item has no children, we still show Expand.
                // The reason is that an item that has never been expanded
                // is marked as "children: unknown" so we show an Expand
                // and then the user picks it and nothing expands.  And then
                // the user clicks it again and the Expand option is gone!
                // (Because the second time, we know that the item isn't
                // expandable.)
                //
                // Better to be consistently wrong than randomly wrong.
                //
                if (_IsItemExpanded(hti))
                    idmKeep = RSVIDM_COLLAPSE;
                else
                    idmKeep = RSVIDM_EXPAND;
            }
            else if (!(_mode & MODE_CONTROL))
            {
                idmKeep = RSVIDM_OPEN;
            }
            else
            {
                idmKeep = 0;
            }

            //  Now go decide which of RSVIDM_COLLAPSE, RSVIDM_EXPAND, or
            //  RSVIDM_OPEN we want to keep.
            //
            if (idmKeep != RSVIDM_EXPAND)
                DeleteMenu(hmenuctx, RSVIDM_EXPAND,   MF_BYCOMMAND);
            if (idmKeep != RSVIDM_COLLAPSE)
                DeleteMenu(hmenuctx, RSVIDM_COLLAPSE, MF_BYCOMMAND);
            if (idmKeep != RSVIDM_OPEN)
                DeleteMenu(hmenuctx, RSVIDM_OPEN,     MF_BYCOMMAND);

            // in normal mode we want to gray out expand if folder cannot be expanded
            if (idmKeep == RSVIDM_EXPAND && _mode == MODE_NORMAL)
            {
                TV_ITEM tvi;
                tvi.mask = TVIF_CHILDREN;
                tvi.hItem = hti;
                if (TreeView_GetItem(_hwndTree, &tvi) && !tvi.cChildren)
                {
                    EnableMenuItem(hmenuctx, RSVIDM_EXPAND, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
                }
            }
            
            Shell_MergeMenus(hmenu, hmenuctx, 0, 0, 0xFFFF, fReplaceOpen ? 0 : MM_ADDSEPARATOR);

            DestroyMenu(hmenuctx);

            if (idmKeep)
                SetMenuDefaultItem(hmenu, idmKeep, MF_BYCOMMAND);
        }

        // Menu item "Open in New Window" needs to be disabled if the restriction is set
        if( SHRestricted2W(REST_NoOpeninNewWnd, NULL, 0))
        {
            EnableMenuItem(hmenu, RSVIDM_CONTEXT_START + RSVIDM_OPEN_NEWWINDOW, 
                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        _SHPrettyMenu(hmenu);
    }
    return hmenu;
}

LRESULT CNscTree::_OnContextMenu(short x, short y)
{
    HTREEITEM hti;
    POINT ptPopup;  // in screen coordinate

    //assert that the SetFocus() below won't be ripping focus away from anyone
    ASSERT((_mode & MODE_CONTROL) ? (GetFocus() == _hwndTree) : TRUE);

    if (x == -1 && y == -1)
    {
        // Keyboard-driven: Get the popup position from the selected item.
        hti = TreeView_GetSelection(_hwndTree);
        if (hti)
        {
            RECT rc;
            //
            // Note that TV_GetItemRect returns it in client coordinate!
            //
            TreeView_GetItemRect(_hwndTree, hti, &rc, TRUE);
            //cannot point to middle of item rect because if item name cannot fit into control rect
            //treeview puts tooltip on top and rect returned above is from tooltip whose middle
            //may not be in Treeview which causes problems later in the function
            ptPopup.x = rc.left + 1;
            ptPopup.y = (rc.top + rc.bottom) / 2;
            ::MapWindowPoints(_hwndTree, HWND_DESKTOP, &ptPopup, 1);
        }
        //so we can go into rename mode
        _fOkToRename = TRUE;
    }
    else
    {
        TV_HITTESTINFO tvht;

        // Mouse-driven: Pick the treeitem from the position.
        ptPopup.x = x;
        ptPopup.y = y;

        tvht.pt = ptPopup;
        ::ScreenToClient(_hwndTree, &tvht.pt);

        hti = TreeView_HitTest(_hwndTree, &tvht);
    }

    if (hti)
    {
        LPCITEMIDLIST pidl = _CacheParentShellFolder(hti, NULL);
        if (pidl)
        {
            IContextMenu *pcm;

            TreeView_SelectDropTarget(_hwndTree, hti);

            if (SUCCEEDED(_psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, IID_PPV_ARG_NULL(IContextMenu, &pcm))))
            {
                pcm->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcmSendTo));

                HMENU hmenu = _CreateContextMenu(pcm, hti);
                if (hmenu)
                {
                    UINT idCmd;

                    _pcm = pcm; // for IContextMenu2 code

                    // use _hwnd so menu msgs go there and I can forward them
                    // using IContextMenu2 so "Sent To" works

                    // review chrisny:  useTrackPopupMenuEx for clipping etc.  
                    idCmd = TrackPopupMenu(hmenu,
                        TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                        ptPopup.x, ptPopup.y, 0, _hwndTree, NULL);
                    // Note:  must requery selected item to verify that the hti is good.  This
                    // solves the problem where the hti was deleted, hence pointed to something
                    // bogus, then we write to it causing heap corruption, while the menu was up.  
                    TV_HITTESTINFO tvht;
                    tvht.pt = ptPopup;
                    ::ScreenToClient(_hwndTree, &tvht.pt);
                    hti = TreeView_HitTest(_hwndTree, &tvht);
                    if (hti && idCmd)
                    {
                        switch (idCmd)
                        {
                        case RSVIDM_OPEN:
                        case RSVIDM_EXPAND:
                        case RSVIDM_COLLAPSE:
                            TreeView_SelectItem(_hwndTree, hti);
                            //  turn off flag, so select will have an effect.
                            _fOkToRename = FALSE;
                            _OnSelChange(FALSE);     // selection has changed, force the navigation.
                            //  SelectItem may not expand (if was closed and selected)
                            TreeView_Expand(_hwndTree, hti, idCmd == RSVIDM_COLLAPSE ? TVE_COLLAPSE : TVE_EXPAND);
                            break;

                        // This WAS unix only, now win32 does it too
                        // IEUNIX : We allow new folder creation from context menu. since
                        // this control was used to organize favorites in IEUNIX4.0
                        case RSVIDM_NEWFOLDER:
                            CreateNewFolder(hti);
                            break;

                        default:
                            _ApplyCmd(hti, pcm, idCmd-RSVIDM_CONTEXT_START);
                            break;
                        }

                        //we must have had focus before (asserted above), but we might have lost it after a delete.
                        //get it back.
                        //this is only a problem in the nsc oc.
                        if ((_mode & MODE_CONTROL) && !_fInLabelEdit)
                            ::SetFocus(_hwndTree);
                    }
                    ATOMICRELEASE(_pcmSendTo);
                    DestroyMenu(hmenu);
                    _pcm = NULL;
                }
                pcm->Release();
            }
            TreeView_SelectDropTarget(_hwndTree, NULL);
        }
    }

    if (x == -1 && y == -1)
        _fOkToRename = FALSE;

    return S_FALSE;       // So WM_CONTEXTMENU message will not come.
}


HRESULT CNscTree::_QuerySelection(IContextMenu **ppcm, HTREEITEM *phti)
{
    HRESULT hr = E_FAIL;
    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
    if (hti)
    {
        LPCITEMIDLIST pidl = _CacheParentShellFolder(hti, NULL);
        if (pidl)
        {
            if (ppcm)
            {
                hr = _psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, 
                    IID_PPV_ARG_NULL(IContextMenu, ppcm));
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    
    if (phti)
        *phti = hti;
    
    return hr;
}

LRESULT NSCEditBoxSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    if (uIdSubclass == ID_NSC_SUBCLASS && uMsg == WM_GETDLGCODE)
    {
        return DLGC_WANTMESSAGE;
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CNscTree::_OnBeginLabelEdit(TV_DISPINFO *ptvdi)
{
    BOOL fCantRename = TRUE;
    LPCITEMIDLIST pidl = _CacheParentShellFolder(ptvdi->item.hItem, NULL);
    if (pidl)
    {
        if (SHGetAttributes(_psfCache, pidl, SFGAO_CANRENAME))
            fCantRename = FALSE;
    }

    HWND hwndEdit = (HWND)::SendMessage(_hwndTree, TVM_GETEDITCONTROL, 0, 0);
    if (hwndEdit)
    {
        WCHAR szName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(_psfCache, pidl, SHGDN_INFOLDER|SHGDN_FOREDITING, szName, ARRAYSIZE(szName))))
        {
            SHLimitInputEdit(hwndEdit, _psfCache);
            ::SetWindowText(hwndEdit, szName);
        }
        
        SetWindowSubclass(hwndEdit, NSCEditBoxSubclassWndProc, ID_NSC_SUBCLASS, NULL);
    }
    
    _fInLabelEdit = !fCantRename;
    if (_fInLabelEdit)
        _htiRenaming = ptvdi->item.hItem;
        
    return fCantRename;
}

//
// Utility function for CNSCTree::_OnEndLabelEdit
//  Does not set the new value in the tree view if the old
//   value is the same.
//
BOOL CNscTree::_LabelEditIsNewValueValid(TV_DISPINFO *ptvdi)
{
    ASSERT(ptvdi && ptvdi->item.hItem);
    
    TCHAR szOldValue[MAX_PATH];

    szOldValue[0] = '\0';
    
    TV_ITEM tvi;
    tvi.mask       = TVIF_TEXT;
    tvi.hItem      = (HTREEITEM)ptvdi->item.hItem;
    tvi.pszText    = szOldValue;
    tvi.cchTextMax = ARRAYSIZE(szOldValue);
    TreeView_GetItem(_hwndTree, &tvi);
    
    //
    // is the old value in the control unequal to the new one?
    //
    return (0 != StrCmp(tvi.pszText, ptvdi->item.pszText));
}

LRESULT CNscTree::_OnEndLabelEdit(TV_DISPINFO *ptvdi)
{
    HWND hwndEdit = (HWND)::SendMessage(_hwndTree, TVM_GETEDITCONTROL, 0, 0);
    if (hwndEdit)
    {
        RemoveWindowSubclass(hwndEdit, NSCEditBoxSubclassWndProc, ID_NSC_SUBCLASS);
    }

#ifdef UNIX
    // IEUNIX (APPCOMPAT): If we lose activation in the  middle of rename operation
    // and we have invalid name in the   edit box, rename operation will popup 
    // a message box which causes IE on unix to go into infinite focus changing
    // loop. To workaround this problem, we are considering the operation as 
    // cancelled and we copy the original value into the buffer.

    BOOL fHasActivation = FALSE;

    if (GetActiveWindow() && IsChild(GetActiveWindow(), _hwndTree))
        fHasActivation = TRUE;

    if (!fHasActivation)
    {
       
        TV_ITEM tvi;
        tvi.mask = TVIF_TEXT;
        tvi.hItem = (HTREEITEM)ptvdi->item.hItem;
        tvi.pszText = ptvdi->item.pszText;  
        tvi.cchTextMax = ptvdi->item.cchTextMax;
        TreeView_GetItem(_hwndTree, &tvi);
    }
#endif

    if ((ptvdi->item.pszText != NULL) && _LabelEditIsNewValueValid(ptvdi))
    {
        ASSERT(ptvdi->item.hItem);
        
        LPCITEMIDLIST pidl = _CacheParentShellFolder(ptvdi->item.hItem, NULL);
        if (pidl)
        {
            WCHAR wszName[MAX_PATH - 5]; //-5 to work around nt4 shell32 bug
            SHTCharToUnicode(ptvdi->item.pszText, wszName, ARRAYSIZE(wszName));
            
            if (SUCCEEDED(_psfCache->SetNameOf(_hwndTree, pidl, wszName, 0, NULL)))
            {
                // NOTES: pidl is no longer valid here.
                
                // Set the handle to NULL in the notification to let
                // the system know that the pointer is probably not
                // valid anymore.
                ptvdi->item.hItem = NULL;
                _FlushNotifyMessages(_hwndTree);    // do this last, else we get bad results
                _fInLabelEdit = FALSE;
#ifdef UNIX
                SHChangeNotifyHandleEvents();
#endif
            }
            else
            {
                // not leaving label edit mode here, so do not set _fInLabelEdit to FALSE or we
                // will not get ::TranslateAcceleratorIO() and backspace, etc, will not work.
                _fOkToRename = TRUE;  //otherwise label editing is canceled
                ::SendMessage(_hwndTree, TVM_EDITLABEL, (WPARAM)ptvdi->item.pszText, (LPARAM)ptvdi->item.hItem);
                _fOkToRename = FALSE;
            }
        }
    }
    else
        _fInLabelEdit = FALSE;

    if (!_fInLabelEdit)
        _htiRenaming = NULL;
        
    //else user cancelled, nothing to do here.
    return 0;   // We always return 0, "we handled it".
}    
    
BOOL _DidDropOnRecycleBin(IDataObject *pdtobj)
{
    CLSID clsid;
    return SUCCEEDED(DataObj_GetBlob(pdtobj, g_cfTargetCLSID, &clsid, sizeof(clsid))) &&
           IsEqualCLSID(clsid, CLSID_RecycleBin);
}

void CNscTree::_OnBeginDrag(NM_TREEVIEW *pnmhdr)
{
    LPCITEMIDLIST pidl = _CacheParentShellFolder(pnmhdr->itemNew.hItem, NULL);
    _htiDragging = pnmhdr->itemNew.hItem;   // item we are dragging.
    if (pidl)
    {
        if (_pidlDrag)
        {
            ILFree(_pidlDrag);
            _pidlDrag = NULL;
        }

        DWORD dwEffect = SHGetAttributes(_psfCache, pidl, DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK);
        if (dwEffect)
        {
            IDataObject *pdtobj;
            HRESULT hr = _psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, IID_PPV_ARG_NULL(IDataObject, &pdtobj));
            if (SUCCEEDED(hr))
            {
                HWND hwndTT;
                
                _fDragging = TRUE;
                if (hwndTT = TreeView_GetToolTips(_hwndTree))
                    ::SendMessage(hwndTT, TTM_POP, (WPARAM) 0, (LPARAM) 0);
                PORDERITEM poi = _GetTreeOrderItem(pnmhdr->itemNew.hItem);
                if (poi)
                {
                    _iDragSrc = poi->nOrder;
                    TraceMsg(TF_NSC, "NSCBand: Starting Drag");
                    _pidlDrag = ILClone(poi->pidl);
                    _htiFolderStart = TreeView_GetParent(_hwndTree, pnmhdr->itemNew.hItem);
                    if (_htiFolderStart == NULL)
                        _htiFolderStart = TVI_ROOT;
                }
                else
                {
                    _iDragSrc = -1;
                    _pidlDrag = NULL;
                    _htiFolderStart = NULL;
                }

                //
                // Don't allow drag and drop of channels if
                // REST_NoRemovingChannels is set.
                //
                if (!SHRestricted2(REST_NoRemovingChannels, NULL, 0) ||
                    !_IsChannelFolder(_htiDragging))
                {
                    HIMAGELIST himlDrag;
                
                    SHLoadOLE(SHELLNOTIFY_OLELOADED); // Browser Only - our shell32 doesn't know ole has been loaded

                    _fStartingDrag = TRUE;
                    IDragSourceHelper* pdsh = NULL;
                    if (SUCCEEDED(CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER, 
                        IID_PPV_ARG(IDragSourceHelper, &pdsh))))
                    {
                        pdsh->InitializeFromWindow(_hwndTree, &pnmhdr->ptDrag, pdtobj);
                        _fStartingDrag = FALSE;
                    }
                    else
                    {
                        himlDrag = TreeView_CreateDragImage(_hwndTree, pnmhdr->itemNew.hItem);
                        _fStartingDrag = FALSE;
                
                        if (himlDrag) 
                        {
                            DAD_SetDragImage(himlDrag, NULL);
                        }
                    }
           
                    hr = SHDoDragDrop(_hwndTree, pdtobj, NULL, dwEffect, &dwEffect);

                    // the below follows the logic in defview for non-filesystem deletes.
                    InitClipboardFormats();
                    if ((DRAGDROP_S_DROP == hr) &&
                        (DROPEFFECT_MOVE == dwEffect) &&
                        (DROPEFFECT_MOVE == DataObj_GetDWORD(pdtobj, g_cfPerformedEffect, DROPEFFECT_NONE)))
                    {
                        // enable UI for the recycle bin case (the data will be lost
                        // as the recycle bin really can't recycle stuff that is not files)

                        UINT uFlags = _DidDropOnRecycleBin(pdtobj) ? 0 : CMIC_MASK_FLAG_NO_UI;
                        SHInvokeCommandOnDataObject(_hwndTree, NULL, pdtobj, uFlags, "delete");
                    }
                    else if (dwEffect == DROPEFFECT_NONE)
                    {
                        // nothing happened when the d&d terminated, so clean up you fool.
                        ILFree(_pidlDrag);
                        _pidlDrag = NULL;
                    }

                    if (pdsh)
                    {
                        pdsh->Release();
                    }
                    else
                    {
                        DAD_SetDragImage((HIMAGELIST)-1, NULL);
                        ImageList_Destroy(himlDrag);
                    }
                }

                _iDragSrc = -1;
                pdtobj->Release();
            }
        }
    }
    _htiDragging = NULL;
}

BOOL IsExpandableChannelFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
        return SHIsExpandableFolder(psf, pidl);

    ASSERT(pidl);
    ASSERT(psf);

    BOOL          fExpand = FALSE;
    IShellFolder* psfChannelFolder;
    if (pidl && psf && SUCCEEDED(SHBindToObject(psf, IID_X_PPV_ARG(IShellFolder, pidl, &psfChannelFolder))))
    {
        IEnumIDList *penum;
        if (S_OK == psfChannelFolder->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum))
        {
            ULONG celt;
            LPITEMIDLIST pidlTemp;

            if (penum->Next(1, &pidlTemp, &celt) == S_OK && celt == 1)
            {
                ILFree(pidlTemp);
                fExpand = FALSE;
            }
            if (penum->Next(1, &pidlTemp, &celt) == S_OK && celt == 1)
            {
                ILFree(pidlTemp);
                fExpand = TRUE;
            }
            penum->Release();
        }
        psfChannelFolder->Release();
    }

    return fExpand;
}

BOOL CNscTree::_OnSelChange(BOOL fMark)
{
    BOOL fExpand = TRUE;
    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
    BOOL fMultiSelect = _dwFlags & NSS_MULTISELECT;

    //if we're in control mode (where pnscProxy always null), never navigate
    if (hti)
    {
        LPCITEMIDLIST pidlItem = _CacheParentShellFolder(hti, NULL);
        if (pidlItem && !fMultiSelect)
        {
            if (_pnscProxy && !_fInSelectPidl)
            {
                ULONG ulAttrs = SFGAO_FOLDER | SFGAO_NEWCONTENT;
                LPITEMIDLIST pidlTarget;
                LPITEMIDLIST pidlFull = _GetFullIDList(hti);
                HRESULT hr = _pnscProxy->GetNavigateTarget(pidlFull, &pidlTarget, &ulAttrs);
                if (SUCCEEDED(hr))
                {
                    if (hr == S_OK)
                    {
                        _pnscProxy->Invoke(pidlTarget);
                        ILFree(pidlTarget);
                    }
                    // review chrisny:  still need to handle notify of changes from
                    //  other navs.
                    if (ulAttrs & SFGAO_NEWCONTENT)
                    {
                        TV_ITEM tvi;
                        tvi.hItem = hti;
                        tvi.mask = TVIF_STATE | TVIF_HANDLE;
                        tvi.stateMask = TVIS_FOCUSED;  // the BOLD bit is to be
                        tvi.state = 0;              // cleared
                    
                        TreeView_SetItem(_hwndTree, &tvi);
                    }
                }
                else
                {
                    if (!(SHGetAttributes(_psfCache, pidlItem, SFGAO_FOLDER)))
                        SHInvokeDefaultCommand(_hwndTree, _psfCache, pidlItem);
                }

                ILFree(pidlFull);
                fExpand = hr != S_OK && (ulAttrs & SFGAO_FOLDER);
            }
        }
    }

    if (fMultiSelect)
    {
        if (fMark)
        {
            UINT uState = TreeView_GetItemState(_hwndTree, hti, NSC_TVIS_MARKED) & NSC_TVIS_MARKED;

            uState ^= NSC_TVIS_MARKED;
            _MarkChildren(hti, uState == NSC_TVIS_MARKED);
            _htiActiveBorder = NULL;
        }
    }
    else if (!_fSingleExpand && fExpand && (_mode != MODE_NORMAL))
    {
        TreeView_Expand(_hwndTree, hti, TVE_TOGGLE);
    }

    if (!fMultiSelect)
        _UpdateActiveBorder(hti);

    return TRUE;
}

void CNscTree::_OnSetSelection()
{
    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
    LPITEMIDLIST pidlItem = _GetFullIDList(hti);

    if (_pnscProxy && !_fInSelectPidl)
    {
        _pnscProxy->OnSelectionChanged(pidlItem);
    }    

    ILFree(pidlItem);
}

void CNscTree::_OnGetInfoTip(NMTVGETINFOTIP* pnm)
{
    // No info tip operation on drag/drop
    if (_fDragging || _fDropping || _fClosing || _fHandlingShellNotification || _fInSelectPidl)
        return;

    PORDERITEM poi = GetPoi(pnm->lParam);
    if (poi)
    {
        LPITEMIDLIST pidl = _CacheParentShellFolder(pnm->hItem, poi->pidl);
        if (pidl)
        {
            // Use the imported Browseui function because the one in shell\lib does
            // not work on browser-only platforms
            GetInfoTip(_psfCache, pidl, pnm->pszText, pnm->cchTextMax);
        }
    }
}

LRESULT CNscTree::_OnSetCursor(NMMOUSE* pnm)
{
    if (_mode == MODE_NORMAL && _fShouldShowAppStartCursor)
    {
        SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        return 1;
    }

    if (!pnm->dwItemData)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return 1;
    }

    if (!(_mode & MODE_CONTROL) && (_mode != MODE_NORMAL))
    {
        ITEMINFO* pii = GetPii(pnm->dwItemData);
        if (pii) 
        {
            if (!pii->fNavigable)
            {
                //folders always get the arrow
                SetCursor(LoadCursor(NULL, IDC_ARROW));
            }
            else
            {
                //favorites always get some form of the hand
                HCURSOR hCursor = pii->fGreyed ? (HCURSOR)LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_OFFLINE_HAND)) :
                                         LoadHandCursor(0);
                if (hCursor)
                    SetCursor(hCursor);
            }
        }
    }
    else
    {
        //always show the arrow in org favs
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
    
    return 1; // 1 if We handled it, 0 otherwise
}

BOOL CNscTree::_IsTopParentItem(HTREEITEM hti)
{
    return (hti && (!TreeView_GetParent(_hwndTree, hti)));
}

LRESULT CNscTree::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;

    switch (pnm->idFrom)
    {
    case ID_CONTROL:
        {
            switch (pnm->code) 
            {
            case NM_CUSTOMDRAW:
                return _OnCDNotify((LPNMCUSTOMDRAW)pnm);

            case TVN_GETINFOTIP:
                // no info tips on drag/drop ops
                // According to Bug#241601, Tooltips display too quickly. The problem is
                // the original designer of the InfoTips in the Treeview merged the "InfoTip" tooltip and
                // the "I'm too small to display correctly" tooltips. This is really unfortunate because you
                // cannot control the display of these tooltips independantly. Therefore we are turning off
                // infotips in normal mode.
                if (!_fInLabelEdit && _mode != MODE_NORMAL)
                    _OnGetInfoTip((NMTVGETINFOTIP*)pnm);
                else 
                    return FALSE;
                break;
                
            case NM_SETCURSOR:
                lres = _OnSetCursor((NMMOUSE*)pnm);
                break;
                
            case NM_SETFOCUS:
            case NM_KILLFOCUS:
                if (pnm->code == NM_KILLFOCUS)
                {
                    _fHasFocus = FALSE;

                    //invalidate the item because tabbing away doesn't
                    RECT rc;

                    // Tree can focus and not have any items.
                    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
                    if (hti)
                    {
                        TreeView_GetItemRect(_hwndTree, hti, &rc, FALSE);
                        //does this need to be UpdateWindow? only if focus rect gets left behind.
                        ::InvalidateRect(_hwndTree, &rc, FALSE);
                    }
                }
                else
                {
                    _fHasFocus = TRUE;
                }

                // do this for both set and kill focus...
                if (_dwFlags & NSS_MULTISELECT)
                {
                    HTREEITEM hti = TreeView_GetNextItem(_hwndTree, NULL, TVGN_FIRSTVISIBLE);

                    while (hti)
                    {
                        UINT uState = TreeView_GetItemState(_hwndTree, hti, NSC_TVIS_MARKED);
                        
                        if (uState & NSC_TVIS_MARKED)
                        {
                            RECT rc;

                            TreeView_GetItemRect(_hwndTree, hti, &rc, FALSE);
                            //does this need to be UpdateWindow? only if focus rect gets left behind.
                            ::InvalidateRect(_hwndTree, &rc, FALSE);
                        }
                        hti = TreeView_GetNextItem(_hwndTree, hti, TVGN_NEXTVISIBLE);
                    }
                }
                break;

            case TVN_KEYDOWN:
                {
                    TV_KEYDOWN *ptvkd = (TV_KEYDOWN *) pnm;
                    switch (ptvkd->wVKey)
                    {
                    case VK_RETURN:
                    case VK_SPACE:
                        _OnSelChange(TRUE);
                        lres = TRUE;
                        break;

                    case VK_DELETE:
                        if (!((_mode & MODE_HISTORY) && IsInetcplRestricted(L"History")))
                        {
                            // in explorer band we never come here
                            // and in browse for folder we cannot ignore the selection
                            // because we will end up with nothing selected
                            if (_mode != MODE_NORMAL)
                                _fIgnoreNextSelChange = TRUE;
                            InvokeContextMenuCommand(L"delete");
                        }
                        break;

                    case VK_UP:
                    case VK_DOWN:
                        //VK_MENU == VK_ALT
                        if ((_mode != MODE_HISTORY) && (_mode != MODE_NORMAL)  && (GetKeyState(VK_MENU) < 0))
                        {
                            MoveItemUpOrDown(ptvkd->wVKey == VK_UP);
                            lres = 0;
                            _fIgnoreNextSelChange = TRUE;
                        }
                        break;
                    
                    case VK_F2:
                        //only do this in org favs, because the band accel handler usually processes this
                        //SHBrowseForFolder doesn't have band to process it so do it in normal mode as well
                        if ((_mode & MODE_CONTROL) || _mode == MODE_NORMAL)
                            InvokeContextMenuCommand(L"rename");
                        break;

                    default:
                        break;
                    }
                        
                    if (!_fSingleExpand && !(_dwFlags & NSS_MULTISELECT))
                        _UpdateActiveBorder(TreeView_GetSelection(_hwndTree));
                }
                break;

            case TVN_SELCHANGINGA:
            case TVN_SELCHANGING:
                {
                    //hack because treeview keydown ALWAYS does it's default processing
                    if (_fIgnoreNextSelChange)
                    {
                        _fIgnoreNextSelChange = FALSE;
                        return TRUE;
                    }

                    NM_TREEVIEW * pnmtv = (NM_TREEVIEW *) pnm;

                    //if it's coming from somewhere weird (like a WM_SETFOCUS), don't let it select
                    return (pnmtv->action != TVC_BYKEYBOARD) && (pnmtv->action != TVC_BYMOUSE) && (pnmtv->action != TVC_UNKNOWN);
                }
                break;
                
            case TVN_SELCHANGEDA:
            case TVN_SELCHANGED:
                if (_fSelectFromMouseClick)
                {
                    _OnSetSelection();
                }
                else
                {
                    ::KillTimer(_hwndTree, IDT_SELECTION);
                    ::SetTimer(_hwndTree, IDT_SELECTION, GetDoubleClickTime(), NULL);
                }
#ifdef DEBUG
                {
                    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
                    LPITEMIDLIST pidl = _GetFullIDList(hti);
                    if (pidl)
                    {
                        TCHAR sz[MAX_PATH];
                        SHGetNameAndFlags(pidl, SHGDN_NORMAL, sz, SIZECHARS(sz), NULL);
                        TraceMsg(TF_NSC, "NSCBand: Selecting %s", sz);
                        //
                        // On NT4 and W95 shell this call will miss the history
                        // shell extension junction point.  It will then deref into
                        // history pidls as if they were shell pidls.  On short
                        // history pidls this would fault on a debug version of the OS.
                        //
                        // SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, sz, SIZECHARS(sz), NULL);
                        //TraceMsg(TF_NSC, "displayname = %s", sz);
                        ILFree(pidl);
                    }
                }
#endif  // DEBUG
                break;

            case TVN_GETDISPINFO:
                _OnGetDisplayInfo((TV_DISPINFO *)pnm);
                break;

            case TVN_ITEMEXPANDING: 
                TraceMsg(TF_NSC, "NSCBand: Expanding");
                if (!_fIgnoreNextItemExpanding)
                {
                    lres = _OnItemExpandingMsg((LPNM_TREEVIEW)pnm);
                }
                else if (!_fInExpand) // pretend we processed it if we are expanding to avoid recursion
                {
                    lres = TRUE;
                }
                break;
                
            case TVN_DELETEITEM:
                _OnDeleteItem((LPNM_TREEVIEW)pnm);
                break;
                
            case TVN_BEGINDRAG:
            case TVN_BEGINRDRAG:
                _OnBeginDrag((NM_TREEVIEW *)pnm);
                break;
                
            case TVN_BEGINLABELEDIT:
                //this is to prevent slow double-click rename in favorites and history
                if (_mode != MODE_NORMAL && !_fOkToRename)
                    return 1;

                lres = _OnBeginLabelEdit((TV_DISPINFO *)pnm);

                if (_punkSite)
                    IUnknown_UIActivateIO(_punkSite, TRUE, NULL);
                break;
                
            case TVN_ENDLABELEDIT:
                lres = _OnEndLabelEdit((TV_DISPINFO *)pnm);
                break;
                
            case TVN_SINGLEEXPAND:
            case NM_DBLCLK:
                break;
                
            case NM_CLICK:
            {
                //if someone clicks on the selected item, force a selection change (to force a navigate)
                DWORD dwPos = GetMessagePos();
                TV_HITTESTINFO tvht;
                HTREEITEM hti;
                tvht.pt.x = GET_X_LPARAM(dwPos);
                tvht.pt.y = GET_Y_LPARAM(dwPos);
                ::ScreenToClient(_hwndTree, &tvht.pt);
                hti = TreeView_HitTest(_hwndTree, &tvht);

                // But not if they click on the button, since that means that they
                // are merely expanding/contracting and not selecting
                if (hti && !(tvht.flags & TVHT_ONITEMBUTTON))
                {
                    _fSelectFromMouseClick = TRUE;
                    TreeView_SelectItem(_hwndTree, hti);
                    _OnSelChange(TRUE);
                    _fSelectFromMouseClick = FALSE;
                }
                break;
            }
                
            case NM_RCLICK:
            {
                DWORD dwPos = GetMessagePos();
                _fOkToRename = TRUE;
                lres = _OnContextMenu(GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos));
                _fOkToRename = FALSE;
                break;
            }
                
            default:
                break;
            }
        } // case ID_CONTROL

    case ID_HEADER:
        {
            switch (pnm->code) 
            {
            case HDN_TRACK:
                break;
                
            case HDN_ENDTRACK:
                ::InvalidateRect(_hwndTree, NULL, TRUE);
                break;
                
            default:
                break;
            }
        }

    default:
        break;
    }
    
    return lres;
}

HRESULT CNscTree::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // review chrisny:  better error return here.
    _fHandlingShellNotification = TRUE;
    _OnChangeNotify(lEvent, pidl1, pidl2);
    _fHandlingShellNotification = FALSE;
    return S_OK;
}

// in comctl32 v5 there is no way to programmatically select an item (in single expand mode)
// without expanding it, so we fake it here by setting _fIgnoreNextItemExpanding to true and then
// rejecting expansion when it is set
void CNscTree::_SelectNoExpand(HWND hwnd, HTREEITEM hti)
{
    UINT uFlags = TVGN_CARET;
    if (IsOS(OS_WHISTLERORGREATER))
        uFlags |= TVSI_NOSINGLEEXPAND; // new for v6
    else if (_fSingleExpand)
        _fIgnoreNextItemExpanding = TRUE;

    _fInExpand = TRUE; // Treeview will force expand the parents, make sure we know it's not the user clicking on items   
    TreeView_Select(hwnd, hti, uFlags);
    _fInExpand = FALSE;
    _fIgnoreNextItemExpanding = FALSE;
}

void CNscTree::_SelectPidl(LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert)
{ 
    HTREEITEM hti;
    // _ExpandToItem doesn't play well with empty pidl (i.e. desktop)
    if (_mode == MODE_NORMAL && ILIsEqual(pidl, _pidlRoot))
        hti = _FindFromRoot(NULL, pidl);
    else
        hti = _ExpandToItem(pidl, fCreate, fReinsert);
        
    if (hti != NULL)
    {
        _SelectNoExpand(_hwndTree, hti);
#ifdef DEBUG
        TraceHTREE(hti, TEXT("Found"));
#endif
    }
}

HTREEITEM CNscTree::_ExpandToItem(LPCITEMIDLIST pidl, BOOL fCreate /*= TRUE*/, BOOL fReinsert /*= FALSE*/)
{
    HTREEITEM       hti = NULL;
    LPITEMIDLIST    pidlItem = NULL;
    LPCITEMIDLIST   pidlTemp = NULL;
    LPITEMIDLIST pidlParent;
    TV_ITEM         tvi;
    IShellFolder    *psf = NULL;
    IShellFolder    *psfNext = NULL;
    HRESULT hr = S_OK;

#ifdef DEBUG
    TracePIDLAbs(pidl, TEXT("Attempting to select"));
#endif
    
    // We need to do this so items that are rooted at the Desktop, are found 
    // correctly.
    HTREEITEM htiParent = (_mode == MODE_NORMAL) ? TreeView_GetRoot(_hwndTree) : TVI_ROOT;
    ASSERT((_hwndTree != NULL) && (pidl != NULL));
    
    if (_hwndTree == NULL) 
        goto LGone;

    // We should unify the "FindFromRoot" code path and this one.
    pidlParent = _pidlRoot;
    if (ILIsEmpty(pidlParent))
    {
        pidlTemp = pidl;
        SHGetDesktopFolder(&psf);
    }
    else
    {
        if ((pidlTemp = ILFindChild(pidlParent, pidl)) == NULL)
        {
            goto LGone;    // not root match, no hti
        }

        // root match, carry on . . .   
        hr = IEBindToObject(pidlParent, &psf);
    }

    if (FAILED(hr))
    {
        goto LGone;
    }
    
    while (!ILIsEmpty(pidlTemp))
    {
        if ((pidlItem = ILCloneFirst(pidlTemp)) == NULL)
            goto LGone;
        pidlTemp = _ILNext(pidlTemp);

        // Since we are selecting a pidl, we need to make sure it's parent is visible.
        // We do it this before the insert, so that we don't have to check for duplicates.
        // when enumerating NTDev it goes from about 10min to about 8 seconds.
        if (htiParent != TVI_ROOT)
        {
            // Check to see if it's expanded.
            tvi.mask = TVIF_STATE;
            tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
            tvi.hItem = htiParent;
            if (!TreeView_GetItem(_hwndTree, &tvi))
            {
                goto LGone;
            }

            // If not, Expand it.
            if (!(tvi.state & TVIS_EXPANDED))
            {
                _pidlExpandingTo = pidlItem;
                _ExpandNode(htiParent, TVE_EXPAND, 1);
                _pidlExpandingTo = NULL;
            }
        }

        // Now that we have it enumerated, check to see if the child if there.
        hti = _FindChild(psf, htiParent, pidlItem);
        // fReinsert will allow us to force the item to be reinserted
        if (hti && fReinsert) 
        {
            ASSERT(fCreate);
            TreeView_DeleteItem(_hwndTree, hti);
            hti = NULL;
        }

        // Do we have a child in the newly expanded tree?
        if (NULL == hti)
        {
            // No. We must have to create it.
            if (!fCreate)
            {
                // But, we're not allowed to... Shoot.
                goto LGone;
            }

            if (S_OK != _InsertChild(htiParent, psf, pidlItem, FALSE, FALSE, DEFAULTORDERPOSITION, &hti))
            {
                goto LGone;
            }
        }

        if (htiParent != TVI_ROOT)
        {
            tvi.mask = TVIF_STATE;
            tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
            tvi.hItem = htiParent;
            if (TreeView_GetItem(_hwndTree, &tvi))
            {
                if (!(tvi.state & TVIS_EXPANDED))
                {
                    TreeView_SetChildren(_hwndTree, htiParent, NSC_CHILDREN_ADD);  // Make sure the expand will do something
                    _fIgnoreNextItemExpanding = TRUE;
                    _ExpandNode(htiParent, TVE_EXPAND | TVE_EXPANDPARTIAL, 1);
                    _fIgnoreNextItemExpanding = FALSE;
                }
            }
        }

        // we don't need to bind if its the last one
        //   -- a half-implemented ISF might not like this bind...
        if (!ILIsEmpty(pidlTemp))
            hr = psf->BindToObject(pidlItem, NULL, IID_PPV_ARG(IShellFolder, &psfNext));

        ILFree(pidlItem);
        pidlItem = NULL;
        if (FAILED(hr))
            goto LGone;

        htiParent = hti;
        psf->Release();
        psf = psfNext;
        psfNext = NULL;
    }
LGone:
    
    if (psf != NULL)
        psf->Release();
    if (psfNext != NULL)
        psfNext->Release();
    if (pidlItem != NULL)
        ILFree(pidlItem);

    return hti;    
}


HRESULT CNscTree::GetSelectedItem(LPITEMIDLIST * ppidl, int nItem)
{
    HRESULT hr = E_INVALIDARG;

    // nItem will be used in the future when we support multiple selections.
    // GetSelectedItem() returns S_FALSE and (NULL == *ppidl) if not that many
    // items are selected.  Not yet implemented.
    if (nItem > 0)
    {
        *ppidl = NULL;
        return S_FALSE;
    }

    if (ppidl)
    {
        *ppidl = NULL;
        // Is the ListView still there?
        if (_fIsSelectionCached)
        {
            // No, so get the selection that was saved before
            // the listview was destroyed.
            if (_pidlSelected)
            {
                *ppidl = ILClone(_pidlSelected);
                hr = S_OK;
            }
            else
                hr = S_FALSE;
        }
        else
        {
            HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);

            if (htiSelected)
            {
                *ppidl = _GetFullIDList(htiSelected);
                hr = S_OK;
            }
            else
                hr = S_FALSE;
        }
    }

    return hr;
}


HRESULT CNscTree::SetSelectedItem(LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert, int nItem)
{
    // nItem will be used in the future when we support multiple selections.
    // Not yet implemented.
    if (nItem > 0)
    {
        return S_FALSE;
    }
    
    //  Override fCreate if the object no longer exists
    DWORD dwAttributes = SFGAO_VALIDATE;
    fCreate = fCreate && SUCCEEDED(IEGetAttributesOf(pidl, &dwAttributes));
    
    //  We probably haven't seen the ChangeNotify yet, so we tell
    //  _SelectPidl to create any folders that are there
    //  Then select the pidl, expanding as necessary
    _fInSelectPidl = TRUE;
    _SelectPidl(pidl, fCreate, fReinsert);
    _fInSelectPidl = FALSE;

    return S_OK;
}

//***   CNscTree::IWinEventHandler
HRESULT CNscTree::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hr = E_FAIL;

    ULONG_PTR cookie = 0;
    // FUSION: When nsc calls out to 3rd party code we want it to use 
    // the process default context. This means that the 3rd party code will get
    // v5 in the explorer process. However, if shell32 is hosted in a v6 process,
    // then the 3rd party code will still get v6. 
    // Future enhancements to this codepath may include using the fusion manifest
    // tab <noinherit> which basically surplants the activat(null) in the following
    // codepath. This disables the automatic activation from user32 for the duration
    // of this wndproc, essentially doing this null push.
    // we need to do this here as well as in _SubClassTreeWndProc as someone could have
    // set v6 context before getting in here (band site,...)
    NT5_ActivateActCtx(NULL, &cookie); 

    switch (uMsg) 
    {
    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        hr = S_OK;
        break;
        
    case WM_PALETTECHANGED:
        _OnPaletteChanged(wParam, lParam);
        // are we really supposed to return E_FAIL here?
        break;

    default:
        break;
    }

    if (cookie != 0)
        NT5_DeactivateActCtx(cookie);

    return hr;
}


void CNscTree::_OnChangeNotify(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    switch (lEvent)
    {
    case SHCNE_RENAMEFOLDER:
    case SHCNE_RENAMEITEM:
        if (pidl && pidlExtra)
            _OnSHNotifyRename(pidl, pidlExtra);
        else
            ASSERT(FALSE);
        
        break;
        
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
    case SHCNE_DRIVEREMOVED:
        if (pidl)
            _OnSHNotifyDelete(pidl, NULL, NULL);
        else
            ASSERT(FALSE);
        break;


    case SHCNE_UPDATEITEM:
        // when nsc browses other namespaces, sometimes an updateitem could be fired
        // on a pidl thats actually expanded in the tree, so check for it.
        if (pidl)
        {
            IShellFolder* psf = NULL;
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(_ParentFromItem(pidl, &psf, &pidlChild)))
            {
                LPITEMIDLIST pidlReal;
                if (SUCCEEDED(_IdlRealFromIdlSimple(psf, pidlChild, &pidlReal)) && pidlReal)
                {
                    // zip files receive updateitem when they really mean updatedir
                    if (SHGetAttributes(psf, pidlReal, SFGAO_FOLDER | SFGAO_STREAM) == (SFGAO_FOLDER | SFGAO_STREAM))
                    {
                        _OnSHNotifyUpdateDir(pidl);
                    }
                    _OnSHNotifyUpdateItem(pidl, pidlReal);
                    ILFree(pidlReal);
                }
                psf->Release();
            }
        }
        break;

    case SHCNE_NETSHARE:
    case SHCNE_NETUNSHARE:
        if (pidl)
            _OnSHNotifyUpdateItem(pidl, NULL);
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
    case SHCNE_DRIVEADD:
        if (pidl)
        {
            _OnSHNotifyCreate(pidl, DEFAULTORDERPOSITION, NULL);
            if (SHCNE_MKDIR == lEvent &&
                _pidlNewFolderParent &&
                ILIsParent(_pidlNewFolderParent, pidl, TRUE)) // TRUE = immediate parent only
            {
                EVAL(SUCCEEDED(_EnterNewFolderEditMode(pidl)));
            }
        }
        break;

    case SHCNE_UPDATEDIR:
        if (pidl)
        {
            _OnSHNotifyUpdateDir(pidl);
        }
        break;

    case SHCNE_MEDIAREMOVED:
    case SHCNE_MEDIAINSERTED:
        if (pidl)
        {
            HTREEITEM hti = _FindFromRoot(NULL, pidl);
            if (hti)
            {
                if (lEvent == SHCNE_MEDIAREMOVED)
                {
                    LPITEMIDLIST pidlSelected;
                    if (SUCCEEDED(GetSelectedItem(&pidlSelected, 0)))
                    {
                        if (ILIsEqual(pidl, pidlSelected) || ILIsParent(pidl, pidlSelected, FALSE))
                        {
                            IShellFolder *psf;
                            if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), NULL)))
                            {
                                BOOL fSelected = FALSE;
                                for (HTREEITEM htiSelect = TreeView_GetNextSibling(_hwndTree, hti); htiSelect; htiSelect = TreeView_GetNextSibling(_hwndTree, htiSelect))
                                {
                                    PORDERITEM poi = _GetTreeOrderItem(htiSelect);
                                    if (poi)
                                    {
                                        if (!SHGetAttributes(psf, poi->pidl, SFGAO_REMOVABLE))
                                        {
                                            _SelectNoExpand(_hwndTree, htiSelect);
                                            fSelected = TRUE;
                                            break;
                                        }
                                    }
                                }

                                if (!fSelected)
                                {
                                    _SelectNoExpand(_hwndTree, TreeView_GetParent(_hwndTree, hti));
                                }
                                psf->Release();
                            }
                        }
                        ILFree(pidlSelected);
                    }
                    TreeView_DeleteChildren(_hwndTree, hti);
                    TreeView_Expand(_hwndTree, hti, TVE_COLLAPSE | TVE_COLLAPSERESET); // reset the item
                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_REMOVE);
                }
                else
                {
                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_CALLBACK);
                }
                
                _TreeInvalidateItemInfo(hti, TVIF_TEXT);
            }
        }
        break;
        
    case SHCNE_DRIVEADDGUI:
    case SHCNE_SERVERDISCONNECT:
    case SHCNE_ASSOCCHANGED:
        break;

    case SHCNE_UPDATEIMAGE:
        if (pidl) 
        {
            int iIndex;
            if (pidlExtra)
            {   // new style update image notification.....
                iIndex = SHHandleUpdateImage(pidlExtra);
                if (iIndex == -1)
                    break;
            }
            else
                iIndex = *(int UNALIGNED *)((BYTE*)pidl + 2);
            
            _InvalidateImageIndex(NULL, iIndex);
        }
        break;
    case SHCNE_EXTENDED_EVENT:
        {
            SHChangeDWORDAsIDList UNALIGNED *pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl;
            
            INT_PTR iEvent = pdwidl->dwItem1;

            switch (iEvent)
            {
            case SHCNEE_ORDERCHANGED:
                if (EVAL(pidl))
                {
                    if (_fDropping ||                           // If WE are dropping.
                        _fInLabelEdit ||                        // We're editing a name (Kicks us out)
                        SHChangeMenuWasSentByMe(this, pidl)  || // Ignore if we sent it.
                        (_mode == MODE_HISTORY))                // Always ignore history changes
                    {
                        TraceMsg(TF_NSC, "NSCBand: Ignoring Change Notify: We sent");
                        //ignore the notification                    
                    }
                    else
                    {
                        TraceMsg(TF_BAND, "NSCBand: OnChange SHCNEE_ORDERCHANGED accepted");
                        
                        _dwOrderSig++;

                        HTREEITEM htiRoot = _FindFromRoot(TVI_ROOT, pidlExtra);
                        if (htiRoot != NULL)
                            _UpdateDir(htiRoot, FALSE);
                    }
                }
                break;
            case SHCNEE_WININETCHANGED:
                {
                    if (pdwidl->dwItem2 & (CACHE_NOTIFY_SET_ONLINE | CACHE_NOTIFY_SET_OFFLINE))
                    {
                        BOOL fOnline = !SHIsGlobalOffline();
                        if ((fOnline && !_fOnline) || (!fOnline && _fOnline))
                        {
                            // State changed
                            _fOnline = fOnline;
                            _OnSHNotifyOnlineChange(TVI_ROOT, _fOnline);
                        }
                    }
                    
                    if (pdwidl->dwItem2 & (CACHE_NOTIFY_ADD_URL |
                        CACHE_NOTIFY_DELETE_URL |   
                        CACHE_NOTIFY_DELETE_ALL |
                        CACHE_NOTIFY_URL_SET_STICKY |
                        CACHE_NOTIFY_URL_UNSET_STICKY))
                    {
                        // Something in the cache changed
                        _OnSHNotifyCacheChange(TVI_ROOT, pdwidl->dwItem2);
                    }
                    break;
                }
            }
            break;
        }
        break;
    }
    return;
}

// note, this duplicates SHGetRealIDL() so we work in non integrated shell mode
// WARNING: if it is not a file system pidl SFGAO_FILESYSTEM, we don't need to do this...
// but this is only called in the case of SHCNE_CREATE for shell notify
// and all shell notify pidls are SFGAO_FILESYSTEM
HRESULT CNscTree::_IdlRealFromIdlSimple(IShellFolder *psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST *ppidlReal)
{
    WCHAR wszPath[MAX_PATH];
    ULONG cbEaten;
    HRESULT hr = S_OK;
    if (FAILED(DisplayNameOf(psf, pidlSimple, SHGDN_FORPARSING | SHGDN_INFOLDER, wszPath, ARRAYSIZE(wszPath))) ||
        FAILED(psf->ParseDisplayName(NULL, NULL, wszPath, &cbEaten, ppidlReal, NULL)))
    {
        hr = SHILClone(pidlSimple, ppidlReal);   // we don't own the lifetime of pidlSimple
    }

    return hr;
}


HRESULT CNscTree::Refresh(void)
{
    _bSynchId++;
    if (_bSynchId >= 16)
        _bSynchId = 0;

    TraceMsg(TF_NSC, "Expensive Refresh of tree");
    _htiActiveBorder = NULL;
    HRESULT hr = S_OK;
    if (_pnscProxy)
    {
        DWORD dwStyle, dwExStyle;
        if (SUCCEEDED(_pnscProxy->RefreshFlags(&dwStyle, &dwExStyle, &_grfFlags)))
        {
            dwStyle = _SetStyle(dwStyle); // initializes new _style and returns old one
            if ((dwStyle ^ _style) & ~WS_VISIBLE) // don't care if only visible changed
            {
                DWORD dwMask = (_style | dwStyle) & ~WS_VISIBLE; // don't want to change visible style
                SetWindowBits(_hwndTree, GWL_STYLE, dwMask, _style);
            }

            dwExStyle = _SetExStyle(dwExStyle);
            if (dwExStyle != _dwExStyle)
                TreeView_SetExtendedStyle(_hwndTree, _dwExStyle, dwExStyle | _dwExStyle);
        }
    }

    if (MODE_NORMAL == _mode)
    {
        BOOL fOrdered;
        _fUpdate = TRUE;
        _StartBackgroundEnum(TreeView_GetChild(_hwndTree, TVI_ROOT), _pidlRoot, &fOrdered, TRUE);
        _fUpdate = FALSE;
    }
    else
    {
        LPITEMIDLIST pidlRoot;
        hr = SHILClone(_pidlRoot, &pidlRoot);    // Need to do this because it's freed
        if (SUCCEEDED(hr))
        {
            HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
            TV_ITEM tvi;
            tvi.mask = TVIF_HANDLE | TVIF_STATE;
            tvi.stateMask = TVIS_EXPANDED;
            tvi.hItem = (HTREEITEM)htiSelected;
            BOOL fExpanded = (TreeView_GetItem(_hwndTree, &tvi) && (tvi.state & TVIS_EXPANDED));

            LPITEMIDLIST pidlSelect;
            GetSelectedItem(&pidlSelect, 0);
            
            _ChangePidlRoot(pidlRoot);
            if (pidlSelect)
            {
                _Expand(pidlSelect, fExpanded ? 1 : 0);
                ILFree(pidlSelect);
            }

            ILFree(pidlRoot);
        }
    }

    return hr;
}

void CNscTree::_CacheDetails()
{
    if (_ulDisplayCol == (ULONG)-1)
    {        
        _ulSortCol = _ulDisplayCol = 0;
        
        if (_psf2Cache)
        {
            _psf2Cache->GetDefaultColumn(0, &_ulSortCol, &_ulDisplayCol);
        }
    }
}

HRESULT CNscTree::_GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, 
                                    LPSHELLDETAILS pdetails)
{
    ASSERT(_psfCache);
    _CacheDetails();
    if (_ulDisplayCol)
        return _psf2Cache->GetDetailsOf(pidl, _ulDisplayCol, pdetails);
    return _psfCache->GetDisplayNameOf(pidl, uFlags, &pdetails->str);
}

// if fSort, then compare for sort, else compare for existence.
HRESULT CNscTree::_CompareIDs(IShellFolder *psf, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    _CacheDetails();

    return psf->CompareIDs(_ulSortCol, pidl1, pidl2);
}

HRESULT CNscTree::_ParentFromItem(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild)
{
    return IEBindToParentFolder(pidl, ppsfParent, ppidlChild);
} 

COLORREF CNscTree::_GetRegColor(COLORREF clrDefault, LPCTSTR pszName)
{
    // Fetch the specified alternate color

    COLORREF clrValue;
    DWORD cbData = sizeof(clrValue);
    if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, pszName, NULL, &clrValue, &cbData)))
    {
        return clrDefault;
    }
    return clrValue;
}

LRESULT CNscTree::_OnCDNotify(LPNMCUSTOMDRAW pnm)
{
    LRESULT     lres = CDRF_DODEFAULT;

    ASSERT(pnm->hdr.idFrom == ID_CONTROL);

    if (_dwFlags & NSS_NORMALTREEVIEW)
    {
        LPNMTVCUSTOMDRAW pnmTVCustomDraw = (LPNMTVCUSTOMDRAW) pnm;
        if (pnmTVCustomDraw->nmcd.dwDrawStage == CDDS_PREPAINT)
        {
            if (_fShowCompColor)
            {
                return CDRF_NOTIFYITEMDRAW;
            }
            else
            {
                return lres;
            }
        }

        if (pnmTVCustomDraw->nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
        {
            PORDERITEM pOrderItem = GetPoi(pnmTVCustomDraw->nmcd.lItemlParam);
            if (pOrderItem && pOrderItem->pidl)
            {
                LPCITEMIDLIST pidl = _CacheParentShellFolder((HTREEITEM)pnmTVCustomDraw->nmcd.dwItemSpec, pOrderItem->pidl);
                if (pidl)
                {
                    DWORD dwAttribs = SHGetAttributes(_psfCache, pidl, SFGAO_COMPRESSED | SFGAO_ENCRYPTED);
                    // either compressed, or encrypted, can never be both
                    if (dwAttribs & SFGAO_COMPRESSED)
                    {
                        // If it is the item is hi-lited (selected, and has focus), blue text is not visible with the hi-lite...
                        if ((pnmTVCustomDraw->nmcd.uItemState & CDIS_SELECTED) && (pnmTVCustomDraw->nmcd.uItemState & CDIS_FOCUS))
                            pnmTVCustomDraw->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                        else
                            pnmTVCustomDraw->clrText = _GetRegColor(RGB(0, 0, 255), TEXT("AltColor"));  // default Blue
                    }
                    else if (dwAttribs & SFGAO_ENCRYPTED)
                    {
                        if ((pnmTVCustomDraw->nmcd.uItemState & CDIS_SELECTED) && (pnmTVCustomDraw->nmcd.uItemState & CDIS_FOCUS))
                            pnmTVCustomDraw->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                        else
                            pnmTVCustomDraw->clrText = _GetRegColor(RGB(19, 146, 13), TEXT("AltEncryptionColor")); // default Luna Mid Green
                    }
                }
            }
        }

        return lres;
    }

    switch (pnm->dwDrawStage) 
    {
    case CDDS_PREPAINT:
        if (NSS_BROWSERSELECT & _dwFlags)
            lres = CDRF_NOTIFYITEMDRAW;
        break;
        
    case CDDS_ITEMPREPAINT:
        {
            //APPCOMPAT davemi: why is comctl giving us empty rects?
            if (IsRectEmpty(&(pnm->rc)))
                break;
            PORDERITEM poi = GetPoi(pnm->lItemlParam);
            DWORD dwFlags = 0;
            COLORREF    clrBk, clrText;
            LPNMTVCUSTOMDRAW pnmtv = (LPNMTVCUSTOMDRAW)pnm;             
            TV_ITEM tvi;
            TCHAR sz[MAX_URL_STRING];
            tvi.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_STATE;
            tvi.stateMask = TVIS_EXPANDED | TVIS_STATEIMAGEMASK | TVIS_DROPHILITED;
            tvi.pszText = sz;
            tvi.cchTextMax = MAX_URL_STRING;
            tvi.hItem = (HTREEITEM)pnm->dwItemSpec;
            if (!TreeView_GetItem(_hwndTree, &tvi))
                break;
            //
            //  See if we have fetched greyed/pinned information for this item yet 
            //
            ITEMINFO * pii = GetPii(pnm->lItemlParam);
            pii->fFetched = TRUE;

            if (pii->fGreyed && !(_mode & MODE_CONTROL))
                dwFlags |= DIGREYED;
            if (pii->fPinned)
                dwFlags |= DIPINNED;

            if (!pii->fNavigable)
                dwFlags |= DIFOLDER;
            
            dwFlags |= DIICON;
            
            if (_style & TVS_RTLREADING)
                dwFlags |= DIRTLREADING;

            clrBk   = TreeView_GetBkColor(_hwndTree);
            clrText = GetSysColor(COLOR_WINDOWTEXT);

            //if we're renaming an item, don't draw any text for it (otherwise it shows behind the item)
            if (tvi.hItem == _htiRenaming)
                sz[0] = 0;

            if (tvi.state & TVIS_EXPANDED)
                dwFlags |= DIFOLDEROPEN;
            
            if (!(_dwFlags & NSS_MULTISELECT) && ((pnm->uItemState & CDIS_SELECTED) || (tvi.state & TVIS_DROPHILITED)))
            {
                if (_fHasFocus || tvi.state & TVIS_DROPHILITED)
                {
                    clrBk = GetSysColor(COLOR_HIGHLIGHT);
                    clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                }
                else
                {
                    clrBk = GetSysColor(COLOR_BTNFACE);
                }
//                    dwFlags |= DIFOCUSRECT;
            }

            if (pnm->uItemState & CDIS_HOT)
            {
                if (!(_mode & MODE_CONTROL))
                    dwFlags |= DIHOT;
                clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);

                if (clrText == clrBk)
                    clrText = GetSysColor(COLOR_HIGHLIGHT);
            }

            if ((_dwFlags & NSS_MULTISELECT) && (pnm->uItemState & CDIS_SELECTED))
                dwFlags |= DIACTIVEBORDER | DISUBFIRST | DISUBLAST;

            if (tvi.state & NSC_TVIS_MARKED)
            {                
                if (_dwFlags & NSS_MULTISELECT)
                {
                    if (_fHasFocus)
                    {
                        clrBk = GetSysColor(COLOR_HIGHLIGHT);
                        clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                    }
                    else
                    {
                        clrBk = GetSysColor(COLOR_BTNFACE);
                    }
                }
                else
                {
                    dwFlags |= DIACTIVEBORDER;
                    //top level item
                    if (_IsTopParentItem((HTREEITEM)pnm->dwItemSpec)) 
                    {
                        dwFlags |= DISUBFIRST;
                        if (!(tvi.state & TVIS_EXPANDED))
                            dwFlags |= DISUBLAST;
                    }
                    else    // lower level items
                    {                                                                
                        HTREEITEM hti;

                        dwFlags |= DISUBITEM;
                        if (((HTREEITEM)pnm->dwItemSpec) == _htiActiveBorder)
                            dwFlags |= DISUBFIRST;
                        
                        hti = TreeView_GetNextVisible(_hwndTree, (HTREEITEM)pnm->dwItemSpec);
                        if ((hti && !_IsMarked(hti)) || (hti == NULL))
                            dwFlags |= DISUBLAST;
                    }
                }
            }

            if ((_dwFlags & NSS_HEADER) && _hwndHdr && 
                    _CacheParentShellFolder((HTREEITEM)pnm->dwItemSpec, poi->pidl) && 
                    _psf2Cache)
            {
                // with header we don't draw active order because it looks ugly,
                // but with multiselect we do because that's how we differentiate selected items
                if (!(_dwFlags & NSS_MULTISELECT))
                    dwFlags &= ~DIACTIVEBORDER;
                    
                RECT rc;

                CopyRect(&rc, &(pnm->rc));
                for (int i=0; i<DPA_GetPtrCount(_hdpaColumns); i++)
                {
                    RECT rcHeader;
                    int iLevel = 0;
                    HEADERINFO *phinfo = (HEADERINFO *)DPA_GetPtr(_hdpaColumns, i);
                    
                    ASSERT(phinfo);
                    Header_GetItemRect(_hwndHdr, i, &rcHeader);
                    rc.left = rcHeader.left;
                    rc.right = rcHeader.right;
                    if (i == 0) //it is name column
                    {
                        iLevel = pnmtv->iLevel;
                        //use sz set above in the function
                    }
                    else
                    {
                        // in multiselect draw border only around the name
                        dwFlags &= ~DIACTIVEBORDER;
                        dwFlags = 0;
                        if (phinfo->fmt & LVCFMT_RIGHT)
                            dwFlags |= DIRIGHT;
                        clrBk   = TreeView_GetBkColor(_hwndTree);
                        clrText = GetSysColor(COLOR_WINDOWTEXT);

                        sz[0] = 0;

                        VARIANT var;
                        if (SUCCEEDED(_psf2Cache->GetDetailsEx(poi->pidl, phinfo->pscid, &var)))
                        {
                            VariantToStr(&var, sz, ARRAYSIZE(sz));
                        }
                    }
                    _DrawItem((HTREEITEM)pnm->dwItemSpec, sz, pnm->hdc, &rc, dwFlags, iLevel, clrBk, clrText);
                }
            }
            else
            {
                _DrawItem((HTREEITEM)pnm->dwItemSpec, sz, pnm->hdc, &(pnm->rc), dwFlags, pnmtv->iLevel, clrBk, clrText);
            }
            lres = CDRF_SKIPDEFAULT;
            break;
        }
    case CDDS_POSTPAINT:
        break;
    }
    
    return lres;
} 

// *******droptarget implementation.
void CNscTree::_DtRevoke()
{
    if (_fDTRegistered)
    {
        RevokeDragDrop(_hwndTree);
        _fDTRegistered = FALSE;
    }
}

void CNscTree::_DtRegister()
{
    if (!_fDTRegistered && (_dwFlags & NSS_DROPTARGET))
    {
        if (::IsWindow(_hwndTree))
        {
            HRESULT hr = THR(RegisterDragDrop(_hwndTree, SAFECAST(this, IDropTarget*)));
            _fDTRegistered = BOOLIFY(SUCCEEDED(hr));
        }
        else
            ASSERT(FALSE);
    }
}

HRESULT CNscTree::GetWindowsDDT(HWND * phwndLock, HWND * phwndScroll)
{
    if (!::IsWindow(_hwndTree))
    {
        ASSERT(FALSE);
        return S_FALSE;
    }
    *phwndLock = /*_hwndDD*/_hwndTree;
    *phwndScroll = _hwndTree;
    return S_OK;
}
const int iInsertThresh = 6;

// We use this as the sentinal "This is where you started"
#define DDT_SENTINEL ((DWORD_PTR)(INT_PTR)-1)

HRESULT CNscTree::HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR *pdwId, DWORD * pdwDropEffect)
{                                              
    switch (nEvent)
    {
    case HTDDT_ENTER:
        break;
        
    case HTDDT_LEAVE:
    {
        _fDragging = FALSE; 
        _fDropping = FALSE; 
        DAD_ShowDragImage(FALSE);
        TreeView_SetInsertMark(_hwndTree, NULL, !_fInsertBefore);
        TreeView_SelectDropTarget(_hwndTree, NULL);
        DAD_ShowDragImage(TRUE);
        break;
    }
        
    case HTDDT_OVER: 
        {
            // review chrisny:  make function TreeView_InsertMarkHittest!!!!!
            RECT rc;
            TV_HITTESTINFO tvht;
            HTREEITEM htiOver;     // item to insert before or after.
            BOOL fWasInserting = BOOLIFY(_fInserting);
            BOOL fOldInsertBefore = BOOLIFY(_fInsertBefore);
            TV_ITEM tvi;
            PORDERITEM poi = NULL;
            IDropTarget     *pdtgt = NULL;
            HRESULT hr;
            LPITEMIDLIST    pidl;
        
            _fDragging = TRUE;
            *pdwDropEffect = DROPEFFECT_NONE;   // dropping from without.
            tvht.pt = *ppt;
            htiOver = TreeView_HitTest(_hwndTree, &tvht);
            // if no hittest assume we are dropping on the evil root.
            if (htiOver != NULL)
            {
                TreeView_GetItemRect(_hwndTree, (HTREEITEM)htiOver, &rc, TRUE);
                tvi.mask = TVIF_STATE | TVIF_PARAM | TVIF_HANDLE;
                tvi.stateMask = TVIS_EXPANDED;
                tvi.hItem = (HTREEITEM)htiOver;
                if (TreeView_GetItem(_hwndTree, &tvi))
                    poi = GetPoi(tvi.lParam);
                if (poi == NULL)
                {
                    ASSERT(FALSE);
                    return S_FALSE;
                }
            }
            else if (_mode != MODE_NORMAL) //need parity with win2k Explorer band
            {
                htiOver = TVI_ROOT;
            }

            // NO DROPPY ON HISTORY
            if (_mode & MODE_HISTORY)   
            {
                *pdwId = (DWORD_PTR)(htiOver);
                *pdwDropEffect = DROPEFFECT_NONE;   // dropping from without.
                return S_OK;
            }

            pidl = (poi == NULL) ? _pidlRoot : poi->pidl;
            pidl = _CacheParentShellFolder(htiOver, pidl);
            if (pidl)
            {
                // Is this the desktop pidl?
                if (ILIsEmpty(pidl))
                {
                    // Desktop's GetUIObject does not support the Empty pidl, so
                    // create the view object.
                    hr = _psfCache->CreateViewObject(_hwndTree, IID_PPV_ARG(IDropTarget, &pdtgt));
                }
                else
                    hr = _psfCache->GetUIObjectOf(_hwndTree, 1, (LPCITEMIDLIST *)&pidl, IID_PPV_ARG_NULL(IDropTarget, &pdtgt));
            }

            _fInserting = ((htiOver != TVI_ROOT) && ((ppt->y < (rc.top + iInsertThresh) 
                || (ppt->y > (rc.bottom - iInsertThresh)))  || !pdtgt));
            // review chrisny:  do I need folderstart == folder over?
            // If in normal mode, we never want to insert before, always _ON_...
            if (_mode != MODE_NORMAL && _fInserting)
            {
                ASSERT(poi);
                _iDragDest = poi->nOrder;   // index of item within folder pdwId
                if ((ppt->y < (rc.top + iInsertThresh)) || !pdtgt)
                    _fInsertBefore = TRUE;
                else
                {
                    ASSERT (ppt->y > (rc.bottom - iInsertThresh));
                    _fInsertBefore = FALSE;
                }
                if (_iDragSrc != -1)
                    *pdwDropEffect = DROPEFFECT_MOVE;   // moving from within.
                else
                    *pdwDropEffect = DROPEFFECT_NONE;   // dropping from without.
                // inserting, drop target is actually parent folder of this item
                if (_fInsertBefore || ((htiOver != TVI_ROOT) && !(tvi.state & TVIS_EXPANDED)))
                {
                    _htiDropInsert = TreeView_GetParent(_hwndTree, (HTREEITEM)htiOver);
                }
                else
                    _htiDropInsert = htiOver;
                if (_htiDropInsert == NULL)
                    _htiDropInsert = TVI_ROOT;
                *pdwId = (DWORD_PTR)(_htiDropInsert);
            }
            else
            {
                _htiDropInsert = htiOver;
                *pdwId = (DWORD_PTR)(htiOver);
                _iDragDest = -1;     // no insertion point.
                *pdwDropEffect = DROPEFFECT_NONE;
            }

            // if we're over the item we're dragging, don't allow drop here
            if ((_htiDragging == htiOver) || (IsParentOfItem(_hwndTree, _htiDragging, htiOver)))
            {
                *pdwDropEffect = DROPEFFECT_NONE;
                *pdwId = DDT_SENTINEL;
                _fInserting = FALSE;
                ATOMICRELEASE(pdtgt);
            }

            // update UI
            if (_htiCur != (HTREEITEM)htiOver || fWasInserting != BOOLIFY(_fInserting) || fOldInsertBefore != BOOLIFY(_fInsertBefore))
            {
                // change in target
                _dwLastTime = GetTickCount();     // keep track for auto-expanding the tree
                DAD_ShowDragImage(FALSE);
                if (_fInserting)
                {
                    TraceMsg(TF_NSC, "NSCBand: drop insert now");
                    if (htiOver != TVI_ROOT)
                    {
                        if (_mode != MODE_NORMAL)
                        {
                            TreeView_SelectDropTarget(_hwndTree, NULL);
                            TreeView_SetInsertMark(_hwndTree, htiOver, !_fInsertBefore);
                        }
                    }
                }
                else
                {
                    TraceMsg(TF_NSC, "NSCBand: drop select now");
                    if (_mode != MODE_NORMAL)
                        TreeView_SetInsertMark(_hwndTree, NULL, !_fInsertBefore);

                    if (htiOver != TVI_ROOT)
                    {
                        if (pdtgt)
                        {
                            TreeView_SelectDropTarget(_hwndTree, htiOver);       
                        }
                        else if (_mode != MODE_NORMAL)
                        {
                            // We do not want to select the drop target in normal mode
                            // because it causes a weird flashing of some item unrelated
                            // to the drag and drop when the drop is not supported.
                            TreeView_SelectDropTarget(_hwndTree, NULL);
                        }
                    }
                }
                ::UpdateWindow(_hwndTree);
                DAD_ShowDragImage(TRUE);
            }
            else
            {
                // No target change
                // auto expand the tree
                if (_htiCur)
                {
                    DWORD dwNow = GetTickCount();
                    if ((dwNow - _dwLastTime) >= 1000)
                    {
                        _dwLastTime = dwNow;
                        DAD_ShowDragImage(FALSE);
                        _fAutoExpanding = TRUE;
                        if (_htiCur != TVI_ROOT)
                            TreeView_Expand(_hwndTree, _htiCur, TVE_EXPAND);
                        _fAutoExpanding = FALSE;
                        ::UpdateWindow(_hwndTree);
                        DAD_ShowDragImage(TRUE);
                    }
                }
            }
            _htiCur = (HTREEITEM)htiOver; 
            ATOMICRELEASE(pdtgt);
        }
        break;
    }
    
    return S_OK;
}

HRESULT CNscTree::GetObjectDDT(DWORD_PTR dwId, REFIID riid, void **ppv)
{
    HRESULT hr = S_FALSE;

    if (dwId != DDT_SENTINEL)
    {
        LPCITEMIDLIST pidl = _CacheParentShellFolder((HTREEITEM)dwId, NULL);
        if (pidl)
        {
            if (ILIsEmpty(pidl))
                hr = _psfCache->CreateViewObject(_hwndTree, riid, ppv);
            else
                hr = _psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, riid, NULL, ppv);
        }
    }
    return hr;
}

HRESULT CNscTree::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr;
    
    _fAsyncDrop = FALSE;                //ASSUME
    _fDropping = TRUE;

    // move within same folder, else let Drop() handle it.
    if (_iDragSrc >= 0)
    {
        if (_htiFolderStart == _htiDropInsert && _mode != MODE_NORMAL)
        {
            if (_iDragSrc != _iDragDest)    // no moving needed
            {
                int iNewPos = _fInsertBefore ? (_iDragDest - 1) : _iDragDest;
                if (_MoveNode(_iDragSrc, iNewPos, _pidlDrag))
                {
                    TraceMsg(TF_NSC, "NSCBand:  Reordering");
                    _fDropping = TRUE;
                    _Dropped();
                    // Remove this notify message immediately (so _fDropping is set
                    // and we'll ignore this event in above OnChange method)
                    //
                    _FlushNotifyMessages(_hwndTree);
                    _fDropping = FALSE;
                }
                Pidl_Set(&_pidlDrag, NULL);
            }
            DragLeave();
            _htiCur = _htiFolderStart = NULL;
            _htiDropInsert =  (HTREEITEM)-1;
            _fDragging = _fInserting = _fDropping = FALSE;
            _iDragDest = -1;
            hr = S_FALSE;     // handled 
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        // the item will get created in SHNotifyCreate()
        TraceMsg(TF_NSC, "NSCBand:  Dropped and External Item");

        BOOL         fSafe = TRUE;
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {
            fSafe = IEIsLinkSafe(_hwndParent, pidl, ILS_ADDTOFAV);
            ILFree(pidl);
        }

        if (fSafe)
        {
            _fAsyncDrop = TRUE;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    TreeView_SetInsertMark(_hwndTree, NULL, !_fInsertBefore);
    TreeView_SelectDropTarget(_hwndTree, NULL);

    ILFree(_pidlDrag);
    _pidlDrag = NULL;

    return hr;
}

IStream * CNscTree::GetOrderStream(LPCITEMIDLIST pidl, DWORD grfMode)
{
    // only do this for favorites
    if (!ILIsEmpty(pidl) && (_mode & MODE_FAVORITES))
        return OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, pidl, REG_SUBKEY_FAVORITESA, grfMode);
    return NULL;
}

BOOL CNscTree::_MoveNode(int iDragSrc, int iNewPos, LPITEMIDLIST pidl)
{
    HTREEITEM hti, htiAfter = TVI_LAST, htiDel = NULL;
    
    // if we are not moving and not dropping directly on a folder with no insert.
    if ((iDragSrc == iNewPos) && (iNewPos != -1))
        return FALSE;       // no need to move

    int i = 0;
    for (hti = TreeView_GetChild(_hwndTree, _htiDropInsert); hti; hti = TreeView_GetNextSibling(_hwndTree, hti), i++) 
    {
        if (i == iDragSrc)
            htiDel = hti;       // save node to be deleted, can't deelete it while enumerating
        // cuz the treeview will go down the tubes.  
        if (i == iNewPos)
            htiAfter = hti;
    }
    
    if (iNewPos == -1)  // must be the first item
        htiAfter = TVI_FIRST;
    // add before delete to handle add after deleteable item case.
    _AddItemToTree(_htiDropInsert, pidl, I_CHILDRENCALLBACK, _iDragDest, htiAfter, FALSE);
    if (htiDel)
        TreeView_DeleteItem(_hwndTree, htiDel);

    _PopulateOrderList(_htiDropInsert);

    _fWeChangedOrder = TRUE;
    return TRUE;
}

void CNscTree::_Dropped(void)
{
    // Persist the new order out to the registry
    LPITEMIDLIST pidl = _GetFullIDList(_htiDropInsert);
    if (pidl)
    {
        IStream* pstm = GetOrderStream(pidl, STGM_WRITE | STGM_CREATE);
        if (pstm)
        {
            if (_CacheShellFolder(_htiDropInsert))
            {
#ifdef DEBUG
                if (_hdpaOrd)
                {
                    for (int i=0; i<DPA_GetPtrCount(_hdpaOrd); i++)
                    {
                        PORDERITEM poi = (PORDERITEM)DPA_GetPtr(_hdpaOrd, i);
                        if (poi)
                        {
                            ASSERTMSG(poi->nOrder >= 0, "nsc saving bogus order list nOrder (%d), get reljai", poi->nOrder);
                        }
                    }
                }
#endif

                OrderList_SaveToStream(pstm, _hdpaOrd, _psfCache);
                // remember we are now ordered.
                if (_htiDropInsert == TVI_ROOT)
                {
                    _fOrdered = TRUE;
                }
                else
                {
                    PORDERITEM poi = _GetTreeOrderItem(_htiDropInsert);
                    if (poi)
                    {
                        poi->lParam = (DWORD)FALSE;
                    }
                }
                // Notify everyone that the order changed
                SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, 0, pidl);
                _dwOrderSig++;
            }
            pstm->Release();
        }
        ILFree(pidl);
    }
    
    DPA_Destroy(_hdpaOrd);
    _hdpaOrd = NULL;

    _UpdateActiveBorder(_htiDropInsert);
}

CNscTree::CSelectionContextMenu::~CSelectionContextMenu()
{
    ATOMICRELEASE(_pcmSelection);
    ATOMICRELEASE(_pcm2Selection);
}

HRESULT CNscTree::CSelectionContextMenu::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CNscTree::CSelectionContextMenu, IContextMenu2),                      // IID_IContextMenu2
        QITABENTMULTI(CNscTree::CSelectionContextMenu, IContextMenu, IContextMenu2),   // IID_IContextMenu
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


ULONG CNscTree::CSelectionContextMenu::AddRef(void)
{
    CComObject<CNscTree> *pnsc = IToClass(CComObject<CNscTree>, _scm, this);
    _ulRefs++;
    return pnsc->AddRef();
}

ULONG CNscTree::CSelectionContextMenu::Release(void)
{
    CComObject<CNscTree> *pnsc = IToClass(CComObject<CNscTree>, _scm, this);
    ASSERT(_ulRefs > 0);
    _ulRefs--;
    if (0 == _ulRefs)
    {
        ATOMICRELEASE(_pcmSelection);
        ATOMICRELEASE(_pcm2Selection);
    }
    return pnsc->Release();
}

HRESULT CNscTree::CSelectionContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, 
                                                          UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    if (NULL == _pcmSelection)
    {
        return E_FAIL;
    }
    else
    {
        return _pcmSelection->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    }
}

HRESULT CNscTree::CSelectionContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HTREEITEM hti;
    CNscTree* pnsc = IToClass(CNscTree, _scm, this);
    UINT idCmd;
    
    if (!HIWORD(pici->lpVerb))
    {
        idCmd = LOWORD(pici->lpVerb);
    }
    else
    {
        return E_FAIL;
    }
    
    HRESULT hr = pnsc->_QuerySelection(NULL, &hti);
    if (SUCCEEDED(hr))
    {
        pnsc->_ApplyCmd(hti, _pcmSelection, idCmd);
    }
    return hr;
}

HRESULT CNscTree::CSelectionContextMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (NULL == _pcm2Selection)
    {
        return E_FAIL;
    }
    else
    {
        //  HACK alert.  Work around bug in win95 user code for WM_DRAWITEM that sign extends
        //  itemID
        if (!g_fRunningOnNT && WM_DRAWITEM == uMsg)
        {
            LPDRAWITEMSTRUCT lpDraw = (LPDRAWITEMSTRUCT)lParam;
            
            if (0xFFFF0000 == (lpDraw->itemID & 0xFFFF0000) &&
                (lpDraw->itemID & 0xFFFF) >= FCIDM_BROWSERFIRST &&
                (lpDraw->itemID & 0xFFFF) <= FCIDM_BROWSERLAST)
            {
                lpDraw->itemID = lpDraw->itemID & 0xFFFF;
            }
        }
        
        return _pcm2Selection->HandleMenuMsg(uMsg,wParam,lParam);
    }
}

IContextMenu *CNscTree::CSelectionContextMenu::_QuerySelection()
{
    CNscTree* pnsc = IToClass(CNscTree, _scm, this);
    
    ATOMICRELEASE(_pcmSelection);
    ATOMICRELEASE(_pcm2Selection);
    
    pnsc->_QuerySelection(&_pcmSelection, NULL);
    if (_pcmSelection)
    {
        _pcmSelection->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcm2Selection));
        AddRef();
        return SAFECAST(this, IContextMenu*);
    }
    return NULL;
}

LRESULT CALLBACK CNscTree::s_SubClassTreeWndProc(
                                  HWND hwnd, UINT uMsg, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{

    CNscTree* pns = (CNscTree*)dwRefData;
    ASSERT(pns);
    if (pns == NULL)
        return 0;

    ULONG_PTR cookie = 0;
    // FUSION: When nsc calls out to 3rd party code we want it to use 
    // the process default context. This means that the 3rd party code will get
    // v5 in the explorer process. However, if shell32 is hosted in a v6 process,
    // then the 3rd party code will still get v6. 
    // Future enhancements to this codepath may include using the fusion manifest
    // tab <noinherit> which basically surplants the activat(null) in the following
    // codepath. This disables the automatic activation from user32 for the duration
    // of this wndproc, essentially doing this null push.
    NT5_ActivateActCtx(NULL, &cookie); 
    LRESULT lres = pns->_SubClassTreeWndProc(hwnd, uMsg, wParam, lParam);
    if (cookie != 0)
        NT5_DeactivateActCtx(cookie);

    return lres;
}

LRESULT CNscTree::_SubClassTreeWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    BOOL fCallDefWndProc = TRUE;
 
    switch (uMsg)
    {
    case WM_COMMAND:
        lres = _OnCommand(wParam, lParam);
        break;

    case WM_SIZE:
        // if the width changes, we need to invalidate to redraw the ...'s at the end of the lines
        if (GET_X_LPARAM(lParam) != _cxOldWidth) {
            //FEATURE: be a bit more clever and only inval the right part where the ... can be
            ::InvalidateRect(_hwndTree, NULL, FALSE);
            _cxOldWidth = GET_X_LPARAM(lParam);
        }
        break;
        
    case WM_CONTEXTMENU:
        _OnContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        return TRUE;
        break;
        
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
        if (_pcmSendTo)
        {
            _pcmSendTo->HandleMenuMsg(uMsg, wParam, lParam);
            return TRUE;
        }
        break;

    case WM_NSCUPDATEICONOVERLAY:
        {
            NSC_OVERLAYCALLBACKINFO noci = {(DWORD) (lParam & 0x0FFFFFFF),
                                              (DWORD) ((lParam & 0xF0000000) >> 28) };
            // make sure the magic numbers match
            if (noci.nMagic == _bSynchId)
            {
                TVITEM    tvi;
                tvi.mask = TVIF_STATE;
                tvi.stateMask = TVIS_OVERLAYMASK;
                tvi.state = 0;
                tvi.hItem = (HTREEITEM)wParam;
                // This can fail if the item was moved before the async icon
                // extraction finished for that item.
                if (TreeView_GetItem(_hwndTree, &tvi))
                {
                    tvi.state = INDEXTOOVERLAYMASK(noci.iOverlayIndex);
                    TreeView_SetItem(_hwndTree, &tvi);
                }
            }
        }
        break;

    case WM_NSCUPDATEICONINFO:
        {
            NSC_ICONCALLBACKINFO nici = {(DWORD) (lParam&0x00000FFF),
                                         (DWORD) ((lParam&0x00FFF000) >> 12),
                                         (DWORD) ((lParam&0x0F000000) >> 24),
                                         (DWORD) ((lParam&0xF0000000) >> 28) };
            // make sure the magic numbers match
            if (nici.nMagic == _bSynchId)
            {
                TVITEM    tvi;
                tvi.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                tvi.hItem = (HTREEITEM)wParam;

                // This can fail if the item was moved before the async icon
                // extraction finished for that item.
                if (TreeView_GetItem(_hwndTree, &tvi))
                {
                    ITEMINFO* pii = GetPii(tvi.lParam);

                    pii->fGreyed      = BOOLIFY(nici.nFlags & NSCICON_GREYED);
                    pii->fPinned      = BOOLIFY(nici.nFlags & NSCICON_PINNED);
                    pii->fDontRefetch = BOOLIFY(nici.nFlags & NSCICON_DONTREFETCH);

                    tvi.iImage         = nici.iIcon;
                    tvi.iSelectedImage = nici.iOpenIcon;

                    TreeView_SetItem(_hwndTree, &tvi);
                }
            }
        }
        break;

    case WM_NSCBACKGROUNDENUMDONE:
        {
            if (_fShouldShowAppStartCursor)
            {
                // Restore cursor now
                _fShouldShowAppStartCursor = FALSE;
                SetCursor(LoadCursor(NULL, IDC_ARROW));
            }
            NSC_BKGDENUMDONEDATA * pbedd;
            do
            {
                EnterCriticalSection(&_csBackgroundData);
                // Extract the first element of the list
                pbedd = _pbeddList;
                if (pbedd)
                {
                    _pbeddList = pbedd->pNext;
                }
                LeaveCriticalSection(&_csBackgroundData);
                if (pbedd)
                {
                    pbedd->pNext = NULL;
                    _EnumBackgroundDone(pbedd);
                }
            } while (pbedd);
        }
        break;


    // UGLY: Win95/NT4 shell DefView code sends this msg and does not deal
    // with the failure case. other ISVs do the same so this needs to stay forever
    case CWM_GETISHELLBROWSER:
        return (LRESULT)SAFECAST(this, IShellBrowser*);  // not ref counted!

    case WM_TIMER:
        if (wParam == IDT_SELECTION)
        {
            ::KillTimer(_hwndTree, IDT_SELECTION);
            _OnSetSelection();
        }
        break;
        
    case WM_HELP:
        {
            // Let controls provide thier own help (organize favorites). The default help
            // also doesn't make sence for history (really need separate help id for history)
            if (!(_mode & (MODE_CONTROL | MODE_HISTORY)))
            {
                if (_mode & MODE_FAVORITES)
                {
                    const static DWORD aBrowseHelpIDs[] = 
                    {  // Context Help IDs
                        ID_CONTROL,         IDH_ORGFAVS_LIST,
                        0,                  0
                    };
                    ::WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
                }
                else
                {
                    // default help
                    const static DWORD aBrowseHelpIDs[] = 
                    {  // Context Help IDs
                        ID_CONTROL,         IDH_BROWSELIST,
                        0,                  0
                    };
                    ::WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
                }
            }
        }
        break;

    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
        // _HandleWinIniChange does an item height calculation that
        // depends on treeview having computed the default item height
        // already.  So we need to let treeview handle the settings
        // change before calling _HandleWinIniChange.  Also, we need
        // to reset the height to default so that treeview will
        // calculate a new default.
        TreeView_SetItemHeight(hwnd, -1);
        lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);
        _HandleWinIniChange();
        break;

    case WM_KEYDOWN:
        // Only do this when the CTRL key is not down
        if (GetKeyState(VK_CONTROL) >= 0)
        {
            if (wParam == VK_MULTIPLY)
            {
                // We set _pidlNavigatingTo to NULL here to ensure that we will be doing full expands.
                // When _pidlNavigatingTo is non null, we are doing partial expands by default, which is not
                // what we want here.
                Pidl_Set(&_pidlNavigatingTo, NULL);

                _uDepth = (UINT)-1; // to recursive expand all the way to the end
                lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);
                _uDepth = 0;
                fCallDefWndProc = FALSE;        // Don't call DefSubclassProc again.
            }
        }
        break;

    default:
        break;
    }
    
    if (fCallDefWndProc && lres == 0)
       lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);

    return lres;
}

HRESULT CNscTree::_OnPaletteChanged(WPARAM wParam, LPARAM lParam)
{
    // forward this to our child view by invalidating their window (they should never realize their palette
    // in the foreground so they don't need the message parameters.) ...
    RECT rc;
    ::GetClientRect(_hwndTree, &rc);
    ::InvalidateRect(_hwndTree, &rc, FALSE);
    
    return NOERROR;
}

void CNscTree::_InvalidateImageIndex(HTREEITEM hItem, int iImage)
{
    HTREEITEM hChild;
    TV_ITEM tvi;
    
    if (hItem)
    {
        tvi.mask = TVIF_SELECTEDIMAGE | TVIF_IMAGE;
        tvi.hItem = hItem;
        
        TreeView_GetItem(_hwndTree, &tvi);
        if (iImage == -1 || tvi.iImage == iImage || tvi.iSelectedImage == iImage) 
            _TreeInvalidateItemInfo(hItem, 0);
    }
    
    hChild = TreeView_GetChild(_hwndTree, hItem);
    if (!hChild)
        return;
    
    for (; hChild; hChild = TreeView_GetNextSibling(_hwndTree, hChild))
        _InvalidateImageIndex(hChild, iImage);
}

void CNscTree::_TreeInvalidateItemInfo(HTREEITEM hItem, UINT mask)
{
    TV_ITEM tvi;

    tvi.mask =  mask | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE;
    tvi.stateMask = TVIS_OVERLAYMASK;
    tvi.state = 0;
    tvi.hItem = hItem;
    tvi.cChildren = I_CHILDRENCALLBACK;
    tvi.iImage = I_IMAGECALLBACK;
    tvi.iSelectedImage = I_IMAGECALLBACK;
    tvi.pszText = LPSTR_TEXTCALLBACK;
    TreeView_SetItem(_hwndTree, &tvi);
}

void CNscTree::_DrawActiveBorder(HDC hdc, LPRECT prc)
{
    MoveToEx(hdc, prc->left, prc->top, NULL);
    LineTo(hdc, prc->right, prc->bottom);
}


#define DXLEFT      8
#define MAGICINDENT 3
void CNscTree::_DrawIcon(HTREEITEM hti, HDC hdc, int iLevel, RECT *prc, DWORD dwFlags)
{
    HIMAGELIST  himl = TreeView_GetImageList(_hwndTree, TVSIL_NORMAL);
    TV_ITEM     tvi;
    int         dx, dy, x, y;
    
    tvi.mask = TVIF_SELECTEDIMAGE | TVIF_IMAGE | TVIF_HANDLE;
    tvi.hItem = hti;
    if (TreeView_GetItem(_hwndTree, &tvi))
    {
        ImageList_GetIconSize(himl, &dx, &dy);    
        if (!_fStartingDrag)
            x = DXLEFT;
        else
            x = 0;
        x += (iLevel * TreeView_GetIndent(_hwndTree)); // - ((dwFlags & DIFOLDEROPEN) ? 1 : 0);
        y = prc->top + (((prc->bottom - prc->top) - dy) >> 1);
        int iImage = (dwFlags & DIFOLDEROPEN) ? tvi.iSelectedImage : tvi.iImage;
        ImageList_DrawEx(himl, iImage, hdc, x, y, 0, 0, CLR_NONE, GetSysColor(COLOR_WINDOW), (dwFlags & DIGREYED) ? ILD_BLEND50 : ILD_TRANSPARENT); 
        
        if (dwFlags & DIPINNED)
        {
            ASSERT(_hicoPinned);    
            DrawIconEx(hdc, x, y, _hicoPinned, 16, 16, 0, NULL, DI_NORMAL);
        }
    }
    return;
}

#define TreeView_GetFont(hwnd)  (HFONT)::SendMessage(hwnd, WM_GETFONT, 0, 0)

void CNscTree::_DrawItem(HTREEITEM hti, TCHAR * psz, HDC hdc
                         , LPRECT prc, DWORD dwFlags, int iLevel, COLORREF clrbk, COLORREF clrtxt)
{
    SIZE        size;
    HIMAGELIST  himl = TreeView_GetImageList(_hwndTree, TVSIL_NORMAL);
    HFONT       hfont = NULL;
    HFONT       hfontOld = NULL;
    int         x, y, dx, dy;
    LOGFONT     lf;
    
    COLORREF clrGreyed = GetSysColor(COLOR_BTNSHADOW);
    if ((dwFlags & DIGREYED) && (clrbk != clrGreyed))
    {
        clrtxt = clrGreyed;
    }

    // For the history and favorites bars, we use the default
    // font (for UI consistency with the folders bar).

    if (_mode != MODE_FAVORITES && _mode != MODE_HISTORY)
        hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);

    if ((dwFlags & DIHOT) && !(dwFlags & DIFOLDER))
    {
        if (!hfont)
            hfont = TreeView_GetFont(_hwndTree);

        // create the underline font
        GetObject(hfont, sizeof(lf), &lf);
        lf.lfUnderline = TRUE;
        hfont = CreateFontIndirect(&lf);
    }
    
    if (hfont)
        hfontOld = (HFONT)SelectObject(hdc, hfont);
    GetTextExtentPoint32(hdc, psz, lstrlen(psz), &size);
    if (himl)
        ImageList_GetIconSize(himl, &dx, &dy);    
    else 
    {
        dx = 0;
        dy = 0;
    }
    x = prc->left + ((dwFlags & DIICON) ? (iLevel * TreeView_GetIndent(_hwndTree) + dx + DXLEFT + MAGICINDENT) : DXLEFT);
    if (_fStartingDrag)
        x -= DXLEFT;
    y = prc->top + (((prc->bottom - prc->top) - size.cy) >> 1);

    UINT eto = ETO_CLIPPED;
    RECT rc;
    rc.left = prc->left + 2;
    rc.top = prc->top;
    rc.bottom = prc->bottom;
    rc.right = prc->right - 2;

    SetBkColor(hdc, clrbk);
    eto |= ETO_OPAQUE;
    ExtTextOut(hdc, 0, 0, eto, &rc, NULL, 0, NULL);

    SetTextColor(hdc, clrtxt);
    rc.left = x;
    rc.top = y;
    rc.bottom = rc.top + size.cy;

    UINT uFormat = DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX;
    if (dwFlags & DIRIGHT)
        uFormat |= DT_RIGHT;
    if (dwFlags & DIRTLREADING)
        uFormat |= DT_RTLREADING;        
    DrawTextWrap(hdc, psz, lstrlen(psz), &rc, uFormat);

    if (dwFlags & DIICON)
        _DrawIcon(hti, hdc, iLevel, prc, dwFlags);
    if (hfontOld)
        SelectObject(hdc, hfontOld);

    if (dwFlags & DIACTIVEBORDER)
    {
        if (dwFlags & DIFIRST)
        {
            rc = *prc;
            rc.left += 2;
            rc.bottom = rc.top + 1;
            rc.right -= 2;
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
        }
        if (dwFlags & DISUBITEM)
        {
            rc = *prc;
            rc.left += 2;
            rc.right = rc.left + 1;
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
            rc.right = prc->right - 2;
            rc.left = rc.right - 1;
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
        }
        if (dwFlags & DILAST)
        {
            rc = *prc;
            rc.left += 2;
            rc.top = rc.bottom - 1;
            rc.right -= 2;
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
        }
    }

#if 0
    //focus is currently shown by drawing the selection with a different color
    // (in default scheme, it's blue when has focus, gray when not)
    if (dwFlags & DIFOCUSRECT)
    {
        rc = *prc;
        InflateRect(&rc, -1, -1);
        DrawFocusRect(hdc, &rc);
    }
#endif

    if (hfont)
        DeleteObject(hfont);
}

//+-------------------------------------------------------------------------
// If going online, ungreys all items that were unavailable.  If going
// offline, refreshes all items to see if they are still available.
//--------------------------------------------------------------------------
void CNscTree::_OnSHNotifyOnlineChange(HTREEITEM htiRoot, BOOL fGoingOnline)
{
    HTREEITEM hItem;

    for (hItem = TreeView_GetChild(_hwndTree, htiRoot); hItem
        ; hItem = TreeView_GetNextSibling(_hwndTree, hItem)) 
    {
        ITEMINFO *pii = _GetTreeItemInfo(hItem);
        if (pii)
        {
            if (fGoingOnline)
            {
                // Going online, if previously greyed then ungrey it
                if (pii->fGreyed)
                {
                    pii->fGreyed = FALSE;
                    _UpdateItemDisplayInfo(hItem);
                }
            }
            else
            {
                // Recheck each item to see if they should be greyed
                if (pii->fFetched && !pii->fDontRefetch)
                {
                    pii->fFetched = FALSE;
                    _UpdateItemDisplayInfo(hItem);
                }
            }
        }
        // Inform children too
        _OnSHNotifyOnlineChange(hItem, fGoingOnline);
    }
}

//+-------------------------------------------------------------------------
// Force items to recheck to see if the should be pinned or greyed
//--------------------------------------------------------------------------
void CNscTree::_OnSHNotifyCacheChange
(
 HTREEITEM htiRoot,      // recurse through all children
 DWORD_PTR dwFlags       // CACHE_NOTIFY_* flags
)
{
    HTREEITEM hItem;

    for (hItem = TreeView_GetChild(_hwndTree, htiRoot); hItem
        ; hItem = TreeView_GetNextSibling(_hwndTree, hItem)) 
    {
        ITEMINFO *pii = _GetTreeItemInfo(hItem);
        if (pii)
        {
            // If we have cached info for this item, refresh it if it's state may have toggled
            if ((pii->fFetched && !pii->fDontRefetch) &&
                ((pii->fGreyed && (dwFlags & CACHE_NOTIFY_ADD_URL)) ||
                
                // We only need to check ungreyed items for changes to the 
                // stickey bit in the cache!
                (!pii->fGreyed &&
                ((dwFlags & (CACHE_NOTIFY_DELETE_URL | CACHE_NOTIFY_DELETE_ALL))) ||
                (!pii->fPinned && (dwFlags & CACHE_NOTIFY_URL_SET_STICKY)) ||
                (pii->fPinned && (dwFlags & CACHE_NOTIFY_URL_UNSET_STICKY))
               )
               ))
            {
                pii->fFetched = FALSE;
                _UpdateItemDisplayInfo(hItem);
            }
        }
        
        // Do it's children too
        _OnSHNotifyCacheChange(hItem, dwFlags);
    }
}

//
// Calls the appropriate routine in shdocvw to favorites import or export on
// the currently selected item
//
HRESULT CNscTree::DoImportOrExport(BOOL fImport)
{
    HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
    LPITEMIDLIST pidl = _GetFullIDList(htiSelected);
    if (pidl)
    {
        //
        // If current selection is not a folder get the parent pidl
        //
        if (!ILIsFileSysFolder(pidl))
            ILRemoveLastID(pidl);
    
        //
        // Create the actual routine in shdocvw to do the import/export work
        //
        IShellUIHelper *pShellUIHelper;
        HRESULT hr = CoCreateInstance(CLSID_ShellUIHelper, NULL, CLSCTX_INPROC_SERVER,  IID_PPV_ARG(IShellUIHelper, &pShellUIHelper));
        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL vbImport = fImport ? VARIANT_TRUE : VARIANT_FALSE;
            WCHAR wszPath[MAX_PATH];

            SHGetPathFromIDListW(pidl, wszPath);
        
            hr = pShellUIHelper->ImportExportFavorites(vbImport, wszPath);
            if (SUCCEEDED(hr) && fImport)
            {
                //
                // Successfully imported favorites so need to update view
                // FEATURE ie5 24973 - flicker alert, should optimize to just redraw selected
                //
                Refresh();
                //TreeView_SelectItem(_hwndTree, htiSelected);
            }
        
            pShellUIHelper->Release();
        }
        ILFree(pidl);
    }
    return S_OK;
}


HRESULT CNscTree::GetSelectedItemName(LPWSTR pszName, DWORD cchName)
{
    HRESULT hr = E_FAIL;
    TCHAR szPath[MAX_PATH];
    TV_ITEM tvi;

    tvi.hItem = TreeView_GetSelection(_hwndTree);
    if (tvi.hItem != NULL)
    {
        tvi.mask = TVIF_HANDLE | TVIF_TEXT;
        tvi.pszText = szPath;
        tvi.cchTextMax = ARRAYSIZE(szPath);
        
        if (TreeView_GetItem(_hwndTree, &tvi))
        {
            SHTCharToUnicode(szPath, pszName, cchName);
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT CNscTree::BindToSelectedItemParent(REFIID riid, void **ppv, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    if (!_fClosing)
    {
        LPCITEMIDLIST pidlItem = _CacheParentShellFolder(TreeView_GetSelection(_hwndTree), NULL);
        if (pidlItem)
        {
            hr = _psfCache->QueryInterface(riid, ppv);
            if (SUCCEEDED(hr) && ppidl)
            {
                *ppidl = ILClone(pidlItem);
                if (*ppidl == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    ((IUnknown *)*ppv)->Release();
                    *ppv = NULL;
                }
            }
        }
    }

    return hr;
}

// takes ownership of pidl
HRESULT CNscTree::RightPaneNavigationStarted(LPITEMIDLIST pidl)
{
    _fExpandNavigateTo = FALSE;
    _fNavigationFinished = FALSE;
    
    Pidl_Set(&_pidlNavigatingTo, pidl);
    return S_OK;
}

// takes ownership of pidl
HRESULT CNscTree::RightPaneNavigationFinished(LPITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    _fNavigationFinished = TRUE;
    if (_fExpandNavigateTo)
    {
        _fExpandNavigateTo = FALSE; // only do this once

        hr = E_OUTOFMEMORY;
        HDPA hdpa = DPA_Create(2);
        if (hdpa)
        {
            IDVGetEnum *pdvge;  // private defview interface
            hr = IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IDVGetEnum, &pdvge));
            if (SUCCEEDED(hr))
            {
                HTREEITEM hti = _FindFromRoot(NULL, pidl);
                // Try to find the tree item using the pidl
                if (hti)
                {
                    IShellFolder* psf;
                    hr = IEBindToObject(pidl, &psf);
                    if (S_OK == hr)
                    {
                        ITEMINFO *pii = _GetTreeItemInfo(hti);
                        DWORD grfFlags;
                        _GetEnumFlags(psf, pidl, &grfFlags, NULL);
                        IEnumIDList *penum;
                        hr = pdvge->CreateEnumIDListFromContents(pidl, grfFlags, &penum);
                        if (S_OK == hr)
                        {
                            ULONG celt;
                            LPITEMIDLIST pidlTemp;
                            while (S_OK == penum->Next(1, &pidlTemp, &celt))
                            {
                                if (!OrderList_Append(hdpa, pidlTemp, -1))
                                {
                                    hr = E_OUTOFMEMORY;
                                    ILFree(pidlTemp);
                                    break;
                                }
                            }
                            penum->Release();
                        }

                        if (hr == S_OK)
                        {
                            ORDERINFO oinfo;
                            oinfo.psf = psf;
                            oinfo.dwSortBy = OI_SORTBYNAME; // merge depends on by name.

                            DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);
                            OrderList_Reorder(hdpa);

                            LPITEMIDLIST pidlExpClone = ILClone(_pidlExpandingTo);  // NULL is OK

                            s_NscEnumCallback(this, pidl, (UINT_PTR)hti, pii->dwSig, hdpa, pidlExpClone, _dwOrderSig, 0, FALSE, FALSE);
                            hdpa = NULL;
                            pidl = NULL;
                        }
                        psf->Release();
                    }
                }
                pdvge->Release();
            }
        }

        if (hr != S_OK)
        {
            if (hdpa)
                OrderList_Destroy(&hdpa, TRUE);        // calls DPA_Destroy(hdpa)

            if (pidl)
            {
                HTREEITEM hti = _FindFromRoot(NULL, pidl);
                if (hti)
                {
                    BOOL fOrdered;
                    hr = _StartBackgroundEnum(hti, pidl, &fOrdered, FALSE);
                }
            }
        }
    }
    ILFree(pidl);
    return hr;
}

HRESULT CNscTree::MoveSelectionTo(void)
{
    return MoveItemsIntoFolder(::GetParent(_hwndParent)) ? S_OK : S_FALSE;
}

BOOL CNscTree::MoveItemsIntoFolder(HWND hwndParent)
{
    BOOL         fSuccess = FALSE;
    BROWSEINFO   browse = {0};
    TCHAR        szDisplayName[MAX_PATH];
    TCHAR        szInstructionString[MAX_PATH];
    LPITEMIDLIST pidlDest = NULL, pidlSelected = NULL;
    HTREEITEM    htiSelected = NULL;
    
    //Initialize the BROWSEINFO struct.
    browse.pidlRoot = ILClone(_pidlRoot);
    if (!browse.pidlRoot)
        return FALSE;
    
    htiSelected = TreeView_GetSelection(_hwndTree);
    pidlSelected = _GetFullIDList(htiSelected);
    if (!pidlSelected)
    {
        ILFree((LPITEMIDLIST)browse.pidlRoot);
        return FALSE;
    }
    
    MLLoadShellLangString(IDS_FAVORITEBROWSE, szInstructionString, ARRAYSIZE(szInstructionString));
    
    browse.pszDisplayName = szDisplayName;
    browse.hwndOwner = hwndParent;
    browse.lpszTitle = szInstructionString;
    browse.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
    browse.lpfn = NULL;
    browse.lParam = 0;
    browse.iImage = 0;
    
    pidlDest = SHBrowseForFolder(&browse);
    if (pidlDest)
    {
        TCHAR szFrom[MAX_PATH+1];  // +1 for double null
        TCHAR szDest[MAX_PATH+1];
        SHGetPathFromIDList(pidlDest, szDest);
        SHGetPathFromIDList(pidlSelected, szFrom);
        
        ASSERT(szDest[0]);  // must be a file system thing...
        ASSERT(szFrom[0]);
        
        szDest[lstrlen(szDest) + 1] = 0;   // double null
        szFrom[lstrlen(szFrom) + 1] = 0;   // double null
        
        
        SHFILEOPSTRUCT  shop = {hwndParent, FO_MOVE, szFrom, szDest, 0, };
        SHFileOperation(&shop);
        
        fSuccess = TRUE;
        
        ILFree(pidlDest);
    }
    ILFree((LPITEMIDLIST)browse.pidlRoot);
    ILFree(pidlSelected);
    
    return fSuccess;
}

// the following guid goo and IsChannelFolder are mostly lifted from cdfview
#define     GUID_STR_LEN            80
const GUID  CLSID_CDFINI = {0xf3aa0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x34}};
// {f3aa0dc0-9cc8-11d0-a599-00c04fd64434}

// REARCHITECT: total hack. looks into the desktop.ini for this guy
//
// pwzChannelURL is assumed to be INTERNET_MAX_URL_LENGTH
BOOL IsChannelFolder(LPCWSTR pwzPath, LPWSTR pwzChannelURL)
{
    ASSERT(pwzPath);
    
    BOOL fRet = FALSE;
    
    WCHAR wzFolderGUID[GUID_STR_LEN];
    WCHAR wzIniFile[MAX_PATH];
    
    if (!PathCombineW(wzIniFile, pwzPath, L"desktop.ini"))
        return FALSE;
    
    if (GetPrivateProfileString(L".ShellClassInfo", L"CLSID", L"", wzFolderGUID, ARRAYSIZE(wzFolderGUID), wzIniFile))
    {
        WCHAR wzChannelGUID[GUID_STR_LEN];
        
        //it's only a channel if it's got the right guid and an url
        if (SHStringFromGUID(CLSID_CDFINI, wzChannelGUID, ARRAYSIZE(wzChannelGUID)))
        {
            fRet = (StrCmpN(wzFolderGUID, wzChannelGUID, ARRAYSIZE(wzChannelGUID)) == 0);
            if (fRet && pwzChannelURL)
            {
                fRet = (SHGetIniStringW(L"Channel", L"CDFURL", pwzChannelURL, INTERNET_MAX_URL_LENGTH, wzIniFile) != 0);
            }
        }
    }
    
    return fRet;
}

BOOL CNscTree::_IsChannelFolder(HTREEITEM hti)
{
    BOOL fRet = FALSE;

    LPITEMIDLIST pidl = _GetFullIDList(hti);
    if (pidl)
    {
        WCHAR szPath[MAX_PATH];
        if (SUCCEEDED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
        {
            fRet = IsChannelFolder(szPath, NULL);
        }

        ILFree(pidl);
    }

    return fRet;
}


HRESULT CNscTree::CreateSubscriptionForSelection(/*[out, retval]*/ VARIANT_BOOL *pBool)
{
    HRESULT hr = DoSubscriptionForSelection(TRUE);
    
    if (pBool)
        *pBool = (SUCCEEDED(hr) ? TRUE : FALSE);

    return FIX_SCRIPTING_ERRORS(hr);
}


HRESULT CNscTree::DeleteSubscriptionForSelection(/*[out, retval]*/ VARIANT_BOOL *pBool)
{
    HRESULT hr = DoSubscriptionForSelection(FALSE);
    
    if (pBool)
        *pBool = (SUCCEEDED(hr) ? TRUE : FALSE);

    return FIX_SCRIPTING_ERRORS(hr);
}


//
// 1. get the selected item
// 2. get it's name
// 3. get it's url
// 4. create a Subscription manager and do the right thing for channels
// 5. return Subscription manager's result
HRESULT CNscTree::DoSubscriptionForSelection(BOOL fCreate)
{
#ifndef DISABLE_SUBSCRIPTIONS

    HRESULT hr = E_FAIL;
    WCHAR wzUrl[MAX_URL_STRING];
    WCHAR wzName[MAX_PATH];
    HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
    if (htiSelected == NULL)
        return E_FAIL;
    
    TV_ITEM tvi;
    
    tvi.mask = TVIF_HANDLE | TVIF_TEXT;
    tvi.hItem = htiSelected;
    tvi.pszText = wzName;
    tvi.cchTextMax = ARRAYSIZE(wzName);
    
    TreeView_GetItem(_hwndTree, &tvi);
    
    WCHAR wzPath[MAX_PATH];
    
    LPITEMIDLIST pidlItem = _CacheParentShellFolder(htiSelected, NULL);
    if (pidlItem)
    {
        GetPathForItem(_psfCache, pidlItem, wzPath, NULL);
        hr = GetNavTargetName(_psfCache, pidlItem, wzUrl, ARRAYSIZE(wzUrl));
    }
    
    if (FAILED(hr))     //if we couldn't get an url, not much to do
        return hr;
    
    ISubscriptionMgr *psm;
    
    hr = JITCoCreateInstance(CLSID_SubscriptionMgr, NULL,
        CLSCTX_INPROC_SERVER, IID_PPV_ARG(ISubscriptionMgr, &psm),
        _hwndTree, FIEF_FLAG_FORCE_JITUI);
    if (SUCCEEDED(hr))
    {
        HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
        //IsChannelFolder will fixup wzUrl if it's a channel
        BOOL fChannel = IsChannelFolder(wzPath, wzUrl);
        
        if (fCreate)
        {
            SUBSCRIPTIONINFO si = { sizeof(SUBSCRIPTIONINFO) };
            TASK_TRIGGER tt;
            BOOL bIsSoftware = FALSE;
            
            if (fChannel)
            {
                IChannelMgrPriv *pChannelMgrPriv;
                
                hr = JITCoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, 
                    IID_PPV_ARG(IChannelMgrPriv, &pChannelMgrPriv),
                    _hwndTree, FIEF_FLAG_PEEK);

                if (SUCCEEDED(hr))
                {
                    WCHAR wszTitle[MAX_PATH];
                    
                    si.fUpdateFlags |= SUBSINFO_SCHEDULE;
                    si.schedule     = SUBSSCHED_AUTO;
                    si.pTrigger     = (void *)&tt;
                    
                    hr = pChannelMgrPriv->DownloadMinCDF(_hwndTree, wzUrl, 
                        wszTitle, ARRAYSIZE(wszTitle), 
                        &si, &bIsSoftware);
                    pChannelMgrPriv->Release();
                }
            }

            if (SUCCEEDED(hr))
            {
                DWORD dwFlags = CREATESUBS_NOUI | CREATESUBS_FROMFAVORITES | 
                    ((!bIsSoftware) ? 0 : CREATESUBS_SOFTWAREUPDATE);
                
                hr = psm->CreateSubscription(_hwndTree, wzUrl, wzName, dwFlags, 
                    (fChannel ? SUBSTYPE_CHANNEL : SUBSTYPE_URL), 
                    &si);
            }
        }
        else
        {
            hr = psm->DeleteSubscription(wzUrl, NULL);
        }
        
        BOOL bSubscribed;
        
        //  This is in case subscribing or unsubscribing return a failed result even
        //  though the action succeeded from our standpoint (ie. item was subscribed
        //  successfully but creating a schedule failed or the item was unsubscribed 
        //  successfully but we couldn't abort a running download in syncmgr).
        
        psm->IsSubscribed(wzUrl, &bSubscribed);
        
        hr = ((fCreate && bSubscribed) || (!fCreate && !bSubscribed)) ? S_OK : E_FAIL;
        
        psm->Release();
        
        SetCursor(hCursorOld);
    }
    
    return hr;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return E_FAIL;

#endif /* !DISABLE_SUBSCRIPTIONS */

}


// Causes NSC to re-root on a different pidl --
HRESULT CNscTree::_ChangePidlRoot(LPCITEMIDLIST pidl)
{
    _fClosing = TRUE;
    ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);
    _bSynchId++;
    if (_bSynchId >= 16)
        _bSynchId = 0;
    TreeView_DeleteAllItemsQuickly(_hwndTree);
    _htiActiveBorder = NULL;
    _fClosing = FALSE;
    if (_psfCache)
        _ReleaseCachedShellFolder();

    // We do this even for (NULL == pidl) because (CSIDL_DESKTOP == NULL)
    if ((LPCITEMIDLIST)INVALID_HANDLE_VALUE != pidl)
    {
        _UnSubClass();
        _SetRoot(pidl, 3/*random*/, NULL, NSSR_CREATEPIDL);
        _SubClass(pidl);
    }
    ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);

    return S_OK;
}

BOOL CNscTree::_IsMarked(HTREEITEM hti)
{
    if ((hti == NULL) || (hti == TVI_ROOT))
        return FALSE;
        
    TVITEM tvi;
    tvi.mask = TVIF_HANDLE | TVIF_STATE;
    tvi.stateMask = TVIS_STATEIMAGEMASK;
    tvi.state = 0;
    tvi.hItem = hti;
    TreeView_GetItem(_hwndTree, &tvi);

    return BOOLIFY(tvi.state & NSC_TVIS_MARKED);
}

void CNscTree::_MarkChildren(HTREEITEM htiParent, BOOL fOn)
{
    TVITEM tvi;
    tvi.mask = TVIF_HANDLE | TVIF_STATE;
    tvi.stateMask = TVIS_STATEIMAGEMASK;
    tvi.state = (fOn ? NSC_TVIS_MARKED : 0);
    tvi.hItem = htiParent;
    TreeView_SetItem(_hwndTree, &tvi);

    for (HTREEITEM htiTemp = TreeView_GetChild(_hwndTree, htiParent); htiTemp; htiTemp = TreeView_GetNextSibling(_hwndTree, htiTemp)) 
    {
        tvi.hItem = htiTemp;
        TreeView_SetItem(_hwndTree, &tvi);
    
        _MarkChildren(htiTemp, fOn);
    }
}

//Updates the tree and internal state for the active border (the 1 pixel line)
// htiSelected is the item that was just clicked on/selected
void CNscTree::_UpdateActiveBorder(HTREEITEM htiSelected)
{
    HTREEITEM htiNewBorder;
    if (MODE_NORMAL == _mode)
        return;

    //if an item is a folder, then it should have the border
    if (htiSelected != TVI_ROOT)
    {
        if (TreeView_GetChild(_hwndTree, htiSelected))
            htiNewBorder = htiSelected;
        else
            htiNewBorder = TreeView_GetParent(_hwndTree, htiSelected);
    }
    else
        htiNewBorder = NULL;
        
    //clear the old state
    // in multiselect mode we don't unselect the previously selected folder
    if ((!(_dwFlags & NSS_MULTISELECT)) && (_htiActiveBorder != TVI_ROOT) && (_htiActiveBorder != NULL) 
    && (htiNewBorder != _htiActiveBorder))
        _MarkChildren(_htiActiveBorder, FALSE);
   
    //set the new state
    BOOL bMark = TRUE;
    if (_dwFlags & NSS_MULTISELECT)
    {
        bMark = TreeView_GetItemState(_hwndTree, htiNewBorder, NSC_TVIS_MARKED) & NSC_TVIS_MARKED;
    }
    
    if (bMark && (htiNewBorder != TVI_ROOT) && (htiNewBorder != NULL))
        _MarkChildren(htiNewBorder, TRUE);

    //treeview knows to invalidate itself

    _htiActiveBorder = htiNewBorder;
}

void CNscTree::_UpdateItemDisplayInfo(HTREEITEM hti)
{
    if (_GetTreeItemInfo(hti) && _pTaskScheduler)
    {
        LPITEMIDLIST pidl = _GetFullIDList(hti);
        if (pidl)
        {
            LPITEMIDLIST pidl2 = _mode == MODE_NORMAL ? ILClone(pidl) : NULL;
            
            AddNscIconTask(_pTaskScheduler, pidl, s_NscIconCallback, this, (UINT_PTR) hti, (UINT)_bSynchId);
            if (pidl2)
            {
                AddNscOverlayTask(_pTaskScheduler, pidl2, &s_NscOverlayCallback, this, (UINT_PTR)hti, (UINT)_bSynchId);
            }
        }
    }
    //pidls get freed by CNscIconTask
}

void CNscTree::s_NscOverlayCallback(CNscTree *pns, UINT_PTR uId, int iOverlayIndex, UINT uMagic)
{
    ASSERT(pns);
    ASSERT(uId);

    //this function gets called on a background thread, so use PostMessage to do treeview ops
    //on the main thread only.

    //assert that wacky packing is going to work
    ASSERT(((iOverlayIndex & 0x0fffffff) == iOverlayIndex) && (uMagic < 16));

    LPARAM lParam = (uMagic << 28) + iOverlayIndex;

    if (uMagic == pns->_bSynchId && ::IsWindow(pns->_hwndTree))
        ::PostMessage(pns->_hwndTree, WM_NSCUPDATEICONOVERLAY, (WPARAM)uId, lParam);
}

void CNscTree::s_NscIconCallback(CNscTree *pns, UINT_PTR uId, int iIcon, int iIconOpen, DWORD dwFlags, UINT uMagic)
{
    ASSERT(pns);
    ASSERT(uId);

    //this function gets called on a background thread, so use PostMessage to do treeview ops
    //on the main thread only.

    //assert that wacky packing is going to work
    ASSERT((iIcon < 4096) && (iIconOpen < 4096) && (dwFlags < 16) && (uMagic < 16));

    LPARAM lParam = (uMagic << 28) + (dwFlags << 24) + (iIconOpen << 12) + iIcon;

    if (uMagic == pns->_bSynchId && ::IsWindow(pns->_hwndTree))
        ::PostMessage(pns->_hwndTree, WM_NSCUPDATEICONINFO, (WPARAM)uId, lParam);
}

LRESULT CNscTree::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);

    switch(idCmd)
    {
    case FCIDM_MOVE:
        InvokeContextMenuCommand(L"cut");
        break;

    case FCIDM_COPY:
        InvokeContextMenuCommand(L"copy");
        break;

    case FCIDM_PASTE:
        InvokeContextMenuCommand(L"paste");
        break;

    case FCIDM_LINK:
        InvokeContextMenuCommand(L"link");
        break;

    case FCIDM_DELETE:
        InvokeContextMenuCommand(L"delete");
        if (_hwndTree) 
        {
            SHChangeNotifyHandleEvents();
        }
        break;

    case FCIDM_PROPERTIES:
        InvokeContextMenuCommand(L"properties");
        break;

    case FCIDM_RENAME:
        {
            // HACKHACK (lamadio): This is to hack around tree view renaming on click and hover
            _fOkToRename = TRUE;
            HTREEITEM hti = TreeView_GetSelection(_hwndTree);
            if (hti)
                TreeView_EditLabel(_hwndTree, hti);
            _fOkToRename = FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void CNscTree::_TreeSetItemState(HTREEITEM hti, UINT stateMask, UINT state)
{
    if (hti) 
    {
        TV_ITEM tvi;
        tvi.mask = TVIF_STATE;
        tvi.stateMask = stateMask;
        tvi.hItem = hti;
        tvi.state = state;
        TreeView_SetItem(_hwndTree, &tvi);
    }

}

void CNscTree::_TreeNukeCutState()
{
    _TreeSetItemState(_htiCut, TVIS_CUT, 0);
    _htiCut = NULL;

    ::ChangeClipboardChain(_hwndTree, _hwndNextViewer);
    _hwndNextViewer = NULL;
}

    // *** IFolderFilterSite methods ***
HRESULT CNscTree::SetFilter(IUnknown* punk)
{
    HRESULT hr = S_OK;
    ATOMICRELEASE(_pFilter);

    if (punk)
        hr = punk->QueryInterface(IID_PPV_ARG(IFolderFilter, &_pFilter));

    return hr;
}

int DPADeletePidlsCB(void *pItem, void *pData)
{
    if (pItem)
        ILFree((LPITEMIDLIST)pItem);
    return TRUE;
}

int DPADeleteItemCB(void *pItem, void *pData)
{
    if (pItem)
    {
        LocalFree(pItem);
        pItem = NULL;
    }

    return TRUE;
}

HRESULT CNscTree::get_SubscriptionsEnabled(VARIANT_BOOL * pVal)
{
    *pVal = BOOLIFY(!SHRestricted2(REST_NoAddingSubscriptions, NULL, 0));
    return S_OK;
}

HRESULT CNscTree::Synchronize()
{
    return S_OK;
}

HRESULT CNscTree::NewFolder()
{
    //we should do this activates stuff only in control mode
    //hack to get control to be activated fully
    m_bUIActive = FALSE;
    InPlaceActivate(OLEIVERB_UIACTIVATE);

    return CreateNewFolder(TreeView_GetSelection(_hwndTree));
}

HRESULT CNscTree::InvokeContextMenuCommand(BSTR strCommand)
{
    ASSERT(strCommand);

    if (strCommand)
    {
        //again activate only if in control mode
        //only if renaming, activate control
        if (StrStr(strCommand, L"rename") != NULL)
        {
            //hack to get control to be activated fully
            m_bUIActive = FALSE;
            InPlaceActivate(OLEIVERB_UIACTIVATE);
        }

        return _InvokeContextMenuCommand(strCommand);
    }

    return S_OK;
}

HRESULT CNscTree::get_EnumOptions(LONG *pVal)
{
    *pVal = _grfFlags;
    return S_OK;
}

HRESULT CNscTree::put_EnumOptions(LONG lVal)
{
    _grfFlags = lVal;
    return S_OK;
}

HRESULT CreateFolderItem(LPCITEMIDLIST pidl, IDispatch **ppItem)
{
    *ppItem = NULL;

    IPersistFolder *ppf;
    HRESULT hr = CoCreateInstance(CLSID_FolderItem, NULL, CLSCTX_INPROC_SERVER, 
        IID_PPV_ARG(IPersistFolder, &ppf));
    if (SUCCEEDED(hr))
    {
        if (S_OK == ppf->Initialize(pidl))
        {
            hr = ppf->QueryInterface(IID_PPV_ARG(IDispatch, ppItem));
        }
        else
            hr = E_FAIL;
        ppf->Release();
    }
    return hr;
}

HRESULT CNscTree::get_SelectedItem(IDispatch **ppItem)
{
    *ppItem = NULL;

    LPITEMIDLIST pidl;
    if (SUCCEEDED(GetSelectedItem(&pidl, 0)) && pidl)
    {
        CreateFolderItem(pidl, ppItem);
        ILFree(pidl);
    }
    return *ppItem ? S_OK : S_FALSE;
}

HRESULT CNscTree::put_SelectedItem(IDispatch *pItem)
{
    return S_FALSE;
}

HRESULT CNscTree::get_Root(VARIANT *pvar)
{
    pvar->vt = VT_EMPTY;
    return S_OK;
}

HRESULT CNscTree::put_Root(VARIANT var)
{
    if (_csidl != -1)
    {
        SetNscMode(MODE_CONTROL);
        _csidl = -1;    // unknown
    }

    return _PutRootVariant(&var);
}

HRESULT CNscTree::_PutRootVariant(VARIANT *pvar)
{
    BOOL bReady = _pidlRoot != NULL;
    LPITEMIDLIST pidl = VariantToIDList(pvar);
    if (_hdpaViews)
    {
        DPA_DestroyCallback(_hdpaViews, DPADeletePidlsCB, NULL);
        _hdpaViews = NULL;
    }
    
    HRESULT hr = S_OK;
    if (bReady)
        hr = _ChangePidlRoot(pidl);

    ILFree(pidl);

    return S_OK;
}

HRESULT CNscTree::SetRoot(BSTR bstrFullPath)
{
    // SetRoot is from IShellFavoritesNamespace so turn on Favorites mode
    _csidl = CSIDL_FAVORITES;
    SetNscMode(MODE_FAVORITES | MODE_CONTROL);

    CComVariant varPath(bstrFullPath);

    return FIX_SCRIPTING_ERRORS(_PutRootVariant(&varPath));
}


HRESULT CNscTree::put_Mode(UINT uMode)
{
    SetNscMode(uMode);
    _csidl = -1;
    return S_OK;
}

HRESULT CNscTree::put_Flags(DWORD dwFlags)
{
    _dwFlags = dwFlags;
    return S_OK;
}

HRESULT CNscTree::get_Columns(BSTR *pbstrColumns)
{
    *pbstrColumns = SysAllocString(TEXT(""));
    return *pbstrColumns? S_OK: E_FAIL;
}

typedef struct
{
    TCHAR szName[20];
    const SHCOLUMNID *pscid;
} COLUMNS;

static COLUMNS s_Columns[] = 
{ 
    {TEXT("name"), &SCID_NAME},
    {TEXT("attribs"), &SCID_ATTRIBUTES},
    {TEXT("size"), &SCID_SIZE},
    {TEXT("type"), &SCID_TYPE},
    {TEXT("create"), &SCID_CREATETIME},
};

int _SCIDsFromNames(LPTSTR pszNames, int nSize, const SHCOLUMNID *apscid[])
{
    int cItems = 0;

    if (!pszNames || !apscid || !nSize)
        return -1;
        
    do
    {
        BOOL bInsert = FALSE;
        LPTSTR pszTemp = StrChr(pszNames, TEXT(';'));

        if (pszTemp)
        {
            *pszTemp = 0;
            pszTemp++;
        }
        
        for (int i = 0; i < ARRAYSIZE(s_Columns); i++)
        {
            if (StrCmpI(pszNames, s_Columns[i].szName) == 0)
            {
                bInsert = TRUE;
#ifdef NO_DUPLICATES
                for (int j = 0; j < cItems; j++)
                {
                    if (IsEqualSCID(*(s_Columns[i].pscid), *apscid[j]))
                    {
                        bInsert = FALSE;
                        break;
                    }
                }
#endif
                break;
            }
        }
        if (bInsert)
        {
            apscid[cItems++] = s_Columns[i].pscid;
            if (cItems >= nSize)
                break;
        }
        pszNames = pszTemp;
    }
    while(pszNames);

    return cItems;
}

HRESULT CNscTree::put_Columns(BSTR bstrColumns)
{
    HRESULT hr = E_FAIL;

    if (_dwFlags & NSS_HEADER)
    {
        if (!_hdpaColumns)
        {
            _hdpaColumns = DPA_Create(3);
            hr = E_OUTOFMEMORY;
        }
        else
        {
            DPA_EnumCallback(_hdpaColumns, DPADeleteItemCB, NULL);
            DPA_DeleteAllPtrs(_hdpaColumns);
        }

        if (_hdpaColumns)
        {
            const SHCOLUMNID *apscid[5];
            int cItems = _SCIDsFromNames(bstrColumns, ARRAYSIZE(apscid), apscid);
            
            hr = S_OK;
            
            for (int i = 0; i < cItems; i++)
            {
                HEADERINFO *phinfo = (HEADERINFO *)LocalAlloc(LPTR, sizeof(HEADERINFO));
                if (phinfo)
                {
                    phinfo->pscid = apscid[i];
                    phinfo->iFldrCol = -1;
                    if (DPA_AppendPtr(_hdpaColumns, (void *)phinfo) == -1)
                    {
                        hr = E_FAIL;
                        LocalFree(phinfo);
                        phinfo = NULL;
                        break;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            if (DPA_GetPtrCount(_hdpaColumns) > 0)
                _CreateHeader();
        }
    }
    return hr;
}

HRESULT CNscTree::get_CountViewTypes(int *piTypes)
{
    *piTypes = 0;
    
    if (_pidlRoot && !_hdpaViews)
    {
        IShellFolder *psf;

        if (SUCCEEDED(IEBindToObject(_pidlRoot, &psf))) //do we have this cached?
        {
            IShellFolderViewType *psfvt;
            
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolderViewType, &psfvt))))
            {
                IEnumIDList *penum;

                if (SUCCEEDED(psfvt->EnumViews(0, &penum)))
                {
                    LPITEMIDLIST pidl;
                    ULONG cFetched;

                    _hdpaViews = DPA_Create(4);
                    if (_hdpaViews)
                    {
                        while (penum->Next(1, &pidl, &cFetched) == S_OK && cFetched == 1)
                        {
                            if (DPA_AppendPtr(_hdpaViews, pidl) == -1)
                            {
                                ILFree(pidl);
                                break;
                            }
                        }
                    }
                    penum->Release();
                }
                psfvt->Release();
            }
            psf->Release();
        }
    }

    if (_hdpaViews)
        *piTypes = DPA_GetPtrCount(_hdpaViews);
        
    return S_OK;
}

HRESULT CNscTree::SetViewType(int iType)
{
    HRESULT hr = S_FALSE;
    
    if (_hdpaViews && iType < DPA_GetPtrCount(_hdpaViews))  // allow negative types to reset to _pidlRoot
    {        
        LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_GetPtr(_hdpaViews, iType);
        LPITEMIDLIST pidlType;

        if (pidl)
            pidlType = ILCombine(_pidlRoot, pidl);
        else
            pidlType = _pidlRoot;

        if (pidlType)
        {
            hr = _ChangePidlRoot(pidlType);
            if (pidlType != _pidlRoot)
                ILFree(pidlType);
        }
    }
    return hr;
}

HRESULT CreateFolderItemsFDF(LPCITEMIDLIST pidl, IDispatch **ppItems)
{
    *ppItems = NULL;

    IPersistFolder *ppf;
    HRESULT hr = CoCreateInstance(CLSID_FolderItemsFDF, NULL, CLSCTX_INPROC_SERVER, 
        IID_PPV_ARG(IPersistFolder, &ppf));
    if (SUCCEEDED(hr))
    {
        if (S_OK == ppf->Initialize(pidl))
        {
            hr = ppf->QueryInterface(IID_PPV_ARG(IDispatch, ppItems));
        }
        else
            hr = E_FAIL;
        ppf->Release();
    }
    return hr;
}

void CNscTree::_InsertMarkedChildren(HTREEITEM htiParent, LPCITEMIDLIST pidlParent, IInsertItem *pii)
{
    TV_ITEM tvi;
    
    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
    for (HTREEITEM htiTemp = TreeView_GetChild(_hwndTree, htiParent); htiTemp; htiTemp = TreeView_GetNextSibling(_hwndTree, htiTemp)) 
    {
        BOOL bMarked = TreeView_GetItemState(_hwndTree, htiTemp, NSC_TVIS_MARKED) & NSC_TVIS_MARKED;

        tvi.hItem = htiTemp;
        if (TreeView_GetItem(_hwndTree, &tvi))
        {
            if (tvi.lParam)
            {
                PORDERITEM poi = ((ITEMINFO *)tvi.lParam)->poi;

                if (poi)
                {
                    LPITEMIDLIST pidl = ILCombine(pidlParent, poi->pidl);

                    if (pidl)
                    {
                        if (bMarked)
                        {
                            pii->InsertItem(pidl);
                        }
                        _InsertMarkedChildren(htiTemp, pidl, pii);
                        ILFree(pidl);
                    }
                }
            }
        }
    }
}

HRESULT CNscTree::SelectedItems(IDispatch **ppItems)
{
    HRESULT hr = CreateFolderItemsFDF(_pidlRoot, ppItems);
    // poke all marked items in ppitems)
    if (SUCCEEDED(hr) && _hwndTree)
    {
        IInsertItem *pii;

        hr = (*ppItems)->QueryInterface(IID_PPV_ARG(IInsertItem, &pii));
        if (SUCCEEDED(hr))
        {
            if (!(_mode & MODE_NORMAL) && (_dwFlags & NSS_MULTISELECT))
            {
                _InsertMarkedChildren(TVI_ROOT, NULL, pii);
            }
            else
            {
                LPITEMIDLIST pidl;
                if (SUCCEEDED(GetSelectedItem(&pidl, 0)) && pidl)
                {
                    hr = pii->InsertItem(pidl);
                    ILFree(pidl);
                }
            }
            pii->Release();

        }
    }

    return hr;
}

HRESULT CNscTree::Expand(VARIANT var, int iDepth)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;

    if (var.vt == VT_EMPTY)
        pidl = ILClone(_pidlRoot);
    else
        pidl = VariantToIDList(&var);

    if (pidl)
    {
        hr = _Expand(pidl, iDepth);
        if (FAILED(hr))
            hr = S_FALSE;
        ILFree(pidl);
    }

    return hr;
}

/*
HRESULT CNscTree::get_ReadyState(READYSTATE *plReady)
{
    *plReady = _lReadyState;
    return S_OK;
}

void CNscTree::_ReadyStateChange(READYSTATE lReady)
{
    if (_lReadyState < lReady)
    {
        _lReadyState = lReady;
        //post beta 1 item (need trident v3)
        //IUnknown_CPContainerOnChanged(SAFECAST(this, IShellNameSpace *), DISPID_READYSTATE);
    }
}
*/

HRESULT CNscTree::UnselectAll()
{
    if (_dwFlags & NSS_MULTISELECT)
        _MarkChildren(TVI_ROOT, FALSE);
        
    return S_OK;
}

LRESULT CNscTree::OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // when in label edit mode, don't try to activate the control or you'll get out of label editing,
    // even when you click on the label edit control
    if (!InLabelEdit())
        InPlaceActivate(OLEIVERB_UIACTIVATE);
    return S_OK;
}

LRESULT CNscTree::OnGetIShellBrowser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    LRESULT lResult = NULL; // This will be the IShellBrowser *.
    IShellBrowser * psb;
    if (SUCCEEDED(_InternalQueryInterface(IID_PPV_ARG(IShellBrowser, &psb))))
    {
        lResult = (LRESULT) psb;
        psb->Release();
    }
    
    bHandled = TRUE;
    return lResult;
}

LRESULT CNscTree::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    if (!m_bUIActive)
        CComControlBase::InPlaceActivate(OLEIVERB_UIACTIVATE);

    if ((HWND)wParam != _hwndTree)
        ::SendMessage(_hwndTree, uMsg, wParam, lParam);
    bHandled = TRUE;
    return 0;
}

LRESULT CNscTree::OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    bHandled = TRUE;

    return S_OK;
}

LRESULT CNscTree::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPNMHDR pnm = (LPNMHDR)lParam;
    if (pnm)
    {
        switch (pnm->code)
        {
        case TVN_SELCHANGEDA:
        case TVN_SELCHANGED:
            {
                if (CSIDL_FAVORITES == _csidl)
                {
                    IShellFolder *psf = NULL;
                    LPITEMIDLIST pidl = NULL;
                    UINT cItems, cVisits;
                    WCHAR szTitle[MAX_PATH], szUrl[INTERNET_MAX_URL_LENGTH], szLastVisited[MAX_PATH];
                    BOOL fAvailableOffline;

                    szTitle[0] = szUrl[0] = szLastVisited[0] = 0;

                    HRESULT hr = BindToSelectedItemParent(IID_PPV_ARG(IShellFolder, &psf), &pidl);
                    if (SUCCEEDED(hr) && (SUCCEEDED(GetSelectedItemName(szTitle, ARRAYSIZE(szTitle)))))
                    {
                        GetEventInfo(psf, pidl, &cItems, szUrl, ARRAYSIZE(szUrl), &cVisits, szLastVisited, &fAvailableOffline);

                        CComBSTR strName(szTitle);
                        CComBSTR strUrl(szUrl);
                        CComBSTR strDate(szLastVisited);
                
                        _FireFavoritesSelectionChange(cItems, 0, strName, strUrl, cVisits, strDate, fAvailableOffline);
                    }
                    else
                        _FireFavoritesSelectionChange(0, 0, NULL, NULL, 0, NULL, FALSE);

                    ILFree(pidl);
                    ATOMICRELEASE(psf);
                }
                IUnknown_CPContainerInvokeParam(SAFECAST(this, IShellNameSpace *), 
                    DIID_DShellNameSpaceEvents, DISPID_SELECTIONCHANGE, NULL, 0);
            }
            break;

        case NM_DBLCLK:
            IUnknown_CPContainerInvokeParam(SAFECAST(this, IShellNameSpace *), 
                DIID_DShellNameSpaceEvents, DISPID_DOUBLECLICK, NULL, 0);
            break;

        default:
            break;
        }
    }

    LRESULT lResult;
    HRESULT hr = OnWinEvent(_hwndTree, uMsg, wParam, lParam, &lResult);
    
    bHandled = (lResult ? TRUE : FALSE);
    return SUCCEEDED(hr) ? lResult : hr;
}

void CNscTree::_InitHeaderInfo()
{
    if (!_pidlRoot || !_hdpaColumns || DPA_GetPtrCount(_hdpaColumns) == 0)
        return;

    IShellFolder *psf;
    
    if (SUCCEEDED(IEBindToObject(_pidlRoot, &psf)))
    {
        IShellFolder2 *psf2;

        if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
        {
            int i;
            SHCOLUMNID scid;
            
            for (i=0; SUCCEEDED(psf2->MapColumnToSCID(i, &scid)); i++)
            {
                BOOL bFound = FALSE;
                HEADERINFO *phinfo;

                for (int iCol=0; iCol < DPA_GetPtrCount(_hdpaColumns); iCol++)
                {
                    phinfo = (HEADERINFO *)DPA_GetPtr(_hdpaColumns, iCol);

                    if (phinfo && phinfo->iFldrCol == -1 && IsEqualSCID(*(phinfo->pscid), scid))
                    {
                        bFound = TRUE;
                        break;
                    }
                }

                if (bFound)
                {
                    DETAILSINFO di;

                    di.fmt  = LVCFMT_LEFT;
                    di.cxChar = 20;
                    di.str.uType = (UINT)-1;
                    //di.pidl = NULL;

                    if (SUCCEEDED(psf2->GetDetailsOf(NULL, i, (SHELLDETAILS *)&di.fmt)))
                    {
                        phinfo->fmt = di.fmt;
                        phinfo->iFldrCol = i;
                        phinfo->cxChar = di.cxChar;
                        StrRetToBuf(&di.str, NULL, phinfo->szName, ARRAYSIZE(phinfo->szName));
                    }
                }
            }

            for (i=DPA_GetPtrCount(_hdpaColumns)-1; i >= 0; i--)
            {
                HEADERINFO *phinfo = (HEADERINFO *)DPA_GetPtr(_hdpaColumns, i);

                if (!phinfo || phinfo->iFldrCol == -1)
                {
                    if (phinfo)
                    {
                        LocalFree(phinfo);
                        phinfo = NULL;
                    }

                    DPA_DeletePtr(_hdpaColumns, i);
                }
            }
            psf2->Release();
        }
        psf->Release();
    }
}

HWND CNscTree::Create(HWND hWndParent, RECT& rcPos, LPCTSTR pszWindowName, DWORD dwStyle, DWORD dwExStyle, UINT nID)
{
    CWindowImpl<CNscTree>::Create(hWndParent, rcPos, pszWindowName, dwStyle, dwExStyle, nID);

    LPITEMIDLIST pidl = _pidlRoot, pidlToFree = NULL;

    ASSERT(m_spClientSite);

    SetSite(m_spClientSite); // hook up the site chain

    _dwTVFlags |= TVS_TRACKSELECT | TVS_INFOTIP | TVS_FULLROWSELECT;
    if (!(_mode & MODE_CUSTOM))
    {
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        BOOL  fDefault = TRUE;

        SHRegGetUSValue(L"Software\\Microsoft\\Internet Explorer\\Main",
                        L"NscSingleExpand", NULL, (LPBYTE)&dwValue, &dwSize, FALSE,
                        (void *) &fDefault, sizeof(fDefault));

        if (dwValue)
            _dwTVFlags |= TVS_SINGLEEXPAND;
    }

    _hwndTree = NULL;
    CreateTree(m_hWnd, _dwTVFlags, &_hwndTree);

    if (NULL == pidl)
    {
        SHGetSpecialFolderLocation(NULL, _csidl, &pidl);
        pidlToFree = pidl;
    }

    if (pidl)
    {
        if (_dwFlags & NSS_HEADER)
        {
            if (!_hdpaColumns || DPA_GetPtrCount(_hdpaColumns) == 0)
            {
                _dwFlags &= ~NSS_HEADER;
            }
            else
            {
                _InitHeaderInfo();
            }
        }
        Initialize(pidl, _grfFlags, _dwFlags);
        ShowWindow(TRUE);
        IUnknown_CPContainerInvokeParam(SAFECAST(this, IShellNameSpace *), DIID_DShellNameSpaceEvents, DISPID_INITIALIZED, NULL, 0);
        ILFree(pidlToFree);
    }
    
    return m_hWnd;
}

HRESULT CNscTree::InPlaceActivate(LONG iVerb, const RECT* prcPosRect /*= NULL*/)
{
    HRESULT hr = CComControl<CNscTree>::InPlaceActivate(iVerb, prcPosRect);
    if (::GetFocus() != _hwndTree)
        ::SetFocus(_hwndTree);
    return hr;
}


STDMETHODIMP CNscTree::GetWindow(HWND* phwnd)
{
    return IOleInPlaceActiveObjectImpl<CNscTree>::GetWindow(phwnd);
}

STDMETHODIMP CNscTree::TranslateAccelerator(MSG *pMsg)
{
    // label editing edit control is taking the keystrokes, TAing them will just duplicate them
    if (InLabelEdit())
        return S_FALSE;

    // hack so that the escape can get out to the document, because TA won't do it
    // WM_KEYDOWN is because some keyup's come through that need to not close the dialog
    if ((pMsg->wParam == VK_ESCAPE) && (pMsg->message == WM_KEYDOWN))
    {
        _FireFavoritesSelectionChange(-1, 0, NULL, NULL, 0, NULL, FALSE);
        return S_FALSE;
    }
    
    //except for tabs and sys keys, let nsctree take all the keystrokes
    if ((pMsg->wParam != VK_TAB) && (pMsg->message != WM_SYSCHAR) && (pMsg->message != WM_SYSKEYDOWN) && (pMsg->message != WM_SYSKEYUP))
    {
        // TreeView will return TRUE if it processes the key, so we return S_OK to indicate
        // the keystroke was used and prevent further processing 
        return ::SendMessage(pMsg->hwnd, TVM_TRANSLATEACCELERATOR, 0, (LPARAM)pMsg) ? S_OK : S_FALSE;
    } 
    else
    {
        CComQIPtr<IOleControlSite, &IID_IOleControlSite>spCtrlSite(m_spClientSite);
        if (spCtrlSite)
            return spCtrlSite->TranslateAccelerator(pMsg,0);       
    }        
    
    return S_FALSE;
}

HRESULT CNscTree::SetObjectRects(LPCRECT prcPos, LPCRECT prcClip)
{
    HRESULT hr = IOleInPlaceObjectWindowlessImpl<CNscTree>::SetObjectRects(prcPos, prcClip);
    LONG lTop = 0;

    if (_hwndHdr)
    {
        RECT rc;

        ::GetWindowRect(_hwndHdr, &rc);
        lTop = RECTHEIGHT(rc);
        ::SetWindowPos(_hwndHdr, NULL, 0, 0, RECTWIDTH(*prcPos), lTop, SWP_NOZORDER | SWP_NOACTIVATE);
    }

    if (_hwndTree)
    {
        ::SetWindowPos(_hwndTree, NULL, 0, lTop, RECTWIDTH(*prcPos), RECTHEIGHT(*prcPos)-lTop, 
                       SWP_NOZORDER | SWP_NOACTIVATE);
    }

    return hr;
}

STDMETHODIMP CNscTree::SetClientSite(IOleClientSite *pClientSite)
{
    SetSite(pClientSite);
    return IOleObjectImpl<CNscTree>::SetClientSite(pClientSite);
}

HRESULT CNscTree::OnDraw(ATL_DRAWINFO& di)
{
    //should only get called before CNscTree is initialized
    return S_OK;
}

LRESULT CNscTree::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    bHandled = FALSE; //let default handler also do it's work
    _OnWindowCleanup();
    return 0;
}

BOOL IsChannelFolder(LPCWSTR pwzPath, LPWSTR pwzChannelURL);

HRESULT CNscTree::GetEventInfo(IShellFolder *psf, LPCITEMIDLIST pidl,
                                               UINT *pcItems, LPWSTR pszUrl, DWORD cchUrl, 
                                               UINT *pcVisits, LPWSTR pszLastVisited, BOOL *pfAvailableOffline)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    TCHAR szUrl[MAX_URL_STRING];

    szPath[0] = szUrl[0] = 0;
    
    *pcItems = 1;
    
    ULONG ulAttr = SFGAO_FOLDER;    // make sure item is actually a folder
    hr = GetPathForItem(psf, pidl, szPath, &ulAttr);
    if (SUCCEEDED(hr) && (ulAttr & SFGAO_FOLDER)) 
    {
        pszLastVisited[0] = 0;
        
        StrCpyN(pszUrl, szPath, cchUrl);

        WIN32_FIND_DATA fd;
        HANDLE hfind = FindFirstFile(szPath, &fd);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            SHFormatDateTime(&(fd.ftLastWriteTime), NULL, pszLastVisited, MAX_PATH);
            FindClose(hfind);
        }
        
        *pcVisits = -1;
        *pfAvailableOffline = 0;
        
        return S_OK;
    } 
    
    if (FAILED(hr))
    {
        // GetPathForItem fails on channel folders, but the following GetDisplayNameOf 
        // succeeds.
        STRRET str;
        if (SUCCEEDED(psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
            StrRetToBuf(&str, pidl, szPath, ARRAYSIZE(szPath));
    }

    hr = GetNavTargetName(psf, pidl, szUrl, ARRAYSIZE(szUrl));

    // IsChannelFolder will fixup szUrl if it's a channel
    IsChannelFolder(szPath, szUrl);

    if (szUrl[0])
    {
        SHTCharToUnicode(szUrl, pszUrl, cchUrl);

        //
        // Get the cache info for this item.  Note that we use GetUrlCacheEntryInfoEx instead
        // of GetUrlCacheEntryInfo because it follows any redirects that occured.  This wacky
        // api uses a variable length buffer, so we have to guess the size and retry if the
        // call fails.
        //
        BOOL fInCache = FALSE;
        TCHAR szBuf[512];
        LPINTERNET_CACHE_ENTRY_INFO pCE = (LPINTERNET_CACHE_ENTRY_INFO)szBuf;
        DWORD dwEntrySize = sizeof(szBuf);
    
        fInCache = GetUrlCacheEntryInfoEx(szUrl, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
        if (!fInCache)
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // We guessed too small for the buffer so allocate the correct size & retry
                pCE = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, dwEntrySize);
                if (pCE)
                {
                    fInCache = GetUrlCacheEntryInfoEx(szUrl, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
                }
            }
        }

        *pfAvailableOffline = IsSubscribed(szUrl);

        if (fInCache)
        {
            *pcVisits = pCE->dwHitRate;

            SHFormatDateTime(&(pCE->LastAccessTime), NULL, pszLastVisited, MAX_PATH);        
        } 
        else
        {
            *pcVisits = 0;
            pszLastVisited[0] = 0;
        }

        if ((TCHAR*)pCE != szBuf)
        {
            LocalFree(pCE);
            pCE = NULL;
        }
    }
    else
    {
        *pcVisits = 0;
        SHTCharToUnicode(szPath, pszUrl, cchUrl);
    }
    
    return hr;
}

//    [id(DISPID_FAVSELECTIONCHANGE)] void FavoritesSelectionChange([in] long cItems, [in] long hItem, [in] BSTR strName,
//             [in] BSTR strUrl, [in] long cVisits, [in] BSTR strDate,
//             [in] BOOL fAvailableOffline);
void CNscTree::_FireFavoritesSelectionChange(
    long cItems, long hItem, BSTR strName, BSTR strUrl, 
    long cVisits, BSTR strDate, long fAvailableOffline)
{
    VARIANTARG args[7];

    IUnknown_CPContainerInvokeParam(SAFECAST(this, IShellNameSpace *), 
        DIID_DShellNameSpaceEvents, DISPID_FAVSELECTIONCHANGE, 
        args, ARRAYSIZE(args), 
        VT_I4, cItems,
        VT_I4, hItem,
        VT_BSTR, strName,
        VT_BSTR, strUrl,
        VT_I4, cVisits,
        VT_BSTR, strDate,
        VT_I4, fAvailableOffline);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\mypics.cpp ===
#include "priv.h"
#include <iehelpid.h>
#include <pstore.h>
#include "hlframe.h"
#include "shldisp.h"
#include "opsprof.h"
#include "resource.h"
#include <mluisupp.h>
#include "htmlstr.h"
#include "mypics.h"
#include "mshtmcid.h"
#include "util.h"
#include "winuser.h"

//////////////////////////////////////////////////////////////////////////////////
//
// filename:    mypics.cpp
//
// description: implements the my pictures exposure hoverbar thingie
//
// notes:       lots of stuff is stolen from iforms.cpp and iformsp.h
//
// history:     06.15.2000 created by t-jdavis
//
//////////////////////////////////////////////////////////////////////////////////

extern HINSTANCE g_hinst;

#define TF_MYPICS TF_CUSTOM2

// we don't actually use all of these, but we COULD, you know, if we wanted too.
CMyPicsEventSinkCallback::EventSinkEntry CMyPicsEventSinkCallback::EventsToSink[] =
{
    { EVENT_MOUSEOVER,  L"onmouseover", L"mouseover"  }, 
    { EVENT_MOUSEOUT,   L"onmouseout",  L"mouseout"   }, 
    { EVENT_SCROLL,     L"onscroll",    L"scroll"     }, 
    { EVENT_RESIZE,     L"onresize",    L"resize"     }
};  

// image toolbar states
enum 
{ 
    HOVERSTATE_HIDING = 0,
    HOVERSTATE_SHOWING,
    HOVERSTATE_LOCKED,
    HOVERSTATE_SCROLLING,
    HOVERSTATE_WAITINGTOSHOW
};

//
// CMyPics
//

// set some stuff
CMyPics::CMyPics()
{
    TraceMsg(TF_MYPICS, "+CMyPics::CMyPics");

    m_Hwnd              = NULL;
    m_hWndMyPicsToolBar = NULL;
    m_hWndHover         = NULL;
    m_wndprocOld        = NULL;
    m_pEleCurr          = NULL;
    m_pSink             = NULL;
    m_bIsOffForSession  = FALSE;
    m_cRef              = 1;
    m_bGalleryMeta      = TRUE;

    TraceMsg(TF_MYPICS, "-CMyPics::CMyPics");
}

// destroy whatever needs destroying....
CMyPics::~CMyPics()
{
    TraceMsg(TF_MYPICS, "+CMyPics::~CMyPics");

    DestroyHover();  

    ATOMICRELEASE(m_pEleCurr);

    if (m_hWndMyPicsToolBar)
        DestroyWindow(m_hWndMyPicsToolBar);

    if (m_hWndHover)
    {
        if (m_wndprocOld)
        {
            SetWindowLongPtr(m_hWndHover, GWLP_WNDPROC, (LONG_PTR)m_wndprocOld);
        }
        SetWindowPtr(m_hWndHover, GWLP_USERDATA, NULL);
        DestroyWindow(m_hWndHover);
    }

    TraceMsg(TF_MYPICS, "-CMyPics::~CMyPics");
}


// did the user turn this feature off?
BOOL CMyPics::IsOff() 
{
    return (m_bIsOffForSession);
}

void CMyPics::IsGalleryMeta(BOOL bFlag)
{
    m_bGalleryMeta = bFlag;
}

HRESULT CMyPics::Init(IHTMLDocument2 *pDoc2)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_MYPICS, "+CMyPics::Init");

    ASSERT(pDoc2);

    //sink things
    IHTMLElement2           *pEle2       = NULL;
    IHTMLElementCollection  *pCollect    = NULL;
    IHTMLElementCollection  *pSubCollect = NULL;
    IDispatch               *pDisp       = NULL;
    VARIANT                  TagName;
    ULONG                    ulCount     = 0;
    VARIANTARG               va1;
    VARIANTARG               va2;
    IHTMLWindow3            *pWin3       = NULL;
    
    // ...remember this...
    m_pDoc2 = pDoc2;
    pDoc2->AddRef();
    
    // setup variant for finding all the IMG tags...
    TagName.vt      = VT_BSTR;
    TagName.bstrVal = (BSTR)c_bstr_IMG;
    
    //get all tags
    hr = pDoc2->get_all(&pCollect);                   
    if (FAILED(hr))
        goto Cleanup;

    //get all IMG tags
    hr = pCollect->tags(TagName, &pDisp);
    if (FAILED(hr))
        goto Cleanup;
        
    if (pDisp) 
    {
        hr = pDisp->QueryInterface(IID_IHTMLElementCollection,(void **)&pSubCollect);
        ATOMICRELEASE(pDisp);
    }
    if (FAILED(hr))
        goto Cleanup;

    //get IMG tag count
    hr = pSubCollect->get_length((LONG *)&ulCount);
    if (FAILED(hr))
        goto Cleanup;

    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
        
    //iterate through tags sinking events to elements
    for (int i=0; i<(LONG)ulCount; i++) 
    {
        pDisp    = NULL;                                
        va1.lVal = (LONG)i;
        pSubCollect->item(va1, va2, &pDisp);

        // only create a new CEventSink once
        if (!m_pSink && pDisp)
            m_pSink = new CEventSink(this);

        if (pDisp) 
        {
            hr = pDisp->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
            if (FAILED(hr))
                goto Cleanup;

            ASSERT(m_pSink);

            if (m_pSink && pEle2) 
            {
                EVENTS events[] = { EVENT_MOUSEOVER, EVENT_MOUSEOUT, EVENT_RESIZE };
                m_pSink->SinkEvents(pEle2, ARRAYSIZE(events), events);
            }
            ATOMICRELEASE(pEle2);
            ATOMICRELEASE(pDisp);
        }
    }
    

    // sink scroll event from the window, because it doesn't come from elements.
    if (m_pSink) 
    {
        Win3FromDoc2(m_pDoc2, &pWin3);

        if (pWin3) 
        {
            m_pWin3 = pWin3;
            m_pWin3->AddRef();

            EVENTS eventScroll[] = { EVENT_SCROLL };
            m_pSink->SinkEvents(pWin3, ARRAYSIZE(eventScroll), eventScroll);
        }
    }
    
    //end sinking things

Cleanup:

    ATOMICRELEASE(pCollect);
    ATOMICRELEASE(pSubCollect);
    ATOMICRELEASE(pWin3);
    ATOMICRELEASE(pDisp);
    ATOMICRELEASE(pEle2);

    TraceMsg(TF_MYPICS, "-CMyPics::Init");

    return hr;
}

HRESULT CMyPics::UnInit()
{
    // Unhook regular event sink

    TraceMsg(TF_MYPICS, "+CMyPics::UnInit");

    if (m_pSink) 
    {
        if (m_pWin3) 
        {
            EVENTS events[] = { EVENT_SCROLL };
            m_pSink->UnSinkEvents(m_pWin3, ARRAYSIZE(events), events);
            SAFERELEASE(m_pWin3);
        }

        m_pSink->SetParent(NULL);
        ATOMICRELEASE(m_pSink);
    }

    SAFERELEASE(m_pEleCurr);
    SAFERELEASE(m_pDoc2);
    
    TraceMsg(TF_MYPICS, "-CMyPics::UnInit");

    return S_OK;
}

STDMETHODIMP CMyPics::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IPropertyNotifySink == riid) || (IID_IUnknown == riid)) 
    {
        *ppv = (IPropertyNotifySink *)this;
    }

    if (*ppv) 
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CMyPics::AddRef(void) 
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMyPics::Release(void) 
{
    if (--m_cRef == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// has this been disabled by some administrator or something via IEAK?
BOOL MP_IsEnabledInIEAK()
{
    DWORD dwType = REG_DWORD;
    DWORD dwSize;
    DWORD dwEnabled;
    DWORD dwRet;
    
    const TCHAR c_szSPMIEPS[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\PhotoSupport");
    const TCHAR c_szVal[]     = TEXT("MyPics_Hoverbar");

    dwSize = sizeof(dwEnabled);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSPMIEPS, c_szVal, &dwType, &dwEnabled, &dwSize);

    if ((dwType == REG_DWORD) && (dwRet == ERROR_SUCCESS)) 
    {
        if (dwEnabled!=1)
            return TRUE;  // enabled
        else
            return FALSE; // disabled
    }

    // value not found...
    return TRUE;
}

// has the user explicitly disabled this feature for now and all time via intern control panel?
BOOL MP_IsEnabledInRegistry()
{
    DWORD dwType = REG_SZ;
    DWORD dwSize;
    TCHAR szEnabled[16];
    DWORD dwRet;
    
    const TCHAR c_szSMIEM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
    const TCHAR c_szVal[]   = TEXT("Enable_MyPics_Hoverbar");

    dwSize = sizeof(szEnabled);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSMIEM, c_szVal, &dwType, szEnabled, &dwSize);

    if (dwRet == ERROR_INSUFFICIENT_BUFFER) 
    {
        ASSERT(dwRet == ERROR_SUCCESS); // this is wacky...
        return FALSE;
    }

    if ((dwType == REG_SZ) && (dwRet == ERROR_SUCCESS)) 
    {
        if (!StrCmp(szEnabled, TEXT("yes")))
            return TRUE;  // enabled
        else
            return FALSE; // disabled
    }

    // value not found...
    return TRUE;
}

// what should the default behavior be if an error occurs? hmm...
// check status of the Show Pictures option in the inetcpl
BOOL MP_ShowPicsIsOn()
{
    DWORD dwType = REG_SZ;
    DWORD dwSize;
    TCHAR szEnabled[16];
    DWORD dwRet;
    
    const TCHAR c_szSMIEM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
    const TCHAR c_szVal[]   = TEXT("Display Inline Images");

    dwSize = sizeof(szEnabled);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSMIEM, c_szVal, &dwType, szEnabled, &dwSize);

    if (dwRet == ERROR_INSUFFICIENT_BUFFER) 
    {
        ASSERT(dwRet == ERROR_SUCCESS);
        return FALSE;
    }

    if ((dwType == REG_SZ) && (dwRet == ERROR_SUCCESS)) 
    {
        if (!StrCmp(szEnabled, TEXT("yes")))
            return TRUE;  // enabled
        else
            return FALSE; // disabled
    }

    // value not found...
    return TRUE;
}

DWORD MP_GetFilterInfoFromRegistry()
{

    const TCHAR c_szSMIEAOMM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
    const TCHAR c_szVal[]      = TEXT("Image_Filter");
   
    DWORD dwType, dwSize, dwFilter, dwRet;
    
    dwSize = sizeof(dwFilter);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSMIEAOMM, c_szVal, &dwType, &dwFilter, &dwSize);

    if ((dwRet != ERROR_SUCCESS) || (dwType != REG_DWORD))
    {
        dwFilter = MP_MIN_SIZE;
    }

    return dwFilter;
}

DWORD MP_GetOffsetInfoFromRegistry()
{

    const TCHAR c_szSMIEAOMM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
    const TCHAR c_szVal[]      = TEXT("Offset");
   
    DWORD dwType, dwSize, dwOffset, dwRet;
    
    dwSize = sizeof(dwOffset);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSMIEAOMM, c_szVal, &dwType, &dwOffset, &dwSize);

    if ((dwRet != ERROR_SUCCESS) || (dwType != REG_DWORD))
    {
        dwOffset = MP_HOVER_OFFSET;
    }

    return dwOffset;
}

BOOL_PTR CALLBACK DisableMPDialogProc(HWND hDlg, UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    BOOL bMsgHandled = FALSE;

    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            // center dialog... yay msdn...
            RECT rc;
            GetWindowRect(hDlg, &rc);
            SetWindowPos(hDlg, HWND_TOP,
            ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
            ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
            0, 0, SWP_NOSIZE);
        } 
        break;

    case WM_COMMAND:
        switch (LOWORD(wparam)) 
        {
            case IDC_MP_ALWAYS:
                EndDialog(hDlg, IDC_MP_ALWAYS);
                break;

            case IDC_MP_THISSESSION:
                EndDialog(hDlg, IDC_MP_THISSESSION);
                break;

            case IDC_MP_CANCEL:
                EndDialog(hDlg, IDC_MP_CANCEL);
                break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, IDC_MP_CANCEL);
        break;

    default:
        break;
    }
    return(bMsgHandled);
}


LRESULT CALLBACK CMyPics::s_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMyPics* pThis = (CMyPics*)GetWindowPtr(hWnd, GWLP_USERDATA);    

    TraceMsg(TF_MYPICS, "+CMyPics::s_WndProc  hWnd=%x, pThis=%p", hWnd, pThis);

    HRESULT             hr                = S_OK;
    IOleCommandTarget  *pOleCommandTarget = NULL;   
    switch (uMsg) 
    {
        case WM_SIZE:
            
            if (!pThis)
                break;

            SetWindowPos(pThis->m_hWndMyPicsToolBar, NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);
            break;

        case WM_ERASEBKGND:

            if (!pThis)
                break;

            {
                RECT rc;
                HBRUSH hb = GetSysColorBrush(COLOR_3DFACE);

                GetClientRect(pThis->m_hWndMyPicsToolBar, &rc);
                FillRect((HDC)wParam, &rc, hb);
                return TRUE;
            }

        case WM_COMMAND:

            if (!pThis)
                break;

            switch(LOWORD(wParam))
            {
                case IDM_MYPICS_SAVE:   //Save As... dialogue
                    
                    ASSERT(pThis->m_pEleCurr);

                    // the evil QI call... 
                    hr = pThis->m_pEleCurr->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget);
                    if (FAILED(hr))
                        return(hr);

                    // hide the hoverthing so it doesn't cause us any nasty problems
                    pThis->HideHover();
                    
                    // launch the Save As dialogue thingie...
                    pOleCommandTarget->Exec(&CGID_MSHTML, IDM_SAVEPICTURE, 0, 0, NULL);
                    ATOMICRELEASE(pOleCommandTarget);

                break;
                
                case IDM_MYPICS_PRINT:
                {
                    // get the cmd target
                    hr = pThis->m_pEleCurr->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget);
                    if (FAILED(hr))
                        return(hr);
                    
                    pThis->HideHover();
                    //pThis->m_hoverState = HOVERSTATE_SHOWING; // kludge to keep hover from appearing under print dialogue

                    pOleCommandTarget->Exec(&CGID_MSHTML, IDM_MP_PRINTPICTURE, 0, 0, NULL);
                    ATOMICRELEASE(pOleCommandTarget);
                    
                    //pThis->m_hoverState = HOVERSTATE_HIDING;
                }
                    
                break;
                
                case IDM_MYPICS_EMAIL:
                {
                    // get the cmd target...
                    hr = pThis->m_pEleCurr->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget);
                    if (FAILED(hr)) 
                        return(hr);

                    // ... and then hide the hover bar...
                    pThis->HideHover();
                    //pThis->m_hoverState = HOVERSTATE_SHOWING; // kludge to keep hover from appearing under print dialogue

                    // ... and pray this works...
                    pOleCommandTarget->Exec(&CGID_MSHTML, IDM_MP_EMAILPICTURE, 0, 0, NULL);
                    ATOMICRELEASE(pOleCommandTarget);

                    // ... and cleanup
                    //pThis->m_hoverState = HOVERSTATE_HIDING;
                }
                    
                break;
                
                case IDM_MYPICS_MYPICS:   // Open My Pictures folder

                    // get the cmd target
                    hr = pThis->m_pEleCurr->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget);
                    if (FAILED(hr)) 
                        return(hr);
                    
                    pOleCommandTarget->Exec(&CGID_MSHTML, IDM_MP_MYPICS, 0, 0, NULL);
                    ATOMICRELEASE(pOleCommandTarget);

                    hr = S_OK;
                    pThis->HideHover();

                break;

                default:
                    break;
            }
            break;
            

        case WM_NOTIFY:  // tooltips...

            if (!pThis)
                break;
            
            switch (((LPNMHDR)lParam)->code) 
            {
                case TTN_NEEDTEXT:
                {
                    LPTOOLTIPTEXT lpToolTipText;
                    TCHAR szBuf[MAX_PATH];
                    lpToolTipText = (LPTOOLTIPTEXT)lParam;
                    hr = MLLoadString((UINT)lpToolTipText->hdr.idFrom,   
                                      szBuf,
                                      ARRAYSIZE(szBuf));
                    lpToolTipText->lpszText = szBuf;
                    break;
                }
            }
            break;

        case WM_SETTINGCHANGE:

            if (!pThis)
                break;

            {
                pThis->DestroyHover();                                 // to stop wierd window distortion
                break;
            }

        case WM_CONTEXTMENU:

            if (!pThis)
                break;

            {
                // load the menu
                HMENU hMenu0 = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_MYPICS_CONTEXT_MENU));
                HMENU hMenu1 = GetSubMenu(hMenu0, 0);

                if(!hMenu1)
                    break;
                
                POINT point;

                point.x = (LONG)GET_X_LPARAM(lParam);
                point.y = (LONG)GET_Y_LPARAM(lParam);

                ASSERT(pThis->m_hoverState=HOVERSTATE_SHOWING);

                // lock against mouseouts
                pThis->m_hoverState = HOVERSTATE_LOCKED;

                // display it, get choice (if any)
                int   iPick = TrackPopupMenu(hMenu1, 
                                             TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                             point.x,
                                             point.y,
                                             0,
                                             hWnd,
                                             (RECT *)NULL);

                DestroyMenu(hMenu0);
                DestroyMenu(hMenu1);

                pThis->m_hoverState = HOVERSTATE_SHOWING;

                if (iPick) 
                {
                    switch(iPick) 
                    {
                        case IDM_DISABLE_MYPICS:
                            {
                                pThis->HideHover();
                                
                                // create dialog to ask user if they want to turn this stuff off...
                                // (explicit cast to make Win64 builds happy)
                                int iResult = (int)DialogBoxParam(MLGetHinst(),
                                                             MAKEINTRESOURCE(DLG_DISABLE_MYPICS),
                                                             pThis->m_Hwnd,
                                                             DisableMPDialogProc,
                                                             NULL);
                                
                                // deal with their choice...
                                if (iResult) 
                                {
                                    switch (iResult) 
                                    {
                                        case IDC_MP_ALWAYS:
                                            {
                                                pThis->m_bIsOffForSession = TRUE;
                                                DWORD dwType = REG_SZ;
                                                DWORD dwSize;
                                                TCHAR szEnabled[16] = TEXT("no");
                                                DWORD dwRet;
     
                                                const TCHAR c_szSMIEM[] = 
                                                            TEXT("Software\\Microsoft\\Internet Explorer\\Main");
                                                const TCHAR c_szVal[]   = TEXT("Enable_MyPics_Hoverbar");

                                                dwSize = sizeof(szEnabled);

                                                dwRet = SHSetValue(HKEY_CURRENT_USER, 
                                                                   c_szSMIEM, 
                                                                   c_szVal,
                                                                   dwType, 
                                                                   szEnabled, 
                                                                   dwSize);
                                            }
                                            break;
                                        case IDC_MP_THISSESSION:
                                            // twiddle member var flag
                                            // this is propagated back up to COmWindow via ReleaseMyPics() function.
                                            pThis->m_bIsOffForSession = TRUE;
                                            
                                            break;

                                        default:
                                            break;
                                    }
                                }
                            }
                            break;
                        case IDM_HELP_MYPICS:
                                pThis->HideHover();
                                SHHtmlHelpOnDemandWrap(hWnd, TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("pic_tb_ovr.htm"), ML_CROSSCODEPAGE);
                            break;
                        default:
                            // um, do nothing
                            break;
                    }
                }
            }

            break;

        default:
            return (DefWindowProc(hWnd, uMsg, wParam, lParam));
    }


    TraceMsg(TF_MYPICS, "-CMyPics::s_WndProc  hWnd=%x, pThis=%p", hWnd, pThis);

    return (hr);
}

VOID CALLBACK CMyPics::s_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) 
{
    TraceMsg(TF_MYPICS, "+CMyPics::TimerProc");

    CMyPics* pThis = (CMyPics*)GetWindowPtr(hwnd, GWLP_USERDATA);

    switch (uMsg) 
    {
        case WM_TIMER:
            KillTimer(hwnd, IDT_MP_TIMER);  
            if (pThis && (pThis->m_hoverState == HOVERSTATE_WAITINGTOSHOW))
            {
                // Our hover bar is waiting to be shown.
                if (pThis->m_pEleCurr)
                {
                    // We still have an element.  Show it.
                    pThis->m_hoverState = HOVERSTATE_SHOWING;

                    pThis->ShowHover();
                } 
                else
                {
                    // Our timer popped, but we don't have an element.
                    pThis->HideHover();
                }
            }
            break;
        
        default:
            break;
    }
    TraceMsg(TF_MYPICS, "-CMyPics::TimerProc");
}


BOOL CMyPics::ShouldAppearOnThisElement(IHTMLElement *pEle) 
{
    BOOL                  bRet              = TRUE; // appear by default
    VARIANT               varVal            = {0};
    BSTR                  bstrAttribute     = NULL; // to check img tags for expando
    IHTMLRect            *pRect             = NULL; // to get screen coords
    IHTMLElement2        *pEle2             = NULL;
    IHTMLElement3        *pEle3             = NULL; // to check for contenteditable mode
    VARIANT_BOOL          bEdit             = FALSE;// becomes true if contenteditable mode is true
    LONG                  lLeft;                    // these are the screen coords
    LONG                  lRight;                   // we get right and bottom to det size of image
    LONG                  lTop;
    LONG                  lBottom;
    DWORD                 dwFilter;
    IOleCommandTarget    *pOleCommandTarget = NULL;

    TraceMsg(TF_MYPICS, "+CMyPics::ShouldAppearOnThisElement");

    // don't create it if it already exists.  thats bad.
    if ((HOVERSTATE_SHOWING == m_hoverState) || (HOVERSTATE_LOCKED == m_hoverState))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    m_bGalleryImg = FALSE;

    if (!pEle)
    {
        bRet = FALSE;
        goto Cleanup;
    }

    // find out if the image didn't load or is unrenderable
    if (SUCCEEDED(pEle->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget)))
    {
        OLECMD rgCmd;

        rgCmd.cmdID = IDM_SAVEPICTURE;  // this is the same check the context menu uses
        rgCmd.cmdf = 0;

        pOleCommandTarget->QueryStatus(&CGID_MSHTML, 1, &rgCmd, NULL);

        if (!(OLECMDF_ENABLED & rgCmd.cmdf))
        {
            bRet = FALSE;
            goto Cleanup;
        }
    }

    // check for explicit enable/disable attribute in img tag...
    bstrAttribute=SysAllocString(L"galleryimg"); 
    if (!bstrAttribute) 
        goto Cleanup;

    if (SUCCEEDED(pEle->getAttribute(bstrAttribute, 0, &varVal))) 
    {
        if (varVal.vt == VT_BSTR) 
        {
            if (StrCmpIW(varVal.bstrVal, L"true") == 0 
                || StrCmpIW(varVal.bstrVal, L"on") == 0 
                || StrCmpIW(varVal.bstrVal, L"yes") == 0
                )
            {
                // Explicitly turned on.  Honor it and leave.
                bRet = TRUE;
                m_bGalleryImg = TRUE;
                goto Cleanup;
            }
            if (StrCmpIW(varVal.bstrVal, L"false") == 0 
                || StrCmpIW(varVal.bstrVal, L"off") == 0 
                || StrCmpIW(varVal.bstrVal, L"no") == 0
                )
            {
                // Explicitly turned off.  Honor it and leave.
                bRet = FALSE;
                goto Cleanup;
            }
        } 
        else if (varVal.vt == VT_BOOL)
        {
            if (varVal.boolVal == VARIANT_TRUE)
            {
                bRet = TRUE;
                m_bGalleryImg = TRUE;
                goto Cleanup;
            } 
            else
            {
                bRet = FALSE;
                goto Cleanup;
            }
        }
    } 

    VariantClear(&varVal);
    SysFreeString(bstrAttribute);

    // After checking "galleryimg" tag, check to see if turned off by the META tag
    if (m_bGalleryMeta == FALSE)
        return FALSE;

    // check for mappings on the image...
    bstrAttribute=SysAllocString(L"usemap"); 
    if (!bstrAttribute) 
        return (bRet);

    if (SUCCEEDED(pEle->getAttribute(bstrAttribute, 0, &varVal))) 
    {
        if (varVal.vt == VT_BSTR) 
        {
            // What do we do here?
            bRet = (varVal.bstrVal == NULL);
            if (!bRet)
                goto Cleanup;
        } 
    } 
    VariantClear(&varVal);
    SysFreeString(bstrAttribute);

    // check for mappings on the image...
    bstrAttribute=SysAllocString(L"ismap"); 
    if (!bstrAttribute) 
        return (bRet);

    if (SUCCEEDED(pEle->getAttribute(bstrAttribute, 0, &varVal))) 
    {
        // If the attribute exists, then we need to return FALSE *unless* we see a value of FALSE
        bRet = FALSE;
        if (varVal.vt == VT_BOOL 
            && varVal.boolVal == VARIANT_FALSE)
        {
            // "ismap" is false, so we can show the hover bar over this image.
            bRet = TRUE;
        }
    } 
    if (!bRet)
        goto Cleanup;

    bRet = FALSE;  // If any of the calls below fail, we'll exit with "FALSE".
    
    // Now check to see if we pass the size filter.
    // get an IHTMLElement2 from the IHTMLElement passed in...
    if (FAILED(pEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2) ))
        goto Cleanup;

    // get coords...
    if (FAILED(pEle2->getBoundingClientRect(&pRect) ))
        goto Cleanup;

    if (FAILED(pRect->get_left(&lLeft) )) 
        goto Cleanup;

    if (FAILED(pRect->get_right(&lRight) ))
        goto Cleanup;

    if (FAILED(pRect->get_top(&lTop) ))
        goto Cleanup;

    if (FAILED(pRect->get_bottom(&lBottom) ))
        goto Cleanup;

    dwFilter = MP_GetFilterInfoFromRegistry();

    // see if this picture is big enough to qualify as a "Photo"... 
    // TODO: decide if we like checking aspect ratio or not
    if ( (lRight - lLeft >= (LONG)dwFilter && lBottom - lTop >= (LONG)dwFilter)
       /*&& !(2*(min(lRight-lLeft,lBottom-lTop)) < max(lRight-lLeft,lBottom-lTop)) */)
        bRet = TRUE;

    if (FAILED(pEle2->QueryInterface(IID_IHTMLElement3, (void **)&pEle3) ))
        goto Cleanup;

    if (FAILED(pEle3->get_isContentEditable(&bEdit) ))
        goto Cleanup;

    if (bEdit)
        bRet = FALSE;

Cleanup:
    VariantClear(&varVal);
    if (bstrAttribute)
        SysFreeString(bstrAttribute);

    SAFERELEASE(pOleCommandTarget);

    SAFERELEASE(pEle3);
    SAFERELEASE(pRect);
    SAFERELEASE(pEle2);
    
    TraceMsg(TF_MYPICS, "-CMyPics::ShouldAppearOnThisElement");

    return bRet;
}

HRESULT CMyPics::CreateHover() 
{
    HRESULT hr      = S_OK;               
    SIZE    size    = {0,0};
    WORD    wImage;
    HBITMAP hbmp    = NULL;
    HBITMAP hbmpHot = NULL;

    TraceMsg(TF_MYPICS, "+CMyPics::CreateHover, this=%p, m_hoverState=%d", this, m_hoverState);

    InitCommonControls();

    WNDCLASS wc = {0};
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = TEXT("MyPicturesHost");
    wc.lpfnWndProc = s_WndProc;
    wc.hInstance = g_hinst;
    wc.hbrBackground = HBRUSH(COLOR_BTNFACE);
    RegisterClass(&wc);


    // create the rebar to hold the toolbar...
    if (!m_hWndHover)
    {

        m_hWndHover = CreateWindow(TEXT("MyPicturesHost"), TEXT(""), WS_DLGFRAME | WS_VISIBLE | WS_CHILD, 
                                   0, 0, 0, 0, m_Hwnd, NULL, g_hinst, NULL);

        if (!m_hWndHover)
        {
            TraceMsg(TF_MYPICS | TF_WARNING, "CMyPics::CreateHover, unable to create m_hWndHover");
            hr = E_FAIL;
            goto Cleanup;
        }

        ASSERT(GetWindowPtr(m_hWndHover, GWLP_USERDATA) == NULL);
        SetWindowPtr(m_hWndHover, GWLP_USERDATA, this);

        // set cc version
        SendMessage(m_hWndHover, CCM_SETVERSION, COMCTL32_VERSION, 0);
    }
    
    // create the toolbar...
    if (!m_hWndMyPicsToolBar)
    {

        m_hWndMyPicsToolBar = CreateWindow(TOOLBARCLASSNAME, TEXT(""), TBSTYLE_TOOLTIPS | CCS_NODIVIDER | TBSTYLE_FLAT | WS_VISIBLE | WS_CHILD,
                                           0,0,0,0, m_hWndHover, NULL, g_hinst, NULL);

        if (!m_hWndMyPicsToolBar)
        {
            TraceMsg(TF_MYPICS | TF_WARNING, "CMyPics::CreateHover, unable to create m_hWndMyPicsToolBar");
            hr = E_FAIL;
            goto Cleanup;
        }
        SetWindowPtr(m_hWndMyPicsToolBar, GWLP_USERDATA, this); // for the timer proc

        // set cc version for this too, and the sizeof tbbutton struct...
        SendMessage(m_hWndMyPicsToolBar, CCM_SETVERSION,      COMCTL32_VERSION, 0);
        SendMessage(m_hWndMyPicsToolBar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
    }

    // create image lists...
    wImage      = ((IsOS(OS_WHISTLERORGREATER)) ? IDB_MYPICS_TOOLBARGW : IDB_MYPICS_TOOLBARG);

    if (!m_himlHover)
    {
        m_himlHover = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(wImage), 16, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (!m_himlHover)
        {
            TraceMsg(TF_MYPICS | TF_WARNING, "CMyPics::CreateHover, unable to create m_himlHover");
        }
    }


    wImage = ((IsOS(OS_WHISTLERORGREATER)) ? IDB_MYPICS_TOOLBARW : IDB_MYPICS_TOOLBAR);

    if (!m_himlHoverHot)
    {
        m_himlHoverHot = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(wImage) , 16, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (!m_himlHoverHot)
        {
            TraceMsg(TF_MYPICS | TF_WARNING, "CMyPics::CreateHover, unable to create m_himlHoverHot");
        }
    }

    // set image list and hot image list
    SendMessage(m_hWndMyPicsToolBar, TB_SETIMAGELIST,    0, (LPARAM)m_himlHover   );
    SendMessage(m_hWndMyPicsToolBar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlHoverHot);

    TBBUTTON tbButton;

    // set bitmap indexes in tbbutton structure (this may not be necessary)
    for (int i=0;i<MP_NUM_TBBITMAPS;i++)
    {
        tbButton.iBitmap = MAKELONG(i,0);
        tbButton.fsState = TBSTATE_ENABLED;
        tbButton.fsStyle = TBSTYLE_BUTTON;
        tbButton.dwData  = 0;
        tbButton.iString = 0;
        switch(i)
        {
            case 0: tbButton.idCommand = IDM_MYPICS_SAVE; break;
            case 1: tbButton.idCommand = IDM_MYPICS_PRINT; break;
            case 2: tbButton.idCommand = IDM_MYPICS_EMAIL; break;
            case 3: tbButton.idCommand = IDM_MYPICS_MYPICS; break;
        }
        
        SendMessage(m_hWndMyPicsToolBar, TB_INSERTBUTTON, i, (LPARAM)&tbButton);
    }

Cleanup:

    TraceMsg(TF_MYPICS, "-CMyPics::CreateHover, this=%p, m_hoverState=%d", this, m_hoverState);

    return hr;
}

HRESULT CMyPics::DestroyHover() 
{
    HRESULT hr = S_OK;

    TraceMsg(TF_MYPICS, "+CMyPics::DestroyHover, this=%p, m_hoverState=%d", this, m_hoverState);

    // If we have a MyPicsToolBar...
    if (m_hWndMyPicsToolBar)
    {
        // first destroy the toolbar
        if (!DestroyWindow(m_hWndMyPicsToolBar))
        {
            TraceMsg(TF_MYPICS, "In CMyPics::DestroyHover, DestroyWindow(m_hWndMyPicsToolBar) failed");
            hr = E_FAIL;
        }
        m_hWndMyPicsToolBar=NULL;
    }

    // If we have a hover window...
    if (m_hWndHover)
    {
        if (m_wndprocOld)
        {
            // Unsubclass the window
            SetWindowLongPtr(m_hWndHover, GWLP_WNDPROC, (LONG_PTR)m_wndprocOld);
            m_wndprocOld = NULL;
        }

        // Clear the window word
        SetWindowPtr(m_hWndHover, GWLP_USERDATA, NULL);

        // then destroy the rebar
        if (!DestroyWindow(m_hWndHover))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        m_hWndHover = NULL;
    }

    // and destroy the image lists...
    if (m_himlHover)
    {
        ImageList_Destroy(m_himlHover);
        m_himlHover = NULL;
    }

    if (m_himlHoverHot)
    {
        ImageList_Destroy(m_himlHoverHot);
        m_himlHoverHot = NULL;
    }


Cleanup:
    TraceMsg(TF_MYPICS, "-CMyPics::DestroyHover, this=%p, hr=%x", this, hr);

    return hr;
}

HRESULT CMyPics::HideHover()
{
    HRESULT    hr = S_OK;

    TraceMsg(TF_MYPICS, "+CMyPics::HideHover, this=%p, m_hoverState=%d", this, m_hoverState);

    if (m_hWndHover)
    {
        ShowWindow(m_hWndHover, SW_HIDE);
        m_hoverState = HOVERSTATE_HIDING;
    }
    else
        hr = E_FAIL;

    TraceMsg(TF_MYPICS, "-CMyPics::HideHover, this=%p, m_hoverState=%d", this, m_hoverState);

    return hr;
}


IHTMLElement *CMyPics::GetIMGFromArea(IHTMLElement *pEleIn, POINT ptEvent)
{
    // someone got an IHTMLElement and decided it was an area tag
    // so find the img tag associated and return it as an IHTMLElement

    BSTR                     bstrName    = NULL;
    BSTR                     bstrUseMap  = NULL;
    IHTMLElement            *pEleParent  = NULL;
    IHTMLElement            *pEleMisc    = NULL;
    IHTMLElement2           *pEle2Misc   = NULL;
    IHTMLElement            *pEleMiscPar = NULL;
    IHTMLMapElement         *pEleMap     = NULL;
    IHTMLImgElement         *pEleImg     = NULL;
    IHTMLElement            *pEleOut     = NULL;
    IHTMLElementCollection  *pCollect    = NULL;
    IHTMLElementCollection  *pSubCollect = NULL;
    IDispatch               *pDisp       = NULL;
    VARIANT                  TagName;
    ULONG                    ulCount     = 0;
    VARIANTARG               va1;
    VARIANTARG               va2;
    HRESULT                  hr;
    POINT                    ptMouse,
                             ptScr;
    LONG                     xInIMG      = 0,
                             yInIMG      = 0,
                             lOffset     = 0,
                             lOffsetLeft = 0,
                             lOffsetTop  = 0,
                             lScrollLeft = 0,
                             lScrollTop  = 0,
                             lOffsetW    = 0,
                             lOffsetH    = 0;


    TagName.vt      = VT_BSTR;
    TagName.bstrVal = (BSTR)c_bstr_IMG;

    
    // first get the map element
    if (SUCCEEDED(pEleIn->get_offsetParent(&pEleParent)))
    {
        // get the map element
        hr=pEleParent->QueryInterface(IID_IHTMLMapElement, (void **)&pEleMap);
        if (FAILED(hr))
            goto Cleanup;

        // next get the name of the map
        if (SUCCEEDED(pEleMap->get_name(&bstrName)))
        {
            //next get all tags
            hr = m_pDoc2->get_all(&pCollect);                   
            if (FAILED(hr))
                goto Cleanup;

            //get all IMG tags
            hr = pCollect->tags(TagName, &pDisp);
            if (FAILED(hr))
                goto Cleanup;
        
            if (pDisp) 
            {
                hr = pDisp->QueryInterface(IID_IHTMLElementCollection,(void **)&pSubCollect);
                ATOMICRELEASE(pDisp);
            }
            if (FAILED(hr))
                goto Cleanup;

            //get IMG tag count
            hr = pSubCollect->get_length((LONG *)&ulCount);
            if (FAILED(hr))
                goto Cleanup;
            
            va1.vt = VT_I4;
            va2.vt = VT_EMPTY;

            ASSERT(pDisp==NULL);
        
            //iterate through tags looking for images that have the right usemap set
            for (int i=0; i<(LONG)ulCount; i++) 
            {
                ATOMICRELEASE(pEleImg);
                ATOMICRELEASE(pDisp);
                
                pDisp       = NULL;                                
                bstrUseMap  = NULL;
                xInIMG      = 0;
                yInIMG      = 0;
                lOffset     = 0;
                lOffsetLeft = 0;
                lOffsetTop  = 0;
                lScrollLeft = 0;
                lScrollTop  = 0;
                lOffsetW    = 0;
                lOffsetH    = 0;
                va1.lVal    = (LONG)i;

                pSubCollect->item(va1, va2, &pDisp);

                if (pDisp) 
                {
                    hr = pDisp->QueryInterface(IID_IHTMLImgElement, (void **)&pEleImg);
                    if (FAILED(hr))
                        goto Cleanup;

                    hr = pEleImg->get_useMap(&bstrUseMap);
                    if (FAILED(hr))
                        goto Cleanup;

                    // this will be non-null if set for this IMG element...
                    if (bstrUseMap){
                        // get rid of the prepended '#'...
                        bstrUseMap++;
                        // see if this is what we're looking for...
                        if (StrCmp(bstrUseMap, bstrName) == 0)
                        {
                            m_pWin3->get_screenLeft(&ptScr.x);
                            m_pWin3->get_screenTop (&ptScr.y);

                            //Ok, we found a candidate.  See if the mouse is here...
                            ptMouse.x = ptEvent.x - ptScr.x;
                            ptMouse.y = ptEvent.y - ptScr.y;

                            hr = pDisp->QueryInterface(IID_IHTMLElement, (void **)&pEleMisc);
                            if (FAILED(hr))
                                goto Cleanup;

                            while (pEleMisc)
                            {
                                hr = pEleMisc->QueryInterface(IID_IHTMLElement2, (void **)&pEle2Misc);
                                if (FAILED(hr))
                                    goto Cleanup;

                                pEleMisc->get_offsetLeft(&lOffsetLeft);
                                pEle2Misc->get_scrollLeft(&lScrollLeft);

                                lOffset += lOffsetLeft - lScrollLeft;

                                pEleMisc->get_offsetParent(&pEleMiscPar);
                                ATOMICRELEASE(pEleMisc);
                                ATOMICRELEASE(pEle2Misc);
                                pEleMisc=pEleMiscPar;

                            }

                            ATOMICRELEASE(pEleMiscPar);

                            hr = pDisp->QueryInterface(IID_IHTMLElement, (void **)&pEleMisc);
                            if (FAILED(hr))
                                goto Cleanup;

                            xInIMG = ptMouse.x - lOffset;
                            pEleMisc->get_offsetWidth(&lOffsetW);

                            if ((xInIMG < 0) || (xInIMG > lOffsetW))
                                continue;

                            lOffset = 0;

                            while (pEleMisc)
                            {
                                hr = pEleMisc->QueryInterface(IID_IHTMLElement2, (void **)&pEle2Misc);
                                if (FAILED(hr))
                                    goto Cleanup;

                                pEleMisc->get_offsetTop(&lOffsetTop);
                                pEle2Misc->get_scrollTop(&lScrollTop);

                                lOffset += lOffsetTop - lScrollTop;

                                pEleMisc->get_offsetParent(&pEleMiscPar);
                                ATOMICRELEASE(pEleMisc);
                                ATOMICRELEASE(pEle2Misc);
                                pEleMisc=pEleMiscPar;

                            }

                            ATOMICRELEASE(pEleMiscPar);

                            hr = pDisp->QueryInterface(IID_IHTMLElement, (void **)&pEleMisc);
                            if (FAILED(hr))
                                goto Cleanup;

                            yInIMG = ptMouse.y - lOffset;
                            pEleMisc->get_offsetHeight(&lOffsetH);

                            ATOMICRELEASE(pEleMisc);

                            if ((yInIMG < 0) || (yInIMG > lOffsetH))
                                continue;

                            // if we get to this point we found our IMG element so...
                            // ...do the QI...
                            pEleImg->QueryInterface(IID_IHTMLElement, (void **)&pEleOut);
                            
                            // ...and we're done.
                            break;

                        }
                    }
                }
            }
        }
    }

Cleanup:

    ATOMICRELEASE(pCollect);
    ATOMICRELEASE(pSubCollect);
    ATOMICRELEASE(pEleMap);
    ATOMICRELEASE(pEleParent);
    ATOMICRELEASE(pDisp);
    ATOMICRELEASE(pEleImg);
    ATOMICRELEASE(pEleMisc);
    ATOMICRELEASE(pEle2Misc);
    ATOMICRELEASE(pEleMiscPar);

    return (pEleOut);  
}

// sometimes coordinates are relative to a parent object, like in frames, etc.  so this gets their real position relative
// to the browser window...
HRESULT CMyPics::GetRealCoords(IHTMLElement2 *pEle2, HWND hwnd, LONG *plLeft, LONG *plTop, LONG *plRight, LONG *plBottom)
{
    LONG       lScreenLeft = 0, 
               lScreenTop  = 0;
    HRESULT    hr          = E_FAIL;
    IHTMLRect *pRect       = NULL;
  
    *plLeft = *plTop = *plRight = *plBottom = 0;

    if (!pEle2)
        return hr;

    if (SUCCEEDED(pEle2->getBoundingClientRect(&pRect)) && pRect)
    {
        LONG lLeft, lRight, lTop, lBottom;

        pRect->get_left(&lLeft);
        pRect->get_right(&lRight);
        pRect->get_top(&lTop);
        pRect->get_bottom(&lBottom);

        // if its an iframe and it scrolls past the top of the frame, we should correct a bit.
        if (lTop <= 0)
            lTop = 0;

        // dito for left side
        if (lLeft <= 0)
            lLeft = 0;
        
        POINT pointTL, pointBR;  // TL=Top,Left BR=Bottom,Right

        ASSERT(m_pWin3);
        m_pWin3->get_screenLeft(&lScreenLeft);
        m_pWin3->get_screenTop(&lScreenTop);

        // convert coords relative to the frame window to screen coords
        pointTL.x = lScreenLeft + lLeft;
        pointTL.y = lScreenTop  + lTop;
        pointBR.x = lScreenLeft + lRight;
        pointBR.y = lScreenTop  + lBottom;

        // now convert from screen coords to client coords and assign...
        if (ScreenToClient(hwnd, &pointTL) && ScreenToClient(hwnd, &pointBR)) 
        {
            *plLeft   = pointTL.x;
            *plRight  = pointBR.x;
            *plTop    = pointTL.y;
            *plBottom = pointBR.y;

            hr = S_OK;
        }

        pRect->Release();
    }
    return hr;
}

HRESULT CMyPics::ShowHover()
{
    HRESULT               hr = S_OK;
    IHTMLElement2        *pEle2        = NULL; // cause we need an ele2 to get screen coords
    IHTMLRect            *pRect        = NULL; // to get screen coords
    LONG                  lLeft;               // these are the screen coords
    LONG                  lRight;              // we get right and bottom to det size of image
    LONG                  lTop;
    LONG                  lBottom;
    DWORD                 dwOffset;

    DWORD dw;
    SIZE  sz;
    RECT  rc;   
    
    TraceMsg(TF_MYPICS, "+CMyPics::ShowHover, this=%p, m_hoverState=%d", this, m_hoverState);

    ASSERT(m_pEleCurr);
    ASSERT(m_Hwnd);

    // get an IHTMLElement2 from the IHTMLElement cached...
    hr = m_pEleCurr->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
    if (FAILED(hr))
        goto Cleanup;

    // get correct coords...
    hr = GetRealCoords(pEle2, m_Hwnd, &lLeft, &lTop, &lRight, &lBottom);
    if (FAILED(hr))
        goto Cleanup;

    // adjust for offset...
    dwOffset = MP_GetOffsetInfoFromRegistry();
    lLeft += dwOffset;
    lTop  += dwOffset;

    // need to do some sanity checks to make sure the hover bar appears in a visible location...
    RECT rcBrowserWnd;
    if (GetClientRect(m_Hwnd, &rcBrowserWnd)) 
    {
        // check to make sure it'll appear somewhere we'll see it...
        if (lLeft < rcBrowserWnd.left)
            lLeft = rcBrowserWnd.left + dwOffset;

        if (lTop < rcBrowserWnd.top)
            lTop = rcBrowserWnd.top + dwOffset;

        // check to make sure the entire hoverbar is over the image (so the user
        // doesn't mouseout trying to get to the buttons!)

        // If "galleryimg" was explicitly turned on, then bypass this code, which ensures that the entire
        // toolbar will fit within the image.

        if (!m_bGalleryImg)
        {
            if (lRight - lLeft < MP_MIN_CX + 10 - (LONG)dwOffset)
                goto Cleanup;

            if (lBottom - lTop < MP_MIN_CY + 10)
                goto Cleanup;

            // now check to make sure there is enough horiz and vert room for it to appear...
            // if there isn't enough room, we just don't display it...
            if ((rcBrowserWnd.right  - MP_SCROLLBAR_SIZE)     - lLeft < MP_MIN_CX)
                goto Cleanup;

            if ((rcBrowserWnd.bottom - (MP_SCROLLBAR_SIZE+2)) - lTop  < MP_MIN_CY)
                goto Cleanup;
        }
    }

    dw = (DWORD)SendMessage(m_hWndMyPicsToolBar, TB_GETBUTTONSIZE, 0, 0);
    sz.cx = LOWORD(dw); sz.cy = HIWORD(dw);
    rc.left = rc.top = 0; 

    SendMessage(m_hWndMyPicsToolBar, TB_GETIDEALSIZE, FALSE, (LPARAM)&sz);

    rc.right  = sz.cx; 
    rc.bottom = sz.cy;
    
    AdjustWindowRectEx(&rc, GetWindowLong(m_hWndHover, GWL_STYLE), FALSE, GetWindowLong(m_hWndHover, GWL_EXSTYLE));

    if (SetWindowPos(m_hWndHover, NULL, lLeft, lTop, rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER | SWP_SHOWWINDOW))
    {
        m_hoverState = HOVERSTATE_SHOWING;
    }

Cleanup:
    ATOMICRELEASE(pRect);
    ATOMICRELEASE(pEle2);

    TraceMsg(TF_MYPICS, "-CMyPics::ShowHover, this=%p, m_hoverState=%d", this, m_hoverState);

    return hr;
}


HRESULT CMyPics::HandleScroll() 
{
    TraceMsg(TF_MYPICS, "+CMyPics::HandleScroll, this=%p, m_hoverState=%d", this, m_hoverState);

    HRESULT hr = S_OK;

    switch(m_hoverState)
    {
        // I don't think we need to do anything in these cases.
        //
        case HOVERSTATE_HIDING:
        case HOVERSTATE_LOCKED:
        case HOVERSTATE_WAITINGTOSHOW:
            break;

        case HOVERSTATE_SHOWING:
            {
                IHTMLElement2 *pEle2=NULL;
                IHTMLRect     *pRect=NULL;
                RECT           rect;

                ASSERT(m_pEleCurr);
                ASSERT(m_Hwnd);
                ASSERT(m_hWndHover);  // Ensure we do have a window

                HideHover();
                ShowHover();                

                // Redraw client area to get rid of window droppings scrolling causes.
                // Try to redraw just the part where its likely to need it.
                if (FAILED(m_pEleCurr->QueryInterface(IID_IHTMLElement2, (void **)&pEle2)))
                {
                    goto CleanUp;
                }
                
                if (FAILED(pEle2->getBoundingClientRect(&pRect)))
                {
                    goto CleanUp;
                }
                
                pRect->get_left(&rect.left);
                pRect->get_right(&rect.right);
                pRect->get_top(&rect.top);
                pRect->get_bottom(&rect.bottom);

                rect.top -= 2*MP_MIN_CY; 
                if (rect.top < 0)
                    rect.top = 0;

                rect.left -= 2*MP_MIN_CX;
                if (rect.left <0)
                    rect.left = 0;
                
                rect.bottom *= 2; rect.right *= 2;

                RedrawWindow(m_Hwnd, &rect, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
CleanUp:
                SAFERELEASE(pRect);
                SAFERELEASE(pEle2);

            }
            break;
    }

    TraceMsg(TF_MYPICS, "-CMyPics::HandleScroll, this=%p, m_hoverState=%d", this, m_hoverState);

    return hr;
}

HRESULT CMyPics::HandleMouseover(IHTMLElement *pEle)
{
    HRESULT               hr = S_OK;
    IOleWindow           *pOleWindow;

    TraceMsg(TF_MYPICS, "+CMyPics::HandleMouseover");

    if (m_hoverState != HOVERSTATE_HIDING)
    {
        // Ensure we really have a hover window
        ASSERT(m_hWndHover);
        return (S_OK);
    }
    else
    {
        // No bar.  Release current element, if any.
        ATOMICRELEASE(m_pEleCurr);

        if (ShouldAppearOnThisElement(pEle))
        {
            m_pEleCurr = pEle;
            pEle->AddRef();

            // set m_Hwnd once...
            if (!m_Hwnd) 
            {
                // Get the Hwnd for the document...
                hr = m_pDoc2->QueryInterface(IID_IOleWindow,(void **)&pOleWindow);
                if (FAILED(hr))
                    return hr;

                pOleWindow->GetWindow(&m_Hwnd);
                pOleWindow->Release();
            }

            if (!m_hWndHover)
            {
                // We need a hover window now to conveniently set a timer.
                hr = CreateHover();  // review: do we need to pass member variables as params?
            }

            // We're all set up.  Set the state and start the timer.
            m_hoverState=HOVERSTATE_WAITINGTOSHOW;
            SetTimer(m_hWndMyPicsToolBar, IDT_MP_TIMER, MP_TIMER, s_TimerProc);
        }
    }

    TraceMsg(TF_MYPICS, "-CMyPics::HandleMouseover");

    return hr;
}


HRESULT CMyPics::HandleMouseout()
{
    TraceMsg(TF_MYPICS, "+CMyPics::HandleMouseout");

    switch(m_hoverState)
    {
    case HOVERSTATE_HIDING:
        // Nothing to do
        break;

    case HOVERSTATE_SHOWING:
        // Hide it
        HideHover();
        break;

    case HOVERSTATE_LOCKED:
        // Noop
        break;

    case HOVERSTATE_WAITINGTOSHOW:
        m_hoverState = HOVERSTATE_HIDING;
        KillTimer(m_hWndMyPicsToolBar, IDT_MP_TIMER);
        break;
    }

    TraceMsg(TF_MYPICS, "-CMyPics::HandleMouseout");

    return S_OK;
}

HRESULT CMyPics::HandleResize()
{
    HRESULT hr = S_OK;

    if (m_pEleCurr && (HOVERSTATE_SHOWING == m_hoverState))
    {
        HideHover();
        ShowHover();
    }

    return hr;
}

HRESULT CMyPics::HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) 
{
    TraceMsg(TF_MYPICS, "CMyPics::HandleEvent Event=%ws", EventsToSink[Event].pwszEventName);

    HRESULT       hr          = S_OK;
    BSTR          bstrTagName = NULL;
    IHTMLElement *pEleUse     = NULL;
    BOOL          fWasArea    = FALSE;
    
    // if this is an area tag we need to find the IMG tag that corresponds
    if (pEle && SUCCEEDED(pEle->get_tagName(&bstrTagName)))
    {
        // if its an area tag, we need to find the img tag associated with it...
        if (StrCmpNI(bstrTagName, TEXT("area"), 4)==0)
        {
            POINT ptEvent;

            if (FAILED(pEventObj->get_screenX(&ptEvent.x)) ||
                FAILED(pEventObj->get_screenY(&ptEvent.y)))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

            fWasArea = TRUE;
            pEleUse  = GetIMGFromArea(pEle, ptEvent);
        }
    }

    // has the user turned this off?
    if (m_bIsOffForSession)
        goto Cleanup;

    switch(Event) 
    {
        case EVENT_SCROLL:
            HandleScroll();
            break;

        case EVENT_MOUSEOVER:
            hr = HandleMouseover(fWasArea ? pEleUse : pEle);
            break;

        case EVENT_MOUSEOUT:
            hr = HandleMouseout();
            break;

        case EVENT_RESIZE:
            hr = HandleResize();
            break;

        default:
            //do nothing?
            break;
    }

Cleanup:
    if (pEleUse)
        ATOMICRELEASE(pEleUse);

    if (bstrTagName)
        SysFreeString(bstrTagName);

    return (hr);
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

// this is stolen from iforms.cpp:

//=========================================================================
//
// Event sinking class
//
//  We simply implement IDispatch and make a call into our parent when
//   we receive a sinked event.
//
//=========================================================================

CMyPics::CEventSink::CEventSink(CMyPicsEventSinkCallback *pParent)
{
    TraceMsg(TF_MYPICS, "CMyPics::CEventSink::CEventSink");
    DllAddRef();
    m_cRef = 1;
    m_pParent = pParent;
}

CMyPics::CEventSink::~CEventSink()
{
    TraceMsg(TF_MYPICS, "CMyPics::CEventSink::~CEventSink");
    ASSERT( m_cRef == 0 );
    DllRelease();
}

STDMETHODIMP CMyPics::CEventSink::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IDispatch == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IDispatch *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CMyPics::CEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMyPics::CEventSink::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CMyPics::CEventSink::SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CMyPicsEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}

HRESULT CMyPics::CEventSink::SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CMyPicsEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}


HRESULT CMyPics::CEventSink::UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CMyPicsEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

HRESULT CMyPics::CEventSink::UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CMyPicsEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

// IDispatch
STDMETHODIMP CMyPics::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMyPics::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMyPics::CEventSink::GetIDsOfNames(
                REFIID          riid,
                OLECHAR**       rgszNames,
                UINT            cNames,
                LCID            lcid,
                DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMyPics::CEventSink::Invoke(
            DISPID dispIdMember,
            REFIID, LCID,
            WORD wFlags,
            DISPPARAMS* pDispParams,
            VARIANT* pVarResult,
            EXCEPINFO*,
            UINT* puArgErr)
{
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) && pObj))
            {
                EVENTS Event=EVENT_BOGUS;
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                if (bstrEvent)
                {
                    for (int i=0; i<ARRAYSIZE(CMyPicsEventSinkCallback::EventsToSink); i++)
                    {
                        if (!StrCmpCW(bstrEvent, CMyPicsEventSinkCallback::EventsToSink[i].pwszEventName))
                        {
                            Event = (EVENTS) i;
                            break;
                        }
                    }

                    SysFreeString(bstrEvent);
                }

                if (Event != EVENT_BOGUS)
                {
                    IHTMLElement *pEle=NULL;

                    pObj->get_srcElement(&pEle);

                    // EVENT_SCROLL comes from our window so we won't have an
                    //  element for it
                    if (pEle || (Event == EVENT_SCROLL))
                    {
                        // Call the event handler here
                        m_pParent->HandleEvent(pEle, Event, pObj);

                        if (pEle)
                        {
                            pEle->Release();
                        }
                    }
                }

                pObj->Release();
            }
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////

// {9E56BE60-C50F-11CF-9A2C-00A0C90A90CE}
EXTERN_C const GUID MP_CLSID_MailRecipient = {0x9E56BE60L, 0xC50F, 0x11CF, 0x9A, 0x2C, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xCE};

HRESULT DropPicOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState)
{
    IDropTarget *pdrop;
    HRESULT hres = CoCreateInstance(MP_CLSID_MailRecipient,
        NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_PPV_ARG(IDropTarget, &pdrop));

    if (SUCCEEDED(hres))
    {
        hres = SHSimulateDrop(pdrop, pdtobj, grfKeyState, NULL, NULL);
        pdrop->Release();
    }
    return hres;
}


//
// This function cannot return Non -NULL pointers if
// it returns a FAILED(hr)
//

HRESULT CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(
    LPCITEMIDLIST pidl,
    IUnknown *pUnkSite,
    IUniformResourceLocator **ppUrlOut,
    IDataObject **ppdtobj
)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];
    TCHAR *szTemp = NULL;

    ASSERT(ppUrlOut);
    ASSERT(ppdtobj);
    *ppUrlOut = NULL;
    *ppdtobj = NULL;
    szUrl[0] = TEXT('\0');

    hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl, SIZECHARS(szUrl), NULL);

    if ((S_OK == hr) && (*szUrl))
    {

       BOOL fIsHTML = FALSE;
       BOOL fHitsNet = UrlHitsNetW(szUrl);

       if (!fHitsNet)
       {
            if (URL_SCHEME_FILE == GetUrlScheme(szUrl))
            {
                TCHAR *szExt = PathFindExtension(szUrl);
                if (szExt)
                {
                    fIsHTML = ((0 == StrCmpNI(szExt, TEXT(".htm"),4)) ||
                              (0 == StrCmpNI(szExt, TEXT(".html"),5)));
                }
            }
       }

       if (fHitsNet || fIsHTML)
       {
            // Create a shortcut object and
            HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                            IID_PPV_ARG(IUniformResourceLocator, ppUrlOut));
            if (SUCCEEDED(hr))
            {

                hr = (*ppUrlOut)->SetURL(szUrl, 0);
                if (S_OK == hr)
                {

                    // Get the IDataObject and send that back for the Drag Drop
                    hr = (*ppUrlOut)->QueryInterface(IID_PPV_ARG(IDataObject, ppdtobj));
                    if (SUCCEEDED(hr))
                    {
                        IUnknown_SetSite(*ppUrlOut, pUnkSite); // Only set the site if we're sure of
                                                          // returning SUCCESS
                    }
                }
           }
       }
       else
       {
            hr = E_FAIL;
       }
    }

    if (FAILED(hr))
    {
        SAFERELEASE(*ppUrlOut);
        SAFERELEASE(*ppdtobj);
    }
    return hr;
}

HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite)
{
    IDataObject *pdtobj = NULL;
    IUniformResourceLocator *purl = NULL;
    HRESULT hr = CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(pidl, pUnkSite, &purl, &pdtobj);
    if (FAILED(hr))
    {
        ASSERT(NULL == pdtobj);
        ASSERT(NULL == purl);
        hr = GetDataObjectForPidl(pidl, &pdtobj);
    }

    if (SUCCEEDED(hr))
    {
        IQueryCodePage * pQcp;
        if (SUCCEEDED(pdtobj->QueryInterface(IID_PPV_ARG(IQueryCodePage, &pQcp))))
        {
            pQcp->SetCodePage(uiCodePage);
            pQcp->Release();
        }
        hr = DropPicOnMailRecipient(pdtobj, grfKeyState);
        pdtobj->Release();
    }

    if (purl)
    {
        IUnknown_SetSite(purl, NULL);
        purl->Release();
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////

#undef TF_MYPICS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\nscband.cpp ===
/**************************************************************\
    FILE: NSCBand.cpp

    DESCRIPTION:  implementation of CNSCBand.  the class CNSCBand 
        exists to support name space control bands.  A name 
        space control uses IShellFolder rooted in various 
        namespaces including Favorites, history, Shell Name 
        Space, etc. to depict a hierarchical UI 
        representation of the given name space.  
    
    AUTHOR:  chrisny

\**************************************************************/
#include "priv.h"
#include "sccls.h"
#include "util.h"
#include "resource.h"
#include "dhuihand.h"
#include "nscband.h"
#include <varutil.h>
#include <mluisupp.h>

HRESULT CNSCBand::_Init(LPCITEMIDLIST pidl)
{
    // further initialization happens in ShowDW
    _fInited = FALSE;
    _fVisible = FALSE;
    _fCanFocus = TRUE;
    _haccTree = LoadAccelerators(MLGetHinst(), MAKEINTRESOURCE(ACCEL_FAVBAR));

    // pidl can be real or a CSIDL_ constant
    if (HIWORD(pidl))
        _pidl = ILClone(pidl);
    else
        SHGetSpecialFolderLocation(NULL, LOWORD(pidl), &_pidl);

    return _pidl ? S_OK : E_FAIL;
}

CNSCBand::~CNSCBand()
{
    if (_pidl)
        ILFree(_pidl);
    ATOMICRELEASE(_pns);
    ATOMICRELEASE(_pweh);

    if (_himlNormal)
        ImageList_Destroy(_himlNormal);
    if (_himlHot)  
        ImageList_Destroy(_himlHot);
}

HRESULT CNSCBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CNSCBand, IContextMenu),       // IID_IContextMenu
        QITABENT(CNSCBand, IWinEventHandler),   // IID_IWinEventHandler
        QITABENT(CNSCBand, IBandNavigate),      // IID_IBandNavigate
        QITABENT(CNSCBand, INamespaceProxy),          // IID_INamespaceProxy
        { 0 },
    };
    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);
    return hres;
}

#ifndef ENABLE_CCHANNELBAND
HRESULT CNSCBand_CreateInstanceEx(IUnknown *punkOuter, IUnknown **ppunk, 
                                  LPCOBJECTINFO poi, LPCITEMIDLIST pidl)
{
    // aggregation checking is handled in class factory
    HRESULT hres;
    CNSCBand * p = new CNSCBand();
    if (p)
    {
        hres = p->_Init(pidl);
        if (SUCCEEDED(hres))
        {
            p->_pns = CNscTree_CreateInstance();
            if (p->_pns)
            {
                p->_poi = poi;   
                // if you change this cast, fix up CChannelBand_CreateInstance
                *ppunk = SAFECAST(p, IDeskBand *);

                IUnknown_SetSite(p->_pns, *ppunk);
                hres = S_OK;
            }
        }
        p->Release();
    }
    else
        hres = E_OUTOFMEMORY;
    return hres;
}
#endif

#ifdef ENABLE_CHANNELS

extern LPITEMIDLIST Channel_GetFolderPidl();

HRESULT CChannelBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
#ifndef ENABLE_CCHANNELBAND
    ASSERT(FALSE);
    return E_FAIL;
#else
    HRESULT hres = CNSCBand_CreateInstanceEx(punkOuter, ppunk, poi, Channel_GetFolderPidl());
    if (*ppunk) {
        CNSCBand* p = (CNSCBand*)(IDeskBand*)*ppunk;
        p->_SetNscMode(MODE_CHANNELS);
    }
    return hres;
#endif
}

#endif  // ENABLE_CHANNELS

extern HRESULT GetHistoryPIDL(LPITEMIDLIST *ppidlHistory);


HRESULT CNSCBand::CloseDW(DWORD dw)
{
    if (_fVisible) 
    {
        _UnregisterBand();
    }

    if (_pns)
    {
        IUnknown_SetSite(_pns, NULL); // Break the ref-count cycle.
    }

    return CToolBand::CloseDW(dw);
}

void CNSCBand::_UnregisterBand()
{
    IBrowserService *pswProxy;
    QueryService(SID_SProxyBrowser, IID_IBrowserService, (LPVOID*)&pswProxy);
    ASSERT(pswProxy);
    if (pswProxy)
    {
        IOleCommandTarget *poctProxy;

        if (SUCCEEDED(pswProxy->QueryInterface(IID_IOleCommandTarget, (void **)&poctProxy)))
        {
            VARIANT var;
            VariantInit(&var);
                
            //  Register ourselves for SBCMDID_SELECTHISTPIDL,SBCMDID_INITFILECTXMENU
            var.vt = VT_UNKNOWN;
            QueryInterface(IID_IUnknown, (void **)&var.punkVal);
            poctProxy->Exec(&CGID_Explorer, SBCMDID_UNREGISTERNSCBAND,  OLECMDEXECOPT_PROMPTUSER, &var, NULL);
            VariantClear(&var);
            poctProxy->Release();
        }
        pswProxy->Release();
    }
}

HRESULT CNSCBand::_InitializeNsc()
{
    return _pns->Initialize(_pidl, _GetEnumFlags(), NSS_DROPTARGET | NSS_BROWSERSELECT);
}

HRESULT CNSCBand::ShowDW(BOOL fShow)
{
    BOOL fIsHistory = IsEqualCLSID(*_poi->pclsid, CLSID_HistBand);
    if (fShow && _hwnd && !_fVisible)
    {
        IBrowserService *pswProxy;

        QueryService(SID_SProxyBrowser, IID_PPV_ARG(IBrowserService, &pswProxy));
        ASSERT(pswProxy);
        if (!_fInited)
        {
            _InitializeNsc();
        }
        else
        {
            _pns->ShowWindow(TRUE);
        }

        if (pswProxy)
        {
            IOleCommandTarget *poctProxy;

            if (SUCCEEDED(pswProxy->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poctProxy))))
            {
                VARIANT var;
                VariantInit(&var);
                
                //  Register ourselves for SBCMDID_SELECTHISTPIDL,SBCMDID_INITFILECTXMENU
                var.vt = VT_UNKNOWN;
                QueryInterface(IID_PPV_ARG(IUnknown, &var.punkVal));

                poctProxy->Exec(&CGID_Explorer, SBCMDID_REGISTERNSCBAND, OLECMDEXECOPT_PROMPTUSER, &var, NULL);

                //clear the variant cheaply
                var.vt = VT_EMPTY;
                Release();

                // do any special registration if necessary
                _OnRegisterBand(poctProxy);
                
                poctProxy->Release();
            }
            pswProxy->Release();
        }
       _fInited = TRUE;
       _fVisible = TRUE;
    }
    else if (!fShow && _fVisible)
    {
        _pns->ShowWindow(FALSE);
        _UnregisterBand();
        _fVisible = FALSE;
    }

    return CToolBand::ShowDW(fShow);
}

HRESULT CNSCBand::GetWindow(HWND *phwnd)
{
    INSCTree2 *pns2;
    HRESULT hr = _pns->QueryInterface(IID_PPV_ARG(INSCTree2, &pns2));
    if (SUCCEEDED(hr))
    {
        pns2->CreateTree2(_hwndParent, _GetTVStyle(), _GetTVExStyle(), &_hwnd);
        hr = CToolBand::GetWindow(phwnd);
        pns2->Release();
    }

    return hr;
}

DWORD CNSCBand::_GetTVStyle()
{ 
    DWORD dwFlags = TVS_FULLROWSELECT | TVS_TRACKSELECT | TVS_INFOTIP;
    DWORD dwValue;
    DWORD dwSize = SIZEOF(dwValue);
    BOOL  fDefault = TRUE;

    SHRegGetUSValue(L"Software\\Microsoft\\Internet Explorer\\Main",
                    L"NscSingleExpand", NULL, (LPBYTE)&dwValue, &dwSize, FALSE,
                    (void *) &fDefault, SIZEOF(fDefault));

    if (dwValue)
        dwFlags |= TVS_SINGLEEXPAND;

    return dwFlags; 
}

HRESULT CNSCBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;
    pdbi->dwModeFlags = DBIMF_FIXEDBMP | DBIMF_VARIABLEHEIGHT;
    
    pdbi->ptMinSize.x = 16;
    pdbi->ptMinSize.y = 0;
    pdbi->ptMaxSize.x = 32000; // random
    pdbi->ptMaxSize.y = 32000; // random
    pdbi->ptActual.y = -1;
    pdbi->ptActual.x = -1;
    pdbi->ptIntegral.y = 1;

    if (_szTitle[0]) 
    {
        StrCpyNW(pdbi->wszTitle, _szTitle, ARRAYSIZE(pdbi->wszTitle));
    } 
    else 
    {
        CLSID clsid;
        UINT  ids;
        GetClassID(&clsid);
        if (IsEqualIID(clsid, CLSID_FavBand))
            ids = IDS_BAND_FAVORITES;
        else if (IsEqualIID(clsid, CLSID_HistBand)) 
            ids = IDS_BAND_HISTORY;
        else if (IsEqualIID(clsid, CLSID_ExplorerBand))
            ids = IDS_BAND_EXPLORER;
        else 
        {
            ASSERT(FALSE);      // BOGUS BAND!!!
            return S_FALSE;
        }
        MLLoadStringW(ids, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    }
    return S_OK;
} 

void _InitColors(BOOL fReinit);


// *** IWinEventHandler methods ***

HRESULT CNSCBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hr = E_FAIL;

    if (!_pweh && _pns)
        _pns->QueryInterface(IID_IWinEventHandler, (void **) &_pweh);

    // We need to tell the bandsite that we have become active if we're getting a 
    // click focus or something
    if (uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->code == NM_SETFOCUS)
    {
        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
    }


    if (_pweh)
        hr = _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return hr;
}

HRESULT CNSCBand::IsWindowOwner(HWND hwnd)
{
    HRESULT hres;

    hres = SHIsChildOrSelf(_hwnd, hwnd);
    ASSERT(hwnd != NULL || hres == S_FALSE);
    ASSERT(_hwnd != NULL || hres == S_FALSE);
    return hres;
}

//***   CNSCBand::IPersistStream::* {

HRESULT CNSCBand::GetClassID(CLSID *pClassID)
{
    ASSERT(_poi->pclsid != NULL);
    *pClassID = *(_poi->pclsid);
    return S_OK;
}

HRESULT CNSCBand::Load(IStream *pstm)
{
    return S_OK;
}

HRESULT CNSCBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

// }

//***   CNSCBand::IContextMenu::* {

HRESULT CNSCBand::QueryContextMenu(HMENU hmenu,
    UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    int i = 0;
#if 0
    HMENU hmenuMe = LoadMenuPopup(MENU_IWBBAND);

    i += Shell_MergeMenus(hmenu, hmenuMe, indexMenu, idCmdFirst + i, idCmdLast, MM_ADDSEPARATOR) - (idCmdFirst + i);
    DestroyMenu(hmenuMe);
#endif

    // aka (S_OK|i)
    return MAKE_HRESULT(ERROR_SUCCESS, FACILITY_NULL, i);
}

HRESULT CNSCBand::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
#if 0
    int idCmd = -1;

    if (!HIWORD(pici->lpVerb))
        idCmd = LOWORD(pici->lpVerb);
    switch (idCmd) 
    {
        case default:
            TraceMsg(DM_ERROR, "cbb::ic cmd=%d not handled", idCmd);
            break;
    }
#endif
    return S_OK;
}

HRESULT CNSCBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        for (UINT i=0; i < cCmds; i++)
        {
            rgCmds[i].cmdf = 0;
            switch (rgCmds[i].cmdID)
            {
                case SBCMDID_INITFILECTXMENU:
                    if (_hwnd && _fVisible)
                    {
                        rgCmds->cmdf = 0;
                        if (pcmdtext) 
                            pcmdtext->cmdtextf = 0;

                        if (pcmdtext)
                        {
                            if (SUCCEEDED(_pns->GetSelectedItemName(pcmdtext->rgwz, pcmdtext->cwBuf)))
                            {
                                rgCmds->cmdf = OLECMDF_ENABLED;
                                pcmdtext->cmdtextf = OLECMDTEXTF_NAME;
                                pcmdtext->cwActual = lstrlenW(pcmdtext->rgwz) + 1;
                            }
                        }
                    }
                    break;

                case SBCMDID_FILERENAME:
                case SBCMDID_FILEDELETE:
                case SBCMDID_FILEPROPERTIES:
                {
                    LPITEMIDLIST  pidl;

                    // get selected item can return NULL pidl and S_FALSE
                    if (_pns->GetSelectedItem(&pidl, 0) == S_OK)
                    {
                        DWORD rgfAttrib = SFGAO_CANDELETE | SFGAO_CANRENAME | SFGAO_HASPROPSHEET; // CAN_LINK
                        if (SUCCEEDED(IEGetAttributesOf(pidl, &rgfAttrib)))
                        {
                            DWORD nCmdID;
        
                            static const DWORD tbtab[] = {
                                    SBCMDID_FILEDELETE, SBCMDID_FILEPROPERTIES, SBCMDID_FILERENAME };
                            static const DWORD cttab[] = {
                                    SFGAO_CANDELETE,    SFGAO_HASPROPSHEET,     SFGAO_CANRENAME };

                            nCmdID = SHSearchMapInt((int*)tbtab, (int*)cttab, ARRAYSIZE(tbtab), rgCmds[i].cmdID);

                            if (nCmdID != -1 && (rgfAttrib & nCmdID))
                                rgCmds[i].cmdf = OLECMDF_ENABLED;
                        }
                        ILFree(pidl);
                    }
                    break;
                }
                    
                default:
                    break;
            }
        }

        return S_OK;
    }
    return CToolBand::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CNSCBand::_InvokeCommandOnItem(LPCTSTR pszVerb)
{
    HRESULT hr;
    IContextMenu *pcm;
    
    hr = _QueryContextMenuSelection(&pcm);
    if (SUCCEEDED(hr))
    {
        CMINVOKECOMMANDINFOEX ici = 
        {
            SIZEOF(CMINVOKECOMMANDINFOEX),
            0L,
            _hwnd,
            NULL,
            NULL, NULL,
            SW_NORMAL,
        };
        
#ifdef UNICODE
        CHAR szVerbAnsi[MAX_PATH];
        SHUnicodeToAnsi(pszVerb, szVerbAnsi, ARRAYSIZE(szVerbAnsi));
        ici.lpVerb = szVerbAnsi;
        ici.lpVerbW = pszVerb;
        ici.fMask |= CMIC_MASK_UNICODE;
#else
        ici.lpVerb = pszVerb;
#endif
        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
        pcm->Release();
    }
    
    return hr;
}

HRESULT CNSCBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        switch (nCmdID)
        {
        case OLECMDID_REFRESH:
            if (_pns)
                _pns->Refresh();
            return S_OK;
        }

    }
    else if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        HRESULT hr = S_OK;
        
        switch (nCmdID)
        {
        case SBCMDID_SELECTHISTPIDL:
            if (IsEqualCLSID(*_poi->pclsid, CLSID_HistBand) && _hwnd && _fVisible)
            {
                // If you're not visible do nothing.  On becoming visible
                // use Exec to proxy to get last pidlSelect that you would
                // have shown, had you been visible
                LPITEMIDLIST pidlSelect = VariantToIDList(pvarargIn);
                if (pidlSelect)
                {
                    _pns->SetSelectedItem(pidlSelect, TRUE, FALSE, 0);
                    ILFree(pidlSelect);
                }
            }
            break;

        case SBCMDID_INITFILECTXMENU:
            if (_hwnd && _fVisible)
            {
                if (pvarargOut)
                {
                    VariantClearLazy(pvarargOut);

                    HRESULT hres = _QueryContextMenuSelection((IContextMenu **)&(pvarargOut->punkVal));
                    if (SUCCEEDED(hres))
                    {
                        pvarargOut->vt = VT_UNKNOWN;
                    }
                }
            }
            break;

        case SBCMDID_FILERENAME:
        {
            IShellNameSpace *psfns;
            hr = _pns->QueryInterface(IID_PPV_ARG(IShellNameSpace, &psfns));
            if (SUCCEEDED(hr))
            {
                hr = psfns->InvokeContextMenuCommand(L"rename");
                psfns->Release();
            }
            break;
        }
            
        case SBCMDID_FILEDELETE:
            hr = _InvokeCommandOnItem(TEXT("delete"));
            break;
            
        case SBCMDID_FILEPROPERTIES:
            hr = _InvokeCommandOnItem(TEXT("properties"));
            break;

        default:
            hr = E_FAIL;
            break;
        }
        if (SUCCEEDED(hr))
            return hr;
    }

    return CToolBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}


HRESULT CNSCBand::_QueryContextMenuSelection(IContextMenu ** ppcm)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlSelected;

    *ppcm = NULL;
    hr = _pns->GetSelectedItem(&pidlSelected, 0);
    if (SUCCEEDED(hr))
    {
        LPCITEMIDLIST pidlRelative;
        IShellFolder * psf;

        hr = IEBindToParentFolder(pidlSelected, &psf, &pidlRelative);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(NULL, 1, &pidlRelative, IID_PPV_ARG_NULL(IContextMenu, ppcm));
        }
        ILFree(pidlSelected);
    }
    
    return hr;
}


HRESULT CNSCBand::Select(LPCITEMIDLIST pidl)
{
    _pns->SetSelectedItem(pidl, TRUE, FALSE, 0);
    return S_OK;
}


// *** IInputObject Methods ***
HRESULT CNSCBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    HWND hwndFocus = GetFocus();
    if (_pns->InLabelEdit())
        return EditBox_TranslateAcceleratorST(lpMsg);
    else if ( lpMsg && lpMsg->hwnd && SendMessage(lpMsg->hwnd, TVM_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;
    else if (hwndFocus == _hwnd && TranslateAcceleratorWrap(_hwnd, _haccTree, lpMsg))
        return S_OK;

    return S_FALSE;
}


void CNSCBand::_EnsureImageListsLoaded()
{
    if (_himlNormal == NULL)
        _himlNormal = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_HISTORYANDFAVBANDSDEF), 18, 3, RGB(255, 0, 255), IMAGE_BITMAP, LR_CREATEDIBSECTION);

    if (_himlHot == NULL)
        _himlHot = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_HISTORYANDFAVBANDSHOT), 18, 3, RGB(255, 0, 255), IMAGE_BITMAP, LR_CREATEDIBSECTION);
}

HRESULT CNSCBand::_TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib)
{
    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        hr = SHGetNavigateTarget(psf, pidlLast, ppidlTarget, pulAttrib);
        psf->Release();
    }

    return hr;
}

// favorites, history and Explorer band should override this (they need not worry about channel band)
BOOL CNSCBand::_ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib)
{
    BOOL bReturn = (ulAttrib & SFGAO_FOLDER);
    if (bReturn)
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlLast;
        HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            bReturn = IsExpandableChannelFolder(psf, pidlLast);
            psf->Release();
        }
    }

    return !bReturn;
}

HRESULT CNSCBand::GetNavigateTarget(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib)
{
    HRESULT hr = _TranslatePidl(pidl, ppidlTarget, pulAttrib);
    if (SUCCEEDED(hr))
    {
        hr = _ShouldNavigateToPidl(pidl, *pulAttrib) ? S_OK : S_FALSE;
        if (hr == S_FALSE)
        {
            ILFree(*ppidlTarget);
            *ppidlTarget = NULL;
        }
    }
            
    return hr;
}

HRESULT CNSCBand::OnSelectionChanged(LPCITEMIDLIST pidl)
{
    return S_OK;
}

HRESULT CNSCBand::Invoke(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl)
    {
        IShellBrowser *psb;
        hr = IUnknown_QueryService(_punkSite, SID_SProxyBrowser, IID_PPV_ARG(IShellBrowser, &psb));
        if (SUCCEEDED(hr))
        {
            hr = _NavigateRightPane(psb, pidl);
            if (FAILED(hr))
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlChild;
                if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
                {
                    DWORD dwAttributes = SFGAO_FOLDER;
                    psf->GetAttributesOf(1, &pidlChild, &dwAttributes);
                    if (!(dwAttributes & SFGAO_FOLDER))
                    {
                        hr = SHInvokeDefaultCommand(_hwnd, psf, pidlChild);
                    }
                    psf->Release();
                }
            }
            psb->Release();
        }
    }
    return hr;
}

HRESULT CNSCBand::_NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl)
{
    HRESULT hr = psb->BrowseObject(pidl, SBSP_SAMEBROWSER);
    if (SUCCEEDED(hr))
        UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVOTHER);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\nsctask.h ===
#ifndef CIconTask_h
#define CIconTask_h
#include <runtask.h>

#ifdef DEBUG
void DumpOrderList(IShellFolder *psf, HDPA hdpa);
#endif

typedef void (*PFNNSCICONTASKBALLBACK)(CNscTree *pns, UINT_PTR uId, int iIcon, int iOpenIcon, DWORD dwFlags, UINT uSynchId);
HRESULT AddNscIconTask(IShellTaskScheduler* pts, LPITEMIDLIST pidl, PFNNSCICONTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId);

typedef void (*PFNNSCOVERLAYTASKBALLBACK)(CNscTree *pns, UINT_PTR uId, int iOverlayIndex, UINT uSynchId);
HRESULT AddNscOverlayTask(IShellTaskScheduler* pts, LPITEMIDLIST pidl, PFNNSCOVERLAYTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId);


typedef void (*PFNNSCENUMTASKBALLBACK)(CNscTree *pns, LPITEMIDLIST pidl, UINT_PTR uId, DWORD dwSig, HDPA hdpa, 
                                       LPITEMIDLIST pidlExpandingTo, DWORD dwOrderSig, UINT uDepth, 
                                       BOOL fUpdate, BOOL fUpdatePidls);

HRESULT AddNscEnumTask(IShellTaskScheduler* pts, LPCITEMIDLIST pidl,
                       PFNNSCENUMTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId,
                       DWORD dwSig, DWORD grfFlags, HDPA hdpaOrder, LPCITEMIDLIST pidlExpandingTo, 
                       DWORD dwOrderSig, BOOL fForceExpand, UINT uDepth, 
                       BOOL fUpdate, BOOL fUpdatePidls);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\occtrl.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: olecontrol.cpp
//
// History:
//         7-31-96  by dli
//------------------------------------------------------------------------

#include "priv.h"

class COleControlHost;

//---------------------------------------------------------------------------
// Event sink
class CEventSink : public IDispatch
//---------------------------------------------------------------------------
{
public:
    CEventSink( BOOL bAutoDelete = FALSE ) ;

    //  Connect/disconnect
    BOOL  Connect( HWND hwndOwner, HWND hwndSite, LPUNKNOWN punkOC ) ;
    BOOL  Disconnect() ;

//  IUnknown methods
    STDMETHOD (QueryInterface)( REFIID riid, void** ppvObj ) ;
    STDMETHOD_(ULONG, AddRef)() ;
    STDMETHOD_(ULONG, Release)() ;

//  IDispatch methods
    STDMETHOD (GetTypeInfoCount)( UINT *pctinfo )
        { return E_NOTIMPL ; }

    STDMETHOD (GetTypeInfo)( UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo )
        { return E_NOTIMPL ; }

    STDMETHOD (GetIDsOfNames)( REFIID riid, LPOLESTR *rgszNames, UINT cNames,
                                LCID lcid, DISPID *rgDispId )
        { return E_NOTIMPL ; }

    STDMETHOD (Invoke)( 
        IN DISPID dispIdMember,
        IN REFIID riid,
        IN LCID lcid,
        IN WORD wFlags,
        IN OUT DISPPARAMS *pDispParams,
        OUT VARIANT *pVarResult,
        OUT EXCEPINFO *pExcepInfo,
        OUT UINT *puArgErr) ;

private:
    static HRESULT _GetDefaultEventIID( LPUNKNOWN punkOC, IID* piid ) ;
    BOOL           _Connect( HWND hwndOwner, HWND hwndSite, LPUNKNOWN punkOC, REFIID iid ) ;
    BOOL           _IsConnected( REFIID iid ) ;

    ULONG       _dwCookie ;   // connection cookie
    IID         _iid ;        // connection interface
    IID         _iidDefault ; // OC's default event dispatch interface
    LPUNKNOWN   _punkOC ;     // OC's unknown
    LONG        _cRef ;       // ref count
    HWND        _hwndSite,    // 
                _hwndOwner ;
    BOOL        _bAutoDelete ;
} ;

class CProxyUIHandler : 
    public IDocHostUIHandler2
{
public:
    
    // *** IUnknown methods *** 
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IDocHostUIHandler methods *** 
    virtual STDMETHODIMP ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    virtual STDMETHODIMP GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual STDMETHODIMP ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
    virtual STDMETHODIMP HideUI();
    virtual STDMETHODIMP UpdateUI();
    virtual STDMETHODIMP EnableModeless(BOOL fActivate);
    virtual STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
    virtual STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
    virtual STDMETHODIMP ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual STDMETHODIMP TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual STDMETHODIMP GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw);
    virtual STDMETHODIMP GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual STDMETHODIMP GetExternal(IDispatch **ppDispatch);
    virtual STDMETHODIMP TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual STDMETHODIMP FilterDataObject( IDataObject *pDO, IDataObject **ppDORet);

    // *** IDocHostUIHandler2 methods ***
    virtual STDMETHODIMP GetOverrideKeyPath( LPOLESTR *pchKey, DWORD dw);
};

//---------------------------------------------------------------------------
//  Ole control container object
class COleControlHost : 
        public IOleClientSite,
        public IAdviseSink,
        public IOleInPlaceSite,
        public IOleInPlaceFrame,
        public IServiceProvider,
        public IOleCommandTarget,
        public IDispatch            // For ambient properties
{
friend CProxyUIHandler;

protected:
    static LRESULT CALLBACK OCHostWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT _Draw(HDC hdc);
    HRESULT _PersistInit();
    HRESULT _Init();
    HRESULT _Activate();
    HRESULT _Deactivate();
    HRESULT _DoVerb(long iVerb, LPMSG lpMsg);
    HRESULT _Exit();
    HRESULT _InitOCStruct(LPOCHINITSTRUCT lpocs);
    LRESULT _OnPaint();
    LRESULT _OnSize(HWND hwnd, LPARAM lParam);
    LRESULT _OnCreate(HWND hwnd, LPCREATESTRUCT);
    LRESULT _OnDestroy();
    LRESULT _OnQueryInterface(WPARAM wParam, LPARAM lParam);
    LRESULT _SetOwner(IUnknown * punkOwner);
    LRESULT _ConnectEvents( LPUNKNOWN punkOC, BOOL bConnect ) ;
    LRESULT _SetServiceProvider(IServiceProvider* pSP);
    LRESULT _SendNotify(UINT code, LPNMHDR pnmhdr);
    
    // IUnknown 
    UINT _cRef;
    
    DWORD _dwAspect;
    DWORD _dwMiscStatus;    // OLE misc status 
    DWORD _dwConnection;    // Token for Advisory connections
   
    BOOL _bInPlaceActive;   // Flag indicating if the OC is in place active
        
    HWND _hwnd;
    HWND _hwndParent;
    CLSID _clsidOC;
   
    IUnknown *_punkOC;
    IViewObject *_pIViewObject; 
    IOleObject *_pIOleObject;
    IOleInPlaceObject *_pIOleIPObject;

    IUnknown *_punkOwner;
    CEventSink  _eventSink ;
    CProxyUIHandler     _xuih;
    IDocHostUIHandler  *_pIDocHostUIParent;
    IDocHostUIHandler2 *_pIDocHostUIParent2;

    IDispatch *_pdispSiteDelegate;

public:
    COleControlHost(HWND hwnd);

    static void _RegisterClass();

    // *** IUnknown methods *** 
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);    
    
    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);
    
    // *** IOleClientSite methods *** 
    STDMETHOD (SaveObject)();
    STDMETHOD (GetMoniker)(DWORD, DWORD, LPMONIKER *);
    STDMETHOD (GetContainer)(LPOLECONTAINER *);
    STDMETHOD (ShowObject)();
    STDMETHOD (OnShowWindow)(BOOL);
    STDMETHOD (RequestNewObjectLayout)();
    
    // *** IAdviseSink methods *** 
    STDMETHOD_(void,OnDataChange)(FORMATETC *, STGMEDIUM *);
    STDMETHOD_(void,OnViewChange)(DWORD, LONG);
    STDMETHOD_(void,OnRename)(LPMONIKER);
    STDMETHOD_(void,OnSave)();
    STDMETHOD_(void,OnClose)();
    
    // *** IOleWindow Methods ***
    STDMETHOD (GetWindow) (HWND * phwnd);
    STDMETHOD (ContextSensitiveHelp) (BOOL fEnterMode);
    
    // *** IOleInPlaceSite Methods *** 
    STDMETHOD (CanInPlaceActivate) (void);
    STDMETHOD (OnInPlaceActivate) (void);
    STDMETHOD (OnUIActivate) (void);
    STDMETHOD (GetWindowContext) (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD (Scroll) (SIZE scrollExtent);
    STDMETHOD (OnUIDeactivate) (BOOL fUndoable);
    STDMETHOD (OnInPlaceDeactivate) (void);
    STDMETHOD (DiscardUndoState) (void);
    STDMETHOD (DeactivateAndUndo) (void);
    STDMETHOD (OnPosRectChange) (LPCRECT lprcPosRect); 

    // IOleInPlaceUIWindow methods.
    STDMETHOD (GetBorder)(LPRECT lprectBorder);
    STDMETHOD (RequestBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
    STDMETHOD (SetBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
    STDMETHOD (SetActiveObject)(IOleInPlaceActiveObject * pActiveObject,
                                LPCOLESTR lpszObjName);

    // IOleInPlaceFrame methods
    STDMETHOD (InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD (SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD (RemoveMenus)(HMENU hmenuShared);
    STDMETHOD (SetStatusText)(LPCOLESTR pszStatusText);
    STDMETHOD (EnableModeless)(BOOL fEnable);
    STDMETHOD (TranslateAccelerator)(LPMSG lpmsg, WORD wID);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguid, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguid, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IDispatch (for ambient properties)
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
        LCID lcid, DISPID *rgDispId);
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pvarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr);
};

HRESULT COleControlHost::GetTypeInfoCount(UINT* pctinfo)
{
    if (_pdispSiteDelegate)
    {
        return _pdispSiteDelegate->GetTypeInfoCount(pctinfo);
    }

    return E_NOTIMPL;
}

HRESULT COleControlHost::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo)
{
    if (_pdispSiteDelegate)
    {
        return _pdispSiteDelegate->GetTypeInfo(iTInfo, lcid, ppTInfo);
    }

    return E_NOTIMPL;
}

HRESULT COleControlHost::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
        LCID lcid, DISPID *rgDispId)
{
    if (_pdispSiteDelegate)
    {
        return _pdispSiteDelegate->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }

    return E_NOTIMPL;
}

HRESULT COleControlHost::Invoke(DISPID dispIdMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pvarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    if (_pdispSiteDelegate)
    {
        return _pdispSiteDelegate->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pvarResult, pExcepInfo, puArgErr);
    }

    return DISP_E_MEMBERNOTFOUND;
}

HRESULT COleControlHost::_Draw(HDC hdc)
{
    HRESULT hr = E_FAIL;
        
    if (_hwnd && _punkOC && !_bInPlaceActive)
    {
        RECT rc;
        GetClientRect(_hwnd, &rc);
        hr = OleDraw(_punkOC, _dwAspect, hdc, &rc);
    }
    return(hr);
}

HRESULT COleControlHost::_PersistInit()
{
    IPersistStreamInit * pIPersistStreamInit;

    if (_SendNotify(OCN_PERSISTINIT, NULL) == OCNPERSISTINIT_HANDLED)
        return S_FALSE;
    
    HRESULT hr = _punkOC->QueryInterface(IID_IPersistStreamInit, (void **)&pIPersistStreamInit);
    if (SUCCEEDED(hr))
    {
        hr = pIPersistStreamInit->InitNew();
        pIPersistStreamInit->Release();
    }
    else    
    {
        IPersistStorage * pIPersistStorage;
        hr = _punkOC->QueryInterface(IID_IPersistStorage, (void **)&pIPersistStorage);
        if (SUCCEEDED(hr))
        {
            // Create a zero sized ILockBytes.
            ILockBytes *pILockBytes;
            hr = CreateILockBytesOnHGlobal(NULL, TRUE, &pILockBytes);
            if (SUCCEEDED(hr)) {
                // Use the ILockBytes to create a storage.
                IStorage    *pIStorage;
                hr = StgCreateDocfileOnILockBytes(pILockBytes,
                                                  STGM_CREATE |
                                                  STGM_READWRITE |
                                                  STGM_SHARE_EXCLUSIVE,
                                                  0, &pIStorage);
                if (SUCCEEDED(hr)) {
                    // Call InitNew to initialize the object.
                    hr = pIPersistStorage->InitNew(pIStorage);
                    // Clean up
                    pIStorage->Release();
                } // IStorage
                pILockBytes->Release();
            } // ILockBytes
            pIPersistStorage->Release();
        }   
    }
    return hr;
}

HRESULT COleControlHost::_Init()
{
    HRESULT hr = E_FAIL;

    OCNCOCREATEMSG ocm = {0};
    ocm.clsidOC = _clsidOC;
    ocm.ppunk = &_punkOC;
    if(_SendNotify(OCN_COCREATEINSTANCE, &ocm.nmhdr) != OCNCOCREATE_HANDLED)
    {
        hr = CoCreateInstance(_clsidOC, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                                  IID_IUnknown, (LPVOID *)&_punkOC);
        if (FAILED(hr))
        {
            TraceMsg(TF_OCCONTROL, "_Init: Unable to CoCreateInstance this Class ID -- hr = %lX -- hr = %lX", _clsidOC, hr);
            return hr;
        }
        
    }
    
    ASSERT(_punkOC != NULL);
        
    if (_punkOC == NULL)
        return E_FAIL;
    
    hr = _punkOC->QueryInterface(IID_IOleObject, (void **)&_pIOleObject);    
    if (FAILED(hr))
    {
        TraceMsg(TF_OCCONTROL, "_Init: Unable to QueryInterface IOleObject -- hr = %s", hr);
        return hr;
    }

    hr = _pIOleObject->GetMiscStatus(_dwAspect, &_dwMiscStatus);

    // Set the inplace active flag here
    // If this fails, we will assume that we can setclientsite later

    if (_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
    {   
        hr = _pIOleObject->SetClientSite(this);
        _PersistInit();
    }
    else
    {
        _PersistInit();
        hr = _pIOleObject->SetClientSite(this);
    }
    
    if (FAILED(hr))
    {
        TraceMsg(TF_OCCONTROL, "_Init: Unable to set client site -- hr = %lX", hr);
        return hr;
    }
    
    
    if (SUCCEEDED(_punkOC->QueryInterface(IID_IViewObject, (void **)&_pIViewObject)))
    {    
        _pIViewObject->SetAdvise(_dwAspect, 0, this);
    }
    
    //FEATURE: this is not really useful because we do not handle the cases, yet 
    _pIOleObject->Advise(this, &_dwConnection);
    
    _pIOleObject->SetHostNames(TEXTW("OC Host Window"), TEXTW("OC Host Window"));
    
    return S_OK;
}

// 
HRESULT COleControlHost::_Activate()
{
    HRESULT hr = E_FAIL;
    
    RECT rcClient;
    ASSERT(_hwnd);
    
    _SendNotify(OCN_ACTIVATE, NULL);
    
    if (!GetClientRect(_hwnd, &rcClient))
        SetRectEmpty(&rcClient);
    
    hr = _pIOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, this, 0, _hwnd, &rcClient);
    
    if (SUCCEEDED(hr))
        _bInPlaceActive = TRUE;
    
    // Calling second DoVerb with OLEIVERB_SHOW because:
    // 1. If the above DoVerb fails, this is a back up activation call
    // 2. If the above DoVerb succeeds, this is also necessary because 
    //    Some embeddings needs to be explicitly told to show themselves.
    
    if (!(_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME)) 
        hr = _pIOleObject->DoVerb(OLEIVERB_SHOW, NULL, this, 0, _hwnd, &rcClient);      
    
    if (FAILED(hr))
        TraceMsg(TF_OCCONTROL, "_Activate: %d Unable to DoVerb! Error = %lX", _bInPlaceActive, hr);

    return hr;
}

HRESULT COleControlHost::_Deactivate()
{
    _SendNotify(OCN_DEACTIVATE, NULL);
    if (_pIOleIPObject)
    {
        _pIOleIPObject->InPlaceDeactivate();
        // Should be set to NULL by the above function call
        ASSERT(_pIOleIPObject == NULL);
        
        return S_OK;
    }
    
    return S_FALSE;
}

HRESULT COleControlHost::_DoVerb(long iVerb, LPMSG lpMsg)
{
    HRESULT hr = E_FAIL;
    
    RECT rcClient;
    ASSERT(_hwnd && IsWindow(_hwnd));
    
    if (!GetClientRect(_hwnd, &rcClient))
        SetRectEmpty(&rcClient);
    
    hr = _pIOleObject->DoVerb(iVerb, lpMsg, this, 0, _hwnd, &rcClient);
    
    if (SUCCEEDED(hr))
        _bInPlaceActive = TRUE;
    
#if 0 // we'll count on DocHost::DoVerb to do this if needed (or our caller?)
    // note that DocHost does this always (no OLEMISC_* check)
    if (iVerb == OLEIVERB_INPLACEACTIVATE) {
        // Calling second DoVerb with OLEIVERB_SHOW because:
        // 1. If the above DoVerb fails, this is a back up activation call
        // 2. If the above DoVerb succeeds, this is also necessary because 
        //    Some embeddings needs to be explicitly told to show themselves.
        
        if (!(_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME)) 
            hr = _pIOleObject->DoVerb(OLEIVERB_SHOW, lpMsg, this, 0, _hwnd, &rcClient);      
    }
#endif
    
    if (FAILED(hr))
        TraceMsg(TF_OCCONTROL, "_Activate: %d Unable to DoVerb! Error = %lX", _bInPlaceActive, hr);

    return hr;
}

// Clean up and Release all of interface pointers used in this object
HRESULT COleControlHost::_Exit()
{
    _SendNotify(OCN_EXIT, NULL);
    if (_pIViewObject)
    {
        _pIViewObject->SetAdvise(_dwAspect, 0, NULL);
        _pIViewObject->Release();
        _pIViewObject = NULL;
    }
    
    if (_pIOleObject)
    {
        if (_dwConnection)
        {
            _pIOleObject->Unadvise(_dwConnection);
            _dwConnection = 0;
        }
        
        _pIOleObject->Close(OLECLOSE_NOSAVE);
        _pIOleObject->SetClientSite(NULL);
        _pIOleObject->Release();
        _pIOleObject = NULL;
    }

    if (_punkOC)
    {
        ULONG ulRef;
        ulRef = _punkOC->Release();
        _punkOC = NULL;
        if (ulRef != 0)
            TraceMsg(TF_OCCONTROL, "OCHOST _Exit: After last release ref = %d > 0", ulRef);
    }
    
    ATOMICRELEASE(_pIDocHostUIParent);
    ATOMICRELEASE(_pIDocHostUIParent2);

    if (_punkOwner) {
        _punkOwner->Release();
        _punkOwner = NULL;
    }
        
    if (_pdispSiteDelegate) {
        _pdispSiteDelegate->Release();
        _pdispSiteDelegate = NULL;
    }
        
    return S_OK;
}

COleControlHost::COleControlHost(HWND hwnd)
    : _cRef(1), _dwAspect(DVASPECT_CONTENT), _hwnd(hwnd)
    {
    // These variables should be initialized to zeros automatically
    ASSERT(_dwMiscStatus == 0);
    ASSERT(_dwConnection == 0);
    ASSERT(_bInPlaceActive == FALSE);
    ASSERT(_pIDocHostUIParent  == NULL);
    ASSERT(_pIDocHostUIParent2 == NULL);
    ASSERT(_clsidOC == CLSID_NULL);
    ASSERT(_punkOC == NULL);
    ASSERT(_pIViewObject == NULL);
    ASSERT(_pIOleIPObject == NULL);
    ASSERT(_pdispSiteDelegate == NULL);

    ASSERT(_hwnd);
    
}


#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_OCCONTROL, "CDocObjectHost(%x)::QI(%s) is AddRefing _cRef=%lX", this, psz, _cRef); }
#else
#define _AddRef(psz)    ++_cRef
#endif

// *** IUnknown Methods ***

HRESULT COleControlHost::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    // ppvObj must not be NULL
    ASSERT(ppvObj != NULL);

    if (ppvObj == NULL)
        return E_INVALIDARG;
    
    *ppvObj = NULL;

    if ((IsEqualIID(riid, IID_IUnknown)) ||
        (IsEqualIID(riid, IID_IOleWindow)) || 
        (IsEqualIID(riid, IID_IOleInPlaceUIWindow)) || 
        (IsEqualIID(riid, IID_IOleInPlaceFrame)))
    {
        *ppvObj = SAFECAST(this, IOleInPlaceFrame *);
        TraceMsg(TF_OCCONTROL, "QI IOleInPlaceFrame succeeded");
    }
    else if (IsEqualIID(riid, IID_IServiceProvider)) 
    {
        *ppvObj = SAFECAST(this, IServiceProvider *);
        TraceMsg(TF_OCCONTROL, "QI IServiceProvider succeeded");
    }
        
    else if (IsEqualIID(riid, IID_IOleClientSite))
    {
        *ppvObj = SAFECAST(this, IOleClientSite *);
        TraceMsg(TF_OCCONTROL, "QI IOleClientSite succeeded");
    }
    else if (IsEqualIID(riid, IID_IAdviseSink))
    {
        *ppvObj = SAFECAST(this, IAdviseSink *);
        TraceMsg(TF_OCCONTROL, "QI IAdviseSink succeeded");
    }
    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
    {
        *ppvObj = SAFECAST(this, IOleInPlaceSite *);
        TraceMsg(TF_OCCONTROL, "QI IOleInPlaceSite succeeded");
    } 
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppvObj = SAFECAST(this, IOleCommandTarget *);
        TraceMsg(TF_OCCONTROL, "QI IOleCommandTarget succeeded");
    }
    else if (NULL != _pIDocHostUIParent  && 
            IsEqualIID(riid, IID_IDocHostUIHandler))
    {
        // only implement this if the host implements it
        *ppvObj = SAFECAST(&_xuih, IDocHostUIHandler *);
        TraceMsg(TF_OCCONTROL, "QI IDocHostUIHandler succeeded");
    }
    else if (NULL != _pIDocHostUIParent2  && 
            IsEqualIID(riid, IID_IDocHostUIHandler2))
    {
        // only implement this if the host implements it
        *ppvObj = SAFECAST(&_xuih, IDocHostUIHandler2 *);
        TraceMsg(TF_OCCONTROL, "QI IDocHostUIHandler2 succeeded");
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch *);
        TraceMsg(TF_OCCONTROL, "QI IDispatch succeeded");
    }
    else
        return E_NOINTERFACE;  // Otherwise, don't delegate to HTMLObj!!
     
    
    _AddRef(TEXT("IOleInPlaceSite"));
    return S_OK;
}


ULONG COleControlHost::AddRef()
{
    _cRef++;
    TraceMsg(TF_OCCONTROL, "COleControlHost(%x)::AddRef called, new _cRef=%lX", this, _cRef);
    return _cRef;
}

ULONG COleControlHost::Release()
{
    _cRef--;
    TraceMsg(TF_OCCONTROL, "COleControlHost(%x)::Release called, new _cRef=%lX", this, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

// ServiceProvider interfaces
HRESULT COleControlHost::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;
    
    if (_punkOwner) {
        IServiceProvider *psp;
        
        _punkOwner->QueryInterface(IID_IServiceProvider, (LPVOID*)&psp);
        if (psp) {
            hres = psp->QueryService(guidService, riid, ppvObj);
            psp->Release();
        }
    }
    
    return hres;
}

// ************************ IOleClientSite methods ****************** 

HRESULT COleControlHost::SaveObject()
{
    //FEATURE: default set to E_NOTIMPL may not be correct
    HRESULT hr = E_NOTIMPL;
    
    IStorage * pIs;
    if (SUCCEEDED(_punkOC->QueryInterface(IID_IStorage, (void **)&pIs)))
    {
        IPersistStorage *pIps;
        if (SUCCEEDED(_punkOC->QueryInterface(IID_IPersistStorage, (void **)&pIps)))
        {
            OleSave(pIps, pIs, TRUE);
            pIps->SaveCompleted(NULL);
            pIps->Release();
            hr = S_OK;
        }
        pIs->Release();
    }
    
    return hr;   
}

HRESULT COleControlHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppMk)
{
     return E_NOTIMPL;   
}

HRESULT COleControlHost::GetContainer(LPOLECONTAINER * ppContainer)
{
    *ppContainer = NULL;       
    return E_NOINTERFACE;
}

HRESULT COleControlHost::ShowObject()
{
//    RECTL rcl;
//    POINT pt1, pt2;
    
    return S_OK;   
}

HRESULT COleControlHost::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

HRESULT COleControlHost::RequestNewObjectLayout()
{
     return E_NOTIMPL;   
}

// ************************ IAdviseSink methods ********************* 
void COleControlHost::OnDataChange(FORMATETC * pFmt, STGMEDIUM * pStgMed)
{
    // NOTES: This is optional
    return;   
}
    
void COleControlHost::OnViewChange(DWORD dwAspect, LONG lIndex)
{
    // FEATURE: need to let the container know the colors might have changed
    // but don't want to deal with the paletts now

    // Draw only if not inplace active and this is the right aspect.  Inplace
    // active objects have their own window and are responsible for painting
    // themselves.
    
    // WARNING: _bInPlaceActive is not determined, yet. 
    // This funtion is called as a result of calling doverb, however, 
    // _bInPlaceActive will only be determined as DoVerb returns
    // works fine for now, but could be trouble later. 
    if ((_hwnd) && (!_bInPlaceActive) && (dwAspect == _dwAspect))
    {
        HDC hdc = GetDC(_hwnd);

        if (hdc)
        {
            _Draw(hdc);
            ReleaseDC(_hwnd, hdc);
        }
    }
}

void COleControlHost::OnRename(LPMONIKER pMoniker)
{
    return;   
}

void COleControlHost::OnSave()
{
    // NOTES: This is optional
    return;   
}

void COleControlHost::OnClose()
{
    // FEATURE: need to let the container know the colors might have changed
    return;   
}

// ************************ IOleWindow Methods ********************** 
HRESULT COleControlHost::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return S_OK;
}

HRESULT COleControlHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    // NOTES: This is optional
    return E_NOTIMPL;   
}

// *********************** IOleInPlaceSite Methods *****************
HRESULT COleControlHost::CanInPlaceActivate(void)
{
    return S_OK;   
}

HRESULT COleControlHost::OnInPlaceActivate(void)
{
    if (!_pIOleIPObject)
        return (_punkOC->QueryInterface(IID_IOleInPlaceObject, (void **)&_pIOleIPObject));    
    else
        return S_OK;
}


HRESULT COleControlHost::OnUIActivate(void)
{
    LRESULT lres;
    OCNONUIACTIVATEMSG oam = {0};

    oam.punk = _punkOC;

    lres = _SendNotify(OCN_ONUIACTIVATE, &oam.nmhdr);
    return S_OK;
}

HRESULT COleControlHost::GetWindowContext (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppIIPUIWin, 
                                           LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    *ppFrame = this;
    _AddRef("GetWindowContext");
        
    // This is set to NULL because the document window is the same as the frame 
    // window
    *ppIIPUIWin = NULL;
    
    ASSERT(_hwnd);
    if (!GetClientRect(_hwnd, lprcPosRect))
        SetRectEmpty(lprcPosRect);
    
    // Set the clip rectangle to be the same as the position rectangle
    
    CopyRect(lprcClipRect, lprcPosRect);
        
    lpFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
    
#ifdef MDI
    lpFrameInfo->fMDIApp = TRUE;
#else
    lpFrameInfo->fMDIApp = FALSE;
#endif
    lpFrameInfo->hwndFrame = _hwnd;
    lpFrameInfo->haccel = 0;
    lpFrameInfo->cAccelEntries = 0;
    return S_OK;
}

HRESULT COleControlHost::Scroll(SIZE scrollExtent)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::OnUIDeactivate(BOOL fUndoable)
{
    
    return E_NOTIMPL;   
}


HRESULT COleControlHost::OnInPlaceDeactivate(void)
{
    if (_pIOleIPObject)
    {
        _pIOleIPObject->Release();
        _pIOleIPObject = NULL;
    }
    
    return S_OK;
}

HRESULT COleControlHost::DiscardUndoState(void)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::DeactivateAndUndo(void)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::OnPosRectChange(LPCRECT lprcPosRect) 
{
    // We do not allow the children to change the size themselves
    OCNONPOSRECTCHANGEMSG opcm = {0};
    opcm.prcPosRect = lprcPosRect;
    _SendNotify(OCN_ONPOSRECTCHANGE, &opcm.nmhdr);
    return S_OK;
}
// ************************ IOleInPlaceUIWindow methods *************

HRESULT COleControlHost::GetBorder(LPRECT lprectBorder)
{
    return E_NOTIMPL;
}

HRESULT COleControlHost::RequestBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT COleControlHost::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT COleControlHost::SetActiveObject(IOleInPlaceActiveObject * pActiveObject,
                                LPCOLESTR lpszObjName)
{
    return E_NOTIMPL;
}

// *********************** IOleInPlaceFrame Methods *****************
HRESULT COleControlHost::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::RemoveMenus(HMENU hmenuShared)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::SetStatusText(LPCOLESTR pszStatusText)
{
    OCNONSETSTATUSTEXTMSG osst = {0};
    osst.pwszStatusText = pszStatusText;
    _SendNotify(OCN_ONSETSTATUSTEXT, &osst.nmhdr);
    return S_OK;
}

HRESULT COleControlHost::EnableModeless(BOOL fEnable)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    // Should implement later
    return E_NOTIMPL;   
}

// ************************ IOleCommandTarget Methods *************
HRESULT COleControlHost::QueryStatus(const GUID *pguid, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdtext)
{
    return IUnknown_QueryStatus(_punkOwner, pguid, cCmds, rgCmds, pcmdtext);
}

HRESULT COleControlHost::Exec(const GUID *pguid, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return IUnknown_Exec(_punkOwner, pguid, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

HRESULT COleControlHost::_InitOCStruct(LPOCHINITSTRUCT lpocs)
{               
    HRESULT hres = E_FAIL;

    if (_punkOC)
        return S_FALSE;
    
    if (lpocs)
    {
        if (lpocs->cbSize != SIZEOF(OCHINITSTRUCT))
            return hres;

        if (lpocs->clsidOC == CLSID_NULL)
            return hres;

        _clsidOC = lpocs->clsidOC;
        _SetOwner(lpocs->punkOwner);
    }
    else 
        return hres;

    hres = _Init();
    if (SUCCEEDED(hres))
        hres = _Activate();    
    
    return hres;
}

LRESULT COleControlHost::_OnPaint()
{
    ASSERT(_hwnd);

    PAINTSTRUCT ps;

    HDC hdc = BeginPaint(_hwnd, &ps);    
    _Draw(hdc);
    EndPaint(_hwnd, &ps);
    return 0;
}

LRESULT COleControlHost::_OnSize(HWND hwnd, LPARAM lParam)
{
    if (_pIOleIPObject)
    {
        RECT rcPos, rcClip ;
        SetRect( &rcPos, 0, 0, LOWORD(lParam), HIWORD(lParam) ) ;
        rcClip = rcPos ;
        _pIOleIPObject->SetObjectRects(&rcPos, &rcClip);
    }
    return 0;
}

LRESULT COleControlHost::_OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{   
    TCHAR szClsid[50];
    _hwndParent = GetParent(hwnd);
    SetWindowLongPtr(hwnd, 0, (LONG_PTR)this);
    
    LPOCHINITSTRUCT lpois = (LPOCHINITSTRUCT)lpcs->lpCreateParams;
    HRESULT hres = S_OK;
        
    if (lpois)
        hres = _InitOCStruct(lpois);
    else if (GetWindowText(hwnd, szClsid, ARRAYSIZE(szClsid)))
    {
        OCHINITSTRUCT ois;
        ois.cbSize = SIZEOF(OCHINITSTRUCT);
        if (FAILED(SHCLSIDFromString(szClsid, &ois.clsidOC)))
            ois.clsidOC = CLSID_NULL;
        ois.punkOwner = NULL;
        
        hres = _InitOCStruct(&ois);
    }
    
    if (FAILED(hres))
        return -1;
    return 0;
}

LRESULT COleControlHost::_OnDestroy()
{    
    ASSERT(_hwnd);
    SetWindowLongPtr(_hwnd, 0, 0);
    _ConnectEvents( _punkOC, FALSE ) ;
    _Deactivate();
    _Exit();
    Release();
   
    return 0;
}

LRESULT COleControlHost::_OnQueryInterface(WPARAM wParam, LPARAM lParam)
{
    if (lParam)
    {
        QIMSG * qiMsg = (QIMSG *)lParam;
        return _punkOC->QueryInterface(*qiMsg->qiid, qiMsg->ppvObject);
    }
    return -1;
}

LRESULT COleControlHost::_SetOwner(IUnknown * punkNewOwner)
{
    if (_punkOwner)
        _punkOwner->Release();
    _punkOwner = punkNewOwner;
    if (_punkOwner)
        _punkOwner->AddRef();

    ATOMICRELEASE(_pIDocHostUIParent);
    ATOMICRELEASE(_pIDocHostUIParent2);

    // Query if owner supports IDocHostUIHandler, if so then
    // we turn on our delegating wrapper
    if (punkNewOwner)
    {
        punkNewOwner->QueryInterface(IID_IDocHostUIHandler,  (LPVOID *)&_pIDocHostUIParent);
        punkNewOwner->QueryInterface(IID_IDocHostUIHandler2, (LPVOID *)&_pIDocHostUIParent2);
    }
    return 0;
}

LRESULT COleControlHost::_ConnectEvents( LPUNKNOWN punkOC, BOOL bConnect )
{
    if( bConnect )
    {
        ASSERT( punkOC ) ;
        return _eventSink.Connect( _hwndParent, _hwnd, punkOC ) ;
    }
    return _eventSink.Disconnect() ;
}

LRESULT COleControlHost::_SetServiceProvider(IServiceProvider* pSP)
{
    // Free any existing delegates
    if (_pdispSiteDelegate)
    {
        _pdispSiteDelegate->Release();
    }
    
    // For now, we just delegate IDispatch (Ambient properties) calls
    HRESULT hr = pSP->QueryService(SID_OleControlSite, IID_PPV_ARG(IDispatch, &_pdispSiteDelegate));

    if (FAILED(hr))
    {
        _pdispSiteDelegate = NULL;
    }

    return 0;
}

LRESULT COleControlHost::_SendNotify(UINT code, LPNMHDR pnmhdr)
{
    NMHDR nmhdr;
    ASSERT(_hwnd);

    if (!_hwndParent)
        return 0;
   
    if (!pnmhdr)
        pnmhdr = &nmhdr;
    pnmhdr->hwndFrom = _hwnd;  
    pnmhdr->idFrom = GetDlgCtrlID( _hwnd ) ;
    pnmhdr->code = code;
    
    return SendMessage(_hwndParent, WM_NOTIFY, 0, (LPARAM)pnmhdr);
}



LRESULT CALLBACK COleControlHost::OCHostWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    COleControlHost *pcoch = (COleControlHost *)GetWindowPtr(hwnd, 0);

    if (!pcoch && (uMsg != WM_CREATE))
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);            
    
    switch(uMsg)
    {
    case WM_CREATE:
        pcoch = new COleControlHost(hwnd);
        if (pcoch)
            return pcoch->_OnCreate(hwnd, (LPCREATESTRUCT)lParam);
        return -1;

    case WM_ERASEBKGND:
        if (pcoch->_punkOC && pcoch->_bInPlaceActive)
        {
            //  Now tell windows we don't need no stinkin'
            //  erased background because our view object
            //  is in-place active and he/she will be
            //  taking over from here.
            return TRUE;
        }
        break;
        
    case WM_PAINT:
        return pcoch->_OnPaint();
        
    case WM_SIZE:
        return pcoch->_OnSize(hwnd, lParam);
        
    case WM_DESTROY:
        return pcoch->_OnDestroy();
        
    case OCM_QUERYINTERFACE:
        return  pcoch->_OnQueryInterface(wParam, lParam);
        
    case OCM_INITIALIZE:
        return pcoch->_InitOCStruct((LPOCHINITSTRUCT)lParam);
        
    case OCM_SETOWNER:
        return pcoch->_SetOwner((IUnknown*)lParam);
    
    case OCM_DOVERB:
        return pcoch->_DoVerb((long)wParam, (LPMSG)lParam);

    case OCM_ENABLEEVENTS:
        return pcoch->_ConnectEvents( pcoch->_punkOC, (BOOL)wParam ) ;

    case OCM_SETSERVICEPROVIDER:
        return pcoch->_SetServiceProvider((IServiceProvider*) lParam);
    
    case WM_PALETTECHANGED:
        if (pcoch->_pIOleIPObject) {
            HWND hwnd;
            if (SUCCEEDED(pcoch->_pIOleIPObject->GetWindow(&hwnd))) {
                SendMessage(hwnd, WM_PALETTECHANGED, wParam, lParam);
                }
        }   
        break;

    case WM_SETFOCUS:
        
        //  OC doesn't respond to OLEIVERB_UIACTIVATE ?
        if( pcoch->_dwMiscStatus & OLEMISC_NOUIACTIVATE )
        {
            //  so explicitly assign focus
            HWND hwndObj ;
            if( pcoch->_pIOleIPObject && 
                SUCCEEDED( pcoch->_pIOleIPObject->GetWindow( &hwndObj ) ) )
                SetFocus( hwndObj ) ;
        }
        else
            pcoch->_DoVerb( OLEIVERB_UIACTIVATE, NULL ) ;

        break ;

        
    default:
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);            
    }
    
    return 0;
}

void COleControlHost::_RegisterClass()
{
    WNDCLASS wc = {0};

    wc.style         = CS_GLOBALCLASS;
    wc.lpfnWndProc   = OCHostWndProc;
    //wc.cbClsExtra    = 0;
    wc.cbWndExtra    = SIZEOF(LPVOID);
    wc.hInstance     = HINST_THISDLL;
    //wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor (NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    //wc.lpszMenuName  = NULL;
    wc.lpszClassName = OCHOST_CLASS;
    SHRegisterClass(&wc);
}


HRESULT CProxyUIHandler::QueryInterface(REFIID riid, LPVOID * ppvObj)
{   
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->QueryInterface(riid, ppvObj); 
};

ULONG CProxyUIHandler::AddRef(void)
{   
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->AddRef(); 
};

ULONG CProxyUIHandler::Release(void)
{   
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->Release(); 
};

HRESULT CProxyUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->ShowContextMenu(dwID, ppt, pcmdtReserved, pdispReserved) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->GetHostInfo(pInfo) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc): E_NOTIMPL;
}

HRESULT CProxyUIHandler::HideUI()
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->HideUI(): E_NOTIMPL;
}

HRESULT CProxyUIHandler::UpdateUI()
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->UpdateUI(): E_NOTIMPL;
}

HRESULT CProxyUIHandler::EnableModeless(BOOL fActivate)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->EnableModeless(fActivate): E_NOTIMPL;
}

HRESULT CProxyUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->OnDocWindowActivate(fActivate): E_NOTIMPL;
}

HRESULT CProxyUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->OnFrameWindowActivate(fActivate): E_NOTIMPL;
}

HRESULT CProxyUIHandler::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->ResizeBorder(prcBorder, pUIWindow, fRameWindow): E_NOTIMPL;
}

HRESULT CProxyUIHandler::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID): E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->GetOptionKeyPath(pchKey, dw): E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->GetDropTarget(pDropTarget, ppDropTarget) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetExternal(IDispatch **ppDispatch)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->GetExternal(ppDispatch) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::FilterDataObject( IDataObject *pDO, IDataObject **ppDORet)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->FilterDataObject(pDO, ppDORet) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetOverrideKeyPath( LPOLESTR *pchKey, DWORD dw)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent2 ? poch->_pIDocHostUIParent2->GetOverrideKeyPath(pchKey, dw) : E_NOTIMPL;    
}

STDAPI_(BOOL) DllRegisterWindowClasses(const SHDRC * pshdrc)
{
    if (pshdrc && pshdrc->cbSize == SIZEOF(SHDRC) && !(pshdrc->dwFlags & ~SHDRCF_ALL))
    {
        if (pshdrc->dwFlags & SHDRCF_OCHOST)
        {
            COleControlHost::_RegisterClass();
            return TRUE;
        }
    }
    return FALSE;
}

//---------------------------------------------------------------------------
//  CEventSink constructor
CEventSink::CEventSink( BOOL bAutoDelete )
    :    _hwndSite(NULL),
         _hwndOwner(NULL),
         _punkOC(NULL),
         _dwCookie(0),
         _cRef(1),
         _bAutoDelete( bAutoDelete )
{
    _iid = _iidDefault = IID_NULL ;
}

//  CEventSink IUnknown impl
STDMETHODIMP CEventSink::QueryInterface( REFIID riid, void** ppvObj )
{
    *ppvObj = NULL ;
    if( IsEqualGUID( riid, IID_IUnknown ) || 
        IsEqualGUID( riid, IID_IDispatch )||
        IsEqualGUID( riid, _iidDefault ) )
    {
        *ppvObj = this ;
        return S_OK ;
    }
    return E_NOINTERFACE ;
}

STDMETHODIMP_(ULONG) CEventSink::AddRef()
{ 
    return InterlockedIncrement( &_cRef ) ;
}

STDMETHODIMP_(ULONG) CEventSink::Release()
{
    if( InterlockedDecrement( &_cRef ) <= 0 )
    {
        if( _bAutoDelete )
            delete this ;
        return 0 ; 
    }
    return _cRef ;
}

//  Connects the sink to the OC's default event dispatch interface.
BOOL CEventSink::Connect( HWND hwndOwner, HWND hwndSite, LPUNKNOWN punkOC )
{
    ASSERT( punkOC ) ;
    IID iidDefault = IID_NULL ;

    if( SUCCEEDED( _GetDefaultEventIID( punkOC, &iidDefault ) ) )
    {
        _iidDefault = iidDefault ;
        return _Connect( hwndOwner, hwndSite, punkOC, iidDefault ) ;
    }
    return FALSE ;
}

//  Establishes advise connection on the specified interface
BOOL CEventSink::_Connect( HWND hwndOwner, HWND hwndSite, LPUNKNOWN punkOC, REFIID iid )
{
    LPCONNECTIONPOINTCONTAINER pcpc;
    ASSERT(punkOC != NULL) ;
    HRESULT hr = CONNECT_E_CANNOTCONNECT ;

    if( _IsConnected( iid ) )
        return TRUE ;

    if( _dwCookie )
        Disconnect() ;

    if( punkOC &&
        SUCCEEDED( punkOC->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pcpc )))
    {
        LPCONNECTIONPOINT pcp = NULL;
        DWORD             dwCookie = 0;
        ASSERT(pcpc != NULL);

        if( SUCCEEDED(pcpc->FindConnectionPoint( iid, &pcp )))
        {
            ASSERT(pcp != NULL);
            hr = pcp->Advise( this, &dwCookie ) ;
            
            if( SUCCEEDED( hr ) )
            {
                _iid = iid ;
                _dwCookie  = dwCookie ;
                _hwndOwner = hwndOwner ;
                _hwndSite  = hwndSite ;
                _punkOC    = punkOC ;
                _punkOC->AddRef() ;
            }
            pcp->Release();
        }
        pcpc->Release();
    }

    return SUCCEEDED( hr ) ;
}

//  Retrieves default event dispatch interface from the OC.
HRESULT CEventSink::_GetDefaultEventIID( LPUNKNOWN punkOC, IID* piid )
{
    HRESULT hr ;

    ASSERT( punkOC ) ;
    ASSERT( piid ) ;

    IProvideClassInfo  *pci ;
    IProvideClassInfo2 *pci2 ;
    *piid = IID_NULL ;

    #define IMPLTYPE_MASK \
        (IMPLTYPEFLAG_FDEFAULT|IMPLTYPEFLAG_FSOURCE|IMPLTYPEFLAG_FRESTRICTED)
    #define IMPLTYPE_DEFAULTSOURCE \
        (IMPLTYPEFLAG_FDEFAULT|IMPLTYPEFLAG_FSOURCE)

    //  Retrieve default outbound dispatch IID using OC's IProvideClassInfo2
    if( SUCCEEDED( (hr = punkOC->QueryInterface( IID_IProvideClassInfo2, (void**)&pci2 )) ) )
    {
        hr = pci2->GetGUID( GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid ) ;
        pci2->Release() ;
    }
    else // no IProvideClassInfo2; try IProvideClassInfo:
    if( SUCCEEDED( (hr = punkOC->QueryInterface( IID_IProvideClassInfo, (void**)&pci )) ) )
    {
        ITypeInfo* pClassInfo = NULL;

        if( SUCCEEDED( (hr = pci->GetClassInfo( &pClassInfo )) ) )
        {
            LPTYPEATTR pClassAttr;
            ASSERT( pClassInfo );

            if( SUCCEEDED( (hr = pClassInfo->GetTypeAttr( &pClassAttr )) ) )
            {
                ASSERT( pClassAttr ) ;
                ASSERT( pClassAttr->typekind == TKIND_COCLASS ) ;

                // Enumerate implemented interfaces looking for default source IID.
                HREFTYPE hRefType;
                int      nFlags;

                for( UINT i = 0; i < pClassAttr->cImplTypes; i++ )
                {
                    if( SUCCEEDED( (hr = pClassInfo->GetImplTypeFlags( i, &nFlags )) ) &&
                        ((nFlags & IMPLTYPE_MASK) == IMPLTYPE_DEFAULTSOURCE) )
                    {
                        // Got the interface, now retrieve its IID:
                        ITypeInfo* pEventInfo = NULL ;

                        if( SUCCEEDED( (hr = pClassInfo->GetRefTypeOfImplType( i, &hRefType )) ) &&
                            SUCCEEDED( (hr = pClassInfo->GetRefTypeInfo( hRefType, &pEventInfo )) ) )
                        {
                            LPTYPEATTR pEventAttr;
                            ASSERT( pEventInfo ) ;

                            if( SUCCEEDED( (hr = pEventInfo->GetTypeAttr( &pEventAttr )) ) )
                            {
                                *piid = pEventAttr->guid ; 
                                pEventInfo->ReleaseTypeAttr(pEventAttr);
                            }
                            pEventInfo->Release();
                        }
                        break;
                    }
                }
                pClassInfo->ReleaseTypeAttr(pClassAttr);
            }
            pClassInfo->Release();
        }
        pci->Release() ;
    }

    if( SUCCEEDED( hr ) && IsEqualIID( *piid, IID_NULL ) )
        hr = E_FAIL ;

    return hr ;
}

//  reports whether the sink is connected to the indicated sink
BOOL CEventSink::_IsConnected( REFIID iid )
{
    return _dwCookie != 0L && 
           IsEqualIID( iid, _iid ) ;
}

//  disconnects the sink
BOOL CEventSink::Disconnect()
{
    LPCONNECTIONPOINTCONTAINER pcpc;

    if( _dwCookie != 0 &&
        _punkOC &&
        SUCCEEDED( _punkOC->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pcpc)))
    {
        LPCONNECTIONPOINT pcp = NULL;
        ASSERT(pcpc != NULL);

        if (SUCCEEDED(pcpc->FindConnectionPoint(_iid, &pcp)))
        {
            ASSERT(pcp != NULL);
            pcp->Unadvise(_dwCookie);
            pcp->Release();

            _iid        = IID_NULL ;
            _dwCookie   = 0L ;
            _hwndOwner = NULL ;
            _hwndSite  = NULL ;
            _punkOC->Release() ;
            _punkOC     = NULL ;
        }
        pcpc->Release();
        return TRUE ;
    }

    return FALSE ;
}

//  CEventSink IDispatch interface
STDMETHODIMP CEventSink::Invoke( 
    IN DISPID dispIdMember,
    IN REFIID riid,
    IN LCID lcid,
    IN WORD wFlags,
    IN OUT DISPPARAMS *pDispParams,
    OUT VARIANT *pVarResult,
    OUT EXCEPINFO *pExcepInfo,
    OUT UINT *puArgErr)
{
    //  Copy method args to notification block
    NMOCEVENT   event ;
    ZeroMemory( &event, sizeof(event) ) ;
    event.hdr.hwndFrom = _hwndSite;  
    event.hdr.idFrom   = GetDlgCtrlID( _hwndSite ) ;
    event.hdr.code     = OCN_OCEVENT ;
    event.dispID       = dispIdMember ;
    event.iid          = riid ;
    event.lcid         = lcid ;
    event.wFlags       = wFlags ;
    event.pDispParams  = pDispParams ;
    event.pVarResult   = pVarResult ;
    event.pExepInfo    = pExcepInfo ;
    event.puArgErr     = puArgErr ;

    //  Notify parent of event
    ::SendMessage( _hwndOwner, WM_NOTIFY, event.hdr.idFrom, (LPARAM)&event ) ;
    
    //  Cleanup args
    if (pVarResult != NULL)
        VariantClear( pVarResult ) ;

    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\nsctask.cpp ===
#include "priv.h"
#include "nsc.h"
#include "nsctask.h"

#define PRIORITY_ENUM       ITSAT_DEFAULT_PRIORITY
#define PRIORITY_ICON       PRIORITY_ENUM + 1      //needs to be slightly higher priority
#define PRIORITY_OVERLAY    ITSAT_DEFAULT_PRIORITY

/////////////////////////////////////////////////////////////////////////
// COPY AND PASTE ALERT

// this code is mostly copied and pasted from browseui/icotask.cpp
// see lamadio and/or davemi for why these aren't combined or shared
/////////////////////////////////////////////////////////////////////////

// {7DB7F689-BBDB-483f-A8A9-C6E963E8D274}
EXTERN_C const GUID TASKID_BackgroundEnum = { 0x7db7f689, 0xbbdb, 0x483f, { 0xa8, 0xa9, 0xc6, 0xe9, 0x63, 0xe8, 0xd2, 0x74 } };

// {EB30900C-1AC4-11d2-8383-00C04FD918D0}
EXTERN_C const GUID TASKID_IconExtraction = { 0xeb30900c, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

// {EB30900D-1AC4-11d2-8383-00C04FD918D0}
EXTERN_C const GUID TASKID_OverlayExtraction = { 0xeb30900d, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

class CNscIconTask : public CRunnableTask
{
public:
    CNscIconTask(LPITEMIDLIST pidl, PFNNSCICONTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId);

    // IRunnableTask
    STDMETHODIMP RunInitRT(void);
    
protected:
    virtual ~CNscIconTask();

    virtual void _Extract(IShellFolder *psf, LPCITEMIDLIST pidlItem);

    BOOL                   _bOverlayTask;
    LPITEMIDLIST           _pidl;
    PFNNSCICONTASKBALLBACK _pfnIcon;
    CNscTree              *_pns;
    UINT_PTR               _uId;
    UINT                   _uSynchId;
};

CNscIconTask::CNscIconTask(LPITEMIDLIST pidl, PFNNSCICONTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId):
    _pidl(pidl), _pfnIcon(pfn), _uId(uId), _uSynchId(uSynchId), CRunnableTask(RTF_DEFAULT)
{
    _pns = pns;
    if (_pns)
        _pns->AddRef();
}

CNscIconTask::~CNscIconTask()
{
    if (_pns)
        _pns->Release();

    ILFree(_pidl);
}

// IRunnableTask methods (override)
STDMETHODIMP CNscIconTask::RunInitRT(void)
{
    IShellFolder* psf;
    LPCITEMIDLIST pidlItem;
    // We need to rebind because shell folders may not be thread safe.
    if (SUCCEEDED(IEBindToParentFolder(_pidl, &psf, &pidlItem)))
    {
        _Extract(psf, pidlItem);
        psf->Release();
    }

    return S_OK;
}

void CNscIconTask::_Extract(IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    int iIcon = -1, iIconOpen = -1;
#ifdef IE5_36825
    HRESULT hr = E_FAIL;
    IShellIcon *psi;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellIcon, &psi))))
    {
        hr = psi->GetIconOf(pidlItem, 0, &iIcon); 
        if (hr == S_OK)
        {
            ULONG ulAttrs = SFGAO_FOLDER;
            psf->GetAttributesOf(1, &pidlItem, &ulAttrs);

            if (!(ulAttrs & SFGAO_FOLDER) || FAILED(psi->GetIconOf(pidlItem, GIL_OPENICON, &iIconOpen)))
                iIconOpen = iIcon;
        }
        psi->Release();
    }

    if (hr != S_OK)
    {
#endif
        // slow way...
        iIcon = IEMapPIDLToSystemImageListIndex(psf, pidlItem, &iIconOpen);
#ifdef IE5_36825
    }
#endif

    // REARCHITECT : This is no good.  We are attempted to see if the content is offline.  That should
    // be done by using IQueryInfo::xxx().  This should go in the InternetShortcut object.
    // IShellFolder2::GetItemData or can also be used.
    //
    // See if it is a link. If it is not, then it can't be in the wininet cache and can't
    // be pinned (sticky cache entry) or greyed (unavailable when offline)
    DWORD dwFlags = 0;
    BOOL fAvailable;
    BOOL fSticky;
    
    // GetLinkInfo() will fail if the SFGAO_FOLDER or SFGAO_BROWSER bits aren't set.
    if (pidlItem && SUCCEEDED(GetLinkInfo(psf, pidlItem, &fAvailable, &fSticky)))
    {
        if (!fAvailable)
        {
            dwFlags |= NSCICON_GREYED;
        }

        if (fSticky)
        {
            dwFlags |= NSCICON_PINNED;
        }
    }
    else
    {
        //item is not a link
        dwFlags |= NSCICON_DONTREFETCH;
    }

    _pfnIcon(_pns, _uId, iIcon, iIconOpen, dwFlags, _uSynchId);
}

// takes ownership of pidl
HRESULT AddNscIconTask(IShellTaskScheduler* pts, LPITEMIDLIST pidl, PFNNSCICONTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId)
{
    HRESULT hr;
    CNscIconTask* pTask = new CNscIconTask(pidl, pfn, pns, uId, uSynchId);
    if (pTask)
    {
        hr = pts->AddTask(SAFECAST(pTask, IRunnableTask*), TASKID_IconExtraction, 
            ITSAT_DEFAULT_LPARAM, PRIORITY_ICON);
        pTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        ILFree(pidl);
    }

    return hr;
}

class CNscOverlayTask : public CNscIconTask
{
public:
    CNscOverlayTask(LPITEMIDLIST pidl, PFNNSCOVERLAYTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId);

protected:
    virtual void _Extract(IShellFolder *psf, LPCITEMIDLIST pidlItem);
    
    PFNNSCOVERLAYTASKBALLBACK _pfnOverlay;
};

CNscOverlayTask::CNscOverlayTask(LPITEMIDLIST pidl, PFNNSCOVERLAYTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId) :
    CNscIconTask(pidl, NULL, pns, uId, uSynchId), _pfnOverlay(pfn)
{   
}

void CNscOverlayTask::_Extract(IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    IShellIconOverlay *psio;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &psio))))
    {
        int iOverlayIndex = 0;
        if (psio->GetOverlayIndex(pidlItem, &iOverlayIndex) == S_OK && iOverlayIndex > 0)
        {
            _pfnOverlay(_pns, _uId, iOverlayIndex, _uSynchId);
        }
        psio->Release();
    }
}

// takes ownership of pidl
HRESULT AddNscOverlayTask(IShellTaskScheduler* pts, LPITEMIDLIST pidl, PFNNSCOVERLAYTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId)
{
    HRESULT hr;
    CNscOverlayTask *pTask = new CNscOverlayTask(pidl, pfn, pns, uId, uSynchId);
    if (pTask)
    {
        hr = pts->AddTask(SAFECAST(pTask, IRunnableTask*), TASKID_OverlayExtraction, 
                          ITSAT_DEFAULT_LPARAM, PRIORITY_OVERLAY);
        pTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        ILFree(pidl);   // we own it, clean up here
    }

    return hr;
}

class CNscEnumTask : public CRunnableTask
{
public:
    CNscEnumTask(PFNNSCENUMTASKBALLBACK pfn, 
        CNscTree *pns, UINT_PTR uId, DWORD dwSig, DWORD grfFlags, HDPA hdpaOrder,
        DWORD dwOrderSig, BOOL fForceExpand, UINT uDepth, BOOL fUpdate, BOOL fUpdatePidls);
    HRESULT Init(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExpandingTo);

    // IRunnableTask
    STDMETHODIMP RunInitRT(void);
    STDMETHODIMP InternalResumeRT(void);
    
private:
    virtual ~CNscEnumTask();

    LPITEMIDLIST           _pidl;
    PFNNSCENUMTASKBALLBACK _pfn;
    CNscTree *             _pns;
    UINT_PTR               _uId;
    DWORD                  _dwSig;
    DWORD                  _grfFlags;
    HDPA                   _hdpaOrder;
    LPITEMIDLIST           _pidlExpandingTo;
    DWORD                  _dwOrderSig;
    BOOL                   _fForceExpand;
    BOOL                   _fUpdate;
    BOOL                   _fUpdatePidls;
    UINT                   _uDepth;
    HDPA                   _hdpa;
    IShellFolder *         _psf;
    IEnumIDList *          _penum;

    static DWORD           s_dwMaxItems;
};

DWORD CNscEnumTask::s_dwMaxItems = 0;

CNscEnumTask::CNscEnumTask(PFNNSCENUMTASKBALLBACK pfn, CNscTree *pns, 
                           UINT_PTR uId, DWORD dwSig, DWORD grfFlags, HDPA hdpaOrder, 
                           DWORD dwOrderSig, BOOL fForceExpand, UINT uDepth, 
                           BOOL fUpdate, BOOL fUpdatePidls) :
    CRunnableTask(RTF_SUPPORTKILLSUSPEND), _pfn(pfn), _uId(uId), _dwSig(dwSig), _grfFlags(grfFlags), 
    _hdpaOrder(hdpaOrder), _dwOrderSig(dwOrderSig),  _fForceExpand(fForceExpand), _uDepth(uDepth), 
    _fUpdate(fUpdate), _fUpdatePidls(fUpdatePidls)
{
    _pns = pns;
    if (_pns)
        _pns->AddRef();
}

HRESULT CNscEnumTask::Init(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExpandingTo)
{
    if (pidlExpandingTo)
        SHILClone(pidlExpandingTo, &_pidlExpandingTo);  // failure OK
    return SHILClone(pidl, &_pidl);
}

CNscEnumTask::~CNscEnumTask()
{
    if (_pns)
        _pns->Release();
    
    ILFree(_pidl);
    ILFree(_pidlExpandingTo);
    OrderList_Destroy(&_hdpaOrder, TRUE);        // calls DPA_Destroy(_hdpaOrder)
    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_penum);
    if (_hdpa)
        OrderList_Destroy(&_hdpa, TRUE);        // calls DPA_Destroy(hdpa)
}

BOOL OrderList_AppendCustom(HDPA hdpa, LPITEMIDLIST pidl, int nOrder, DWORD dwAttrib)
{
    PORDERITEM poi = OrderItem_Create(pidl, nOrder);
    if (poi)
    {
        poi->lParam = dwAttrib;
        if (-1 != DPA_AppendPtr(hdpa, poi))
            return TRUE;

        OrderItem_Free(poi, FALSE); //don't free pidl because caller will do it
    }
    return FALSE;
}

// IRunnableTask methods (override)
STDMETHODIMP CNscEnumTask::RunInitRT(void)
{
    if (!s_dwMaxItems)
    {
        DWORD dwDefaultLimit = 100; // Default value for the limit
        DWORD dwSize = sizeof(s_dwMaxItems);
        SHRegGetUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("PartialExpandLimit"), NULL, &s_dwMaxItems, &dwSize,
                        FALSE, &dwDefaultLimit, sizeof(dwDefaultLimit));
        if (!s_dwMaxItems)
            s_dwMaxItems = dwDefaultLimit;
    }

    HRESULT hr = E_OUTOFMEMORY;
    _hdpa = DPA_Create(2);
    if (_hdpa)
    {
        // We need to rebind because shell folders may not be thread safe.
        hr = IEBindToObject(_pidl, &_psf);
        if (SUCCEEDED(hr))
        {
            hr = _psf->EnumObjects(NULL, _grfFlags, &_penum);
            if (S_OK != hr)
            {
                // Callback function takes ownership of the pidls and hdpa
                _pfn(_pns, _pidl, _uId, _dwSig, _hdpa, _pidlExpandingTo, _dwOrderSig, _uDepth, _fUpdate, _fUpdatePidls);
                _pidl = NULL;
                _pidlExpandingTo = NULL;
                _hdpa = NULL;
                if (SUCCEEDED(hr))
                    hr = E_FAIL;
            }
        }
    }

    return hr;
}

#define FILE_JUNCTION_FOLDER_FLAGS   (SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_STREAM)

STDMETHODIMP CNscEnumTask::InternalResumeRT(void)
{
    HRESULT hr = S_OK;
    ULONG celt;
    LPITEMIDLIST pidlTemp;
    while (S_OK == _penum->Next(1, &pidlTemp, &celt))
    {
        // filter out zip files (they are both folders and files but we treat them as files)
        // on downlevel SFGAO_STREAM is the same as SFGAO_HASSTORAGE so we'll let zip files slide through (oh well)
        // better than not adding filesystem folders (that have storage)
        if (!(_grfFlags & SHCONTF_NONFOLDERS) && IsOS(OS_WHISTLERORGREATER) && 
            (SHGetAttributes(_psf, pidlTemp, FILE_JUNCTION_FOLDER_FLAGS) & FILE_JUNCTION_FOLDER_FLAGS) == FILE_JUNCTION_FOLDER_FLAGS)
        {
            ILFree(pidlTemp);
        }
        else if (!OrderList_AppendCustom(_hdpa, pidlTemp, -1, 0))
        {
            hr = E_OUTOFMEMORY;
            ILFree(pidlTemp);
            break;
        }
        
        if (!_fForceExpand && (DPA_GetPtrCount(_hdpa) > (int)s_dwMaxItems))
        {
            hr = E_ABORT;
            break;
        }

        // we were told to either suspend or quit...
        if (WaitForSingleObject(_hDone, 0) == WAIT_OBJECT_0)
        {
            return (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
        }
    }

    if (hr == S_OK)
    {
        ORDERINFO oinfo;
        oinfo.psf = _psf;
        oinfo.dwSortBy = OI_SORTBYNAME; // merge depends on by name.
        if (_hdpaOrder && DPA_GetPtrCount(_hdpaOrder) > 0)
        {
            OrderList_Merge(_hdpa, _hdpaOrder,  -1, (LPARAM)&oinfo, NULL, NULL);
            oinfo.dwSortBy = OI_SORTBYORDINAL;
        }
        else
            oinfo.dwSortBy = OI_SORTBYNAME;

        DPA_Sort(_hdpa, OrderItem_Compare, (LPARAM)&oinfo);
        OrderList_Reorder(_hdpa);
        
        // Callback function takes ownership of the pidls and hdpa
        _pfn(_pns, _pidl, _uId, _dwSig, _hdpa, _pidlExpandingTo, _dwOrderSig, _uDepth, _fUpdate, _fUpdatePidls);
        _pidl = NULL;
        _pidlExpandingTo = NULL;
        _hdpa = NULL;
    }
    
    return S_OK;        // return S_OK even if we failed
}


HRESULT AddNscEnumTask(IShellTaskScheduler* pts, LPCITEMIDLIST pidl, PFNNSCENUMTASKBALLBACK pfn, 
                       CNscTree *pns, UINT_PTR uId, DWORD dwSig, DWORD grfFlags, HDPA hdpaOrder, 
                       LPCITEMIDLIST pidlExpandingTo, DWORD dwOrderSig, 
                       BOOL fForceExpand, UINT uDepth, BOOL fUpdate, BOOL fUpdatePidls)
{
    HRESULT hr;
    CNscEnumTask *pTask = new CNscEnumTask(pfn, pns, uId, dwSig, grfFlags, 
                                         hdpaOrder, dwOrderSig, fForceExpand, uDepth, 
                                         fUpdate, fUpdatePidls);
    if (pTask)
    {
        hr = pTask->Init(pidl, pidlExpandingTo);
        if (SUCCEEDED(hr))
        {
            hr = pts->AddTask(SAFECAST(pTask, IRunnableTask*), TASKID_BackgroundEnum, 
                              ITSAT_DEFAULT_LPARAM, PRIORITY_ENUM);
        }
        pTask->Release();
    }
    else
    {
        OrderList_Destroy(&hdpaOrder, TRUE);        // calls DPA_Destroy(hdpaOrder)
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#ifdef DEBUG
#define TF_NSC      0x00002000
void DumpOrderItem(IShellFolder *psf, PORDERITEM poi)
{
    if (poi)
    {
        TCHAR szDebugName[MAX_URL_STRING] = TEXT("Desktop");
        DisplayNameOf(psf, poi->pidl, SHGDN_FORPARSING, szDebugName, ARRAYSIZE(szDebugName));
        TraceMsg(TF_NSC, "OrderItem (%d, %s)\n", poi->nOrder, szDebugName);
    }
}

void DumpOrderList(IShellFolder *psf, HDPA hdpa)
{
    if (psf && hdpa)
    {
        TraceMsg(TF_NSC, "OrderList dump: #of items:%d\n", DPA_GetPtrCount(hdpa));
        for (int i = 0; i < DPA_GetPtrCount(hdpa); i++)
        {
            PORDERITEM poi = (PORDERITEM)DPA_GetPtr(hdpa, i);
            DumpOrderItem(psf, poi);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\nscband.h ===
/**************************************************************\
    FILE: NSCBand.h

    DESCRIPTION:  the class CNscBand exists to support name 
        space control bands.  A name space control uses IShellFolder
        rooted in various namespaces including Favorites, history, 
        Shell Name Space, etc. to depict a hierarchical UI 
        representation of the given name space.  
    
    AUTHOR:  chrisny

\**************************************************************/
#include "bands.h"
#include "nsc.h"
#include "uemapp.h"

#ifndef _NSCBAND_H
#define _NSCBAND_H

// for degug trace messages.
#define DM_PERSIST      0           // trace IPS::Load, ::Save, etc.
#define DM_MENU         0           // menu code
#define DM_FOCUS        0           // focus
#define DM_FOCUS2       0           // like DM_FOCUS, but verbose

const short CSIDL_NIL = -32767;

////////////////
///  NSC band

class CNSCBand : public CToolBand
               , public IContextMenu
               , public IBandNavigate
               , public IWinEventHandler
               , public INamespaceProxy
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CToolBand::Release(); };

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IPersistStream methods ***
    // (others use base class implementation) 
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg
                                    , WPARAM wParam, LPARAM lParam
                                    , LRESULT *plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) { return E_NOTIMPL; };

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);

    // *** IBandNavigate methods ***
    virtual STDMETHODIMP Select(LPCITEMIDLIST pidl);
    

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** INamespaceProxy ***
    virtual STDMETHODIMP GetNavigateTarget(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib);
    virtual STDMETHODIMP Invoke(LPCITEMIDLIST pidl);
    virtual STDMETHODIMP OnSelectionChanged(LPCITEMIDLIST pidl);
    virtual STDMETHODIMP RefreshFlags(DWORD *pdwStyle, DWORD *pdwExStyle, DWORD *pdwEnum) 
        {*pdwStyle = _GetTVStyle(); *pdwExStyle = _GetTVExStyle(); *pdwEnum = _GetEnumFlags(); return S_OK; };
    virtual STDMETHODIMP CacheItem(LPCITEMIDLIST pidl) { return S_OK; };
    
protected:    
    void _SetNscMode(UINT nMode) { _pns->SetNscMode(nMode); };
    virtual DWORD _GetTVStyle();
    virtual DWORD _GetTVExStyle() { return 0; };
    virtual DWORD _GetEnumFlags() { return SHCONTF_FOLDERS | SHCONTF_NONFOLDERS; };
    
    HRESULT _Init(LPCITEMIDLIST pidl);
    virtual HRESULT _InitializeNsc();
    
    virtual ~CNSCBand();
    virtual HRESULT _OnRegisterBand(IOleCommandTarget *poctProxy) { return S_OK; } // meant to be overridden
    
    void _UnregisterBand();
    void _EnsureImageListsLoaded();

    virtual HRESULT _TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib);
    virtual BOOL _ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib);
    virtual HRESULT _NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl);
    HRESULT _QueryContextMenuSelection(IContextMenu ** ppcm);
    HRESULT _InvokeCommandOnItem(LPCTSTR pszVerb);

#ifndef ENABLE_CCHANNELBAND
    friend HRESULT CNSCBand_CreateInstanceEx(IUnknown *punkOuter, IUnknown **ppunk
                                            , LPCOBJECTINFO poi, LPCITEMIDLIST pidl);
#endif
    friend HRESULT CHistBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk
                                            , LPCOBJECTINFO poi);      

#ifndef ENABLE_CCHANNELBAND
    friend HRESULT CChannelBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk
                                            , LPCOBJECTINFO poi);      
#endif  // ENABLE_CCHANNELBAND
                        
    LPITEMIDLIST        _pidl;
    WCHAR               _szTitle[40];
                        
    INSCTree2 *         _pns;               // name space control data.
    IWinEventHandler *  _pweh;              // name space control's OnWinEvent handler
    BITBOOL             _fInited :1;        // true if band has been inited.
    BITBOOL             _fVisible :1;       // true if band is showing
    DWORD              _dwStyle;         // Treeview style
    LPCOBJECTINFO       _poi;               // cached object info.
    HACCEL              _haccTree;

    HIMAGELIST          _himlNormal;        // shared image list
    HIMAGELIST          _himlHot;
};

#endif /* _NSCBAND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\packager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       packager.hxx
//
//  Contents:   Save as Office9 'Thicket' format implementation classes.
//
//----------------------------------------------------------------------------

#ifndef _PACKAGER_HXX_
#define _PACKAGER_HXX_

#define MAX_SAVING_STATUS_TEXT                128
#define MAX_BUFFER_LEN                        512
#define REGPATH_MSIE_MAIN                     TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define REGVALUE_DOWNLOAD_IMAGES              "Display Inline Images"
#define URL_ABOUT_BLANK                       TEXT("about:blank")

class CWebArchive;

class CThicketProgress
{
public:
    CThicketProgress( HWND hDlg );
    ~CThicketProgress(void);

    void SetPercent( ULONG ulPct );
    void SetSaving( LPCTSTR szFile, LPCTSTR szDst );
    void SetSaveText(LPCTSTR szText);

protected:
    HWND    m_hDlg;
    HWND    m_hwndProg;
    TCHAR*  m_pszSavingFmt;
    int     m_cchSavingFmt;
    TCHAR*  m_pszPctFmt;
    ULONG   m_ulPct;
};

/*
 *  CDocumentPackager - master packager class.
 */

// Packaging styles. 
// NOTE: These need to match the order in the format filter string.
enum {
    PACKAGE_THICKET = 1,
    PACKAGE_MHTML,
    PACKAGE_HTML,
    PACKAGE_TEXT
};

class CDocumentPackager
{
public:
    CDocumentPackager(UINT iPackageStyle) {  m_iPackageStyle = iPackageStyle;
                                             m_ptp = NULL; }
    ~CDocumentPackager(void) {}

    HRESULT PackageDocument(IHTMLDocument2 *pDoc, LPCTSTR lpstrDoc,
                            BOOL *pfCancel, CThicketProgress *ptprog,
                            ULONG progLow, ULONG progHigh,
                            UINT cpDst,
                            CWebArchive *pwa = NULL );

    CWebArchive *GetFrameDocArchive( CWebArchive *pwaSrc );

protected:
    friend class CFramesPackager;

    UINT    m_iPackageStyle;

    HRESULT _PackageDocument(IHTMLDocument2 *pDoc, LPCTSTR lpstrDoc,
                             BOOL *pfCancel, CThicketProgress *ptprog,
                             ULONG progLow, ULONG progHigh,
                             UINT cpDst,
                             CWebArchive *pwa,
                             CDocumentPackager *pdpFrames,
                             BOOL fFrameDoc);

    HRESULT _GetDesignDoc( IHTMLDocument2 *pDocSrc, IHTMLDocument2 **ppDocDesign, 
                           BOOL *pfCancel, CThicketProgress *ptp, UINT cp );
private:
    CThicketProgress                 *m_ptp;
};


#endif // _PACKAGER_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\preview.h ===
//  CPrintDoc status defines
//  NB: The # defined of status is important; it 0..2 is used as an array index. (greglett)
#define LOADING_OEHEADER        0
#define LOADING_CONTENT         1       
#define LOADING_TABLEOFLINKS    2
#define PAGING_COMPLETE         3
#define READY_TO_PRINT          4

#define MEMBER(strClass, strMember) \
    strClass.prototype.strMember = strClass##_##strMember

#ifndef DEBUG

#define AssertSz(x, str)
#define PrintDocAlert(str)
#define Transition(nNew, str) this._nStatus = nNew

#else   // ndef DEBUG
#define AssertSz(x, str)    \
    if (!(x))               \
        alert(str)

#define PrintDocAlert(str)  \
    alert("[" + this._strDoc + "," + StatusToString(this._nStatus) + "] " + str )

#define Transition(nNew, str)                                               \
    this._nStatus = nNew;                                                   \
    //PrintDocAlert("Transition status in " + str);
    
#endif      // ndef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\packager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       persist.cxx
//
//  Contents:   Implmentation of Office9 Thicket Save API
//
//----------------------------------------------------------------------------


#include "priv.h"
#include <mshtml.h>
#include <winineti.h>
#include <mlang.h>
// fake out mimeole.h's dll linkage directives for our delay load stuff in dllload.c
#define _MIMEOLE_
#define DEFINE_STRCONST
#include <mimeole.h>
#include "resource.h"
#include "packager.h"
#include "reload.h"

#include <mluisupp.h>

#define DEFINE_STRING_CONSTANTS
#pragma warning( disable : 4207 ) 
#include "htmlstr.h"
#pragma warning( default : 4207 )

const GUID CLSID_IMimeInternational =
{0xfd853cd9, 0x7f86, 0x11d0, {0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4}};

const GUID IID_IMimeInternational =
{0xc5588349, 0x7f86, 0x11d0, {0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4}};

const GUID IID_IMimeBody =
{0xc558834c, 0x7f86, 0x11d0, {0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4}};

// Trident legacy defines...

#define RRETURN(hr) return hr;
#define ReleaseInterface(punk) { if (punk) punk->Release(); punk = NULL; }

// Local prototypes

void RemoveBookMark(WCHAR *pwzURL, WCHAR **ppwzBookMark);
void RestoreBookMark(WCHAR *pwzBookMark);

HRESULT HrGetElement(IHTMLDocument2 *pDoc, LPCSTR pszName, IHTMLElement **ppElem);
HRESULT HrGetBodyElement(IHTMLDocument2 *pDoc, IHTMLBodyElement **ppBody);
HRESULT HrSetMember(LPUNKNOWN pUnk, BSTR bstrMember, BSTR bstrValue);
HRESULT HrGetCollectionOf(IHTMLDocument2 *pDoc, BSTR bstrTagName, IHTMLElementCollection **ppCollect);
HRESULT HrGetCollectionItem(IHTMLElementCollection *pCollect, ULONG uIndex, REFIID riid, LPVOID *ppvObj);
ULONG UlGetCollectionCount(IHTMLElementCollection *pCollect);
HRESULT HrGetMember(LPUNKNOWN pUnk, BSTR bstrMember,LONG lFlags, BSTR *pbstr);
HRESULT HrLPSZToBSTR(LPCSTR lpsz, BSTR *pbstr);
HRESULT HrBSTRToLPSZ(BSTR bstr, LPSTR *lplpsz);
HRESULT HrGetCombinedURL( IHTMLElementCollection *pCollBase,
                          LONG cBase,
                          LONG lElemPos,
                          BSTR bstrRelURL,
                          BSTR bstrDocURL,
                          BSTR *pbstrBaseURL);

class CHashEntry {
public:
    CHashEntry(void) : m_bstrKey(NULL), m_bstrValue(NULL), m_pheNext(NULL) {};
    ~CHashEntry(void)
    {
        if (m_bstrKey)
            SysFreeString(m_bstrKey);
        if (m_bstrValue)
            SysFreeString(m_bstrValue);
    }

    BOOL SetKey(BSTR bstrKey)
    {
        ASSERT(m_bstrKey==NULL);
        m_bstrKey = SysAllocString(bstrKey);
        return m_bstrKey != NULL;
    }

    BOOL SetValue(BSTR bstrValue)
    {
        ASSERT(m_bstrValue==NULL || !StrCmpIW(m_bstrValue, c_bstr_BLANK) ||
               !StrCmpIW(m_bstrValue, bstrValue));
        m_bstrValue = SysAllocString(bstrValue);
        return m_bstrValue != NULL;
    }

    BSTR       m_bstrKey;
    BSTR       m_bstrValue;
    CHashEntry  *m_pheNext;        
};


class CWebArchive
{
public:

    CWebArchive(CThicketProgress* ptp=NULL);
    ~CWebArchive(void);

    virtual HRESULT Init( LPCTSTR lpstrDoc, DWORD dwHashSize );

    virtual HRESULT AddURL( BSTR bstrURL, CHashEntry **pphe ) = 0;
    virtual HRESULT AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc ) = 0;
    virtual HRESULT Find(BSTR bstrF, CHashEntry **pphe);

    virtual HRESULT Commit(void);
    virtual HRESULT Revert(void);

    virtual HRESULT ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc) = 0;
    virtual HRESULT ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc ) = 0;

protected:

    LPTSTR m_lpstrDoc;          // Desintation file for thicket document  
    LPTSTR m_lpstrSafeDoc;      // Temp name of original file, which we delete on Commit()

    CThicketProgress*   m_ptp;

    enum ThURLType {
        thurlMisc,
        thurlHttp,
        thurlFile
    };

    ThURLType _GetURLType( BSTR bstrURL );

    HRESULT _BackupOldFile(void);

    // hash table stuff stolen from MIMEEDIT
    HRESULT _Insert(BSTR bstrI, BSTR bstrThicket, CHashEntry **pphe);
    inline DWORD Hash(LPWSTR psz);

    DWORD       m_cBins;
    CHashEntry  *m_rgBins;
};


class CThicketArchive : public CWebArchive
{
public:

    CThicketArchive(CThicketProgress* ptp=NULL);
    ~CThicketArchive(void);

    virtual HRESULT Init( LPCTSTR lpstrDoc, DWORD dwHashSize );

    virtual HRESULT AddURL( BSTR bstrURL, CHashEntry **pphe );
    virtual HRESULT AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc );

    virtual HRESULT Commit(void);
    virtual HRESULT Revert(void);

    virtual HRESULT ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc);
    virtual HRESULT ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc );

protected:

    LPTSTR m_lpstrFilesDir;     // directory for document's supporting files.
    LPTSTR m_lpstrFilesDirName; // suffix of m_lpstrFilesDir
    LPTSTR m_lpstrSafeDir;      // Temp name of original files directory, which we delete on Commit()
    BOOL   m_fFilesDir;         // TRUE if m_lpstrFilesDir has been created.


    HRESULT _ApplyMarkOfTheWeb( IHTMLDocument2 *pDoc, LPSTREAM pstm, BOOL fUnicode );

    HRESULT _AddHttpEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, LPTSTR lpstrSrcFile=NULL );
    HRESULT _AddFileEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, LPTSTR lpstrSrcFile=NULL );
    HRESULT _AddMiscEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, int cchDstFile );

    HRESULT _PersistHttpURL( BSTR bstrURL, CHashEntry **pphe );
    HRESULT _PersistFileURL( BSTR bstrURL, CHashEntry **pphe );
    HRESULT _PersistMiscURL( BSTR bstrURL, CHashEntry **pphe );

    HRESULT _BackupOldDirectory(void);
    HRESULT _RemoveOldDirectoryAndChildren( LPCWSTR pszDir );

    HRESULT _Insert(BSTR bstrI, LPTSTR lpszFile, int cchFile, CHashEntry **pphe);
};

class CMHTMLArchive : public CWebArchive
{
public:

    CMHTMLArchive(CThicketProgress* ptp=NULL);
    ~CMHTMLArchive(void);

    virtual HRESULT Init( LPCTSTR lpstrDoc, DWORD dwHashSize );

    virtual HRESULT AddURL( BSTR bstrURL, CHashEntry **pphe );
    virtual HRESULT AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc );

    virtual HRESULT ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc);
    virtual HRESULT ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc );

    virtual HRESULT SetCharset(UINT uiCharset, CSETAPPLYTYPE csat, IMimeBody *pBody);

protected:

    HBODY m_hBodyAlt;
    IMimeMessage *m_pimm;
};

/*
 * The following classes implement extended Save As MTHML functionality.
 * Access to the extended functionality is controlled by new MECD_ flags
 * defined in mimeole.h. Clients of the C API in this module should notice
 * mimimal change in its behavior. ( limited to the additional inclusion
 * table and table cell background images ).
 *
 * The root idea is that of a collection packager, which takes a subset
 * of the document.all collection, filters the elements of that subcollection,
 * and marshall's the element data into the MIMEOle document This is patterned
 * after the existing PackageImageData routine, and relies heavily on
 * HrAddImageToMessage, which is much more general than its name implies.
 *
 *
 * Stylesheets introduce some repetition, as the stylesheet OM is similar,
 * but not similar enough, to support common base classes specialized via
 * templates.
 *
 * The process of adding new packagers is pretty straight-forward.
 * [1]  (a) if the packaged attribute is a complete URL, derive from CCollectionPackager
 *      (b) if the attribute is a relative URL, derive from CRelativeURLPackager
 * [2] Implement InitFromCollection. Have it call _InitSubCollection() with the tag name.
 *     See CImagePackager::InitFromCollection() as a simple example.
 * [3] Implement _GetTargetAttribute() to return the attribute you want to package.
 *     You may want to add the string constants for [2] and [3] to htmlstr.h
 * [4] Define an MECD_ control flag, if the thing you're packaging is new.
 * [5] Add a local var of your packager type to CDocumentPackager::PackageDocument.
 * [6] Follow the pattern of the other packagers in CDocumentPackager::PackageDocument
 *
 * For elements with multiple persisted attributes, it's dealer's choice as to how
 * to approach it. Write seperate, simpler packagers for each attribute or write
 * one packager that deals with all of the target element's attributes.
 */



/*
 *  CCollectionPackager - abstract base class for HTML element packagers.
 *      Implements subsampling from the all collection, iteration over the
 *  collection, and basic packaging functionality.
 *
 *      Derived classes must implement InitFromCollection and _GetTargetAttribute.
 *  InitFromCollection - derived class should store the desired subset of the
 *      input collection into the m_pColl data member. _InitSubCollection is
 *      a useful method for this purpose.
 *  _GetTargetAttribute - derived class should return a BSTR naming the attribute
 *      of the element to be packaged.
 *
 */
class CCollectionPackager
{
public:
    virtual ~CCollectionPackager(void);
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL) = 0;
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel = NULL,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100)
    { 
        return _PackageData( pwa, m_pColl, pfCancel, ptp, progLow, progHigh );
    }

protected:

    CCollectionPackager(void) : m_pColl(NULL), m_fAddCntLoc(FALSE) {};

    HRESULT _InitSubCollection(IHTMLElementCollection *pAll,
                              BSTR bstrTagName,
                              IHTMLElementCollection **ppSub,
                              ULONG *pcElems = NULL);

    virtual BSTR _GetTargetAttribute(void) = 0;

    virtual HRESULT _GetElementURL(IHTMLElement *pElem, BSTR *pbstrURL);
    virtual HRESULT _PackageData(CWebArchive *pwa,
                                 IHTMLElementCollection *pColl,
                                 BOOL *pfCancel = NULL,
                                 CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);
    virtual HRESULT _PackageElement(CWebArchive *pwa,
                                    IHTMLElement *pElem);

    IHTMLElementCollection *m_pColl; 
    BOOL                    m_fAddCntLoc;
};

/*
 * CImagePackager - packages the src's of IMG tags.
 */
class CImagePackager : public CCollectionPackager
{
public:
    CImagePackager(void) {};
    virtual ~CImagePackager(void) {};
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL);
protected:

    virtual BSTR _GetTargetAttribute(void);

};

/*
 * CInputImgPackager - packages INPUT type="image"
 */

class CInputImgPackager : public CImagePackager
{
public:
    CInputImgPackager() {}
    virtual ~CInputImgPackager() {}

    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL);
    
};

/*
 * CBGSoundsPackager - packages background sounds
 */

class CBGSoundsPackager : public CCollectionPackager
{
    public:
        CBGSoundsPackager() {};
        virtual ~CBGSoundsPackager() {};

        virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                           ULONG *pcElems = NULL);
protected:

    virtual BSTR _GetTargetAttribute(void);

};
     
/*
 * CAnchorAdjustor - modifies anchor hrefs.
 *
 * Makes them absolute if they point out of the collection.
 */

class CAnchorAdjustor : public CCollectionPackager
{
public:
    CAnchorAdjustor(void) {};
    virtual ~CAnchorAdjustor(void) {};
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL);
protected:

    virtual BSTR _GetTargetAttribute(void);
    virtual HRESULT _PackageElement(CWebArchive *pwa,
                                    IHTMLElement *pElem);
};

/*
 * CAreaAdjustor - modifies AREA hrefs.
 *
 * Makes them absolute if they point out of the collection. Same filter
 * as the anchor adjustor, but different tag.
 */

class CAreaAdjustor : public CAnchorAdjustor
{
public:
    CAreaAdjustor(void) {};
    virtual ~CAreaAdjustor(void) {};
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL);
};

/*
 * CBaseNeutralizer - resets any and all <BASE> tags to the d.
 *
 * No actual packaging goes on here, but we do remap the 
 * <BASE> href.
 */

class CBaseNeutralizer : public CCollectionPackager
{
public:
    CBaseNeutralizer(void) : m_bstrLocal(NULL), m_pTree(NULL) {};
    virtual ~CBaseNeutralizer(void);

    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL )
        { return InitFromCollection( pColl, pcElems, NULL ); };
    HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL,
                                       IHTMLDocument2 *pDoc = NULL);
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel = NULL,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);

protected:

    virtual BSTR _GetTargetAttribute(void);
    virtual HRESULT _PackageElement(CWebArchive *pwa,
                                    IHTMLElement *pElem);

    BSTR m_bstrLocal;
    IMarkupServices *m_pTree;
};

/*
 *  CRelativeURLPackager - abstract base class for packagers
 *      whose element's source attribute returns a relative URL.
 *  This class implements triutils.pp's GetBackgroundImageUrl's
 *  process of attempting to combine the (relative) element URL
 *  with the nearest <BASE> URL. If no <BASE> is availaible, it
 *  uses the document URL.
 *
 *  This class is an abstract base because it does not implement
 *  _GetTargetAttribute. It's implementation of InitFromCollection
 *  isn't very useful and will probably be overridden by derived
 *  classes.
 */

class CRelativeURLPackager : public CCollectionPackager
{
public:
    CRelativeURLPackager(void) : m_pCollBase(NULL), m_cBase(0), m_bstrDocURL(NULL) {};
    virtual ~CRelativeURLPackager(void);
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL)
    {
        return Init( pColl, pcElems, NULL );
    }

    virtual HRESULT Init(IHTMLElementCollection *pColl,
                         ULONG *pcElems,
                         IHTMLDocument2 *pDoc);

protected:

    virtual HRESULT _GetElementURL(IHTMLElement *pElem, BSTR *pbstrURL);

    IHTMLElementCollection  *m_pCollBase; // collection of BASE tags used to complete URLs
    ULONG                   m_cBase;
    BSTR                    m_bstrDocURL;
};

/*
 * CBackgroundPackager - packages the background of BODY, TABLE, TD, and TH.
 *
 * These three tags have a common target attribute.
 */

class CBackgroundPackager : public CRelativeURLPackager
{
public:
    CBackgroundPackager(void) {};
    ~CBackgroundPackager(void) {};
 
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);
protected:

    virtual BSTR _GetTargetAttribute(void);
};

/*
 * CDynSrcPackager - packages the dynsrc of IMG and INPUT.
 *
 * These two tags have a common target attribute.
 */

class CDynSrcPackager : public CRelativeURLPackager
{
public:
    CDynSrcPackager(void) {};
    ~CDynSrcPackager(void) {};
 
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);
protected:

    virtual BSTR _GetTargetAttribute(void);
};


/*
 * CScriptPackager - packages the dynsrc of IMG and INPUT.
 *
 * These two tags have a common target attribute.
 */

class CScriptPackager : public CRelativeURLPackager
{
public:
    CScriptPackager(void) : m_pCollScripts(NULL) {};
    ~CScriptPackager(void) { if (m_pCollScripts) m_pCollScripts->Release(); };
 
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel = NULL,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100)
    { 
        return _PackageData( pwa, m_pCollScripts, pfCancel, ptp, progLow, progHigh );
    }

    virtual HRESULT Init(IHTMLElementCollection *pColl,
                         ULONG *pcElems = NULL,
                         IHTMLDocument2 *pDoc = NULL);
protected:

    virtual BSTR _GetTargetAttribute(void);

    IHTMLElementCollection *m_pCollScripts;

};


/*
 * CFramesPackager - packages the <FRAME> and <IFRAME> sub-documents.
 *
 *  This process is recursive, so all nested frames will be packaged.
 */

class CFramesPackager : public CRelativeURLPackager
{
public:
    CFramesPackager(void) :
        m_pCollFrames(NULL),
        m_pframes2(NULL),
        m_cFrames(0),
        m_iFrameCur(0),
        m_pfCancel(0),
        m_ptp(NULL),
        m_uLow(0),
        m_uHigh(0),
        m_uRangeDoc(0) {};

        virtual ~CFramesPackager(void)
            { 
                if (m_pCollFrames) m_pCollFrames->Release();
                if (m_pframes2) m_pframes2->Release();
            };
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL)
    {
        return CRelativeURLPackager::Init( pColl, pcElems, NULL );
    }

    virtual HRESULT Init(IHTMLElementCollection *pColl,
                         ULONG *pcElems,
                         IHTMLDocument2 *pDoc,
                         IHTMLDocument2 *pDocDesign,
                         CDocumentPackager *pdp);

    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);

protected:

    virtual BSTR _GetTargetAttribute(void);
    virtual HRESULT _PackageElement(CWebArchive *pwa,
                                    IHTMLElement *pElem);

    IHTMLElementCollection *m_pCollFrames;
    IHTMLFramesCollection2 *m_pframes2;
    ULONG   m_cFrames;
    ULONG   m_iFrameCur;
    BOOL    *m_pfCancel;
    CThicketProgress*    m_ptp;
    ULONG   m_uLow;
    ULONG   m_uHigh;
    ULONG   m_uRangeDoc;
    CDocumentPackager *m_pdp;
};

/*
 * CSSPackager - packages imported stylesheets.
 *
 *  Stylesheets have a different OM than document elements, so
 *  we have a packager that looks similar, but works differently
 *  than the other element packagers.
 *
 *  We derive from CRelativeURLPackager for the convenience of 
 *  its Init method and <BASE> collection functionality, which
 *  we also need because the hrefs in style sheets can be relative.
 *
 *  Since we aren't actually packaging elments, the _GetTargetAttribute()
 *  implementation is a formality to satisfy the abstract base class.
 */

class CSSPackager : public CRelativeURLPackager
{
public:
    CSSPackager(void) : m_pDoc(NULL) {};
    ~CSSPackager(void) {};

    HRESULT Init( IHTMLElementCollection *pColl,
                         ULONG *pcElems = NULL,
                         IHTMLDocument2 *pDoc = NULL);

    HRESULT PackageStyleSheets(IHTMLDocument2 *pDoc2, CWebArchive *pwa);

protected:

    BSTR _GetTargetAttribute(void) { ASSERT(FALSE); return NULL; };

    HRESULT _PackageSSCollection(IHTMLStyleSheetsCollection *pssc,
                                         CWebArchive *pwa);
    HRESULT _PackageSS(IHTMLStyleSheet *pss, CWebArchive *pwa);

    IHTMLDocument2 *m_pDoc;
};


// possible hash-table sizes, chosen from primes not close to powers of 2
static const DWORD s_rgPrimes[] = { 29, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593 };

/*
*  class implementation
*/

/*
*  CWebArchive ##################################################
*/

CWebArchive::CWebArchive(CThicketProgress *ptp)
{
    m_lpstrDoc = NULL;
    m_lpstrSafeDoc = NULL;
    
    m_cBins = 0;
    m_rgBins = NULL;

    m_ptp = ptp;
}


CWebArchive::~CWebArchive(void)
{
    CHashEntry *phe, *pheTemp;
    
    if (m_lpstrDoc != NULL)
    {
        LocalFree( m_lpstrDoc );
        m_lpstrDoc = NULL;
    }

    if (m_lpstrSafeDoc != NULL)
    {
        LocalFree( m_lpstrSafeDoc );
        m_lpstrSafeDoc = NULL;
    }
        
    // m_ptp is on loan to us, don't delete it
    
    for (DWORD dw = 0; dw < m_cBins; dw++)
    {
        if (m_rgBins[dw].m_pheNext)
        {
            phe = m_rgBins[dw].m_pheNext;
            while (phe)
            {
                pheTemp = phe;
                phe = phe->m_pheNext;
                delete pheTemp;
            }
        }
    }
    delete[] m_rgBins;
}


HRESULT
CWebArchive::Init( LPCTSTR lpstrDoc, DWORD dwHashSize )
{
    HRESULT hr = S_OK;
    int     i = 0;
    
    m_lpstrDoc = StrDup(lpstrDoc);

    // check for replacement of old file
    if (PathFileExists(m_lpstrDoc))
        hr = _BackupOldFile();
    if (FAILED(hr))
        goto error; 
    
    // Initialize the hash table.
    for (i = 0; i < (ARRAYSIZE(s_rgPrimes) - 1) && s_rgPrimes[i] < dwHashSize; i++);
    ASSERT(s_rgPrimes[i] >= dwHashSize || i == (ARRAYSIZE(s_rgPrimes)-1));
    m_cBins = s_rgPrimes[i];
    
    m_rgBins = new CHashEntry[m_cBins];
    if (m_rgBins==NULL)
        hr = E_OUTOFMEMORY;
    
error:
    
    RRETURN(hr);
}


HRESULT
CWebArchive::Commit()
{
    // clean up old version of file
    if (m_lpstrSafeDoc)
        DeleteFile(m_lpstrSafeDoc);

    return S_OK;
}

HRESULT
CWebArchive::Revert()
{
    if (m_lpstrSafeDoc)
    {
        // we used to use MoveFileEx with MOVEFILE_REPLACE_EXISTING, but MoveFileEx
        // doesn't work on Win9x... so we have to DeleteFile/MoveFile instead...

        DeleteFile(m_lpstrDoc);
        BOOL fMoved = MoveFile(m_lpstrSafeDoc, m_lpstrDoc);

        if (!fMoved)
        {
            ASSERT(FALSE);
            // We shouldn't get into this situtation because we've pre-checked that
            // the original file is not read-only.
            DeleteFile(m_lpstrSafeDoc);
        }
    }

   return S_OK;
}

CWebArchive::ThURLType
CWebArchive::_GetURLType( BSTR bstrURL )
{
//    _tcsncmpi(bstrURL, 4, _T("http",4)
    if ( bstrURL[0] == TEXT('h') &&
         bstrURL[1] == TEXT('t') &&
         bstrURL[2] == TEXT('t') &&
         bstrURL[3] == TEXT('p') )
        return thurlHttp;
    else if ( bstrURL[0] == TEXT('f') &&
              bstrURL[1] == TEXT('i') &&
              bstrURL[2] == TEXT('l') &&
              bstrURL[3] == TEXT('e') )
        return thurlFile;
    else
        return thurlMisc;
}



HRESULT
CWebArchive::_Insert(BSTR bstrI, BSTR bstrThicket, CHashEntry **pphe )
{
    HRESULT hr = S_OK;

    CHashEntry *phe = &m_rgBins[Hash(bstrI)];
    
    ASSERT(pphe != NULL);

    *pphe = NULL;

 
    if (phe->m_bstrKey)
    {        
        CHashEntry *pheNew = new CHashEntry;
        
        if (pheNew==NULL)
            return E_OUTOFMEMORY;

        if (pheNew->SetKey(bstrI) && pheNew->SetValue(bstrThicket))
            *pphe = pheNew;
        else
        {
            delete pheNew;
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pheNew->m_pheNext = phe->m_pheNext;
        phe->m_pheNext = pheNew;
        phe = pheNew;
    } 
    else if (phe->SetKey(bstrI) && phe->SetValue(bstrThicket))
        *pphe = phe;
    else
        hr = E_OUTOFMEMORY;
        
Cleanup:

    return hr;
}

HRESULT
CWebArchive::Find(BSTR bstrF, CHashEntry **pphe)
{
    CHashEntry *phe = &m_rgBins[Hash(bstrF)];

    if (!pphe)
        return E_POINTER;

    *pphe = NULL;

    if (phe->m_bstrKey)
    {
        do
        {
            if (!StrCmpW(phe->m_bstrKey, bstrF))
            {
                ASSERT(phe->m_bstrValue!=NULL);
                *pphe = phe;
                return NOERROR;
            }
            phe = phe->m_pheNext;
        }
        while (phe);
    }
    return E_INVALIDARG;
}


DWORD
CWebArchive::Hash(BSTR bstr)
{
    DWORD h = 0;
    WCHAR *pwch = bstr;
    
    while (*pwch)
        h = ((h << 4) + *pwch++ + (h >> 28));
    return (h % m_cBins);
}

HRESULT
CWebArchive::_BackupOldFile()
{
    HRESULT hr = S_OK;
    TCHAR   chT;
    LPTSTR  lpstrT;
    TCHAR   szT[MAX_PATH];
    DWORD   dwAttrib = GetFileAttributes(m_lpstrDoc);

    if (dwAttrib & FILE_ATTRIBUTE_READONLY)
        return E_ACCESSDENIED;

    lpstrT = PathFindFileName(m_lpstrDoc);
    ASSERT(lpstrT);

    lpstrT--; // back up to the slash
    chT = *lpstrT;
    *lpstrT = 0;
    if (GetTempFileName( m_lpstrDoc, &lpstrT[1], 0,szT ))
    {
        *lpstrT = chT;
        if (CopyFile(m_lpstrDoc, szT, FALSE))
        {
            int cchSafeDoc = lstrlen(szT) + 1;
            m_lpstrSafeDoc = (LPTSTR)LocalAlloc( LMEM_FIXED, sizeof(TCHAR) * cchSafeDoc);
            if (m_lpstrSafeDoc)
                StrCpyN(m_lpstrSafeDoc, szT, cchSafeDoc);
            else
            {
                hr = E_OUTOFMEMORY;
                DeleteFile(szT);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }
    else
    {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

error:
    *lpstrT = chT;
    RRETURN(hr);
}

/*
*  CThicketArchive ##################################################
*/

CThicketArchive::CThicketArchive(CThicketProgress *ptp) : CWebArchive(ptp)
{
    m_lpstrFilesDir = NULL;
    m_lpstrFilesDirName = NULL;
    m_lpstrSafeDir = NULL;
    m_fFilesDir = FALSE;   // TRUE when m_lpstrFilesDir has been created
}


CThicketArchive::~CThicketArchive(void)
{    
    if (m_lpstrFilesDir != NULL)
    {
        LocalFree( m_lpstrFilesDir );
        m_lpstrFilesDir = NULL;
    }

    if (m_lpstrSafeDir != NULL)
    {
        LocalFree( m_lpstrSafeDir );
        m_lpstrSafeDir = NULL;
    }
    
    // m_lpstrFilesDirName points into m_lpstrFilesDir
}


HRESULT
CThicketArchive::Init( LPCTSTR lpstrDoc, DWORD dwHashSize )
{
    HRESULT hr = CWebArchive::Init( lpstrDoc, dwHashSize );
    int     i = 0;
    TCHAR   chT;
    LPTSTR  lpstrT;
    TCHAR   szFmt[MAX_PATH];
    int     cch;
    
    if (FAILED(hr))
        goto error;  
    
    // Build the path to the directory for stored files, like 'Document1 files'.
    lpstrT = PathFindExtension(m_lpstrDoc);
    chT = *lpstrT;
    *lpstrT = 0;
    MLLoadString(IDS_THICKETDIRFMT, szFmt, ARRAYSIZE(szFmt));
    cch = lstrlen(m_lpstrDoc) + lstrlen(szFmt) + 1;
    m_lpstrFilesDir = (LPTSTR)LocalAlloc( LMEM_FIXED, sizeof(TCHAR) * cch );
    if (m_lpstrFilesDir==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    StrCpyN( m_lpstrFilesDir, m_lpstrDoc, cch);
    StrCatBuff( m_lpstrFilesDir, szFmt, cch );

    *lpstrT = chT;  

    // make m_lpstrFilesDirName point to the last component of m_lpstrFilesDir
    for ( i = lstrlen(m_lpstrFilesDir) - 1; i > 0 && m_lpstrFilesDirName == NULL; i-- )
    {
        if ( m_lpstrFilesDir[i-1] == FILENAME_SEPARATOR )
            m_lpstrFilesDirName = &m_lpstrFilesDir[i];
    }

    // check to see if the files dir already exists. If it does, rename the original.
    if (PathFileExists(m_lpstrFilesDir))
        hr = _BackupOldDirectory();
    if (FAILED(hr))
        goto error;
    
error:
    
    RRETURN(hr);
}


HRESULT
CThicketArchive::AddURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    
    hr = THR(Find(bstrURL, pphe));
    
    if (FAILED(hr))
    {
        // first, lets put our document dir in place, if it isn't already
        if (!m_fFilesDir)
            m_fFilesDir = (SHCreateDirectory(NULL, m_lpstrFilesDir) == ERROR_SUCCESS);
        
        if (m_fFilesDir)
        {
            switch (_GetURLType(bstrURL))
            {
            case thurlMisc:
                hr = _PersistMiscURL(bstrURL, pphe);
                break;

            case thurlHttp:
                hr = _PersistHttpURL(bstrURL, pphe);
                break;

            case thurlFile:
                hr = _PersistFileURL(bstrURL, pphe);
                break;
            }
        }
        else
            hr = E_FAIL;
    }
    
    RRETURN(hr);
}

HRESULT
CThicketArchive::AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc )
{
    HRESULT hr;
    
    hr = THR(Find(bstrURL, pphe)); // there's always a slim chance we're reusing a frame.
    
    if (FAILED(hr))
    {
        // first, lets put our document dir in place, if it isn't already
        if (!m_fFilesDir)
            m_fFilesDir = (SHCreateDirectory(NULL, m_lpstrFilesDir) == ERROR_SUCCESS);
        
        if (m_fFilesDir)
        {
            switch (_GetURLType(bstrURL))
            {
            case thurlMisc:
                //hr = _AddMiscEntry(bstrURL, pphe, lpstrFrameDoc);
                // It would be nice if we could just _AddMiscEntry, but if set a frame src
                // to one of the temp files that this produces, we get a 'Do you want to open'
                // prompt, so instead, we'll just keep this funky protocol URL.
                hr = CWebArchive::_Insert( bstrURL, bstrURL, pphe );
                lpstrFrameDoc[0] = 0; // shouldn't be used, anyway
                hr = S_FALSE;         // I told him we all-reddy got one! <snicker>
                break;

            case thurlHttp:
                hr = _AddHttpEntry(bstrURL, pphe, lpstrFrameDoc);
                break;

            case thurlFile:
                hr = _AddFileEntry(bstrURL, pphe, lpstrFrameDoc);
                break;
            }

            if (m_ptp)
                m_ptp->SetSaving( PathFindFileName(lpstrFrameDoc), m_lpstrFilesDir );

        }
        else
        {
            hr = (GetLastError() == ERROR_DISK_FULL) ? (HRESULT_FROM_WIN32(ERROR_DISK_FULL))
                                                     : (E_FAIL);
        }
    }
    else
    {
        LPTSTR lpszThicket;
        lpszThicket = (*pphe)->m_bstrValue;
        PathCombine( lpstrFrameDoc, m_lpstrFilesDir, lpszThicket );
        hr = S_FALSE;
    }
    
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT
CThicketArchive::Commit()
{
    CWebArchive::Commit();

    // clean up obsolete files dir.
    if (m_lpstrSafeDir)
    {
        _RemoveOldDirectoryAndChildren(m_lpstrSafeDir);
    }

    return S_OK;
}

HRESULT
CThicketArchive::Revert()
{
    // clean up file dir

    _RemoveOldDirectoryAndChildren(m_lpstrFilesDir);

    // restore old files dir.
    if (m_lpstrSafeDir)
        MoveFile(m_lpstrSafeDir,m_lpstrFilesDir);
    
    return CWebArchive::Revert();;
}

HRESULT CThicketArchive::ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit* ppsi = NULL;
    IStream*            pstm = NULL;

    hr = SHCreateStreamOnFile(m_lpstrDoc, STGM_WRITE | STGM_CREATE, &pstm);
    if (SUCCEEDED(hr))
    {
        hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void**)&ppsi);
        if (SUCCEEDED(hr))
        {          
            hr = _ApplyMarkOfTheWeb( pDoc, pstm, cpDoc == CP_UNICODE );

            if ( SUCCEEDED(hr) )
                hr = ppsi->Save(pstm, FALSE);
        }
    }
   
    ReleaseInterface(ppsi);
    ReleaseInterface(pstm);
    
    RRETURN(hr);
}

HRESULT CThicketArchive::ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc )
{
    HRESULT hr = S_OK;
    HANDLE  hfile;

    hfile = CreateFile( lpszStyleDoc, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile!=INVALID_HANDLE_VALUE) 
    {
        ULONG   cbWrite, cbWritten;

        cbWrite = lstrlenA(lpszSSText);
        if (!WriteFile( hfile, lpszSSText, cbWrite, &cbWritten, NULL ))
             hr = HRESULT_FROM_WIN32(GetLastError());

        CloseHandle(hfile);
    }
    else
        hr = HRESULT_FROM_WIN32(hr);

    return hr;
}

EXTERN_C HRESULT GetMarkOfTheWeb( LPCSTR, LPCSTR, DWORD, LPSTR *);

HRESULT CThicketArchive::_ApplyMarkOfTheWeb( IHTMLDocument2 *pDoc, LPSTREAM pstm, BOOL fUnicode )
{
    HRESULT hr;
    IInternetSecurityManager *pism = NULL;
    DWORD   dwZone;
    BSTR    bstrURL = NULL;

    hr = pDoc->get_URL( &bstrURL );
    if (FAILED(hr))
        return hr;

    // We only want to mark the document if it isn't already coming from the local
    // file system. If  ( minus the mark ) the file is in the local machine zone,
    // then it was made here, saved with a mark, or created outside our control.
    // If it was saved with a mark, then we want to leave that in place, rather
    // than mark it with the local copy's file: URL.

    hr = CoInternetCreateSecurityManager( NULL, &pism, 0 );
    if (SUCCEEDED(hr) && 
        SUCCEEDED(pism->MapUrlToZone( bstrURL, &dwZone, MUTZ_NOSAVEDFILECHECK)) &&
        dwZone != URLZONE_LOCAL_MACHINE )
    {
        LPSTR   pszMark;
        DWORD   cchURL = WideCharToMultiByte(CP_ACP, 0, bstrURL, -1, NULL, 0, NULL, NULL);
        LPSTR   pszURL = new CHAR[cchURL];

        if (pszURL)
        {
            if (WideCharToMultiByte(CP_ACP, 0, bstrURL, -1, pszURL, cchURL, NULL, NULL))
            {
                int   cch = lstrlen(m_lpstrDoc) + 1;
                LPSTR psz = new char[cch];

                if (psz)
                {
                    SHUnicodeToAnsi(m_lpstrDoc, psz, cch);
                    
                    hr = GetMarkOfTheWeb( pszURL, psz, 0, &pszMark);

                    delete [] psz;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }


                IMarkupServices              *pims = NULL;
                IMarkupPointer               *pimp = NULL;
                IMarkupContainer             *pimc = NULL;
                IHTMLElement                 *pihe = NULL;
                IHTMLElement                 *piheBody = NULL;
                IDispatch                    *pidDocument = NULL;
                IHTMLCommentElement          *pihce = NULL;
                LPWSTR                        pwszMark = NULL;
                BSTR                          bstrMark = NULL;

                hr = pDoc->QueryInterface(IID_IMarkupServices, (void **)&pims);

                if (SUCCEEDED(hr)) {
                    hr = pims->CreateElement(TAGID_COMMENT, NULL, &pihe);

                    if (SUCCEEDED(hr)) {
                        hr = pihe->QueryInterface(IID_IHTMLCommentElement, (void **)&pihce);
                    }

                    if (SUCCEEDED(hr)) {
                        int cbWrite = 0;
                        int cchMark = MultiByteToWideChar(CP_ACP, 0, pszMark, -1, NULL, 0);

                        // cchMark includes the null terminator.
                    
                        pwszMark = new WCHAR[cchMark];
                        if ( pwszMark != NULL )
                        {
                            MultiByteToWideChar( CP_ACP, 0, pszMark, -1, pwszMark, cchMark);
                            cbWrite = (cchMark - 1) * sizeof(WCHAR);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }

                        if (SUCCEEDED(hr))
                        {
                            // force <!-- ... --> style comment
                            hr = pihce->put_atomic(1);
                        }

                    }

                    if (SUCCEEDED(hr)) {
                        bstrMark = SysAllocString(pwszMark);
                        if (NULL != bstrMark)
                        {
                            hr = pihce->put_text(bstrMark);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        
                    }

                    if (SUCCEEDED(hr)) {
                        hr = pims->CreateMarkupPointer(&pimp);
                    }

                    if (SUCCEEDED(hr)) {
                        hr = pDoc->get_body(&piheBody);
                    }

                    if (SUCCEEDED(hr)) {
                        hr = piheBody->get_document(&pidDocument);
                    }

                    if (SUCCEEDED(hr)) {
                        hr = pidDocument->QueryInterface(IID_IMarkupContainer, (void **)&pimc);
                    }

                    if (SUCCEEDED(hr)) {
                        // Move to beginning of doc and insert it
                        hr = pimp->MoveToContainer(pimc, TRUE);

                        if (SUCCEEDED(hr)) {
                            hr = pims->InsertElement(pihe, pimp, pimp);
                        }
                    }
                }

                SAFERELEASE(pims);
                SAFERELEASE(pimc);
                SAFERELEASE(pihe);
                SAFERELEASE(pimp);
                SAFERELEASE(piheBody);
                SAFERELEASE(pidDocument);
                SAFERELEASE(pihce);

                if (bstrMark)
                {
                    SysFreeString(bstrMark);
                }

                if (pwszMark)
                {
                    delete[] pwszMark;
                }
            }
            else
                 hr = HRESULT_FROM_WIN32(GetLastError());

            delete[] pszURL;
        }
        else
            hr = E_OUTOFMEMORY;
    }



    ReleaseInterface(pism);
    if (bstrURL)
        SysFreeString(bstrURL);

    return hr;
}

HRESULT
CThicketArchive::_AddHttpEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, LPTSTR lpstrSrcFile )
{
    HRESULT hr;
    TCHAR   szCacheFile[MAX_PATH];
    LPTSTR  lpszDst;
    LPTSTR  lpszFile;
    int     cchFile;
    LPTSTR  lpszURL;

    lpszURL = bstrURL;

    hr = URLDownloadToCacheFile(NULL, lpszURL, szCacheFile,
                                ARRAYSIZE(szCacheFile), BINDF_FWD_BACK,
                                NULL);
    if (FAILED(hr))
        goto Cleanup;

    if (lpstrSrcFile)
        StrCpyN(lpstrSrcFile, szCacheFile, MAX_PATH);

    PathUndecorate( szCacheFile );

    lpszFile = PathFindFileName( szCacheFile );
    ASSERT(lpszFile != NULL);

    cchFile = ARRAYSIZE(szCacheFile) - (int)(lpszFile-szCacheFile);

    hr = _Insert( bstrURL, lpszFile, cchFile, pphe ); 

    lpszDst = PathCombine( lpstrDstFile, m_lpstrFilesDir, lpszFile );
    ASSERT( lpszDst );

Cleanup:

    RRETURN(hr);
}


HRESULT
CThicketArchive::_AddFileEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, LPTSTR lpstrSrcFile )
{
    HRESULT hr;
    LPTSTR  lpszDst;
    LPTSTR  lpszFile;
    int     cchFile;
    LPTSTR  lpszPath;
    WCHAR   rgchUrlPath[MAX_PATH];
    DWORD   dwLen;

    dwLen = ARRAYSIZE(rgchUrlPath);

    hr = PathCreateFromUrlW(bstrURL, rgchUrlPath, &dwLen, 0);
    if (FAILED(hr))
        return E_FAIL;

    lpszPath = rgchUrlPath;

    if (lpstrSrcFile)
        StrCpyN( lpstrSrcFile, lpszPath, MAX_PATH );

    lpszFile = PathFindFileName( lpszPath );
    ASSERT(lpszFile != NULL);
    cchFile = ARRAYSIZE(rgchUrlPath) - (int)(lpszFile-rgchUrlPath);

    hr = THR(_Insert( bstrURL, lpszFile, cchFile, pphe )); 

    lpszDst = PathCombine( lpstrDstFile, m_lpstrFilesDir, lpszFile );
    ASSERT( lpszDst );

    RRETURN(hr);
}

HRESULT
CThicketArchive::_AddMiscEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, int cchDstFile )
{
    HRESULT hr;
    TCHAR   szT[MAX_PATH];
    LPTSTR  lpszPrefix;
    LPTSTR  lpszDst;

    lpszPrefix = bstrURL;

    if (GetTempFileName( m_lpstrFilesDir, lpszPrefix, 0,szT ))
    {
        lpszDst = PathCombine( lpstrDstFile, m_lpstrFilesDir, szT );
        ASSERT(lpszDst);

        LPTSTR pszFile = PathFindFileName(lpstrDstFile);
        hr = THR(_Insert( bstrURL, pszFile, cchDstFile - (int)(pszFile-lpstrDstFile), pphe ));
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}

HRESULT
CThicketArchive::_PersistHttpURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    TCHAR   szDst[MAX_PATH];
    TCHAR   szSrc[MAX_PATH];

    hr = THR(_AddHttpEntry(  bstrURL, pphe, szDst, szSrc ));
    if (FAILED(hr))
        goto Error;

    if (m_ptp)
        m_ptp->SetSaving( PathFindFileName(szSrc), m_lpstrFilesDir );

    if (!CopyFile(szSrc,szDst, FALSE))
        hr = HRESULT_FROM_WIN32(GetLastError());

Error:
    RRETURN(hr);
}

HRESULT
CThicketArchive::_PersistFileURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    TCHAR   szDst[MAX_PATH];
    TCHAR   szSrc[MAX_PATH];

    hr = THR(_AddFileEntry(  bstrURL, pphe, szDst, szSrc ));
    if (FAILED(hr))
        goto Error;

    if (m_ptp)
        m_ptp->SetSaving( PathFindFileName(szSrc), m_lpstrFilesDir );

    if (!CopyFile(szSrc,szDst, FALSE))
        hr = HRESULT_FROM_WIN32(GetLastError());

Error:
    RRETURN(hr);
}

HRESULT
CThicketArchive::_PersistMiscURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    TCHAR   szDst[MAX_PATH];
    LPTSTR  lpszURL;

    lpszURL = bstrURL;

    hr = THR(_AddMiscEntry(  bstrURL, pphe, szDst, ARRAYSIZE(szDst) ));
    if (FAILED(hr))
        goto Error;

    if (m_ptp)
        m_ptp->SetSaving( PathFindFileName(szDst), m_lpstrFilesDir );

    hr = URLDownloadToFile(NULL, lpszURL, szDst,0, NULL);

Error:
    RRETURN(hr);
}


HRESULT
CThicketArchive::_Insert(BSTR bstrI, LPTSTR lpszFile, int cchFile, CHashEntry **pphe )
{
    HRESULT hr = S_OK;
    BSTR    bstrThicket = NULL;
    TCHAR   buf[MAX_PATH];
    int     i = 0;

    CHashEntry *phe = &m_rgBins[Hash(bstrI)];
    
    ASSERT(pphe != NULL);

    *pphe = NULL;

    if (lstrlen(m_lpstrFilesDir) + lstrlen(lpszFile) + 1 < MAX_PATH)
        wnsprintf( buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s"), m_lpstrFilesDir, lpszFile );
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Defend against bug 18160 - collision of file names in the thicket.
    if ( PathFileExists(buf) )
    {
        TCHAR *pszExt = PathFindExtension(lpszFile);
        int   i = 0;

        // chop the file name into name and extenstion
        if ( pszExt )
        {
            *pszExt = 0;
            pszExt++;
        }

        do
        {
            i++;

            if ( pszExt )
                wnsprintf( buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s(%d).%s"), m_lpstrFilesDir, lpszFile, i, pszExt );
            else
                wnsprintf( buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s(%d)"), m_lpstrFilesDir, lpszFile, i );

        } while ( PathFileExists(buf) && i < 1000 );


        // deviously rewrite the file name for the caller
        StrCpyN( lpszFile, PathFindFileName(buf), cchFile );
    }
    else
        wnsprintf( buf, ARRAYSIZE(buf), TEXT("%s/%s"), m_lpstrFilesDirName, lpszFile );
    
    bstrThicket = SysAllocString(buf);
    if (bstrThicket == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (phe->m_bstrKey)
    {        
        CHashEntry *pheNew = new CHashEntry;
        
        if (pheNew==NULL)
            return E_OUTOFMEMORY;

        if (pheNew->SetKey(bstrI) && pheNew->SetValue(bstrThicket))
            *pphe = pheNew;
        else
        {
            delete pheNew;
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pheNew->m_pheNext = phe->m_pheNext;
        phe->m_pheNext = pheNew;
        phe = pheNew;
    } 
    else if (phe->SetKey(bstrI) && phe->SetValue(bstrThicket))
        *pphe = phe;
    else
        hr = E_OUTOFMEMORY;
        
Cleanup:
    if (bstrThicket)
        SysFreeString(bstrThicket);

    return hr;
}


HRESULT 
CThicketArchive::_BackupOldDirectory()
{
    int n = 1;
    HRESULT hr = S_OK;
    TCHAR szFmt[MAX_PATH];

    // Do we need to do this under critical section?
    MLLoadString(IDS_THICKETTEMPFMT, szFmt, ARRAYSIZE(szFmt));

    do {
        if (m_lpstrSafeDir)
        {
            LocalFree( m_lpstrSafeDir );
            m_lpstrSafeDir = NULL;
        }

        if (n > 100)    // avoid infinite loop!
            break;

        DWORD cchSafeDir = lstrlen(m_lpstrFilesDir) + lstrlen(szFmt) + 1;
        m_lpstrSafeDir = (LPTSTR)LocalAlloc( LMEM_FIXED, sizeof(TCHAR) * cchSafeDir );
        if (m_lpstrSafeDir!=NULL)
        {
            wnsprintf( m_lpstrSafeDir, cchSafeDir, szFmt, m_lpstrFilesDir, n++ );
        }
        else
            hr = E_OUTOFMEMORY;

    } while (SUCCEEDED(hr) && GetFileAttributes(m_lpstrSafeDir) != -1 && n < 1000);

    // rename the old version of the supporting files directory
    if (SUCCEEDED(hr) && !MoveFile(m_lpstrFilesDir, m_lpstrSafeDir))
    {
        LocalFree( m_lpstrSafeDir );
        m_lpstrSafeDir = NULL;

        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

HRESULT
CThicketArchive::_RemoveOldDirectoryAndChildren( LPCWSTR pwzDir )
{
    HRESULT hr = S_OK;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WCHAR wzBuf[MAX_PATH];
    WIN32_FIND_DATAW fd;

    if (!pwzDir)
        goto Exit;

    if (RemoveDirectoryW(pwzDir))
        goto Exit;

    // FindNextFile returns 120, not implemented on OSR2, so we'll have to do all
    // this stuff multibyte

    StrCpyNW(wzBuf, pwzDir, ARRAYSIZE(wzBuf));
    StrCatBuffW(wzBuf, FILENAME_SEPARATOR_STR_W L"*", ARRAYSIZE(wzBuf));

    if ((hf = FindFirstFileW(wzBuf, &fd)) == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    do {

        if ( (StrCmpW(fd.cFileName, L".") == 0) ||
             (StrCmpW(fd.cFileName, L"..") == 0))
            continue;

        wnsprintfW(wzBuf, ARRAYSIZE(wzBuf), L"%s" FILENAME_SEPARATOR_STR_W L"%s", pwzDir, fd.cFileName);

        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            SetFileAttributesW(wzBuf, 
                FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL);

            if (FAILED((hr=_RemoveOldDirectoryAndChildren(wzBuf)))) {
                goto Exit;
            }

        } else {

            SetFileAttributesW(wzBuf, FILE_ATTRIBUTE_NORMAL);
            if (!DeleteFileW(wzBuf)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }


    } while (FindNextFileW(hf, &fd));


    if (GetLastError() != ERROR_NO_MORE_FILES) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (hf != INVALID_HANDLE_VALUE) {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }

    // here if all subdirs/children removed
    /// re-attempt to remove the main dir
    if (!RemoveDirectoryW(pwzDir)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:

    if (hf != INVALID_HANDLE_VALUE)
        FindClose(hf);

    RRETURN(hr);
}



/*
 *  CMHTMLArchive ##################################################
 */

CMHTMLArchive::CMHTMLArchive(CThicketProgress *ptp) :
    CWebArchive(ptp),
    m_hBodyAlt(NULL),
    m_pimm(NULL)
{
}


CMHTMLArchive::~CMHTMLArchive(void)
{  
    ReleaseInterface(m_pimm);
}


HRESULT
CMHTMLArchive::Init( LPCTSTR lpstrDoc, DWORD dwHashSize )
{
    HRESULT hr = S_OK;
  
    MimeOleSetCompatMode(MIMEOLE_COMPAT_MLANG2);
  
    if ( m_pimm == NULL )
    {
        hr = CWebArchive::Init( lpstrDoc, dwHashSize );
        if (SUCCEEDED(hr))
            hr = MimeOleCreateMessage(NULL, &m_pimm);
    }

    RRETURN(hr);
}


HRESULT
CMHTMLArchive::AddURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    
    hr = THR(Find(bstrURL, pphe));
    
    if (FAILED(hr))
    {       
        IStream     *pstm = NULL;
        CHAR        szUrl[INTERNET_MAX_URL_LENGTH];
        WCHAR       wzArchiveText[MAX_SAVING_STATUS_TEXT + 1];
        WCHAR       wzBuf[INTERNET_MAX_URL_LENGTH + MAX_SAVING_STATUS_TEXT + 1];
        LPSTR       lpszCID=0;
        DWORD       dwAttach = URL_ATTACH_SET_CNTTYPE; 

        SHUnicodeToAnsi(bstrURL, szUrl, ARRAYSIZE(szUrl));

        // hack: if it's an MHTML: url then we have to fixup to get the cid:
        if (StrCmpNIA(szUrl, "mhtml:", 6)==0)
        {
            LPSTR lpszBody;

            if (SUCCEEDED(MimeOleParseMhtmlUrl(szUrl, NULL, &lpszBody)))
            {
                StrCpyNA(szUrl, lpszBody, INTERNET_MAX_URL_LENGTH);
                CoTaskMemFree(lpszBody);
            }
        }

        MLLoadStringW(IDS_SAVING_STATUS_TEXT, wzArchiveText,
                      ARRAYSIZE(wzArchiveText));

        wnsprintfW(wzBuf, ARRAYSIZE(wzBuf), L"%ws: %ws", wzArchiveText, bstrURL);
        m_ptp->SetSaveText(wzBuf);

#ifndef WIN16  //RUN16_BLOCK - NOT YET AVAILABLE
        hr = URLOpenBlockingStreamW(NULL, bstrURL, &pstm, 0, NULL);
#else
        hr = MIME_E_URL_NOTFOUND;
#endif

        if (SUCCEEDED(hr))
        {
            HBODY hBody;

            hr = m_pimm->AttachURL(NULL, szUrl, dwAttach, pstm, &lpszCID, &hBody);

            if (SUCCEEDED(hr))
                hr = _Insert( bstrURL, bstrURL, pphe );
        }

        ReleaseInterface(pstm);
    }
    
    RRETURN(hr);
}

HRESULT
CMHTMLArchive::AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc )
{
    HRESULT hr;
    
    hr = THR(Find(bstrURL, pphe)); // there's always a slim chance we're reusing a frame.
    
    if (FAILED(hr))
    {     
        // insert place-holder
        hr = _Insert(bstrURL, c_bstr_BLANK, pphe);  
    }
    
    return hr; // no RRETURN - may return S_FALSE
}



HRESULT
CMHTMLArchive::ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit* ppsi = NULL;
    PROPVARIANT             variant;
    FILETIME                filetime;
    WCHAR                   wzBuffer[MAX_BUFFER_LEN];
    WCHAR                   wzArchiveText[MAX_SAVING_STATUS_TEXT + 1];
    WCHAR                   wzBuf[INTERNET_MAX_URL_LENGTH + MAX_SAVING_STATUS_TEXT + 1];

    // Set the MIME subject header

    PropVariantClear(&variant);
    variant.vt = VT_LPWSTR;
    hr = pDoc->get_title(&variant.pwszVal);
    if (SUCCEEDED(hr))
    {
        hr = m_pimm->SetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), 0,
                                 &variant);
        SAFEFREEBSTR(variant.pwszVal);
    }

    // Set the MIME date header

    if (SUCCEEDED(hr))
    {
        hr = CoFileTimeNow(&filetime);
    }

    if (SUCCEEDED(hr))
    {
        PropVariantClear(&variant);
        variant.vt = VT_FILETIME;
        variant.filetime = filetime;
        hr = m_pimm->SetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_DATE), 0,
                                 &variant);
    }

    // Set the MIME from header

    if (SUCCEEDED(hr))
    {
        MLLoadStringW(IDS_MIME_SAVEAS_HEADER_FROM, wzBuffer,
                      ARRAYSIZE(wzBuffer));

        PropVariantClear(&variant);
        variant.vt = VT_LPWSTR;
        variant.pwszVal = wzBuffer;
        hr = m_pimm->SetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), 0,
                                 &variant);
    }
    
    hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void**)&ppsi);
    if (SUCCEEDED(hr))
    {
        IStream *pstm = NULL;

        hr = MimeOleCreateVirtualStream( &pstm );
        if ( SUCCEEDED(hr) )
        {
            HBODY hBody;
            hr = ppsi->Save(pstm, FALSE);


            if (SUCCEEDED(hr))
            {
                BSTR    bstrDocURL = NULL;
                WCHAR  *pwzBookMark = NULL;
                
                pDoc->get_URL(&bstrDocURL);
                RemoveBookMark(bstrDocURL, &pwzBookMark);

                if (!StrCmpIW(bstrDocURL, URL_ABOUT_BLANK))
                {
                    // We got about:blank as the URL (because the doc has
                    // document.write's etc in it). We can't save this!
                    hr = E_FAIL;
                    goto Exit;
                }

                MLLoadStringW(IDS_SAVING_STATUS_TEXT, wzArchiveText,
                              ARRAYSIZE(wzArchiveText));
        
                wnsprintfW(wzBuf, ARRAYSIZE(wzBuf), L"%ws: %ws", wzArchiveText, bstrDocURL);
                m_ptp->SetSaveText(wzBuf);


                if (fFrameDoc)
                {
                    CHAR    szURL[INTERNET_MAX_URL_LENGTH];
                    LPSTR   lpszCID = NULL;
                    DWORD   dwAttach = URL_ATTACH_SET_CNTTYPE; 
        
                    szURL[0] = 0;

        
                    if (WideCharToMultiByte(CP_ACP, 0, bstrDocURL, -1, szURL, INTERNET_MAX_URL_LENGTH, NULL, NULL))
                    {

                        hr = m_pimm->AttachURL(NULL, szURL, dwAttach,
                                               pstm, &lpszCID, &hBody);

                        if (SUCCEEDED(hr) && cpDoc)
                        {
                            IMimeBody         *pBody = NULL;

                            hr = m_pimm->BindToObject(hBody, IID_IMimeBody,
                                                      (LPVOID *)&pBody);
                            if (SUCCEEDED(hr))
                            {
                                hr = SetCharset(cpDoc, CSET_APPLY_TAG_ALL, pBody);
                            }
                            pBody->Release();
                        }

                        if (SUCCEEDED(hr))
                        {
                            CHashEntry *phe;

                            LPWSTR  pwz = NULL;
                            int     iLen = 0;

                            // If it is ASP, it is actually HTML
            
                            iLen = lstrlenW(bstrDocURL);
            
                            if (iLen) {
                                pwz = StrRChrW(bstrDocURL, bstrDocURL + iLen, L'.');
                            }
            
            
                            if (pwz && !StrCmpIW(pwz, TEXT(".asp")))
                            {
                                PROPVARIANT             propvar;

                                PropVariantClear(&propvar);
                                propvar.vt = VT_LPSTR;
                                propvar.pszVal = "text/html";
                                hr = m_pimm->SetBodyProp(hBody,
                                                         PIDTOSTR(PID_HDR_CNTTYPE),
                                                         0, &propvar);
                            }

                            if ( m_hBodyAlt == NULL )
                                m_hBodyAlt = hBody;

                            // update the place-holder hash entry
                            hr = Find( bstrDocURL, &phe);
                            if (SUCCEEDED(hr))
                            {
                                ASSERT(phe != NULL);
                                phe->SetValue( bstrDocURL );
                            }
                        }
                    }
                    else
                         hr = HRESULT_FROM_WIN32(GetLastError());

                }
                else
                {
                    hr = m_pimm->SetTextBody( TXT_HTML, IET_INETCSET, m_hBodyAlt, pstm, &hBody);
                    // The main text was the last thing we were waiting for
                    if (SUCCEEDED(hr) && cpDoc)
                    {
                        IMimeBody         *pBody = NULL;

                        hr = m_pimm->BindToObject(hBody, IID_IMimeBody,
                                                  (LPVOID *)&pBody);
                        if (SUCCEEDED(hr))
                        {
                            hr = SetCharset(cpDoc, CSET_APPLY_TAG_ALL, pBody);
                        }
                        pBody->Release();
                    }

                    if (SUCCEEDED(hr))
                    {
                        IPersistFile *pipf = NULL;
                        // Initialzie PropVariant
                        PROPVARIANT rVariant;
                        rVariant.vt = VT_LPWSTR;
                        rVariant.pwszVal = (LPWSTR)bstrDocURL;
                        // Add a content location, so we can use it for security later.
                        hr = m_pimm->SetBodyProp( hBody, STR_HDR_CNTLOC, 0, &rVariant );
                        if (SUCCEEDED(hr))
                        {
                            hr = m_pimm->QueryInterface(IID_IPersistFile, (LPVOID *)&pipf);
                            if (SUCCEEDED(hr))
                            {
                                LPWSTR lpwszFile;
                                lpwszFile = m_lpstrDoc;
                                hr = pipf->Save(lpwszFile, FALSE);

                                SAFERELEASE(pipf);
                            }
                        }

                        ReleaseInterface(pstm);
                    }
                }

                if ( bstrDocURL )
                {
                    // Restore Bookmark
                    RestoreBookMark(pwzBookMark);
                    SysFreeString(bstrDocURL);
                }
            }

            ReleaseInterface(pstm);
        }
    }
   
    ReleaseInterface(ppsi);

Exit:
    
    RRETURN(hr);
}

HRESULT
CMHTMLArchive::ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc )
{
    HRESULT hr;
    BSTR    bstrDocURL = NULL;
    CHAR    szURL[INTERNET_MAX_URL_LENGTH];
    LPSTR   lpszCID = NULL;
    DWORD   dwAttach = URL_ATTACH_SET_CNTTYPE;
    HBODY   hBody;
    IStream *pstm = NULL;
    ULONG cbWrite, cbWritten;

    hr = MimeOleCreateVirtualStream( &pstm );
    if (FAILED(hr))
        return hr;

    cbWrite = lstrlenA(lpszSSText);
    pstm->Write(lpszSSText, cbWrite, &cbWritten);
    ASSERT(cbWritten==cbWrite);

    //if (dwFlags & MECD_CNTLOCATIONS)
    //    dwAttach |= URL_ATTACH_SET_CNTLOCATION;

    szURL[0] = 0;

    if (WideCharToMultiByte(CP_ACP, 0, bstrCSSUrl, -1, szURL, INTERNET_MAX_URL_LENGTH, NULL, NULL))
    {

        hr = m_pimm->AttachURL(NULL, szURL, dwAttach,
                                 pstm, &lpszCID, &hBody);

        if (SUCCEEDED(hr))
        {
            CHashEntry *phe;

            // update the place-holder hash entry
            hr = Find(bstrCSSUrl, &phe);

            ASSERT(SUCCEEDED(hr) && phe != NULL);

            phe->SetValue( bstrCSSUrl );
        }
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    ReleaseInterface(pstm);

    return hr;
}

HRESULT CMHTMLArchive::SetCharset(UINT uiCharset, CSETAPPLYTYPE csat,
                                  IMimeBody *pBody)
{
    HRESULT                        hr = E_FAIL;
    HCHARSET                       hCharset;
    IMimeInternational            *pimi = NULL;
    
    hr = CoCreateInstance(CLSID_IMimeInternational,
                          NULL, CLSCTX_INPROC_SERVER,
                          IID_IMimeInternational, (LPVOID*)&pimi);
    if (SUCCEEDED(hr))
    {
        hr = pimi->GetCodePageCharset(uiCharset, CHARSET_WEB, &hCharset);
    }

    if (SUCCEEDED(hr))
    {
        hr = pBody->SetCharset(hCharset, csat);
    }
                            
    if (pimi)
    {
        pimi->Release();
    }

    return hr;
}

/*
*  CThicketProgress ##################################################
*/

CThicketProgress::CThicketProgress( HWND hDlg )
{
    TCHAR szFmt[MAX_PATH];
    int   cchPctFmt;

    m_hDlg = hDlg;
    m_hwndProg = GetDlgItem(hDlg, IDC_THICKETPROGRESS);

    MLLoadString(IDS_THICKETSAVINGFMT, szFmt, ARRAYSIZE(szFmt) );
    m_cchSavingFmt = lstrlen(szFmt);
    m_pszSavingFmt = new TCHAR[m_cchSavingFmt+1];
    if (m_pszSavingFmt != NULL)
    {
        StrCpyN( m_pszSavingFmt, szFmt, m_cchSavingFmt+1 );
    }

    MLLoadString(IDS_THICKETPCTFMT, szFmt, ARRAYSIZE(szFmt));
    cchPctFmt = lstrlen(szFmt);
    m_pszPctFmt = new TCHAR[cchPctFmt+1];
    if (m_pszPctFmt != NULL)
    {
        StrCpyN( m_pszPctFmt, szFmt, cchPctFmt+1 );
    }

    m_ulPct = 0;
}

CThicketProgress::~CThicketProgress(void)
{
    if (m_pszSavingFmt)
        delete[] m_pszSavingFmt;

    if (m_pszPctFmt)
        delete[] m_pszPctFmt;

}

void CThicketProgress::SetPercent( ULONG ulPct )
{
    TCHAR szBuf[MAX_PATH];

    szBuf[0] = TEXT('\0');

    if ( ulPct > 100 )
        ulPct = 100;

    if ( ulPct > m_ulPct ) // prevent retrograde motion.
    {
        m_ulPct = ulPct;
        if (m_pszPctFmt != NULL)
        {
            wnsprintf( szBuf, ARRAYSIZE(szBuf), m_pszPctFmt, m_ulPct );
        }
        SetDlgItemText(m_hDlg, IDC_THICKETPCT, szBuf);
        SendMessage(m_hwndProg, PBM_SETPOS, m_ulPct, 0);
    }
}

void CThicketProgress::SetSaving( LPCTSTR szFile, LPCTSTR szDst )
{
    TCHAR szPath[30];
    TCHAR szBuf[MAX_PATH*2];
    LPCTSTR psz;

    szBuf[0] = TEXT('\0');

    if (PathCompactPathEx( szPath, szDst, 30, 0 ))
    {
        psz = szPath;
    }
    else
    {
        psz = szDst;
    }

    if (m_pszSavingFmt != NULL)
    {
        wnsprintf( szBuf, ARRAYSIZE(szBuf), m_pszSavingFmt, szFile, psz );
    }

    SetDlgItemText(m_hDlg, IDC_THICKETSAVING, szBuf);
}

void CThicketProgress::SetSaveText(LPCTSTR szText)
{
    if (szText)
    {
        SetDlgItemText(m_hDlg, IDC_THICKETSAVING, szText);
    }
}

/*
*  CCollectionPackager ##################################################
*/

CCollectionPackager::~CCollectionPackager(void)
{
    if (m_pColl)
        m_pColl->Release();
}


HRESULT CCollectionPackager::_GetElementURL(IHTMLElement *pElem, BSTR *pbstrURL)
{
    HRESULT         hr;
    VARIANT         rVar;
    
    ASSERT (pElem);
    
    rVar.vt = VT_BSTR;
    
    // Note that _GetTargetAttribute is a virtual method, so the derived class
    // specifies what attribute to fetch.
    
    hr = THR(pElem->getAttribute(_GetTargetAttribute(), VARIANT_FALSE, &rVar));
    if (SUCCEEDED(hr))
    {
        if (rVar.vt == VT_BSTR && rVar.bstrVal != NULL)
            *pbstrURL = rVar.bstrVal;
        else
            hr = S_FALSE;
    }
    
    return hr; // no RRETURN - may return S_FALSE
}


HRESULT CCollectionPackager::_PackageData(CWebArchive *pwa,
                                          IHTMLElementCollection *pColl,
                                          BOOL *pfCancel,
                                          CThicketProgress *ptp, ULONG progLow, ULONG progHigh)
{
    HRESULT        hr = S_OK;
    ULONG          uElem,
                   cElems,
                   uRange = progHigh - progLow;
    IHTMLElement   *pElem;
    
    cElems = UlGetCollectionCount(pColl);
    
    // Iterate over the collection, packaging each element in turn.
    
    for (uElem=0; uElem<cElems && SUCCEEDED(hr) ; uElem++)
    {
        hr = THR(HrGetCollectionItem(pColl, uElem, IID_IHTMLElement, (LPVOID *)&pElem));
        if (SUCCEEDED(hr))
        {
            hr = _PackageElement(pwa, pElem ); // no THR - may return S_FALSE
            pElem->Release();
        }

        if (pfCancel && *pfCancel)
            hr = E_ABORT;

        if (ptp && uRange)
            ptp->SetPercent( progLow + (uRange * uElem) / cElems );
    }
    
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT CCollectionPackager::_PackageElement(CWebArchive *pwa,
                                             IHTMLElement *pElem)
{
    HRESULT        hr = S_OK;
    BSTR           bstrURL = NULL;
    BOOL           fBadLinks=FALSE;
    CHashEntry     *phe;
    
    hr = _GetElementURL(pElem, &bstrURL);
    if (hr == S_OK && bstrURL && bstrURL[0])
    {
        // PTH hr = HrAddImageToMessage(pMsgSrc, pMsgDst, pHash, bstrURL, &bstrURLThicket, m_fAddCntLoc);
        hr = pwa->AddURL( bstrURL, &phe );

        if (SUCCEEDED(hr))
        {
            hr = THR(HrSetMember(pElem, _GetTargetAttribute(), phe->m_bstrValue));
        }
        else
            hr = THR(HrSetMember(pElem, _GetTargetAttribute(), c_bstr_EMPTY));
    }

    if (bstrURL)
        SysFreeString(bstrURL);


    return hr; 
}


HRESULT CCollectionPackager::_InitSubCollection(IHTMLElementCollection *pAll,
                                                BSTR bstrTagName,
                                                IHTMLElementCollection **ppSub,
                                                ULONG *pcElems)
{
    IDispatch              *pDisp=NULL;
    VARIANT                 TagName;
    HRESULT                 hr = S_FALSE;

    ASSERT (ppSub);
    ASSERT(pAll);

    *ppSub = NULL;
    
    TagName.vt = VT_BSTR;
    TagName.bstrVal = bstrTagName;
    if (NULL == TagName.bstrVal)
        hr = E_INVALIDARG;
    else
    {
        hr = pAll->tags(TagName, &pDisp);
    }
    
    if (pDisp)
    {
        hr = pDisp->QueryInterface(IID_IHTMLElementCollection,
            (void **)ppSub);
        pDisp->Release();
    }
    
    if (pcElems)
    {
        if (hr == S_OK)
            *pcElems = UlGetCollectionCount(*ppSub);
        else
            *pcElems = 0;
    }
    
    RRETURN(hr);
}

/*
*  CImagePackager ##################################################
*/


HRESULT CImagePackager::InitFromCollection(IHTMLElementCollection *pColl,
                                           ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_IMG, &m_pColl, pcElems);
}

BSTR CImagePackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_SRC;
}

/*
*  CInputImgPackager ##################################################
*/

HRESULT CInputImgPackager::InitFromCollection(IHTMLElementCollection *pColl,
                                              ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_INPUT, &m_pColl, pcElems);
}

/*
*  CBGSoundsPackager ##################################################
*/

HRESULT CBGSoundsPackager::InitFromCollection(IHTMLElementCollection *pColl,
                                              ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_BGSOUND, &m_pColl, pcElems);
}

BSTR CBGSoundsPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_SRC;
}

/*
*  CAnchorAdjustor ##################################################
*/


HRESULT CAnchorAdjustor::InitFromCollection(IHTMLElementCollection *pColl,
                                            ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_ANCHOR, &m_pColl, pcElems);
}

BSTR CAnchorAdjustor::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_HREF;
}

HRESULT CAnchorAdjustor::_PackageElement(CWebArchive *pwa,
                                         IHTMLElement *pElem)
{
    HRESULT        hr = S_OK;
    BSTR           bstrURL = NULL;
    BSTR           bstrThicket = NULL;
    BOOL           fBadLinks=FALSE;
    CHashEntry     *phe;
    
    // leave intra-doc urls and <A name=> alone
    // seanf(2/11/98) : haven't seen a local # link come through here yet. 
    hr = _GetElementURL(pElem, &bstrURL);
    if (hr != S_OK || bstrURL == NULL || bstrURL[0] == '#' || bstrURL[0] == 0)
        goto error;
    
    // See if the target is something we have in the thicket, like an <A> in frame A
    // targetting the page saved for frame B.
    ASSERT(pwa);

    hr = pwa->Find(bstrURL, &phe);
    if (SUCCEEDED(hr))
        bstrThicket = phe->m_bstrValue;
    else
    {
        // not in the thicket, so make both URLs the same.
        bstrThicket = bstrURL;
        hr = S_OK;
    }

    if (hr == S_OK)
        hr = THR(HrSetMember(pElem, _GetTargetAttribute(), bstrThicket));
    
error:
    
    if (bstrURL)
        SysFreeString(bstrURL);

    // don't free bstrThicket, its either bstrURL, or belongs to the thicket hash table.
    
    return hr; 
}

/*
*  CAreaAdjustor ##################################################
*/


HRESULT CAreaAdjustor::InitFromCollection(IHTMLElementCollection *pColl,
                                            ULONG *pcElems)
{
    return _InitSubCollection(pColl, (BSTR)c_bstr_AREA, &m_pColl, pcElems);
}

/*
*  CBaseNeutralizer ##################################################
*/

CBaseNeutralizer::~CBaseNeutralizer(void)
{
    if (m_bstrLocal)
        SysFreeString(m_bstrLocal);
 
    if (m_pTree)
        m_pTree->Release();
}

HRESULT CBaseNeutralizer::InitFromCollection(IHTMLElementCollection *pColl,
                                             ULONG *pcElems,
                                             IHTMLDocument2 *pDoc )
{
    if ( pDoc != NULL )
    {
        if ( m_pTree )
        {
            m_pTree->Release();
            m_pTree = NULL;
        }
        pDoc->QueryInterface(IID_IMarkupServices, (void**)&m_pTree);
    }

    return _InitSubCollection(pColl, (BSTR)c_bstr_BASE, &m_pColl, pcElems);
}


BSTR CBaseNeutralizer::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_HREF;
}

HRESULT CBaseNeutralizer::PackageData(CWebArchive *pwa, BOOL *pfCancel,
                                      CThicketProgress *ptp,
                                      ULONG progLow, ULONG progHigh)
{
    HRESULT        hr = S_OK;
    ULONG          uElem,
                   cElems,
                   uRange = progHigh - progLow;
    IHTMLElement   *pElem;
    
    cElems = UlGetCollectionCount(m_pColl);
    
    // Iterate over the collection, packaging each element in turn.
    
    for (uElem=0; uElem<cElems && SUCCEEDED(hr) ; uElem++)
    {
        hr = THR(HrGetCollectionItem(m_pColl, 0, IID_IHTMLElement, (LPVOID *)&pElem));
        if (SUCCEEDED(hr))
        {
            hr = _PackageElement(pwa, pElem ); // no THR - may return S_FALSE
            pElem->Release();
        }

        if (pfCancel && *pfCancel)
            hr = E_ABORT;

        if (ptp && uRange)
            ptp->SetPercent( progLow + (uRange * uElem) / cElems );
    }
    
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT CBaseNeutralizer::_PackageElement(CWebArchive *pwa,
                                          IHTMLElement *pElem)
{
    HRESULT        hr = S_FALSE;

    // NOTE: There's seems to be no retouching that will make this work.
    //         Tried setting BASE to ".", ".\", "". It has to be absolute,
    //         which would anchor the thicket to one location in the file
    //         system. The solution here is to use the base to fix the
    //         other rel URLs in the doc, then whack the base tags.
    if ( m_pTree )
    {
        //OLD NOTE: Tree Services can't remove a head element yet, so 
        //        wait to enable this pending Joe Beda/EricVas work.
        hr = m_pTree->RemoveElement( pElem );
    }

    return hr; // no RRETURN - may return S_FALSE
}

/*
*  CRelativeURLPackager ##################################################
*/


CRelativeURLPackager::~CRelativeURLPackager(void)
{
    if (m_pCollBase)
        m_pCollBase->Release();
    
    if (m_bstrDocURL)
        SysFreeString(m_bstrDocURL);
}


HRESULT CRelativeURLPackager::Init(IHTMLElementCollection *pColl,
                                   ULONG *pcElems,
                                   IHTMLDocument2 *pDoc)
{
    HRESULT hr = S_OK;
    
    // Hold on to the outer collection, we'll subsample it later.
    m_pColl = pColl;
    
    if (m_pColl)
    {
        m_pColl->AddRef();
        hr = _InitSubCollection( m_pColl, (BSTR)c_bstr_BASE, &m_pCollBase, &m_cBase );
    }
    
    if (SUCCEEDED(hr) && pDoc)
    {
        hr = pDoc->get_URL( &m_bstrDocURL );
    }
    
    RRETURN(hr);
}

HRESULT CRelativeURLPackager::_GetElementURL(IHTMLElement *pElem, BSTR *pbstrURL)
{
    HRESULT             hr = S_FALSE;
    LONG                lElemPos;
    BSTR                bstr = NULL;
    
    
    ASSERT (pbstrURL);
    *pbstrURL = 0;
    
    hr = CCollectionPackager::_GetElementURL(pElem, &bstr);
    if (hr==S_OK)
    {
        if (bstr==NULL)
            hr = S_FALSE;
        else
        {
            hr = pElem->get_sourceIndex(&lElemPos);
            ASSERT(SUCCEEDED(hr));
            hr = HrGetCombinedURL(m_pCollBase, m_cBase, lElemPos, bstr, m_bstrDocURL, pbstrURL);
            SysFreeString(bstr);
        }
    }
    
    return hr; // no RRETURN - may return S_FALSE
}

/*
*  CBackgroundPackager ##################################################
*/


HRESULT CBackgroundPackager::PackageData(CWebArchive *pwa,
                                         BOOL *pfCancel,
                                         CThicketProgress *ptp, ULONG progLow, ULONG progHigh)
{
    HRESULT hr = S_OK;
    IHTMLElementCollection *pColl = NULL;
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_BODY, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_TABLE, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel);
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_TD, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_TH, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
error:
    
    if (pColl)
        pColl->Release();
    
    return hr; // no RRETURN - may return S_FALSE
}


BSTR CBackgroundPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_BACKGROUND;
}


/*
*  CDynSrcPackager ##################################################
*/


HRESULT CDynSrcPackager::PackageData(CWebArchive *pwa,
                                          BOOL *pfCancel,
                                          CThicketProgress *ptp, ULONG progLow, ULONG progHigh)
{
    HRESULT hr = S_OK;
    IHTMLElementCollection *pColl = NULL;
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_IMG, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_INPUT, &pColl);
    if (SUCCEEDED(hr))
    {
        if (hr==S_OK)
            hr = _PackageData( pwa, pColl, pfCancel );
        if (FAILED(hr))
            goto error;
        pColl->Release();
        pColl = NULL;
    }
    
    
error:
    
    if (pColl)
        pColl->Release();
    
    return hr; // no RRETURN - may return S_FALSE
}


BSTR CDynSrcPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_DYNSRC;
}


/*
*  CScriptPackager ##################################################
*/


HRESULT CScriptPackager::Init(IHTMLElementCollection *pColl,
                              ULONG *pcElems,
                              IHTMLDocument2 *pDoc)
{
    HRESULT hr = CRelativeURLPackager::Init(pColl, NULL, pDoc);

    if (SUCCEEDED(hr))
        hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_SCRIPT, &m_pCollScripts, pcElems );

    return hr;
}


BSTR CScriptPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_SRC;
}

/*
*  CFramesPackager ##################################################
*/

HRESULT CFramesPackager::Init(IHTMLElementCollection *pColl,
                              ULONG *pcElems,
                              IHTMLDocument2 *pDoc,
                              IHTMLDocument2 *pDocDesign,
                              CDocumentPackager *pdp)
{
    HRESULT hr = CRelativeURLPackager::Init(pColl, NULL, pDocDesign);

    if (SUCCEEDED(hr))
    {
        m_pdp = pdp;
        // Get the element collection for the frames.
        // Note: If documents have frames, they are either all
        // <FRAME>s _OR_ all <IFRAME>s.
        hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_FRAME, &m_pCollFrames, &m_cFrames);
        if (FAILED(hr) || m_cFrames == 0)
        {
            if (m_pCollFrames)
                m_pCollFrames->Release();
            hr = _InitSubCollection(m_pColl, (BSTR)c_bstr_IFRAME, &m_pCollFrames, &m_cFrames);
        }

        if (pcElems)
            *pcElems = m_cFrames;

        // To traverse a framseset that spans multiple domains, we need to approach it
        // via the "unsecured" window object, which is only accessible via Invoke.
        if (SUCCEEDED(hr) && m_cFrames > 0)
        {
            DISPPARAMS dispparams;
            VARIANT VarResult;
            VariantInit(&VarResult);
            ZeroMemory(&dispparams, sizeof(dispparams));

            hr = pDoc->Invoke(DISPID_WINDOWOBJECT,
                              IID_NULL,
                              0,
                              DISPATCH_PROPERTYGET,
                              &dispparams,
                              &VarResult,
                              NULL,
                              NULL );

            if( SUCCEEDED(hr) )
            {
                // Code in iedisp.cpp's  GetDelegateOnIDispatch was really paranoid about this,
                // so we'll be similarly cautious.
                if( (VarResult.vt == VT_DISPATCH || VarResult.vt == VT_UNKNOWN)
                    && VarResult.pdispVal )
                {
                    IHTMLWindow2 *pwin2 = NULL;

                    hr = VarResult.pdispVal->QueryInterface( IID_IHTMLWindow2, (LPVOID*)&pwin2);
                    if (SUCCEEDED(hr))
                    {
                        hr = pwin2->get_frames(&m_pframes2);
                        pwin2->Release();
                    }
                } // if we really got an interface
                else
                    hr = E_FAIL;

                VariantClearLazy( &VarResult );
            } // if we can get the un-secured window object
        } // if we have frames
    } // if base initialization succeeded

    return hr;
}


HRESULT CFramesPackager::PackageData(CWebArchive *pwa,
                                          BOOL *pfCancel,
                                          CThicketProgress *ptp, ULONG progLow, ULONG progHigh)
{
    HRESULT hr = S_OK;
    //ULONG   cColl = 0;
    
    if (m_cFrames == 0)
        return S_OK; // Trident will get confused if we return a non-S_OK success code
    
    m_iFrameCur = 0; // index of frame in window.frames and all.tags("FRAME");
    m_pfCancel = pfCancel;
    m_ptp = ptp;
    m_uLow = progLow;
    m_uHigh = progHigh; 
    
    m_uRangeDoc = (progHigh - progLow) / m_cFrames;
    hr = _PackageData( pwa, m_pCollFrames, pfCancel );
        
    return hr; // no RRETURN - may return S_FALSE
}


BSTR CFramesPackager::_GetTargetAttribute(void)
{
    return (BSTR)c_bstr_SRC;
}

HRESULT CFramesPackager::_PackageElement(CWebArchive *pwa,
                                         IHTMLElement *pElem)
{
    HRESULT        hr = S_OK;
    BSTR           bstrURL = NULL;
    BOOL           fBadLinks=FALSE;
    IHTMLDocument2 *pDocFrame = NULL;
    //IWebBrowser    *pwb = NULL;
    IDispatch      *pDisp = NULL;
    IHTMLWindow2   *pwin2 = NULL;
    VARIANT        varIndex;
    VARIANT        varFrame;
    WCHAR         *pwzBookMark = NULL;
    
    ASSERT(pElem);
    ASSERT(pwa);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_iFrameCur;
    hr = m_pframes2->item( &varIndex, &varFrame );
    if (FAILED(hr))
        goto error;
    // The variant should give us an IHTMLWindow2, but we'll treat it as a Disp anyway
    ASSERT(varFrame.vt & VT_DISPATCH);
    pDisp = varFrame.pdispVal;
    hr = pDisp->QueryInterface(IID_IHTMLWindow2, (LPVOID*)&pwin2 );
    if (FAILED(hr))
        goto error;

    hr = pwin2->get_document(&pDocFrame);

#ifdef OLD_THICKET

    hr = pElem->QueryInterface(IID_IWebBrowser, (void**)&pwb);
    if (FAILED(hr))
        goto error;
    
    hr = pwb->get_Document( &pDisp );
    if (FAILED(hr))
        goto error;
    else if ( pDisp == NULL )
    {
        hr = S_FALSE;
        goto error;
    }
    
    hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDocFrame);
    if (FAILED(hr))
        goto error;

#endif // OLD_THICKET

    if (SUCCEEDED(hr) && SUCCEEDED(pDocFrame->get_URL(&bstrURL)) && bstrURL && bstrURL[0])
    {
        TCHAR       szFrameDoc[MAX_PATH];
        CHashEntry  *phe;
        
        RemoveBookMark(bstrURL, &pwzBookMark);

        hr = pwa->AddFrameOrStyleEntry( bstrURL, &phe, szFrameDoc );
        if (hr==S_OK)
        {
            ULONG uLowDoc = m_uLow + m_iFrameCur * m_uRangeDoc;
            ULONG uHighDoc = uLowDoc + m_uRangeDoc;
            CWebArchive *pwaFrame = m_pdp->GetFrameDocArchive( pwa );
            
            if ( pwaFrame != NULL )
            {
                BSTR               bstrCharSetSrc = NULL;
                MIMECSETINFO       csetInfo;
                IMultiLanguage2   *pMultiLanguage = NULL;

                hr = pDocFrame->get_charset(&bstrCharSetSrc);
                if (FAILED(hr))
                    goto error;
            
                hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IMultiLanguage2, (void**)&pMultiLanguage);
                if (FAILED(hr))
                {
                    goto error;
                }
            
                hr = pMultiLanguage->GetCharsetInfo(bstrCharSetSrc, &csetInfo);
                pMultiLanguage->Release();

                if (FAILED(hr))
                {
                    goto error;
                }

                hr = m_pdp->_PackageDocument(pDocFrame, szFrameDoc, m_pfCancel, m_ptp, 
                                             uLowDoc, uHighDoc, csetInfo.uiInternetEncoding,
                                             pwaFrame, m_pdp, TRUE );
                if (SUCCEEDED(hr))
                    hr = THR(HrSetMember(pElem, _GetTargetAttribute(), phe->m_bstrValue));
                else
                    fBadLinks = TRUE;

                if ( pwaFrame != pwa ) // only delete if new one was made (thicket)
                    delete pwaFrame;
            }
            else
                hr = E_OUTOFMEMORY;
        } // if the location matched the element URL
        else if (hr==S_FALSE)
        {
            // This is a repeat - we don't need to do most of the work, but we
            // do need to record the element for remapping.
            hr = THR(HrSetMember(pElem, _GetTargetAttribute(), phe->m_bstrValue));
        }
    } // if we got the frame's doc's URL
    else // if ( hr == DISP_E_MEMBERNOTFOUND ) // frame is non-trident docobj
    {
        IHTMLLocation *ploc = NULL;

        // For a non-trident doc-obj, get the file, if possible, and put it in the thicket.

        hr = pwin2->get_location( &ploc );
        if (SUCCEEDED(hr) &&
            SUCCEEDED(hr = ploc->get_href( &bstrURL )))
        {
            if (bstrURL && bstrURL[0])
            {
                CHashEntry  *phe;
                // PTH hr = HrAddImageToMessage(pMsgSrc, pMsgDst, pHash, bstrURL, &bstrURLThicket, m_fAddCntLoc);
                hr = pwa->AddURL( bstrURL, &phe );
                if (!FAILED(hr))
                {
                    hr = THR(HrSetMember(pElem, _GetTargetAttribute(), phe->m_bstrValue));
                }
            }
            else
                hr = S_FALSE;
        }
        ReleaseInterface(ploc);
    }
    
error:
    //ReleaseInterface(pwb);
    ReleaseInterface(pwin2);
    ReleaseInterface(pDisp);
    ReleaseInterface(pDocFrame);

    if (bstrURL) {
        RestoreBookMark(pwzBookMark);
        SysFreeString(bstrURL); // bstrFrameURL);
    }
    
    m_iFrameCur++;

    return hr;
}

/*
*  CDocumentPackager ##################################################
*/

HRESULT CDocumentPackager::PackageDocument(IHTMLDocument2 *pDoc,
                                           LPCTSTR lpstrDoc,
                                           BOOL *pfCancel, CThicketProgress *ptp,
                                           ULONG progLow, ULONG progHigh,
                                           UINT cpDst,
                                           CWebArchive *pwa)
{
    HRESULT hr = S_OK;

    m_ptp = ptp;

    switch (m_iPackageStyle)
    {
    case PACKAGE_THICKET:
        {
            CThicketArchive thicket(ptp);

            hr = _PackageDocument( pDoc, lpstrDoc, pfCancel, ptp, progLow, progHigh, cpDst, &thicket, this, FALSE );
        }
        break;

    case PACKAGE_MHTML:
        {
            CMHTMLArchive *pmhtmla = (CMHTMLArchive *)pwa; // sleazy downcast
    
            if (pwa == NULL)
                pmhtmla = new CMHTMLArchive(ptp);

            if (pmhtmla != NULL)
            {
                hr = _PackageDocument( pDoc, lpstrDoc, pfCancel, ptp, progLow, progHigh, cpDst,
                                       pmhtmla, this, FALSE );

                // if pwa is NULL, then we created a CMHTMLArchive for
                // use in _PackageDocument which we now need to clean up
                if (pwa == NULL)
                    delete pmhtmla;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;

    case PACKAGE_HTML:
        // fall through - Trident will do the right thing by sniffing the 
        // extension.
    case PACKAGE_TEXT:
        {
            if (SUCCEEDED(hr))
            {
                IHTMLDocument2 *pDocDesign = NULL;
                IHTMLDocument2 *pDocSave = NULL;
                IPersistFile *ppf = NULL;

                if (cpDst == CP_ACP)
                {
                    // No encoding change, use the browse doc
                    pDocSave = pDoc;
                }
                else
                {
                    hr = _GetDesignDoc( pDoc, &pDocDesign, pfCancel, ptp, cpDst);

                    if (SUCCEEDED(hr))
                    {
                        pDocSave = pDocDesign;
                    }
                    else
                    {
                        return E_FAIL;
                    }
                }
                
                // Trident IPersistFile::Save looks at the extension to determine if it's
                // an HTML or text save.

                hr = pDocSave->QueryInterface(IID_IPersistFile, (void**)&ppf);

                if (SUCCEEDED(hr))
                {
                    LPCWSTR lpwszFile;
                    lpwszFile = lpstrDoc;
                    BSTR bstrURL = NULL;
                    WCHAR wzSavingText[MAX_SAVING_STATUS_TEXT + 1];
                    WCHAR wzBuf[INTERNET_MAX_URL_LENGTH + MAX_SAVING_STATUS_TEXT + 1];

                    hr = pDocSave->get_URL(&bstrURL);

                    if (SUCCEEDED(hr))
                    {

                        MLLoadStringW(IDS_SAVING_STATUS_TEXT, wzSavingText,
                                      ARRAYSIZE(wzSavingText));
                
                        wnsprintfW(wzBuf, ARRAYSIZE(wzBuf),
                                   L"%ws: %ws", wzSavingText, bstrURL);
                        ptp->SetSaveText(wzBuf);
                    
                        if (bstrURL)
                        {
                            SysFreeString(bstrURL);
                        }
                    }

                    hr = ppf->Save( lpwszFile, FALSE );
                    ppf->SaveCompleted(lpwszFile);

                    ppf->Release();
                }

                if (cpDst != CP_ACP)
                {
                    pDocSave->Release();
                }

                // If we used the browse-time pDoc, we don't need to release
                // it because it is released by CThicketUI::ThicketUIThreadProc
            }
        }
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return hr;
}

HRESULT CDocumentPackager::_PackageDocument(IHTMLDocument2 *pDoc,
                                            LPCTSTR lpstrDoc,
                                            BOOL *pfCancel, CThicketProgress *ptp,
                                            ULONG progLow, ULONG progHigh,
                                            UINT cpDst,
                                            CWebArchive *pwa,
                                            CDocumentPackager *pdpFrames,
                                            BOOL fFrameDoc)
{
    HRESULT                 hr = S_OK;
    ULONG                   cImages;
    ULONG                   cInputImgs;
    ULONG                   cBGSounds;
    ULONG                   cFrames;
    ULONG                   uRange = progHigh - progLow;
    ULONG                   uRangeThis;
    ULONG                   uLow, uHigh;
    IHTMLElementCollection  *pCollect = NULL;
    CImagePackager          imgPkgr;
    CInputImgPackager       inputimgPkgr;
    CBGSoundsPackager       bgsPkgr;
    CBackgroundPackager     bkgndPkgr;
    CBaseNeutralizer        baseNeut;
    CAnchorAdjustor         anchorAdj;
    CAreaAdjustor           areaAdj;
    CFramesPackager         framesPkgr;
    CSSPackager             stylesheetPkgr;
    CDynSrcPackager         dynsrcPkgr;
    CScriptPackager         scriptPkgr;
    IHTMLDocument2          *pDocDesign = NULL;
    BYTE                     abBuffer[MAX_BUFFER_LEN];
    DWORD                    dwType = 0;
    DWORD                    dwSize = 0;
    BOOL                     bDLImages = TRUE;
    HKEY                     hkey = 0;
    IOleCommandTarget       *pIOCT = NULL;

    if (pDoc==NULL)
        return E_INVALIDARG;

    hr = _GetDesignDoc( pDoc, &pDocDesign, pfCancel, ptp, cpDst );
    if (FAILED(hr))
        goto error;

    // HACK! If you have a unicode character in the filename, when we
    // call put_href on the CSS, trident tries to download this. The
    // invalid character is sent to the server, who sends badddddd
    // stuff, which the CSS parser doesn't understand. The result is
    // that trident falls on the floor. This tells trident not to download
    // the CSS hence avoiding the problem.

    hr = pDocDesign->QueryInterface(IID_IOleCommandTarget, (void **)&pIOCT);

    if (SUCCEEDED(hr) && pIOCT)
    {
        pIOCT->Exec(NULL, OLECMDID_DONTDOWNLOADCSS, OLECMDID_DONTDOWNLOADCSS,
                    NULL, NULL);
        pIOCT->Release();
    }

    hr = pDocDesign->get_all(&pCollect);
    if (FAILED(hr))
        RRETURN(hr);
    
    dwSize = MAX_BUFFER_LEN;
    if (RegOpenKey(HKEY_CURRENT_USER, REGPATH_MSIE_MAIN, &hkey) == ERROR_SUCCESS)
    {
        if (SHQueryValueExA(hkey, REGVALUE_DOWNLOAD_IMAGES, 0, &dwType,
                            abBuffer, &dwSize) == NO_ERROR)
        {
            bDLImages = !StrCmpIA((char *)abBuffer, "yes");
        }

        RegCloseKey(hkey);
    }

    if (bDLImages)
    {
        // pack all the images into the message and remember the Thicket mappings
        hr = imgPkgr.InitFromCollection(pCollect, &cImages);
        if (FAILED(hr))
            goto error;

        hr = inputimgPkgr.InitFromCollection(pCollect, &cInputImgs);
        if (FAILED(hr))
            goto error;

    }

    hr = bgsPkgr.InitFromCollection(pCollect, &cBGSounds);
    if (FAILED(hr))
        goto error;
   
    hr = bkgndPkgr.Init(pCollect, NULL, pDocDesign);
    if (FAILED(hr))
        goto error;

    hr = dynsrcPkgr.Init(pCollect, NULL, pDocDesign);
    if (FAILED(hr))
        goto error;

    hr = stylesheetPkgr.Init(pCollect, NULL, pDocDesign);
    if (FAILED(hr))
        goto error;

    hr = framesPkgr.Init(pCollect, &cFrames, pDoc, pDocDesign, this);
    if (FAILED(hr))
        goto error;

    hr = scriptPkgr.Init(pCollect, NULL, pDocDesign);
    if (FAILED(hr))
        goto error;

    hr = pwa->Init(lpstrDoc, cImages + cInputImgs + cFrames);
    if (FAILED(hr))
        goto error;

    // herewith commences the hackery to drive the progess bar.
    // If we have frames we devide the progress range among all the docs involved.
    // We'll neglect style sheets and devote the range for the immediate
    // document to the image collection.
    uRangeThis = uRange / (cFrames + 1);

    uLow = progLow;
    uHigh = progLow + uRangeThis;
    
    if (bDLImages)
    {
        hr = imgPkgr.PackageData(pwa, pfCancel, ptp, uLow, uHigh);
        if (FAILED(hr))
            goto error;

        hr = inputimgPkgr.PackageData(pwa, pfCancel, ptp, uLow, uHigh);
        if (FAILED(hr))
            goto error;
    }

    hr = bgsPkgr.PackageData(pwa, pfCancel, ptp, uLow, uHigh);
    if (FAILED(hr))
        goto error;
     
    hr = bkgndPkgr.PackageData(pwa, pfCancel);
    if (FAILED(hr))
        goto error;

    hr = dynsrcPkgr.PackageData(pwa, pfCancel);
    if (FAILED(hr))
        goto error;
    
    hr = stylesheetPkgr.PackageStyleSheets(pDocDesign, pwa);
    if (FAILED(hr))
        goto error;
 
    uLow = progHigh - uRangeThis;
    uHigh = progHigh;

    hr = framesPkgr.PackageData(pwa, pfCancel, ptp, uLow, uHigh);
    if (FAILED(hr))
        goto error;

    hr = scriptPkgr.PackageData(pwa, pfCancel);
    if (FAILED(hr))
        goto error;
                
    // we want to do this after frames s.t. the frame docs will be in the thicket
    // and we can correctly direct a targetted hyperlink from frame A to frame B
    // if the href is in the thicket vs. still out on the Web.
    hr = anchorAdj.InitFromCollection(pCollect);
    if (FAILED(hr))
        goto error;
    
    hr = anchorAdj.PackageData(pwa, pfCancel); // not that we need the thicket...
    if (FAILED(hr))
        goto error;  
    
    hr = areaAdj.InitFromCollection(pCollect);
    if (FAILED(hr))
        goto error;
    
    hr = areaAdj.PackageData(pwa, pfCancel); // not that we need the thicket...
    if (FAILED(hr))
        goto error;   

 
    // Now that we've got everybody remapped, short-circuit the base tags
    // and redirect to the current directory.
    hr = baseNeut.InitFromCollection(pCollect, NULL, pDocDesign );
    if (FAILED(hr))
        goto error;
    
    hr = baseNeut.PackageData(pwa, pfCancel);
    if (FAILED(hr))
        goto error;
        
    //if(dwFlags & MECD_HTML || dwFlags & MECD_PLAINTEXT)
    {
        hr = pwa->ArchiveDocumentText( pDocDesign, cpDst, fFrameDoc );
        if (FAILED(hr))
            goto error;
    }

    
error:
    
    if (pCollect)
        pCollect->Release();

    if (pDocDesign)
        pDocDesign->Release();

    if (pfCancel && *pfCancel)
        hr = E_ABORT;

    if (SUCCEEDED(hr))
        pwa->Commit();
    else
        pwa->Revert();
    
    return hr;
}

CWebArchive *CDocumentPackager::GetFrameDocArchive(CWebArchive *pwaSrc)
{
    CWebArchive *pwa = NULL;

    if (m_iPackageStyle == PACKAGE_THICKET)
        pwa = new CThicketArchive(m_ptp);
    else if (m_iPackageStyle == PACKAGE_MHTML)
        pwa = pwaSrc;
    else
        ASSERT(FALSE);

    return pwa;
}

HRESULT CDocumentPackager::_GetDesignDoc( IHTMLDocument2 *pDocSrc, IHTMLDocument2 **ppDocDesign,
                                          BOOL *pfCancel, CThicketProgress *ptp, UINT cpDst )
{
    HRESULT            hr;
    DWORD              dwFlags;
    BSTR               bstrURL = NULL;
    BSTR               bstrCharSetSrc = NULL;
    MIMECSETINFO       csetInfo;
    IMultiLanguage2   *pMultiLanguage = NULL;
    CUrlDownload      *pud = NULL;
    ULONG              cRef = 0;
    DWORD              dwUrlEncodingDisableUTF8;
    DWORD              dwSize = SIZEOF(dwUrlEncodingDisableUTF8);
    BOOL               fDefault = FALSE;

    hr = pDocSrc->get_charset(&bstrCharSetSrc);
    if (FAILED(hr))
        goto Cleanup;

    hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER,
                          IID_IMultiLanguage2, (void**)&pMultiLanguage);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = pMultiLanguage->GetCharsetInfo(bstrCharSetSrc, &csetInfo);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    
    if (FAILED(pDocSrc->get_URL( &bstrURL )))
        goto Cleanup;

    pud = new CUrlDownload( ptp, &hr, csetInfo.uiInternetEncoding );

    if (pud == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppDocDesign = NULL;

    // seanf(2/6/98): Review DLCTL_ flags.
    dwFlags = DLCTL_NO_SCRIPTS | DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_FRAMEDOWNLOAD |
              DLCTL_SILENT | DLCTL_OFFLINE;

    SHRegGetUSValue(REGSTR_PATH_INTERNET_SETTINGS,
        TEXT("UrlEncoding"), NULL, (LPBYTE) &dwUrlEncodingDisableUTF8, &dwSize, FALSE, (LPVOID) &fDefault, SIZEOF(fDefault));

    if (dwUrlEncodingDisableUTF8)
    {
        dwFlags |= DLCTL_URL_ENCODING_DISABLE_UTF8;
    }
    else
    {
        dwFlags |= DLCTL_URL_ENCODING_ENABLE_UTF8;
    }

    hr = pud->SetDLCTL(dwFlags);
    if (SUCCEEDED(hr))
        hr = pud->BeginDownloadURL2( bstrURL, BDU2_BROWSER, BDU2_NONE, NULL, 0xF0000000 );

    if (SUCCEEDED(hr))
    {
        MSG msg;

        hr = S_FALSE;

        while (hr==S_FALSE)
        {
            GetMessage(&msg, NULL, 0, 0);
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            if (*pfCancel)
            {
                pud->AbortDownload();
                hr = E_ABORT;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pud->GetDocument( ppDocDesign );

            // Set the document to the codepage the user has selected.
            // Don't bother if it's no specific page has been directed, as is the case
            // with frame documents and in cases where the user kept the default
            // code page selected in the Save As... dialog.
            if (SUCCEEDED(hr) && cpDst != CP_ACP)
            {
                MIMECPINFO  cpInfo;
                BSTR        bstrCharSet = NULL;
                LANGID      langid;

                langid = MLGetUILanguage();

                if ( SUCCEEDED(pMultiLanguage->GetCodePageInfo(cpDst, langid, &cpInfo)) &&
                     (bstrCharSet = SysAllocString(cpInfo.wszWebCharset)) != NULL )
                    hr = (*ppDocDesign)->put_charset(bstrCharSet);

                ASSERT(SUCCEEDED(hr));

                if (bstrCharSet)
                    SysFreeString(bstrCharSet);
            }
        }
    }

    pud->DoneDownloading();

    cRef = pud->Release();

    if (SUCCEEDED(hr))
    {
        IOleCommandTarget *pioct;

        hr = pDocSrc->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pioct);
        if (SUCCEEDED(hr))
        {
            VARIANTARG v;

            v.vt = VT_UNKNOWN;
            v.punkVal = *ppDocDesign;

            hr = pioct->Exec( &CGID_ShortCut, CMDID_SAVEASTHICKET, OLECMDEXECOPT_DODEFAULT, &v, NULL );

            pioct->Release();
        }
    }

Cleanup:

    SAFERELEASE(pMultiLanguage);

    if (bstrURL)
        SysFreeString(bstrURL);

    if (bstrCharSetSrc)
        SysFreeString(bstrCharSetSrc);

    if (FAILED(hr))
    {
        if (ppDocDesign != NULL)
        {
            ReleaseInterface((*ppDocDesign));
        }
    }

    return hr;
}

/*
*  CSSPackager ##################################################
*/

HRESULT CSSPackager::Init(IHTMLElementCollection *pColl,
                          ULONG *pcElems,
                          IHTMLDocument2 *pDoc)
{
    HRESULT hr = CRelativeURLPackager::Init( pColl, pcElems, pDoc );
            
    m_pDoc = pDoc;

    RRETURN(hr);
}


HRESULT CSSPackager::PackageStyleSheets(IHTMLDocument2 *pDoc2,
                                        CWebArchive *pwa)
{
    HRESULT hr = S_OK;
    IHTMLStyleSheetsCollection *pssc = NULL;
    
    ASSERT(pDoc2);
    ASSERT(pwa);
    
    // process the inline style sheets
    hr = pDoc2->get_styleSheets( &pssc );
    if (SUCCEEDED(hr))
    {
        hr = _PackageSSCollection(pssc, pwa);
        pssc->Release();
    }
    
    return hr; // no RRETURN - may return S_FALSE
}


HRESULT CSSPackager::_PackageSSCollection(IHTMLStyleSheetsCollection *pssc,
                                          CWebArchive *pwa)
{
    HRESULT hr;
    LONG cSS;
    
    hr = pssc->get_length( &cSS );
    if (SUCCEEDED(hr))
    {
        LONG iSS;
        
        for (iSS = 0; iSS < cSS && SUCCEEDED(hr); iSS++ )
        {
            VARIANT varIndex;
            VARIANT varSS;
            
            varIndex.vt = VT_I4;
            varIndex.lVal = iSS;
            varSS.vt = VT_EMPTY;
            hr = pssc->item( &varIndex, &varSS );
            if (SUCCEEDED(hr) && varSS.vt == VT_DISPATCH && varSS.pdispVal != NULL)
            {
                IHTMLStyleSheet *pss = NULL;
                if(SUCCEEDED(varSS.pdispVal->QueryInterface(IID_IHTMLStyleSheet, (void**)&pss)))
                {
                    hr = _PackageSS(pss, pwa); 
                    pss->Release();
                }
                varSS.pdispVal->Release();
            }
        }
    }
    return hr; // no RRETURN - may return S_FALSE
}


HRESULT CSSPackager::_PackageSS(IHTMLStyleSheet *pss,
                                CWebArchive *pwa)
{
    HRESULT     hr;
    BSTR        bstrRelURL = NULL;
    BSTR        bstrAbsURL = NULL;
    LONG        lElemPos;
    IHTMLElement *pElemOwner = NULL;
    IHTMLStyleSheetsCollection *pssc = NULL;
    BOOL        fStyleTag = FALSE;
    
    if (pss == NULL || pwa == NULL)
        return E_INVALIDARG;
    
    hr = pss->get_href(&bstrRelURL);
    if (FAILED(hr))
        goto error;
    fStyleTag = bstrRelURL == NULL || *bstrRelURL == 0;
    
    hr = pss->get_owningElement(&pElemOwner);
    if (FAILED(hr))
        goto error;
    
    hr = pElemOwner->get_sourceIndex(&lElemPos);
    if (FAILED(hr))
        goto error;
    
    hr = HrGetCombinedURL(m_pCollBase, m_cBase, lElemPos, bstrRelURL, m_bstrDocURL, &bstrAbsURL);
    if (FAILED(hr))
        goto error;
    
    // First we do the defualt processing, gathering the imports into _our_
    
    // process the inline style sheets
    hr = pss->get_imports( &pssc );
    if (SUCCEEDED(hr))
    {
        long cSS;
        
        hr = pssc->get_length( &cSS );
        if (SUCCEEDED(hr) && cSS > 0)
        {
            CSSPackager importPkgr;
            
            hr = importPkgr.Init(m_pCollBase, NULL, m_pDoc);
            
            hr = importPkgr._PackageSSCollection(pssc, pwa);
        }
        pssc->Release();
    }
    
    // oh, yeah, if we want to do background-image and list-style-image, we'd enumerate this ss's rule styles
    // here, find the ones with these attributes, and build a list of IHTML rule style, maybe using some sub-obj
    // like an image packager.
    
    if (SUCCEEDED(hr) && !fStyleTag)
    {
        BSTR    bstrSSText;
        
        // Now we grab our modified text and add it to the document.
        hr = pss->get_cssText(&bstrSSText);
        if (SUCCEEDED(hr) && bstrSSText != NULL)
        {
            LPSTR lpszSSText;
            
            // This text needs to be ANSI before we put it into the stream.
            hr = HrBSTRToLPSZ( bstrSSText, &lpszSSText );
            if (SUCCEEDED(hr))
            {
                // PTH hr = MimeOleCreateVirtualStream(&pstm);
                TCHAR       szStyleDoc[MAX_PATH];
                CHashEntry  *phe;

                hr = pwa->AddFrameOrStyleEntry( bstrAbsURL, &phe, szStyleDoc );
                
                if (hr==S_OK)
                {
                    hr = pwa->ArchiveCSSText( bstrAbsURL, lpszSSText, szStyleDoc );

                    if ( SUCCEEDED(hr) )
                        hr = pss->put_href(phe->m_bstrValue);
                }
                else if (hr==S_FALSE)
                {
                    // repeated style sheet, don't need to do all the work, but do need to note
                    // the ss for remapping
                    hr = pss->put_href( phe->m_bstrValue);
                }
                delete lpszSSText;
            }
            SysFreeString(bstrSSText);
        }
    }
    
error:
    if (pElemOwner)
        pElemOwner->Release();
    if (bstrRelURL)
        SysFreeString(bstrRelURL);
    if (bstrAbsURL)
        SysFreeString(bstrAbsURL);
    
    return hr; // no RRETURN - may return S_FALSE
}

//
// Functions ##############################################################
//

HRESULT HrGetElement(IHTMLDocument2 *pDoc, LPCSTR pszName, IHTMLElement **ppElem)
{
    HRESULT                 hr = E_FAIL;
    IHTMLElementCollection *pCollect = NULL;
    IDispatch              *pDisp = NULL;
    VARIANTARG              va1, va2;
    
    if (pDoc)
    {
        pDoc->get_all(&pCollect);
        if (pCollect)
        {
            if (SUCCEEDED(HrLPSZToBSTR(pszName, &va1.bstrVal)))
            {
                va1.vt = VT_BSTR;
                va2.vt = VT_EMPTY;
                pCollect->item(va1, va2, &pDisp);
                if (pDisp)
                {
                    hr = pDisp->QueryInterface(IID_IHTMLElement, (LPVOID*)ppElem);
                    pDisp->Release();
                }
                SysFreeString(va1.bstrVal);
            }
            pCollect->Release();
        }
    }
    return hr; // no RRETURN - may return S_FALSE
    
}


HRESULT HrGetBodyElement(IHTMLDocument2 *pDoc, IHTMLBodyElement **ppBody)
{
    HRESULT         hr=E_FAIL;
    IHTMLElement    *pElem=0;
    
    if (ppBody == NULL)
        return E_INVALIDARG;
    
    *ppBody = 0;
    if (pDoc)
    {
        pDoc->get_body(&pElem);
        if (pElem)
        {
            hr = pElem->QueryInterface(IID_IHTMLBodyElement, (LPVOID *)ppBody);
            pElem->Release();
        }
    }
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT HrGetMember(LPUNKNOWN pUnk, BSTR bstrMember,LONG lFlags, BSTR *pbstr)
{
    IHTMLElement    *pObj;
    HRESULT         hr;
    VARIANT         rVar;
    
    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pObj);
    if (SUCCEEDED(hr))
    {
        ASSERT (pObj);
        
        rVar.vt = VT_BSTR;
        hr = pObj->getAttribute(bstrMember, lFlags, &rVar);
        if (SUCCEEDED(hr) && rVar.vt == VT_BSTR && rVar.bstrVal != NULL)
        {
            *pbstr = rVar.bstrVal;
        }
        pObj->Release();
    }
    return hr; // no RRETURN - may return S_FALSE
}



ULONG UlGetCollectionCount(IHTMLElementCollection *pCollect)
{
    ULONG   ulCount=0;
    
    if (pCollect)
        pCollect->get_length((LONG *)&ulCount);
    
    return ulCount;
}

HRESULT HrGetCollectionItem(IHTMLElementCollection *pCollect, ULONG uIndex, REFIID riid, LPVOID *ppvObj)
{
    HRESULT     hr=E_FAIL;
    IDispatch   *pDisp=0;
    VARIANTARG  va1,
        va2;
    
    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
    va1.lVal = (LONG)uIndex;
    
    pCollect->item(va1, va2, &pDisp);
    if (pDisp)
    {
        hr = pDisp->QueryInterface(riid, ppvObj);
        pDisp->Release();
    }
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT HrGetCollectionOf(IHTMLDocument2 *pDoc, BSTR bstrTagName, IHTMLElementCollection **ppCollect)
{
    VARIANT                 v;
    IDispatch               *pDisp=0;
    IHTMLElementCollection  *pCollect=0;
    HRESULT                 hr;
    
    ASSERT(ppCollect);
    ASSERT(bstrTagName);
    ASSERT(pDoc);
    
    *ppCollect = NULL;
    
    hr = pDoc->get_all(&pCollect);
    if (pCollect)
    {
        v.vt = VT_BSTR;
        v.bstrVal = bstrTagName;
        pCollect->tags(v, &pDisp);
        if (pDisp)
        {
            hr = pDisp->QueryInterface(IID_IHTMLElementCollection, (LPVOID *)ppCollect);
            pDisp->Release();
        }
        pCollect->Release();
    }
    else if (S_OK == hr)
        hr = E_FAIL;
    
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT HrSetMember(LPUNKNOWN pUnk, BSTR bstrMember, BSTR bstrValue)
{
    IHTMLElement    *pObj;
    HRESULT         hr;
    VARIANT         rVar;
    
    ASSERT(pUnk);

    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pObj);
    if (SUCCEEDED(hr))
    {
        ASSERT (pObj);
        rVar.vt = VT_BSTR;
        rVar.bstrVal = bstrValue;
        hr = pObj->setAttribute(bstrMember, rVar, FALSE);
        pObj->Release();
    }
    return hr; // no RRETURN - may return S_FALSE
}


/*
* HrGetCombinedURL does some of the things that GetBackgroundImageUrl
* does, but in a more general way. It relies on the caller to have
* isolated the <BASE> collection and to supply the root document URL.
* While a trifle awkward, it is more efficient if the caller is going
* to combine many URLS.
*/

HRESULT HrGetCombinedURL( IHTMLElementCollection *pCollBase,
                         LONG cBase,
                         LONG lElemPos,
                         BSTR bstrRelURL,
                         BSTR bstrDocURL,
                         BSTR *pbstrBaseURL)
{
    HRESULT             hr = S_FALSE;
    IHTMLElement        *pElemBase;
    IHTMLBaseElement    *pBase;
    LONG                lBasePos=0,
        lBasePosSoFar=0;
    BSTR                bstr = NULL;
    LPWSTR              pszUrlW=0;
    WCHAR               szBaseW[INTERNET_MAX_URL_LENGTH];
    WCHAR               szUrlW[INTERNET_MAX_URL_LENGTH];
    DWORD               cch=INTERNET_MAX_URL_LENGTH;
    LONG                i;
    
    *pbstrBaseURL = 0;
    *szBaseW = 0;
    
    for (i=0; i<cBase; i++)
    {
        if (SUCCEEDED(HrGetCollectionItem(pCollBase, i, IID_IHTMLElement, (LPVOID *)&pElemBase)))
        {
            pElemBase->get_sourceIndex(&lBasePos);
            if (lBasePos < lElemPos &&
                lBasePos >= lBasePosSoFar)
            {
                if (SUCCEEDED(pElemBase->QueryInterface(IID_IHTMLBaseElement, (LPVOID *)&pBase)))
                {
                    bstr = NULL;
                    if (pBase->get_href(&bstr)==S_OK && bstr != NULL)
                    {
                        ASSERT (bstr);
                        if (*bstr)
                        {
                            StrCpyNW(szBaseW, bstr, ARRAYSIZE(szBaseW));
                            lBasePosSoFar = lBasePos;
                        }
                        SysFreeString(bstr);
                    }
                    pBase->Release();
                }
            }
            pElemBase->Release();
        }
    }
    
    if (szBaseW[0] == 0 && bstrDocURL)
    {
        // We didn't find a <BASE> tag before our element, so fall back to using
        // the document's location as basis for the base
        StrCpyNW( szBaseW, bstrDocURL, ARRAYSIZE(szBaseW) );
    }
    
#ifndef WIN16  //RUN16_BLOCK - UrlCombineW is not available
    // if there's a <BASE> then do the combine
    if (*szBaseW && 
        SUCCEEDED(UrlCombineW(szBaseW, bstrRelURL, szUrlW, &cch, 0)))
        pszUrlW = szUrlW;
#endif //!WIN16
    
    // pszUrlW contains the combined <BODY> and <BASE> tag, return this.
    if (pszUrlW)
        *pbstrBaseURL = SysAllocString(pszUrlW);
    
    return (*pbstrBaseURL == NULL ? S_FALSE : S_OK);
}

HRESULT HrLPSZToBSTR(LPCSTR lpsz, BSTR *pbstr)
{
    HRESULT hr = NOERROR;
    BSTR    bstr=0;
    ULONG   cch = 0, ccb,
        cchRet;
    UINT cp = GetACP();
    
    // get byte count
    ccb = lstrlenA(lpsz);
    
    // get character count - DBCS string ccb may not equal to cch
    cch=MultiByteToWideChar(cp, 0, lpsz, ccb, NULL, 0);
    if(cch==0 && ccb!=0)
    {
        ASSERT(FALSE);
        hr=E_FAIL;
        goto error;
    }
    
    // allocate a wide-string with enough character to hold string - use character count
    bstr=SysAllocStringLen(NULL, cch);
    if (!bstr)
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }
    
    cchRet=MultiByteToWideChar(cp, 0, lpsz, ccb, (LPWSTR)bstr, cch);
    if (cchRet==0 && ccb!=0)
    {
        hr=E_FAIL;
        goto error;
    }
    
    *pbstr = bstr;
    bstr=0;             // freed by caller
    
error:
    if (bstr)
        SysFreeString(bstr);   
    RRETURN(hr);
    
}

HRESULT HrBSTRToLPSZ(BSTR bstr, LPSTR *lplpsz)
{
    ULONG     cch = 0;
    
    ASSERT (bstr && lplpsz);
    
    cch = WideCharToMultiByte(CP_ACP, 0, bstr, -1, NULL, 0, NULL, NULL);

    if (!cch)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *lplpsz = new char[cch + 1];

    if (!*lplpsz)
    {
        return E_OUTOFMEMORY;
    }
    
    if (WideCharToMultiByte(CP_ACP, 0, bstr, -1, *lplpsz, cch+1, NULL, NULL))
        return S_OK;
    else
        return HRESULT_FROM_WIN32(GetLastError());
}

void RemoveBookMark(WCHAR *pwzURL, WCHAR **ppwzBookMark)
{
    if (pwzURL && ppwzBookMark)
    {
        *ppwzBookMark = pwzURL;

        while (**ppwzBookMark)
        {
            if (**ppwzBookMark == L'#')
            {
                **ppwzBookMark = L'\0';
                break;
            }

            (*ppwzBookMark)++;
        }
    }
}

void RestoreBookMark(WCHAR *pwzBookMark)
{
    if (pwzBookMark)
    {
        *pwzBookMark = L'#';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\privacyimport.hpp ===
//
//  declares privacy import headers.. defined in privacyimport.cpp
//

SHDOCAPI_(BOOL) LoadPrivacySettings( IN LPCWSTR szFilename);
SHDOCAPI_(BOOL) ExportPerSiteListW( IN LPCWSTR szFilename);

#define REGSTR_VAL_PRIVLEASHLEGACY (L"LeashLegacyCookies")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\privacyimport.cpp ===
//  PrivacyImport.cpp  - handles parsing and import of privacy preferences
#include "priv.h"
#include "resource.h"
#include <mluisupp.h>

#include "SmallUtil.hpp"
#include "PrivacyImport.hpp"


#define MAX_TOKEN_SIZE 64
#define NUM_OF_ZONES (1 + IDS_PRIVACYXML6_COOKIEZONE_LAST - IDS_PRIVACYXML6_COOKIEZONE_FIRST)
#define NUM_OF_ACTIONS (1 + IDS_PRIVACYXML6_ACTION_LAST - IDS_PRIVACYXML6_ACTION_FIRST) 


//
//  DeleteCacheCookies was copy'n'pasted from Cachecpl.cpp
//
//     Any changes to either version should probably be transfered to both.
//

BOOL DeleteCacheCookies()
{
    BOOL bRetval = TRUE;
    DWORD dwEntrySize, dwLastEntrySize;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntry;
    
    HANDLE hCacheDir = NULL;
    dwEntrySize = dwLastEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) new BYTE[dwEntrySize];
    if( lpCacheEntry == NULL)
    {
        bRetval = FALSE;
        goto Exit;
    }
    lpCacheEntry->dwStructSize = dwEntrySize;

Again:
    if (!(hCacheDir = FindFirstUrlCacheEntryA("cookie:",lpCacheEntry,&dwEntrySize)))
    {
        delete [] lpCacheEntry;
        switch(GetLastError())
        {
            case ERROR_NO_MORE_ITEMS:
                goto Exit;
            case ERROR_INSUFFICIENT_BUFFER:
                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                new BYTE[dwEntrySize];
                if( lpCacheEntry == NULL)
                {
                    bRetval = FALSE;
                    goto Exit;
                }
                lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                goto Again;
            default:
                bRetval = FALSE;
                goto Exit;
        }
    }

    do 
    {
        if (lpCacheEntry->CacheEntryType & COOKIE_CACHE_ENTRY)
            DeleteUrlCacheEntryA(lpCacheEntry->lpszSourceUrlName);
            
        dwEntrySize = dwLastEntrySize;
Retry:
        if (!FindNextUrlCacheEntryA(hCacheDir,lpCacheEntry, &dwEntrySize))
        {
            delete [] lpCacheEntry;
            switch(GetLastError())
            {
                case ERROR_NO_MORE_ITEMS:
                    goto Exit;
                case ERROR_INSUFFICIENT_BUFFER:
                    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                    new BYTE[dwEntrySize];
                    if( lpCacheEntry == NULL)
                    {
                        bRetval = FALSE;
                        goto Exit;
                    }
                    lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                    goto Retry;
                default:
                    bRetval = FALSE;
                    goto Exit;
            }
        }
    }
    while (TRUE);

Exit:
    if (hCacheDir)
        FindCloseUrlCache(hCacheDir);
    return bRetval;        
}


//*****************************************************************************************
//*****************************************************************************************
//
// CPrivacyXMLResourceStrings
//
//   just stores the Privacy format XML strings..

class CPrivacyXMLResourceStrings
{
    WCHAR m_szResourceString[IDS_PRIVACYXML6_LASTPRIVACYXML6
                             -IDS_PRIVACYXML6 + 1] [MAX_TOKEN_SIZE];
public:
    LPCWSTR GetResourceString( int iIndex) { return m_szResourceString[ iIndex - IDS_PRIVACYXML6];};


    BOOL Initialize()
    {
        for( int i = 0; 
             i < ARRAYSIZE(m_szResourceString);
             i++)
        {
            if( 0 == MLLoadStringW( IDS_PRIVACYXML6 + i, 
                                    m_szResourceString[i], MAX_TOKEN_SIZE))
                return FALSE;
        }
        return TRUE;
    }
};


//*****************************************************************************************
//*****************************************************************************************
//
//  CParseAccumulation is a class that stores the results of parsing an XML privacy
//preference file.  These results can then be sent to the system after parsing
//successfully completes.
//

class CParseAccumulation : public CPrivacyXMLResourceStrings
{
public:

    bool m_fFlushCookies;
    bool m_fFlushSiteList;
    bool m_fLeashCookies;

    struct SPerZonePartyPreferences
    {
        UINT m_uiNoPolicyDefault;
        UINT m_uiNoRuleDefault;
        bool m_fAlwaysAllowSession;
        CGrowingString m_cZonePreference;
    };

    struct SPerZonePreferences
    {
        UINT m_uiZoneID;
        bool m_fSetZone;
        SPerZonePartyPreferences m_party[2];  // first party = 0, third party = 1
    };

    SPerZonePreferences m_zonePref[NUM_OF_ZONES];

    CQueueSortOf m_queueSitesToAccept;
    CQueueSortOf m_queueSitesToReject;

    ~CParseAccumulation()
    {
        void* iterator;

        iterator = NULL;
        //  free up the names sites to be accepted
        while( NULL != (iterator = m_queueSitesToAccept.StepEnumerate( iterator)))
        {
            SysFreeString( (BSTR)m_queueSitesToAccept.Get( iterator));
        }

        iterator = NULL;
        //  free up the names of sites to be rejected
        while( NULL != (iterator = m_queueSitesToReject.StepEnumerate( iterator)))
        {
            SysFreeString( (BSTR)m_queueSitesToReject.Get( iterator));
        }
    }

    BOOL Initialize()
    {
        m_fFlushCookies = false;
        m_fFlushSiteList = false;
        m_fLeashCookies = true;

        for( int i = 0; i < ARRAYSIZE( m_zonePref); i++)
        {
            m_zonePref[i].m_uiZoneID = 0;
            m_zonePref[i].m_fSetZone = false;
            m_zonePref[i].m_party[0].m_uiNoPolicyDefault = 0;
            m_zonePref[i].m_party[0].m_uiNoRuleDefault = 0;
            m_zonePref[i].m_party[0].m_fAlwaysAllowSession = false;
            m_zonePref[i].m_party[1].m_uiNoPolicyDefault = 0;
            m_zonePref[i].m_party[1].m_uiNoRuleDefault = 0;
            m_zonePref[i].m_party[1].m_fAlwaysAllowSession = false;
        }

        return CPrivacyXMLResourceStrings::Initialize();
    }


    BOOL AddSiteRule( BSTR bstrDomain, DWORD uiAction)
    {
        if( uiAction == IDS_PRIVACYXML6_ACTION_ACCEPT)
            return m_queueSitesToAccept.InsertAtEnd( (void*)bstrDomain) ? TRUE : FALSE;
        else if( uiAction == IDS_PRIVACYXML6_ACTION_REJECT)
            return m_queueSitesToReject.InsertAtEnd( (void*)bstrDomain) ? TRUE : FALSE;
        else
            return FALSE;
    }


    long GetZoneFromResource( UINT uiZoneResource)
    {
        switch(uiZoneResource)
        {
        case IDS_PRIVACYXML6_COOKIEZONE_INTERNET:
            return URLZONE_INTERNET;
        case IDS_PRIVACYXML6_COOKIEZONE_INTRANET:
            return URLZONE_INTRANET;
        case IDS_PRIVACYXML6_COOKIEZONE_TRUSTED:
            return URLZONE_TRUSTED;
        default:
            return -1;
        }
    }

    BOOL DoAccumulation()
    {
        BOOL returnValue = FALSE;
        long i;
        void* iterator;

        if( m_fFlushSiteList)
            InternetClearAllPerSiteCookieDecisions();

    
        DWORD dwSetValue = m_fLeashCookies ? TRUE : FALSE;
        SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNET_SETTINGS, REGSTR_VAL_PRIVLEASHLEGACY,
                   REG_DWORD, &dwSetValue, sizeof(DWORD));

        if( m_fFlushCookies)
            DeleteCacheCookies();

        //  Set compact policy response rules for each zone
        for( i = 0; i < ARRAYSIZE(m_zonePref); i++)
        {
            if( !m_zonePref[i].m_fSetZone)
                continue;
            
            if( ERROR_SUCCESS !=
                PrivacySetZonePreferenceW( 
                    GetZoneFromResource(m_zonePref[i].m_uiZoneID), 
                    PRIVACY_TYPE_FIRST_PARTY, PRIVACY_TEMPLATE_CUSTOM, 
                    m_zonePref[i].m_party[0].m_cZonePreference.m_szString))
            {
                goto doneDoAccumulation;
            }

            if( ERROR_SUCCESS !=
                PrivacySetZonePreferenceW( 
                    GetZoneFromResource(m_zonePref[i].m_uiZoneID), 
                    PRIVACY_TYPE_THIRD_PARTY, PRIVACY_TEMPLATE_CUSTOM, 
                    m_zonePref[i].m_party[1].m_cZonePreference.m_szString))
            {
                goto doneDoAccumulation;
            }
        }

        //  If any per-site rules were specified, we modify the persite list..
        if( NULL != m_queueSitesToAccept.StepEnumerate(NULL)
            || NULL != m_queueSitesToReject.StepEnumerate(NULL))
        {
            //  First we clear all existing per site rules..
            InternetClearAllPerSiteCookieDecisions();

            //  Then we add the Accept per-site exceptions
            iterator = NULL;
            while( NULL != (iterator = m_queueSitesToAccept.StepEnumerate( iterator)))
            {
                InternetSetPerSiteCookieDecision( (LPCWSTR)m_queueSitesToAccept.Get( iterator), COOKIE_STATE_ACCEPT);
            }

            //  and then the Reject per-site exceptions
            iterator = NULL;
            while( NULL != (iterator = m_queueSitesToReject.StepEnumerate( iterator)))
            {
                InternetSetPerSiteCookieDecision( (LPCWSTR)m_queueSitesToReject.Get( iterator), COOKIE_STATE_REJECT);
            }
        }

        returnValue = TRUE;
    doneDoAccumulation:
        return returnValue;
    }
};



int FindP3PPolicySymbolWrap( LPCWSTR szSymbol)
{
    char szSymBuffer[MAX_PATH];
    int length = lstrlen( szSymbol);

    if( length + 1 > ARRAYSIZE( szSymBuffer))
        return -1;
    
    szSymBuffer[0] = '\0';
    SHTCharToAnsi( szSymbol, szSymBuffer, ARRAYSIZE( szSymBuffer));

    return FindP3PPolicySymbol( szSymBuffer);
}



//*****************************************************************************
//*****************************************************************************
//
//  XML Parsing functions
//
//  These functions help parsing XML.
//


//  GetNextToken looks at the node you are at (*ppCurrentNode) and tests
//if it has a particular tag value.  If it does, *ppOutToken is set to
//be a pointer to the node, *ppCurrentNode is advanced to the next node,
//and *pfFoundToken is set to TRUE.  If the *ppCurrentNode doesn't have
//the target tag, the *pfFoundToken is FALSE, *ppCurrentNode is unchanged,
//and *ppOutToken is NULL.
//  If *ppCurrentNode is the last node, *ppCurrentNode would be advanced
//to NULL when finding the target token.
BOOL GetNextToken( IN OUT IXMLDOMNode ** ppCurrentNode, IN LPCWSTR szTargetToken, 
                   OUT BOOL * pfFoundToken, OUT IXMLDOMNode ** ppOutTokenNode)
{
    BOOL returnValue = FALSE;
    HRESULT hr;

    BSTR bstrNodeName = NULL;
    VARIANT var;
    VariantInit( &var);

    if( *ppCurrentNode == NULL)
    {
        *pfFoundToken = FALSE;
        *ppOutTokenNode = NULL;
        returnValue = TRUE;
        goto doneGetNextToken;
    }

    hr = (*ppCurrentNode)->get_nodeName( &bstrNodeName);
    if( FAILED(hr))
        goto doneGetNextToken;

    if( 0 != StrCmpW( szTargetToken, bstrNodeName))
    {
        *pfFoundToken = FALSE;
        *ppOutTokenNode = NULL;
        returnValue = TRUE;
    }
    else
    {
        IXMLDOMNode * pNode = NULL;
        hr = (*ppCurrentNode)->get_nextSibling( &pNode);
        if( FAILED(hr))
            goto doneGetNextToken;
    
        *ppOutTokenNode = *ppCurrentNode;
        if( hr == S_OK)
            *ppCurrentNode = pNode;
        else
            *ppCurrentNode = NULL;
        *pfFoundToken = TRUE;
        returnValue = TRUE;
    }

doneGetNextToken:
    
    if( bstrNodeName != NULL)
        SysFreeString( bstrNodeName);

    return returnValue;
}


//  GeAttributes retrieves the XML attributes for a node.  The attributes to
//be fetched are passed in in array aszName, of length iStringCount.  The results
//are returned as VT_BSTRs on success of VT_EMPTY on failure.  The total number
//of attributes for the node is also returned (*plAllAttributesCount).
BOOL GetAttributes( 
    IN IXMLDOMNode * pNode, IN LPCWSTR * aszName, IN long iStringCount,
    OUT VARIANT * aAttributeVariants, OUT long * plAllAttributesCount)
{
    BOOL returnValue = FALSE;

    HRESULT hr;
    BSTR bstrAttributeName = NULL;
    IXMLDOMNamedNodeMap * pAttributes = NULL;
    IXMLDOMNode * pTempNode = NULL;

    hr = pNode->get_attributes( &pAttributes);
    if( FAILED(hr))
        goto doneGetAttributes;

    if( plAllAttributesCount != NULL)
    {
        hr = pAttributes->get_length( plAllAttributesCount);
        if( FAILED(hr))
            goto doneGetAttributes;
    }
    
    for( int i = 0; i < iStringCount; i++)
    {
        if( pTempNode != NULL)
            pTempNode->Release();
        pTempNode = NULL;
        if( bstrAttributeName != NULL)
            SysFreeString( bstrAttributeName);
        bstrAttributeName = NULL;

        aAttributeVariants[i].vt = VT_EMPTY;
        aAttributeVariants[i].bstrVal = NULL;
        
        bstrAttributeName = SysAllocString( aszName[i]);
        if( bstrAttributeName == NULL)
            continue;

        //  test if the ith attribute was set
        hr = pAttributes->getNamedItem( bstrAttributeName, &pTempNode);
        if( FAILED(hr) || pTempNode == NULL)
            continue;

        //  get the value
        hr = pTempNode->get_nodeTypedValue( &aAttributeVariants[i]);

        //  convert the value to a BSTR.
        hr = VariantChangeType( &aAttributeVariants[i], &aAttributeVariants[i], NULL, VT_BSTR);

        if( FAILED(hr) || aAttributeVariants[i].bstrVal == NULL)
        {
            VariantClear( &aAttributeVariants[i]);
            aAttributeVariants[i].vt = VT_EMPTY;
            aAttributeVariants[i].bstrVal = NULL;
        }
    }

    returnValue = TRUE;
doneGetAttributes:
    if( bstrAttributeName != NULL)
        SysFreeString( bstrAttributeName);
    
    if( pAttributes != NULL)
        pAttributes->Release();

    if( pTempNode != NULL)
        pTempNode->Release();
    return returnValue;
}


//  The actions by GetActionByResource are formatted for
//PrivacySetZonePreference, like /token=n/ where n is the action.
LPCWSTR GetActionByResource( UINT uiActionResource)
{
    switch( uiActionResource)
    {
    case IDS_PRIVACYXML6_ACTION_ACCEPT:
        return L"=a/";
    case IDS_PRIVACYXML6_ACTION_PROMPT:
        return L"=p/";
    case IDS_PRIVACYXML6_ACTION_FIRSTPARTY:
        return L"=l/";
    case IDS_PRIVACYXML6_ACTION_SESSION:
        return L"=d/";
    case IDS_PRIVACYXML6_ACTION_REJECT:
        return L"=r/";
    default:
        ASSERT(0);
        return L"r/";
    }
}

LPCWSTR GetShortActionByResource( UINT uiActionResource)
{
    switch( uiActionResource)
    {
    case IDS_PRIVACYXML6_ACTION_ACCEPT:
        return L"=a";
    case IDS_PRIVACYXML6_ACTION_PROMPT:
        return L"=p";
    case IDS_PRIVACYXML6_ACTION_FIRSTPARTY:
        return L"=l";
    case IDS_PRIVACYXML6_ACTION_SESSION:
        return L"=d";
    case IDS_PRIVACYXML6_ACTION_REJECT:
        return L"=r";
    default:
        ASSERT(0);
        return L"r";
    }
}


//  GetChildrenByName takes an XML node and returns all the subnodes
//with a particular name.
BOOL GetChildrenByName( IN IXMLDOMNode * pNode, IN LPCWSTR szName, 
                        OUT IXMLDOMNodeList ** ppOutNodeList, OUT long * plCount)
{
    BOOL returnValue = FALSE;
    HRESULT hr;
    BSTR bstr = NULL;
    IXMLDOMNodeList * pSelectedNodes;

    if( NULL == (bstr = SysAllocString( szName)))
        goto doneGetChildrenByName;

    hr = pNode->selectNodes( bstr, &pSelectedNodes);

    if( FAILED(hr))
        goto doneGetChildrenByName;

    if( plCount != NULL)
    {
        hr = pSelectedNodes->get_length( plCount);
        if( FAILED(hr))
            goto doneGetChildrenByName;
    }

    returnValue = TRUE;
    *ppOutNodeList = pSelectedNodes;
    pSelectedNodes = NULL;

doneGetChildrenByName:
    if( bstr != NULL)
        SysFreeString( bstr);

    if( pSelectedNodes != NULL)
        pSelectedNodes->Release();

    return returnValue;
}


//*****************************************************************************
//*****************************************************************************
//
//  XML preference parsing functions
//
//    These functions are specific to the v6 XML format of privacy preferences
//
//    To make sense of these functions, their easiest to look at looking at
//the bottom function first, then moving up to the next function.


//  parses <if expr="rule" action="act">
//  where rule is like " token & ! token" and act is like "accept"
BOOL ParseIfRule( IN IXMLDOMNode* pIfNode,
                  CParseAccumulation::SPerZonePartyPreferences* pAccumParty,
                  CParseAccumulation& thisAccum)                  
{
    BOOL returnValue = FALSE;
    LONG lTemp;
    UINT uiTemp;

    VARIANT avarRule[2];
    for( lTemp = 0; lTemp < ARRAYSIZE( avarRule); lTemp++)
        VariantInit( &avarRule[lTemp]);
    LPCWSTR aszRuleAttributes[2] = 
              { thisAccum.GetResourceString(IDS_PRIVACYXML6_EXPR), 
                thisAccum.GetResourceString(IDS_PRIVACYXML6_ACTION)};

    if( TRUE != GetAttributes( 
                  pIfNode, aszRuleAttributes, ARRAYSIZE(aszRuleAttributes),
                  avarRule, &lTemp)
        || lTemp != 2
        || avarRule[0].vt == VT_EMPTY
        || avarRule[1].vt == VT_EMPTY)
    {
        goto doneParseIfRule;
    }

    // determine the action
    UINT uiActionResource;
    uiActionResource = 0;
    for( uiTemp = IDS_PRIVACYXML6_ACTION_FIRST;
         uiTemp <= IDS_PRIVACYXML6_ACTION_LAST;
         uiTemp++)
    {
        if( 0 == StrCmp( avarRule[1].bstrVal, thisAccum.GetResourceString(uiTemp)))
            uiActionResource = uiTemp;
    }
    if( uiActionResource == 0)
        goto doneParseIfRule;


    //  Write the beginning of the next rule " /"
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L" /"))
        goto doneParseIfRule;

    //  Write the rule expression formatted for GetZoneFromResource
    LPWSTR pCursor, pEndCursor;
    pCursor = avarRule[0].bstrVal;
    bool fContinue, fNegated;
    fContinue = true;
    while( fContinue)
    {
        while( *pCursor == L' ')
            pCursor++;
        
        fNegated = false;
        while( *pCursor == L'!')
        {
            fNegated = !fNegated;
            pCursor++;
            while( *pCursor == L' ')
                pCursor++;
        }
        if( fNegated)
        {
            if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L"!"))
                goto doneParseIfRule;
        }

        while( *pCursor == L' ')
            pCursor++;

        pEndCursor = pCursor;
        while( *pEndCursor != L'\0' && *pEndCursor != L',' && *pEndCursor != L' ')
        {
            pEndCursor++;
        }
        WCHAR szToken[10];
        if( pEndCursor == pCursor
            || pEndCursor - pCursor > ARRAYSIZE(szToken)-1)
        {
            goto doneParseIfRule;
        }
        StrCpyNW( szToken, pCursor, (int)(pEndCursor-pCursor+1));
        szToken[ pEndCursor-pCursor] = L'\0';
        if( -1 == FindP3PPolicySymbolWrap( szToken))
            goto doneParseIfRule;
        if( TRUE != pAccumParty->m_cZonePreference.AppendToString(szToken))
             goto doneParseIfRule;
        pCursor = pEndCursor;

        while( *pCursor == L' ')
            pCursor++;

        fContinue = false;
        if( *pCursor == L',')
        {
            if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L"&"))
                goto doneParseIfRule;
            fContinue = true;
            pCursor++;
        }
    }

    while( *pCursor == L' ')
        pCursor++;

    if( *pCursor != L'\0')
        goto doneParseIfRule;

    //  Write the ending of the next rule "=action/"
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString( GetActionByResource(
                                uiActionResource)))
    {
        goto doneParseIfRule;
    }

    returnValue = TRUE;
doneParseIfRule:

    for( lTemp = 0; lTemp < ARRAYSIZE( avarRule); lTemp++)
        VariantClear( &avarRule[lTemp]);

    return returnValue;
}
                  

// parses  <firstParty ...> or <thirdParty ...> elements
BOOL ParsePartyBlock( IN IXMLDOMNode* pPartyNode,
                      CParseAccumulation::SPerZonePartyPreferences* pAccumParty,
                      CParseAccumulation& thisAccum)
{
    BOOL returnValue = FALSE;
    long lTemp;
    UINT uiTemp;
    HRESULT hr;

    IXMLDOMNode * pCurrentNode = NULL;
    IXMLDOMNode * pRuleNode = NULL;
    VARIANT avarAttributes[3];
    for( lTemp = 0; lTemp < ARRAYSIZE( avarAttributes); lTemp++)
        VariantInit( &avarAttributes[lTemp]);
    LPCWSTR aszAttributes[3] = 
              { thisAccum.GetResourceString(IDS_PRIVACYXML6_NOPOLICYDEFAULT), 
                thisAccum.GetResourceString(IDS_PRIVACYXML6_NORULESDEFAULT), 
                thisAccum.GetResourceString(IDS_PRIVACYXML6_ALWAYSALLOWSESSION)};

    if( TRUE != GetAttributes( pPartyNode, aszAttributes, ARRAYSIZE(aszAttributes),
                               avarAttributes, &lTemp)
        || lTemp != 3
        || avarAttributes[0].vt == VT_EMPTY
        || avarAttributes[1].vt == VT_EMPTY
        || avarAttributes[2].vt == VT_EMPTY)
    {
        goto doneParsePartyBlock;
    }

    hr = pPartyNode->get_firstChild( &pCurrentNode);
    if( FAILED(hr))
        goto doneParsePartyBlock;

    //  Determine No Policy and No Rule Matched defaults
    pAccumParty->m_uiNoPolicyDefault = 0;
    pAccumParty->m_uiNoRuleDefault = 0;
    for( uiTemp = IDS_PRIVACYXML6_ACTION_FIRST;
         uiTemp <= IDS_PRIVACYXML6_ACTION_LAST;
         uiTemp++)
    {
        if( 0 == StrCmp( avarAttributes[0].bstrVal, thisAccum.GetResourceString(uiTemp)))
            pAccumParty->m_uiNoPolicyDefault = uiTemp;
        if( 0 == StrCmp( avarAttributes[1].bstrVal, thisAccum.GetResourceString(uiTemp)))
            pAccumParty->m_uiNoRuleDefault = uiTemp;
    }
    if( pAccumParty->m_uiNoPolicyDefault == 0 || pAccumParty->m_uiNoRuleDefault == 0)
        goto doneParsePartyBlock;

    //  Determine if we should always allow session cookies.
    if( 0 == StrCmp( avarAttributes[2].bstrVal, 
                     thisAccum.GetResourceString(IDS_PRIVACYXML6_YES)))
    {
        pAccumParty->m_fAlwaysAllowSession = true;
    }
    else if( 0 == StrCmp( avarAttributes[2].bstrVal, 
                          thisAccum.GetResourceString(IDS_PRIVACYXML6_NO)))

    {
        pAccumParty->m_fAlwaysAllowSession = false;
    }
    else
    {
        goto doneParsePartyBlock;
    }

    //  Write the response if there is no policy
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L"IE6-P3PV1/settings: nopolicy"))
        goto doneParsePartyBlock;
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString( GetShortActionByResource(
                                pAccumParty->m_uiNoPolicyDefault)))
    {
        goto doneParsePartyBlock;
    }

    //  If we allow all session cookies, write that rule.
    if( pAccumParty->m_fAlwaysAllowSession)
    {
        if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L" session=a"))
            goto doneParsePartyBlock;
    }

    //  Write each of the rules in IF blocks
    while( pCurrentNode != NULL)
    {
        if( pRuleNode != NULL)
            pRuleNode->Release();
        pRuleNode = NULL;
        
        BOOL fFoundIfRule;
        if( TRUE != GetNextToken( 
                      &pCurrentNode, thisAccum.GetResourceString( IDS_PRIVACYXML6_IF),
                      &fFoundIfRule, &pRuleNode)
            || fFoundIfRule != TRUE)
        {
            goto doneParsePartyBlock;
        }

        if( TRUE != ParseIfRule( pRuleNode, pAccumParty, thisAccum))
            goto doneParsePartyBlock;
    }

    //  Write the command for the No Rule Matched rule..
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString(L" /"))
        goto doneParsePartyBlock;
    if( TRUE != pAccumParty->m_cZonePreference.AppendToString( GetActionByResource(
                                pAccumParty->m_uiNoRuleDefault)))
    {
        goto doneParsePartyBlock;
    }

    returnValue = TRUE;
doneParsePartyBlock:
    if( pCurrentNode != NULL)
        pCurrentNode->Release();
    
    if( pRuleNode != NULL)
        pRuleNode->Release();
    
    for( lTemp = 0; lTemp < ARRAYSIZE( avarAttributes); lTemp++)
        VariantClear( &avarAttributes[lTemp]);

    return returnValue;
}


BOOL ParseP3pCookiePolicyBlock( IN IXMLDOMNode* pP3pPolicyNode, CParseAccumulation& thisAccum)
{
    BOOL returnValue = FALSE;
    HRESULT hr;
    BOOL bl;
    long iTemp;
    
    VARIANT varZoneAttribute;
    VariantInit( &varZoneAttribute);
    IXMLDOMNode * pCurrentNode = NULL;
    IXMLDOMNode * pFirstPartyNode = NULL;
    IXMLDOMNode * pThirdPartyNode = NULL;
    
    LPCWSTR aszAttributes[1] = { thisAccum.GetResourceString(IDS_PRIVACYXML6_COOKIEZONE_ZONE)};
    if( TRUE != GetAttributes( pP3pPolicyNode, 
                               aszAttributes, ARRAYSIZE( aszAttributes), 
                               &varZoneAttribute, &iTemp)
        || iTemp != 1
        || varZoneAttribute.vt == VT_EMPTY)
    {
        goto doneParseP3pCookiePolicyBlock;
    }

    hr = pP3pPolicyNode->get_firstChild( &pCurrentNode);
    if( FAILED( hr))
        goto doneParseP3pCookiePolicyBlock;

    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_FIRSTPARTY),
                              &bl, &pFirstPartyNode)
        || bl != TRUE)
    {
        goto doneParseP3pCookiePolicyBlock;
    }
    
    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_THIRDPARTY),
                              &bl, &pThirdPartyNode)
        || bl != TRUE)
    {
        goto doneParseP3pCookiePolicyBlock;
    }

    if( pCurrentNode != NULL)  //  to many elements ...
        goto doneParseP3pCookiePolicyBlock;


    long iCurrentZone;
    iCurrentZone = -1;
    for( iTemp = 0; iTemp < NUM_OF_ZONES; iTemp++)
    {
        if( 0 == StrCmp(varZoneAttribute.bstrVal, 
                        thisAccum.GetResourceString( iTemp + IDS_PRIVACYXML6_COOKIEZONE_FIRST)))
        {
            iCurrentZone = iTemp;
        }
    }

    if( iCurrentZone == -1)
        goto doneParseP3pCookiePolicyBlock;

    thisAccum.m_zonePref[iCurrentZone].m_uiZoneID = iCurrentZone + IDS_PRIVACYXML6_COOKIEZONE_FIRST;
    thisAccum.m_zonePref[iCurrentZone].m_fSetZone = true;

    if( TRUE != ParsePartyBlock( pFirstPartyNode, &(thisAccum.m_zonePref[iCurrentZone].m_party[0]),
                                 thisAccum))
    {
        goto doneParseP3pCookiePolicyBlock;
    }

    if( TRUE != ParsePartyBlock( pThirdPartyNode, &(thisAccum.m_zonePref[iCurrentZone].m_party[1]),
                                 thisAccum))
    {
        goto doneParseP3pCookiePolicyBlock;
    }

    returnValue = TRUE;

doneParseP3pCookiePolicyBlock:
    VariantClear( &varZoneAttribute);

    if( pCurrentNode != NULL)
        pCurrentNode->Release();

    if( pFirstPartyNode != NULL)
        pFirstPartyNode->Release();

    if( pThirdPartyNode != NULL)
        pThirdPartyNode->Release();

    return returnValue;
}


BOOL ParseMSIEPrivacyBlock( IXMLDOMNode* pMSIEPrivacyNode, CParseAccumulation& thisAccum)
{
    bool returnValue = NULL;
    HRESULT hr;
    BOOL bl;
    long iZoneIndex;

    IXMLDOMNode * pCurrentNode = NULL;
    IXMLDOMNode * pAlwaysReplayLegacyNode = NULL;
    IXMLDOMNode * pFlushCookiesNode = NULL;
    IXMLDOMNode * pFlushSiteListNode = NULL;
    IXMLDOMNode * apZoneNode[NUM_OF_ZONES];  
    for( iZoneIndex = 0; iZoneIndex < ARRAYSIZE(apZoneNode); iZoneIndex++)
        apZoneNode[iZoneIndex] = NULL;

    //  The correctness of attributes for this node was verified in
    //LoadPrivacySettings()..  (formatVersion="6.0")

    hr = pMSIEPrivacyNode->get_firstChild( &pCurrentNode);
    if( FAILED( hr))
        goto doneParseMSIEPrivacyBlock;

    for( iZoneIndex = 0; iZoneIndex < ARRAYSIZE( apZoneNode); iZoneIndex++)
    {
        if( TRUE != GetNextToken( &pCurrentNode, 
                       thisAccum.GetResourceString(IDS_PRIVACYXML6_COOKIEZONE),
                       &bl, &apZoneNode[iZoneIndex]))
        {
            goto doneParseMSIEPrivacyBlock;
        }
    }

    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_ALWAYSREPLAYLEGACY),
                              &bl, &pAlwaysReplayLegacyNode))
    {
        goto doneParseMSIEPrivacyBlock;
    }

    thisAccum.m_fLeashCookies = pAlwaysReplayLegacyNode == NULL;

    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_FLUSHCOOKIES),
                              &bl, &pFlushCookiesNode))
    {
        goto doneParseMSIEPrivacyBlock;
    }

    thisAccum.m_fFlushCookies = pFlushCookiesNode != NULL;
    
    if( TRUE != GetNextToken( &pCurrentNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_FLUSHSITELIST),
                              &bl, &pFlushSiteListNode))
    {
        goto doneParseMSIEPrivacyBlock;
    }

    thisAccum.m_fFlushSiteList = pFlushSiteListNode != NULL;

    if( pCurrentNode != NULL)
        goto doneParseMSIEPrivacyBlock;

    for( iZoneIndex = 0; iZoneIndex < ARRAYSIZE( apZoneNode); iZoneIndex++)
    {
        if( apZoneNode[iZoneIndex] != NULL)
        {
            if( TRUE != ParseP3pCookiePolicyBlock( apZoneNode[iZoneIndex], thisAccum))
                goto doneParseMSIEPrivacyBlock;
        }
    }    

    returnValue = TRUE;

doneParseMSIEPrivacyBlock:
    
    if( pCurrentNode != NULL)
        pCurrentNode->Release();

    if( pAlwaysReplayLegacyNode != NULL)
        pAlwaysReplayLegacyNode->Release();

    if( pFlushCookiesNode != NULL)
        pFlushCookiesNode->Release();

    if( pFlushSiteListNode != NULL)
        pFlushSiteListNode->Release();

    for( iZoneIndex = 0; iZoneIndex < ARRAYSIZE(apZoneNode); iZoneIndex++)
    {
        if( apZoneNode[iZoneIndex] != NULL)
            apZoneNode[iZoneIndex]->Release();
    }

    return returnValue;
}


BOOL ParsePerSiteRule( IXMLDOMNode* pPerSiteRule, CParseAccumulation& thisAccum)
{
    BOOL returnValue = FALSE;
    LONG lTemp;

    VARIANT avarRule[2];
    for( lTemp = 0; lTemp < ARRAYSIZE( avarRule); lTemp++)
        VariantInit( &avarRule[lTemp]);
    VARIANT varDomain;
    VariantInit( &varDomain);
    LPCWSTR aszRuleAttributes[2] = 
              { thisAccum.GetResourceString(IDS_PRIVACYXML6_DOMAIN), 
                thisAccum.GetResourceString(IDS_PRIVACYXML6_ACTION)};

    if( TRUE != GetAttributes( 
                  pPerSiteRule, aszRuleAttributes, ARRAYSIZE(aszRuleAttributes),
                  avarRule, &lTemp)
        || lTemp != 2
        || avarRule[0].vt == VT_EMPTY
        || avarRule[1].vt == VT_EMPTY)
    {
        goto doneParsePerSiteRule;
    }

    //  get the domain and make sure its legit
    varDomain.vt = avarRule[0].vt;
    varDomain.bstrVal = avarRule[0].bstrVal;
    avarRule[0].vt = VT_EMPTY;
    avarRule[0].bstrVal = NULL;

    if( TRUE != IsDomainLegalCookieDomain( varDomain.bstrVal, varDomain.bstrVal))
        goto doneParsePerSiteRule;

    //  get the action, ensuring its also legit
    UINT uiActionResource;
    if( 0 == StrCmp( avarRule[1].bstrVal, thisAccum.GetResourceString(IDS_PRIVACYXML6_ACTION_ACCEPT)))
        uiActionResource = IDS_PRIVACYXML6_ACTION_ACCEPT;
    else if( 0 == StrCmp( avarRule[1].bstrVal, thisAccum.GetResourceString(IDS_PRIVACYXML6_ACTION_REJECT)))
        uiActionResource = IDS_PRIVACYXML6_ACTION_REJECT;
    else
        goto doneParsePerSiteRule;

    //  store the rule in the accumulated result
    if( TRUE != thisAccum.AddSiteRule( varDomain.bstrVal, uiActionResource))
        goto doneParsePerSiteRule;

    varDomain.vt = VT_EMPTY;
    varDomain.bstrVal = NULL;
   
    returnValue = TRUE;

doneParsePerSiteRule:
    for( lTemp = 0; lTemp < ARRAYSIZE( avarRule); lTemp++)
        VariantClear( &avarRule[lTemp]);

    VariantClear( &varDomain);

    return returnValue;
}


BOOL ParseMSIEPerSiteBlock( IXMLDOMNode* pPerSiteRule, CParseAccumulation& thisAccum)
{
    BOOL returnValue = FALSE;
    HRESULT hr;

    IXMLDOMNode * pCurrentNode = NULL;
    IXMLDOMNode * pRuleNode = NULL;

    hr = pPerSiteRule->get_firstChild( &pCurrentNode);
    if( FAILED(hr))
        goto doneParsePerSiteBlock;

    while( pCurrentNode != NULL)
    {
        if( pRuleNode != NULL)
            pRuleNode->Release();
        pRuleNode = NULL;
        
        BOOL fFoundPerSiteRule;
        if( TRUE != GetNextToken( 
                      &pCurrentNode, thisAccum.GetResourceString( IDS_PRIVACYXML6_SITE),
                      &fFoundPerSiteRule, &pRuleNode)
            || fFoundPerSiteRule != TRUE)
        {
            goto doneParsePerSiteBlock;
        }

        if( TRUE != ParsePerSiteRule( pRuleNode, thisAccum))
            goto doneParsePerSiteBlock;
    }

    returnValue = TRUE;

doneParsePerSiteBlock:
    if( pCurrentNode != NULL)
        pCurrentNode->Release();

    if( pRuleNode != NULL)
        pRuleNode->Release();

    return returnValue;
}


BOOL OpenXMLFile( LPCWSTR szFilename, IXMLDOMNode ** ppOutputNode)
{
    BOOL returnValue = FALSE;

    HRESULT hr;
    VARIANT varFilename;
    VariantInit( &varFilename);
        
    IXMLDOMDocument * pXMLDoc = NULL;
    IXMLDOMElement * pXMLRoot = NULL;
    IXMLDOMNode * pRootNode = NULL;

    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
           IID_IXMLDOMDocument, (void**)&pXMLDoc);
    if( FAILED(hr))
        goto doneOpenXMLFile;

    hr = pXMLDoc->put_async( VARIANT_FALSE);
    if( FAILED(hr))
        goto doneOpenXMLFile;

    varFilename.vt = VT_BSTR;
    varFilename.bstrVal = SysAllocString( szFilename);
    if( varFilename.bstrVal == NULL)
        goto doneOpenXMLFile;
    VARIANT_BOOL varbool;
    hr = pXMLDoc->load( varFilename, &varbool);
    if( FAILED(hr) || varbool != VARIANT_TRUE)
        goto doneOpenXMLFile;

    hr = pXMLDoc->get_documentElement( &pXMLRoot);
    if( FAILED(hr))
        goto doneOpenXMLFile;

    hr = pXMLRoot->QueryInterface( IID_IXMLDOMNode, (void **)&pRootNode);
    if( FAILED(hr))
        goto doneOpenXMLFile;

    returnValue = TRUE;
    *ppOutputNode = pRootNode;
    pRootNode = NULL;
    
doneOpenXMLFile:   
    if( pXMLDoc != NULL)
        pXMLDoc->Release();

    if( pXMLRoot != NULL)
        pXMLRoot->Release();
  
    if( pRootNode != NULL)
        pRootNode->Release();

    VariantClear( &varFilename);

    return returnValue;
}


//
//  GetVersionedTag
//
//   Looks at all tags in pSource with the tag szTargetTag.  Returns
//the member with version fVersion.  Fails if zero or >1 such
//tags are found.
//

BOOL GetVersionedTag( IXMLDOMNode* pSource, LPCWSTR szTargetTag, LPCWSTR szVersionAttribute, float fVersion,
                      IXMLDOMNode** ppOutputNode)
{
    BOOL returnValue = FALSE;
    HRESULT hr;

    IXMLDOMNode * pNode = NULL;
    IXMLDOMNode * pResult = NULL;
    IXMLDOMNodeList * pRootNodeList = NULL;
    IXMLDOMNode * pVersionAttribute = NULL;
    VARIANT varVersion;
    VariantInit( &varVersion);

    //  Get the elements in pSource with tag szTargetTag
    long iListSize;
    if( TRUE != GetChildrenByName( pSource, szTargetTag,
                                   &pRootNodeList, &iListSize))
    {
        goto doneGetVersionedTag;
    }

    long iListIndex;
    for( iListIndex = 0; iListIndex < iListSize; iListIndex++)
    {
        if( pNode != NULL)
            pNode->Release();
        pNode = NULL;
        if( pVersionAttribute != NULL)
            pVersionAttribute->Release();
        pVersionAttribute = NULL;
        VariantClear( &varVersion);
        
        hr = pRootNodeList->get_item( iListIndex, &pNode);
        if( FAILED(hr))
            goto doneGetVersionedTag;

        long iTotalAttributeCount;
        LPCWSTR aszAttributes[1] = { szVersionAttribute};
        if( TRUE != GetAttributes( pNode, aszAttributes, ARRAYSIZE(aszAttributes), 
                                   &varVersion, &iTotalAttributeCount)
            || varVersion.vt == VT_EMPTY)
        {
            continue;
        }

        hr = VariantChangeType( &varVersion, &varVersion, NULL, VT_R4);
        if( FAILED(hr))
            goto doneGetVersionedTag;

        if( varVersion.fltVal != fVersion)
            continue;

        if( pResult == NULL)
        {
            pResult = pNode;
            pNode = NULL;
        }
        else
        {  // found multiple of right version.. syntax problem.
            goto doneGetVersionedTag;
        }
    }

    *ppOutputNode = pResult;
    pResult = NULL;
    returnValue = TRUE;

doneGetVersionedTag:
    if( pNode != NULL)
        pNode->Release();
    
    if( pResult != NULL)
        pResult->Release();

    if( pRootNodeList != NULL)
        pRootNodeList->Release();

    if( pVersionAttribute != NULL)
        pVersionAttribute->Release();

    VariantClear( &varVersion);
    
    return returnValue;
}
                      


BOOL LoadPrivacySettings(LPCWSTR szFilename, CParseAccumulation& thisAccum, 
                         IN OUT BOOL* pfParsePrivacyPreferences, IN OUT BOOL* pfParsePerSiteRules)
{
    BOOL returnValue = FALSE;

    IXMLDOMNode * pRootNode = NULL;
    IXMLDOMNode * pPrivacyPreferencesNode = NULL;
    IXMLDOMNode * pPerSiteSettingsNode = NULL;

    //  Load the XML file  
    if( TRUE != OpenXMLFile( szFilename, &pRootNode))
        goto doneLoadPrivacySettings;

    //  Get the node containing privacy settings
    if( TRUE != GetVersionedTag( pRootNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_ROOTPRIVACY),
                  thisAccum.GetResourceString(IDS_PRIVACYXML6_VERSION), 6.0, &pPrivacyPreferencesNode))
    {
        goto doneLoadPrivacySettings;
    }

    //  Get the node containing per-site settings
    if( TRUE != GetVersionedTag( pRootNode, thisAccum.GetResourceString(IDS_PRIVACYXML6_ROOTPERSITE),
                  thisAccum.GetResourceString(IDS_PRIVACYXML6_VERSION), 6.0, &pPerSiteSettingsNode))
    {
        goto doneLoadPrivacySettings;
    }

    //  If we're supposed to import privacy preferences and we found some, parse privacy preferences.
    if( *pfParsePrivacyPreferences == TRUE && pPrivacyPreferencesNode != NULL)
    {
        if( TRUE != ParseMSIEPrivacyBlock( pPrivacyPreferencesNode, thisAccum))
        {
            goto doneLoadPrivacySettings;
        }
    }

    //  If we're supposed to import per-site rules and we found some, parse per-site rules.
    if( *pfParsePerSiteRules == TRUE && pPerSiteSettingsNode != NULL)
    {
        if( TRUE != ParseMSIEPerSiteBlock( pPerSiteSettingsNode, thisAccum))
        {
            goto doneLoadPrivacySettings;
        }
    }

    //  Indicate whether privacy preferences or per-site rules were parsed..
    *pfParsePrivacyPreferences = (*pfParsePrivacyPreferences == TRUE) && (pPrivacyPreferencesNode != NULL);
    *pfParsePerSiteRules = (*pfParsePerSiteRules == TRUE) && (pPerSiteSettingsNode != NULL);

    returnValue = TRUE;

doneLoadPrivacySettings:
    if( pRootNode != NULL)
        pRootNode->Release();

    if( pPrivacyPreferencesNode != NULL)
        pPrivacyPreferencesNode->Release();
    
    if( pPerSiteSettingsNode != NULL)
        pPerSiteSettingsNode->Release();
    
    return returnValue;
}


//  Top-level import function..  optionally imports privacy settings and per-site rules.
//The flag in tells if those items should be parsed, the flag out indicates if they were found.
//
//  Returns TRUE to indicate the import was successful, no syntax problems in the import
//file and the output flags are set.
//
//  Returns FALSE if there were any problems loading the file or writing the imported settings.
SHDOCAPI_(BOOL) ImportPrivacySettings( IN LPCWSTR szFilename,
                                       IN OUT BOOL* pfParsePrivacyPreferences,
                                       IN OUT BOOL* pfParsePerSiteRules)
{
    BOOL returnValue = FALSE;
    CParseAccumulation thisAccum;

    if( TRUE != thisAccum.Initialize())
        goto doneImportPrivacySettings;

    if( TRUE != LoadPrivacySettings( szFilename, thisAccum, 
                    pfParsePrivacyPreferences, pfParsePerSiteRules))
        goto doneImportPrivacySettings;

    returnValue = thisAccum.DoAccumulation();

doneImportPrivacySettings:
    return returnValue;
}




//*****************************************************************************************
//*****************************************************************************************
//
//*****************************************************************************************
//*****************************************************************************************
//
//  Privacy Export
//
//    This code exists to export the per-site list only.
//


CHAR g_szPerSiteFileBegin[] =
"\
<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\
<MSIEPrivacy>\r\n\
  <MSIESiteRules formatVersion=\"6.0\">\r\n\
";

CHAR g_szPerSiteRule[] = "<site domain=\"%s\" \taction=\"%s\"></site>\r\n";

CHAR g_szAccept[] = "accept";
CHAR g_szReject[] = "reject";

CHAR g_szPerSiteFileEnd[] =
"\
  </MSIESiteRules>\r\n\
</MSIEPrivacy>\r\n\
";


SHDOCAPI_(BOOL) ExportPerSiteListW( IN LPCWSTR szFilename)
{
    BOOL retVal = FALSE;
    CFileOutputStream OutputStream;
    PCHAR pszRuleBuffer = NULL;

    int iRuleIndex = 0;

    //  Allocate a temporary buffer to write the rules to
    long cRuleBufferSize = MAX_URL_STRING + ARRAYSIZE( g_szPerSiteRule) + MAX_PATH;
    pszRuleBuffer = new CHAR[ cRuleBufferSize];

    if( pszRuleBuffer == NULL)
        goto doneExportCookieFileW;

    //  Load the output file
    if( !OutputStream.Load( szFilename, FALSE))
        goto doneExportCookieFileW;
    
    //  Write the begining of the file.
    if( !OutputStream.DumpStr( g_szPerSiteFileBegin, ARRAYSIZE( g_szPerSiteFileBegin) - 1))
        goto doneExportCookieFileW;

    //  Enumerate the per-site rules and export the accept/reject rules
    CHAR szSiteName[ MAX_URL_STRING];
    DWORD cSiteNameSize;
    DWORD dwDecision;
    while( (cSiteNameSize = ARRAYSIZE( szSiteName))  // initialize in-out param
           && InternetEnumPerSiteCookieDecisionA( szSiteName, &cSiteNameSize, &dwDecision, iRuleIndex++))
    {
        if( dwDecision == COOKIE_STATE_ACCEPT
            || dwDecision == COOKIE_STATE_REJECT)
        {
            int iRuleLength = 
                wnsprintfA(pszRuleBuffer, cRuleBufferSize, g_szPerSiteRule,
                           szSiteName,
                           (dwDecision == COOKIE_STATE_ACCEPT) ? g_szAccept : g_szReject);
            OutputStream.DumpStr( pszRuleBuffer, iRuleLength);
        }

    }
    
    //  Write the ending of the file.
    if( !OutputStream.DumpStr( g_szPerSiteFileEnd, ARRAYSIZE( g_szPerSiteFileEnd) - 1))
        goto doneExportCookieFileW;
    
    retVal = TRUE;

doneExportCookieFileW:
    if( pszRuleBuffer != NULL)
        delete [] pszRuleBuffer;
    
    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\opsprof.cpp ===
//
// COPSProfile implementation
//

#include "priv.h"
#include "sccls.h"
#include "hlframe.h"
#include "mshtmdid.h"
#include "wtypes.h"

#include "shlwapi.h"

#include "resource.h"

#include "iehelpid.h"

#include <mluisupp.h>

// Definitions copied from WININET

#define COOKIES_WARN     0 // warn with a dlg if using cookies
#define COOKIES_ALLOW    1 // allow cookies without any warning
#define COOKIES_DENY     2 // disable cookies completely


#ifndef VARIANT_TRUE
#define VARIANT_TRUE     ((VARIANT_BOOL)-1)           // TRUE for VARIANT_BOOL
#endif

#ifndef VARIANT_FALSE
#define VARIANT_FALSE    ((VARIANT_BOOL)0)            // FALSE for VARIANT_BOOL
#endif

#define EMPTY_STRINGA(s)    ( !s || (s)[0] == '\0'  )
#define EMPTY_STRINGW(s)    ( !s || (s)[0] == L'\0' )

#ifdef  UNICODE
#define EMPTY_STRING(s)     EMPTY_STRINGW(s)
#else
#define EMPTY_STRING(s)     EMPTY_STRINGA(s)
#endif

// Max number of characters in a friendly OPS attribute name.        
const   int     MAX_PROFILE_NAME = 128;


// Constant non-localizable string definitions
const   TCHAR   rgszP3Global[]  = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Security\\P3Global");
const   TCHAR   rgszP3Sites[]   = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Security\\P3Sites");

const   TCHAR   rgszInetKey[]   = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings");
const   TCHAR   rgszPathTxt[]   = TEXT("Path");
const   TCHAR   rgszDomainTxt[] = TEXT("Domain");
const   TCHAR   rgszAllowTxt[]  = TEXT("Allow");
const   TCHAR   rgszDenyTxt[]   = TEXT("Deny");
const   TCHAR   rgszExpireTxt[] = TEXT("Expiration");
const   TCHAR   rgszCookieTxt[] = TEXT("AllowCookies");
const   TCHAR   rgszEnabled[]   = TEXT("Enabled");
const   TCHAR   rgszRegKey[]    = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\P3\\Write");
const   TCHAR   rgszRegTxt[]    = TEXT("Registration");

const   TCHAR   GENDER_UNSPECIFIED[] = TEXT("U");
const   TCHAR   GENDER_FEMALE[] = TEXT("F");
const   TCHAR   GENDER_MALE[] = TEXT("M");
const   WCHAR   GENDER_FEMALE_W[] = L"F";
const   WCHAR   GENDER_MALE_W[] = L"M";

#ifdef _USE_PSTORE_

// {647EC150-DC4A-11d0-A02C-00C0DFA9C763}
EXTERN_C const GUID GUID_PStoreType = { 0x647ec150, 0xdc4a, 0x11d0, { 0xa0, 0x2c, 0x0, 0xc0, 0xdf, 0xa9, 0xc7, 0x63 } };

PST_KEY s_Key = PST_KEY_CURRENT_USER;

#endif  // _USE_PSTORE_


// Static helper functions
static WCHAR*   _GetNameFromAttrIndex ( int index );
static INT      _GetResourceIdFromAttrIndex( int index );
static ULONG    _GetPropTagFromAttrIndex( int index );


// This table maintains the list of the suffixes for the Standard OPS attributes
// The names are intentionally kept here because these should not be localized.
struct _ProfileAttribute
{
     WCHAR * pwzName;
     int     id;         // resource ID for the friendly name of the attribute.
     ULONG   ulPropTag;
};

const _ProfileAttribute rgProfAttr [] =
        {
            { L"Vcard.DisplayName",             IDS_OPS_COMMONNAME,         PR_DISPLAY_NAME             },
            { L"Vcard.FirstName",               IDS_OPS_GIVENNAME,          PR_GIVEN_NAME               },
            { L"Vcard.LastName",                IDS_OPS_LASTNAME,           PR_SURNAME                  },
            { L"Vcard.MiddleName",              IDS_OPS_MIDDLENAME,         PR_MIDDLE_NAME              },
            // 0, 1, 2 for Unspecified, Female, Male
            { L"Vcard.Gender",                  IDS_OPS_GENDER,             PR_GENDER                   },

            { L"Vcard.Cellular",                IDS_OPS_CELLULAR,           PR_CELLULAR_TELEPHONE_NUMBER},
            { L"Vcard.Email",                   IDS_OPS_EMAIL,              PR_EMAIL_ADDRESS            },
            { L"Vcard.HomePage",                IDS_OPS_URL,                PR_PERSONAL_HOME_PAGE       },

            { L"Vcard.Company",                 IDS_OPS_COMPANY,            PR_COMPANY_NAME             },
            { L"Vcard.Department",              IDS_OPS_DEPARTMENT,         PR_DEPARTMENT_NAME          },
            { L"Vcard.Office",                  IDS_OPS_OFFICE,             PR_OFFICE_LOCATION,         },
            { L"Vcard.JobTitle",                IDS_OPS_JOBTITLE,           PR_TITLE                    },
            { L"Vcard.Pager",                   IDS_OPS_PAGER,              PR_PAGER_TELEPHONE_NUMBER   },
            
            { L"Vcard.Home.StreetAddress",      IDS_OPS_HOME_ADDRESS,       PR_HOME_ADDRESS_STREET      },
            { L"Vcard.Home.City",               IDS_OPS_HOME_CITY,          PR_HOME_ADDRESS_CITY        },
            { L"Vcard.Home.ZipCode",            IDS_OPS_HOME_ZIPCODE,       PR_HOME_ADDRESS_POSTAL_CODE },
            { L"Vcard.Home.State",              IDS_OPS_HOME_STATE,         PR_HOME_ADDRESS_STATE_OR_PROVINCE   },
            { L"Vcard.Home.Country",            IDS_OPS_HOME_COUNTRY,       PR_HOME_ADDRESS_COUNTRY     },
            { L"Vcard.Home.Phone",              IDS_OPS_HOME_PHONE,         PR_HOME_TELEPHONE_NUMBER    },
            { L"Vcard.Home.Fax",                IDS_OPS_HOME_FAX,           PR_HOME_FAX_NUMBER          },

            { L"Vcard.Business.StreetAddress",  IDS_OPS_BUSINESS_ADDRESS,   PR_BUSINESS_ADDRESS_STREET  },
            { L"Vcard.Business.City",           IDS_OPS_BUSINESS_CITY,      PR_BUSINESS_ADDRESS_CITY    },
            { L"Vcard.Business.Zipcode",        IDS_OPS_BUSINESS_ZIPCODE,   PR_BUSINESS_ADDRESS_POSTAL_CODE},
            { L"Vcard.Business.State",          IDS_OPS_BUSINESS_STATE,     PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE},
            { L"Vcard.Business.Country",        IDS_OPS_BUSINESS_COUNTRY,   PR_BUSINESS_ADDRESS_COUNTRY },
            
            { L"Vcard.Business.Phone",          IDS_OPS_BUSINESS_PHONE,     PR_BUSINESS_TELEPHONE_NUMBER},
            { L"Vcard.Business.Fax",            IDS_OPS_BUSINESS_FAX,       PR_BUSINESS_FAX_NUMBER      },
            { L"Vcard.Business.URL",            IDS_OPS_BUSINESS_URL,       PR_BUSINESS_HOME_PAGE       },
        };


// A sentinel value returned for unsuccessful searches
const   int     INVALID_ATTRIBUTE_INDEX = 0xFFFFFFFF;


// Compute the number of bytes necessary to hold a bit-vector for the
// Vcard schema where each attribute is represented by one bit.
const   DWORD   dwVcardCount    = ARRAYSIZE(rgProfAttr);
const   DWORD   dwVcardBytes    = (dwVcardCount+7) / 8;


const   DWORD   defExpireDays   = 7;            // Default expiration time in days
const   DWORD   maxExpireDays   = 30;           // Maximum allowed expiration period

// Number of 100-ns intervals per day
const   __int64 intervalsPerDay = (__int64) 10000000 * 3600 * 24;    

// Default and maximum expiration time in units of 100 nanoseconds
// (This is the format used for the FILETIME structure)
const   __int64 defExpiration = defExpireDays * intervalsPerDay;
const   __int64 maxExpiration = maxExpireDays * intervalsPerDay;


// Context-sensitive help IDS
const   DWORD   aHelpIDs[] =
{
    IDC_OPS_INFO_REQUESTED,     IDH_PA_OPS_REQUEST,
    IDC_OPS_URL,                IDH_PA_OPS_REQUEST,
    IDC_SITE_IDENTITY,          IDH_PA_OPS_REQUEST,
    IDC_OPS_LIST,               IDH_PA_OPS_LIST,
    IDC_USAGE_STRING,           IDH_PA_USAGE_STRING,
    IDC_VIEW_CERT,              IDH_PA_VIEW_CERT,
    IDC_EDIT_PROFILE,           IDH_EDIT_PROFILE_BTN,
    IDC_OPS_PRIVACY,            IDH_PA_CONNECTION_SECURITY,
    IDC_SECURITY_ICON,          IDH_PA_CONNECTION_SECURITY,
    IDC_SECURE_CONNECTION,      IDH_PA_CONNECTION_SECURITY,
    IDC_UNSECURE_CONNECTION,    IDH_PA_CONNECTION_SECURITY,
    IDC_KEEP_SETTINGS,          IDH_PA_ALWAYS_SHARE,
    0,                          0
};

WCHAR* _GetNameFromAttrIndex ( int index ) 
{
    // Assert that the index is valid.
    ASSERT(index>=0 && index<ARRAYSIZE(rgProfAttr));
    return rgProfAttr[index].pwzName;
}

INT _GetResourceIdFromAttrIndex( int index )
{
    // Assert that the index is valid.
    ASSERT(index>=0 && index<ARRAYSIZE(rgProfAttr));
    return rgProfAttr[index].id;
}

ULONG _GetPropTagFromAttrIndex( int index )
{
    // Assert that the index is valid.
    ASSERT(index>=0 && index<ARRAYSIZE(rgProfAttr));
    return rgProfAttr[index].ulPropTag;
}

//================================================
//   Implementation of the OPSRequestEntry object
//------------------------------------------------

int CIEFrameAuto::COpsProfile::OPSRequestEntry::destWrapper(void *pEntry, void *pUnused) 
{
    OPSRequestEntry *pReqEntry = (OPSRequestEntry*) pEntry;

    if ( pReqEntry )
    {
        delete pReqEntry;
        pReqEntry = NULL;
    }

    return TRUE; 
}

int CIEFrameAuto::COpsProfile::OPSRequestEntry::grantRequest(void *pEntry, void *pUnused)
{
    OPSRequestEntry *pReqEntry = (OPSRequestEntry*) pEntry;
    pReqEntry->grantRequest();
    return TRUE;
}

void CIEFrameAuto::COpsProfile::OPSRequestEntry::grantRequest() 
{
    m_fQuery    = FALSE;
    m_fAnswer   = TRUE; 
}

void CIEFrameAuto::COpsProfile::OPSRequestEntry::denyRequest() 
{   
    m_fQuery    = FALSE;
    m_fAnswer   = FALSE;
}

void CIEFrameAuto::COpsProfile::OPSRequestEntry::clearValue()
{   
    SysFreeString(m_bstrValue);
    m_bstrValue = NULL;
}

CIEFrameAuto::COpsProfile::OPSRequestEntry::OPSRequestEntry()
{
    m_fQuery        = TRUE;
    m_fAnswer       = FALSE;
    m_bstrValue     = NULL;
    m_bstrName      = NULL;
    m_bstrOldVal    = NULL;
}
   
CIEFrameAuto::COpsProfile::OPSRequestEntry::~OPSRequestEntry()
{
    SysFreeString(m_bstrName);
    SysFreeString(m_bstrValue);
    SysFreeString(m_bstrOldVal);
}

//================================================
//   Implementation of the COpsProfile object
//------------------------------------------------

CIEFrameAuto::COpsProfile::COpsProfile()
:    CAutomationStub( MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE ) 
{    
#ifdef NEVER
    m_pCert = NULL;
#endif  // NEVER

#ifdef _USE_PSTORE_   
    m_provID = GUID_NULL;
    m_pStore    = NULL;
    m_iStoreRef = 0;
#else
    m_bWABInit = FALSE;
    m_hInstWAB = NULL;
    m_lpAdrBook = NULL;
    m_lpWABObject = NULL;
    m_hrWAB = E_UNEXPECTED;
    m_SBMe.cb = 0;
    m_SBMe.lpb = NULL;
#endif  // _USE_PSTORE_

    m_fEnabled = FALSE;
        
    m_bstrLastURL = NULL;

    m_hdpaRequests = DPA_Create(0);
    m_hdpaChanges = DPA_Create(0);

    m_hP3Global     = NULL;
    m_hP3Sites      = NULL;

    //Begin a-thkesa	Initialize . See Windows BUG:589837.
    VariantInit(&m_vUsage);// a-thkesa. 
    m_vUsage.vt = VT_I4;
    m_vUsage.lVal = 8;
    //End a-thkesa
}


CIEFrameAuto::COpsProfile::~COpsProfile() 
{
    clearRequest();

#ifdef NEVER
    if (m_pCert)
        m_pCert->Release();
#endif  // NEVER

    for (unsigned i=m_iStoreRef; i>0; i--)
        _ReleaseStore();

#ifdef _USE_PSTORE_
    if (m_pStore)
        ATOMICRELEASE(m_pStore);
#else
    if (m_SBMe.lpb)
        m_lpWABObject->FreeBuffer(m_SBMe.lpb);

    if (m_lpAdrBook)
        ATOMICRELEASE(m_lpAdrBook);

    if (m_lpWABObject)
        ATOMICRELEASE(m_lpWABObject);

    if (m_hInstWAB)
        FreeLibrary(m_hInstWAB);
#endif  // _USE_PSTORE_

    // Prevent delay-loading of OLEAUT32.DLL if not necessary
    if (m_bstrLastURL)
        SysFreeString(m_bstrLastURL);

    RegCloseKey(m_hP3Global);
    RegCloseKey(m_hP3Sites);

    DPA_DestroyCallback(m_hdpaRequests, OPSRequestEntry::destWrapper, NULL);
    m_hdpaRequests = NULL;

    DPA_DestroyCallback(m_hdpaChanges, OPSRequestEntry::destWrapper, NULL);
    m_hdpaChanges = NULL;
}

HRESULT     CIEFrameAuto::COpsProfile::_CreateStore()
{
#ifdef _USE_PSTORE_
    if (m_iStoreRef == 0) 
    {
        HRESULT hr = PStoreCreateInstance(  &m_pStore,  
                                            IsEqualGUID(m_provID, GUID_NULL) ? NULL : &m_provID,
                                            NULL,
                                            0);
        if (SUCCEEDED(hr))
            m_iStoreRef++;

        return hr;
    }
    m_iStoreRef++;

    return S_OK;
#else
    if (!m_bWABInit) 
    {

        ASSERT(NULL == m_hInstWAB);
        ASSERT(NULL == m_lpAdrBook && NULL == m_lpWABObject);

        // Don't try initializing the wab again and again 
        m_bWABInit = TRUE;
        
        {
            // Figure out the location of the wab dll and try opening it.
            TCHAR szWABDllPath[MAX_PATH];
            DWORD dwType = 0;
            ULONG cbData = sizeof(szWABDllPath);
            HKEY hKey = NULL;

            *szWABDllPath = '\0';
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
                RegQueryValueEx( hKey, TEXT(""), NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);

            if(hKey) RegCloseKey(hKey);

            if (lstrlen(szWABDllPath) != 0 )
                m_hInstWAB = LoadLibrary (szWABDllPath);
            else
                m_hInstWAB = NULL;
        }

        HRESULT hr;
        if (m_hInstWAB)
        {
            LPWABOPEN lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hInstWAB, "WABOpen");
            
            if (lpfnWABOpen)
            {
                hr = lpfnWABOpen(&m_lpAdrBook, &m_lpWABObject, NULL, 0);

                if (NULL == m_lpAdrBook || NULL == m_lpWABObject)
                    hr = E_UNEXPECTED;
            }
            else 
            {
                hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);  // Not the right dll anyway!!
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
        }

        // Good so far, call GetMe.
        if (!hr)
        {
            m_SBMe.cb = 0;
            m_SBMe.lpb = NULL;
            hr = m_lpWABObject->GetMe(m_lpAdrBook, WABOBJECT_ME_NOCREATE | AB_NO_DIALOG, NULL, &m_SBMe, 0);

            if (0 == m_SBMe.cb || NULL == m_SBMe.lpb)
                hr = E_UNEXPECTED;
        }     

        // Remember the return code for later.
        m_hrWAB = hr;
    }
        
    if (!m_hrWAB)
        m_iStoreRef++;

    return m_hrWAB;
#endif
}

HRESULT     CIEFrameAuto::COpsProfile::_ReleaseStore()
{
    if (m_iStoreRef > 0) 
        m_iStoreRef--;

    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::Init() 
{
    DWORD   dwError;
    DWORD   dwAction;

    dwError = RegCreateKeyEx(HKEY_CURRENT_USER, 
                            rgszP3Global, 
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, 
                            NULL, 
                            &m_hP3Global, 
                            &dwAction);

    dwError = RegCreateKeyEx(HKEY_CURRENT_USER,
                            rgszP3Sites,
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &m_hP3Sites,
                            &dwAction);

    m_fEnabled = _IsP3Enabled();

 
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _profile, this);
    return CAutomationStub::Init( SAFECAST(this, IHTMLOpsProfile*), IID_IHTMLOpsProfile,
                        CLSID_COpsProfile, pauto );
}

HRESULT     CIEFrameAuto::COpsProfile::addReadRequest(BSTR bstrName, VARIANT reserved, VARIANT_BOOL *pfSuccess)
{
    if ( pfSuccess )
        *pfSuccess = VARIANT_FALSE;

    if (!m_fEnabled)
        return S_FALSE;

    if (bstrName==NULL)
        return E_POINTER;

    BSTR    bstrURL = NULL;
    HRESULT hr = _pAuto->get_LocationURL(&bstrURL);

    if (_DifferentURL())
        clearRequest();

    SysFreeString(m_bstrLastURL);
    m_bstrLastURL = SysAllocString(bstrURL);
    if (NULL == m_bstrLastURL)
    {
        return E_OUTOFMEMORY;
    }

    int index = _GetAttrIndexFromName(bstrName);
    if (index==INVALID_ATTRIBUTE_INDEX)
        return S_FALSE;

    // If the attribute already exists on the list, return from this function
    for (int i=0; i<DPA_GetPtrCount(m_hdpaRequests); i++)
    {
        OPSRequestEntry *pEntry = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests, i);

        if (StrCmpIW(pEntry->m_bstrName,bstrName)==0)
            return S_OK;
    }

    OPSRequestEntry *pNewEntry = new OPSRequestEntry;

    if (pNewEntry==NULL)
        return E_OUTOFMEMORY;

    pNewEntry->m_bstrName = SysAllocString(_GetNameFromAttrIndex(index));
    if (pNewEntry->m_bstrName==NULL) 
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    pNewEntry->m_bstrValue  = NULL;

    int eIns = DPA_AppendPtr(m_hdpaRequests, (void*) pNewEntry);
    if (eIns==-1) 
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    if ( pfSuccess )
        *pfSuccess = VARIANT_TRUE;
    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::clearRequest() 
{
    m_fEnabled = _IsP3Enabled();

    if (!m_fEnabled)
        return S_FALSE;
   
    DPA_EnumCallback(m_hdpaRequests, OPSRequestEntry::destWrapper, NULL);
    DPA_DeleteAllPtrs(m_hdpaRequests);
    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::doRequest(VARIANT usage, VARIANT fname, 
                                                 VARIANT vaDomain, VARIANT vaPath, VARIANT vaExpire,
                                                 VARIANT reserved)
{
    m_fEnabled = _IsP3Enabled();

    if (!m_fEnabled)
        return S_FALSE;

    int     i, k;
    HRESULT hr;

    BOOL    fShowUI = FALSE;
    BOOL    fPersistent = FALSE;

    BSTR    bstrURL;
    TCHAR   rgchURL[MAX_URL_STRING];
    TCHAR   rgchDomain[INTERNET_MAX_HOST_NAME_LENGTH+1];
    TCHAR   rgchPath[MAX_PATH+1];
    TCHAR   rgchScheme[16];

    URL_COMPONENTS      uc;
    AccessSettings      acSettings;

    HDPA    hdpaConfirm = DPA_Create(0);

    if (_DifferentURL())
    {
        clearRequest();
        return S_FALSE;
    }

    hr = _pAuto->get_LocationURL(&bstrURL);
    if (FAILED(hr))
        return S_FALSE;

    _StringFromBSTR(bstrURL, rgchURL, ARRAYSIZE(rgchURL));

    ZeroMemory(&uc, sizeof(uc));
    uc.dwStructSize = sizeof(URL_COMPONENTS);
    uc.lpszHostName = rgchDomain;
    uc.dwHostNameLength = ARRAYSIZE(rgchDomain);
    uc.lpszUrlPath = rgchPath;
    uc.dwUrlPathLength = ARRAYSIZE(rgchPath);
    uc.lpszScheme = rgchScheme;
    uc.dwSchemeLength = ARRAYSIZE(rgchScheme);

    InternetCrackUrl(rgchURL, lstrlen(rgchURL), ICU_DECODE, &uc);
    
    _GetSiteSettings(&uc, vaDomain, vaPath, vaExpire, &acSettings);

    hr = _CreateStore();
    if (FAILED(hr))
        return S_FALSE;

    if (DPA_GetPtrCount(m_hdpaRequests)==0)
        return S_OK;

    for (k=0; k<DPA_GetPtrCount(m_hdpaRequests); k++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,k);
        pCurrent->clearValue();
    }

    HWND hwnd = _pAuto->_GetHWND();
    INT_PTR nRet = -1;

    // #59340 - don't need special priviliges for local machine zone anymore.
    if (FALSE && _IsLocalMachine())
    {
        // If page is on the local machine, all requested information will be given
        DPA_EnumCallback(m_hdpaRequests, OPSRequestEntry::grantRequest, NULL);
        nRet = TRUE;
    }
    else
    {
        // Process the request list and mark attributes according to the configuration
        _ApplyPreferences(&uc, m_hdpaRequests);

        // Go through the request list and for each attribute that was not marked as
        // grant/deny according to the preferences, add it to the list
        for (k=0; k<DPA_GetPtrCount(m_hdpaRequests); k++)
        {
            OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,k);
            
            if (pCurrent->m_fQuery)
                DPA_AppendPtr(hdpaConfirm, pCurrent);
        }

        // Determine whether there are any attributes to query
        fShowUI = DPA_GetPtrCount(hdpaConfirm)>0;

        if (!fShowUI)
        {
            nRet = TRUE;
            goto HandleRequest;
        }

        // If a UI is going to be shown, all attributes that were going to be
        // given or denied silently should also be shown
        for (k=0; k<DPA_GetPtrCount(m_hdpaRequests); k++)
        {
            OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,k);
            if (!pCurrent->m_fQuery && 
                (pCurrent->m_fAnswer || (!pCurrent->m_fAnswer && pCurrent->m_dwDecision==P3_SITELEVEL)))
            {
                DPA_AppendPtr(hdpaConfirm, pCurrent);
                pCurrent->m_fQuery = TRUE;
            }
        }


        OPSDlgInfo opsDlgInfo;

        opsDlgInfo.m_hdpa = hdpaConfirm;
        StrCpyN(opsDlgInfo.m_rgchURL, rgchURL, ARRAYSIZE(opsDlgInfo.m_rgchURL));
        opsDlgInfo.m_pOpsProfile = this;
        opsDlgInfo.m_pacSettings = &acSettings;

        opsDlgInfo.m_fRemember = (_GetCookieSettings()==COOKIES_ALLOW);

        if (fname.vt == VT_BSTR && fname.bstrVal && lstrlenW(fname.bstrVal)>0)
            opsDlgInfo.m_bstrFName = SysAllocString(fname.bstrVal);
        else
            opsDlgInfo.m_bstrFName = NULL;

        _GetUsageCode(usage, opsDlgInfo.m_rgchUsage, ARRAYSIZE(opsDlgInfo.m_rgchUsage));

        //Beign a-thkesa  to solve Windows BUG:589837. Assigne the usage member for the next use.
        {
         m_vUsage.vt = usage.vt;
         m_vUsage.lVal = usage.lVal;
        }
        // End.
         
        OSVERSIONINFOA osvi;
        ZeroMemory(&osvi, sizeof(osvi));

        osvi.dwOSVersionInfoSize = sizeof(osvi);

        if (GetVersionExA((OSVERSIONINFOA*)&osvi) && (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId &&
            (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1 && LOWORD(osvi.dwBuildNumber) == 2600)))
        {
            HMODULE hmod = LoadLibrary(TEXT("xpsp1res.dll"));
            if (hmod)
            {
                nRet = (UINT) DialogBoxParam(hmod, MAKEINTRESOURCE(IDD_OPS_CONSENT),
                                                hwnd,
                                                _OPSConsent_DlgProc,
                                                (LPARAM) &opsDlgInfo);
                FreeLibrary(hmod);
            }
        }

        if(nRet == -1)
            nRet = DialogBoxParam(MLGetHinst(),
                                    MAKEINTRESOURCE(IDD_OPS_CONSENT),
                                    hwnd,
                                    _OPSConsent_DlgProc,
                                    (LPARAM) &opsDlgInfo);

        fPersistent = opsDlgInfo.m_fRemember;

    }

HandleRequest:

    if (nRet==-1)
        return E_FAIL;
    
    if (!nRet)
    {
        fPersistent = FALSE;
        goto Cleanup;
    }

    for (i=0; i<DPA_GetPtrCount(m_hdpaRequests); i++) 
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,i);
 
        if (pCurrent->m_fQuery)
        {
            pCurrent->m_prefs.m_lastRequest = pCurrent->m_fAnswer ? P3_ACCEPT : P3_REJECT;
            _PutUserPreference(pCurrent->m_bstrName, pCurrent->m_prefs);
        }

        if (pCurrent->m_fAnswer)
        {
            hr = _GetFieldValue(pCurrent->m_bstrName, & (pCurrent->m_bstrValue));
            if (FAILED(hr))
                pCurrent->clearValue();
        }
    }

    if (fShowUI && fPersistent &&
        (uc.nScheme==INTERNET_SCHEME_HTTP || uc.nScheme==INTERNET_SCHEME_HTTPS))
    {
        _UpdateSiteSettings(&acSettings, m_hdpaRequests);
    }

Cleanup:
    DPA_Destroy(hdpaConfirm);
    hdpaConfirm = NULL;
    _ReleaseStore();
    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::getAttribute(BSTR bstrAttribName, BSTR *pbstrAttribValue) 
{
    if (!m_fEnabled)
        return S_FALSE;
    
    if (pbstrAttribValue==NULL || bstrAttribName==NULL)
        return E_POINTER;

    *pbstrAttribValue = NULL;

    //
    // SECURITY: Since shdocvw has no notion of frames, 
    // we now prompt on every attempt to get attributes.
    // See Windows bugs 536637 & 549409 for details.
    //

    VARIANT_BOOL vbSuccess;
    VARIANT vError, vUsage, vName;
    VariantInit(&vError);
    VariantInit(&vUsage);
    VariantInit(&vName);
    vError.vt = VT_ERROR;
    vError.scode = DISP_E_PARAMNOTFOUND;
    
    //a-thkesa to solve Windows BUG:589837. Assign the usage member for the this use.
    //Begin comment a-thkesa   
    //vUsage.vt = VT_I4;
    //vUsage.lVal = 8;
    //End
    vUsage = m_vUsage ;// a-thkesa to solve Windows BUG:589837

    vName.vt = VT_EMPTY;
    clearRequest();
    addReadRequest(bstrAttribName, vError, &vbSuccess);
    if (vbSuccess == VARIANT_FALSE)
        return E_FAIL;
    doReadRequest(vUsage, vName, vError, vError, vError, vError);

    for (int i=0; i<DPA_GetPtrCount(m_hdpaRequests); i++) 
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,i);

        if (StrCmpIW(bstrAttribName,pCurrent->m_bstrName) == 0) 
        {
            if (pCurrent->m_bstrValue == NULL)
            {
                *pbstrAttribValue = SysAllocString(L"");
            }
            else
            {
                *pbstrAttribValue = SysAllocString(pCurrent->m_bstrValue);
            }
            return (*pbstrAttribValue == NULL) ? E_OUTOFMEMORY : S_OK;
        }
    }

    return S_FALSE;
}

HRESULT     CIEFrameAuto::COpsProfile::setAttribute(BSTR bstrAttribName, BSTR bstrAttribValue, VARIANT vaPrefs,
                                                    VARIANT_BOOL *pfSuccess)
{
    BSTR bstrStdName = NULL;
    HRESULT hr = S_FALSE;

    if (pfSuccess)
        *pfSuccess = VARIANT_FALSE;

    if (!m_fEnabled)
        return S_FALSE;

    if (bstrAttribName==NULL)
        return E_POINTER;

    // If this is a new URL, flush the change queue.
    if (_DifferentURL())
    {
        DPA_EnumCallback(m_hdpaChanges,OPSRequestEntry::destWrapper,NULL);
        DPA_DeleteAllPtrs(m_hdpaChanges);
    }

    // Load the name of the current URL into the last visited URL
    SysFreeString(m_bstrLastURL);
    _pAuto->get_LocationURL(&m_bstrLastURL);

    int index = _GetAttrIndexFromName(bstrAttribName);
    if (index==INVALID_ATTRIBUTE_INDEX)
        return S_FALSE;

    OPSRequestEntry *pNewEntry = new OPSRequestEntry;
    if (pNewEntry == NULL)
        return E_OUTOFMEMORY;
    
    pNewEntry->m_bstrName = SysAllocString(_GetNameFromAttrIndex(index));
    if (pNewEntry->m_bstrName==NULL)
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    if (bstrAttribValue != NULL)
        pNewEntry->m_bstrValue = SysAllocString(bstrAttribValue);
    else
        pNewEntry->m_bstrValue = SysAllocString(L"");

    if (pNewEntry->m_bstrValue==NULL)
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    for (int i=0; i<DPA_GetPtrCount(m_hdpaChanges); i++) 
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaChanges,i);

        if (StrCmpIW(pCurrent->m_bstrName, bstrAttribName) == 0)
        {
            SysFreeString(pCurrent->m_bstrValue);
            pCurrent->m_bstrValue = SysAllocString(bstrAttribName);

            if (*pfSuccess)
                *pfSuccess = (pCurrent->m_bstrValue!=NULL) ? VARIANT_TRUE : VARIANT_FALSE;

            delete pNewEntry;

            return S_OK;
        }
    }

    int eIns = DPA_AppendPtr(m_hdpaChanges, pNewEntry);
    if (eIns==-1) 
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    if (pfSuccess)
        *pfSuccess = VARIANT_TRUE;

    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::commitChanges(VARIANT_BOOL *pfSuccess) {

    if ( pfSuccess )
        *pfSuccess = VARIANT_FALSE;

    if (!m_fEnabled)
        return S_FALSE;

    HRESULT hr;
    HWND hwnd;
    int i;
    INT_PTR nRet;
    OPSDlgInfo opsDlgInfo;

    BSTR    bstrURL = NULL;
    TCHAR   rgchURL[MAX_URL_STRING];

    _pAuto->get_LocationURL(&bstrURL);
    _StringFromBSTR(bstrURL, rgchURL, ARRAYSIZE(rgchURL));
    SysFreeString(bstrURL);

    // Crack the URL and get the hostname
    TCHAR   rgchHostName[INTERNET_MAX_HOST_NAME_LENGTH] = { TEXT('\0') };
    DWORD   dwcbHostLen = ARRAYSIZE(rgchHostName);
    UrlGetPart(rgchURL, rgchHostName,  &dwcbHostLen, URL_PART_HOSTNAME, 0);

    // Read the hostname for the registration page from the registry 
    TCHAR   rgchRegDomain[INTERNET_MAX_HOST_NAME_LENGTH];
    DWORD   dwcbReg = sizeof(rgchRegDomain);

    HKEY    hWriteKey = NULL;
    DWORD   dwError;

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgszRegKey, 0, KEY_READ, &hWriteKey);

    if (dwError==ERROR_SUCCESS)
    {
        dwError = RegQueryValueEx(hWriteKey, rgszRegTxt, NULL, NULL, (LPBYTE) rgchRegDomain, &dwcbReg);
        RegCloseKey(hWriteKey);
    }

    BOOL  fRegDomain = (dwError==ERROR_SUCCESS && _DomainMatch(rgchHostName, rgchRegDomain));
    BOOL  fCanWrite = _IsLocalMachine() || fRegDomain;

    if (!fCanWrite || _DifferentURL())
        goto Cleanup;

    hr = _CreateStore();
    if (hr)
        goto Cleanup;

    // Look up the old values from the store
    for (i=0; i<DPA_GetPtrCount(m_hdpaChanges); i++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaChanges, i);

        // Default case: the attribute will be updated
        pCurrent->m_fAnswer = TRUE;

        hr = _GetFieldValue (pCurrent->m_bstrName, &(pCurrent->m_bstrOldVal));
        if (hr)
        {
            SysFreeString(pCurrent->m_bstrOldVal);
            pCurrent->m_bstrOldVal = NULL;
        }
    }

    // Delete nodes in the list if the new value is the same as the old one
    // NOTE: The loop counter will remain stationary or increment depending on whether
    // the current node in the list is deleted
    for (i=0; i<DPA_GetPtrCount(m_hdpaChanges); )
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaChanges, i);

        if (StrCmpW(pCurrent->m_bstrValue, pCurrent->m_bstrOldVal)==0)
            DPA_DeletePtr(m_hdpaChanges, i);
        else
            i++;
    }

    // If nothing has changed, then we do not need to write data back to the storage
    if (DPA_GetPtrCount(m_hdpaChanges)==0)     
        goto Cleanup;  

    // The registration domain can write profile information silently.
    // For all other cases, a UI will be displayed.
    if (!fRegDomain)
    {

        // Pop up a UI to show the items that are being changes and allow the user to 
        // confirm the changes by selecting check-boxes for each attribute
        opsDlgInfo.m_hdpa = m_hdpaChanges;
        opsDlgInfo.m_pOpsProfile = this;

        hwnd = _pAuto->_GetHWND();
        nRet = DialogBoxParam(MLGetHinst(),
                                MAKEINTRESOURCE(IDD_OPS_UPDATE),
                                hwnd,
                                _OPSUpdate_DlgProc,
                                (LPARAM) &opsDlgInfo
                            );

        // Unrecoverable error: failed to show the dialog box
        if (nRet==-1)
            return S_FALSE;

        // If the user clicked "CANCEL", then no changes will be performed
        if (nRet==0)
            goto Cleanup;
    }

    if ( pfSuccess )
        *pfSuccess = VARIANT_TRUE;

    for (i=0; i<DPA_GetPtrCount(m_hdpaChanges); i++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaChanges, i);

        // Registration page should not overwrite existing entries
        if (fRegDomain && ! EMPTY_STRINGW(pCurrent->m_bstrOldVal))
            continue;

        // Update only if the user allowed in the UI
        // For the registration page, this condition will hold for all attributes
        if (pCurrent->m_fAnswer)
        {
            hr = _SetFieldValue(pCurrent->m_bstrName, pCurrent->m_bstrValue);
            if (hr && pfSuccess)
                *pfSuccess = VARIANT_FALSE;
        }
     }

Cleanup:

    // Clear the queue that holds the changes 
    DPA_EnumCallback(m_hdpaChanges,OPSRequestEntry::destWrapper,NULL);
    DPA_DeleteAllPtrs(m_hdpaChanges);

    return S_OK;
}

// *** IOpsProfileSimple members ***
STDMETHODIMP CIEFrameAuto::COpsProfile::ReadProperties(long lNumProperties, const LPCWSTR szProperties[], LPWSTR szReturnValues[])
{
    HRESULT hr=S_OK;

    for (int i=0; i<lNumProperties; i++)
    {
        BSTR bstrValue=NULL;
        LPWSTR pwszRet=NULL;

        if (szProperties[i])
        {
            _GetFieldValue(szProperties[i], &bstrValue);

            if (bstrValue)
            {
                // FEATURE change _GetFieldValue so we don't reallocate twice unnecessarily
                int cch = (1 + lstrlenW(bstrValue));

                pwszRet = (LPWSTR) CoTaskMemAlloc(sizeof(WCHAR) * cch);

                if (pwszRet)
                    StrCpyNW(pwszRet, bstrValue, cch);

                SysFreeString(bstrValue);
            }
            else
            {
                hr = S_FALSE;
            }
        }

        szReturnValues[i] = pwszRet;
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COpsProfile::WriteProperties(long lNumProperties, const LPCWSTR szProperties[], const LPCWSTR szValues[])
{
    return E_NOTIMPL;
}


#ifdef _USE_PSTORE_

HRESULT     CIEFrameAuto::COpsProfile::_GetFieldValue(const OLECHAR *pszField, BSTR * pbstrValue) 
{

    GUID            itemType = GUID_NULL;
    GUID            itemSubtype = GUID_NULL;
    BSTR            bstrName = NULL;
    DWORD           cbData;
    BYTE *          pbData = NULL;
    PST_PROMPTINFO  promptInfo;

    HRESULT         hr;
    BOOL            fOpen = FALSE;

    if (pszField==NULL || pbstrValue==NULL)
        return E_POINTER;

    ZeroMemory(&promptInfo,sizeof(promptInfo));
    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.szPrompt = pszField;
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = _pAuto->_GetHWND();

    hr = _CreateStore();
    if (hr)
        goto Cleanup;

    hr = _GetPStoreTypes(pszField, &itemType, &itemSubtype, &bstrName);
    if (hr)
        goto Cleanup;

    hr =    m_pStore->ReadItem(
                        s_Key,
                        &itemType,
                        &itemSubtype,
                        bstrName,
                        &cbData,
                        &pbData,
                        &promptInfo,
                        0);
    if (FAILED(hr))
    {
        *pbstrValue = SysAllocString(L"");
        hr = S_OK;
        goto Cleanup;
    }

    *pbstrValue = SysAllocString((OLECHAR *) pbData);

Cleanup:
    _ReleaseStore();
    CoTaskMemFree(pbData);
    SysFreeString(bstrName);
    return hr;
}

HRESULT     CIEFrameAuto::COpsProfile::_SetFieldValue(const OLECHAR *pszField, BSTR bstrValue) 
{
    
    HRESULT         hr;
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo;
    WCHAR *         szValue = bstrValue ? bstrValue : L"";
    TCHAR           szDisplayName[MAX_PATH];
    WCHAR           wzDisplayName[MAX_PATH];

    if (pszField==NULL)
        return E_POINTER;

    MLLoadString(IDS_PROFILE_ASSISTANT, szDisplayName, ARRAYSIZE(szDisplayName));

    typeInfo.cbSize = sizeof(typeInfo);
    int cch = MultiByteToWideChar(  CP_ACP, 0, szDisplayName, -1, 
                                    wzDisplayName, ARRAYSIZE(wzDisplayName));
    ASSERT(cch != 0); 
    typeInfo.szDisplayName = wzDisplayName;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = _pAuto->_GetHWND();  
    promptInfo.szPrompt = pszField;

    hr = _CreateStore();
    if (hr)
        goto Cleanup;

    hr = m_pStore->CreateType(s_Key, &GUID_PStoreType, &typeInfo, 0);
    if (hr && (hr != PST_E_TYPE_EXISTS))
        goto Cleanup;

    hr = m_pStore->CreateSubtype(
                            s_Key,
                            &GUID_PStoreType,
                            &GUID_NULL,
                            &typeInfo,
                            NULL,
                            0);
    if (hr && (hr != PST_E_TYPE_EXISTS))
        goto Cleanup;

    hr = m_pStore->WriteItem(
                        s_Key,
                        &GUID_PStoreType,
                        &GUID_NULL,
                        pszField,
                        (lstrlenW(szValue) + 1) * sizeof(WCHAR),
                        (BYTE *) szValue,
                        &promptInfo,
                        PST_CF_NONE,
                        0);

Cleanup:
    _ReleaseStore();
    return hr;
}

#else       // _USE_PSTORE_

HRESULT     CIEFrameAuto::COpsProfile::_GetFieldValue(const OLECHAR *pszField, BSTR * pbstrValue) 
{

    LPMAILUSER lpMailUser = NULL;
    ULONG ulPropTag; 
    ULONG ulObjType = 0;
    WCHAR * pwzValue = NULL;
    BOOL bStoreCreated = FALSE;
    HRESULT hr;

    if (pszField==NULL || pbstrValue==NULL)
        return E_POINTER;
     
    hr = _CreateStore();
    if (hr)
        goto Cleanup;
    else
        bStoreCreated = TRUE;

    INT index;
    index = INVALID_ATTRIBUTE_INDEX;
    if (!_ValidateElemName(pszField, &index))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    // Open the entry in the address book. 

    hr = m_lpAdrBook->OpenEntry(m_SBMe.cb, 
                                (LPENTRYID) m_SBMe.lpb,
                                NULL,
                                0,
                                &ulObjType,
                                (LPUNKNOWN *)&lpMailUser);

    if (hr)
        goto Cleanup;

    if (lpMailUser)
    {
        ulPropTag = _GetPropTagFromAttrIndex(index);
        SPropTagArray SPTA;
        SPTA.cValues = 1;
        SPTA.aulPropTag[0] = ulPropTag;

        if (PROP_TYPE(ulPropTag) ==  PT_TSTRING || ulPropTag == PR_GENDER)
        {
            DWORD cValues = 0;
            LPSPropValue lpSPropValue = NULL;

            hr = lpMailUser->GetProps(&SPTA, 0, &cValues, &lpSPropValue);
            if (!hr)
            {
                ASSERT(1 == cValues);
                ASSERT(NULL != lpSPropValue);

                int cch = 0;
                LPCTSTR pszPropStr = NULL; 
                
                if (ulPropTag == PR_GENDER)
                {
                    switch (lpSPropValue->Value.i) 
                    {
                        case 1:
                            pszPropStr = GENDER_FEMALE;
                            break;
                        case 2:
                            pszPropStr = GENDER_MALE;
                            break;
                        default:
                            pszPropStr = GENDER_UNSPECIFIED;
                            break;
                    }
                }
                else
                {
                    ASSERT(PROP_TYPE(lpSPropValue->ulPropTag) == PT_TSTRING);
                    pszPropStr = lpSPropValue->Value.LPSZ;
                }

                if (pszPropStr)
                {

#ifdef _UNICODE
                    cch = lstrlen(pszPropStr) + 1;
#else                    
                    // We get the string back in ANSI convert to Unicode.
                    cch = MultiByteToWideChar(CP_ACP, 0, pszPropStr, -1, NULL, 0);
#endif
                    pwzValue = new WCHAR [cch];
                    if (NULL == pwzValue)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
#ifdef _UNICODE
                        StrCpyN(pwzValue, pszPropStr, cch);
#else
                        cch = MultiByteToWideChar(CP_ACP, 0, pszPropStr, -1, pwzValue, cch);
                        ASSERT(0 != cch);
#endif
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);    // This will cause us to just return the NULL string.                                                                                                                                                                                                                                    
                }
            }

            m_lpWABObject->FreeBuffer(lpSPropValue);
        }
        else 
        {
            // If this assert fires you are probably adding a new PR_* mapping to the OPS code.
            // You will need to write code to convert the returned value to a string meaningfully.
            // See the example for GENDER above.
            ASSERT(FALSE);  
            hr = E_NOTIMPL ; 
        }
    }
    else 
    {
        hr = E_UNEXPECTED;
    }                

    if (hr)
    {
        *pbstrValue = SysAllocString(L"");
        hr = (NULL != pbstrValue) ? S_OK : E_OUTOFMEMORY;
        goto Cleanup;
    }

    *pbstrValue = SysAllocString((OLECHAR *) pwzValue);

Cleanup:

    if (bStoreCreated)
        _ReleaseStore();

    if (lpMailUser)
        lpMailUser->Release();

    delete [] pwzValue;

    return hr;
}

HRESULT     CIEFrameAuto::COpsProfile::_SetFieldValue(const OLECHAR *pszField, BSTR bstrValue) 
{
    HRESULT         hr;
    LPMAILUSER lpMailUser = NULL;
    ULONG ulPropTag; 
    ULONG ulObjType = 0;
    BOOL bStoreCreated = FALSE;

    if (pszField==NULL)
        return E_POINTER;

     
    hr = _CreateStore();
    if (hr)
        goto Cleanup;
    else
        bStoreCreated = TRUE;

    INT index;
    index = INVALID_ATTRIBUTE_INDEX;
    if (!_ValidateElemName(pszField, &index))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Open the entry in the address book. 
    hr = m_lpAdrBook->OpenEntry(m_SBMe.cb, 
                                (LPENTRYID) m_SBMe.lpb,
                                NULL,
                                MAPI_MODIFY,
                                &ulObjType,
                                (LPUNKNOWN *)&lpMailUser);

    if (hr)
        goto Cleanup;

    if (lpMailUser)
    {
        ulPropTag = _GetPropTagFromAttrIndex(index);

        if (PROP_TYPE(ulPropTag) ==  PT_TSTRING || ulPropTag == PR_GENDER)
        {
            // First remove the existing entry
            SPropTagArray SPTA;
            SPTA.cValues = 1;
            SPTA.aulPropTag[0] = ulPropTag;

            lpMailUser->DeleteProps(&SPTA, NULL);

            SPropValue prop;
            prop.ulPropTag = ulPropTag;
            CHAR *pszValue = NULL;

            if (ulPropTag == PR_GENDER)
            {
                short int i = 0;    // unspecified.
                if (0 == StrCmpIW(bstrValue, GENDER_FEMALE_W))
                    i = 1;
                else if (0 == StrCmpIW(bstrValue, GENDER_MALE_W))
                    i = 2;

                prop.Value.i = i;
            }
            else 
            {
                prop.Value.LPSZ = bstrValue;   
            }

            if (!hr)
            {
                hr = lpMailUser->SetProps(1, &prop, NULL);
                lpMailUser->SaveChanges(0);
            }
            
            delete [] pszValue;
        }                                                           
        else 
        {
            hr = E_NOTIMPL ; // FIX THIS BEFORE CHECKING IN. 
        }
    }
    else 
    {
        hr = E_UNEXPECTED;
    }                


Cleanup:

    if (bStoreCreated)
        _ReleaseStore();

    if (lpMailUser)
        lpMailUser->Release();

    return hr;
}

#endif      // ! _USE_PSTORE_

HRESULT     CIEFrameAuto::COpsProfile::_GetIDispatchExDelegate(IDispatchEx ** const delegate) 
{
    if( !delegate )
        return E_POINTER;

    *delegate = NULL;    // We do not handle expandos yet
    return DISP_E_MEMBERNOTFOUND;
}

HRESULT     CIEFrameAuto::COpsProfile::_InternalQueryInterface(REFIID riid, void ** const ppvObjOut)
{
    ASSERT( this );
    ASSERT( !IsEqualIID(riid, IID_IUnknown) );

    if (IsEqualIID(riid, IID_IHTMLOpsProfile))
    {
        *ppvObjOut = SAFECAST(this,IHTMLOpsProfile*);
    }
    else if (IsEqualIID(riid, IID_IOpsProfileSimple))
    {
        *ppvObjOut = SAFECAST(this,IOpsProfileSimple*);
    }
    else
    {
        *ppvObjOut = NULL;
        return E_NOINTERFACE;
    }

    AddRef( );
    return S_OK;
}

#ifdef _USE_PSTORE_

HRESULT
CIEFrameAuto::COpsProfile::_GetPStoreTypes(
        BSTR bstrField,
        GUID * pguidType,
        GUID * pguidSub,
        BSTR * pbstrName)
{
    *pguidType = GUID_PStoreType;
    *pguidSub = GUID_NULL;

    *pbstrName = SysAllocString(bstrField);

    return S_OK;
}
#endif  // _USE_PSTORE_

// Functions to display the consent dialog.

BOOL CIEFrameAuto::COpsProfile::_OPSConsent_OnInitDlg(HWND hDlg)
{
    const   int cbMaxStringDisplay  = 24;
    
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO) GetWindowLongPtr(hDlg, DWLP_USER);
    COpsProfile *pProfile = lpOpsDlgInfo->m_pOpsProfile;

    if (!lpOpsDlgInfo || !lpOpsDlgInfo->m_hdpa)
        return FALSE;

    // Get the hostname
    TCHAR   rgSiteName[MAX_URL_STRING];
    DWORD   dwchOut = ARRAYSIZE(rgSiteName);

    HRESULT hr;
    
    hr = UrlGetPart(lpOpsDlgInfo->m_rgchURL, rgSiteName, &dwchOut, URL_PART_HOSTNAME, 0);
    if (FAILED(hr) || dwchOut == 0 )
        StrCpyN(rgSiteName, lpOpsDlgInfo->m_rgchURL, ARRAYSIZE(rgSiteName));

    // Display site identity information
    HWND        hwndReq = GetDlgItem(hDlg, IDC_SITE_IDENTITY);
    TCHAR       rgRequestInfo[MAX_URL_STRING];
    TCHAR       rgFormat[MAX_URL_STRING];

    BSTR        bstrFName = lpOpsDlgInfo->m_bstrFName;
    TCHAR       rgFName[MAX_URL_STRING];

    MLLoadString(IDS_DEFAULT_FNAME, rgFName, ARRAYSIZE(rgFName));

    MLLoadString(IDS_OPS_REQUEST, rgFormat, ARRAYSIZE(rgFormat));
    wnsprintf(rgRequestInfo, ARRAYSIZE(rgRequestInfo), rgFormat, rgFName);
    SetWindowText(hwndReq, rgRequestInfo);

    // Display the access settings
    TCHAR rgchAccessPath[MAX_URL_STRING];
    HWND hwndURL = GetDlgItem(hDlg, IDC_OPS_URL);
    _FormatSiteSettings(lpOpsDlgInfo->m_pacSettings, rgchAccessPath, ARRAYSIZE(rgchAccessPath));
    SetWindowText(hwndURL, rgchAccessPath);

    // Display the usage information
    HWND hwndUsage = GetDlgItem(hDlg, IDC_USAGE_STRING);
    SetWindowText(hwndUsage, lpOpsDlgInfo->m_rgchUsage);

    // Detect SSL and inform user in the lower pane
    BOOL fUsingSSL = pProfile->_IsUsingSSL();

    if (fUsingSSL) 
    {
        // If the connection is SSL, the default is to remember the settings
        lpOpsDlgInfo->m_fRemember = TRUE;          

        // Hide the unsecure connection text.
        HWND hwndStatic = GetDlgItem(hDlg, IDC_UNSECURE_CONNECTION);
        ASSERT(hwndStatic != NULL);
        ShowWindow(hwndStatic, SW_HIDE);

        HICON hicon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_LOCK));
        if (hicon != NULL)
        {
             HICON hiconOld = (HICON)SendDlgItemMessage(hDlg, IDC_SECURITY_ICON, STM_SETICON, 
                                                                (WPARAM)hicon, 0);
            if (hiconOld)
            {
                DestroyIcon(hiconOld);
            }
        }
    }
    else
    {
        // Hide the view certificate button and the secure connection text.
        HWND hwndViewCert = GetDlgItem(hDlg, IDC_VIEW_CERT);
        ASSERT(hwndViewCert != NULL);
        ShowWindow(hwndViewCert, SW_HIDE);

        HWND hwndStatic = GetDlgItem(hDlg, IDC_SECURE_CONNECTION);
        ASSERT(hwndStatic != NULL);
        ShowWindow(hwndStatic, SW_HIDE);
    }

    // Hide the Edit Profile button if we are using the PStore.
#ifdef _USE_PSTORE
    HWND hwndEditProf = GetDlgItem(hDlg, IDC_EDIT_PROFILE);
    ASSERT(hwndEditProf != NULL);
    ShowWindow(hwndEditProf, SW_HIDE);
#endif

    Button_SetCheck(GetDlgItem(hDlg, IDC_KEEP_SETTINGS), lpOpsDlgInfo->m_fRemember);    

    HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
    ASSERT(hwndLV);

    // Initialize the list view control
    ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_CHECKBOXES);

    // Setup the columns for the list view control. 
    LV_COLUMN lvc = { LVCF_FMT , LVCFMT_LEFT };

    ListView_InsertColumn(hwndLV, 0, &lvc); 
    ListView_InsertColumn(hwndLV, 1, &lvc); 

    // Add elements to the list view. 
    _OPSConsent_ShowRequestedItems(hDlg);

    // show the items.
    ListView_RedrawItems(hwndLV, 0, ListView_GetItemCount(hwndLV));
    UpdateWindow(hwndLV);

    return TRUE;
}

BOOL
CIEFrameAuto::COpsProfile::_OPSConsent_ShowRequestedItems(HWND hDlg)
{
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO) GetWindowLongPtr(hDlg, DWLP_USER);
    COpsProfile *pProfile = lpOpsDlgInfo->m_pOpsProfile;

    HDPA hdpaList = lpOpsDlgInfo->m_hdpa;
    HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
    ASSERT(hwndLV);

    BOOL  fAllBlank = TRUE;

    TCHAR szName[MAX_PROFILE_NAME];

    // Initialize the common parts of the LVI
    LV_ITEM lvi = { 0 };

    for (int i=DPA_GetPtrCount(hdpaList)-1; i>=0; i--)
    {
        OPSRequestEntry * pOpsEntry = (OPSRequestEntry*) DPA_FastGetPtr(hdpaList,i);

        MLLoadString(_GetResourceIdFromAttrName(pOpsEntry->m_bstrName), szName, MAX_PATH);
        
        BSTR    bstrValue = NULL;
        TCHAR   rgchValue[1024];

        pProfile->_GetFieldValue(pOpsEntry->m_bstrName, &bstrValue);
        _StringFromBSTR(bstrValue, rgchValue, ARRAYSIZE(rgchValue));

        fAllBlank = fAllBlank && EMPTY_STRING(rgchValue);

        TCHAR *pchNewLine = StrPBrk(rgchValue, TEXT("\r\n"));
        if (pchNewLine)
            *pchNewLine = '\0';

        if (lstrlen(rgchValue)==0)
        {
            MLLoadString(IDS_OPS_BLANK, rgchValue, ARRAYSIZE(rgchValue));
        }

        SysFreeString(bstrValue);

        lvi.mask        = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
        lvi.iItem       = 0;
        lvi.iSubItem    = 0;
        lvi.pszText     = szName;
        lvi.cchTextMax  = MAX_PROFILE_NAME;
        lvi.stateMask   = LVIS_STATEIMAGEMASK;
        lvi.state       = pOpsEntry->m_fAnswer ? 0x00002000 : 0x00001000;
        lvi.lParam      = (LPARAM)pOpsEntry;

        int iItem = ListView_InsertItem(hwndLV, &lvi);

        lvi.mask        = LVIF_TEXT;
        lvi.iItem       = iItem;
        lvi.iSubItem    = 1;
        lvi.pszText     = rgchValue;
        ListView_SetItem(hwndLV, &lvi);

        // APPCOMPAT: There is a problem with the listview implementation because of which
        // the check box is not displayed even though lvi.state is set correctly.
        //  We have to find the item and set it again.
        ListView_SetItemState(hwndLV, iItem, pOpsEntry->m_fAnswer ? 0x00002000 : 0x00001000, LVIS_STATEIMAGEMASK);
    }

    lpOpsDlgInfo->m_fAllBlank = fAllBlank;

    // Autosize the columns
    ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndLV, 1, LVSCW_AUTOSIZE);

    return TRUE;
}


BOOL CIEFrameAuto::COpsProfile::_OPSDlg_OnClose(HWND hDlg)
{
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
    int nItems = ListView_GetItemCount(hwndLV);

    LV_ITEM lvi = {0};
    lvi.mask    = LVIF_PARAM ;        

    for (int i = 0; i < nItems ; i++ )
    {
        lvi.iItem = i;
        lvi.lParam = 0;
        
        ListView_GetItem(hwndLV, &lvi);

        ASSERT(lvi.lParam != NULL)
        if (lvi.lParam)
        {
            OPSRequestEntry * pOpsEntry = (OPSRequestEntry *)lvi.lParam;
            
            pOpsEntry->m_fAnswer = ListView_GetCheckState(hwndLV, i);
        }
    }

    lpOpsDlgInfo->m_fRemember = Button_GetCheck(GetDlgItem(hDlg, IDC_KEEP_SETTINGS));    
    
    return TRUE;
}                                    


BOOL CIEFrameAuto::COpsProfile::_OPSConsent_EditProfile(HWND hDlg)
{
#ifdef _USE_PSTORE
    return FALSE;
#else
    HRESULT hr;
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!lpOpsDlgInfo || !lpOpsDlgInfo->m_hdpa)
        return FALSE;   
    
    CIEFrameAuto::COpsProfile * pOpsProfile = lpOpsDlgInfo->m_pOpsProfile;
    if (pOpsProfile == NULL || pOpsProfile->m_lpAdrBook == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }
        
    if (pOpsProfile->m_SBMe.cb == 0)
        return FALSE;
             
    LPSBinary lpSB = &(pOpsProfile->m_SBMe);

    // Display the WAB dialog for the me entry. 
    hr = pOpsProfile->m_lpAdrBook->Details(  (LPULONG) &hDlg,
                                        NULL,
                                        NULL,
                                        lpSB->cb,
                                        (LPENTRYID)lpSB->lpb,
                                        NULL,
                                        NULL,
                                        NULL,
                                        0);

    return (hr) ? FALSE : TRUE;
#endif
}


BOOL CIEFrameAuto::COpsProfile::_OPSConsent_OnCommand(HWND hDlg, UINT id, UINT nCmd)
{
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (id)
    {
        case IDOK:
            if (lpOpsDlgInfo->m_fAllBlank)
            {
                // The user has agreed to share information but all the entries in the 
                // profile are blank. This is probably due to user oversight, since the
                // easier way to achieve the same effect would be to select "DENY"

                TCHAR   rgchHeading[256];
                MLLoadShellLangString(IDS_PROFILE_ASSISTANT, rgchHeading, ARRAYSIZE(rgchHeading));

                TCHAR   rgchConfirm[1024];
                MLLoadShellLangString(IDS_OPS_NO_INFORMATION, rgchConfirm, ARRAYSIZE(rgchConfirm));

                ULONG_PTR uCookie = 0;
                SHActivateContext(&uCookie);
                DWORD msgRet = MessageBox(hDlg, rgchConfirm, rgchHeading, MB_YESNO | MB_DEFBUTTON1 | MB_ICONWARNING);
                if (uCookie)
                {
                    SHDeactivateContext(uCookie);
                }

                if (msgRet==IDYES)
                    goto FallThrough;
            }
        
            if (! Button_GetCheck(GetDlgItem(hDlg, IDC_KEEP_SETTINGS))  &&
                  (_GetCookieSettings()==COOKIES_ALLOW))
            {
                // The user wants to share information for one time only but cookies
                // are enabled, allowing sites to store profile information in a cookie
                DWORD   dwConfirm = 0;
                TCHAR   rgchHeading[256];
                TCHAR   rgchConfirm[1024];
                AccessSettings *pac = lpOpsDlgInfo->m_pacSettings;

                MLLoadShellLangString(IDS_PROFILE_ASSISTANT, rgchHeading, ARRAYSIZE(rgchHeading));
                MLLoadShellLangString(IDS_OPS_CONFIRM, rgchConfirm, ARRAYSIZE(rgchConfirm));

                ULONG_PTR uCookie = 0;
                SHActivateContext(&uCookie);
                dwConfirm = MessageBox(hDlg, rgchConfirm, rgchHeading, MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2);
                if (uCookie)
                {
                    SHDeactivateContext(uCookie);
                }

                if (dwConfirm!=IDOK)
                    break;
            }

            _OPSDlg_OnClose(hDlg);        
            EndDialog(hDlg, TRUE);
            break;

FallThrough:

        case IDC_EDIT_PROFILE:
            {
                HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
                ListView_DeleteAllItems(hwndLV);
    
                _OPSConsent_EditProfile(hDlg);
            
                _OPSConsent_ShowRequestedItems(hDlg);
                ListView_RedrawItems(hwndLV, 0, ListView_GetItemCount(hwndLV));
                UpdateWindow(hwndLV);
                break;
            }

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        case IDC_VIEW_CERT:
            _OPSConsent_ViewCertificate(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}                    

              
BOOL         
CIEFrameAuto::COpsProfile::_OPSConsent_ViewCertificate(HWND hDlg) 
{
    OPSDlgInfo *pDlgInfo = (OPSDlgInfo*) GetWindowLongPtr(hDlg, DWLP_USER);

    InternetShowSecurityInfoByURL(pDlgInfo->m_rgchURL, hDlg);
    return TRUE;
}

INT_PTR CIEFrameAuto::COpsProfile::_OPSConsent_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)  
    {
        case WM_INITDIALOG:
            ASSERT(NULL != lParam);            
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);  // save the list.

            return _OPSConsent_OnInitDlg(hDlg);

        case WM_COMMAND:
            return _OPSConsent_OnCommand(hDlg, LOWORD(wParam), HIWORD(wParam));

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND) ((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aHelpIDs);
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPTSTR) aHelpIDs);
            break;
            
        case WM_DESTROY:
            break;
    }
    
    return FALSE;
}                                        


// Update dialog functions.
BOOL CIEFrameAuto::COpsProfile::_OPSUpdate_OnInitDlg(HWND hDlg)
{
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!lpOpsDlgInfo || !lpOpsDlgInfo->m_hdpa)
        return FALSE;   

    HDPA hdpaList = lpOpsDlgInfo->m_hdpa;
    HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
    ASSERT(hwndLV);

    // Add elements to the list view. 
    ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_CHECKBOXES);

    // Initialize the common parts of the LVI
    TCHAR szName[MAX_PROFILE_NAME];
    LV_ITEM lvi = { 0 };
    lvi.mask        = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvi.iItem       = 0;
    lvi.pszText     = szName;
    lvi.cchTextMax  = MAX_PROFILE_NAME;
    lvi.stateMask   = LVIS_STATEIMAGEMASK;

    LV_FINDINFO lvfi = { 0 };
    lvfi.flags = LVFI_STRING;
    lvfi.psz   = szName;

    for (int i=0; i<DPA_GetPtrCount(hdpaList); i++)
    {
        OPSRequestEntry * pOpsEntry = (OPSRequestEntry*) DPA_FastGetPtr(hdpaList,i);

        MLLoadString(_GetResourceIdFromAttrName(pOpsEntry->m_bstrName), szName, MAX_PATH);

        pOpsEntry->m_fAnswer = TRUE;
        lvi.state       = 0x00002000;
        lvi.lParam      = (LPARAM)pOpsEntry;

        ListView_InsertItem(hwndLV, &lvi);

        // APPCOMPAT: There is a problem with the listview implementation because of which
        // the check box is not displayed even though lvi.state is set correctly.
        //  We have to find the item and set it again.
        ListView_SetItemState(hwndLV, ListView_FindItem(hwndLV, -1, &lvfi), 0x00002000, LVIS_STATEIMAGEMASK);
    }

    // show the items.
    ListView_RedrawItems(hwndLV, 0, ListView_GetItemCount(hwndLV));
    UpdateWindow(hwndLV);

    return TRUE;
}

BOOL CIEFrameAuto::COpsProfile::_OPSUpdate_OnCommand(HWND hDlg, UINT id, UINT nCmd)
{
    switch (id)
    {
        case IDOK:
            _OPSDlg_OnClose(hDlg);
            EndDialog(hDlg, TRUE);
            break;
            
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}                    
    
INT_PTR CIEFrameAuto::COpsProfile::_OPSUpdate_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)  
    {
        case WM_INITDIALOG:
            ASSERT(NULL != lParam);            
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);  // save the list.

            return _OPSUpdate_OnInitDlg(hDlg);

        case WM_COMMAND:
            return _OPSUpdate_OnCommand(hDlg, LOWORD(wParam), HIWORD(wParam));

        case WM_HELP:
            break;

        case WM_CONTEXTMENU:
            break;
            
        case WM_DESTROY:
            break;
    }
    
    return FALSE;
}                                        

       
BOOL
CIEFrameAuto::COpsProfile ::_ValidateElemName(LPCWSTR szIn, INT *pIndex /* = NULL */)
{
    int index = _GetAttrIndexFromName(szIn);
    if ( INVALID_ATTRIBUTE_INDEX != index )
    {
        if (pIndex) 
            *pIndex = index;

        return TRUE;                    
    }

    return FALSE;
}

INT CIEFrameAuto::COpsProfile::_GetAttrIndexFromName (LPCWSTR pwzName )
{
    INT index = INVALID_ATTRIBUTE_INDEX;

    if ( pwzName != NULL )
    {
        for ( int i = 0 ; i < ARRAYSIZE(rgProfAttr) ; i++ )
        {
            if (0 == StrCmpIW(rgProfAttr[i].pwzName, pwzName ))
            {
                index = i;
                break;
            }
        }
    }
    return index;
}

INT CIEFrameAuto::COpsProfile::_GetResourceIdFromAttrName( WCHAR * pwzName)
{
    return _GetResourceIdFromAttrIndex(_GetAttrIndexFromName(pwzName));
}

BOOL                
CIEFrameAuto::COpsProfile::_IsLocalMachine() {

    IInternetSecurityManager *pIScManager = NULL;
    BSTR    bstrURL;
    HRESULT hr;
    BOOL    fLocal = FALSE;
    DWORD   dwZone;

    hr = _pAuto->get_LocationURL(&bstrURL);
    if ( FAILED(hr) )
        goto Cleanup;

    hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_IInternetSecurityManager, (void **)&pIScManager);
    if ( FAILED(hr) )
        goto Cleanup;

    hr = pIScManager->MapUrlToZone(bstrURL, &dwZone, 0);
    if ( FAILED(hr) )
        goto Cleanup;

    fLocal = (dwZone == URLZONE_LOCAL_MACHINE); 

Cleanup:
    SAFERELEASE(pIScManager);
    SysFreeString(bstrURL);
    return fLocal;
}

    
HRESULT
CIEFrameAuto::COpsProfile::_GetUserPreference(BSTR bstrName, P3UserPref *pUsrPref) {

    TCHAR   rgszName[MAX_PROFILE_NAME];
    DWORD   dwType;
    DWORD   dwPrefSize;
    DWORD   dwError;

    _StringFromBSTR(bstrName, rgszName, ARRAYSIZE(rgszName));

    dwPrefSize = sizeof(struct P3UserPref);
    dwError = RegQueryValueEx(m_hP3Global, rgszName, 0, &dwType, 
                             (LPBYTE) pUsrPref, &dwPrefSize);

    if (dwError == ERROR_MORE_DATA) 
    {
        BYTE *pBuffer;
        pBuffer = new BYTE [dwPrefSize];
        if (pBuffer == NULL)
        {
            return E_OUTOFMEMORY;
        }
        dwError = RegQueryValueEx(m_hP3Global, rgszName, 0, &dwType, pBuffer, &dwPrefSize);
        memcpy(pUsrPref, pBuffer, sizeof(struct P3UserPref));
        delete [] pBuffer;
    }

    // If a preference for this attribute is not found, create a default one and 
    // write it back to persistent storage
    if (dwError != ERROR_SUCCESS)
    {
        P3UserPref  defPrefs;
        
        defPrefs.m_access = P3_QUERY;
        defPrefs.m_lastRequest = P3_ACCEPT;

        _PutUserPreference(bstrName, defPrefs);
        *pUsrPref = defPrefs;
    }

    return S_OK;
}


HRESULT 
CIEFrameAuto::COpsProfile::_PutUserPreference(BSTR bstrName, P3UserPref usrPref) {

    TCHAR   rgszName[MAX_PROFILE_NAME];
    DWORD   dwError;

    _StringFromBSTR(bstrName, rgszName, ARRAYSIZE(rgszName));

    dwError = RegSetValueEx(m_hP3Global, rgszName, 0, REG_BINARY,
                            (LPBYTE) &usrPref,
                            sizeof(struct P3UserPref));

    return HRESULT_FROM_WIN32(dwError);
}

BOOL
CIEFrameAuto::COpsProfile::_IsUsingSSL() 
{
    BOOL fSecure = FALSE;

    BSTR    bstrUrl;
    TCHAR   rgchUrl[MAX_URL_STRING+1];

    _pAuto->get_LocationURL(&bstrUrl);
    _StringFromBSTR(bstrUrl, rgchUrl, ARRAYSIZE(rgchUrl));
    SysFreeString(bstrUrl);
    fSecure = GetUrlScheme(rgchUrl)==URL_SCHEME_HTTPS;

    return fSecure;
}

HRESULT     
CIEFrameAuto::COpsProfile::_ApplyPreferences(URL_COMPONENTS *pucURL, HDPA hdpaReqList) 
{
    for (int k=0; k<DPA_GetPtrCount(hdpaReqList); k++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(hdpaReqList,k);
        pCurrent->m_fQuery  = TRUE;
        pCurrent->m_fAnswer = FALSE;
        pCurrent->m_dwDecision = P3_NONE;
    }

    _ApplySiteSettings(pucURL, hdpaReqList);
    _ApplyGlobalSettings(hdpaReqList);
    return S_OK;
}

HRESULT     
CIEFrameAuto::COpsProfile::_ApplyGlobalSettings(HDPA hdpaReqList) 
{
    for (int k=0; k<DPA_GetPtrCount(hdpaReqList); k++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(hdpaReqList,k);
        P3UserPref       userInfo;
    
        _GetUserPreference(pCurrent->m_bstrName, &userInfo);

        switch (userInfo.m_access)
        {
        case P3_GRANT:      if (pCurrent->m_fQuery)
                            {
                                pCurrent->grantRequest();
                                pCurrent->m_dwDecision = P3_GLOBAL;
                            }
                            break;
        case P3_DENY:       pCurrent->denyRequest();
                            pCurrent->m_dwDecision = P3_GLOBAL;
                            break;
        case P3_REQSSL:     // This resolves to P3_QUERY at the moment
        case P3_QUERY:      if (pCurrent->m_fQuery)
                                pCurrent->m_fAnswer = (userInfo.m_lastRequest == P3_ACCEPT);
                            break;
        default:            ;
        }
    }

    return S_OK;
}

HRESULT
CIEFrameAuto::COpsProfile::_ApplySiteSettings(URL_COMPONENTS *pucURL, HDPA hdpaReqList)
{
    if (pucURL->nScheme!=INTERNET_SCHEME_HTTP && pucURL->nScheme!=INTERNET_SCHEME_HTTPS)
        return S_OK;

    TCHAR *pszSubDomain = pucURL->lpszHostName;

    // For a given hostname such as "www.foo.bar.com", this loop will iterate over all possible
    // domains such as "www.foo.bar.com", ".foo.bar.com" and ".bar.com" but NOT ".com"
    while (pszSubDomain!=NULL && _LegalDomain(pucURL->lpszHostName, pszSubDomain))
    {
        HKEY    hkey    = NULL;
        
        if (ERROR_SUCCESS == RegOpenKeyEx(m_hP3Sites, pszSubDomain, 0, KEY_ALL_ACCESS, &hkey))
        {
            _ApplyDomainSettings(pucURL, hkey, hdpaReqList);
            RegCloseKey(hkey);
        }
        pszSubDomain = StrChr(pszSubDomain+1, TEXT('.')); // Find the next embedded dot
    }

    return S_OK;
}

HRESULT     
CIEFrameAuto::COpsProfile::_ApplyDomainSettings(URL_COMPONENTS *pucComp, HKEY hkey, HDPA hdpaReqList) 
{
    DWORD   dwError;
    DWORD   dwIndex = 0;
    TCHAR   rgchName[MAX_PATH];

    int     iReqCount = DPA_GetPtrCount(hdpaReqList);
    DWORD  *pdwLastApplied = new DWORD[iReqCount];

    if (pdwLastApplied == NULL)
    {
        return E_OUTOFMEMORY;
    }

    for (int i=0; i<iReqCount; i++)
        pdwLastApplied[i] = 0;

    do
    {
        DWORD dwcbVal = ARRAYSIZE(rgchName);
        
        dwError = RegEnumKeyEx(hkey, dwIndex, rgchName, &dwcbVal, NULL, NULL, NULL, NULL);
        if (dwError==ERROR_SUCCESS)
        {
            HKEY hPathKey;
            AccessSettings ac;

            dwError = RegOpenKeyEx(hkey, rgchName, 0, KEY_READ, &hPathKey);
            _ReadSettingsFromRegistry(hPathKey, &ac);
            _ApplySettings(&ac, pucComp, hdpaReqList, pdwLastApplied);
            RegCloseKey(hPathKey);
        }
        dwIndex++;
    } 
    while (dwError==ERROR_SUCCESS);

    delete [] pdwLastApplied;
    return S_OK;
}

HRESULT
CIEFrameAuto::COpsProfile::_UpdateSiteSettings(AccessSettings *pSettings, HDPA hdpaReqList)
{
    DWORD       dwError;
    DWORD       dwAction;
    HKEY        hDomainKey      = NULL;
    HKEY        hPathKey        = NULL;

    // Clear the allow and deny vectors
    ZeroMemory(pSettings->m_rgbStdAllow, sizeof(pSettings->m_rgbStdAllow));
    ZeroMemory(pSettings->m_rgbStdDeny, sizeof(pSettings->m_rgbStdDeny));

    // Fill out the vectors based on the user responses on the request list    
    for (int i=0; i<DPA_GetPtrCount(hdpaReqList); i++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(hdpaReqList,i);
        int iVcardIndex = _GetAttrIndexFromName(pCurrent->m_bstrName);

        // At the moment we do not handle custom attributes
        if (iVcardIndex!=INVALID_ATTRIBUTE_INDEX)
            _WriteBitVector(pCurrent->m_fAnswer ? pSettings->m_rgbStdAllow : pSettings->m_rgbStdDeny, iVcardIndex);
    }

    // Create a key for the given domain or open it if one already exists
    dwError = RegCreateKeyEx(m_hP3Sites, pSettings->m_rgchDomain, 
                            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                            &hDomainKey, &dwAction);

    if (dwError!=ERROR_SUCCESS)
        return E_FAIL;

    TCHAR       rgchName[16];
    DWORD       dwcbName = 0;
    DWORD       dwIndex = 0;
    
    do
    {
        AccessSettings ac;

        dwcbName = ARRAYSIZE(rgchName);

        if (ERROR_SUCCESS != RegEnumKeyEx(hDomainKey, dwIndex, rgchName, &dwcbName, NULL, NULL, NULL, NULL))
            break;

        if (ERROR_SUCCESS != RegOpenKeyEx(hDomainKey, rgchName, 0, KEY_READ, &hPathKey))
            break;

        _ReadSettingsFromRegistry(hPathKey, &ac);        

        // If there are existing settings for this domain and path, merge the permissions
        if (StrCmp(ac.m_rgchPath, pSettings->m_rgchPath) == 0)
        {
            // An attribute is allowed if it has been allowed explicitly by the user from
            // the current UI or it was previously allowed and it has not been denied
            // in the current UI. Similarly, an attribute is denied if it is denied in the
            // current UI or it was denied previously and it has not been granted this time.
            for (int i=0; i<ARRAYSIZE(pSettings->m_rgbStdAllow); i++)
            {
                pSettings->m_rgbStdAllow[i] |= ac.m_rgbStdAllow[i] & ~(pSettings->m_rgbStdDeny[i]);
                pSettings->m_rgbStdDeny[i]  |= ac.m_rgbStdDeny[i]  & ~(pSettings->m_rgbStdAllow[i]);
            }
            break;
        }
        RegCloseKey(hPathKey);
        dwIndex++;
    }
    while (dwError==ERROR_SUCCESS);

    wnsprintf(rgchName, ARRAYSIZE(rgchName), TEXT("%03d"), dwIndex);
    
    if (ERROR_SUCCESS == RegCreateKeyEx(hDomainKey, rgchName, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hPathKey, &dwAction))
        _WriteSettingsToRegistry(hPathKey, pSettings);

    RegCloseKey(hPathKey);
    RegCloseKey(hDomainKey);

    return S_OK;
}

BOOL
CIEFrameAuto::COpsProfile::_ReadBitVector(LPCBYTE ucBitVector, DWORD dwIndex)
{
    DWORD   dwByte = dwIndex/8;
    DWORD   dwMask = 0x80 >> (dwIndex & 0x07);

    return (ucBitVector[dwByte]&dwMask) != 0;
}

VOID
CIEFrameAuto::COpsProfile::_WriteBitVector(LPBYTE ucBitVector, DWORD dwIndex)
{
    DWORD   dwByte = dwIndex/8;
    DWORD   dwMask = 0x80 >> (dwIndex & 0x07);

    ucBitVector[dwByte] |= dwMask;
}


// The path matching is done on a character-level, which is the way cookies are
// implemented in IE4 and in Navigator
// Note that this is different from the RFC-2109
BOOL
CIEFrameAuto::COpsProfile::_PathMatch(TCHAR *pszDocumentPath, TCHAR *pszAccessPath)
{
    return StrStr(pszDocumentPath,pszAccessPath) == pszDocumentPath;
}


// Domain name matching is done on the character level except that a leading
// period is added to the access domain if necessary
// Refer to "cookie.cxx" in MSHTML for details
BOOL
CIEFrameAuto::COpsProfile::_DomainMatch(TCHAR *pszHostName, TCHAR *pszDomain) 
{
    // If domain is the same as hostname, matching is successful
    if (StrCmp(pszHostName, pszDomain) == 0)
        return TRUE;

    // Fail if the domain is not a legal subdomain of the hostname
    // This prevents matching against invaid domains such as ".com" or ".edu"
    if (! _LegalDomain(pszHostName, pszDomain))
        return FALSE;

    // Find the matching part of the domain on the access path
    TCHAR *pszMatchingPart = StrStr(pszHostName, pszDomain);

    // If the domain is not a substring of the hostname, it does not match
    if (pszMatchingPart==NULL)
        return FALSE;

    // Otherwise the domain must be a suffix and it should either contain a period
    // at the beginning or should match following a period
    if (StrCmp(pszMatchingPart, pszDomain) != 0)
        return FALSE;
    if (*pszMatchingPart!='.' && pszMatchingPart[-1]!='.')
        return FALSE;

    return TRUE;
}

BOOL
CIEFrameAuto::COpsProfile::_LegalDomain(TCHAR *pszHostName, TCHAR *pszDomain)
{
    // Fail if either of the strings are invalid
    if (pszHostName==NULL || pszDomain==NULL ||
        EMPTY_STRING(pszHostName) || EMPTY_STRING(pszDomain))
        return FALSE;

    // If domain is the same as hostname, it is always valid
    if (!StrCmpI(pszHostName, pszDomain))
        return TRUE;
    
    int iEmbeddedPeriods = 0;

    // Count the number of embedded periods, defined as the number of dots after
    // the first character of the domain
    for(int i=1; pszDomain[i]!=0; i++)
        if (pszDomain[i]=='.')
            iEmbeddedPeriods++;

    // Require that the domain name has at least one embedded period
    if (iEmbeddedPeriods==0)
        return FALSE;

    // Find the requested domain name in the host name 
    TCHAR   *pszMatchingPart = StrStr(pszHostName, pszDomain);

    // Require that this search succeed
    if (pszMatchingPart==NULL)
        return FALSE;

    // Require furthermore that the domain name be a suffix of the hostname 
    if (StrCmp(pszMatchingPart, pszDomain) != 0)
        return FALSE;

    // If all the above criteria has been satisfied, then the domain is valid
    return TRUE;
}

// Path matching is done at a character-level; this is to be compliant with Netscape
// Navigator and the original cookie specification.
// This has the surprising result that "/foo" matches "/foo/doc" as well as "/foobar/doc"
BOOL
CIEFrameAuto::COpsProfile::_LegalPath(TCHAR *pszActualPath, TCHAR *pszAccessPath)
{
    return StrStr(pszActualPath, pszAccessPath) == pszActualPath;
}


// For the ANSI<-->UNICODE transition 
HRESULT
CIEFrameAuto::COpsProfile::_StringFromBSTR(BSTR bstrSource, TCHAR *pszDest, DWORD dwDestSize) 
{
    StrCpyNW(pszDest, bstrSource, dwDestSize-1);

    return S_OK;
}

HRESULT     
CIEFrameAuto::COpsProfile::_StringFromVariant(VARIANT *vaSource, TCHAR *pszDest, DWORD dwDestSize)
{
    VARIANT     vaTemp;
    HRESULT     hr;

    VariantInit(&vaTemp);
    hr = VariantChangeType(&vaTemp, vaSource, 0, VT_BSTR);

    if (SUCCEEDED(hr))
        _StringFromBSTR(vaTemp.bstrVal, pszDest, dwDestSize);
    else
        ZeroMemory(pszDest, dwDestSize);
    
    VariantClear(&vaTemp);
    return hr;
}

INT
CIEFrameAuto::COpsProfile::_GetCookieSettings()
{

    HKEY    hInetKey = NULL;
    DWORD   dwCookiePref;
    DWORD   dwDataRead = sizeof(dwCookiePref);

    DWORD   dwError = RegOpenKeyEx(HKEY_CURRENT_USER, rgszInetKey, 0, KEY_READ, &hInetKey);
    if (dwError !=ERROR_SUCCESS)
        return COOKIES_DENY;

    dwError = RegQueryValueEx(hInetKey, rgszCookieTxt, NULL, NULL, (LPBYTE) &dwCookiePref, &dwDataRead);

    RegCloseKey(hInetKey);

    if (dwError==ERROR_SUCCESS)
        return dwCookiePref;
    else
        return COOKIES_ALLOW;
}

HRESULT
CIEFrameAuto::COpsProfile::_GetUsageCode(VARIANT vaUsage, LPTSTR rgchUsage, int cLen)
{
    LONG lUsage;

    VARIANT varDest;
    VariantInit(&varDest);

    HRESULT hr = VariantChangeType(&varDest, &vaUsage, 0, VT_I4);

    if (SUCCEEDED(hr))
    {
        lUsage = varDest.lVal;
        // If lUsage is not within range just display unknown usage.     
        if (lUsage < 0 || lUsage > (IDS_OPS_USAGEMAX - IDS_OPS_USAGE0))
            lUsage = -1;
    }
    else
        lUsage = -1;

    VariantClear(&varDest);

    MLLoadString(lUsage + IDS_OPS_USAGE0, rgchUsage, cLen);

    return S_OK;
}

BOOL
CIEFrameAuto::COpsProfile::_IsP3Enabled()
{
    DWORD dwEnabled;
    DWORD dwDataOut = sizeof(dwEnabled);
    DWORD dwError = RegQueryValueEx(m_hP3Global, rgszEnabled, 
                                    NULL, NULL, 
                                    (LPBYTE) &dwEnabled, &dwDataOut);

    if (dwError!=ERROR_SUCCESS)
    {
        dwEnabled = TRUE;
        RegSetValueEx(  m_hP3Global, rgszEnabled, 0, REG_DWORD, 
                        (LPBYTE) &dwEnabled, sizeof(dwEnabled));
        return TRUE;
    }
    else
        return dwEnabled;
}

// The script can specify domain, path and expiration date for the settings.
// If these are not provided, the domain defaults to the hostname, the path to the current 
// document and the expiration to a specified number of days in the future
HRESULT 
CIEFrameAuto::COpsProfile::_GetSiteSettings(URL_COMPONENTS *pucComp, 
                                            VARIANT vaDomain, VARIANT vaPath, VARIANT vaExpire,
                                            AccessSettings *pSettings)
{
    SYSTEMTIME  st;
    TCHAR       rgchExpire[32];
    HRESULT     hr;
    BOOL        bRet;    

    // Note: For IE4, the domain name has to be hostname.
    StrCpyN(pSettings->m_rgchDomain, pucComp->lpszHostName, ARRAYSIZE(pSettings->m_rgchDomain));

    hr = _StringFromVariant(&vaPath, pSettings->m_rgchPath, ARRAYSIZE(pSettings->m_rgchPath)); 
    if (FAILED(hr))
        StrCpyN(pSettings->m_rgchPath, pucComp->lpszUrlPath, ARRAYSIZE(pSettings->m_rgchPath));

    // If the path is different from the page, add a "/" if necessary at the end
    DWORD dwPathLen = lstrlen(pSettings->m_rgchPath);
    
    if (StrCmp(pSettings->m_rgchPath, pucComp->lpszUrlPath)     &&
        pSettings->m_rgchPath[dwPathLen-1] != TEXT('/'))
    {
        StrCatBuff(pSettings->m_rgchPath, TEXT("/"), ARRAYSIZE(pSettings->m_rgchPath));
    }


    FILETIME        ftNow;
    LARGE_INTEGER  *pqwNow = (LARGE_INTEGER*) & ftNow;
    LARGE_INTEGER  *pftime = (LARGE_INTEGER*) & pSettings->m_ftExpire;

    GetSystemTimeAsFileTime(&ftNow);

    hr = _StringFromVariant(&vaExpire, rgchExpire, ARRAYSIZE(rgchExpire));
    if (SUCCEEDED(hr))
    {
        bRet = InternetTimeToSystemTime(rgchExpire, &st, 0);
        SystemTimeToFileTime(&st, & pSettings->m_ftExpire);
    }
    if (FAILED(hr) || !bRet)
    {
        QUAD_PART(*pftime) = QUAD_PART(*pqwNow) + defExpiration;
    }

    // Enforce the limit on expiration time
    __int64 qwDelta = (QUAD_PART(*pftime)) - (QUAD_PART(*pqwNow));

    if (qwDelta<0 || qwDelta>maxExpiration)
        QUAD_PART(*pftime) = QUAD_PART(*pqwNow) + maxExpiration;

    // Make sure that the domain and path are valid
    // The criteria is a mix of the cookie semantics as defined by RFC-2109 and Navigator 
    // compliant behaviour as implemented elsewhere in IE4 
    if (! _LegalPath(pucComp->lpszUrlPath, pSettings->m_rgchPath) )
        StrCpyN(pSettings->m_rgchPath, pucComp->lpszUrlPath, ARRAYSIZE(pSettings->m_rgchPath));

    if (! _LegalDomain(pucComp->lpszHostName, pSettings->m_rgchDomain) )
        StrCpyN(pSettings->m_rgchDomain, pucComp->lpszHostName, ARRAYSIZE(pSettings->m_rgchDomain));

    // Add a period at the beginning of the domain name if it is not equal to 
    // the host name
    if (StrCmpI(pucComp->lpszHostName, pSettings->m_rgchDomain)   &&
        pSettings->m_rgchDomain[0] != '.')
    {
        StrCpyN(1+pSettings->m_rgchDomain, pSettings->m_rgchDomain, lstrlen(pSettings->m_rgchDomain));
        pSettings->m_rgchDomain[0] = '.';
    }

    pSettings->m_fExactDomain   = ! StrCmpI(pSettings->m_rgchDomain, pucComp->lpszHostName);
    
    if (StrCmp(pSettings->m_rgchPath, pucComp->lpszUrlPath))
    {
        pSettings->m_fExactPath = FALSE;
    }
    else
    {
        pSettings->m_fExactPath = pSettings->m_rgchPath[dwPathLen-1]!=TEXT('/');
    }

    return S_OK;
}

HRESULT
CIEFrameAuto::COpsProfile::_FormatSiteSettings(AccessSettings *pSettings, LPTSTR rgchOut, int cLimit)
{
    TCHAR   rgchFullName[MAX_URL_STRING];
    TCHAR   rgchTemp[MAX_URL_STRING];

    wnsprintf(rgchFullName,
             ARRAYSIZE(rgchFullName),
             TEXT("http://%s%s"),
             pSettings->m_rgchDomain,
             pSettings->m_rgchPath);

    FormatUrlForDisplay(rgchFullName, rgchTemp, cLimit, NULL, 0, FALSE, CP_ACP, NULL);

    TCHAR *pchSiteName = StrStr(rgchTemp, TEXT("//"));
 
    if (pchSiteName==NULL)
        pchSiteName = rgchTemp;
    else
        pchSiteName += 2;

    StrCpyN(rgchOut, pchSiteName, cLimit);
    return S_OK;
}


// Attempts to use the given settings to determine the user response to the requests 
// in the given list. If the domain and path for the settings is not applicable to
// for the given URL, returns FALSE.
BOOL
CIEFrameAuto::COpsProfile::_ApplySettings(AccessSettings *pac, URL_COMPONENTS *puc, HDPA hdpaReqList, DWORD *pdwLast)
{
    if (!_DomainMatch(puc->lpszHostName, pac->m_rgchDomain)  ||
        !_PathMatch(puc->lpszUrlPath, pac->m_rgchPath))
        return FALSE;

    DWORD   dwPathLen = lstrlen(pac->m_rgchPath);

    for (int i=0; i<DPA_GetPtrCount(hdpaReqList); i++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(hdpaReqList,i);
        int iVcIndex = _GetAttrIndexFromName(pCurrent->m_bstrName);

        if (iVcIndex==INVALID_ATTRIBUTE_INDEX)
            continue;

        if (pdwLast[i]>=dwPathLen)
            continue;
        else
            pdwLast[i] = dwPathLen;

        BOOL    fAllow  = _ReadBitVector(pac->m_rgbStdAllow, iVcIndex);
        BOOL    fDeny   = _ReadBitVector(pac->m_rgbStdDeny, iVcIndex);

        if (fDeny)
        {
            pCurrent->denyRequest();
            pCurrent->m_dwDecision = P3_SITELEVEL;
        }
        else if (fAllow)
        {
            pCurrent->grantRequest();
            pCurrent->m_dwDecision = P3_SITELEVEL;
        }
    }    

    return TRUE;
}

BOOL
CIEFrameAuto::COpsProfile::_ReadSettingsFromRegistry(HKEY hkey, AccessSettings *pac)
{
    DWORD  dwError;
    DWORD  dwcb;

    ZeroMemory(pac, sizeof(struct AccessSettings));

    dwcb = sizeof(pac->m_rgbStdAllow);
    dwError = RegQueryValueEx(hkey, rgszAllowTxt, NULL, NULL, (LPBYTE) pac->m_rgbStdAllow, &dwcb);

    dwcb = sizeof(pac->m_rgbStdDeny);
    dwError = RegQueryValueEx(hkey, rgszDenyTxt, NULL, NULL, (LPBYTE) pac->m_rgbStdDeny, &dwcb);

    dwcb = sizeof(pac->m_rgchPath);
    dwError = RegQueryValueEx(hkey, rgszPathTxt, NULL, NULL, (LPBYTE) pac->m_rgchPath, &dwcb);

    dwcb = sizeof(pac->m_rgchDomain);
    dwError = RegQueryValueEx(hkey, rgszDomainTxt, NULL, NULL, (LPBYTE) pac->m_rgchDomain, &dwcb);

    return (dwError==ERROR_SUCCESS);
}

BOOL
CIEFrameAuto::COpsProfile::_WriteSettingsToRegistry(HKEY hkey, AccessSettings *pac)
{
    RegSetValueEx(hkey, rgszAllowTxt, 0, REG_BINARY, pac->m_rgbStdAllow, sizeof(pac->m_rgbStdAllow));
    RegSetValueEx(hkey, rgszDenyTxt, 0, REG_BINARY, pac->m_rgbStdDeny, sizeof(pac->m_rgbStdDeny));

    RegSetValueEx(hkey, rgszPathTxt, 0, REG_SZ, (LPBYTE) pac->m_rgchPath, sizeof(pac->m_rgchPath));
    RegSetValueEx(hkey, rgszDomainTxt, 0, REG_SZ, (LPBYTE) pac->m_rgchDomain, sizeof(pac->m_rgchDomain));

    return TRUE;
}


// This function revokes all site permission given previously by deleting
// the registry entries for all the domains under the "P3Sites" key
// It is not a good idea to invoke recursive delete on the P3Sites key because
// the running instance of the navigator will end up with an invalid handle
HRESULT
CIEFrameAuto::COpsProfile::_ClearAllSettings(HWND hwnd)
{
    DWORD   dwAction;
    DWORD   dwError;
    HKEY    hP3Sites;

    dwError = RegCreateKeyEx(HKEY_CURRENT_USER,  rgszP3Sites, 0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL, &hP3Sites, &dwAction);

    DWORD dwIndex = 0;
    DWORD dwcbVal;
    TCHAR rgchName[MAX_PATH];
    HDPA  hdpaKeys = DPA_Create(0);

    do
    {
        dwcbVal = ARRAYSIZE(rgchName);
        dwError = RegEnumKeyEx(hP3Sites, dwIndex, rgchName, &dwcbVal, NULL, NULL, NULL, NULL);

        if (dwError==ERROR_SUCCESS)
        {
            LPTSTR  pszSiteName = new TCHAR[MAX_PATH];
            if (pszSiteName)
            {
                StrCpyN(pszSiteName, rgchName, MAX_PATH);
                DPA_AppendPtr(hdpaKeys, pszSiteName);
            }
        }
        dwIndex++;
    }
    while (dwError==ERROR_SUCCESS);

    for (int i=0; i<DPA_GetPtrCount(hdpaKeys); i++)
    {
        LPTSTR  pszSiteName = (LPTSTR) DPA_FastGetPtr(hdpaKeys, i);
        SHDeleteKey(hP3Sites, pszSiteName);
        delete pszSiteName;
    }

    DPA_Destroy(hdpaKeys);
    hdpaKeys = NULL;

    return S_OK;
}

BOOL
CIEFrameAuto::COpsProfile::_DifferentURL()
{
    BSTR    bstrCurrentURL  = NULL;
    HRESULT hr = _pAuto->get_LocationURL(&bstrCurrentURL);
    BOOL    fDifferent = (m_bstrLastURL!=NULL) && StrCmpW(bstrCurrentURL, m_bstrLastURL);

    SysFreeString(bstrCurrentURL);
    return fDifferent;
}

STDAPI ResetProfileSharing(HWND hwin)
{
    return CIEFrameAuto::COpsProfile::_ClearAllSettings(hwin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

// For use with VC6
#pragma warning(4:4242)  //'initializing' : conversion from 'unsigned int' to 'unsigned short', possible loss of data

// Sundown
#pragma warning(disable: 4800)  // conversion to bool

// Extra error checking (catches false errors, but useful to run every so often)
#if 0
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4709)   // command operator w/o index expression
#endif


#define ASSERT_PRIV_H_INCLUDED


// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API
#define _BROWSEUI_      // Make functions exported from browseui as stdapi (as they are delay loaded)

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache
#ifndef STRICT
#define STRICT
#endif

//
// Channels are enabled for IE4 upgrades.
//
#define ENABLE_CHANNELS

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */
#include <nt.h>

// WARNING!  NTDLL is manually delay-loaded! bcause it is crippled on Win95.
// We used to use automatic delay-loading, but people who didn't realize that
// Win95 doesn't have full support for NTDLL would accidentally call NTDLL
// functions and cause us to crash on Win95.
#undef NTSYSAPI
#define NTSYSAPI
#include <ntrtl.h>
#include <nturtl.h>
#undef NTSYSAPI
#define NTSYSAPI DECLSPEC_IMPORT

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
#define POST_IE5_BETA // turn on post-split iedev stuff
#include <w95wraps.h>
#include <windows.h>
#include <windowsx.h>

// VariantInit is a trivial function -- avoid using OleAut32, use intrinsic
// version of memset for a good size win
// (it's here so that atl (in stdafx.h) gets it too)
#define VariantInit(p) memset(p, 0, sizeof(*(p)))

// Smartly delay load OLEAUT32
HRESULT VariantClearLazy(VARIANTARG *pvarg);
#define VariantClear VariantClearLazy
WINOLEAUTAPI VariantCopyLazy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc);
#define VariantCopy VariantCopyLazy

// Must do this before including <exdisp.h> or the build will break.
// See comments at declaration of FindWindowD much further below.
#ifdef DEBUG
#undef  FindWindow
#undef  FindWindowEx
#define FindWindow              FindWindowD
#define FindWindowEx            FindWindowExD
#endif

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <hlink.h>
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <exdisp.h>
#include <objidl.h>

#include <shlwapi.h>
#include <shlwapip.h>

#undef SubclassWindow
#if defined(__cplusplus) && !defined(DONT_USE_ATL)
// (stdafx.h must come before windowsx.h)
#include "stdafx.h"             // ATL header file for this component

// AtlMisc.h needs some defines from AtlApp.h
#ifndef __ATLAPP_H__
#include "AtlApp.h"
#endif

// include CString, CSize, CRect, CPoint, CFindFile from WTL10
// see %_NTROOT%\public\sdk\inc\wtl10
#include "AtlMisc.h"

// Include LBSTR::CString
#include <locbstr.h>

#endif

#include <shellapi.h>

//===========================================================================
// ITEMIDLIST
//===========================================================================

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

#define SEN_FIRST       (0U-550U)       // ;Internal


#include <ole2ver.h>
#include <olectl.h>
#include <shellp.h>
#include <shdocvw.h>
#include <ieguidp.h>
#include <isguids.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <dispex.h>     // IDispatchEx
#include <perhist.h>
#include <iethread.h>

#include <help.h>
#include <krnlcmn.h>    // GetProcessDword

#include <multimon.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>
#include <regapix.h>    // MAXIMUM_SUB_KEY_LENGTH, MAXIMUM_VALUE_NAME_LENGTH, MAXIMUM_DATA_LENGTH

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
#include <winineti.h>    // Cache APIs & structures
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#include <propset.h>        // FEATURE (scotth): remove this once OLE adds an official header

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#define DLL_IS_ROOTABLE
#include <ccstock.h>
#include <ccstock2.h>
#include <port32.h>

#include <browseui.h>

#ifdef OLD_HLIFACE
#define HLNF_OPENINNEWWINDOW HLBF_OPENINNEWWINDOW
#endif

#define ISVISIBLE(hwnd)  ((GetWindowStyle(hwnd) & WS_VISIBLE) == WS_VISIBLE)

// shorthand
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#    ifdef __cplusplus
#        define ATOMICRELEASE(p) IUnknown_SafeReleaseAndNullPtr(p)
#    else
#        define ATOMICRELEASE(p) IUnknown_AtomicRelease((LPVOID*)&p)
#    endif
#endif
#endif //ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif
#define SAFERELEASE(p) ATOMICRELEASE(p)


// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <htmlfilter.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

#include "util.h"
#include "iepriv.h"
#include "brutil.h"
#include "qistub.h"
#ifdef DEBUG
#include "dbutil.h"
#endif

#define DLL_IS_UNICODE         (sizeof(TCHAR) == sizeof(WCHAR))

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
// IEUNIX - we do have them in MainWin
//
#ifndef MAINWIN
#ifdef  UNICODE

   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;

#endif /* UNICODE */
#endif /* !MAINWIN */

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


extern const ITEMIDLIST c_idlDesktop;
typedef const BYTE *LPCBYTE;

STDAPI MonikerFromURLPidl(LPCITEMIDLIST pidlURLItem, IMoniker** ppmk);
STDAPI MonikerFromURL(LPCWSTR wszPath, IMoniker** ppmk);
STDAPI MonikerFromString(LPCTSTR szPath, IMoniker** ppmk);

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

extern IShellFolder* g_psfInternet;
HRESULT InitPSFInternet(void);

//
// Debug helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

BOOL    IsStringContained(LPCTSTR pcszBigger, LPCTSTR pcszSuffix);

#endif // DEBUG

//
// we may not be part of the namespace on IE3/Win95
//
#define ILIsEqual(p1, p2)       IEILIsEqual(p1, p2, FALSE)


extern LPCITEMIDLIST c_pidlURLRoot;

//
// Trace/dump/break flags specific to shell32\.
//   (Standard flags defined in shellp.h)
//

// Break flags
#define BF_ONDUMPMENU       0x10000000      // Stop after dumping menus
#define BF_ONLOADED         0x00000010      // Stop when loaded

// Trace flags
#define TF_INTSHCUT         0x00000010      // Internet shortcuts
#define TF_REGCHECK         0x00000100      // Registry check stuff
#define TF_SHDLIFE          0x00000200
#define TF_SHDREF           0x00000400
#define TF_SHDPERF          0x00000800
#define TF_SHDAUTO          0x00001000
#define TF_MENUBAND         0x00002000      // Menu band messages
#define TF_SITEMAP          0x00004000      // Sitemap messages
#define TF_SHDTHREAD        0x00008000      // Thread management
#define TF_SHDCONTROL       0x00010000      // ActiveX Control
#define TF_SHDAPPHACK       0x00020000      // Hack for app-bug
#define TF_SHDBINDING       0x00040000      // Moniker binding
#define TF_SHDPROGRESS      0x00080000      // Download progress
#define TF_SHDNAVIGATE      0x00100000      // Navigation
#define TF_SHDUIACTIVATE    0x00200000      // UI-Activation/Deactivation
#define TF_OCCONTROL        0x00400000      // OC Hosting Window Control
#define TF_PIDLWRAP         0x00800000      // Pidl / Protocol wrapping
#define TF_AUTOCOMPLETE     0x01000000      // AutoCompletion
#define TF_COCREATE         0x02000000      // WinList/CoCreate(Browser only)
#define TF_URLNAMESPACE     0x04000000      // URL Name Space
#define TF_BAND             0x08000000      // Bands (ISF Band, etc)
#define TF_TRAVELLOG        0x10000000      // TravelLog and Navigation stack
#define TF_DDE              0x20000000      // PMDDE traces
#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

//FEATURE: REMOVE
#define TF_OBJECTCACHE      TF_TRAVELLOG

// (Re-use TF_CUSTOM1 and TF_CUSTOM2 by defining a TF_ value in your
// local file to one of these values while you have the file checked
// out.)

// Dump flags
#define DF_SITEMAP          0x00000001      // Sitemap
#define DF_MEMLEAK          0x00000002      // Dump leaked memory at the end
#define DF_DEBUGQI          0x00000004      // Alloc stub object for each QI
#define DF_DEBUGQINOREF     0x00000008      // No AddRef/Release QI stub
#define DF_DEBUGMENU        0x00000010      // Dump menu handles
#define DF_URL              0x00000020      // Display URLs
#define DF_AUTOCOMPLETE     0x00000040      // AutoCompletion
#define DF_DELAYLOADDLL     0x00000080      // Delay-loaded DLL
#define DF_SHELLLIST        0x00000100      // CShellList contents
#define DF_INTSHCUT         0x00000200      // Internet shortcut structs
#define DF_URLPROP          0x00000400      // URL properties
#define DF_MSGHOOK          0x00000800      // Menu MessageFilter
#define DF_GETMSGHOOK       0x00001000      // GetMessageFilter
#define DF_TRANSACCELIO     0x00002000      // GetMessageFilter

// Prototype flags
#define PF_USERMENUS        0x00000001      // Use traditional USER menu bar
#define PF_NEWFAVMENU       0x00000002      // New favorites menu
#define PF_FORCESHDOC401    0x00000004      // force shdoc401 even on NT5
//efine PF_                 0x00000008      // Used by dochost.cpp
//efine PF_                 0x00000010      // Unused
//efine PF_                 0x00000020      // Used by urlhist.cpp
//efine PF_                 0x00000040      // Unused
//efine PF_                 0x00000100      // Unused
//efine PF_                 0x00000200      // Used by shembed.cpp
//efine PF_                 0x00000400      // Unused?
//efine PF_                 0x00000800      // Unused?

//
// global object array - used for class factory, auto registration, type libraries, oc information
//

#include "cfdefs.h"

#define OIF_ALLOWAGGREGATION  0x0001

//
// global variables
//
//
// Function prototypes
//
STDAPI CMyHlinkSrc_CreateInstance(REFCLSID rclsid, DWORD grfContext, REFIID riid, LPVOID* ppvOut);
STDAPI CMyHlinkSrc_OleCreate(CLSID rclsid, REFIID riid, DWORD renderOpt,
                             FORMATETC* pFormatEtc, IOleClientSite* pclient,
                             IStorage* pstg, LPVOID* ppvOut);

STDAPI CMyHlinkSrc_OleLoad(IStorage* pstg, REFIID riid, IOleClientSite* pclient, LPVOID* ppvOut);

HRESULT SHRegisterTypeLib(void);
VOID SHCheckRegistry(void);

// htregmng.cpp
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);

#define OleAlloc(cb)    CoTaskMemAlloc(cb)
#define OleFree(pv)     CoTaskMemFree(pv)

STDAPI_(IBindCtx *) BCW_Create(IBindCtx* pibc);

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH
#define MAX_NAME_STRING     INTERNET_MAX_PATH_LENGTH
#define MAX_BROWSER_WINDOW_TITLE   128

// Stack allocated BSTR (to avoid calling SysAllocString)
typedef struct _SA_BSTR {
    ULONG   cb;
    WCHAR   wsz[MAX_URL_STRING];
} SA_BSTR;

// A "fake" variants for use on the stack - usable for [in] parameters only!!!
typedef struct _SA_BSTRGUID {
    UINT  cb;
    WCHAR wsz[39];
} SA_BSTRGUID;
#define InitFakeBSTR(pSA_BSTR, guid) SHStringFromGUIDW((guid), (pSA_BSTR)->wsz, ARRAYSIZE((pSA_BSTR)->wsz)), (pSA_BSTR)->cb = (38*sizeof(WCHAR))

STDAPI _SetStdLocation(LPTSTR szPath, UINT id);

STDAPI CDocObjectHost_AddPages(LPARAM that, HWND hwnd, HINSTANCE hinst, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
STDAPI_(void) CDocObjectHost_GetCurrentPage(LPARAM that, LPTSTR szBuf, UINT cchMax);

extern BOOL DeleteUrlCacheEntryA(LPCSTR pszUrlName);

void LaunchPrivacySettings(HWND);

//
// a couple bogus pidls
//
#define PIDL_LOCALHISTORY ((LPCITEMIDLIST)-1)
#define PIDL_NOTHING      ((LPCITEMIDLIST)-2)


//
// Globals (per-process)
//
extern UINT g_tidParking;           // parking thread
extern HPALETTE g_hpalHalftone;
extern BOOL g_fBrowserOnlyProcess;  // initialized in IEWinMain()



//
//  In DEBUG, send all our class registrations through a wrapper that
//  checks that the class is on our unregister-at-unload list.
//
#ifdef DEBUG
#undef  SHRegisterClass
#undef    RegisterClass
#define SHRegisterClass       SHRegisterClassD
#define   RegisterClass         RegisterClassD

STDAPI_(BOOL) SHRegisterClassD(CONST WNDCLASS* pwc);
STDAPI_(ATOM)   RegisterClassD(CONST WNDCLASS* pwc);
#ifdef UNICODE
#define RealSHRegisterClass   SHRegisterClassW
#define   RealRegisterClass     RegisterClassWrapW
#else
#define RealSHRegisterClass   SHRegisterClassA
#define   RealRegisterClass     RegisterClassA
#endif // UNICODE
#endif // DEBUG

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow sends interthreadmessages,
//  which is not obvious.
//
//  IShellWindows has a method called FindWindow, so we have to define
//  the debug wrapper macros before including <exdisp.h>.  We should've
//  called it FindWindowSW.  In fact, there should be some law against
//  giving a method the same name as a Windows API.
//
#ifdef DEBUG
STDAPI_(HWND) FindWindowD  (LPCTSTR lpClassName, LPCTSTR lpWindowName);
STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName);
#ifdef UNICODE
#define RealFindWindowEx        FindWindowExWrapW
#else
#define RealFindWindowEx        FindWindowExA
#endif // UNICODE
#endif // DEBUG

#define CALLWNDPROC WNDPROC

extern const GUID CGID_ShellBrowser;
extern const GUID CGID_PrivCITCommands;

// Map KERNEL32 unicode string functions to SHLWAPI
//#define lstrcmpW    StrCmpW
//#define lstrcmpiW   StrCmpIW
//#define lstrcpyW    StrCpyW
//#define lstrcpynW   StrCpyNW
//#define lstrcatW    StrCatW

//
// Prevent buffer overruns - don't use unsafe functions.
//

//lstrcpy
#undef  lstrcpyW
#define lstrcpyW       Do_not_use_lstrcpyW_use_StrCpyNW
#define lstrcpyA       Do_not_use_lstrcpyA_use_StrCpyNA

#ifdef lstrcpy
    #undef lstrcpy
#endif
#define lstrcpy        Do_not_use_lstrcpy_use_StrCpyN

//StrCpy
//#ifdef StrCpyW
//    #undef StrCpyW
//#endif
#define StrCpyW        Do_not_use_StrCpyW_use_StrCpyNW

#ifdef StrCpyA
    #undef StrCpyA
#endif
#define StrCpyA        Do_not_use_StrCpyA_use_StrCpyNA

#ifdef StrCpy
    #undef StrCpy
#endif
#define StrCpy         Do_not_use_StrCpy_use_StrCpyN


//ualstrcpyW
#ifdef ualstrcpyW
    #undef ualstrcpyW
#endif
#define ualstrcpyW     Do_not_use_ualstrcpyW_ualstrcpynW

//lstrcatW
#define lstrcatW       Do_not_use_lstrcatW_use_StrCatBuffW
#define lstrcatA       Do_not_use_lstrcatA_use_StrCatBuffA

#ifdef lstrcat
    #undef lstrcat
#endif
#define lstrcat        Do_not_use_lstrcat_use_StrCatBuff

//wsprintf
#define wsprintfW      Do_not_use_wsprintfW_use_wnsprintfW
#define wsprintfA      Do_not_use_wsprintfA_use_wnsprintfA

#ifdef wsprintf
    #undef wsprintf
#endif
#define wsprintf       Do_not_use_wsprintf_use_wnsprintf

//wvsprintf
#ifdef wvsprintfW
    #undef wvsprintfW
#endif
#define wvsprintfW     Do_not_use_wvsprintfW_use_wvnsprintfW

#define wvsprintfA     Do_not_use_wvsprintfA_use_wvnsprintfA

#ifdef wvsprintf
    #undef wvsprintf
#endif
#define wvsprintf      Do_not_use_wvsprintf_use_wvnsprintf


//
// Don't use the kernel string functions.  Use shlwapi equivalents.
//
#ifndef _WIN64
// lstrcmp
#undef  lstrcmpW
#define lstrcmpW       Do_not_use_lstrcmpW_use_StrCmpW
//#define lstrcmpA       Do_not_use_lstrcmpA_use_StrCmpA
#ifdef lstrcmp
    #undef lstrcmp
#endif
#define lstrcmp        Do_not_use_lstrcmp_use_StrCmp

// lstrcmpi
#undef lstrcmpiW
#define lstrcmpiW      Do_not_use_lstrcmpiW_use_StrCmpIW
//#define lstrcmpiA      Do_not_use_lstrcmpiA_use_StrCmpIA
#ifdef lstrcmpi
    #undef lstrcmpi
#endif
#define lstrcmpi       Do_not_use_lstrcmpi_use_StrCmpI

// lstrncmpi
#define lstrncmpiW     Do_not_use_lstrncmpiW_use_StrCmpNIW
//#define lstrncmpiA      Do_not_use_lstrncmpiA_use_StrCmpNIA
#ifdef lstrncmpi
    #undef lstrncmpi
#endif
#define lstrncmpi      Do_not_use_lstrncmpi_use_StrCmpNI


//lstrcpyn
#undef lstrcpynW
#define lstrcpynW      Do_not_use_lstrcpynW_use_StrCpyNW
//#define lstrcpynA      Do_not_use_lstrcpynA_use_StrCpyNA
#ifdef lstrcpyn
    #undef lstrcpyn
#endif
#define lstrcpyn       Do_not_use_lstrcpyn_use_StrCpyN
#endif

extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst

extern BOOL g_fRunningOnNT;
extern BOOL g_bNT5Upgrade;
extern BOOL g_bRunOnNT5;
extern BOOL g_bRunOnMemphis;
extern BOOL g_fRunOnFE;
extern UINT g_uiACP;
//
// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
//
extern BOOL g_bMirroredOS;

#ifdef WINDOWS_ME
//
// This is needed for BiDi localized win95 RTL stuff
//
extern BOOL g_bBiDiW95Loc;

#else // !WINDOWS_ME
#define g_bBiDiW95Loc FALSE
#endif // WINDOWS_ME

extern const TCHAR c_szHelpFile[];
extern const TCHAR c_szHtmlHelpFile[];
extern const TCHAR c_szURLPrefixesKey[];
extern const TCHAR c_szDefaultURLPrefixKey[];
extern const TCHAR c_szShellEmbedding[];
extern const TCHAR c_szViewClass[];

#define c_szNULL        TEXT("")

// status bar pane numbers actually used to create the controls - in left-to-right order
#define STATUS_PANES            6
#define STATUS_PANE_NAVIGATION  0
#define STATUS_PANE_PROGRESS    1
#define STATUS_PANE_OFFLINE     2
#define STATUS_PANE_PRINTER     2         // printer and offline share a spot
#define STATUS_PANE_PRIVACY     3
#define STATUS_PANE_SSL         4
#define STATUS_PANE_ZONE        5

#define ZONES_PANE_WIDTH        70

extern HICON g_hiconSSL;
extern HICON g_hiconFortezza;
extern HICON g_hiconOffline;
extern HICON g_hiconPrinter;
extern HICON g_hiconPrivacyImpact;

#define MAX_TOOLTIP_STRING 80

#define SID_SOmWindow IID_IHTMLWindow2
#define SID_SDropBlocker CLSID_SearchBand

#define MIN_BROWSER_DISPID              1
#define MAX_BROWSER_DISPID              1000

// We may want to put "Thunks between us and some of the shell private entries as
// some of them will take Ansi strings on Windows 95 and will take unicode strings
// on NT.
#include "runonnt.h"


// Function in IEDISP.CPP
HRESULT CreateBlankURL(BSTR *url, LPCTSTR pszErrorUrl, BSTR oldUrl);
SAFEARRAY * MakeSafeArrayFromData(LPCBYTE pData, DWORD cbData);

#include "idispids.h"

#ifdef __cplusplus
//
// C++ modules only
//
#include <shstr.h>
#include "shembed.h"


extern "C" const ITEMIDLIST s_idlNULL;

// helper routines for view state stuff

IStream *GetDesktopRegStream(DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreams);
//IStream *GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreamMRU, LPCTSTR pszStreams);

// StreamHeader Signatures
#define STREAMHEADER_SIG_CADDRESSBAND        0xF432E001
#define STREAMHEADER_SIG_CADDRESSEDITBOX     0x24F92A92

#define CoCreateInstance IECreateInstance
HRESULT IECreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

#endif

extern HRESULT LoadHistoryShellFolder(IUnknown *punkSFHistory, IHistSFPrivate **pphsfHistory); // from urlhist.cpp
extern void CUrlHistory_CleanUp();

#define c_szHelpFile     TEXT("iexplore.hlp")



/////// mappings...
////// these functions moved from being private utilities to being exported (mostly from shlwapi)
///// and thus need a new name to avoid name collisions
#define IsRegisteredClient SHIsRegisteredClient
#define IE_ErrorMsgBox SHIEErrorMsgBox
#define SetDefaultDialogFont SHSetDefaultDialogFont
#define RemoveDefaultDialogFont SHRemoveDefaultDialogFont
#define IsGlobalOffline SHIsGlobalOffline
#define SetWindowBits SHSetWindowBits
#define IsSameObject SHIsSameObject
#define SetParentHwnd SHSetParentHwnd
#define IsEmptyStream SHIsEmptyStream
#define PropagateMessage SHPropagateMessage
#define MenuIndexFromID  SHMenuIndexFromID
#define Menu_RemoveAllSubMenus SHRemoveAllSubMenus
#define _EnableMenuItem SHEnableMenuItem
#define _CheckMenuItem SHCheckMenuItem
#define SimulateDrop SHSimulateDrop
#define GetMenuFromID  SHGetMenuFromID
#define GetCurColorRes SHGetCurColorRes
#define VerbExists  SHVerbExists
#define IsExpandableFolder SHIsExpandableFolder
#define WaitForSendMessageThread SHWaitForSendMessageThread
#define FillRectClr  SHFillRectClr
#define SearchMapInt SHSearchMapInt
#define IsChildOrSelf SHIsChildOrSelf
#define StripMneumonic SHStripMneumonic
#define MapNbspToSp SHMapNbspToSp
#define GetViewStream SHGetViewStream
#define HinstShdocvw() HINST_THISDLL

STDAPI CoCreateInternetExplorer( REFIID iid, DWORD dwClsContext, void **ppvunk );

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

// Although, UNIX is not exactly right here, because i386
// doesn't require any alignment, but that holds true for
// all the UNIXs we plan IE for.
#ifdef UNIX
#define ALIGN4(cb)         (((unsigned)(cb) % 4)? (unsigned)(cb)+(4-((unsigned)(cb)%4)) : (unsigned)(cb))
#define ALIGN4_IF_UNIX(cb) ALIGN4(cb)
#else
#define ALIGN4_IF_UNIX(cb)
#define QUAD_PART(a) ((a)##.QuadPart)
#endif

// Sundown macros
#define PtrDiff(x,y)        ((LPBYTE)(x)-(LPBYTE)(y))

// Dummy union macros for code compilation on platforms not
// supporting nameless stuct/union

#ifdef NONAMELESSUNION
#define DUMMYUNION_MEMBER(member)   DUMMYUNIONNAME.##member
#define DUMMYUNION2_MEMBER(member)  DUMMYUNIONNAME2.##member
#define DUMMYUNION3_MEMBER(member)  DUMMYUNIONNAME3.##member
#define DUMMYUNION4_MEMBER(member)  DUMMYUNIONNAME4.##member
#define DUMMYUNION5_MEMBER(member)  DUMMYUNIONNAME5.##member
#else
#define DUMMYUNION_MEMBER(member)    member
#define DUMMYUNION2_MEMBER(member)   member
#define DUMMYUNION3_MEMBER(member)   member
#define DUMMYUNION4_MEMBER(member)   member
#define DUMMYUNION5_MEMBER(member)   member
#endif

#define REG_SUBKEY_FAVORITESA            "\\MenuOrder\\Favorites"
#define REG_SUBKEY_FAVORITES             TEXT(REG_SUBKEY_FAVORITESA)

#undef ExpandEnvironmentStrings
#define ExpandEnvironmentStrings #error "Use SHExpandEnvironmentStrings instead"

#include "shfusion.h"


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\privacyui.cpp ===
//
//   privacyui.cpp  - Implements the UI for IE's privacy features
//
//   The privacy dialog is managed from this sourcefile.
//   The privacy view dialog is also managed from this sourcefile.

#include "priv.h"
#include "resource.h"
#include "privacyui.hpp"
#include <mluisupp.h>
#include "richedit.h"

#include "SmallUtil.hpp"


#define REGSTR_PRIVACYPS_PATHEDIT   TEXT("Software\\Policies\\Microsoft\\Internet Explorer")
#define REGSTR_PRIVACYPS_VALUEDIT   TEXT("PrivacyAddRemoveSites")  //  this key is duplicated in cpls\inetcpl\privacyui.cpp

#define REGSTR_PRIVACYPS_PATHPANE   TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGSTR_PRIVACYPS_VALUPANE   TEXT("Privacy Settings")  //  this key is duplicated in cpls\inetcpl\privacyui.cpp

#define REGSTR_PRIVACYPS_PATHTAB    TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGSTR_PRIVACYPS_VALUTAB    TEXT("PrivacyTab")  //  this key is duplicated somewhere else


BOOL allowPerSiteModify()
{
    DWORD dwSize, dwRet, dwType, dwValue;
    dwSize = sizeof(dwValue);

    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHEDIT, 
                       REGSTR_PRIVACYPS_VALUEDIT, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && dwValue && REG_DWORD == dwType)
    {
        return FALSE;
    }

    dwSize = sizeof(dwValue);
    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHPANE, 
                       REGSTR_PRIVACYPS_VALUPANE, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && dwValue && REG_DWORD == dwType)
    {
        return FALSE;
    }

    dwSize = sizeof(dwValue);
    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHTAB, 
                       REGSTR_PRIVACYPS_VALUTAB, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && dwValue && REG_DWORD == dwType)
    {
        return FALSE;
    }
    return TRUE;
}


struct SPerSiteData;
typedef SPerSiteData* PSPerSiteData;

class CPolicyHunt; 

struct SPrivacyDialogData;
typedef SPrivacyDialogData* PSPrivacyDialogData;


//+---------------------------------------------------------------------------
//
//  Function:   HyperlinkSubclass
//
//  Synopsis:   subclass for the makeshift hyperlink control
//
//  Arguments:  [hwnd]   -- window handle
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message handled, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK HyperlinkSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    WNDPROC     wndproc;
    static BOOL fMouseCaptured;

    wndproc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {

    case WM_SETCURSOR:

        if (!fMouseCaptured)
        {
            SetCapture(hwnd);
            fMouseCaptured = TRUE;
        }

        SetCursor(LoadHandCursor(0));
        return( TRUE );

    case WM_GETDLGCODE:
    {
        MSG* pmsg;
        LRESULT lRet = DLGC_STATIC;
        if (((pmsg = (MSG*)lParam)) && ((WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message)))
        {
            switch(pmsg->wParam)
            {
            case VK_RETURN:
            case VK_SPACE:
                lRet |= DLGC_WANTALLKEYS;
                break;

            default:
                break;
            }
        }
        return lRet;
    }

    case WM_KEYDOWN:
        if ((wParam!=VK_SPACE)&&(wParam!=VK_RETURN))
        {
            break;
        }
    
    case WM_LBUTTONUP:
        SetFocus(hwnd);
        PostMessage( GetParent(hwnd), WM_APP, (WPARAM)GetDlgCtrlID( hwnd), (LPARAM)hwnd);
        return( TRUE );

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

    case EM_SETSEL:

        return( TRUE );

    case WM_SETFOCUS:

        if ( hwnd == GetFocus() )
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadHandCursor(0));

            return( TRUE );
        }

        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        
        return( TRUE );

    case WM_PAINT:

        CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

    case WM_MOUSEMOVE:

        RECT                rect;
        int                 xPos, yPos;

        // check to see if the mouse is in this windows rect, if not, then reset
        // the cursor to an arrow and release the mouse
        GetClientRect(hwnd, &rect);
        xPos = LOWORD(lParam);
        yPos = HIWORD(lParam);
        if ((xPos < 0) ||
            (yPos < 0) ||
            (xPos > (rect.right - rect.left)) ||
            (yPos > (rect.bottom - rect.top)))
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            fMouseCaptured = FALSE;
        }


    }

    return(CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam));
}



//  Data structure associated with each site the privacy dialog may show
struct SPerSiteData : public IDispatch
{
    BSTR bstrUrl;
    BSTR bstrCookieDomain;
    BSTR bstrHeaderPolicyRef;
    BSTR bstrLinkTagPolicyRef;
    DWORD dwFlags;
    int iPrivacyImpactResource;
    CPolicyHunt* pPolicyHunt;

    SPerSiteData();
    ~SPerSiteData();

    BOOL ReadyForPolicyHunt();

    //  here is overhead for IDispatch:
    virtual ULONG __stdcall AddRef( void );
    virtual ULONG __stdcall Release( void );
    virtual HRESULT __stdcall
        QueryInterface( REFIID iid, void ** ppv);
    
    virtual HRESULT __stdcall
            GetTypeInfoCount( unsigned int FAR*  pctinfo);

    virtual HRESULT __stdcall
            GetTypeInfo( unsigned int  iTInfo,         
                         LCID  lcid,                   
                         ITypeInfo FAR* FAR*  ppTInfo);

    virtual HRESULT __stdcall
            GetIDsOfNames( REFIID  riid,                  
                           OLECHAR FAR* FAR*  rgszNames,  
                           unsigned int  cNames,          
                           LCID   lcid,                   
                           DISPID FAR*  rgDispId);

    virtual HRESULT __stdcall
            Invoke( DISPID  dispIdMember,      
                    REFIID  riid,              
                    LCID  lcid,                
                    WORD  wFlags,              
                    DISPPARAMS FAR*  pDispParams,  
                    VARIANT FAR*  pVarResult,  
                    EXCEPINFO FAR*  pExcepInfo,  
                    unsigned int FAR*  puArgErr);
};


enum enumPolicyHuntResult
{
    POLICYHUNT_INPROGRESS,
    POLICYHUNT_NOTFOUND,
    POLICYHUNT_FOUND,
    POLICYHUNT_ERROR,
    POLICYHUNT_FORMATERROR,
    POLICYHUNT_CANCELLED,
};

class CPolicyHunt : public CCancellableThread
{
public:
    CPolicyHunt();
    ~CPolicyHunt();
    BOOL Initialize( PSPerSiteData pSite);

    //BOOL Run();     defined in CCancelableThread
    //BOOL IsFinished();   defined in CCancelableThread
    //BOOL WaitForNotRunning( DWORD dwMilliseconds, PBOOL pfFinished);   defined in CCancelableThread
    BOOL GetResult( PDWORD pdwResult);  // special handling wraps CCancelableThread::GetResult
    LPCWSTR GetResultFilename();

    //BOOL NotifyCancel();  defined in CCancelableThread

private:
    virtual DWORD run();

    P3PSignal _p3pSignal;
    P3PResource _resourceSite;
    CHAR _szPolicy[MAX_URL_STRING];
    WCHAR _wszPolicy[MAX_URL_STRING];
    WCHAR _wszResultsFile[ MAX_PATH];
    HANDLE _hPolicyFile;

    PCHAR allocCharFromWChar( LPCWSTR pOriginal);

    static BSTR s_pwszPrivacyPolicyTransform;  
    //  the transform is loaded from a resource and does not need
    //to be deallocated..

public:
    LPCWSTR GetPolicyUrl() { return _wszPolicy;};

    static void FreePrivacyPolicyTransform()
    {
        if( s_pwszPrivacyPolicyTransform != NULL)
        {
            SysFreeString( s_pwszPrivacyPolicyTransform);
            s_pwszPrivacyPolicyTransform = NULL;
        }
    }
};

BSTR CPolicyHunt::s_pwszPrivacyPolicyTransform = NULL;


//
// data used by privacy dialog
//
struct SPrivacyDialogData
{
    // parameters set when initiating the privacy dialog..
    IEnumPrivacyRecords *pEnumPrivacyRecords;     // enumerator from Trident
    LPOLESTR    pszName;                          // site name
    BOOL        fReportAllSites;    // flag: Report all sites?  Otherwise, only report impacted
                                    //    and their parent sites.

    // parameters set within the privacy dialog code.
    
    //  listAllSites lists pointers to SPerSiteData for sites
    //return from IEnumPrivacyRecords::enum
    CQueueSortOf listAllSites;
    ULONG countRecordsEnumerated;                                    

    SPrivacyDialogData()
    {
        countRecordsEnumerated = 0;
    }
};


SPerSiteData::SPerSiteData()
{
    bstrUrl = NULL;
    bstrCookieDomain = NULL;
    bstrHeaderPolicyRef = NULL;
    bstrLinkTagPolicyRef = NULL;
    dwFlags = 0;
    iPrivacyImpactResource = 0;
    pPolicyHunt = NULL;
}


SPerSiteData::~SPerSiteData()
{
    if( bstrUrl != NULL)
        SysFreeString( bstrUrl);

    if( bstrCookieDomain != NULL)
        SysFreeString( bstrCookieDomain);

    if( bstrHeaderPolicyRef != NULL)
        SysFreeString( bstrHeaderPolicyRef);

    if( bstrLinkTagPolicyRef != NULL)
        SysFreeString( bstrLinkTagPolicyRef);

    if( pPolicyHunt != NULL)
        delete pPolicyHunt;
}


CPolicyHunt::CPolicyHunt()
{
    memset( &_p3pSignal, 0, sizeof(P3PSignal));
    memset( &_resourceSite, 0, sizeof(P3PResource));
    _szPolicy[0] = '\0';
    _wszPolicy[0] = L'\0';
    _wszResultsFile[0] = L'\0';
    _hPolicyFile = INVALID_HANDLE_VALUE;
}


CPolicyHunt::~CPolicyHunt()
{
    if( _hPolicyFile != INVALID_HANDLE_VALUE)
        CloseHandle( _hPolicyFile);

    if( _wszResultsFile[0] != L'\0')
    {
        DeleteFile( _wszResultsFile);
    }
    
    if( _p3pSignal.hEvent != NULL)
        CloseHandle( _p3pSignal.hEvent);

    if( _resourceSite.pszLocation != NULL)
        delete [] _resourceSite.pszLocation;
    if( _resourceSite.pszVerb != NULL)
        delete [] _resourceSite.pszVerb;
    if( _resourceSite.pszP3PHeaderRef != NULL)
        delete [] _resourceSite.pszP3PHeaderRef;
    if( _resourceSite.pszLinkTagRef != NULL)
        delete [] _resourceSite.pszLinkTagRef;
}


PCHAR CPolicyHunt::allocCharFromWChar( LPCWSTR pOriginal)
{
    PCHAR pResult;
    
    if( pOriginal == NULL)
        return NULL;
        
    int iSize = 1 + lstrlen( pOriginal);

    pResult = new CHAR[ iSize];

    if( pResult == NULL)
        return NULL;

    SHTCharToAnsi( pOriginal, pResult, iSize);

    return pResult;
}


BOOL CPolicyHunt::Initialize( PSPerSiteData pSite)
{
    if( TRUE != CCancellableThread::Initialize())
        return FALSE;
    
    _resourceSite.pszLocation = allocCharFromWChar( pSite->bstrUrl);
    _resourceSite.pszVerb = allocCharFromWChar( 
         (pSite->dwFlags & PRIVACY_URLHASPOSTDATA) ? L"POST" : L"GET");
    _resourceSite.pszP3PHeaderRef = allocCharFromWChar( pSite->bstrHeaderPolicyRef);
    _resourceSite.pszLinkTagRef = allocCharFromWChar( pSite->bstrLinkTagPolicyRef);
    _resourceSite.pContainer = NULL;

    return TRUE;
}


BOOL CPolicyHunt::GetResult( PDWORD pdwResult)
{
    if( IsFinished())
    {
        return CCancellableThread::GetResult( pdwResult);
    }

    *pdwResult = POLICYHUNT_INPROGRESS;
    return TRUE;
}


LPCWSTR CPolicyHunt::GetResultFilename()
{
    return _wszResultsFile;
}


//  used only in CPolicyHunt::run..
//  This the fetched transform need never be deallocated,
//and need only be allocated once.
BSTR LoadPrivacyPolicyTransform()
{
    BSTR returnValue = NULL;
    DWORD dwByteSizeOfResource;

    HRSRC hrsrc = FindResource( MLGetHinst(), 
                               TEXT("privacypolicytransform.xsl"), 
                               MAKEINTRESOURCE(RT_HTML));

    if( hrsrc == NULL)
        goto doneLoadPrivacyPolicyTransform;

    dwByteSizeOfResource = SizeofResource( MLGetHinst(), hrsrc);

    if( dwByteSizeOfResource == 0)
        goto doneLoadPrivacyPolicyTransform;

    HGLOBAL hGlobal = LoadResource( MLGetHinst(), hrsrc);  // Loaded resources do not need to be unloaded

    if( hGlobal == NULL)
        goto doneLoadPrivacyPolicyTransform;

    LPVOID pLockedResource = LockResource( hGlobal);  // Locked resources do not need to be unlocked

    if( pLockedResource == NULL)
        goto doneLoadPrivacyPolicyTransform;

    // Skip first WCHAR when allocating BSTR copy of the transform,
    // since unicode resource starts with an extra 0xFF 0xFE
    int cwCount = (dwByteSizeOfResource/sizeof(WCHAR)) - 1;
    returnValue = SysAllocStringLen( 1+(LPCWSTR)pLockedResource, cwCount);

doneLoadPrivacyPolicyTransform:
   
    return returnValue;
}


DWORD CPolicyHunt::run()
{
    DWORD retVal = POLICYHUNT_ERROR;
    int iTemp;
    DWORD dw;
    
    if( IsFinished())
        goto doneCPolicyHuntRun;

    //  MapResourceToPolicy phase

    //  ...  need an event..
    _p3pSignal.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL);
    if( _p3pSignal.hEvent == NULL)
        goto doneCPolicyHuntRun;

    //  ...   now call MapResourceToPolicy
    iTemp = MapResourceToPolicy(&(_resourceSite), 
                                _szPolicy, 
                                ARRAYSIZE(_szPolicy), 
                                &(_p3pSignal));
    if( iTemp != P3P_InProgress)
        goto doneCPolicyHuntRun;

    //  ...   now wait for MapResourceToPolicy to finish
    do
    {
        if( IsCancelled())
        {
            retVal = POLICYHUNT_CANCELLED;
            goto doneCPolicyHuntRun;
        }
    } while ( WAIT_TIMEOUT == (dw = WaitForSingleObject( _p3pSignal.hEvent, 100)));
    if( WAIT_OBJECT_0 != dw)
        goto doneCPolicyHuntRun;

    FreeP3PObject( _p3pSignal.hRequest);
    _p3pSignal.hRequest = NULL;
 
    //  ...   check if MapResourceToPolicy found anything..
    if( _szPolicy[0] == '\0')
    {
        retVal = POLICYHUNT_NOTFOUND;
        goto doneCPolicyHuntRun;
    }

    //  prepare a WCHAR copy of the policy
    SHAnsiToUnicode( _szPolicy, _wszPolicy, ARRAYSIZE( _wszPolicy));

    //  Now we need to prepare a temp file for our result.
    //  ...   get the path for the result file
    WCHAR szPathBuffer[ MAX_PATH];
    dw = GetTempPath( ARRAYSIZE( szPathBuffer), szPathBuffer);
    if( dw == 0 || dw+1 > MAX_PATH)
        goto doneCPolicyHuntRun;

    //  ...   get a .tmp filename for the result file
    dw = GetTempFileName( szPathBuffer, L"IE", 0, _wszResultsFile);
    if( dw == 0)
        goto doneCPolicyHuntRun;
    DeleteFile( _wszResultsFile);

    //  ...   make the .tmp filename a .htm filename
    dw = lstrlen( _wszResultsFile);
    while( dw > 0 && _wszResultsFile[dw] != L'.')
    {
           dw--;
    }
    StrCpyNW( _wszResultsFile + dw, L".htm", ARRAYSIZE(L".htm"));
    
    //  ...   open the file
    _hPolicyFile = CreateFile( _wszResultsFile, 
                               GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                               CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if( _hPolicyFile == INVALID_HANDLE_VALUE)
        goto doneCPolicyHuntRun;

    if( s_pwszPrivacyPolicyTransform == NULL)
        s_pwszPrivacyPolicyTransform = LoadPrivacyPolicyTransform();

    if( s_pwszPrivacyPolicyTransform == NULL)
        goto doneCPolicyHuntRun;

    ResetEvent( _p3pSignal.hEvent);

    iTemp = GetP3PPolicy( _szPolicy, _hPolicyFile,
                          s_pwszPrivacyPolicyTransform, &_p3pSignal);
    if( iTemp != P3P_InProgress)
        goto doneCPolicyHuntRun;

    //  ...   now wait for GetP3PPolicy to finish
    do
    {
        if( IsCancelled())
        {
            retVal = POLICYHUNT_CANCELLED;
            goto doneCPolicyHuntRun;
        }
    } while ( WAIT_TIMEOUT == (dw = WaitForSingleObject( _p3pSignal.hEvent, 100)));
    if( WAIT_OBJECT_0 != dw)
        goto doneCPolicyHuntRun;

    int iGetP3PPolicyResult;
    iGetP3PPolicyResult = GetP3PRequestStatus( _p3pSignal.hRequest);

    switch( iGetP3PPolicyResult)
    {
    case P3P_Done:
        retVal = POLICYHUNT_FOUND;
        break;
    case P3P_NoPolicy:
    case P3P_NotFound:
        retVal = POLICYHUNT_NOTFOUND;
        break;
    case P3P_Failed:
        retVal = POLICYHUNT_ERROR;
        break;
    case P3P_FormatErr:
        retVal = POLICYHUNT_FORMATERROR;
        break;
    case P3P_Cancelled:
        retVal = POLICYHUNT_CANCELLED;
        break;
    default:
        retVal = POLICYHUNT_ERROR;
        break;
    }

doneCPolicyHuntRun:
    if( _hPolicyFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle( _hPolicyFile);
        _hPolicyFile = INVALID_HANDLE_VALUE;
    }

    if( _p3pSignal.hRequest != NULL)
    {
        FreeP3PObject( _p3pSignal.hRequest);
        _p3pSignal.hRequest = NULL;
    }

    if( _p3pSignal.hEvent != NULL)
    {
        CloseHandle( _p3pSignal.hEvent);
        _p3pSignal.hEvent = NULL;
    }

    memset( &_p3pSignal, 0, sizeof(P3PSignal));
        
    return retVal;
}


//  be warned: a NULL BSTR is equivalent to a "" BSTR..
//  This function returns the cookie domain from an http:// or https:// style Url.
BSTR GetCookieDomainFromUrl( LPCWSTR bstrFullUrl)
{
    BSTR returnValue = NULL;

    if( bstrFullUrl == NULL)
        goto doneGetMinimizedCookieDomain;

    WCHAR wszUrl[MAX_URL_STRING], *pMinimizedDomain;
    wszUrl[0] = L'\0';
    StrCpyNW( wszUrl, bstrFullUrl, lstrlen( bstrFullUrl)+1);
    
    if( wszUrl[0] == '\0')
        goto doneGetMinimizedCookieDomain;
    
    WCHAR *pBeginUrl = wszUrl;     // pBeginUrl will be 'http://full.domain.com/path/path...'
    while( *pBeginUrl != L'\0' && *pBeginUrl != L'/')
        pBeginUrl++;
    if( *pBeginUrl == L'/')
        pBeginUrl++;
    while( *pBeginUrl != L'\0' && *pBeginUrl != L'/')
        pBeginUrl++;
    if( *pBeginUrl == L'/')
        pBeginUrl++;               // now pBeginUrl is 'full.domain.com/path/path'..
    WCHAR *pEndUrl = pBeginUrl;    // pEndUrl will find the '/path/path..' and clip it from pBeginUrl
    while( *pEndUrl != L'\0' && *pEndUrl != L'/')
        pEndUrl++;
    *pEndUrl = L'\0';
    pMinimizedDomain = pEndUrl;   
    //  pBeginUrl is now like 'full.domain.com'
    //  pMinimizedDomain will reduce pBeginUrl to a domain minimized to still allow cookies..

    do
    {
        pMinimizedDomain--;
        while( pBeginUrl < pMinimizedDomain
               && *(pMinimizedDomain-1) != L'.')
        {
            pMinimizedDomain--;
        }
    } while( !IsDomainLegalCookieDomain( pMinimizedDomain, pBeginUrl)
             && pBeginUrl < pMinimizedDomain);

    returnValue = SysAllocString( pMinimizedDomain);

doneGetMinimizedCookieDomain:
    return returnValue;
}


void PrivacyDlgDeallocSiteList( PSPrivacyDialogData pData)
{
    void* iterator = NULL;
    while( NULL != (iterator = pData->listAllSites.StepEnumerate(iterator)))
    {
        PSPerSiteData pCurrent = 
            (PSPerSiteData)(pData->listAllSites.Get( iterator));
        delete pCurrent;
    }

    CPolicyHunt::FreePrivacyPolicyTransform();
}


BOOL PrivacyDialogExtendSiteList( PSPrivacyDialogData pData)
{
    BOOL returnValue = FALSE;

    BSTR bstrUrl = NULL, bstrPolicyRef = NULL;
    DWORD dwFlags;
    ULONG ulPrivacyRecordsTotal;

    if( FAILED(pData->pEnumPrivacyRecords->GetSize( &ulPrivacyRecordsTotal)))
        ulPrivacyRecordsTotal = 0;

    DWORD dwTemp;

    //  Enumerate the sites in IEnumPrivacyRecords::enum
    PSPerSiteData pCurrentSite = NULL, pCurrentSiteInList = NULL;
    while( pData->countRecordsEnumerated < ulPrivacyRecordsTotal
           && SUCCEEDED( dwTemp = pData->pEnumPrivacyRecords->
                                            Next(&bstrUrl, &bstrPolicyRef, 
                                            NULL, &dwFlags)))
    {
        pData->countRecordsEnumerated++;
        pCurrentSite = NULL;
        pCurrentSiteInList = NULL;
        void* iterator = NULL;

        if(NULL == bstrUrl || 0 == *bstrUrl)
        {
            //  every time we pass a blank token,
            //we begin processing a higher navigation level.
            SysFreeString( bstrUrl);
            bstrUrl = NULL;
            continue;
        }

        if( 0 != StrNCmpI( bstrUrl, L"http", ARRAYSIZE(L"http")-1))
        {
            // we ignore non http stuff... like ftp, local files..
            continue;
        }

        //  Test if the current site is already in the list.
        iterator = NULL;
        while( pCurrentSiteInList == NULL 
               && NULL != 
                  (iterator = pData->listAllSites.StepEnumerate(iterator)))
        {
            PSPerSiteData pCurrent = 
                (PSPerSiteData)(pData->listAllSites.Get( iterator));
            if( 0 == StrCmp( bstrUrl, pCurrent->bstrUrl))
                pCurrentSiteInList = pCurrent;
        }

        //  If the site is not in the list, add it.
        //  If the site isn't in the list, add the information given by enum.
        if( pCurrentSiteInList == NULL)
        {
            pCurrentSite = new SPerSiteData();

            if( pCurrentSite == NULL)
                goto donePrivacyDialogExtendSiteList;

            pCurrentSite->bstrUrl = bstrUrl;
            bstrUrl = NULL;
            pCurrentSite->dwFlags = dwFlags;
            //  Now find the minimized cookie domain..
            pCurrentSite->bstrCookieDomain = 
                GetCookieDomainFromUrl( pCurrentSite->bstrUrl);
            
            if( pData->listAllSites.InsertAtEnd( pCurrentSite))
                pCurrentSiteInList = pCurrentSite;
            else
                goto donePrivacyDialogExtendSiteList;
        }
        else  // else we have a duplicate list item
        {
            pCurrentSite = pCurrentSiteInList;
            //  pCurrentSite->bstrUrl is correct
            //  pCurrentSite->bstrCookieDomain is correct
            pCurrentSite->dwFlags |= dwFlags;
        }

        if( bstrPolicyRef != NULL && dwFlags & PRIVACY_URLHASPOLICYREFHEADER)
        {  //  We have the policy ref from the header..
            SysFreeString( pCurrentSite->bstrHeaderPolicyRef);  // NULLs are ignored..
            pCurrentSite->bstrHeaderPolicyRef = bstrPolicyRef;
            bstrPolicyRef = NULL;
        }
        else if ( bstrPolicyRef != NULL && dwFlags & PRIVACY_URLHASPOLICYREFLINK)
        {  //  We have the policy ref from the link tag..
            SysFreeString( pCurrentSite->bstrLinkTagPolicyRef);  // NULLs are ignored..
            pCurrentSite->bstrLinkTagPolicyRef = bstrPolicyRef;
            bstrPolicyRef = NULL;
        }
        else if( bstrPolicyRef != NULL)
        {  //  We have a policy ref with an unknown source..  bug in IEnumPrivacyRecords
            ASSERT(0);  
            SysFreeString( pCurrentSite->bstrHeaderPolicyRef);  // NULLs are ignored..
            pCurrentSite->bstrHeaderPolicyRef = bstrPolicyRef;
            bstrPolicyRef = NULL;
        }


        //  now to determine the privacy impact of the site..
        //     precedence:  IDS_PRIVACY_BLOCKED > IDS_PRIVACY_RESTRICTED > IDS_PRIVACY_ACCEPTED > nothing
        if( dwFlags & (COOKIEACTION_ACCEPT | COOKIEACTION_LEASH))
        {
            pCurrentSite->iPrivacyImpactResource = max( pCurrentSite->iPrivacyImpactResource,
                                                        IDS_PRIVACY_ACCEPTED);
        }

        if( dwFlags & COOKIEACTION_DOWNGRADE)
        {
            pCurrentSite->iPrivacyImpactResource = max( pCurrentSite->iPrivacyImpactResource,
                                                        IDS_PRIVACY_RESTRICTED);
        }

        if( dwFlags & (COOKIEACTION_REJECT | COOKIEACTION_SUPPRESS))
        {
            pCurrentSite->iPrivacyImpactResource = max( pCurrentSite->iPrivacyImpactResource,
                                                        IDS_PRIVACY_BLOCKED);
        }

        SysFreeString( bstrUrl);
        bstrUrl = NULL;
        SysFreeString( bstrPolicyRef);
        bstrPolicyRef = NULL;
    }

    returnValue = TRUE;
  
donePrivacyDialogExtendSiteList:
    if( bstrUrl != NULL)
        SysFreeString( bstrUrl);

    if( bstrPolicyRef != NULL)
        SysFreeString( bstrUrl);

    if( pCurrentSite != NULL && pCurrentSiteInList == NULL)
        delete pCurrentSite;

    return returnValue;
}


BOOL PrivacyDlgBuildSiteList( PSPrivacyDialogData pData)
{
    PrivacyDlgDeallocSiteList( pData);

    return PrivacyDialogExtendSiteList( pData);
}


BOOL InitializePrivacyDlg(HWND hDlg, PSPrivacyDialogData pData)
{
    WCHAR       szBuffer[256];
    HWND        hwndListView = GetDlgItem(hDlg, IDC_SITE_LIST);
    RECT rc;
 
    //  Set the privacy status caption text
    BOOL fImpacted;
    if( SUCCEEDED(pData->pEnumPrivacyRecords->GetPrivacyImpacted(&fImpacted)) && fImpacted)
    {
        MLLoadStringW( IDS_PRIVACY_STATUSIMPACTED, szBuffer, ARRAYSIZE( szBuffer));
    }
    else
    {
        MLLoadStringW( IDS_PRIVACY_STATUSNOIMPACT, szBuffer, ARRAYSIZE( szBuffer));
    }
    SendMessage( GetDlgItem( hDlg, IDC_PRIVACY_STATUSTEXT), WM_SETTEXT,
                 0, (LPARAM)szBuffer);

    //Initialize the list view..
    // ..Empty the list in list view.
    ListView_DeleteAllItems (hwndListView);

    // ..Initialize the columns in the list view.
    LV_COLUMN   lvColumn;        
    lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.pszText = szBuffer;

    lvColumn.cx = 300;
    if( 0 != GetClientRect( hwndListView, &rc))
        lvColumn.cx = rc.right - rc.left - 150 - GetSystemMetrics( SM_CXVSCROLL);
    //  15 is an arbitrary number to prevent the horizontal scrollbar from appearing
    MLLoadStringW(IDS_PRIVACY_COLUMN1, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hwndListView, 1, &lvColumn);

    lvColumn.cx = 150;
    MLLoadStringW(IDS_PRIVACY_COLUMN2, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hwndListView, 2, &lvColumn);

    //  Initialize the view all/restricted combo box
    HWND hwndComboBox = GetDlgItem( hDlg, IDC_PRIVACY_VIEWCOMBO);

    ComboBox_ResetContent( hwndComboBox);
    int iComboPosition;

    MLLoadStringW(IDS_PRIVACY_VIEWIMPACTED, szBuffer, ARRAYSIZE(szBuffer));
    iComboPosition = ComboBox_AddString(hwndComboBox, szBuffer);
    ComboBox_SetItemData(hwndComboBox, iComboPosition, 0);
    MLLoadStringW(IDS_PRIVACY_VIEWALL, szBuffer, ARRAYSIZE(szBuffer));
    iComboPosition = ComboBox_AddString(hwndComboBox, szBuffer);
    ComboBox_SetItemData(hwndComboBox, iComboPosition, 1);

    ComboBox_SetCurSel( hwndComboBox, pData->fReportAllSites);

    GetDlgItemText( hDlg, IDC_PRIVACY_HELP, szBuffer, ARRAYSIZE( szBuffer));
    MLLoadStringW(IDS_PRIVACY_LEARNMOREABOUTPRIVACY, szBuffer, ARRAYSIZE(szBuffer));
    RenderStringToEditControlW(hDlg,
                               szBuffer,
                               (WNDPROC)HyperlinkSubclass,
                               IDC_PRIVACY_HELP);

    return TRUE;
}


//  add items to the privacy dialog's listview..
BOOL PopulatePrivacyDlgListView(HWND hDlg, PSPrivacyDialogData pData, bool fMaintainSelectedItem)
{
    HWND hwndListView = GetDlgItem( hDlg, IDC_SITE_LIST);
    void* iterator = NULL;
    int iCurrentPosition = 0;
    int iSelectedItem = ListView_GetSelectionMark( hwndListView);
    PSPerSiteData pSelectedItem = NULL;

    if( fMaintainSelectedItem  && iSelectedItem != -1)
    {
        LVITEM lvi;
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iSelectedItem;
        if( FALSE != ListView_GetItem( hwndListView, &lvi)
           && lvi.lParam != (LPARAM)NULL)
        {
            pSelectedItem = (PSPerSiteData)lvi.lParam;
        }
    }

    // Empty the list in list view.
    ListView_DeleteAllItems (hwndListView);

    iSelectedItem = -1;  

    while( NULL != (iterator = pData->listAllSites.StepEnumerate(iterator)))
    {
        PSPerSiteData pCurrent = 
            (PSPerSiteData)(pData->listAllSites.Get(iterator));

        BOOL fAddItem = pData->fReportAllSites
                        || pCurrent->iPrivacyImpactResource == IDS_PRIVACY_SUPPRESSED
                        || pCurrent->iPrivacyImpactResource == IDS_PRIVACY_RESTRICTED
                        || pCurrent->iPrivacyImpactResource == IDS_PRIVACY_BLOCKED;

        if( fAddItem == TRUE)
        {
            LVITEM  lvitem;
            lvitem.mask = LVIF_TEXT | LVIF_PARAM;
            lvitem.pszText = pCurrent->bstrUrl;
            lvitem.iItem = iCurrentPosition++;
            lvitem.iSubItem = 0;
            lvitem.lParam = (LPARAM)pCurrent;
            ListView_InsertItem(hwndListView, &lvitem);

            if( pCurrent->iPrivacyImpactResource != 0)
            {
                WCHAR   wszTemp[128];

                // set cookie string
                lvitem.iSubItem = 1;
                lvitem.mask = LVIF_TEXT;
                lvitem.pszText = wszTemp;
                if( MLLoadString(pCurrent->iPrivacyImpactResource,
                                 wszTemp, ARRAYSIZE(wszTemp)))
                {
                    SendMessage(hwndListView, LVM_SETITEMTEXT, 
                                (WPARAM)lvitem.iItem, (LPARAM)&lvitem);
                }
            }

            //  We either keep the last item selected as selected,
            //or select the last top-level item.
            if( fMaintainSelectedItem)
            {
                if( pSelectedItem == pCurrent)
                    iSelectedItem = lvitem.iItem;
            }
        }
    }

//    if( fMaintainSelectedItem && iSelectedItem != -1)
//    {
//        ListView_SetItemState( hwndListView, iSelectedItem, LVIS_SELECTED, LVIS_SELECTED);
//        ListView_SetSelectionMark( hwndListView, iSelectedItem);
//        ListView_EnsureVisible( hwndListView, iSelectedItem, FALSE);
//    }

    PostMessage( hDlg, WM_APP, IDC_SITE_LIST, 0);  // notifies the dialog that a listview item has been selected

    return TRUE;
}


typedef BOOL (*PFNPRIVACYSETTINGS)(HWND);

void LaunchPrivacySettings(HWND hwndParent)
{
    HMODULE             hmodInetcpl;
    PFNPRIVACYSETTINGS  pfnPriv;

    hmodInetcpl = LoadLibrary(TEXT("inetcpl.cpl"));
    if(hmodInetcpl)
    {
        pfnPriv = (PFNPRIVACYSETTINGS)GetProcAddress(hmodInetcpl, "LaunchPrivacyDialog");
        if(pfnPriv)
        {
            pfnPriv(hwndParent);
        }

        FreeLibrary(hmodInetcpl);
    }
}


BOOL PrivacyPolicyHtmlDlg( HWND hDlg, HWND hwndListView, int iItemIndex)
{
    BOOL returnValue = FALSE;
    HRESULT hr;
    DWORD dw;
    PSPerSiteData pListViewData;
    WCHAR* pwchHtmlDialogInput = NULL;
    IMoniker * pmk = NULL;
    VARIANT  varArg, varOut;
    VariantInit( &varArg);
    VariantInit( &varOut);

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItemIndex;
    if( FALSE == ListView_GetItem( hwndListView, &lvi)
       || lvi.lParam == (LPARAM)NULL)
        goto donePrivacyPolicyHtmlDlg;
    pListViewData = (PSPerSiteData)lvi.lParam;

    WCHAR szResURL[MAX_URL_STRING];

    //  fetch the HTML for the dialog box..
    hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                           HINST_THISDLL,
                           ML_CROSSCODEPAGE,
                           TEXT("privacypolicy.dlg"),
                           szResURL,
                           ARRAYSIZE(szResURL),
                           TEXT("shdocvw.dll"));

    if( FAILED( hr))
        goto donePrivacyPolicyHtmlDlg;
    
    hr = CreateURLMoniker(NULL, szResURL, &pmk);
    if( FAILED( hr))
        goto donePrivacyPolicyHtmlDlg;

    varArg.vt = VT_DISPATCH;
    varArg.pdispVal = (IDispatch*)pListViewData;

    //  Show the dialog..
    hr = ShowHTMLDialog( hDlg, pmk, &varArg, L"help:no; resizable:1", &varOut);

    if( FAILED( hr))
        goto donePrivacyPolicyHtmlDlg;
        
    hr = VariantChangeType( &varOut, &varOut, NULL, VT_I4);

    if( FAILED( hr))
        goto donePrivacyPolicyHtmlDlg;

    if( allowPerSiteModify())
    {
        switch( varOut.lVal)
        {
        default:
            hr = TRUE;
            break;
        case 1:
            hr = InternetSetPerSiteCookieDecision( 
                   pListViewData->bstrCookieDomain, COOKIE_STATE_UNKNOWN);
            break;
        case 2:
            hr = InternetSetPerSiteCookieDecision( 
                   pListViewData->bstrCookieDomain, COOKIE_STATE_ACCEPT);
            break;
        case 3:
            hr = InternetSetPerSiteCookieDecision( 
                   pListViewData->bstrCookieDomain, COOKIE_STATE_REJECT);
            break;
        }
    }
    
    if( hr != TRUE)
        goto donePrivacyPolicyHtmlDlg;

    returnValue = TRUE;

donePrivacyPolicyHtmlDlg:

    if( pListViewData->pPolicyHunt != NULL)
    {
        // no-op if already finished
        pListViewData->pPolicyHunt->NotifyCancel();  
        pListViewData->pPolicyHunt->WaitForNotRunning( INFINITE);
    }
    
    if( pListViewData->pPolicyHunt != NULL 
        && pListViewData->pPolicyHunt->GetResult( &dw) == TRUE
        && dw != POLICYHUNT_FOUND)
    {
        delete pListViewData->pPolicyHunt;
        pListViewData->pPolicyHunt = NULL;
    }

    if( pwchHtmlDialogInput != NULL)
        delete[] pwchHtmlDialogInput;
    
    if( pmk != NULL)
        ATOMICRELEASE( pmk);

    VariantClear( &varArg);
    VariantClear( &varOut);

    return returnValue;
}


BOOL PrivacyDlgContextMenuHandler( HWND hDlg, HWND hwndListView, 
                                   int iSelectedListItem, int x, int y)
{
    //user has initiated opening the context menu..
    //  if the user right-clicked a non-list item, we do nothing
    if( iSelectedListItem == -1
        || !allowPerSiteModify())
        return TRUE;

    SPerSiteData *psSiteData = NULL;
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iSelectedListItem;
    if( FALSE == ListView_GetItem( hwndListView, &lvi)
       || lvi.lParam == (LPARAM)NULL)
        return FALSE;
    psSiteData = (PSPerSiteData)(lvi.lParam);
    
    HMENU hmenu0 = LoadMenu( MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_CNTXTMN_PERSITE_ADD_REM));
    HMENU hmenu1 = GetSubMenu( hmenu0, 0);
    if( hmenu0 == NULL || hmenu1 == NULL)
    {
        DestroyMenu(hmenu0);
        return FALSE;
    }

    //  Check the appropriate option..
    unsigned long ulResult;
    MENUITEMINFO menuiteminfo;
    menuiteminfo.cbSize = sizeof(menuiteminfo);
    menuiteminfo.fMask = MIIM_STATE;
    menuiteminfo.fState = MFS_CHECKED;
    if( InternetGetPerSiteCookieDecision( psSiteData->bstrCookieDomain, &ulResult) == TRUE)
    {
        switch( ulResult)
        {
        case COOKIE_STATE_ACCEPT:
            SetMenuItemInfo( hmenu1, IDM_PRIVACY_PAR_ACCEPT, FALSE, &menuiteminfo);
            break;
        case COOKIE_STATE_REJECT:
            SetMenuItemInfo( hmenu1, IDM_PRIVACY_PAR_REJECT, FALSE, &menuiteminfo);
            break;
        }
    }
    else
    {
        SetMenuItemInfo( hmenu1, IDM_PRIVACY_PAR_DEFAULT, FALSE, &menuiteminfo);
    }

    //  the target location of the context window depends on whether or not the user
    //right-clicked the mouse or used the context menu button..
    if( x == -1 && y == -1)
    {  //  context menu was opened through keyboard, not mouse..
        RECT rectListRect;
        RECT rectSelectionRect;
        if(  0 != GetWindowRect( hwndListView, &rectListRect)
            && TRUE == ListView_GetItemRect( hwndListView, iSelectedListItem, 
                                             &rectSelectionRect, LVIR_LABEL))
        {
            x = rectListRect.left + (rectSelectionRect.left + rectSelectionRect.right) / 2;
            y = rectListRect.top + (rectSelectionRect.top + rectSelectionRect.bottom) / 2;
        }
    }

    //  now we know enough to open the conext menu.
    BOOL userSelection = TrackPopupMenu( hmenu1, TPM_RETURNCMD, x, y, 0, hDlg, NULL);
    DestroyMenu( hmenu1);
    DestroyMenu( hmenu0);

    switch( userSelection)
    {
        case 0:
            //  User cancelled context menu, do nothing.
            break;
        case IDM_PRIVACY_PAR_ACCEPT:
            //  User chose to add site to per-site exclusion list.
            InternetSetPerSiteCookieDecision( psSiteData->bstrCookieDomain, COOKIE_STATE_ACCEPT);
            break;
        case IDM_PRIVACY_PAR_REJECT:
            //  User chose to add site per-site inclusion list.
            InternetSetPerSiteCookieDecision( psSiteData->bstrCookieDomain, COOKIE_STATE_REJECT);
            break;
        case IDM_PRIVACY_PAR_DEFAULT:
            //  User chose to have site use default behavior.
            InternetSetPerSiteCookieDecision( psSiteData->bstrCookieDomain, COOKIE_STATE_UNKNOWN);
            break;
    }

   return TRUE;
}


LRESULT CALLBACK PrivacyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    PSPrivacyDialogData pData = (PSPrivacyDialogData)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam);
            pData = (PSPrivacyDialogData)lParam;
            InitializePrivacyDlg( hDlg, pData);
            PrivacyDlgBuildSiteList( pData);
            PopulatePrivacyDlgListView(hDlg, pData, false);

            if( IsOS(OS_WHISTLERORGREATER))
            {
                HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                if( hIcon != NULL)
                    SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                // icons loaded with LoadIcon never need to be released
            }
            
            PostMessage( hDlg, WM_NEXTDLGCTL, 
                         (WPARAM)GetDlgItem( hDlg, IDC_SITE_LIST), 
                         MAKELPARAM( TRUE, 0));
            SetTimer( hDlg, NULL, 500, NULL);
            return TRUE;

        case WM_DESTROY:
            PrivacyDlgDeallocSiteList( pData);

            break;

        case WM_TIMER:
            {
                ULONG oldCount = pData->countRecordsEnumerated;
                if( pData != NULL
                    && TRUE == PrivacyDialogExtendSiteList( pData)
                    && oldCount < pData->countRecordsEnumerated)
                {
                    PopulatePrivacyDlgListView( hDlg, pData, true);
                }
            }
            
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    switch( GetDlgCtrlID(GetFocus()))
                    {
                        case IDC_SITE_LIST:
                        {
                            PostMessage( hDlg, WM_COMMAND, 
                                         (WPARAM)IDC_PRIVACY_SHOWPOLICY,
                                         (LPARAM)GetDlgItem(hDlg, IDC_PRIVACY_SHOWPOLICY));
                            return 0;  // return 0 to indicate message was handled
                        }
                        case IDC_PRIVACY_HELP:
                        {
                            PostMessage( hDlg, WM_APP, (WPARAM)IDC_PRIVACY_HELP, (LPARAM)GetDlgItem(hDlg, IDC_PRIVACY_HELP));
                            return 0;
                        }
                        case IDC_PRIVACY_VIEWCOMBO:
                        {
                            PostMessage( hDlg, WM_NEXTDLGCTL, 
                                         (WPARAM)GetDlgItem( hDlg, IDC_SITE_LIST), 
                                         MAKELPARAM( TRUE, 0)); 
                            return 0;
                        }
                    }
                    //  fall through if IDOK was actually due to hitting IDOK with defaulting on an enter..
                 case IDCANCEL:
                    EndDialog(hDlg, LOWORD(wParam));
                    return 0;
                case IDC_SETTINGS:
                    LaunchPrivacySettings(hDlg);
                    return 0;
                case IDC_PRIVACY_VIEWCOMBO:
                    if( CBN_SELCHANGE == HIWORD(wParam))
                    {
                        HWND hwndComboBox = (HWND)lParam;

                        int iIndex = ComboBox_GetCurSel(hwndComboBox);
                        
                        if( iIndex != CB_ERR)
                        {
                            pData->fReportAllSites = (iIndex == 1) ? TRUE : FALSE;
                                                    
                            PopulatePrivacyDlgListView(hDlg, pData, true);
                        }
                        return 0;
                    }
                    break;
                case IDC_PRIVACY_SHOWPOLICY:
                    {
                        //  Catching the default return and seeing if the site list is
                        //selected was the only way to detect a return on the listview.
                        HWND hwndSiteList = GetDlgItem( hDlg, IDC_SITE_LIST);
                        int iSelectedItem = ListView_GetSelectionMark( hwndSiteList);
                        if( iSelectedItem != -1)
                        {
                            PrivacyPolicyHtmlDlg( hDlg, hwndSiteList, iSelectedItem);
                        }
                        return 0;
                    }
            }
            break;

        case WM_APP:
            if( LOWORD(wParam) == IDC_PRIVACY_HELP)
            {
                SHHtmlHelpOnDemandWrap(hDlg, TEXT("iexplore.chm > iedefault"), 
                    HH_DISPLAY_TOPIC, (DWORD_PTR) L"sec_cook.htm", ML_CROSSCODEPAGE);
            }
            else if ( LOWORD( wParam) == IDC_SITE_LIST)
            {
                //   We post an WM_APP to the dialog everytime the selected list view item
                //is changed..  By handling the change in a posted message, we insure the
                //list view's selected item is updated.

                //  Whenever the selected privacy report list item is changed, we have to enable/disable
                //the show site policy button.

                int iSelectedItem = ListView_GetSelectionMark( GetDlgItem( hDlg, IDC_SITE_LIST));

                EnableWindow( GetDlgItem( hDlg, IDC_PRIVACY_SHOWPOLICY), (-1 != iSelectedItem));

            }
            
            return 0;

        case WM_CONTEXTMENU:
            //  If the user hits the context menu button on the list view, we handle it here,
            //because its the only place to check for that keypress.
            //  If the user clicks the right mouse button for the context menu, we handle it in
            //WM__NOTIFY::NM_RCLICK, because the NM_RCLICK gives the correct seleceted item.
            if( GET_X_LPARAM(lParam) == -1
                && (HWND)wParam == GetDlgItem( hDlg, IDC_SITE_LIST))
            {
                int iSelectedItem = ListView_GetSelectionMark( GetDlgItem( hDlg, IDC_SITE_LIST));
                PrivacyDlgContextMenuHandler( hDlg, (HWND)wParam, 
                                              iSelectedItem,
                                              GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            }
            break;
        case WM_NOTIFY:
            if( IDC_SITE_LIST == ((LPNMHDR)lParam)->idFrom
                && NM_DBLCLK == ((LPNMHDR)lParam)->code
                && ((LPNMITEMACTIVATE)lParam)->iItem != -1)
            {
                PrivacyPolicyHtmlDlg( hDlg, ((LPNMHDR)lParam)->hwndFrom, 
                                      ((LPNMITEMACTIVATE)lParam)->iItem);
            }
            else if( IDC_SITE_LIST == ((LPNMHDR)lParam)->idFrom
                     && NM_RCLICK == ((LPNMHDR)lParam)->code)
            {
                int iRightClickedItem = ((LPNMITEMACTIVATE)lParam)->iItem;
                if( iRightClickedItem != -1)
                {
                    POINT pointClick = ((LPNMITEMACTIVATE)lParam)->ptAction;
                    RECT rc;
                    if( 0 != GetWindowRect( GetDlgItem( hDlg, IDC_SITE_LIST), &rc))
                    {
                        pointClick.x += rc.left;
                        pointClick.y += rc.top;
                    }
                    else
                    {  
                        //  Strange error case.. but its alright since we can place the context menu
                        //as if the context-menu button was clicked, instead of the mouse
                        pointClick.x = -1;
                        pointClick.y = -1;
                    }
                    PrivacyDlgContextMenuHandler( hDlg, GetDlgItem( hDlg, IDC_SITE_LIST), 
                                                  iRightClickedItem,
                                                  pointClick.x, pointClick.y);
                }
            }
            else if( IDC_SITE_LIST == ((LPNMHDR)lParam)->idFrom
                     && LVN_ITEMCHANGED == ((LPNMHDR)lParam)->code)
            {
                if( ((LPNMLISTVIEW)lParam)->uChanged & LVIF_STATE)
                {
                    //  For some unknown reason the selection mark does not move with
                    //the selected item..  We have to update it.
                    if( ((LPNMLISTVIEW)lParam)->uNewState & LVIS_SELECTED)
                    {
                         ListView_SetSelectionMark( GetDlgItem( hDlg, IDC_SITE_LIST), 
                                                    ((LPNMLISTVIEW)lParam)->iItem);
                    }
                    else
                    {
                         ListView_SetSelectionMark( GetDlgItem( hDlg, IDC_SITE_LIST), 
                                                    -1);
                    }

                    //  Now that the selection mark is in sync, the UI can update
                    //related items
                    PostMessage( hDlg, WM_APP, IDC_SITE_LIST, 0);
                }
            }
            break;
    }
    return FALSE;
}


//
// Exported entry point to show privacy dialog
//
SHDOCAPI
DoPrivacyDlg(
    HWND                hwndParent,             // parent window
    LPOLESTR            pszUrl,                 // base URL
    IEnumPrivacyRecords *pPrivacyEnum,          // enum of all affected dependant URLs
    BOOL                fReportAllSites         // show all or just show bad
    )
{
    HINSTANCE hRichEditDll;
    
    SPrivacyDialogData p;     // data to send to dialogbox

    if(NULL == pszUrl || NULL == pPrivacyEnum)
    {
        return E_INVALIDARG;
    }

    // We need to load richedit
    hRichEditDll = LoadLibrary(TEXT("RICHED20.DLL"));
    if (!hRichEditDll)
    {
        ASSERT(FALSE); //can't load richedit, complain to akabir
        return E_UNEXPECTED;
    }

    p.pszName = pszUrl;
    p.pEnumPrivacyRecords = pPrivacyEnum;
    p.fReportAllSites = fReportAllSites;

    SHFusionDialogBoxParam(MLGetHinst(),
        MAKEINTRESOURCE(IDD_PRIVACY_DIALOG),
        hwndParent,
        (DLGPROC)PrivacyDlgProc,
        (LPARAM)&p);

    FreeLibrary( hRichEditDll);

    return S_OK;
}


#define DISPID_URL 10
#define DISPID_COOKIEURL 11
#define DISPID_ARD 12
#define DISPID_ARD_FIXED 13
#define DISPID_POLICYHUNT_DONE 14
#define DISPID_POLICYHUNT_VIEW 15
#define DISPID_CREATEABSOLUTEURL 16

struct SPropertyTable
{
    WCHAR* pName;
    DISPID dispid;
} const g_SPerSiteDataDisptable[] =
{
    L"url",       DISPID_URL,
    L"cookieUrl", DISPID_COOKIEURL,
    L"acceptRejectOrDefault", DISPID_ARD,
    L"fixedAcceptRejectOrDefault", DISPID_ARD_FIXED,
    L"flagPolicyHuntDone", DISPID_POLICYHUNT_DONE,
    L"urlPolicyHuntView", DISPID_POLICYHUNT_VIEW,
    L"CreateAbsoluteUrl", DISPID_CREATEABSOLUTEURL
};

const DWORD g_cSPerSiteDataDisptableSize = ARRAYSIZE( g_SPerSiteDataDisptable);

ULONG SPerSiteData::AddRef( void )
{
    return 1;
}

ULONG SPerSiteData::Release( void )
{
    return 1;
}

HRESULT SPerSiteData::QueryInterface( REFIID iid, void ** ppv)
{
    if( ppv == NULL) return E_POINTER;

    if (IsEqualIID(iid, IID_IUnknown) 
        || IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (void *)this;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}
    
HRESULT SPerSiteData::GetTypeInfoCount( unsigned int FAR*  pctinfo)
{
    if( pctinfo == NULL)
        return E_POINTER;

    *pctinfo = 0;
    return S_OK;
}

HRESULT SPerSiteData::GetTypeInfo( unsigned int  iTInfo,         
                                   LCID  lcid,                   
                                   ITypeInfo FAR* FAR*  ppTInfo)
{
    return E_NOTIMPL;
}

HRESULT SPerSiteData::GetIDsOfNames( REFIID  riid,                  
                                     OLECHAR FAR* FAR*  rgszNames,  
                                     unsigned int  cNames,          
                                     LCID   lcid,                   
                                     DISPID FAR*  rgDispId)
{
    if( !IsEqualIID(riid, IID_NULL) )
        return E_INVALIDARG;

    if( cNames != 1)
        return E_INVALIDARG; // none of the objects we ID have arguments..

    int i;

    for( i = 0; i < g_cSPerSiteDataDisptableSize; i++)
    {
        if( 0 == StrCmp( rgszNames[0], g_SPerSiteDataDisptable[i].pName))
        {
            rgDispId[0] = g_SPerSiteDataDisptable[i].dispid;
            return S_OK;
        }
    }

    rgDispId[0] = DISPID_UNKNOWN;
    return DISP_E_UNKNOWNNAME;
}


HRESULT SPerSiteData::Invoke( DISPID  dispIdMember,      
                              REFIID  riid,              
                              LCID  lcid,                
                              WORD  wFlags,              
                              DISPPARAMS FAR*  pDispParams,  
                              VARIANT FAR*  pVarResult,  
                              EXCEPINFO FAR*  pExcepInfo,  
                              unsigned int FAR*  puArgErr)
{
    HRESULT hr;
    DWORD dw;
    
    if( !IsEqualIID(riid, IID_NULL) )
        return E_INVALIDARG;

    if( pDispParams == NULL 
        || pDispParams->cNamedArgs != 0)
        return DISP_E_BADPARAMCOUNT;
        
    switch( dispIdMember)
    {
    case DISPID_CREATEABSOLUTEURL:
        if( pDispParams->cArgs != 1)
            return DISP_E_BADPARAMCOUNT;
        if( pVarResult == NULL)
            return S_OK;
        break;
    case DISPID_COOKIEURL:
    case DISPID_URL:
    case DISPID_ARD:
    case DISPID_ARD_FIXED:
    case DISPID_POLICYHUNT_DONE:
    case DISPID_POLICYHUNT_VIEW:
        if( pDispParams->cArgs != 0)
            return DISP_E_BADPARAMCOUNT;
        if( !(wFlags & DISPATCH_PROPERTYGET))
            return DISP_E_MEMBERNOTFOUND;
        if( pVarResult == NULL)
            return S_OK;
        break;
    default:
        return DISP_E_MEMBERNOTFOUND;
    }

    pVarResult->vt = VT_BSTR;

    switch( dispIdMember)
    {
    case DISPID_COOKIEURL:
        pVarResult->bstrVal = SysAllocString(bstrCookieDomain);
        return S_OK;
    case DISPID_URL:
        {
            BSTR bstrResult = SysAllocString( bstrUrl);

            if( bstrResult == NULL)
                return ERROR_OUTOFMEMORY;

            //  Cut of query info from end of URL..
            PWCHAR pCursor = bstrResult;
            while( pCursor[0] != L'\0' && pCursor[0] != L'?')
                pCursor++;
            pCursor[0] = L'\0';
                
            pVarResult->bstrVal = bstrResult;
            return S_OK;
        }
    case DISPID_ARD:
        {
            unsigned long ulResult;
            if( InternetGetPerSiteCookieDecision( 
                    bstrCookieDomain, &ulResult)
                == TRUE)
            {
                switch( ulResult)
                {
                case COOKIE_STATE_ACCEPT:
                    pVarResult->bstrVal = SysAllocString( L"a");
                    break;
                case COOKIE_STATE_REJECT:
                    pVarResult->bstrVal = SysAllocString( L"r");
                    break;
                default:
                    pVarResult->bstrVal = SysAllocString( L"d");
                    break;
                }
            }
            else
            {
                pVarResult->bstrVal = SysAllocString( L"d");
            }           
            return S_OK;
        }
    case DISPID_ARD_FIXED:
        {
            pVarResult->vt = VT_BOOL;
            pVarResult->boolVal = !allowPerSiteModify();
            return S_OK;
        }
    case DISPID_POLICYHUNT_DONE:
        {
            //  try to start the policy hunt..
            if( pPolicyHunt == NULL)
            {
                CPolicyHunt* pNewHunt = new CPolicyHunt();

                if( !pNewHunt
                    || TRUE != pNewHunt->Initialize( this)
                    || TRUE != pNewHunt->Run())
                {
                    goto doneTryToStartPolicyHunt;
                }

                pPolicyHunt = pNewHunt;
                pNewHunt = NULL;
            doneTryToStartPolicyHunt:
                if( pNewHunt != NULL)
                    delete pNewHunt;
            }
            pVarResult->vt = VT_BOOL;
            pVarResult->boolVal = pPolicyHunt != NULL
                                  && pPolicyHunt->IsFinished();

            return S_OK;
        }
    case DISPID_POLICYHUNT_VIEW:
        {
            pVarResult->vt = VT_BSTR;
            LPWSTR szResultHtm = L"policyerror.htm";

            if( pPolicyHunt == NULL
                || FALSE == pPolicyHunt->IsFinished())
            {
                szResultHtm = L"policylooking.htm";
            }
            else if( TRUE == pPolicyHunt->GetResult( &dw))
            {
                switch( dw)
                {
                case POLICYHUNT_FOUND:
                    pVarResult->bstrVal = SysAllocString( pPolicyHunt->GetResultFilename());
                    return pVarResult->bstrVal ? S_OK : E_UNEXPECTED;
                case POLICYHUNT_NOTFOUND:
                    szResultHtm = L"policynone.htm";
                    break;
                case POLICYHUNT_INPROGRESS:
                    szResultHtm = L"policylooking.htm";
                    break;
                case POLICYHUNT_FORMATERROR:
                    szResultHtm = L"policysyntaxerror.htm";
                    break;
                case POLICYHUNT_ERROR:
                case POLICYHUNT_CANCELLED:
                    szResultHtm = L"policyerror.htm";
                    break;
                }
            }
            else
            {
                szResultHtm = L"policyerror.htm";
            }
            
            WCHAR   szResURL[MAX_URL_STRING];
               
            hr = MLBuildResURLWrap(L"shdoclc.dll",
                               HINST_THISDLL,
                               ML_CROSSCODEPAGE,
                               szResultHtm,
                               szResURL,
                               ARRAYSIZE(szResURL),
                               L"shdocvw.dll");

            if( FAILED(hr))
                return E_UNEXPECTED;

            pVarResult->bstrVal = SysAllocString( szResURL);
            return S_OK;
        }
    case DISPID_CREATEABSOLUTEURL:
        {
            WCHAR szBuffer[ MAX_URL_STRING];
            DWORD dwBufferSize = ARRAYSIZE( szBuffer);
            pVarResult->bstrVal = NULL;
            
            if( pDispParams == NULL)
            {
                return E_UNEXPECTED;
            }

            if( pDispParams->rgvarg[0].vt != VT_BSTR
                || pDispParams->rgvarg[0].bstrVal == NULL)
            {
                //  when pVarResult->bstrVal == NULL and we return S_OK,
                //    we are returning an empty string.
                return S_OK;
            }

            HRESULT hr = UrlCombine( pPolicyHunt->GetPolicyUrl(),
                                     pDispParams->rgvarg[0].bstrVal,
                                     szBuffer, &dwBufferSize,
                                     URL_ESCAPE_UNSAFE );

            if( hr != S_OK)
                return E_UNEXPECTED;

            pVarResult->bstrVal = SysAllocString( szBuffer);
            if( pVarResult->bstrVal == NULL)
                return E_UNEXPECTED;
            else
                return S_OK;
                                     
        }
    }
    return S_OK;
}

//
// Privacy record implementation
//
HRESULT CPrivacyRecord::Init( LPTSTR * ppszUrl, LPTSTR * ppszPolicyRef, LPTSTR * ppszP3PHeader, 
                              DWORD dwFlags)
{
    unsigned long     len = 0;
    TCHAR           * pUrl = NULL;

    if (!ppszUrl || !*ppszUrl || !**ppszUrl || !ppszP3PHeader || !ppszPolicyRef )
        return E_POINTER;

    _pszUrl = *ppszUrl;    
    _pszP3PHeader = *ppszP3PHeader;
    _pszPolicyRefUrl = *ppszPolicyRef;

    // The record will own the memory from now for these
    *ppszUrl = NULL;
    *ppszP3PHeader = NULL;
    *ppszPolicyRef = NULL;

    _dwPrivacyFlags = dwFlags;

    return S_OK;
}

CPrivacyRecord::~CPrivacyRecord()
{
    delete [] _pszUrl;
    delete [] _pszPolicyRefUrl;
    delete [] _pszP3PHeader;
}

HRESULT CPrivacyRecord::SetNext( CPrivacyRecord *  pNextRec )
{
    if (!pNextRec)
        return E_POINTER;

    _pNextNode = pNextRec;
    return S_OK;
}

//
// Privacy queue implementation
//
CPrivacyQueue::~CPrivacyQueue()
{
    Reset();
}

void CPrivacyQueue::Reset()
{
    while (_pHeadRec)
    {
        delete Dequeue();
    }
}

void CPrivacyQueue::Queue(CPrivacyRecord *pRecord)
{
    ASSERT(pRecord);

    if (!_ulSize)
    {   
        _pHeadRec = _pTailRec = pRecord;
    }
    else
    {
        ASSERT(_pTailRec);
        _pTailRec->SetNext(pRecord);
        _pTailRec = pRecord;
    }
    _ulSize++;
}

CPrivacyRecord* CPrivacyQueue::Dequeue()
{
    CPrivacyRecord *headRec = NULL;

    if (_ulSize)
    {
        ASSERT(_pHeadRec);
        headRec = _pHeadRec;
        _pHeadRec = headRec->GetNext();
        --_ulSize;
    }

    return headRec;
}

////////////////////////////////////////////////////////////////////////////////////
//
// One time privacy discovery dialog proc
//
////////////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK PrivacyDiscoveryDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fDontShowNextTime = FALSE;
    WCHAR       szBuffer[256];

    switch (message)
    {
        case WM_INITDIALOG:
            {
                CheckDlgButton( hDlg, IDC_PRIV_DISCOVER_DONTSHOW, BST_CHECKED);
                MLLoadStringW(IDS_PRIVACY_LEARNMOREABOUTCOOKIES, szBuffer, ARRAYSIZE(szBuffer));
                RenderStringToEditControlW(hDlg,
                                           szBuffer,
                                           (WNDPROC)HyperlinkSubclass,
                                           IDC_PRIVACY_HELP);

                if( IsOS(OS_WHISTLERORGREATER))
                {
                    HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                    if( hIcon != NULL)
                        SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                    // icons loaded with LoadIcon never need to be released
                }
            
                return TRUE;
            }
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    if(IsDlgButtonChecked(hDlg, IDC_PRIV_DISCOVER_DONTSHOW))
                        fDontShowNextTime = TRUE;
                    else
                        fDontShowNextTime = FALSE;

                    // fall through
                case IDCANCEL:

                    EndDialog(hDlg, fDontShowNextTime);
                    return 0;
                case IDC_SETTINGS:
                    LaunchPrivacySettings(hDlg);
                    return 0;
            }
            break;
        case WM_APP:
            switch( LOWORD( wParam))
            {
                case IDC_PRIVACY_HELP:
                    SHHtmlHelpOnDemandWrap(hDlg, TEXT("iexplore.chm > iedefault"), 
                        HH_DISPLAY_TOPIC, (DWORD_PTR) L"sec_cook.htm", ML_CROSSCODEPAGE);
   
            }
    }

    return FALSE;
}


//  returns boolean indicating if dialog should be shown again.
BOOL DoPrivacyFirstTimeDialog( HWND hwndParent)
{
    HINSTANCE hRichEditDll;
    BOOL returnValue;

    // We need to load richedit
    hRichEditDll = LoadLibrary(TEXT("RICHED20.DLL"));
    if (!hRichEditDll)
    {
        ASSERT(FALSE); //can't load richedit, complain to akabir
        return TRUE;
    }

    returnValue = (BOOL)SHFusionDialogBoxParam(MLGetHinst(),
                                               MAKEINTRESOURCE(IDD_PRIV_DISCOVER),
                                               hwndParent,
                                               (DLGPROC)PrivacyDiscoveryDlgProc,
                                               NULL);

    FreeLibrary( hRichEditDll);

    return returnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\propstg.c ===
/*
 * propstg.c - Property storage ADT 
 */


#include "priv.h"
#include "propstg.h"

#ifndef UNIX
// SafeGetItemObject
//
// Since the GetItemObject member of IShellView was added late in the game
// during Win95 development we have found at least one example (rnaui.dll)
// of an application that built an IShellView with a NULL member for
// GetItemObject.  Fearing more applications that may have the same
// problem, this wrapper function was added to catch bad apps like rnaui.
// Thus, we check here for NULL before calling the member.
//
STDAPI SafeGetItemObject(LPSHELLVIEW psv, UINT uItem, REFIID riid, LPVOID *ppv)
{
#ifdef __cplusplus
#error THIS_MUST_STAY_C
    // read the comment above
#endif
    if (!psv->lpVtbl->GetItemObject)
        return E_FAIL;

    return (HRESULT)(psv->lpVtbl->GetItemObject(psv, uItem, riid, ppv));
}
#endif


// This structure is a dictionary element. It maps a name to a propid.  

typedef struct
{
    PROPID  propid;
    WCHAR   wszName[MAX_PATH];
} DICTEL, * PDICTEL;


// This structure is a propvariant element.
typedef struct
{
    PROPVARIANT propvar;
    DWORD       dwFlags;        // PEF_*
} PROPEL, * PPROPEL;

// Flags for PROPEL structure
#define PEF_VALID           0x00000001
#define PEF_DIRTY           0x00000002

// This structure is the ADT for property storage

typedef struct
{
    DWORD   cbSize;
    DWORD   dwFlags;
    HDSA    hdsaProps;          // array of properties (indexed by propid) 
    HDPA    hdpaDict;           // dictionary of names mapped to propid 
    //  (each element is a DICTEL) 
    int     idsaLastValid;
} PROPSTG, * PPROPSTG;


// The first two entries in hdsaProps are reserved.  When we enumerate
// thru the list, we skip these entries.
#define PROPID_DICT     0
#define PROPID_CODEPAGE 1

#define IDSA_START      2
#define CDSA_RESERVED   2

BOOL IsValidHPROPSTG(HPROPSTG hstg)
{
    PPROPSTG pstg = (PPROPSTG)hstg;
    
    return (IS_VALID_WRITE_PTR(pstg, PROPSTG) &&
        SIZEOF(*pstg) == pstg->cbSize && 
        NULL != pstg->hdsaProps &&
        NULL != pstg->hdpaDict);
}

#ifdef DEBUG
BOOL IsValidPPROPSPEC(PROPSPEC * ppropspec)
{
    return (ppropspec &&
        PRSPEC_PROPID == ppropspec->ulKind ||
        (PRSPEC_LPWSTR == ppropspec->ulKind && 
        IS_VALID_STRING_PTRW(ppropspec->DUMMYUNION_MEMBER(lpwstr), -1)));
}
#endif

STDAPI PropStg_Create(OUT HPROPSTG * phstg, IN  DWORD dwFlags)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_WRITE_PTR(phstg, HPROPSTG)))
    {
        PPROPSTG pstg = (PPROPSTG)LocalAlloc(LPTR, SIZEOF(*pstg));
        
        hres = STG_E_INSUFFICIENTMEMORY;       // assume error 
        
        if (pstg) 
        {
            pstg->cbSize = SIZEOF(*pstg);
            pstg->dwFlags = dwFlags;
            pstg->idsaLastValid = PROPID_CODEPAGE;
            
            pstg->hdsaProps = DSA_Create(SIZEOF(PROPEL), 8);
            pstg->hdpaDict = DPA_Create(8);
            
            if (pstg->hdsaProps && pstg->hdpaDict)
            {
                // The first two propids are reserved, so insert
                // placeholders.
                PROPEL propel;
                
                propel.propvar.vt = VT_EMPTY;
                propel.dwFlags = 0;
                
                DSA_SetItem(pstg->hdsaProps, PROPID_DICT, &propel);
                DSA_SetItem(pstg->hdsaProps, PROPID_CODEPAGE, &propel);
                
                hres = S_OK;
            }
            else
            {
                // Clean up because something failed 
                if (pstg->hdsaProps)
                {
                    DSA_Destroy(pstg->hdsaProps);
                    pstg->hdsaProps = NULL;
                }
                
                if (pstg->hdpaDict)
                {
                    DPA_Destroy(pstg->hdpaDict);
                    pstg->hdpaDict = NULL;
                }
                
                LocalFree(pstg);
                pstg = NULL;
            }
        }
        
        *phstg = (HPROPSTG)pstg;
        
        // Validate return values
        ASSERT((SUCCEEDED(hres) && 
            IS_VALID_WRITE_PTR(*phstg, PPROPSTG)) ||
            (FAILED(hres) && NULL == *phstg));
    }
    
    return hres;
}


STDAPI PropStg_Destroy(HPROPSTG hstg)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        
        if (pstg->hdsaProps)
        {
            int cdsa = DSA_GetItemCount(pstg->hdsaProps) - CDSA_RESERVED;
            
            // The first two elements are not cleared, because they
            // are just place-holders.
            
            if (0 < cdsa)
            {
                PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, IDSA_START);
                
                ASSERT(ppropel);
                
                while (0 < cdsa--)
                {
                    PropVariantClear(&ppropel->propvar);
                    ppropel++;
                }
            }
            
            DSA_Destroy(pstg->hdsaProps);
            pstg->hdsaProps = NULL;
        }
        
        if (pstg->hdpaDict)
        {
            int i, cel = DPA_GetPtrCount(pstg->hdpaDict);
            for (i = 0; i < cel; i++)
            {
                LocalFree(DPA_FastGetPtr(pstg->hdpaDict, i));
            }
            DPA_Destroy(pstg->hdpaDict);
            pstg->hdpaDict = NULL;
        }
        
        LocalFree(pstg);
        pstg = NULL;
        
        hres = S_OK;
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Compare names

Returns: standard -1, 0, 1
Cond:    --
*/
int CALLBACK PropStg_Compare(IN LPVOID pv1, IN LPVOID pv2, IN LPARAM lParam)
{
    LPCWSTR psz1 = pv1;
    LPCWSTR psz2 = pv2;
    
    // Case insensitive 
    return StrCmpW(psz1, psz2);
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the property exists in this storage.
         If it does exist, the propid is returned.

Returns: TRUE 
         FALSE 

Cond:    --
*/
BOOL PropStg_PropertyExists(IN  PPROPSTG   pstg,
                            IN  const PROPSPEC * ppropspec,
                            OUT PROPID *   ppropid)
{
    BOOL bRet;
    PPROPEL ppropel;
    HDSA hdsaProps;
    
    ASSERT(pstg);
    ASSERT(ppropspec);
    ASSERT(ppropid);
    
    hdsaProps = pstg->hdsaProps;
    
    switch (ppropspec->ulKind)
    {
    case PRSPEC_PROPID:
        *ppropid = ppropspec->DUMMYUNION_MEMBER(propid);
        
        bRet = (*ppropid < (PROPID)DSA_GetItemCount(hdsaProps));
        if (bRet)
        {
            ppropel = DSA_GetItemPtr(hdsaProps, *ppropid);
            bRet = (ppropel && IsFlagSet(ppropel->dwFlags, PEF_VALID));
        }
        break;
        
    case PRSPEC_LPWSTR:
        // Key off whether the name exists 
        *ppropid = DPA_Search(pstg->hdpaDict, ppropspec->DUMMYUNION_MEMBER(lpwstr), 0, PropStg_Compare, 0, DPAS_SORTED);
        
#ifdef DEBUG
        // Sanity check that the property actually exists
        ppropel = DSA_GetItemPtr(hdsaProps, *ppropid);
        ASSERT(-1 == *ppropid ||
            (ppropel && IsFlagSet(ppropel->dwFlags, PEF_VALID)));
#endif
        
        bRet = (-1 != *ppropid);
        break;
        
    default:
        bRet = FALSE;
        break;
    }
    
    // Propid values 0 and 1 are reserved, as are values >= 0x80000000 
    if (bRet && (0 == *ppropid || 1 == *ppropid || 0x80000000 <= *ppropid))
        bRet = FALSE;
    
    return bRet;
}


/*----------------------------------------------------------
Purpose: Create a new propid and assign the given name to
         it.  

         The propid is an index into hdsaProps.

Returns: S_OK
         STG_E_INSUFFICIENTMEMORY

Cond:    --
*/
HRESULT PropStg_NewPropid(IN  PPROPSTG pstg,
                          IN  LPCWSTR  pwsz,
                          IN  PROPID   propidFirst,
                          OUT PROPID * ppropid)           OPTIONAL
{
    HRESULT hres = STG_E_INVALIDPOINTER;        // assume error
    DICTEL * pdictel;
    PROPID propid = (PROPID)-1;
    HDPA hdpa;
    
    ASSERT(pstg);
    ASSERT(ppropid);
    
    if (EVAL(IS_VALID_STRING_PTRW(pwsz, -1)))
    {
        hres = STG_E_INSUFFICIENTMEMORY;            // assume error
        
        hdpa = pstg->hdpaDict;
        
        // The name shouldn't be in the list yet 
        ASSERT(-1 == DPA_Search(hdpa, (LPVOID)pwsz, 0, PropStg_Compare, 0, DPAS_SORTED));
        
        pdictel = LocalAlloc(LPTR, SIZEOF(*pdictel));
        if (pdictel)
        {
            // Determine the propid for this 
            PROPID propidNew = max(propidFirst, (PROPID)pstg->idsaLastValid + 1);
            
            pdictel->propid = propidNew;
            
            StrCpyNW(pdictel->wszName, pwsz, ARRAYSIZE(pdictel->wszName));
            
            if (-1 != DPA_AppendPtr(hdpa, pdictel))
            {
                // Sort it by name
                DPA_Sort(hdpa, PropStg_Compare, 0);
                hres = S_OK;
                propid = propidNew;
            }
        }
    }
    
    *ppropid = propid;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read a set of properties given their propids.  If the propid 
         doesn't exist in this property storage, then set the
         value type to VT_EMPTY but return success; unless
         all the properties in rgpropspec don't exist, in which
         case also return S_FALSE.  

Returns: S_OK
         S_FALSE
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_ReadMultiple(IN HPROPSTG      hstg,
                            IN ULONG         cpspec,
                            IN const PROPSPEC * rgpropspec,
                            IN PROPVARIANT * rgpropvar)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropspec, PROPSPEC, cpspec)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropvar, PROPVARIANT, cpspec)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        ULONG cpspecSav = cpspec;
        const PROPSPEC * ppropspec = rgpropspec;
        PROPVARIANT * ppropvar = rgpropvar;
        int idsa;
        BOOL bPropertyExists;
        ULONG cpspecIllegal = 0;
        
        hres = S_OK;        // assume success
        
        if (0 < cpspec)
        {
            // Read the list of property specs 
            while (0 < cpspec--)
            {
                bPropertyExists = PropStg_PropertyExists(pstg, ppropspec, (LPDWORD)&idsa);
                
                // Does this property exist? 
                if ( !bPropertyExists )
                {
                    // No
                    ppropvar->vt = VT_ILLEGAL;
                    cpspecIllegal++;
                }
                else
                {
                    // Yes; is the element a valid property? 
                    PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, idsa);
                    
                    ASSERT(ppropel);
                    
                    if (IsFlagSet(ppropel->dwFlags, PEF_VALID))
                    {
                        // Yes; copy the variant value
                        hres = PropVariantCopy(ppropvar, &ppropel->propvar);
                    }
                    else
                    {
                        // No
                        ppropvar->vt = VT_ILLEGAL;
                        cpspecIllegal++;
                    }
                }
                
                ppropspec++;
                ppropvar++;
                
                //  Bail out of loop if something failed 
                if (FAILED(hres))
                    break;
            }
            
            // Are all the property specs illegal? 
            if (cpspecIllegal == cpspecSav)
            {
                hres = S_FALSE;     // yes
            }
            
            // Did anything fail above?
            if (FAILED(hres))
            {
                // Yes; clean up -- no properties will be retrieved 
                FreePropVariantArray(cpspecSav, rgpropvar);
            }
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Add a set of property values given their propids.  
         If the propid doesn't exist in this property storage, 
         then add the propid as a legal ID and set the value. 

         On error, some properties may or may not have been 
         written.

         If pfn is non-NULL, this callback will get called
         to optionally "massage" the propvariant value or to
         validate it.  The rules for the callback are:

            1)  It can change the value directly if it is not
                allocated

            2)  If the value is allocated, the callback must 
                replace the pointer with a newly allocated 
                buffer that it allocates.  It must not try
                to free the value coming in, since it doesn't
                know how it was allocated.  It must also use
                CoTaskMemAlloc to allocate its buffer. 

            3)  If the callback returns an error, this function
                will stop writing properties and return that
                error.

            4)  If the callback returns S_FALSE, this function
                will not write that particular property and 
                continue on to the next property.  The function
                then returns S_FALSE once it is finished.

Returns: S_OK
         S_FALSE
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_WriteMultipleEx(IN HPROPSTG          hstg,
                               IN ULONG             cpspec,
                               IN const PROPSPEC *  rgpropspec,
                               IN const PROPVARIANT * rgpropvar,
                               IN PROPID            propidFirst,   OPTIONAL
                               IN PFNPROPVARMASSAGE pfn,           OPTIONAL
                               IN LPARAM            lParam)        OPTIONAL
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropspec, PROPSPEC, cpspec)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropvar, PROPVARIANT, cpspec)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        const PROPSPEC * ppropspec = rgpropspec;
        const PROPVARIANT * ppropvar = rgpropvar;
        int idsa;
        PROPEL propel;
        BOOL bPropertyExists;
        BOOL bSkippedProperty = FALSE;
        
        if (0 == cpspec)
        {
            hres = S_OK;
        }
        else
        {
            // Write the list of property specs 
            while (0 < cpspec--)
            {
                bPropertyExists = PropStg_PropertyExists(pstg, ppropspec, (LPDWORD)&idsa);
                
                hres = S_OK;
                
                // If this is an illegal variant type and yet a valid 
                // property, then return an error.  Otherwise, ignore it
                // and move on.
                if (VT_ILLEGAL == ppropvar->vt)
                {
                    if (bPropertyExists)
                        hres = STG_E_INVALIDPARAMETER;
                    else
                        goto NextDude;
                }
                
                if (SUCCEEDED(hres))
                {
                    // Add the property.  If it doesn't exist, add it.
                    
                    // Is this a propid or a name? 
                    switch (ppropspec->ulKind)
                    {
                    case PRSPEC_PROPID:
                        idsa = ppropspec->DUMMYUNION_MEMBER(propid);
                        break;
                        
                    case PRSPEC_LPWSTR:
                        if ( !bPropertyExists )
                        {
                            hres = PropStg_NewPropid(pstg, ppropspec->DUMMYUNION_MEMBER(lpwstr), 
                                propidFirst, (LPDWORD)&idsa);
                        }
                        break;
                        
                    default:
                        hres = STG_E_INVALIDNAME;
                        break;
                    }
                    
                    if (SUCCEEDED(hres))
                    {
                        PROPVARIANT propvarT;
                        
                        ASSERT(S_OK == hres);   // we're assuming this on entry 
                        
                        // Save a copy of the original in case the
                        // callback changes it.
                        CopyMemory(&propvarT, ppropvar, SIZEOF(propvarT));
                        
                        // How did the callback like it? 
                        if (pfn)
                            hres = pfn(idsa, ppropvar, lParam);
                        
                        if (S_OK == hres)
                        {
                            // Fine; make a copy of the (possibly changed)
                            // propvariant value
                            hres = PropVariantCopy(&propel.propvar, ppropvar);
                            if (SUCCEEDED(hres))
                            {
                                propel.dwFlags = PEF_VALID | PEF_DIRTY;
                                
                                hres = (DSA_SetItem(pstg->hdsaProps, idsa, &propel) ? S_OK : STG_E_INSUFFICIENTMEMORY);
                                
                                if (SUCCEEDED(hres) && idsa > pstg->idsaLastValid)
                                {
                                    pstg->idsaLastValid = idsa;
                                }
                            }
                        }
                        else if (S_FALSE == hres)
                        {
                            bSkippedProperty = TRUE;
                        }
                        
                        // Restore the propvariant value to its original
                        // value. But first, did the callback allocate a
                        // new buffer? 
                        if (propvarT.DUMMYUNION_MEMBER(pszVal) != ppropvar->DUMMYUNION_MEMBER(pszVal))
                        {
                            // Yes; clear it (this function is safe for
                            // non-allocated values too).
                            PropVariantClear((PROPVARIANT *)ppropvar);
                        }
                        
                        // Restore
                        CopyMemory((PROPVARIANT *)ppropvar, &propvarT, SIZEOF(*ppropvar));
                        hres = S_OK;
                    }
                }
                
NextDude:
                ppropspec++;
                ppropvar++;
                
                //  Bail out of loop if something failed 
                if (FAILED(hres))
                    break;
            }
            
            if (bSkippedProperty)
                hres = S_FALSE;
            }
        }
        
        return hres;
    }
    

/*
Purpose: Add a set of property values given their propids.  
         If the propid doesn't exist in this property storage, 
         then add the propid as a legal ID and set the value. 

         On error, some properties may or may not have been 
         written.

Returns: S_OK
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

*/
STDAPI PropStg_WriteMultiple(IN HPROPSTG      hstg,
                             IN ULONG         cpspec,
                             IN const PROPSPEC * rgpropspec,
                             IN const PROPVARIANT * rgpropvar,
                             IN PROPID        propidFirst)      OPTIONAL
{
    return PropStg_WriteMultipleEx(hstg, cpspec, rgpropspec, rgpropvar,
        propidFirst, NULL, 0);
}

STDAPI PropStg_DeleteMultiple(IN HPROPSTG      hstg,
                              IN ULONG         cpspec,
                              IN const PROPSPEC * rgpropspec)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropspec, PROPSPEC, cpspec)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        const PROPSPEC * ppropspec = rgpropspec;
        HDSA hdsaProps = pstg->hdsaProps;
        PPROPEL ppropel;
        int idsa;
        int cdsa;
        
        hres = S_OK;
        
        if (0 < cpspec)
        {
            BOOL bDeletedLastValid = FALSE;
            
            // Delete the list of property specs
            while (0 < cpspec--)
            {
                if (PropStg_PropertyExists(pstg, ppropspec, (LPDWORD)&idsa))
                {
                    // Delete the property.  Zero out the existing
                    // propel.  Don't call DSA_DeleteItem, otherwise
                    // we'll move the positions of any remaining
                    // properties following this one, thus changing their
                    // propids.
                    ppropel = DSA_GetItemPtr(hdsaProps, idsa);
                    ASSERT(ppropel);
                    
                    PropVariantClear(&ppropel->propvar);
                    ppropel->dwFlags = 0;
                    
                    // Our idsaLastValid is messed up if we hit this
                    // assert
                    ASSERT(idsa <= pstg->idsaLastValid);
                    
                    if (idsa == pstg->idsaLastValid)
                        bDeletedLastValid = TRUE;
                    
                    // Delete the names associated with the property 
                    // FEATURE (scotth): implement this
                }
                
                ppropspec++;
            }
            
            // Did we delete the property that was marked as the terminating
            // valid property in the list? 
            if (bDeletedLastValid)
            {
                // Yes; go back and search for the new terminating index 
                ppropel = DSA_GetItemPtr(hdsaProps, pstg->idsaLastValid);
                cdsa = pstg->idsaLastValid + 1 - CDSA_RESERVED;
                ASSERT(ppropel);
                
                while (0 < cdsa--)
                {
                    if (IsFlagSet(ppropel->dwFlags, PEF_VALID))
                    {
                        pstg->idsaLastValid = cdsa - 1;
                        break;
                    }
                    ppropel--;
                }
                
                if (0 == cdsa)
                    pstg->idsaLastValid = PROPID_CODEPAGE;
            }
            
            // Since we didn't delete any items from hdsaProps (we freed 
            // the variant value and zeroed it out), this structure 
            // may have a bunch of unused elements at the end.  
            // Compact now if necessary.
            
            // Do we have a bunch of trailing, empty elements? 
            cdsa = DSA_GetItemCount(hdsaProps);
            
            if (cdsa > pstg->idsaLastValid + 1)
            {
                // Yes; compact.  Start from the end and go backwards
                // so DSA_DeleteItem doesn't have to move memory blocks.
                for (idsa = cdsa-1; idsa > pstg->idsaLastValid; idsa--)
                {
#ifdef DEBUG
                    ppropel = DSA_GetItemPtr(hdsaProps, idsa);
                    ASSERT(IsFlagClear(ppropel->dwFlags, PEF_VALID));
#endif
                    DSA_DeleteItem(hdsaProps, idsa);
                }
            }
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Marks the specified properties dirty or undirty, depending
         on the value of bDirty.  
         
Returns: S_OK
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_DirtyMultiple(IN HPROPSTG    hstg,
                             IN ULONG       cpspec,
                             IN const PROPSPEC * rgpropspec,
                             IN BOOL        bDirty)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_READ_BUFFER(rgpropspec, PROPSPEC, cpspec)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        const PROPSPEC * ppropspec = rgpropspec;
        HDSA hdsaProps = pstg->hdsaProps;
        PPROPEL ppropel;
        int idsa;
        
        hres = S_OK;
        
        if (0 < cpspec)
        {
            // Mark the list of property specs
            while (0 < cpspec--)
            {
                // Does it exist?
                if (PropStg_PropertyExists(pstg, ppropspec, (LPDWORD)&idsa))
                {
                    // Yes; mark it
                    ppropel = DSA_GetItemPtr(hdsaProps, idsa);
                    ASSERT(ppropel);
                    
                    if (bDirty)
                    {
                        SetFlag(ppropel->dwFlags, PEF_DIRTY);
                    }
                    else
                    {
                        ClearFlag(ppropel->dwFlags, PEF_DIRTY);
                    }
                }
                
                ppropspec++;
            }
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Marks or unmarks all the property values.
         
Returns: S_OK
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_DirtyAll(IN HPROPSTG hstg,
                        IN BOOL     bDirty)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        int cdsa = pstg->idsaLastValid + 1 - CDSA_RESERVED;
        
        hres = S_OK;
        
        if (0 < cdsa)
        {
            PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, IDSA_START);
            
            ASSERT(ppropel);
            
            while (0 < cdsa--)
            {
                if (bDirty)
                    SetFlag(ppropel->dwFlags, PEF_DIRTY);
                else
                    ClearFlag(ppropel->dwFlags, PEF_DIRTY);
                ppropel++;
            }
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Returns S_OK if at least one property value is dirty
         in the storage.  Otherwise, this function returns 
         S_FALSE.
         
Returns: S_OK if it is dirty
         S_FALSE if not
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_IsDirty(HPROPSTG hstg)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        int cdsa = pstg->idsaLastValid + 1 - CDSA_RESERVED;
        
        hres = S_FALSE;
        
        if (0 < cdsa)
        {
            PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, IDSA_START);
            
            ASSERT(ppropel);
            
            while (0 < cdsa--)
            {
                if (IsFlagSet(ppropel->dwFlags, PEF_DIRTY))
                {
                    hres = S_OK;
                    break;
                }
                ppropel++;
            }
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Enumerates thru the list of properties.
         
Returns: S_OK
         STG_E_INVALIDPARAMETER 
         STG_E_INSUFFICIENTMEMORY 

Cond:    --
*/
STDAPI PropStg_Enum(IN HPROPSTG       hstg,
                    IN DWORD          dwFlags,      // One of PSTGEF_ 
                    IN PFNPROPSTGENUM pfnEnum,
                    IN LPARAM         lParam)       OPTIONAL
{
    HRESULT hres = STG_E_INVALIDPARAMETER;
    
    if (EVAL(IS_VALID_HANDLE(hstg, PROPSTG)) &&
        EVAL(IS_VALID_CODE_PTR(pfnEnum, PFNPROPSTGENUM)))
    {
        PPROPSTG pstg = (PPROPSTG)hstg;
        int cdsa = pstg->idsaLastValid + 1 - CDSA_RESERVED;
        DWORD dwFlagsPEF = 0;
        
        hres = S_OK;
        
        // Set the filter flags
        if (dwFlags & PSTGEF_DIRTY)
            SetFlag(dwFlagsPEF, PEF_DIRTY);
        
        if (0 < cdsa)
        {
            PPROPEL ppropel = DSA_GetItemPtr(pstg->hdsaProps, IDSA_START);
            int idsa = IDSA_START;
            
            ASSERT(ppropel);
            
            while (0 < cdsa--)
            {
                // Does it pass thru filter? 
                if (IsFlagSet(ppropel->dwFlags, PEF_VALID) &&
                    (0 == dwFlagsPEF || (dwFlagsPEF & ppropel->dwFlags)))
                {
                    // Yes, call callback
                    HRESULT hresT = pfnEnum(idsa, &ppropel->propvar, lParam);
                    if (S_OK != hresT)
                    {
                        if (FAILED(hresT))
                            hres = hresT;
                        break;      // stop enumeration
                    }
                }
                ppropel++;
                idsa++;
            }
        }
    }
    
    return hres;
}


#ifdef DEBUG

HRESULT CALLBACK PropStg_DumpVar(IN PROPID        propid,
                                 IN PROPVARIANT * ppropvar,
                                 IN LPARAM        lParam)
{
    TCHAR sz[MAX_PATH];
    PPROPEL ppropel = (PPROPEL)ppropvar;        // we're cheating here
    
    if (IsFlagSet(ppropel->dwFlags, PEF_DIRTY))
        wnsprintf(sz, ARRAYSIZE(sz), TEXT("    *id:%#lx\t%s"), propid, Dbg_GetVTName(ppropvar->vt));
    else
        wnsprintf(sz, ARRAYSIZE(sz), TEXT("     id:%#lx\t%s"), propid, Dbg_GetVTName(ppropvar->vt));
    
    
    switch (ppropvar->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:
        TraceMsg(TF_ALWAYS, "     %s", sz);
        break;
        
    case VT_I2:
    case VT_I4:
        TraceMsg(TF_ALWAYS, "     %s\t%d", sz, ppropvar->DUMMYUNION_MEMBER(lVal));
        break;
        
    case VT_UI1:
        TraceMsg(TF_ALWAYS, "     %s\t%#02x '%c'", sz, ppropvar->DUMMYUNION_MEMBER(bVal), ppropvar->DUMMYUNION_MEMBER(bVal));
        break;
    case VT_UI2:
        TraceMsg(TF_ALWAYS, "     %s\t%#04x", sz, ppropvar->DUMMYUNION_MEMBER(uiVal));
        break;
    case VT_UI4:
        TraceMsg(TF_ALWAYS, "     %s\t%#08x", sz, ppropvar->DUMMYUNION_MEMBER(ulVal));
        break;
        
    case VT_LPSTR:
        TraceMsg(TF_ALWAYS, "     %s\t\"%S\"", sz, Dbg_SafeStrA(ppropvar->DUMMYUNION_MEMBER(pszVal)));
        break;
    case VT_LPWSTR:
        TraceMsg(TF_ALWAYS, "     %s\t\"%ls\"", sz, Dbg_SafeStrW(ppropvar->DUMMYUNION_MEMBER(pwszVal)));
        break;
        
    default:
#if defined(_WIN64)
        TraceMsg(TF_ALWAYS, "     %s\t0x%p", sz, (DWORD_PTR)ppropvar->DUMMYUNION_MEMBER(pszVal)); 
#else
        TraceMsg(TF_ALWAYS, "     s\t%#08lx", sz, (DWORD)ppropvar->DUMMYUNION_MEMBER(pszVal));
#endif
        
        break;
    }
    return S_OK;
}

STDAPI PropStg_Dump(IN HPROPSTG       hstg,
                    IN DWORD          dwFlags)      // One of PSTGDF_ 
{
    TraceMsg(TF_ALWAYS, "  Property storage 0x%08lx = {", hstg);
    
    PropStg_Enum(hstg, 0, PropStg_DumpVar, 0);
    
    TraceMsg(TF_ALWAYS, "  }");
    
    return NOERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\privacyui.hpp ===
#ifndef _PRIVACYUI_HPP_
#define _PRIVACYUI_HPP_
// 
//  PrivacyUI.hpp
//
//  Privacy implementation classes and functions
//

// Forward Declarations
class CDocObjectHost;
class CDOHBindStatusCallback;

// Function to initiate privacy dialog.. implemented in privacyui.cpp
// Publicly exported through the .w files
HRESULT
DoPrivacyDlg(
    HWND                hwndParent,             // parent window
    LPOLESTR            pszUrl,                 // base URL
    IEnumPrivacyRecords *pPrivacyEnum,          // enum of all affected dependant URLs
    BOOL                fReportAllSites         // show all or just show sites with privacy impact
    );

// Used during binding to keep track of the privacy data coming in through
// urlmon notifications

class CPrivacyRecord
{
public:
    // Data Members
    TCHAR *       _pszUrl;
    TCHAR *       _pszPolicyRefUrl;
    TCHAR *       _pszP3PHeader;
    DWORD         _dwPrivacyFlags;    // contains the COOKIEACTION flags in the LOWORD and other 
                                      // PRIVACY flags (TopLevel, HasPolicy, Impacted) defined in mshtml.h
    CPrivacyRecord *    _pNextNode;         

    // Methods
    CPrivacyRecord() : _pszUrl(NULL), _pszPolicyRefUrl(NULL), _pszP3PHeader(NULL),
                       _dwPrivacyFlags(0), _pNextNode(NULL) {}
    ~CPrivacyRecord();

    HRESULT Init(LPTSTR * ppszUrl, LPTSTR * ppszPolicyRef, LPTSTR * ppszP3PHeader, DWORD dwFlags);

    HRESULT SetNext( CPrivacyRecord *  pNextRec );
    CPrivacyRecord * GetNext() { return _pNextNode; }
};


class CPrivacyQueue
{
public:
    CPrivacyQueue() : _pHeadRec(NULL), _pTailRec(NULL), _ulSize(0) {}
    ~CPrivacyQueue();

    void Queue(CPrivacyRecord *pRecord);
    CPrivacyRecord * Dequeue();
    
    void Reset();

private:
    CPrivacyRecord  *     _pHeadRec;      // Beginning of the list
    CPrivacyRecord  *     _pTailRec;      // Last record in the list. Need to keep track of this to ease addition
    ULONG                 _ulSize;        // Number of records in the list
};

#endif

// value to determine whether to show one time discovery ui or not
#define REGSTR_VAL_PRIVDISCOVER     TEXT("PrivDiscUiShown")

// discovery dlg proc
BOOL DoPrivacyFirstTimeDialog( HWND hwndParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\ratings.cpp ===
#include "priv.h"

#ifdef FEATURE_PICS

#include "asyncrat.h"
#include <ratings.h>
#include "dochost.h"
#include <mshtmdid.h>


/* There is a PicsQuery structure in the following global array for each
 * outstanding query.  It records the address of the PicsData structure in
 * the corresponding w3doc, the window handle corresponding to the Mwin,
 * and a serial number.  This way, RatingObtainQueryCallback can tell if
 * the page the query corresponds to still exists, before posting a message;
 * and PicsDataMessageLoop can tell if the doc still exists when the message
 * finally gets delivered.
 *
 * The array is dynamically allocated and is protected by the main HTML
 * critical section.
 */


HDSA g_haQueries = NULL;
DWORD g_dwPicsSerial = 1L;
const UINT c_cQueryAllocSize = 8;		/* should be plenty by default */
UINT g_crefQueries = 0;


/* AddPicsQuery - add an outstanding PICS query to the list, given a window
 * handle to send a completion message to.  Returns the serial number of the
 * query for later reference.
 */
DWORD _AddPicsQuery(HWND hwnd)
{
    ENTERCRITICAL;
    
    DWORD dwRet = 0;
    
    if (g_haQueries == NULL) {
        g_haQueries = DSA_Create(sizeof(PicsQuery), c_cQueryAllocSize);
    }
    
    if (g_haQueries != NULL) {
        PicsQuery q;
        
        q.dwSerial = ::g_dwPicsSerial++;
        q.hwnd = hwnd;
        q.lpvRatingDetails = NULL;
        
        if (DSA_InsertItem(g_haQueries, DA_LAST, &q) >= 0)
            dwRet = q.dwSerial;
    }
    
    LEAVECRITICAL;
    
    return dwRet;
}


/* RemovePicsQuery - remove an outstanding query based on its serial number.
*/
void _RemovePicsQuery(DWORD dwSerial)
{
    ENTERCRITICAL;
    
    if (g_haQueries != NULL) {
        UINT cQueries = DSA_GetItemCount(g_haQueries);
        PicsQuery *pq = NULL;
        for (UINT i=0; i<cQueries; i++) {
            pq = (PicsQuery *)DSA_GetItemPtr(g_haQueries, i);
            if (pq != NULL && pq->dwSerial == dwSerial)
                break;
        }
        
        if (pq != NULL) {
            if (pq->lpvRatingDetails != NULL)
                ::RatingFreeDetails(pq->lpvRatingDetails);
            DSA_DeleteItem(g_haQueries, i);
        }
    }
    
    LEAVECRITICAL;
}


/* GetPicsQuery - get a copy of an outstanding PICS query record, given its
 * serial number.  Returns TRUE if found.
 */
BOOL _GetPicsQuery(DWORD dwSerial, PicsQuery *pOut)
{
    ENTERCRITICAL;
    
    PicsQuery *pq = NULL;
    
    if (g_haQueries != NULL) {
        UINT cQueries = DSA_GetItemCount(g_haQueries);
        for (UINT i=0; i<cQueries; i++) {
            pq = (PicsQuery *)DSA_GetItemPtr(g_haQueries, i);
            if (pq != NULL && pq->dwSerial == dwSerial)
                break;
        }
        
        if (pq != NULL) {
            *pOut = *pq;
            pq->lpvRatingDetails = NULL;	/* caller's copy owns this now */
        }
    }
    
    LEAVECRITICAL;
    
    return pq != NULL;
}


/* _RefPicsQueries - add a reference to the async query array */
void _RefPicsQueries(void)
{
    ENTERCRITICAL;

    ++g_crefQueries;

    LEAVECRITICAL;
}


/* _ReleasePicsQueries - cleanup all memory associated with outstanding queries
 */
void _ReleasePicsQueries(void)
{
    ENTERCRITICAL;
    
    if (!--g_crefQueries) {
        if (g_haQueries != NULL) {
            UINT cQueries = DSA_GetItemCount(g_haQueries);
            for (UINT i=0; i<cQueries; i++) {
                PicsQuery *pq = (PicsQuery *)DSA_GetItemPtr(g_haQueries, i);
                if (pq != NULL && pq->lpvRatingDetails != NULL) {
                    RatingFreeDetails(pq->lpvRatingDetails);
                }
            }
            DSA_Destroy(g_haQueries);
            g_haQueries = NULL;
            // leave g_dwPicsSerial as it is, just in case we start up again
        }
    }
    
    LEAVECRITICAL;
}


/* PostPicsMessage - formats up a custom window message to signal that a
 * query is complete.  Format is WM_PICS_STATUS(hresult,dwSerial).  Other
 * information (the rating details blob obtained from RatingCheckUserAccess)
 * is stored in the query record for safekeeping.
 *
 * Returns TRUE if a message was posted successfully to the right window.
 */
BOOL _PostPicsMessage(DWORD dwSerial, HRESULT hr, LPVOID lpvRatingDetails)
{
    BOOL fRet = FALSE;
    
    ENTERCRITICAL;
    
    if (g_haQueries != NULL) {
        PicsQuery *pq = NULL;
        UINT cQueries = DSA_GetItemCount(g_haQueries);
        for (UINT i=0; i<cQueries; i++) {
            pq = (PicsQuery *)DSA_GetItemPtr(g_haQueries, i);
            if (pq != NULL && pq->dwSerial == dwSerial)
                break;
        }
        
        if (pq != NULL) {
            pq->lpvRatingDetails = lpvRatingDetails;
            fRet = PostMessage(pq->hwnd, WM_PICS_ASYNCCOMPLETE, (WPARAM)hr,
                (LPARAM)dwSerial);
            if (!fRet) {	/* oops, couldn't post message, don't keep copy of details */
                pq->lpvRatingDetails = NULL;
            }
        }
    }
    
    LEAVECRITICAL;
    
    return fRet;
}


/* Class CPicsRootDownload manages the download of the root document of a
 * site, to get ratings from it.
 */

CPicsRootDownload::CPicsRootDownload(IOleCommandTarget *pctParent, BOOL fFrameIsOffline, BOOL fFrameIsSilent)
{
    m_cRef = 1;
    m_pctParent = pctParent; m_pctParent->AddRef();
    m_pole = NULL;
    m_pctObject = NULL;
    m_pBinding = NULL;
    m_fFrameIsOffline = fFrameIsOffline ? TRUE : FALSE;
    m_fFrameIsSilent = fFrameIsSilent ? TRUE : FALSE;
}


CPicsRootDownload::~CPicsRootDownload()
{
    ATOMICRELEASE(m_pctParent);

    CleanUp();

    ATOMICRELEASE(m_pBinding);

    ATOMICRELEASE(m_pBindCtx);
}


HRESULT CPicsRootDownload::StartDownload(IMoniker *pmk)
{
    IUnknown *punk = NULL;
    HRESULT hr;

    hr = CreateBindCtx(0, &m_pBindCtx);
    if (FAILED(hr))
        goto LErrExit;

    /*
    hr = m_pBindCtx->RegisterObjectParam(BROWSER_OPTIONS_OBJECT_NAME,
                    (IBrowseControl *)this);
    if (FAILED(hr))
        goto LErrExit;
    */

    //
    //  Associate the client site as an object parameter to this
    // bind context so that Trident can pick it up while processing
    // IPersistMoniker::Load().
    //
    m_pBindCtx->RegisterObjectParam(WSZGUID_OPID_DocObjClientSite,
                                    SAFECAST(this, IOleClientSite*));

    hr = RegisterBindStatusCallback(m_pBindCtx,
            (IBindStatusCallback *)this,
            0,
            0L);
    if (FAILED(hr))
        goto LErrExit;

    hr = pmk->BindToObject(m_pBindCtx, NULL, IID_IUnknown, (LPVOID*)&punk);

    if (SUCCEEDED(hr) || hr==E_PENDING)
    {
        hr = S_OK;

        //
        // If moniker happen to return the object synchronously, emulate
        // OnDataAvailable callback and OnStopBinding.
        //
        if (punk)
        {
            OnObjectAvailable(IID_IUnknown, punk);
            OnStopBinding(hr, NULL);
            punk->Release();
        }
    }
    else
    {
        /* OnStopBinding can be called by URLMON within the BindToObject
         * call in some cases.  So, don't call it ourselves if it's
         * already been called (we can tell by looking whether our
         * bind context still exists).
         */
        if (m_pBindCtx != NULL) {
            OnStopBinding(hr, NULL);
        }
    }

LErrExit:
    if (FAILED(hr) && (m_pBindCtx != NULL)) {
        m_pBindCtx->Release();
        m_pBindCtx = NULL;
    }

    return hr;
}


/* _NotifyEndOfDocument is used in all the error cases to make sure the caller
 * gets a notification of some sort.  The case where this function does not
 * send a notification is if we have a valid OLE object -- in that case, we're
 * assuming that we have it because we know it supports PICS, therefore we're
 * expecting it to send such a notification to the parent itself.
 */
void CPicsRootDownload::_NotifyEndOfDocument(void)
{
    if (m_pole == NULL) {
        if (m_pctParent != NULL) {
            m_pctParent->Exec(&CGID_ShellDocView, SHDVID_NOMOREPICSLABELS, 0, NULL, NULL);
        }
    }
}


HRESULT CPicsRootDownload::_Abort()
{
    if (m_pBinding)
    {
        return m_pBinding->Abort();
    }
    return S_FALSE;
}


void CPicsRootDownload::CleanUp()
{
    _Abort();

    if (m_pctObject != NULL) {
        VARIANTARG v;
        v.vt = VT_UNKNOWN;
        v.punkVal = NULL;
        m_pctObject->Exec(&CGID_ShellDocView, SHDVID_CANSUPPORTPICS, 0, &v, NULL);
        m_pctObject->Exec(NULL, OLECMDID_STOP, NULL, NULL, NULL);
        ATOMICRELEASE(m_pctObject);
    }

    LPOLECLIENTSITE pcs;
    if (m_pole && SUCCEEDED(m_pole->GetClientSite(&pcs)) && pcs) 
    {
        if (pcs == SAFECAST(this, LPOLECLIENTSITE)) 
        {
            m_pole->SetClientSite(NULL);
        }
        pcs->Release();
    }

    ATOMICRELEASE(m_pole);
}


// IUnknown members
STDMETHODIMP CPicsRootDownload::QueryInterface(REFIID riid, void **punk)
{
    *punk = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IsPicsBrowser))
        *punk = (IUnknown *)(IBindStatusCallback *)this;
    else if (IsEqualIID(riid, IID_IBindStatusCallback))
        *punk = (IBindStatusCallback *)this;
    else if (IsEqualIID(riid, IID_IOleClientSite))
        *punk = (IOleClientSite *)this;
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *punk = (IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *punk = (IDispatch *)this;

    if (*punk != NULL) {
        ((IUnknown *)(*punk))->AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CPicsRootDownload::AddRef(void)
{
    ++m_cRef;
    TraceMsg(TF_SHDREF, "CPicsRootDownload(%x)::AddRef called, new m_cRef=%d", this, m_cRef);
    return m_cRef;
}


STDMETHODIMP_(ULONG) CPicsRootDownload::Release(void)
{
    UINT crefNew = --m_cRef;

    TraceMsg(TF_SHDREF, "CPicsRootDownload(%x)::Release called, new m_cRef=%d", this, m_cRef);

    if (!crefNew)
        delete this;

    return crefNew;
}

// IBindStatusCallback methods
STDMETHODIMP CPicsRootDownload::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    if (m_pBinding != NULL)
        m_pBinding->Release();

    m_pBinding = pbinding;

    if (m_pBinding != NULL)
        m_pBinding->AddRef();

    return S_OK;
}


STDMETHODIMP CPicsRootDownload::GetPriority(LONG* pnPriority)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPicsRootDownload::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                           ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
    /* If the root document's data type is not HTML, don't try to get any
     * ratings out of it, just abort.
     */
    if (ulStatusCode == BINDSTATUS_CLASSIDAVAILABLE) {
        BOOL fContinueDownload = FALSE;

        CLSID clsid;
        // CLSIDFromString is prototyped wrong, non const first param
        HRESULT hresT = CLSIDFromString((WCHAR *)pwzStatusText, &clsid);
        if (SUCCEEDED(hresT)) {
            LPWSTR pwzProgID = NULL;
            hresT = ProgIDFromCLSID(clsid, &pwzProgID);
            if (SUCCEEDED(hresT)) {
                if (StrCmp(pwzProgID, L"htmlfile") == 0)
                {
                    fContinueDownload = TRUE;
                }
                OleFree(pwzProgID);
            }
        }

        if (!fContinueDownload) {
            _Abort();
        }
    }

    return S_OK;
}


STDMETHODIMP CPicsRootDownload::OnStopBinding(HRESULT hrResult, LPCWSTR szError)
{
    /* Some of the cleanup we do in here (RevokeObjectParam is suspect?) could
     * remove our last reference, causing the Releases at the end to fault.
     * Guard against this with an AddRef/Release.  Dochost does this too.
     *
     * WARNING - if URLMON is calling back through this object, shouldn't he
     * have a reference to us?  If so, where is it?
     */
    AddRef();

    /* Notify the caller that we've got to the end of the document */
    _NotifyEndOfDocument();
    m_pBindCtx->RevokeObjectParam(WSZGUID_OPID_DocObjClientSite);
    ::RevokeBindStatusCallback(m_pBindCtx, (IBindStatusCallback *)this);
    ATOMICRELEASE(m_pBinding);
    ATOMICRELEASE(m_pBindCtx);

    /* Undo above AddRef(). */
    Release();

    return S_OK;
}

void SetBindfFlagsBasedOnAmbient(BOOL fAmbientOffline, DWORD *pgrfBindf);

STDMETHODIMP CPicsRootDownload::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    if ( !pgrfBINDF || !pbindInfo || !pbindInfo->cbSize )
        return E_INVALIDARG;

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE;
    *pgrfBINDF |= BINDF_GETNEWESTVERSION;

    if(m_fFrameIsSilent)
    {
        *pgrfBINDF |= BINDF_NO_UI;  
    }
    else
    {
        *pgrfBINDF &= ~BINDF_NO_UI;
    }

    SetBindfFlagsBasedOnAmbient(BOOLIFY(m_fFrameIsOffline), pgrfBINDF);
    
    // clear BINDINFO except cbSize
    DWORD cbSize = pbindInfo->cbSize;
    ZeroMemory( pbindInfo, cbSize );
    pbindInfo->cbSize = cbSize;

    pbindInfo->dwBindVerb = BINDVERB_GET;

    return S_OK;
}


STDMETHODIMP CPicsRootDownload::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                                FORMATETC *pfmtetc,
                                                STGMEDIUM* pstgmed)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    if (SUCCEEDED(punk->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pctObject))) {
        VARIANTARG v;
        v.vt = VT_UNKNOWN;
        v.punkVal = (IOleCommandTarget *)m_pctParent;
        HRESULT hresT = m_pctObject->Exec(&CGID_ShellDocView, SHDVID_CANSUPPORTPICS, 0, &v, NULL);
        if (hresT == S_OK) {
            hresT = punk->QueryInterface(IID_IOleObject, (LPVOID *)&m_pole);
            if (FAILED(hresT))
                m_pole = NULL;
        }
    }

    if (m_pole == NULL) {
        ATOMICRELEASE(m_pctObject);
        _Abort();
    }

    return S_OK;
}


// IOleClientSite
STDMETHODIMP CPicsRootDownload::SaveObject(void)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::GetMoniker(DWORD, DWORD, IMoniker **)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::GetContainer(IOleContainer **)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::ShowObject(void)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}


STDMETHODIMP CPicsRootDownload::RequestNewObjectLayout(void)
{
    return E_NOTIMPL;
}


// IServiceProvider (must be QI'able from IOleClientSite)
STDMETHODIMP CPicsRootDownload::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_STopLevelBrowser)) {
        if (IsEqualIID(riid, IID_IsPicsBrowser))
            return QueryInterface(riid, ppvObj);
        return E_NOINTERFACE;
    }

    return E_FAIL;
}


// IDispatch
HRESULT CPicsRootDownload::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                        VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr)
{
    if (!pVarResult)
        return E_INVALIDARG;

    if (wFlags == DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
        case DISPID_AMBIENT_DLCONTROL :
            // We support IDispatch so that Trident can ask us to control the
            // download.  By specifying all the following flags, and by NOT
            // specifying DLCTL_DLIMAGES, DLCTL_VIDEOS, or DLCTL_BGSOUNDS,
            // we ensure we only download the HTML doc itself, and not a lot
            // of associated things that aren't going to help us find a META
            // tag.

            pVarResult->vt = VT_I4;
            pVarResult->lVal = DLCTL_SILENT | DLCTL_NO_SCRIPTS | 
                               DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS |
                               DLCTL_NO_DLACTIVEXCTLS | DLCTL_NO_FRAMEDOWNLOAD |
                               DLCTL_NO_CLIENTPULL;
            break;
        default:
            return DISP_E_MEMBERNOTFOUND;
        }
        return S_OK;
    }

    return DISP_E_MEMBERNOTFOUND;
}


#endif  /* FEATURE_PICS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\propstg.h ===
/*
 * propstg.h - Property storage ADT
 */

#ifndef _PROPSTG_H_
#define _PROPSTG_H_

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_HANDLE(HPROPSTG);

HRESULT
WINAPI
PropStg_Create(
    OUT HPROPSTG * phstg,
    IN  DWORD      dwFlags);        // PSTGF_*

// Flags for PropStg_Create
#define PSTGF_DEFAULT       0x00000000

HRESULT
WINAPI
PropStg_Destroy(
    IN HPROPSTG hstg);

HRESULT
WINAPI
PropStg_ReadMultiple(
    IN HPROPSTG      hstg,
    IN ULONG         cpspec,
    IN const PROPSPEC * rgpropspec,
    IN PROPVARIANT * rgpropvar);

HRESULT
WINAPI
PropStg_WriteMultiple(
    IN HPROPSTG      hstg,
    IN ULONG         cpspec,
    IN const PROPSPEC * rgpropspec,
    IN const PROPVARIANT * rgpropvar,
    IN PROPID        propidFirst);     OPTIONAL


typedef HRESULT (CALLBACK *PFNPROPVARMASSAGE)(PROPID propid, const PROPVARIANT * ppropvar, LPARAM lParam);

HRESULT
WINAPI
PropStg_WriteMultipleEx(
    IN HPROPSTG      hstg,
    IN ULONG         cpspec,
    IN const PROPSPEC * rgpropspec,
    IN const PROPVARIANT * rgpropvar,
    IN PROPID        propidFirst,      OPTIONAL
    IN PFNPROPVARMASSAGE pfn,          OPTIONAL
    IN LPARAM        lParam);          OPTIONAL

HRESULT
WINAPI
PropStg_DeleteMultiple(
    IN HPROPSTG      hstg,
    IN ULONG         cpspec,
    IN const PROPSPEC * rgpropspec);


HRESULT
WINAPI
PropStg_DirtyMultiple(
    IN HPROPSTG    hstg,
    IN ULONG       cpspec,
    IN const PROPSPEC * rgpropspec,
    IN BOOL        bDirty);

HRESULT
WINAPI
PropStg_DirtyAll(
    IN HPROPSTG    hstg,
    IN BOOL        bDirty);

HRESULT
WINAPI
PropStg_IsDirty(
    IN HPROPSTG hstg);


typedef HRESULT (CALLBACK *PFNPROPSTGENUM)(PROPID propid, PROPVARIANT * ppropvar, LPARAM lParam);

HRESULT
WINAPI
PropStg_Enum(
    IN HPROPSTG       hstg,
    IN DWORD          dwFlags,      // One of PSTGEF_ 
    IN PFNPROPSTGENUM pfnEnum,
    IN LPARAM         lParam);      OPTIONAL

// Filter flags for PropStg_Enum
#define PSTGEF_DEFAULT      0x00000000
#define PSTGEF_DIRTY        0x00000001

#ifdef DEBUG
HRESULT
WINAPI
PropStg_Dump(
    IN HPROPSTG       hstg,
    IN DWORD          dwFlags);     // One of PSTGDF_ 
#endif


#ifdef DEBUG

BOOL
IsValidPPROPSPEC(
    PROPSPEC * ppropspec);

BOOL
IsValidHPROPSTG(
    HPROPSTG hstg);

#endif


#ifdef __cplusplus
};
#endif

#endif  // _PROPSTG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\reload.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       reload.cpp ( based on WebCheck's downld.cxx )
//
//  Contents:   Implmentation of Office9 Thicket Save API
//
//----------------------------------------------------------------------------

#include "priv.h"

//#include "headers.hxx"
#include "reload.h"

#include <exdisp.h>
#include <exdispid.h>
#include <htiface.h>
#include <mshtmdid.h>
#include <mshtmcid.h>
#include <mshtmhst.h>
#include <optary.h>                 // needed for IHtmlLoadOptions
#include <wininet.h>
#include <winineti.h>
#include <shlguid.h>
#include <shlobj.h>
#include "intshcut.h"               // IUniformResourceLocator

#undef DEFINE_STRING_CONSTANTS
#pragma warning( disable : 4207 ) 
#include "htmlstr.h"
#pragma warning( default : 4207 )

// Disable perf warning for typecasts to the native bool type
// Useful for NT64 where pointers cannot be cast to "BOOL"
#pragma warning( disable : 4800 )

//MtDefine(CUrlDownload, Utilities, "CUrlDownload")

#define TF_THISMODULE   TF_DOWNLD

LRESULT UrlDownloadWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);


CLIPFORMAT g_cfHTML=CF_NULL;

// User-Agent strings
const WCHAR c_szUserAgent95[] = L"Mozilla/4.0 (compatible; MSIE 4.01; MSIECrawler; Windows 95)";
const WCHAR c_szUserAgentNT[] = L"Mozilla/4.0 (compatible; MSIE 4.01; MSIECrawler; Windows NT)";

// Refresh header for http-equiv (client-pull)
const WCHAR c_wszRefresh[] = L"Refresh";

const int  MAX_CLIENT_PULL_NUM = 4;     // max # redirections
const int  MAX_CLIENT_PULL_TIMEOUT = 6; // max timeout we'll follow

// Function also present in shdocvw\basesb.cpp and in mshtml
BOOL DLParseRefreshContent(LPWSTR pwzContent, UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf);

const WCHAR c_wszHeadVerb[] = L"HEAD";

const WCHAR c_szUserAgentPrefix[] = L"User-Agent: ";
const WCHAR c_szAcceptLanguagePrefix[] = L"Accept-Language: ";

#define WM_URLDL_CLEAN      (WM_USER + 0x1010)
#define WM_URLDL_ONDLCOMPLETE (WM_USER + 0x1012)
#define WM_URLDL_CLIENTPULL (WM_USER+0x1013)

#define PROP_CODEPAGE       3

const PROPSPEC c_rgPropRead[] = {
    { PRSPEC_PROPID, PID_INTSITE_SUBSCRIPTION},
    { PRSPEC_PROPID, PID_INTSITE_FLAGS},
    { PRSPEC_PROPID, PID_INTSITE_TRACKING},
    { PRSPEC_PROPID, PID_INTSITE_CODEPAGE},
};

//---------------------------------------------------------------
// CUrlDownload class
CUrlDownload::CUrlDownload( CThicketProgress* ptp, HRESULT *phr, UINT cpDL )
{
    // Maintain global count of objects
    //DllAddRef();

    m_ptp = ptp;
    m_phr = phr;
    m_cpDL = cpDL;
    m_dwProgMax = 0;

    m_cRef = 1;
    
    m_pDocument = NULL;
    m_dwConnectionCookie = 0;
    m_pwszURL = NULL;
    m_pScript = NULL;
    m_fAdviseOn = FALSE;
    m_pCP = NULL;
    m_pDocument = NULL;
    m_pPersistMk = NULL;
    m_pOleCmdTarget = NULL;
    m_pwszClientPullURL = NULL;
    m_fWaitingForReadyState = FALSE;
    m_fFormSubmitted = FALSE;
    m_fBrowserValid = FALSE;
    m_hwndMe = NULL;

    // find the HTML clipboard format
    if (!g_cfHTML)
    {
        g_cfHTML = RegisterClipboardFormat(CFSTR_MIME_HTML);
    }

    // find out if we need to set the "RESYNCHRONIZE" flag
    INTERNET_CACHE_CONFIG_INFOA CacheConfigInfo;
    DWORD dwBufSize = sizeof(CacheConfigInfo);

    if (GetUrlCacheConfigInfoA(&CacheConfigInfo, &dwBufSize, CACHE_CONFIG_SYNC_MODE_FC))
    {
        if ((WININET_SYNC_MODE_ONCE_PER_SESSION == CacheConfigInfo.dwSyncMode) ||
             (WININET_SYNC_MODE_NEVER == CacheConfigInfo.dwSyncMode) ||
             (WININET_SYNC_MODE_AUTOMATIC == CacheConfigInfo.dwSyncMode))
        {
            m_fSetResync = FALSE;
        }
        else
        {
            m_fSetResync = TRUE;
        }
    }
    else
        ASSERT(FALSE);

    m_lBindFlags = DLCTL_SILENT | DLCTL_NO_SCRIPTS | DLCTL_NO_FRAMEDOWNLOAD | 
        DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_DLACTIVEXCTLS;
    if (m_fSetResync)
        m_lBindFlags |= DLCTL_RESYNCHRONIZE;

    // register our window class if necessary
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = UrlDownloadWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hinst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = (HBRUSH)NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = URLDL_WNDCLASS;

    SHRegisterClass(&wc);

}

CUrlDownload::~CUrlDownload()
{
    // Maintain global count of objects
    //DllRelease();

    CleanUp();
}

void CUrlDownload::CleanUpBrowser()
{
    SAFERELEASE(m_pScript);

    if (m_fAdviseOn)
    {
        UnAdviseMe();
    }
    SAFERELEASE(m_pCP);
    SAFERELEASE(m_pDocument);
    SAFERELEASE(m_pPersistMk);
    SAFERELEASE(m_pOleCmdTarget);
    SAFELOCALFREE(m_pwszClientPullURL);
}

void CUrlDownload::CleanUp()
{
    CleanUpBrowser();
    SAFELOCALFREE(m_pwszURL);

    if (m_hwndMe)
    {
        SetWindowLongPtr(m_hwndMe, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndMe);
        m_hwndMe = NULL;
    }
}

LRESULT UrlDownloadWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    CUrlDownload *pThis = (CUrlDownload *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    // Validate pThis
#ifdef DEBUG
    if (pThis && IsBadWritePtr(pThis, sizeof(*pThis)))
    {
        ASSERT(FALSE);
    }
#endif

    switch (Msg)
    {
    case WM_CREATE :
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;

            if (!pcs || !(pcs->lpCreateParams))
            {
                return -1;
            }
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pcs->lpCreateParams);
            return 0;
        }

    case WM_URLDL_CLIENTPULL :
    case WM_URLDL_ONDLCOMPLETE :
        if (pThis)
            pThis->HandleMessage(hWnd, Msg, wParam, lParam);
        break;

    default:
        return DefWindowProc(hWnd, Msg, wParam, lParam);
    }
    return 0;
}

HRESULT CUrlDownload::CreateMyWindow()
{
    // Create our callback window
    if (NULL == m_hwndMe)
    {
//      TraceMsg(TF_THISMODULE, "Creating MeWnd, this=0x%08x", (DWORD)this);
        m_hwndMe = CreateWindow(URLDL_WNDCLASS, TEXT("CUrlDownloadWnd"), WS_OVERLAPPED,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL, NULL, g_hinst, (LPVOID)this);

        if (NULL == m_hwndMe)
        {
            return E_FAIL;
        }
    }
    return S_OK;
}

HRESULT CUrlDownload::BeginDownloadURL2(
    LPCWSTR     pwszURL,        // URL
    BDUMethod   iMethod,        // download method
    BDUOptions  iOptions,       // download options
    LPTSTR      pszLocalFile,   // Local file to download to instead of cache
    DWORD       dwMaxSize       // Max size in bytes; will abort if exceeded
)
{
    HRESULT hr = S_OK;

    // Param validation
    ASSERT(pwszURL);
    ASSERT(!(iOptions & BDU2_NEEDSTREAM));
    ASSERT(!pszLocalFile);

    if (pszLocalFile)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CreateMyWindow();

        // Clean up some old stuff
        SAFERELEASE(m_pScript);

        m_fBrowserValid = FALSE;

        m_iMethod = iMethod;
        m_iOptions = iOptions;

        m_dwMaxSize = dwMaxSize;

        SAFELOCALFREE(m_pwszClientPullURL);
        m_iNumClientPull = 0;

        // Save URL
        SAFELOCALFREE(m_pwszURL);
        m_pwszURL = StrDupW(pwszURL);

        // Determine how to download this URL
        hr = BeginDownloadWithBrowser(pwszURL);
    }

    if (FAILED(hr))
    {
        OnDownloadComplete(BDU2_ERROR_GENERAL);
    }

    return (hr);
}

//
// Looks up the Url in the url history object and if its not CP_ACP
// inserts an IHTMLLoadOptions object that contains the codepage
// into the bind context
//


HRESULT InsertCodepageIntoBindCtx(UINT codepage, IBindCtx * pbc)
{
    HRESULT hr = S_OK;

    if (pbc == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (codepage != CP_ACP)
        {
            DWORD dwcp = codepage;
            //
            // We got a codepage that wasn't the ansi one create an
            // HTMLLoadOptions object and set the code page in it.
            //
            IHtmlLoadOptions *phlo = NULL;
            hr = CoCreateInstance(CLSID_HTMLLoadOptions, NULL, 
                CLSCTX_INPROC_SERVER, IID_IHtmlLoadOptions, (void**)&phlo);

            if (SUCCEEDED(hr) && phlo)
            {
                hr = phlo->SetOption(HTMLLOADOPTION_CODEPAGE, &dwcp,
                    sizeof(dwcp));

                if (SUCCEEDED(hr))
                {
                    //
                    // Insert the option into the bindctx
                    //
                    pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
                }
                phlo->Release();
            }
        }
    }
    return hr; // no return  - may return S_FALSE
}

HRESULT CUrlDownload::BeginDownloadWithBrowser(LPCWSTR pwszURL)
{
    HRESULT hr;

    // Get browser and hook up sink
    // (no-op if we're already set up)
    hr = GetBrowser();

    if (SUCCEEDED(hr))
    {
        // browse to the required URL
        LPMONIKER           pURLMoniker = NULL;
        IBindCtx           *pbc = NULL;

        // create a URL moniker from the canonicalized path
        hr=CreateURLMoniker(NULL, pwszURL, &pURLMoniker);

        // create an empty bind context so that Urlmon will call Trident's
        //  QueryService on the proper thread so that Trident can delegate
        //  it to use properly.
        hr=CreateBindCtx(0, &pbc);

        if (SUCCEEDED(hr))
        {
            //
            // Looks up the Url in the url history object and if its not CP_ACP
            // inserts an IHTMLLoadOptions object that contains the codepage
            // into the bind context. This is done so that TRIDENT is seeded
            // with the correct codepage.
            //
            InsertCodepageIntoBindCtx(m_cpDL, pbc);

            hr = m_pPersistMk->Load(FALSE, pURLMoniker, pbc, 0);
            if (SUCCEEDED(hr)) m_fWaitingForReadyState = TRUE;
        }

        // clean up junk
        if (pURLMoniker)
            pURLMoniker->Release();

        if (pbc)
            pbc->Release();

        if (SUCCEEDED(hr))
        {
            m_fBrowserValid = TRUE;
        }
        else
        {
            CleanUpBrowser();
        }
    }

    return (hr);
}

HRESULT CUrlDownload::OnDownloadComplete(int iError)
{
    PostMessage(m_hwndMe, WM_URLDL_ONDLCOMPLETE, (WPARAM)iError, 0);
    return S_OK;
}

BOOL CUrlDownload::HandleMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_URLDL_CLIENTPULL :
        {
            HRESULT hr = S_OK;

            // Ask our parent if we should do this
            if (m_pwszClientPullURL)
            {
                if (m_iNumClientPull >= MAX_CLIENT_PULL_NUM)
                    hr = E_FAIL;
            }

            if (SUCCEEDED(hr))
            {
                // Download this new url. Don't give "downloadcomplete" for first one
                // Save member vars since they get reset in BDU2
                int iNumClientPull = m_iNumClientPull;
                LPWSTR pszNewURL = m_pwszClientPullURL;

                m_pwszClientPullURL = NULL;
                hr = BeginDownloadURL2(pszNewURL, m_iMethod, m_iOptions, NULL, m_dwMaxSize);
                SAFELOCALFREE(pszNewURL);
                if (SUCCEEDED(hr))
                {
                    m_iNumClientPull = iNumClientPull + 1;
                }
            }
        }
        break;

    case WM_URLDL_ONDLCOMPLETE :
        ASSERT(m_phr);
        *m_phr = S_OK;
        return TRUE;

    default:
        break;

    }
    return TRUE;
}

HRESULT CUrlDownload::AbortDownload(int iErrorCode /* =-1 */)
{
    HRESULT hr=S_FALSE;
    BOOL    fAborted=FALSE;

    if (m_fBrowserValid)
    {
        ASSERT(m_pOleCmdTarget);
        if (m_pOleCmdTarget)
        {
            m_pOleCmdTarget->Exec(NULL, OLECMDID_STOP, 0, NULL, NULL);
        }

        SAFELOCALFREE(m_pwszClientPullURL);

        fAborted=TRUE;
        m_fBrowserValid = FALSE;
    }

    return hr; // no return  - may return S_FALSE
}

// Loads browser, creates sink and hooks it up to DIID_DWebBrowserEvents
HRESULT CUrlDownload::GetBrowser()
{
    HRESULT hr = S_OK;

    if (m_fAdviseOn)
        return (hr);

    if (NULL == m_pDocument)
    {
        ASSERT(!m_pPersistMk);
        ASSERT(!m_pCP);

        hr = CoCreateInstance(CLSID_HTMLDocument, NULL,
                    CLSCTX_INPROC, IID_IHTMLDocument2, (void **)&m_pDocument);

        if (SUCCEEDED(hr)) // setting design mode faults Trident && SUCCEEDED(hr = m_pDocument->put_designMode( (BSTR)c_bstr_ON )))
        {
            IOleObject *pOleObj;

            hr = m_pDocument->QueryInterface(IID_IOleObject, (void **)&pOleObj);
            if (SUCCEEDED(hr))
            {
                pOleObj->SetClientSite((IOleClientSite *)this);
                pOleObj->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pDocument->QueryInterface(IID_IPersistMoniker, (void**)&m_pPersistMk);
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pDocument->QueryInterface(IID_IOleCommandTarget, (void**)&m_pOleCmdTarget);
        }

        ASSERT(SUCCEEDED(hr));
    }

    // At this point we have m_pDocument and m_pPersistMk

    // Find our connection point if necessary
    if (NULL == m_pCP && SUCCEEDED(hr))
    {
        IConnectionPointContainer *pCPCont=NULL;
        hr = m_pDocument->QueryInterface(IID_IConnectionPointContainer,
                (void **)&pCPCont);

        if (SUCCEEDED(hr))
        {
            hr = pCPCont->FindConnectionPoint(IID_IPropertyNotifySink, &m_pCP);
            pCPCont->Release();
            pCPCont = NULL;
        }
    }

    // And hook it up to us
    if (SUCCEEDED(hr))
    {
        // create sink
        IPropertyNotifySink *pSink = (IPropertyNotifySink *)this;

        hr = m_pCP->Advise(pSink, &m_dwConnectionCookie);
        if (SUCCEEDED(hr))
        {
            m_fAdviseOn = TRUE;
        }
    }

    return (hr);
}

void CUrlDownload::UnAdviseMe()
{
    if (m_fAdviseOn)
    {
        m_pCP->Unadvise(m_dwConnectionCookie);
        m_fAdviseOn = FALSE;
    }
}

void CUrlDownload::DestroyBrowser()
{
    CleanUpBrowser();
}

void CUrlDownload::DoneDownloading()
{
    // Don't send any more messages to the parent

    AbortDownload();

    CleanUp();
}

HRESULT CUrlDownload::GetScript(IHTMLWindow2 **ppWin)
{
    HRESULT hr = E_FAIL;
    IDispatch *pDisp=NULL;

    ASSERT(ppWin);
    *ppWin=NULL;

    if (!m_fBrowserValid)
    {
        return (E_FAIL);
    }

    *ppWin = NULL;

    if (m_pScript)
    {
        m_pScript->AddRef();
        *ppWin = m_pScript;
        return S_OK;
    }

    if (m_pDocument)
    {
        hr = m_pDocument->get_Script(&pDisp);
        if (!pDisp) hr=E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        hr = pDisp->QueryInterface(IID_IHTMLWindow2, (void **)ppWin);
        if (*ppWin == NULL) hr = E_NOINTERFACE;
        pDisp->Release();
    }

    // Save this so future GetScript() calls much faster
    ASSERT(!m_pScript);
    if (SUCCEEDED(hr))
    {
        m_pScript = *ppWin;
        m_pScript->AddRef();
    }

    return (hr);
}


// Returns pointer to '.' or pointer to null-terminator or query '?'
LPWSTR                  // ptr to period or to null-term or '?'
URLFindExtensionW(
    LPCWSTR pszURL,
    int *piLen)         // length including period
{
    LPCWSTR pszDot;

    ASSERT(pszURL);

    for (pszDot = NULL; *pszURL && *pszURL!=TEXT('?'); pszURL++)
    {
        switch (*pszURL) {
        case TEXT('.'):
            pszDot = pszURL;         // remember the last dot
            break;
        case TEXT('/'):
            pszDot = NULL;       // forget last dot, it was in a directory
            break;
        }
    }

    if (piLen)
    {
        if (pszDot)
            *piLen = (int) (pszURL-pszDot);
        else
            *piLen = 0;
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPWSTR)pszDot : (LPWSTR)pszURL;
}

// Returns TRUE if this appears to be an HTML URL
BOOL CUrlDownload::IsHTMLURL(LPCWSTR lpURL)
{
    LPWSTR pwch;
    int iLen;

    pwch = URLFindExtensionW(lpURL, &iLen);

    if (*pwch && iLen)
    {
        // We found an extension. Check it out.
        if ((iLen<4 || iLen>5) ||
            (iLen == 5 &&
                (StrCmpNIW(pwch, L".html", 5))) ||
            (iLen == 4 &&
                (StrCmpNIW(pwch, L".htm", 4) &&
                 StrCmpNIW(pwch, L".htt", 4) &&
                 StrCmpNIW(pwch, L".asp", 4) &&
                 StrCmpNIW(pwch, L".htx", 4)
                                            )))
        {
            // extension < 3 chars, or extension > 4 chars, or
            // extension not one of the above
            return FALSE;
        }
    }
    else
        return FALSE;       // no extension. Can't assume it's HTML.

    return TRUE;
}

// Returns TRUE if this is a URL we should try to download (http:)
BOOL CUrlDownload::IsValidURL(LPCWSTR lpURL)
{
    // Check protocol
//  HKEY hk;

#if 0
    BOOL fValidProtocol = FALSE;

    // Always accept http or https
    if (!StrCmpNIW(lpURL, L"http", 4))
        fValidProtocol = TRUE;

    if (!fValidProtocol &&
        (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("PROTOCOLS\\Handler"), 0, KEY_QUERY_VALUE, &hk)))
    {
        // Crack out protocol
        DWORD dwData=0, cbData = sizeof(DWORD);
        int i;
        char ch[16];

        // we know we are 7-bit
        for (i=0; i<ARRAYSIZE(ch) && lpURL[i] != L':' && lpURL[i]; i++)
            ch[i] = (char) (lpURL[i]);

        if (i<ARRAYSIZE(ch))
        {
            ch[i] = '\0';

            // We have protocol
            if (NO_ERROR == SHGetValue(hk, ch, TEXT("SupportsNoUI"), NULL, &dwData, &cbData))
            {
                if (dwData != 0)
                    fValidProtocol = TRUE;  // Passed test
            }
        }

        RegCloseKey(hk);
    }
#endif

    // See if this protocol will give us something for the cache
    BOOL fUsesCache=FALSE;
    DWORD dwBufSize=0;
    CoInternetQueryInfo(lpURL, QUERY_USES_CACHE, 0,
        &fUsesCache, sizeof(fUsesCache), &dwBufSize, 0);

    if (!fUsesCache || (S_FALSE == ::IsValidURL(NULL, lpURL, 0)))
        return FALSE;

    return TRUE;
}

HRESULT CUrlDownload::GetRealURL(LPWSTR *ppwszURL)
{
    *ppwszURL = NULL;

    if (!m_fBrowserValid)
    {
        if (m_pwszURL)
            *ppwszURL = StrDupW(m_pwszURL);
    }
    else
    {
        // Get the real URL from the browser in case we were redirected
        // We could optimize to do this only once
        ITargetContainer *pTarget=NULL;
        LPWSTR pwszThisUrl=NULL;

        if (m_pDocument)
        {
            m_pDocument->QueryInterface(IID_ITargetContainer, (void **)&pTarget);

            if (pTarget)
            {
                pTarget->GetFrameUrl(&pwszThisUrl);
                pTarget->Release();
            }
        }

        if (pwszThisUrl)
        {
            if (m_pwszURL) SAFELOCALFREE(m_pwszURL);
            m_pwszURL = StrDupW(pwszThisUrl);
            *ppwszURL = StrDupW(pwszThisUrl);
            CoTaskMemFree(pwszThisUrl);
        }
        else if (m_pwszURL)
        {
            *ppwszURL = StrDupW(m_pwszURL);
        }
    }

    return (*ppwszURL) ? S_OK : E_OUTOFMEMORY;
}


HRESULT CUrlDownload::GetDocument(IHTMLDocument2 **ppDoc)
{
    HRESULT hr;

    if (!m_fBrowserValid)
    {
        *ppDoc = NULL;
        return (E_FAIL);
    }

    *ppDoc = m_pDocument;
    if (m_pDocument)
    {
        m_pDocument->AddRef();
        hr = S_OK;
    }
    else
        hr = E_NOINTERFACE;

    return (hr);
}

    


//
// IUnknown of CUrlDownload
//
STDMETHODIMP CUrlDownload::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv=NULL;

    // Validate requested interface
    if (IID_IOleClientSite == riid)
        *ppv=(IOleClientSite *)this;
    else if (IID_IPropertyNotifySink == riid)
        *ppv=(IPropertyNotifySink *)this;
    else if (IID_IOleCommandTarget == riid)
        *ppv=(IOleCommandTarget *)this;
    else if (IID_IDispatch == riid)
        *ppv=(IDispatch *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else if (IID_IAuthenticate == riid)
        *ppv = (IAuthenticate *)this;
    else if (IID_IInternetSecurityManager == riid)
        *ppv = (IInternetSecurityManager *)this;
    else if ((IID_IUnknown == riid) ||
             (IID_IHlinkFrame == riid))
        *ppv = (IHlinkFrame *)this;
    else
    {
        // DBGIID("CUrlDownload::QueryInterface() failing", riid);
    }

    // Addref through the interface
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CUrlDownload::AddRef(void)
{
//  TraceMsg(TF_THISMODULE, "CUrlDownload addref to %d", m_cRef+1);
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CUrlDownload::Release(void)
{
//  TraceMsg(TF_THISMODULE, "CUrlDownload release - %d", m_cRef-1);
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CUrlDownload::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::Invoke(DISPID dispidMember, 
                                  REFIID riid, 
                                  LCID lcid, 
                                  WORD wFlags,
                                  DISPPARAMS *pdispparams, 
                                  VARIANT *pvarResult,
                                  EXCEPINFO *pexcepinfo, 
                                  UINT *puArgErr)
{
    if (!pvarResult)
        return E_INVALIDARG;

    ASSERT(V_VT(pvarResult)== VT_EMPTY);

    if (wFlags == DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
        case DISPID_AMBIENT_DLCONTROL :
            //TraceMsg(TF_THISMODULE, "Returning DLCONTROL ambient property 0x%08x", m_lBindFlags);
            pvarResult->vt = VT_I4;
            pvarResult->lVal = m_lBindFlags;
            break;

        case DISPID_AMBIENT_USERAGENT:
            CHAR    szUserAgent[MAX_PATH];  // URLMON says the max length of the UA string is MAX_PATH
            DWORD   dwSize;

            dwSize = MAX_PATH;
            szUserAgent[0] = '\0';

            pvarResult->vt = VT_BSTR;

            if ( ObtainUserAgentString( 0, szUserAgent, &dwSize ) == S_OK )
            {
                UINT cch = lstrlenA( szUserAgent );

                // Allocates size + 1
                pvarResult->bstrVal = SysAllocStringLen( 0, cch );
                if( pvarResult->bstrVal )
                {
                    if( !MultiByteToWideChar( CP_ACP, 0, szUserAgent, -1, pvarResult->bstrVal, cch + 1 ) )
                    {
                        SysFreeString( pvarResult->bstrVal );
                        pvarResult->bstrVal = 0;
                    }
                }
            }
            break;

        case DISPID_AMBIENT_USERMODE:
            pvarResult->vt = VT_BOOL;
            pvarResult->boolVal = VARIANT_FALSE; // put it in design mode
            break;

        default:
            return DISP_E_MEMBERNOTFOUND;
        }
        return S_OK;
    }

    return DISP_E_MEMBERNOTFOUND;
}

// IPropertyNotifySink

STDMETHODIMP CUrlDownload::OnChanged(DISPID dispID)
{
    if ((DISPID_READYSTATE == dispID) ||
        (DISPID_UNKNOWN == dispID))
    {
        // Find out if we're done
        if (m_fWaitingForReadyState)
        {
            VARIANT     varState;
            DISPPARAMS  dp;

            VariantInit(&varState);

            if (SUCCEEDED(m_pDocument->Invoke(DISPID_READYSTATE, 
                                              IID_NULL, 
                                              GetUserDefaultLCID(), 
                                              DISPATCH_PROPERTYGET, 
                                              &dp, 
                                              &varState, NULL, NULL)) &&
                V_VT(&varState)==VT_I4 && 
                V_I4(&varState)== READYSTATE_COMPLETE)
            {
                m_fWaitingForReadyState = FALSE;
                // Successful download. See if a client-pull is waiting.
                if (m_pwszClientPullURL)
                    PostMessage(m_hwndMe, WM_URLDL_CLIENTPULL, 0, 0);
                else
                    OnDownloadComplete(BDU2_ERROR_NONE);
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CUrlDownload::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

// IOleCommandTarget
STDMETHODIMP CUrlDownload::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                    OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CUrlDownload::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                                VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_NOTSUPPORTED;

    if (pguidCmdGroup == NULL) 
    {
        switch(nCmdID) 
        {
        case OLECMDID_SETPROGRESSPOS:
        {
            hres = S_OK;
            VARIANT     varBytes;
            
            if (m_pOleCmdTarget)
            {
                varBytes.vt=VT_EMPTY;
                m_pOleCmdTarget->Exec(&CGID_MSHTML, IDM_GETBYTESDOWNLOADED, 0, NULL, &varBytes);

                if (varBytes.vt == VT_I4)
                {
                    DWORD dwBytes = (DWORD) varBytes.lVal;

                    //TraceMsg(TF_THISMODULE, "%d bytes on page so far (mshtml)", dwBytes);

                    ProgressBytes(dwBytes);

                    // for this mutant version, we also want to keep mom and dad up to date.
                    LONG lPos;

                    // we use 0..50 so that the progress meter won't max out
                    // when only the download phase is finished and we still have
                    // packaging work to do.
                    if (pvarargIn && m_dwProgMax)
                        lPos = (pvarargIn->lVal * 25) / m_dwProgMax;
                    else
                        lPos = 0;

                    if (m_ptp)
                        m_ptp->SetPercent( lPos );
                    hres = S_OK;
                }
            }
        }
            break;

        case OLECMDID_SETPROGRESSMAX:
        {
            if (pvarargIn && pvarargIn->vt == VT_I4)
                m_dwProgMax = pvarargIn->lVal;
            hres = S_OK;
        }
            break;

        //
        // The containee has found an http-equiv meta tag; handle it
        // appropriately (client pull)
        //
        case OLECMDID_HTTPEQUIV_DONE:
            hres = S_OK;
            break;

        case OLECMDID_HTTPEQUIV:
            {
                LPWSTR  pwszEquivString = pvarargIn? pvarargIn->bstrVal : NULL;
                BOOL    fHasHeader = (bool) pwszEquivString;

                if (pvarargIn && pvarargIn->vt != VT_BSTR)
                    return OLECMDERR_E_NOTSUPPORTED;

                if (!fHasHeader || StrCmpNIW(c_wszRefresh, pwszEquivString, lstrlenW(c_wszRefresh)) == 0)
                {
                    // Hit.  Now do the right thing for this header
                    // We pass both the header and a pointer to the first char after
                    // ':', which is usually the delimiter handlers will look for.

                    LPWSTR pwszColon = fHasHeader ? StrChrW(pwszEquivString, ':') : NULL;
      
                    // Enforce the : at the end of the header
                    if (fHasHeader && !pwszColon)
                    {
                        return OLECMDERR_E_NOTSUPPORTED;
                    }
             
                    hres = HandleRefresh(pwszEquivString, pwszColon ? pwszColon+1:NULL,
                                         (nCmdID == OLECMDID_HTTPEQUIV_DONE));
                }
            }

            // if we return OLECMDERR_E_NOTSUPPORTED, we don't handle
            // client pull
            break;
        }
    }

    return hres;
}

// The basic operation was lifted from shdocvw\basesb.cpp
HRESULT CUrlDownload::HandleRefresh(LPWSTR pwszEquivString, LPWSTR pwszContent, BOOL fDone)
{
    unsigned int uiTimeout = 0;
    WCHAR        awch[INTERNET_MAX_URL_LENGTH];

    if (fDone)
    {
        return S_OK;    // fDone means we don't process this
    }

    // NSCompat: we only honor the first successfully parsed Refresh
    if (m_pwszClientPullURL)
        return S_OK;

    if (!pwszContent ||
        !DLParseRefreshContent(pwszContent, &uiTimeout, awch, INTERNET_MAX_URL_LENGTH))
    {
        return OLECMDERR_E_NOTSUPPORTED;   // cannot handle refresh w/o timeout
    }
    
    if (!awch[0])
    {
        return S_OK;
    }

    if (m_iNumClientPull >= MAX_CLIENT_PULL_NUM)
    {
        return S_OK;
    }

    //TraceMsg(TF_THISMODULE, "CUrlDownload client pull (refresh=%d) url=%ws", uiTimeout, awch);
    if (uiTimeout > MAX_CLIENT_PULL_TIMEOUT)
    {
        return S_OK;
    }

    m_pwszClientPullURL = StrDupW(awch);

    // If we can't copy the URL, don't set the timer or else we'll
    // keep reloading the same page.

    if (m_pwszClientPullURL == NULL)
        return OLECMDERR_E_NOTSUPPORTED;

    return S_OK;
}



HRESULT CUrlDownload::SetDLCTL(long lFlags)
{
//  TraceMsg(TF_THISMODULE, "CUrlDownload: SetDLCTL %04x", lFlags);
    m_lBindFlags = lFlags | DLCTL_SILENT;
    if (m_fSetResync)
        m_lBindFlags |= DLCTL_RESYNCHRONIZE;

    return S_OK;
}

#define INET_E_AGENT_BIND_IN_PROGRESS 0x800C0FFF

HRESULT CUrlDownload::ProgressBytes(DWORD dwBytes)
{
    if (m_dwMaxSize > 0 && dwBytes > m_dwMaxSize)
    {
        //TraceMsg(TF_THISMODULE, "CUrlDownload MaxSize exceeded aborting. %d of %d bytes", dwBytes, m_dwMaxSize);

        AbortDownload(BDU2_ERROR_MAXSIZE);
        return E_ABORT;
    }

    return S_OK;
}

//---------------------------------------------------------------
// IServiceProvider
STDMETHODIMP CUrlDownload::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    if ((SID_SHlinkFrame == guidService && IID_IHlinkFrame == riid) ||
        (IID_IAuthenticate == guidService && IID_IAuthenticate == riid) ||
        (SID_SInternetSecurityManager == guidService && IID_IInternetSecurityManager == riid))
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
}

//---------------------------------------------------------------
// IAuthenticate
STDMETHODIMP CUrlDownload::Authenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    HRESULT hr;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    
    *phwnd = (HWND)-1;
    *ppszUsername = NULL;
    *ppszPassword = NULL;

    hr = E_NOTIMPL;

    //TraceMsg(TF_THISMODULE, "CUrlDownload::Authenticate returning hr=%08x", hr);

    return (hr);
}

//---------------------------------------------------------------
// IHlinkFrame
STDMETHODIMP CUrlDownload::SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate)
{
    // We should only get a call through IHlinkFrame->Navigate()
    // when the webcrawler has submitted a form for authentication.
    // Bail out if that's not the case.
    if (!m_fFormSubmitted)
    {
        return E_NOTIMPL;
    }

    // Our timer has already been started. If this fails, OnDownloadComplete will get
    //  called when we time out.

    // We don't support a wide variety of parameters.
    ASSERT(grfHLNF == 0);
    ASSERT(pbc);
    ASSERT(pibsc);
    ASSERT(pihlNavigate);

    // Get the moniker from IHlink
    HRESULT hr;
    IMoniker *pmk = NULL;
    hr = pihlNavigate->GetMonikerReference(HLINKGETREF_ABSOLUTE, &pmk, NULL);
    if (SUCCEEDED(hr))
    {
        // Load the URL with the post data.
        // REARCHITECT: What if we get redirected to something other than HTML? (beta 2)
        hr = m_pPersistMk->Load(FALSE, pmk, pbc, 0);
        SAFERELEASE(pmk);
        if (SUCCEEDED(hr))
        {
            m_fBrowserValid = TRUE;
            // Need to wait again.
            m_fWaitingForReadyState = TRUE;
        }
    }
    return (hr);
}
STDMETHODIMP CUrlDownload::OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved)
{
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
// IInternetSecurityManager interface
// Used to override security to allow form submits, for form auth sites
HRESULT CUrlDownload::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return E_NOTIMPL;
}

HRESULT CUrlDownload::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    return E_NOTIMPL;
}

HRESULT CUrlDownload::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    if ((dwAction == URLACTION_HTML_SUBMIT_FORMS_TO) ||
        (dwAction == URLACTION_HTML_SUBMIT_FORMS_FROM))
    {
        return S_OK;
    }
    
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

//
// IOleClientSite
//
STDMETHODIMP CUrlDownload:: SaveObject(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: GetContainer(IOleContainer **ppContainer)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: ShowObject(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: RequestNewObjectLayout(void)
{
    return E_NOTIMPL;
}



// ParseRefreshContent was lifted in its entirety from shdocvw\basesb.cpp
BOOL DLParseRefreshContent(LPWSTR pwzContent,
    UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf)
{
    // We are parsing the following string:
    //
    //  [ws]* [0-9]+ [ws]* ; [ws]* url [ws]* = [ws]* { ' | " } [any]* { ' | " }
    //
    // Netscape insists that the string begins with a delay.  If not, it
    // ignores the entire directive.  There can be more than one URL mentioned,
    // and the last one wins.  An empty URL is treated the same as not having
    // a URL at all.  An empty URL which follows a non-empty URL resets
    // the previous URL.

    enum { PRC_START, PRC_DIG, PRC_DIG_WS, PRC_SEMI, PRC_SEMI_URL,
        PRC_SEMI_URL_EQL, PRC_SEMI_URL_EQL_ANY };
    #define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

    UINT uiState = PRC_START;
    UINT uiDelay = 0;
    LPWSTR pwz = pwzContent;
    LPWSTR pwzUrl = NULL;
    UINT   cchUrl = 0;
    WCHAR  wch,  wchDel = 0;

    *pwzUrlBuf = 0;

    do
    {
        wch = *pwz;

        switch (uiState)
        {
            case PRC_START:
                if (wch >= TEXT('0') && wch <= TEXT('9'))
                {
                    uiState = PRC_DIG;
                    uiDelay = wch - TEXT('0');
                }
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_DIG:
                if (wch >= TEXT('0') && wch <= TEXT('9'))
                    uiDelay = uiDelay * 10 + wch - TEXT('0');
                else if (ISSPACE(wch))
                    uiState = PRC_DIG_WS;
                else if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else
                    goto done;
                break;

            case PRC_DIG_WS:
                if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_SEMI:
                if (    (wch == TEXT('u') || wch == TEXT('U'))
                    &&  (pwz[1] == TEXT('r') || pwz[1] == TEXT('R'))
                    &&  (pwz[2] == TEXT('l') || pwz[2] == TEXT('L')))
                {
                    uiState = PRC_SEMI_URL;
                    pwz += 2;
                }
                else if (!ISSPACE(wch) && wch != TEXT(';'))
                    goto done;
                break;

            case PRC_SEMI_URL:
                if (wch == TEXT('='))
                {
                    uiState = PRC_SEMI_URL_EQL;
                    *pwzUrlBuf = 0;
                }
                else if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_SEMI_URL_EQL:
                if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                {
                    uiState = PRC_SEMI_URL_EQL_ANY;

                    pwzUrl = pwzUrlBuf;
                    cchUrl = cchUrlBuf;

                    if (wch == TEXT('\'')|| wch == TEXT('\"'))
                        wchDel = wch;
                    else
                    {
                        wchDel = 0;
                        *pwzUrl++ = wch;
                        cchUrl--;
                    }
                }
                break;
                        
            case PRC_SEMI_URL_EQL_ANY:
                if (    !wch
                    ||  ( wchDel && wch == wchDel)
                    ||  (!wchDel && wch == L';'))
                {
                    *pwzUrl = 0;
                    uiState = wch == TEXT(';') ? PRC_SEMI : PRC_DIG_WS;
                }
                else if (cchUrl > 1)
                {
                    *pwzUrl++ = wch;
                    cchUrl--;
                }
                break;
        }

        ++pwz;

    } while (wch);

done:

    *puiDelay = uiDelay;

    return(uiState >= PRC_DIG);
} // ParseRefreshContent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\reload.h ===
#ifndef _DOWNLD_HXX_
#define _DOWNLD_HXX_

#include <mshtmdid.h>
#include <mshtml.h>
#include <hlink.h>
#include "packager.h"

#ifndef GUIDSTR_MAX
// GUIDSTR_MAX is 39 and includes the terminating zero.
// == Copied from OLE source code =================================
// format for string form of GUID is (leading identifier ????)
// ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)
// ================================================================
#endif

// Trace and debug flags
#define TF_WEBCHECKCORE 0x00001000
//#define TF_SCHEDULER    0x00002000
#define TF_WEBCRAWL     0x00004000
//#define TF_FAVORITES    0x00008000
#define TF_CDFAGENT     0x00010000
#define TF_STRINGLIST   0x00020000
#define TF_URLDOWNLOAD  0x00040000
#define TF_DOWNLD       0x00080000
#define TF_DIALMON      0x00100000
#define TF_MAILAGENT    0x00200000
#define TF_TRAYAGENT    0x00400000
#define TF_SUBSFOLDER   0x00800000
#define TF_MEMORY       0x01000000
#define TF_UPDATEAGENT  0x02000000
#define TF_POSTAGENT    0x04000000
#define TF_DELAGENT     0x08000000
#define TF_TRACKCACHE   0x10000000
#define TF_SYNCMGR      0x20000000
#define TF_THROTTLER    0x40000000

#define PSM_QUERYSIBLINGS_WPARAM_RESCHEDULE 0XF000

#undef DBG
#define DBG(sz)             TraceMsg(TF_THISMODULE, sz)
#define DBG2(sz1, sz2)      TraceMsg(TF_THISMODULE, sz1, sz2)
#define DBG_WARN(sz)        TraceMsg(TF_WARNING, sz)
#define DBG_WARN2(sz1, sz2) TraceMsg(TF_WARNING, sz1, sz2)

#ifdef DEBUG
#define DBGASSERT(expr,sz)  do { if (!(expr)) TraceMsg(TF_WARNING, (sz)); } while (0)
#define DBGIID(sz,iid)      DumpIID(sz,iid)
#else
#define DBGASSERT(expr,sz)  ((void)0)
#define DBGIID(sz,iid)      ((void)0)
#endif

// shorthand
#ifndef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; } else
#endif
#ifndef ATOMICRELEASE
#define ATOMICRELEASET(p,type) { type* punkT=p; p=NULL; punkT->Release(); }
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#endif
#ifndef SAFEFREEBSTR
#define SAFEFREEBSTR(p) if ((p) != NULL) { SysFreeString(p); (p) = NULL; } else
#endif
#ifndef SAFEFREEOLESTR
#define SAFEFREEOLESTR(p) if ((p) != NULL) { CoTaskMemFree(p); (p) = NULL; } else
#endif
#ifndef SAFELOCALFREE
#define SAFELOCALFREE(p) if ((p) != NULL) { LocalFree(p); (p) = NULL; } else
#endif
#ifndef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; } else
#endif

#define URLDL_WNDCLASS  TEXT("TridentThicketUrlDlClass")

#define ACCEPT_LANG_MAX     256

// Options for BeginDownloadURL2
typedef enum {
    BDU2_BROWSER    // always download into the browser
} BDUMethod;

typedef DWORD BDUOptions;

// BDUOptions
#define BDU2_NONE               0
#define BDU2_NEEDSTREAM         1   // keep an istream around from bdu2_urlmon download

// OnDownloadComplete error codes
#define BDU2_ERROR_NONE         0
#define BDU2_ERROR_GENERAL      1
#define BDU2_ERROR_ABORT        2
#define BDU2_ERROR_MAXSIZE      3
#define BDU2_ERROR_TIMEOUT      4


// CUrlDowload hosts one browser and can handle one download at a time.
//
// Use of class CUrlDownload:
//
// 1) Create and AddRef it
// 1.5) call put_Flags() to set the bind status callback IBrowseControl::Flags
// 2) Call BeginDownloadURL2 to start a download
// 3) Call BeginDownloadURL2 to start another download, reusing browser
// 4) Call DoneDownloading() when finished
// 5) Release()

// DoneDownloading() must be called before Release() or the CUrlDownload instance may
//  continue to receive notifications from the browser and attempt to pass them to
//  the parent. It unhooks itself as soon as OnProgress(-1) is received. But be safe.


// See webcrawl.h and webcrawl.cpp for example
class CUrlDownload :  public IOleClientSite         // e_notimpl
                    , public IPropertyNotifySink    // for readystate change notifications
                    , public IOleCommandTarget      // for client pull callbacks
                    , public IDispatch              // for ambient properties
                    , public IServiceProvider       // for IAuthenticate and IHlinkFrame
                    , public IAuthenticate          // for Basic and NTLM authentication
                    , public IHlinkFrame            // for catching the post of a form
                    , public IInternetSecurityManager // for allowing the post of a form
{
    

public:
    CUrlDownload( CThicketProgress *ptp, HRESULT *phr, UINT cpDL );
    ~CUrlDownload();

    void SetFormSubmitted(BOOL fFormSubmitted) { m_fFormSubmitted = fFormSubmitted; }
    BOOL GetFormSubmitted(void) { return m_fFormSubmitted; }

    // An E_ return code from this function may be ignored if desired. The
    //  client's OnDownloadComplete will be called with fAborted==TRUE after this
    //  function returns with an error value.
    HRESULT BeginDownloadURL2(LPCWSTR, BDUMethod, BDUOptions, LPTSTR, DWORD);

    HRESULT SetDLCTL(long lFlags);  // DLCTL flags used for browser control

    HRESULT AbortDownload(int iErrorCode=-1);   // S_OK, S_FALSE, E_FAIL

    HRESULT GetRealURL(LPWSTR *ppwszURL);   // Gets URL accounting for any and all redirections (MemFree)

    HRESULT GetScript(IHTMLWindow2 **pWin);    // Will cache an *additional* reference internally
    void    ReleaseScript() { SAFERELEASE(m_pScript); } // Releases internal reference

    HRESULT GetDocument(IHTMLDocument2 **ppDoc);

    void    DoneDownloading();  // Call before releasing. Will destroy browser and windows.
    void    DestroyBrowser();   // Destroy hosted browser, leave all else alone

    // URL manipulation functions
static HRESULT StripAnchor(LPWSTR lpURL);
static BOOL IsHTMLURL(LPCWSTR lpURL); // TRUE (yes) or FALSE (maybe)
static BOOL IsValidURL(LPCWSTR lpURL);  // TRUE (get it) or FALSE (skip it)

    // Should only be called from CUrlDownloadMsgProc
    BOOL HandleMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //      IDispatch (ambient properties)
    STDMETHODIMP         GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP         GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP         GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                                LCID lcid, DISPID *rgdispid);
    STDMETHODIMP         Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                DISPPARAMS *pdispparams, VARIANT *pvarResult,
                                EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // IOleClientSite
    STDMETHODIMP        SaveObject(void);
    STDMETHODIMP        GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    STDMETHODIMP        GetContainer(IOleContainer **ppContainer);
    STDMETHODIMP        ShowObject(void);
    STDMETHODIMP        OnShowWindow(BOOL fShow);
    STDMETHODIMP        RequestNewObjectLayout(void);

    // IPropertyNotifySink
    STDMETHODIMP        OnChanged(DISPID dispID);
    STDMETHODIMP        OnRequestEdit(DISPID dispID);

    // IOleCommandTarget
    STDMETHODIMP         QueryStatus(const GUID *pguidCmdGroup,
                                     ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHODIMP         Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                              DWORD nCmdexecopt, VARIANTARG *pvaIn,
                              VARIANTARG *pvaOut);

    // IServiceProvider
    STDMETHODIMP        QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

    // IAuthenticate
    STDMETHODIMP        Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);
    
    // IHlinkFrame
    STDMETHODIMP        SetBrowseContext(IHlinkBrowseContext *pihlbc);
    STDMETHODIMP        GetBrowseContext(IHlinkBrowseContext **ppihlbc);
    STDMETHODIMP        Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate);
    STDMETHODIMP        OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved);
    STDMETHODIMP        UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName);

    // IInternetSecurityManager
    STDMETHODIMP        SetSecuritySite(IInternetSecurityMgrSite *pSite);
    STDMETHODIMP        GetSecuritySite(IInternetSecurityMgrSite **ppSite);
    STDMETHODIMP        MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
    STDMETHODIMP        GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
    STDMETHODIMP        ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    STDMETHODIMP        QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
    STDMETHODIMP        SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
    STDMETHODIMP        GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);



protected:
    // main object stuff
    ULONG               m_cRef;
    HWND                m_hwndMe;
    CThicketProgress*   m_ptp;
    UINT                m_cpDL;
    HRESULT             *m_phr;
    DWORD               m_dwProgMax;

    // GetBrowser/CleanUpBrowser (browser download data)
    IPersistMoniker     *m_pPersistMk;
    IHTMLDocument2      *m_pDocument;
    IOleCommandTarget   *m_pOleCmdTarget;
    BOOL                m_fWaitingForReadyState;
    BOOL                m_fFormSubmitted;
    IConnectionPoint    *m_pCP;         // connection point for DIID_DWebBrowserEvents
    BOOL                m_fAdviseOn;    // our sink is hooked up? (ConnectionCookie valid)
    DWORD               m_dwConnectionCookie;
    BOOL                m_fBrowserValid;    // Browser pointing to 'current' URL?


    // General download data
    BDUMethod           m_iMethod;
    BDUOptions          m_iOptions;
    LPWSTR              m_pwszURL;      // gives us the current url after redirections
    BOOL                m_fSetResync;   // need RESYNCHRONIZE?
    DWORD               m_dwMaxSize;    // in bytes

    // IBrowseControl
    long                m_lBindFlags;

    // allow caching GetScript calls
    IHTMLWindow2        *m_pScript;

    // Client pull
    LPWSTR              m_pwszClientPullURL;
    int                 m_iNumClientPull;

    // other internal stuff
    HRESULT     CreateMyWindow();
    HRESULT     GetBrowser();   // Get browser and set us on connection point
    void        UnAdviseMe();   // Unhook our advise sink

    void        CleanUpBrowser();
    void        CleanUp();      // Clean up, including releasing browser

    HRESULT     BeginDownloadWithBrowser(LPCWSTR);

    HRESULT     HandleRefresh(LPWSTR pwszEquivString, LPWSTR pwszContent, BOOL fDone);

    HRESULT     OnDownloadComplete(int iError);     // cancel timeout, send OnDownloadComplete

    HRESULT     ProgressBytes(DWORD dwBytes);       // Will abort if too many
};



#endif // _DWNLOAD_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\sccls.cpp ===
#define  DONT_USE_ATL
#include "priv.h"
#include "sccls.h"
#include "atl.h"
#include <ntverp.h>

#include <ieguidp.h>                // for CLSID_CDocObjectFolder
#include "ishcut.h"
#include "reload.h"                 // for URLDL_WNDCLASS
#include "inetnot.h"                // CWinInetNotify_szWindowClass
#include <activscp.h>               // IID_IActiveScriptStats
#define MLUI_INIT
#include <mluisupp.h>

#define DECL_CRTFREE
#include <crtfree.h>

#include "shfusion.h"

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

STDAPI_(FARPROC) DelayloadNotifyHook(UINT iReason, PDelayLoadInfo pdli);

PfnDliHook __pfnDliFailureHook;
PfnDliHook __pfnDliNotifyHook = DelayloadNotifyHook;      // notify hook is needed so that we can unload wininet.dll
HANDLE BaseDllHandle;


LONG                g_cRefThisDll = 0;      // per-instance
CRITICAL_SECTION    g_csDll = {0};          // per-instance
HINSTANCE           g_hinst = NULL;

EXTERN_C HANDLE g_hMutexHistory = NULL;

BOOL g_fRunningOnNT = FALSE;
BOOL g_bNT5Upgrade = FALSE;
BOOL g_bRunOnNT5 = FALSE;
BOOL g_bRunOnMemphis = FALSE;
BOOL g_fRunOnFE = FALSE;
UINT g_uiACP = CP_ACP;
DWORD g_dwStopWatchMode = 0;        // Shell perf automation
BOOL g_bMirroredOS = FALSE;         // Is Mirroring enabled
BOOL g_bBiDiW95Loc = FALSE;         // needed for BiDi localized win95 RTL stuff
HMODULE g_hmodWininet = NULL;       // have we loaded wininet because of a delayload thunk??

EXTERN_C HANDLE g_hSemBrowserCount;

HPALETTE g_hpalHalftone = NULL;

EXTERN_C const GUID CLSID_MsgBand;

STDAPI CMsgBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY(&CLSID_CDocObjectFolder,        CDocObjectFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_NOFLAGS(&CLSID_CBaseBrowser,    CBaseBrowser2_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_CURLFolder,              CInternetFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_Internet,                CInternetFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CacheFolder,             CacheFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CacheFolder2,            CacheFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_HistFolder,              HistFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_ALL(&CLSID_WebBrowser,          CWebBrowserOC_CreateInstance,
         &IID_IWebBrowser2, &DIID_DWebBrowserEvents2, VERSION_2,
        OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT,OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_CUrlHistory,             CUrlHistory_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CURLSearchHook,          CURLSearchHook_CreateInstance,
        COCREATEONLY), 

    CF_TABLE_ENTRY_ALL(&CLSID_WebBrowser_V1,           CWebBrowserOC_CreateInstance,
         &IID_IWebBrowser, &DIID_DWebBrowserEvents, VERSION_1,
        OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT,OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_CStubBindStatusCallback, CStubBSC_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ShellUIHelper,           CShellUIHelper_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_InternetShortcut,        CIntShcut_CreateInstance,
        COCREATEONLY),

#ifdef ENABLE_CHANNELS
    CF_TABLE_ENTRY_ALL(&CLSID_ChannelOC,                ChannelOC_CreateInstance,
        NULL,NULL,0,
        OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT,
        OIF_ALLOWAGGREGATION),
#endif  // ENABLE_CHANNELS

#ifndef NO_SPLASHSCREEN 
   CF_TABLE_ENTRY(&CLSID_IESplashScreen,            CIESplashScreen_CreateInstance,
        COCREATEONLY),
#endif
        
   CF_TABLE_ENTRY(&CLSID_WinListShellProc,          CWinListShellProc_CreateInstance,
        COCREATEONLY),

   CF_TABLE_ENTRY(&CLSID_CDFCopyHook,               CCDFCopyHook_CreateInstance,
        COCREATEONLY),

   CF_TABLE_ENTRY(&CLSID_InternetCacheCleaner,      CInternetCacheCleaner_CreateInstance,
        COCREATEONLY),
   
    CF_TABLE_ENTRY(&CLSID_OfflinePagesCacheCleaner, COfflinePagesCacheCleaner_CreateInstance,
        COCREATEONLY),        

   CF_TABLE_ENTRY(&CLSID_TaskbarList,               TaskbarList_CreateInstance,
        COCREATEONLY),
        
   CF_TABLE_ENTRY(&CLSID_DocFileInfoTip,            CDocFileInfoTip_CreateInstance,
        COCREATEONLY),

   CF_TABLE_ENTRY(&CLSID_DocHostUIHandler,          CDocHostUIHandler_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ToolbarExtBand,           CToolbarExtBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ToolbarExtExec,           CToolbarExtExec_CreateInstance,
        COCREATEONLY),
        
    CF_TABLE_ENTRY(&CLSID_NSCTree,                  CNscTree_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_FavBand,                 CFavBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ExplorerBand,             CExplorerBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_HistBand,                  CHistBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MruLongList,                CMruLongList_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MruPidlList,                CMruPidlList_CreateInstance,
        COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)

// constructor for CObjectInfo. 

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn, 
                         DWORD dwClassFactFlagsIn)
{ 
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;
       
        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
    
        ASSERT(FAILED(hr) ? *ppv == NULL : TRUE);
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    TraceMsg(DM_TRACE, "sccls: LockServer(%s) to %d", fLock ? TEXT("LOCK") : TEXT("UNLOCK"), g_cRefThisDll);
    return S_OK;
}

BOOL IsProxyRegisteredProperly(LPCTSTR pszInterface, LPCTSTR pszClsid)
{
    TCHAR szInterface[128];
    wnsprintf(szInterface, ARRAYSIZE(szInterface), TEXT("Interface\\%s\\ProxyStubClsid32"), pszInterface);

    TCHAR szValue[40];
    DWORD cbValue = sizeof(szValue);
    return (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szInterface, NULL, NULL, szValue, &cbValue)) &&
           (0 == StrCmpI(szValue, pszClsid));
}

// published, so invariant

#define ACTXPROXYSTUB           TEXT("{B8DA6310-E19B-11D0-933C-00A0C90DCAA9}")
#define FOLDERMARSHALPROXYSTUB  TEXT("{bf50b68e-29b8-4386-ae9c-9734d5117cd5}")  // CLSID_FolderMarshalStub
#define ISHELLFOLDER            TEXT("{000214E6-0000-0000-C000-000000000046}")  // IID_IShellFolder
#define ISHELLFOLDER2           TEXT("{93F2F68C-1D1B-11D3-A30E-00C04F79ABD1}")  // IID_IShellFolder2
#define IOLECOMMANDTARGET       TEXT("{b722bccb-4e68-101b-a2bc-00aa00404770}")  // IID_IOleCommandTarget
#define IHLINKTARGET            TEXT("{79eac9c4-baf9-11ce-8c82-00aa004ba90b}")  // IID_IHlinkTarget

void SHShouldRegisterActxprxy(void)
{
    // IOleCommandTarget / IHlinkTarget Proxy/Stub CLSID key missing?
    if (!IsProxyRegisteredProperly(IOLECOMMANDTARGET, ACTXPROXYSTUB) ||
        !IsProxyRegisteredProperly(IHLINKTARGET, ACTXPROXYSTUB))
    {
        HINSTANCE hinst = LoadLibrary(TEXT("ACTXPRXY.DLL"));
        if (hinst)
        {
            typedef HRESULT (WINAPI * REGSERVERPROC)(void);
            REGSERVERPROC pfn = (REGSERVERPROC) GetProcAddress(hinst, "DllRegisterServer");
            if (pfn)
                pfn();
            FreeLibrary(hinst);
        }
    }

    // test for IShellFolder marshaler not being set to our app compat stub
    if (!IsProxyRegisteredProperly(ISHELLFOLDER, FOLDERMARSHALPROXYSTUB) ||
        !IsProxyRegisteredProperly(ISHELLFOLDER2, FOLDERMARSHALPROXYSTUB))
    {
        SHSetValue(HKEY_CLASSES_ROOT, TEXT("Interface\\") ISHELLFOLDER TEXT("\\ProxyStubClsid32"), 
            TEXT(""), REG_SZ, FOLDERMARSHALPROXYSTUB, sizeof(FOLDERMARSHALPROXYSTUB));

        SHSetValue(HKEY_CLASSES_ROOT, TEXT("Interface\\") ISHELLFOLDER2 TEXT("\\ProxyStubClsid32"), 
            TEXT(""), REG_SZ, FOLDERMARSHALPROXYSTUB, sizeof(FOLDERMARSHALPROXYSTUB));
    }
}

void SHCheckRegistry(void)
{
    // VBE has a bug where they destroy the interface registration information of any control
    // hosted in a VBE user form.  Check the registry here.  Only do this once.
    // 17-Nov-97 [alanau/terrylu] Added a check for the IOleCommandTarget Proxy/Stub handler
    //
    static BOOL fNeedToCheckRegistry = TRUE;

    if (fNeedToCheckRegistry)
    {
        fNeedToCheckRegistry = FALSE;

        // This is published, so is invariant
        TCHAR szValue[39];
        DWORD cbValue = sizeof(szValue);
        LONG rc = SHGetValue(HKEY_CLASSES_ROOT, TEXT("Interface\\{EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B}\\Typelib"), 
            NULL, NULL, szValue, &cbValue); 
            
        if (rc == ERROR_SUCCESS)
        {
            // Compare the retrieved value with our typelib id.
            //
            if (StrCmpI(szValue, TEXT("{EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}")) != 0)
            {
                // If different, we need to explicitly register our typelib
                //
                SHRegisterTypeLib();
            }
        }
         
        SHShouldRegisterActxprxy();
     }
}

STDAPI CInstClassFactory_Create(REFCLSID rclsid, REFIID riid, void *ppv);

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    SHCheckRegistry();  // patch up broken registry

    *ppv = NULL;
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    if ((riid == IID_IClassFactory) || (riid == IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls; 
                DllAddRef();        // class factory holds DLL ref count
                hr = S_OK;
                break;
            }
        }

        if (FAILED(hr))
        {
            // Try the ATL class factory
            hr = AtlGetClassObject(rclsid, riid, ppv);
            if (FAILED(hr))
            {
                // not found, see if it's an 'instance' (code + initialization)
                hr = CInstClassFactory_Create(rclsid, riid, ppv);
            }
        }
    }
    else if ((riid == IID_IPSFactoryBuffer) && 
             (rclsid == CLSID_FolderMarshalStub) &&
             !(SHGetAppCompatFlags(ACF_APPISOFFICE) & ACF_APPISOFFICE))
    {
        // IID_IActiveScriptStats == CLSID_ActiveXProxy
        // B8DA6310-E19B-11d0-933C-00A0C90DCAA9
        hr = CoGetClassObject(IID_IActiveScriptStats, CLSCTX_INPROC_SERVER, NULL, riid, ppv);
    }
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (0 != g_cRefThisDll || 0 != AtlGetLockCount())
        return S_FALSE;

    TraceMsg(DM_TRACE, "DllCanUnloadNow returning S_OK (bye, bye...)");
    return S_OK;
}

// DllGetVersion - New for IE 4.0
//
// All we have to do is declare this puppy and CCDllGetVersion does the rest
//
DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);

#ifdef DEBUG
EXTERN_C
DWORD g_TlsMem = 0xffffffff;
#endif

void InitNFCtl()
{
    INITCOMMONCONTROLSEX icc;

    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icc);
}

//
// we use shlwapi as our delayload error handler.
// NOTE: this only works if we are statically linked to shlwapi!
//
void SetupDelayloadErrorHandler()
{
    BaseDllHandle = GetModuleHandleA("shlwapi.dll");
    ASSERTMSG(BaseDllHandle != NULL, "SHDOCVW must be statically linked to shlwapi.dll for delayload failure handling to work!");
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress((HMODULE)BaseDllHandle, "DelayLoadFailureHook");
}

//
// we use this function to see if we have loaded wininet.dll due to a delayload thunk so that we 
// can free it at dll detach and therefore it will cleanup all of its crud
//
STDAPI_(FARPROC) DelayloadNotifyHook(UINT iReason, PDelayLoadInfo pdli)
{
    if (iReason == dliNoteEndProcessing)
    {
        if (pdli        &&
            pdli->szDll &&
            (StrCmpIA("wininet.dll", pdli->szDll) == 0))
        {
            // wininet was loaded!!
            g_hmodWininet = pdli->hmodCur;
        }
    }

    return NULL;
}

//
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
//
const LPCTSTR c_rgszClasses[] = {
    c_szViewClass,                          // dochost.cpp
    URLDL_WNDCLASS,                         // reload.cpp
    c_szShellEmbedding,                     // embed.cpp
    TEXT("CIESplashScreen"),                // splash.cpp
    CWinInetNotify_szWindowClass,           // inetnot.cpp
    OCHOST_CLASS,                           // occtrl.cpp
    TEXT("AutoImageResizeHost"),            // airesize.cpp
    TEXT("MyPicturesHost")                  // mypics.cpp
};

//
//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
//
#define UnregisterWindowClasses() \
    SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses))

// IEUNIX - This function  should be moved to some file used to create 
// shdocvw.dll. While compiling for DLLs mainsoft will #define DllMain
// to the appropriate function being called in generated *_init.c
#if defined(MAINWIN)
STDAPI_(BOOL) DllMain_Internal(HINSTANCE hDll, DWORD dwReason, void *fProcessUnload)
#else
STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, void *fProcessUnload)
#endif
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModule(hDll);

        SetupDelayloadErrorHandler();

        AtlInit(hDll);
        DisableThreadLibraryCalls(hDll);    // perf

        g_hinst = hDll;
        InitializeCriticalSection(&g_csDll);

        MLLoadResources(g_hinst, TEXT("shdoclc.dll"));

        // Don't put it under #ifdef DEBUG
        CcshellGetDebugFlags();

#ifdef DEBUG
        g_TlsMem = TlsAlloc();
        if (IsFlagSet(g_dwBreakFlags, BF_ONLOADED))
        {
            TraceMsg(TF_ALWAYS, "SHDOCVW.DLL has just loaded");
            DEBUG_BREAK;
        }
#endif

        g_fRunningOnNT = IsOS(OS_NT);
        if (g_fRunningOnNT)
            g_bRunOnNT5 = IsOS(OS_WIN2000ORGREATER);
        else
            g_bRunOnMemphis = IsOS(OS_WIN98ORGREATER);

        g_fRunOnFE = GetSystemMetrics(SM_DBCSENABLED);
        g_uiACP = GetACP();

        //
        // Check if the mirroring APIs exist on the current
        // platform.
        //
        g_bMirroredOS = IS_MIRRORING_ENABLED();

#ifdef WINDOWS_ME
        //
        // Check to see if running on BiDi localized Win95
        //
        g_bBiDiW95Loc = IsBiDiLocalizedWin95(FALSE);
#endif // WINDOWS_ME
        

        InitNFCtl();

        // See if perfmode is enabled
        g_dwStopWatchMode = StopWatchMode();

        // Cache a palette handle for use throughout shdocvw
        g_hpalHalftone = SHCreateShellPalette(NULL);

        SHCheckRegistry();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        MLFreeResources(g_hinst);

        if (g_hMutexHistory) 
        {
            CloseHandle(g_hMutexHistory);
            g_hMutexHistory = NULL;
        }

        if (g_hSemBrowserCount)
            CloseHandle(g_hSemBrowserCount);

        if (g_hpalHalftone)
            DeletePalette(g_hpalHalftone);
        if (g_hiconSSL)
            DestroyIcon(g_hiconSSL);
        if (g_hiconOffline)
            DestroyIcon(g_hiconOffline);
        if (g_hiconPrinter)
            DestroyIcon(g_hiconPrinter);

        if (fProcessUnload == NULL)
        {
            // DLL being unloaded, FreeLibrary() (vs process shutdown)
            // at process shutdown time we can't make call outs since 
            // we don't know if those DLLs will still be loaded!

            AtlTerm();

            CUrlHistory_CleanUp();

            if (g_psfInternet)
            {
                // Atomic Release for a C pgm.
                //
                IShellFolder *psfInternet = g_psfInternet;
                g_psfInternet = NULL;
                psfInternet->Release();
            }

            UnregisterWindowClasses();

            if (g_fRunningOnNT && g_hmodWininet)
            {
                // we need to free wininet if it was loaded because of a delayload thunk. 
                //
                // (a) we can only safely do this on NT since on win9x calling FreeLibrary during
                //     process detach can cause a crash (depending on what msvcrt you are using).
                //
                // (b) we only really need to free this module from winlogon.exe's process context 
                //     because when we apply group policy in winlogon, MUST finally free wininet 
                //     so that it will clean up all of its reg key and file handles.
                FreeLibrary(g_hmodWininet);
            }
        }

        SHFusionUninitialize();

        DeleteCriticalSection(&g_csDll);
    }
    return TRUE;
}

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cRefThisDll);
    ASSERT(g_cRefThisDll >= 0);      // don't underflow
}


STDAPI_(UINT) WhichPlatformFORWARD()
{
    return WhichPlatform();
}


// IEUNIX
// CoCreateInstance is #defined as IECreateInstance #ifdef __cplusplus, 
// so I #undef it  here to prevent the recursive call. 
// On Windows it works, because this file is C file.

#ifdef CoCreateInstance
#undef CoCreateInstance
#endif

HRESULT IECreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, void **ppv)
{
#ifndef NO_MARSHALLING
    if (dwClsContext == CLSCTX_INPROC_SERVER) 
    {
#else
    if (dwClsContext & CLSCTX_INPROC_SERVER) 
    {
#endif
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            // Note that we do pointer comparison (instead of IsEuqalGUID)
            if (&rclsid == pcls->pclsid)
            {
                // const -> non-const expclit casting (this is OK)
                IClassFactory* pcf = GET_ICLASSFACTORY(pcls);
                return pcf->CreateInstance(pUnkOuter, riid, ppv);
            }
        }
    }
    // Use SHCoCreateInstanceAC to go through the app compat layer
    return SHCoCreateInstanceAC(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

#ifdef DEBUG

//
//  In DEBUG, make sure every class we register lives in the c_rgszClasses
//  table so we can clean up properly at DLL unload.  NT does not automatically
//  unregister classes when a DLL unloads, so we have to do it manually.
//
STDAPI_(BOOL) SHRegisterClassD(CONST WNDCLASS *pwc)
{
    for (int i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (StrCmpI(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealSHRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

STDAPI_(ATOM) RegisterClassD(CONST WNDCLASS *pwc)
{
    for (int i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (StrCmpI(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow'ing for a window title
//  sends inter-thread WM_GETTEXT messages, which is not obvious.
//
STDAPI_(HWND) FindWindowD(LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    return FindWindowExD(NULL, NULL, lpClassName, lpWindowName);
}

STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    if (lpWindowName) {
        ASSERTNONCRITICAL;
    }
    return RealFindWindowEx(hwndParent, hwndChildAfter, lpClassName, lpWindowName);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\runonnt.c ===
#include "priv.h"

// no wrappers are needed on non-x86 since this is only for win9x interop
#ifdef _X86_

#include <mluisupp.h>

//============================================================================
// This file contains a bunch of Unicode/Ansi thunks to handle calling
// some internal functions that on Windows 95 the strings are Ansi,
// whereas the string on NT are unicode
//============================================================================

// First undefine everything that we are intercepting as to not forward back to us...
#undef ILCreateFromPath
#undef PathCleanupSpec
#undef PathQualify
#undef PathProcessCommand
#undef SHCLSIDFromString
#undef SHGetSpecialFolderPath
#undef SHILCreateFromPath
#undef SHSimpleIDListFromPath
#undef ShellMessageBox
#undef GetFileNameFromBrowse
#undef OpenRegStream
#undef Win32DeleteFile
#undef PathYetAnotherMakeUniqueName
#undef PathResolve
#undef IsLFNDrive
#undef Shell_GetCachedImageIndex
#undef SHRunControlPanel
#undef PickIconDlg
#undef SHCreateDirectory

#if 0
#define TF_THUNK    TF_CUSTOM1
#else
#define TF_THUNK    0
#endif

#define THUNKMSG(psz)   TraceMsg(TF_THUNK, "shdv THUNK::%s", psz)


// FEATURE:: need to properly handle not having ILGetdisplaynameex...
typedef BOOL (*PFNILGETDISPLAYNAMEEX)(LPSHELLFOLDER psfRoot, LPCITEMIDLIST pidl, LPTSTR pszName, int fType);

#ifndef ANSI_SHELL32_ON_UNIX
#define UseUnicodeShell32() (g_fRunningOnNT)
#else
#define UseUnicodeShell32() (FALSE)
#endif


//=================================================================================
// Now the thunks...

int _AorW_SHRunControlPanel(LPCTSTR pszOrig_cmdline, HWND errwnd)
{
    CHAR szPath[MAX_PATH];
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszOrig_cmdline, szPath, ARRAYSIZE(szPath));
        pszOrig_cmdline = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }
    return SHRunControlPanel(pszOrig_cmdline, errwnd);
}

int _AorW_Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    CHAR szPath[MAX_PATH];
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszIconPath, szPath, ARRAYSIZE(szPath));
        pszIconPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }
    return Shell_GetCachedImageIndex(pszIconPath, iIconIndex, uIconFlags);
}

// the reverse, do it for wide strings also..
int _WorA_Shell_GetCachedImageIndex(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    CHAR szPath[MAX_PATH];
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszIconPath, szPath, ARRAYSIZE(szPath));
        pszIconPath = (LPCWSTR)szPath;  // overload the pointer to pass through...
    }
    return Shell_GetCachedImageIndex( (LPCTSTR) pszIconPath, iIconIndex, uIconFlags);
}

// Explicit prototype because only the A/W prototypes exist in the headers
WINSHELLAPI LPITEMIDLIST  WINAPI ILCreateFromPath(LPCTSTR pszPath);

LPITEMIDLIST _AorW_ILCreateFromPath(LPCTSTR pszPath)
{
    CHAR szPath[MAX_PATH];
    THUNKMSG(TEXT("ILCreateFromPath"));
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return ILCreateFromPath(pszPath);
}

int _AorW_PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec)
{
    THUNKMSG(TEXT("PathCleanupSpec"));
    if (!UseUnicodeShell32())
    {
        CHAR szDir[MAX_PATH];
        CHAR szSpec[MAX_PATH];
        LPSTR pszDir2 = szDir;
        int iRet;

        if (pszDir) {
            UnicodeToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        } else {
            pszDir2 = NULL;
        }

        UnicodeToAnsi(pszSpec, szSpec, ARRAYSIZE(szSpec));

        iRet = PathCleanupSpec((LPTSTR)pszDir2, (LPTSTR)szSpec);

        AnsiToUnicode(szSpec, pszSpec, MAX_PATH);
        return iRet;
    }
    else
        return PathCleanupSpec(pszDir, pszSpec);
}

void _AorW_PathQualify(LPTSTR pszDir)
{
    THUNKMSG(TEXT("PathQualify"));
    if (!UseUnicodeShell32())
    {
        CHAR szDir[MAX_PATH];

        UnicodeToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        PathQualify((LPTSTR)szDir);
        AnsiToUnicode(szDir, pszDir, MAX_PATH);
    }
    else
        PathQualify(pszDir);
}

LONG WINAPI _AorW_PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags)
{
    LONG    lReturnValue;

    THUNKMSG(TEXT("PathProcessCommand"));
    if (!UseUnicodeShell32())
    {
        CHAR szSrc[MAX_PATH];
        CHAR szDest[MAX_PATH];

        UnicodeToAnsi(lpSrc, szSrc, ARRAYSIZE(szSrc));
        lReturnValue = PathProcessCommand((LPTSTR)szSrc, (LPTSTR)szDest, iDestMax, dwFlags);
        AnsiToUnicode(szDest, lpDest, iDestMax);
    }
    else
        lReturnValue = PathProcessCommand(lpSrc, lpDest, iDestMax, dwFlags);

    return(lReturnValue);
}

HRESULT _AorW_SHCLSIDFromString(LPCTSTR lpsz, LPCLSID lpclsid)
{
    CHAR szPath[MAX_PATH];
    THUNKMSG(TEXT("SHCLSIDFromString"));
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(lpsz, szPath, ARRAYSIZE(szPath));
        lpsz = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return SHCLSIDFromString(lpsz, lpclsid);
}

#ifndef UNIX
// Explicit prototype because only the A/W prototypes exist in the headers
WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);
#else
#ifdef UNICODE
#define SHGetSpecialFolderPath SHGetSpecialFolderPathW
#else
#define SHGetSpecialFolderPath SHGetSpecialFolderPathA
#endif
#endif

BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR pszPath, int nFolder, BOOL fCreate)
{
    THUNKMSG(TEXT("SHGetSpecialFolderPath"));
    if (!UseUnicodeShell32())
    {
        CHAR szPath[MAX_PATH];
        BOOL fRet = SHGetSpecialFolderPath(hwndOwner, (LPTSTR)szPath, nFolder, fCreate);
        if (fRet)
            AnsiToUnicode(szPath, pszPath, MAX_PATH);
        return fRet;
    }
    else
        return SHGetSpecialFolderPath(hwndOwner, pszPath, nFolder, fCreate);
}

HRESULT _AorW_SHILCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut)
{
    WCHAR wszPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("SHILCreateFromPath"));

    if (pszPath)
    {
        //
        //  Shell32 will blindly copy pszPath into a MAX_PATH buffer.  This
        //  results in a exploitable buffer overrun.  Do not pass more than
        //  MAX_PATH characters.
        //
        if (!UseUnicodeShell32())
        {
            UnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
            pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
        }
        else if (lstrlenW(pszPath) >= MAX_PATH)
        {
            StrCpyN(wszPath, pszPath, ARRAYSIZE(wszPath));
            pszPath = wszPath; // overload the pointer to pass through...
        }
    }

    return SHILCreateFromPath(pszPath, ppidl, rgfInOut);
}

LPITEMIDLIST _AorW_SHSimpleIDListFromPath(LPCTSTR pszPath)
{
    CHAR szPath[MAX_PATH];
    THUNKMSG(TEXT("SHSimpleIDListFromPath"));
    if (!UseUnicodeShell32() && pszPath)
    {
        UnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return SHSimpleIDListFromPath(pszPath);
}


#define TEMP_SMALL_BUF_SZ  256
BOOL WINAPI _AorW_GetFileNameFromBrowse(HWND hwnd, LPTSTR pszFilePath, UINT cchFilePath,
        LPCTSTR pszWorkingDir, LPCTSTR pszDefExt, LPCTSTR pszFilters, LPCTSTR pszTitle)
{
    CHAR    szPath[MAX_PATH];
    CHAR    szDir[MAX_PATH];
    CHAR    szExt[TEMP_SMALL_BUF_SZ];
    CHAR    szFilters[TEMP_SMALL_BUF_SZ*2];
    CHAR    szTitle[TEMP_SMALL_BUF_SZ];
    LPTSTR  pszPath = pszFilePath;
    BOOL    bResult;
    THUNKMSG(TEXT("GetFileNameFromBrowse"));

    // thunk strings to ansi 
    if (!UseUnicodeShell32()) 
    {
        // always move szFilePath stuff to wszPath buffer. Should never be a resourceid.
        UnicodeToAnsi((LPCTSTR)pszFilePath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPTSTR)szPath;
        if (!IS_INTRESOURCE(pszWorkingDir)) //not a resource
        {
            UnicodeToAnsi((LPCTSTR)pszWorkingDir, szDir, ARRAYSIZE(szDir));
            pszWorkingDir = (LPCTSTR)szDir;
        }
        if (!IS_INTRESOURCE(pszDefExt)) //not a resource
        {
            UnicodeToAnsi((LPCTSTR)pszDefExt, szExt, ARRAYSIZE(szExt));
            pszDefExt = (LPCTSTR)szExt;
        }
        if (!IS_INTRESOURCE(pszFilters)) //not a resource
        {
            int l=1;
            while (*(pszFilters+l) != 0 || *(pszFilters+l-1) != 0)
                l++;
            WideCharToMultiByte(CP_ACP, 0, (LPCTSTR)pszFilters, l+1, szFilters,
                                ARRAYSIZE(szFilters), NULL, NULL);
            pszFilters = (LPCTSTR)szFilters;
        }
        if (!IS_INTRESOURCE(pszTitle)) //not a resource
        {
            UnicodeToAnsi((LPCTSTR)pszTitle, szTitle, ARRAYSIZE(szTitle));
            pszTitle = (LPCTSTR)szTitle;
        }
    }

    bResult = GetFileNameFromBrowse(hwnd, pszPath, cchFilePath, pszWorkingDir, pszDefExt, pszFilters, pszTitle);

    if (!UseUnicodeShell32())
    {
        AnsiToUnicode(szPath, pszFilePath, cchFilePath);
    }

    return (bResult);
}

IStream * _AorW_OpenRegStream(HKEY hkey, LPCTSTR pszSubkey, LPCTSTR pszValue, DWORD grfMode)
{
    CHAR szSubkey[MAX_PATH];      // large enough to hold most any name...
    CHAR szValue[MAX_PATH];       // dito.
    if (!UseUnicodeShell32())
    {

        UnicodeToAnsi(pszSubkey, szSubkey, ARRAYSIZE(szSubkey));
        pszSubkey = (LPCTSTR)szSubkey;
        if (pszValue)
        {
            UnicodeToAnsi(pszValue, szValue, ARRAYSIZE(szValue));
            pszValue = (LPCTSTR)szValue;
        }
    }

    return OpenRegStream(hkey, pszSubkey, pszValue, grfMode);

}


BOOL 
_AorW_Win32DeleteFile(LPCTSTR lpszFileName)
{
    CHAR szPath[MAX_PATH];
    THUNKMSG(TEXT("Win32DeleteFile"));
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(lpszFileName, szPath, ARRAYSIZE(szPath));
        lpszFileName = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }
    return Win32DeleteFile(lpszFileName);
}

BOOL
_AorW_PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName,
                                  LPCTSTR pszPath,
                                  LPCTSTR pszShort,
                                  LPCTSTR pszFileSpec)
{
    CHAR szUniqueName[MAX_PATH];
    CHAR szPath[MAX_PATH];
    CHAR szShort[32];
    CHAR szFileSpec[MAX_PATH];
    BOOL fRet;
    THUNKMSG(TEXT("PathYetAnotherMakeUniqueName"));
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...

        if (pszShort)
        {
            UnicodeToAnsi(pszShort, szShort, ARRAYSIZE(szShort));
            pszShort = (LPCTSTR)szShort;  // overload the pointer to pass through...
        }

        if (pszFileSpec)
        {
            UnicodeToAnsi(pszFileSpec, szFileSpec, ARRAYSIZE(szFileSpec));
            pszFileSpec = (LPCTSTR)szFileSpec;  // overload the pointer to pass through...
        }

        fRet = PathYetAnotherMakeUniqueName((LPTSTR)szUniqueName, pszPath, pszShort, pszFileSpec);
        if (fRet)
            AnsiToUnicode(szUniqueName, pszUniqueName, MAX_PATH);

        return fRet;
    }
    else
        return PathYetAnotherMakeUniqueName(pszUniqueName, pszPath, pszShort, pszFileSpec);
}

BOOL
_AorW_PathResolve(LPTSTR lpszPath, LPCTSTR rgpszDirs[], UINT fFlags)
{
    CHAR szPath[MAX_PATH];
    CHAR szDir[MAX_PATH];
    BOOL fRet;
    THUNKMSG(TEXT("PathResolve"));
    if (!UseUnicodeShell32())
    {
        // WARNING!!!
        // Super Hack, we assume dirs has only one element since it's the only case
        // this is called in SHDOCVW.

        UnicodeToAnsi(lpszPath, szPath, ARRAYSIZE(szPath));

        if (rgpszDirs && rgpszDirs[0])
        {
            UnicodeToAnsi(rgpszDirs[0], szDir, ARRAYSIZE(szDir));
            rgpszDirs[0] = (LPCTSTR)szDir;  // overload the pointer to pass through...

            if (rgpszDirs[1])
            {
                AssertMsg(0, TEXT("PathResolve thunk needs to be fixed to handle more than one dirs."));
                rgpszDirs[1] = NULL;
            }
        }

        fRet = PathResolve((LPTSTR)szPath, rgpszDirs, fFlags);
        if (fRet)
            AnsiToUnicode(szPath, lpszPath, MAX_PATH);

        return fRet;
    }
    else
        return PathResolve(lpszPath, rgpszDirs, fFlags);
}


// Explicit prototype because only the A/W prototypes exist in the headers
// For UNIX, the old prototype should be defined, because there is no export
// by ordinal there and IsLFNDrive is exported from shell32 just this way.

#ifndef UNIX
BOOL IsLFNDrive(LPCTSTR pszPath);
#else
#  ifdef UNICODE
#    define IsLFNDrive IsLFNDriveW
#  else
#    define IsLFNDrive IsLFNDriveA
#  endif
#endif

BOOL
_AorW_IsLFNDrive(LPTSTR lpszPath)
{
    CHAR szPath[MAX_PATH];
    THUNKMSG(TEXT("IsLFNDrive"));
    if (!UseUnicodeShell32())
    {
        UnicodeToAnsi(lpszPath, szPath, ARRAYSIZE(szPath));
        return IsLFNDrive((LPCTSTR)szPath);
    }
    return IsLFNDrive((LPCTSTR)lpszPath);
}


int _AorW_PickIconDlg(
    IN     HWND  hwnd, 
    IN OUT LPTSTR pszIconPath, 
    IN     UINT  cchIconPath, 
    IN OUT int * piIconIndex)
{
    int  nRet;

    if (UseUnicodeShell32())
    {
        nRet = PickIconDlg(hwnd, pszIconPath, cchIconPath, piIconIndex);
    }
    else
    {
        CHAR szPath[MAX_PATH];
        UINT cch = ARRAYSIZE(szPath);

        UnicodeToAnsi(pszIconPath, szPath, cch);
        nRet = PickIconDlg(hwnd, (LPTSTR)szPath, cch, piIconIndex);
        AnsiToUnicode(szPath, pszIconPath, cchIconPath);
    }

    return nRet;
}

STDAPI_(int) _AorW_SHCreateDirectory(HWND hwnd, LPCTSTR pszPath)
{
    if (UseUnicodeShell32())
    {
        WCHAR wsz[MAX_PATH];

        SHTCharToUnicode(pszPath, wsz, ARRAYSIZE(wsz));
        return SHCreateDirectory(hwnd, (LPCTSTR)wsz);
    }
    else
    {
        CHAR  sz[MAX_PATH];

        SHTCharToAnsi(pszPath, sz, ARRAYSIZE(sz));
        return SHCreateDirectory(hwnd, (LPCTSTR)sz);
    }
}

#endif  // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\resource.h ===
/***************************************************************************/
/* WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! */
/***************************************************************************/
/* As part of the shdocvw/browseui split, parts of this file are moving to */
/* shell32 (#ifdef POSTPOSTSPLIT).  Make sure you make your delta to the   */
/* shell32 version if you don't want your changes to be lost!              */
/***************************************************************************/

// Resource IDs for SHDOCVW
//
// Cursor IDs

//  #define IDC_OFFLINE_HAND        103  This has been moved to shlobj.w so
// that ISVs can access it from outside
// Hence you will find it in shlobj.h

// REARCHITECT:CHEE
// these are duplicated with explorer.exe
//
// (no they aren't -raymondc)
//
#define IDS_CHANNEL_UNAVAILABLE 832
#define IDS_BETAEXPIRED         835
#define IDS_FAV_UNABLETOCREATE  833

#define IDS_OPEN                840
#define IDS_SYNCHRONIZE         841
#define IDS_MAKE_OFFLINE        842
#define IDS_VALUE_UNKNOWN       844

#define IDS_DESKTOP             901

// global ids
#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif

#define IDC_GROUPBOX                    300

#define IDC_KBSTART                     305

//
// END REARCHITECT:CHEE
//
//
// Icons in other modules

#define IDI_URL_WEBDOC                  102     // in url.dll
#define IDI_URL_SPLAT                   106     // in url.dll


// Icon IDs (the order of these IDs should be preserved
//  across releases)
//
//
// *** READ THIS BEFORE MODIFYING ICONS ***
// ***
// *** The order of icons is important, as sometimes they
// *** are referenced by INDEX instead of by ID.  This
// *** means that technically, to maintain backward compat
// *** all icons, onced shipped, must stay there and stay
// *** in the same order.  Specifically, icon IDI_CHANNELSAPP (118)
// *** must be at index 18 as ie4 channels.scf references id.
// ***
// *** IE5 already ripped out a bunch of icons, and I'm putting
// *** back just enough to fix this bug.
// ***
//
// #define IDI_HOMEPAGE                 100 // Index:   0   // defined in inc\shdocvw.h
#define IDI_101                         101 //          1
#define IDI_RUNDLG                      102 //          2
#define IDI_SSL                         103 //          3
#define IDI_104                         104 //          4
//#define IDI_OFFLINE                   105 //          5   // defined in inc\shdocvw.h
#define IDI_106                         106 // ICO_CHANNELS in ie4
#define IDI_107                         107 // ICO_FAVORITES in ie4
#define IDI_108                         108 // ICO_SEARCH in ie4
#define IDI_109                         109 // ICO_HISTORY in ie4
#define IDI_STATE_FIRST                 110
//#define IDI_STATE_NORMAL              110 //          10  // defined in inc\shdocvw.h
#define IDI_STATE_FINDINGRESOURCE       111 //          11
#define IDI_STATE_SENDINGREQUEST        112 //          12
#define IDI_STATE_DOWNLOADINGDATA       113 //          13
#define IDI_STATE_LAST                  113
#define IDI_115                         115 // IDI_SUBSCRIPTION in ie4
#define IDI_PRINTER                     116 //          16
#define IDI_117                         117 // IDI_BACK_NONE in ie4
#define IDI_CHANNELSAPP                 118 //          18
#define IDI_154                         154 // IDI_SYSFILE in ie4
#define IDI_FRAME                       190 // IE4 shipped at 101
#define IDI_FAVORITE                    191 // IE4 shipped at 104
#define IDI_200                         200 // ICO_SHOWALL in ie4
#define IDI_201                         201 // ICO_HIDEHIDDEN in ie4
#define IDI_202                         202 // ICO_HIDESYSTEM in ie4
#define IDI_203                         203 // ICO_MULTWIN in ie4
//#define ICO_TREEUP                    204 //              // defined in inc\shdocvw.h
//#define ICO_GLEAM                     205 //              // defined in inc\shdocvw.h
#ifndef POSTPOSTSPLIT
#define IDI_NEW_FOLDER                  206
#endif
#define IDI_207                         207 // IDI_FOLDER in ie4
#define IDI_208                         208 // IDI_FOLDERVIEW in ie4
#define IDI_209                         209 // IDI_HTTFILE in ie4
#define IDI_LOCK                        0x31E0
#define IDI_UNLOCK                      0x31E1
#define IDI_USAGE_ICON                  0x31E2
#define IDI_SUGENERIC                   0x3330
#define IDI_REMOTEFLD                   20780
#define IDI_HISTORYDELETE               20782
#define IDI_HISTWEEK                    20783
#define IDI_HISTOPEN                    20784
#define IDI_HISTFOLDER                  20785
#define IDI_HISTURL                     20786
// ***
// *** IE4 shipped all the above icons, so if you want
// *** to add new ones, you should must add them
// *** after id 20786
// ***

#define IDI_FORTEZZA                    20788
#define IDI_STATE_SCRIPTERROR           20789
#define IDI_PRIVACY                     20790
#define IDI_PRIVACY_IMPACT              20793
#define IDI_PRIVACY_WARN                20794
#define IDI_PRIVACY_QUESTION            20795
#define IDI_PRIVACY_BLANK               20796
#define IDI_PRIVACY_XP                  20797

// other stuff
#define HSFBASE                         20480   //  0x5000
#ifdef _HSFOLDER
#define POPUP_CACHECONTEXT_URL          20680
#define POPUP_CONTEXT_URL_VERBSONLY     20681
#define POPUP_HISTORYCONTEXT_URL        20682
#define MENU_HISTORY                    20683
#define MENU_CACHE                      20684


#define IDS_BYTES                       (HSFBASE+515)
#define IDS_ORDERKB                     (HSFBASE+520)
#define IDS_ORDERMB                     (HSFBASE+521)
#define IDS_ORDERGB                     (HSFBASE+522)
#define IDS_ORDERTB                     (HSFBASE+523)

#define IDS_HOSTNAME_COL                (HSFBASE+345)
#define IDS_TIMEPERIOD_COL              (HSFBASE+346)
#define IDS_NAME_COL                    (HSFBASE+347)
#define IDS_ORIGINAL_COL                (HSFBASE+348)
#define IDS_STATUS_COL                  (HSFBASE+349)
#define IDS_SIZE_COL                    (HSFBASE+350)
#define IDS_TYPE_COL                    (HSFBASE+351)
#define IDS_MODIFIED_COL                (HSFBASE+352)
#define IDS_EXPIRES_COL                 (HSFBASE+353)
#define IDS_ACCESSED_COL                (HSFBASE+354)
#define IDS_LASTSYNCED_COL              (HSFBASE+355)
#define IDS_HSFNONE                     (HSFBASE+356)

#define IDS_CACHETYPE                   (HSFBASE+357)

#define IDS_LASTVISITED_COL             (HSFBASE+358)
#define IDS_NUMVISITS_COL               (HSFBASE+359)
#define IDS_WHATSNEW_COL                (HSFBASE+360)
#define IDS_DESCRIPTION_COL             (HSFBASE+361)
#define IDS_AUTHOR_COL                  (HSFBASE+362)
#define IDS_TITLE_COL                   (HSFBASE+363)
#define IDS_LASTUPDATED_COL             (HSFBASE+364)
#define IDS_SHORTNAME_COL               (HSFBASE+365)
#define IDS_NOTNETHOST                  (HSFBASE+366)
#define IDS_TODAY                       (HSFBASE+367)
#define IDS_FROMTO                      (HSFBASE+368)
#define IDS_WEEKOF                      (HSFBASE+369)
#define IDS_SITETOOLTIP                 (HSFBASE+370)
#define IDS_DAYTOOLTIP                  (HSFBASE+371)
#define IDS_WEEKTOOLTIP                 (HSFBASE+372)
#define IDS_MISCTOOLTIP                 (HSFBASE+373)
#define IDS_TODAYTOOLTIP                (HSFBASE+374)
#define IDS_WEEKSAGO                    (HSFBASE+375)
#define IDS_LASTWEEK                    (HSFBASE+376)
#define IDS_FILE_TYPE                   (HSFBASE+377)
#define IDS_HISTHOST_FMT                (HSFBASE+378)

#define IDM_SORTBYTITLE                 10
#define IDM_SORTBYADDRESS               11
#define IDM_SORTBYVISITED               12
#define IDM_SORTBYUPDATED               13

#define IDM_SORTBYNAME                  20
#define IDM_SORTBYADDRESS2              21
#define IDM_SORTBYSIZE                  22
#define IDM_SORTBYEXPIRES2              23
#define IDM_SORTBYMODIFIED              24
#define IDM_SORTBYACCESSED              25
#define IDM_SORTBYCHECKED               26

#define IDM_MOREINFO                    30

#define IDS_MH_FIRST                    (HSFBASE+400)
#define IDS_MH_TITLE                    IDS_MH_FIRST+IDM_SORTBYTITLE
#define IDS_MH_ADDRESS                  IDS_MH_FIRST+IDM_SORTBYADDRESS
#define IDS_MH_VISITED                  IDS_MH_FIRST+IDM_SORTBYVISITED
#define IDS_MH_UPDATED                  IDS_MH_FIRST+IDM_SORTBYUPDATED
#define IDS_MH_NAME                     IDS_MH_FIRST+IDM_SORTBYNAME
#define IDS_MH_ADDRESS2                 IDS_MH_FIRST+IDM_SORTBYADDRESS2
#define IDS_MH_SIZE                     IDS_MH_FIRST+IDM_SORTBYSIZE
#define IDS_MH_EXPIRES2                 IDS_MH_FIRST+IDM_SORTBYEXPIRES2
#define IDS_MH_MODIFIED                 IDS_MH_FIRST+IDM_SORTBYMODIFIED
#define IDS_MH_ACCESSED                 IDS_MH_FIRST+IDM_SORTBYACCESSED
#define IDS_MH_CHECKED                  IDS_MH_FIRST+IDM_SORTBYCHECKED


#define  RSVIDM_FIRST                   1
#define  RSVIDM_OPEN                    RSVIDM_FIRST+0
#define  RSVIDM_COPY                    RSVIDM_FIRST+1
#define  RSVIDM_DELCACHE                RSVIDM_FIRST+2
#define  RSVIDM_PROPERTIES              RSVIDM_FIRST+3
#define  RSVIDM_NEWFOLDER               RSVIDM_FIRST+4
#define  RSVIDM_ADDTOFAVORITES          RSVIDM_FIRST+5
#define  RSVIDM_OPEN_NEWWINDOW          RSVIDM_FIRST+6
#define  RSVIDM_EXPAND                  RSVIDM_FIRST+7
#define  RSVIDM_COLLAPSE                RSVIDM_FIRST+8
#define  RSVIDM_LAST                    RSVIDM_COLLAPSE /* Adjust me if you add new RSVIDM_s. */

#define IDS_SB_FIRST                    (HSFBASE+380)
#define IDS_SB_OPEN                     IDS_SB_FIRST+RSVIDM_OPEN
#define IDS_SB_COPY                     IDS_SB_FIRST+RSVIDM_COPY
#define IDS_SB_DELETE                   IDS_SB_FIRST+RSVIDM_DELCACHE
#define IDS_SB_PROPERTIES               IDS_SB_FIRST+RSVIDM_PROPERTIES

#define IDS_WARN_DELETE_HISTORYITEM     (HSFBASE+500)
#define IDS_WARN_DELETE_MULTIHISTORY    (HSFBASE+501)
#define IDS_WARN_DELETE_CACHE           (HSFBASE+502)

#define DLG_CACHEITEMPROP               21080
#define IDD_ITEMICON                    21081
#define IDD_FILETYPE_TXT                21084
#define IDD_FILETYPE                    21085
#define IDD_FILESIZE                    21087
#define IDD_LINE_2                      21088
#define IDD_EXPIRES                     21092
#define IDD_LASTMODIFIED                21094
#define IDD_LASTACCESSED                21096
#define IDD_TITLE                       21097

#define DLG_HISTITEMPROP                21180

#define IDD_INTERNET_ADDRESS            21280
#define IDD_LAST_VISITED                21281
#define IDD_LAST_UPDATED                21282
#define IDD_HSFURL                      21283
#define IDD_LAST_ACCESSED               21284
#define IDD_LAST_MODIFIED               21285
#define IDD_CACHE_NAME                  21286
#define IDD_NUMHITS                     21287

#define DLG_HISTCACHE_WARNING           21380
#define IDD_TEXT4                       21382

#endif

#ifndef POSTPOSTSPLIT
#define IDD_ADDTOFAVORITES_TEMPLATE     21400

#if 0
#define IDD_ADDTOCHANNELS_TEMPLATE      21401
#define IDD_ACTIVATE_PLATINUM_CHANNEL   21402
#define IDD_SUBSCRIBE_FAV_CHANNEL       21403
#define IDD_SUBSCRIBE_FAVORITE          21404
#define IDD_ADDTOSOFTDISTCHANNELS_TEMPLATE  21405
#endif

#define IDC_SUBSCRIBE_CUSTOMIZE         1004

#define IDC_FAVORITE_NAME               1005
#define IDC_FAVORITE_CREATEIN           1006
#define IDC_FAVORITE_NEWFOLDER          1007
#define IDC_FAVORITE_ICON               1008

#define IDC_CHANNEL_NAME                1009
#define IDC_CHANNEL_URL                 1010
#define IDC_FOLDERLISTSTATIC            1011
#define IDC_NAMESTATIC                  1012

#endif
    //control id's for next 3 are important -- they're the id's
    //of the same object (non-placeholder) in dialog created
    //by SHBrowseForFolder.  REVIEW!
#define IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER 0x3741
#define IDOK_PLACEHOLDER                0001
#define IDCANCEL_PLACEHOLDER            0002


#define IDM_CLOSE               FCIDM_LAST + 0x0011

#define HELP_ITEM_COUNT         10

#define IDS_HELP_FIRST          0x4000
#define IDS_HELP_OF(id)         ((id - DVIDM_FIRST)+IDS_HELP_FIRST)
#define IDS_HELP_OPEN           IDS_HELP_OF(DVIDM_OPEN           )
#define IDS_HELP_SAVE           IDS_HELP_OF(DVIDM_SAVE           )
#define IDS_HELP_SAVEASFILE     IDS_HELP_OF(DVIDM_SAVEASFILE     )
#define IDS_HELP_PAGESETUP      IDS_HELP_OF(DVIDM_PAGESETUP      )
#define IDS_HELP_PRINT          IDS_HELP_OF(DVIDM_PRINT          )
#define IDS_HELP_SEND           IDS_HELP_OF(DVIDM_SEND           )
#define IDS_HELP_SENDPAGE       IDS_HELP_OF(DVIDM_SENDPAGE       )
#define IDS_HELP_SENDSHORTCUT   IDS_HELP_OF(DVIDM_SENDSHORTCUT   )
#define IDS_HELP_SENDTODESKTOP  IDS_HELP_OF(DVIDM_DESKTOPSHORTCUT)
#define IDS_HELP_IMPORTEXPORT   IDS_HELP_OF(DVIDM_IMPORTEXPORT   )
#define IDS_HELP_PROPERTIES     IDS_HELP_OF(DVIDM_PROPERTIES     )
#define IDS_HELP_CUT            IDS_HELP_OF(DVIDM_CUT            )
#define IDS_HELP_COPY           IDS_HELP_OF(DVIDM_COPY           )
#define IDS_HELP_PASTE          IDS_HELP_OF(DVIDM_PASTE          )
#define IDS_HELP_STOPDOWNLOAD   IDS_HELP_OF(DVIDM_STOPDOWNLOAD   )
#define IDS_HELP_REFRESH        IDS_HELP_OF(DVIDM_REFRESH        )
#define IDS_HELP_GOHOME         IDS_HELP_OF(DVIDM_GOHOME         )
#define IDS_HELP_GOSEARCH       IDS_HELP_OF(DVIDM_GOSEARCH       )
#define IDS_HELP_NEWWINDOW      IDS_HELP_OF(DVIDM_NEWWINDOW      )
#define IDS_HELP_PRINTPREVIEW   IDS_HELP_OF(DVIDM_PRINTPREVIEW   )
#define IDS_HELP_PRINTFRAME     IDS_HELP_OF(DVIDM_PRINTFRAME     )
#define IDS_HELP_NEWMESSAGE     IDS_HELP_OF(DVIDM_NEWMESSAGE     )
#define IDS_HELP_DHFAVORITES    IDS_HELP_OF(DVIDM_DHFAVORITES    )
#define IDS_HELP_HELPABOUT      IDS_HELP_OF(DVIDM_HELPABOUT      )
#define IDS_HELP_HELPSEARCH     IDS_HELP_OF(DVIDM_HELPSEARCH     )
#define IDS_HELP_HELPTUTORIAL   IDS_HELP_OF(DVIDM_HELPTUTORIAL   )
#define IDS_HELP_HELPMSWEB      IDS_HELP_OF(DVIDM_HELPMSWEB      )

#define IDS_HELP_NEW            IDS_HELP_OF(DVIDM_NEW            )
#define IDS_HELP_NEWPOST        IDS_HELP_OF(DVIDM_NEWPOST        )
#define IDS_HELP_NEWAPPOINTMENT IDS_HELP_OF(DVIDM_NEWAPPOINTMENT )
#define IDS_HELP_NEWMEETING     IDS_HELP_OF(DVIDM_NEWMEETING     )
#define IDS_HELP_NEWCONTACT     IDS_HELP_OF(DVIDM_NEWCONTACT     )
#define IDS_HELP_NEWTASK        IDS_HELP_OF(DVIDM_NEWTASK        )
#define IDS_HELP_NEWTASKREQUEST IDS_HELP_OF(DVIDM_NEWTASKREQUEST )
#define IDS_HELP_NEWJOURNAL     IDS_HELP_OF(DVIDM_NEWJOURNAL     )
#define IDS_HELP_NEWNOTE        IDS_HELP_OF(DVIDM_NEWNOTE        )
#define IDS_HELP_CALL           IDS_HELP_OF(DVIDM_CALL           )

#define FCIDM_HELPNETSCAPEUSERS (DVIDM_HELPMSWEB+11)
#define FCIDM_HELPONLINESUPPORT (DVIDM_HELPMSWEB+4)
#define FCIDM_HELPSENDFEEDBACK  (DVIDM_HELPMSWEB+5)
#define FCIDM_PRODUCTUPDATES    (DVIDM_HELPMSWEB+2)

#define IDS_HELP_HELPNETSCAPEUSERS  IDS_HELP_OF(FCIDM_HELPNETSCAPEUSERS)
#define IDS_HELP_HELPONLINESUPPORT  IDS_HELP_OF(FCIDM_HELPONLINESUPPORT)
#define IDS_HELP_HELPSENDFEEDBACK   IDS_HELP_OF(FCIDM_HELPSENDFEEDBACK)
#define IDS_HELP_PRODUCTUPDATES     IDS_HELP_OF(FCIDM_PRODUCTUPDATES)
#define IDS_HELP_ADDTOFAVORITES     IDS_HELP_OF(FCIDM_ADDTOFAVORITES)
#define IDS_HELP_ORGANIZEFAVORITES  IDS_HELP_OF(FCIDM_ORGANIZEFAVORITES)



#define IDS_MAYSAVEDOCUMENT     0x201
#define IDS_CANTACCESSDOCUMENT  0x202


#define IDS_SSL40               0x205
#define IDS_SSL128              0x206
#define IDS_SSL_FORTEZZA        0x207
#define IDS_SSL56               0x208

// END
//

// We pull this resource from browseui.  Don't change this ID unless
// you change browseui to match!!!  [Similar note in browseui]
#define IDB_IEBRAND             0x130


#define DELTA_HOT 1                     // HOT icons are def icons +1

#define IDB_CLASSIC_IETOOLBAR           0x145
#define IDB_CLASSIC_IETOOLBARHOT        0x146   // IDB_IETOOLBAR + DELTA_HOT
#define IDB_CLASSIC_IETOOLBAR16         0x147
#define IDB_CLASSIC_IETOOLBARHOT16      0x148   // IDB_IETOOLBAR16 + DELTA_HOT
#define IDB_CLASSIC_IETOOLBARHICOLOR    0x149
#define IDB_CLASSIC_IETOOLBARHOTHICOLOR 0x14A   // IDB_IETOOLBARHICOLOR + DELTA_HOT


#define IDS_BROWSER_TB_LABELS   0x14F   // string table for cut copy paste encoding

// For splash screen
#define IDB_SPLASH_IEXPLORER    0x150
#define IDB_SPLASH_IEXPLORER_HI 0x151
#define IDS_SPLASH_FONT         0x152
#define IDS_SPLASH_STR1         0x153
#define IDS_SPLASH_STR2         0x154
#define IDS_SPLASH_SIZE         0x155
#define IDS_SPLASH_Y1           0x156
#define IDS_SPLASH_Y2           0x157


// constants for download dialogs
#define IDB_DOWNLOAD            0x215

#define IDB_HISTORYANDFAVBANDSDEF  0x216
#define IDB_HISTORYANDFAVBANDSHOT  0x217

// ReBar stuff
#define IDS_SUBSTR_PRD           0x22C
#define IDS_SUBSTR_PVER          0x22D

#define IDS_BAND_MESSAGE         0x232

// OC stuff
//
#define IDS_VERB_EDIT           0x240

// Progress bar text
#define IDS_BINDSTATUS          0x260
#define IDS_BINDSTATUS_FIN      0x261 // (IDS_BINDSTATUS+BINDSTATUS_FINDINGRESOURCE)
#define IDS_BINDSTATUS_CON      0x262 // (IDS_BINDSTATUS+BINDSTATUS_CONNECTING)
#define IDS_BINDSTATUS_RED      0x263 // (IDS_BINDSTATUS+BINDSTATUS_REDIRECTING)
#define IDS_BINDSTATUS_BEG      0x264 // (IDS_BINDSTATUS+BINDSTATUS_BEGINDOWNLOADDATA)
#define IDS_BINDSTATUS_DOW      0x265 // (IDS_BINDSTATUS+BINDSTATUS_DOWNLOADINGDATA  )
#define IDS_BINDSTATUS_END      0x266 // (IDS_BINDSTATUS+BINDSTATUS_ENDDOWNLOADDATA  )
#define IDS_BINDSTATUS_BEGC     0x267 // (IDS_BINDSTATUS+BINDSTATUS_BEGINDOWNLOADCOMPONENTS)
#define IDS_BINDSTATUS_INSC     0x268 // (IDS_BINDSTATUS+BINDSTATUS_INSTALLINGCOMPONENTS        )
#define IDS_BINDSTATUS_ENDC     0x269 // (IDS_BINDSTATUS+BINDSTATUS_ENDDOWNLOADCOMPONENTS)
#define IDS_BINDSTATUS_USEC     0x26a // (IDS_BINDSTATUS+BINDSTATUS_USINGCACHEDCOPY)
#define IDS_BINDSTATUS_SEND     0x26b // (IDS_BINDSTATUS+BINDSTATUS_SENDINGREQUEST )
#define IDS_BINDSTATUS_PROXYDETECTING 0x26c 



// Registration Strings
//


#define IDS_REG_HTTPNAME        0x350
#define IDS_REG_HTTPSNAME       0x351
#define IDS_REG_FTPNAME         0x352
#define IDS_REG_GOPHERNAME      0x353
#define IDS_REG_TELNETNAME      0x354
#define IDS_REG_RLOGINNAME      0x355
#define IDS_REG_TN3270NAME      0x356
#define IDS_REG_MAILTONAME      0x357
#define IDS_REG_NEWSNAME        0x358
#define IDS_REG_FILENAME        0x359
#define IDS_REG_INTSHNAME       0x35a
#define IDS_REG_THEINTERNET     0x35b
#define IDS_REG_URLEXECHOOK     0x35c
#define IDS_REG_OPEN            0x35d
#define IDS_REG_OPENSAME        0x35e
#define IDS_REG_SCFTYPENAME     0x35f
#define IDS_RELATEDSITESMENUTEXT    0x360   // 864
#define IDS_RELATEDSITESSTATUSBAR   0x361   // 865
#define IDS_RELATEDSITESBUTTONTEXT  0x362   // 866
#define IDS_TIPOFTHEDAYTEXT         0x363   // 867
#define IDS_TIPOFTHEDAYSTATUSBAR    0x364   // 868

#define IDS_INTERNETEXPLORER        0x370   // 880
#define IDS_INTERNETEXPLORER_TIP    0x371   // 881

////  3d0- 420 reserved for quick links

#define IDS_TYPELIB             0x4f0
#define IDS_SHELLEXPLORER       0x4f1
//                              0x4f2

#define IDS_CATDESKBAND         0x502

#define IDS_CATINFOBAND         0x504

#define IDS_CATCOMMBAND         0x509

#define IDS_ERRMSG_FIRST        0x1000
#define IDS_ERRMSG_LAST         0x1fff

// OC Bitmaps
//
#define IDB_FOLDER              0x101 // used in selfreg.inf
#define IDB_FOLDERVIEW          0x104 // used in selfreg.inf

// Dialog Boxes
#define DLG_DOWNLOADPROGRESS    0x1100
#define IDD_ANIMATE             0x1101
#define IDD_NAME                0x1102
#define IDD_OPENIT              0x1103
#define IDD_PROBAR              0x1104
#define IDD_TIMEEST             0x1105
#define IDD_SAVEAS              0x1106
#define IDD_DOWNLOADICON        0x1107
#define IDD_NOFILESIZE          0x1109
#define IDD_TRANSFERRATE        0x1110
#define IDD_DIR                 0x1112
#define IDD_DISMISS             0x1113
#define IDD_DNLDCOMPLETEICON    0x1114
#define IDD_DNLDCOMPLETETEXT    0x1115
#define IDD_DNLDESTTIME         0x1116
#define IDD_DNLDTIME            0x1117
#define IDD_BROWSEDIR           0x1118
#define IDD_OPENFILE            0x1119

#define DLG_SAFEOPEN            0x1140
#define IDC_SAFEOPEN_ICON       0x1141
#define IDC_SAFEOPEN_FILENAME   0x1142
#define IDC_SAFEOPEN_AUTOOPEN   0x1143
#define IDC_SAFEOPEN_AUTOSAVE   0x1144
#define IDC_SAFEOPEN_ALWAYS     0x1145
#define IDC_SAFEOPEN_FILETYPE   0x1146
#define IDC_SAFEOPEN_FILEFROM   0x1147
#define IDC_SAFEOPEN_WARNICON   0x1148
#define IDC_SAFEOPEN_WARNTEXT   0x1149

#define IDD_ASSOC               0x1160
#define IDC_ASSOC_CHECK         0x1161
#define IDC_ASSOC_IE40          0x1163

#define IDD_PRINTOPTIONS        0x1165

#define DLG_RUN                 0x1170
#define IDD_ICON                0x1171
#define IDD_PROMPT              0x1172
#define IDD_COMMAND             0x1173
#define IDD_RUNDLGOPENPROMPT    0x1174
#define IDD_BROWSE              0x1175
#define IDC_ASWEBFOLDER         0x1176

#define DLG_NEWFOLDER           0x1180
#define IDD_SUBSCRIBE           0x1185

// UNIX only
#define DLG_RUNMOTIF            0x1187


// Resources for Internet Shortcut dialogs

#define IDD_INTSHCUT_PROP               1048
#undef IDC_ICON         // The one defined in winuser is obsolete
#define IDC_ICON                        1002
#define IDC_NAME                        1003
#define IDC_URL_TEXT                    1004
#define IDC_URL                         1005
#define IDC_HOTKEY_TEXT                 1006
#define IDC_START_IN_TEXT               1007
#define IDC_START_IN                    1008
#define IDC_SHOW_CMD                    1009
#define IDC_CHANGE_ICON                 1010
#define IDC_HOTKEY                      1011

#define IDC_WHATSNEW                    1011
#define IDC_RATING                      1012
#define IDC_AUTHOR                      1013
#define IDC_LAST_VISITED                1014
#define IDC_LAST_MODIFIED               1015
#define IDC_VISITCOUNT                  1016
#define IDC_DESC                        1017

#define IDC_VISITS_TEXT                 1018
#define IDC_VISITS                      1019
#define IDC_MAKE_OFFLINE                1020
#define IDC_SUMMARY                     1021
#define IDC_LAST_SYNC_TEXT              1022
#define IDC_LAST_SYNC                   1023
#define IDC_DOWNLOAD_SIZE_TEXT          1024
#define IDC_DOWNLOAD_SIZE               1025
#define IDC_DOWNLOAD_RESULT_TEXT        1026
#define IDC_DOWNLOAD_RESULT             1027
#define IDC_FAVORITE_DESC               1028
#define IDC_FREESPACE_TEXT              1029

#define IDS_ALLFILES                    1200
#define IDS_BROWSEFILTER                1201
#define IDS_DOWNLOADFAILED              1202
#define IDS_TRANSFERRATE                1203
#define IDS_DOWNLOADTOCACHE             1204
#define IDS_UNTITLE_SHORTCUT            1205
#define IDS_SECURITYALERT               1206
#define IDS_DOWNLOADDISALLOWED          1207
// unused - recycle me                  1208
#define IDS_URL_SEARCH_KEY              1210
#define IDS_SEARCH_URL                  1211
#define IDS_SEARCH_SUBSTITUTIONS        1212
#define IDS_SHURL_ERR_PARSE_NOTALLOWED  1213
#define IDS_SEARCH_INTRANETURL          1214

// UNIX only
#define IDS_SHURL_ERR_NOASSOC           1215
#define IDS_DOWNLOAD_BADCACHE           1216


#define IDS_SETHOME_TITLE               1220
#define IDS_SETHOME_TEXT                1221

// Warning strings must be sequential.
#define IDS_ADDTOFAV_WARNING            1230
#define IDS_ADDTOLINKS_WARNING          1231
#define IDS_MAKEHOME_WARNING            1232
#define IDS_DROP_WARNING                1233

#define IDS_CONFIRM_RESET_SAFEMODE      1526

// Internet shortcut-related IDs
#define IDS_SHORT_NEW_INTSHCUT              0x2730
#define IDS_NEW_INTSHCUT                    0x2731
#define IDS_INVALID_URL_SYNTAX              0x2732
#define IDS_UNREGISTERED_PROTOCOL           0x2733
#define IDS_SHORTCUT_ERROR_TITLE            0x2734
#define IDS_IS_EXEC_FAILED                  0x2735
#define IDS_IS_EXEC_OUT_OF_MEMORY           0x2736
#define IDS_IS_EXEC_UNREGISTERED_PROTOCOL   0x2737
#define IDS_IS_EXEC_INVALID_SYNTAX          0x2738
#define IDS_IS_LOADFROMFILE_FAILED          0x2739
#define IDS_INTERNET_SHORTCUT               0x273E
#define IDS_URL_DESC_FORMAT                 0x273F
#define IDS_FAV_LASTVISIT                   0x2740
#define IDS_FAV_LASTMOD                     0x2741
#define IDS_FAV_WHATSNEW                    0x2742
#define IDS_IS_APPLY_FAILED                 0x2744
#define IDS_FAV_STRING                      0x2745

#define IDS_AUTHOR                          0x2746
#define IDS_SUBJECT                         0x2747
#define IDS_COMMENTS                        0x2748
#define IDS_DOCTITLE                        0x2749

#define IDS_MENUOPEN                        0x2800
#define IDS_MENUOPENHOMEPAGE                0x2801

// Open Web Folder Dialogs
#define IDS_ERRORINTERNAL                   0x2940

// Internet shortcut menu help
#define IDS_MH_ISFIRST                      0x2750
#define IDS_MH_OPEN                         (IDS_MH_ISFIRST + 0)
#define IDS_MH_SYNCHRONIZE                  (IDS_MH_ISFIRST + 1)
#define IDS_MH_MAKE_OFFLINE                 (IDS_MH_ISFIRST + 2)

// AVI
#define IDA_DOWNLOAD            0x100




//---------------------------------------------------------------------------
// Defines for the rc file.
//---------------------------------------------------------------------------

// REARCHITECT: these are duplicated in browseui

// Commmand ID
#define FCIDM_FIRST             FCIDM_GLOBALFIRST
#define FCIDM_LAST              FCIDM_BROWSERLAST

#define FCIDM_BROWSER_EXPLORE   (FCIDM_BROWSERFIRST + 0x0120)

#define FCIDM_BROWSER_FILE      (FCIDM_BROWSERFIRST+0x0020)
#define FCIDM_PREVIOUSFOLDER    (FCIDM_BROWSER_FILE+0x0002) // shbrowse::EXEC (cannot change)
#define FCIDM_DELETE            (FCIDM_BROWSER_FILE+0x0003)
#define FCIDM_RENAME            (FCIDM_BROWSER_FILE+0x0004)
#define FCIDM_PROPERTIES        (FCIDM_BROWSER_FILE+0x0005)

#define FCIDM_BROWSER_EDIT      (FCIDM_BROWSERFIRST+0x0040)
#define FCIDM_MOVE              (FCIDM_BROWSER_EDIT+0x0001)
#define FCIDM_COPY              (FCIDM_BROWSER_EDIT+0x0002)
#define FCIDM_PASTE             (FCIDM_BROWSER_EDIT+0x0003)
#define FCIDM_LINK              (FCIDM_BROWSER_EDIT+0x0005)     // create shortcut

#define FCIDM_FAVS_FIRST        (FCIDM_BROWSER_EXPLORE  +0x0052)
#define FCIDM_ORGANIZEFAVORITES (FCIDM_FAVS_FIRST       +0x0000)
#define FCIDM_ADDTOFAVORITES    (FCIDM_FAVS_FIRST       +0x0001)
#define FCIDM_FAVS_MORE         (FCIDM_FAVS_FIRST       +0x0002)
#define FCIDM_FAVORITEFIRST     (FCIDM_FAVS_FIRST       +0x0003)
#define FCIDM_UPDATESUBSCRIPTIONS (FCIDM_FAVS_FIRST       +0x0004)
#define FCIDM_SORTBY            (FCIDM_FAVS_FIRST       +0x0005)
#define FCIDM_SORTBYNAME        (FCIDM_FAVS_FIRST       +0x0006)
#define FCIDM_SORTBYVISIT       (FCIDM_FAVS_FIRST       +0x0007)
#define FCIDM_SORTBYDATE        (FCIDM_FAVS_FIRST       +0x0008)
#define FCIDM_FAVAUTOARRANGE    (FCIDM_FAVS_FIRST       +0x0009)
#define FCIDM_SUBSCRIPTIONS     (FCIDM_FAVS_FIRST       +0x000A)
#define FCIDM_SUBSCRIBE         (FCIDM_FAVS_FIRST       +0x000B)

#define FCIDM_FAVORITELAST      (FCIDM_FAVORITEFIRST    +0x0050)
#define FCIDM_FAVORITE_ITEM     (FCIDM_FAVORITEFIRST + 0)
#define FCIDM_FAVORITECMDFIRST  (FCIDM_FAVS_FIRST)
#define FCIDM_FAVORITECMDLAST   (FCIDM_FAVORITELAST)
#define FCIDM_FAVS_LAST         (FCIDM_FAVORITELAST)


//---------------------------------------------------------------------------
#define FCIDM_BROWSER_VIEW      (FCIDM_BROWSERFIRST + 0x0200)
#define FCIDM_VIEWTOOLBAR       (FCIDM_BROWSER_VIEW + 0x0001)
#define FCIDM_VIEWSTATUSBAR     (FCIDM_BROWSER_VIEW + 0x0002)
#define FCIDM_VIEWOPTIONS       (FCIDM_BROWSER_VIEW + 0x0003)
#define FCIDM_VIEWTOOLS         (FCIDM_BROWSER_VIEW + 0x0004)
#define FCIDM_VIEWADDRESS       (FCIDM_BROWSER_VIEW + 0x0005)
#define FCIDM_VIEWLINKS         (FCIDM_BROWSER_VIEW + 0x0006)
#define FCIDM_VIEWTEXTLABELS    (FCIDM_BROWSER_VIEW + 0x0007)
#define FCIDM_VIEWTBCUST        (FCIDM_BROWSER_VIEW + 0x0008)
#define FCIDM_VIEWAUTOHIDE      (FCIDM_BROWSER_VIEW + 0x0009)
#define FCIDM_VIEWMENU          (FCIDM_BROWSER_VIEW + 0x000A)

#define FCIDM_STOP              (FCIDM_BROWSER_VIEW + 0x001a)
#define FCIDM_REFRESH           (FCIDM_BROWSER_VIEW + 0x0020) // ie4 shell32: must be A220 (cannot change)
#define FCIDM_ADDTOFAVNOUI      (FCIDM_BROWSER_VIEW + 0x0021)
#define FCIDM_VIEWITBAR         (FCIDM_BROWSER_VIEW + 0x0022)
#define FCIDM_VIEWSEARCH        (FCIDM_BROWSER_VIEW + 0x0017)
#define FCIDM_CUSTOMIZEFOLDER   (FCIDM_BROWSER_VIEW + 0x0018)
#define FCIDM_VIEWFONTS         (FCIDM_BROWSER_VIEW + 0x0019)
// 1a is FCIDM_STOP
#define FCIDM_THEATER           (FCIDM_BROWSER_VIEW + 0x001b)
#define FCIDM_JAVACONSOLE       (FCIDM_BROWSER_VIEW + 0x001c)
// 1d - FCIDM_VIEWTOOLBARCUSTOMIZE
#define FCIDM_ENCODING          (FCIDM_BROWSER_VIEW + 0x001e)
// (FCIDM_BROWSER_VIEW + 0x0030) through
// (FCIDM_BROWSER_VIEW + 0x003f) is taken

// Define string ids that go into resource file
#define IDS_CHANNEL             0x503

#define IDS_SUBS_UNKNOWN        711
#ifndef POSTPOSTSPLIT
#define IDS_NEED_CHANNEL_PASSWORD     716
#endif


// REARCHITECT: these are duplciated in browseui
#define IDS_TITLE       723
#define IDS_ERROR_GOTO  724
// END

#define IDS_NONE        725
#define IDS_NAME        726     // Used for NAME member function for fram programmability

#define IDS_INVALIDURL   727    // Generic error message in OnStopBinding
#define IDS_CANTDOWNLOAD 728
#define IDS_TARGETFILE   730    // String for target file of downloading
#define IDS_DOWNLOADCOMPLETE 731 // Download completed

#define IDS_CREATE_SHORTCUT_MSG 734
#define IDS_UNDEFINEDERR 735
#define IDS_SAVING       736
#define IDS_OPENING      737

#define IDS_ESTIMATE    738     // Estimated time string for progress (B/sec)
// 739 below
#define IDS_SAVED       740
#define IDS_BYTESCOPIED 741     // Progress text when ulMax is 0 (unknown)
#define IDS_DEF_UPDATE  742
#define IDS_DEF_CHANNELGUIDE 743
#define IDS_DOCUMENT    744
#define IDS_ERR_OLESVR  745     // CoCreateInstance failed.
#define IDS_ERR_LOAD    746     // IPersistFile::Load failed.

#ifndef POSTPOSTSPLIT
#define IDS_FAVORITES          749
#define IDS_FAVORITEBROWSE     748

#define IDS_FAVS_SUBSCRIBE_TEXT 718
#define IDS_FAVS_SUBSCRIBE      719
#define IDS_FAVS_ADVANCED      753
#define IDS_FAVS_ADDTOFAVORITES 757
#define IDS_FAVS_FILEEXISTS     794
#define IDS_FAVS_INVALIDFN      795
#define IDS_FAVS_ADVANCED_EXPAND   812
#define IDS_FAVS_ADVANCED_COLLAPSE 813
#define IDS_FAVS_FNTOOLONG      810


#define IDS_EXCEPTIONMSGSH 739
#define IDS_EXCEPTIONMSG        754
#define IDS_EXCEPTIONNOMEMORY   755
#endif

#define IDS_CANTSHELLEX         756     // Shell Execute on the URL failed

#define IDS_TITLEBYTES          760   // Download title with % loaded
#define IDS_TITLEPERCENT        761     // Download title with bytes copied
#define IDS_HELPTUTORIAL        762

#define IDS_HELPMSWEB           763
// Don't use 763=779 because they are used by HELPMSWEB strings

// Don't use 780=790 because they wil be used by different URLs used in the product

#define IDS_DEFDLGTITLE         790

#define IDS_EXCHANGE            791 // Exchange mail client display name

#define IDS_CANTFINDURL         793 // Autosearching prompt on failed navigation

#ifndef POSTPOSTSPLIT
#define IDS_CHANNELS_FILEEXISTS 796
#endif
#define IDS_BYTESTIME           797
#define IDS_CANTFINDSEARCH      799
#define IDS_CLOSE               800
#define IDS_EXTDOCUMENT         811

#define IDS_OPENFROMINTERNET    920
#define IDS_SAVEFILETODISK      921
#define IDS_SAFEOPENPROMPT      922

// Coolbar String IDs - starting from 950

////////////////// WARNING!!!  /////////////////
///  IDS_QLURL1 MUST be 1000, IDS_QLTEXT1 MUST BE 1010
// inetcpl depends on it ..  -Chee
// also, inetcpl hard codes that there are 5 quicklinks!
#define IDS_DEF_HOME    998  //// WARNING!!! DO NOT CHANGE THESE VALUES
#define IDS_DEF_SEARCH  999 //// WARNING!!!  INETCPL RELIES ON THEM

//////////////////////// END WARNING! //////////////////////


#define IDS_FOLDEROPTIONS       1030
#define IDS_INTERNETOPTIONS     1031


#define IDS_CONFIRM_RESETFLAG           1060

// Accelerator ID

#define ACCEL_DOCVIEW             0x101
#define ACCEL_DOCVIEW_NOFILEMENU  0x102
#define ACCEL_FAVBAR              0x103

#define MID_FOCUS               0x102

#define MENU_SCRDEBUG                   0x103


//#ifdef DEBUG
#define ALPHA_WARNING_IS_DUMB
//#endif

#ifndef ALPHA_WARNING_IS_DUMB
#define IDS_ALPHAWARNING        0x2000
#endif



// Title for properties dialog
#define IDS_INTERNETSECURITY    0x2003
// ID for running uninstall stubs
#define IDS_UNINSTALL         0x3010

#define IDS_CONFIRM_SCRIPT_CLOSE_TEXT 0x3035

// OPSProfile strings (0x3100 to 0x31BF)
#define IDR_TRACK                       0x3101

#define IDS_OPS_REQUEST                 0x3100
#define IDS_PROFILE_ASSISTANT           0x3101
#define IDS_OPS_CONFIRM                 0x3102
#define IDS_OPS_BLANK                   0x3103
#define IDS_OPS_NO_INFORMATION          0x3104

#define IDS_DEFAULT_FNAME               0x3140

#define IDS_OPS_COMMONNAME              0x3150
#define IDS_OPS_GIVENNAME               0x3151
#define IDS_OPS_LASTNAME                0x3152
#define IDS_OPS_MIDDLENAME              0x3153
#define IDS_OPS_GENDER                  0x3154
#define IDS_OPS_CELLULAR                0x3155
#define IDS_OPS_EMAIL                   0x3156
#define IDS_OPS_URL                     0x3157

#define IDS_OPS_COMPANY                 0x3158
#define IDS_OPS_DEPARTMENT              0x3159
#define IDS_OPS_JOBTITLE                0x315a
#define IDS_OPS_PAGER                   0x315b

#define IDS_OPS_HOME_ADDRESS            0x315c
#define IDS_OPS_HOME_CITY               0x315d
#define IDS_OPS_HOME_ZIPCODE            0x315e
#define IDS_OPS_HOME_STATE              0x315f
#define IDS_OPS_HOME_COUNTRY            0x3160
#define IDS_OPS_HOME_PHONE              0x3161
#define IDS_OPS_HOME_FAX                0x3162

#define IDS_OPS_BUSINESS_ADDRESS        0x3163
#define IDS_OPS_BUSINESS_CITY           0x3164
#define IDS_OPS_BUSINESS_ZIPCODE        0x3165
#define IDS_OPS_BUSINESS_STATE          0x3166
#define IDS_OPS_BUSINESS_COUNTRY        0x3167

#define IDS_OPS_BUSINESS_PHONE          0x3168
#define IDS_OPS_BUSINESS_FAX            0x3169
#define IDS_OPS_BUSINESS_URL            0x316a

#define IDS_OPS_OFFICE                  0x316b

#define IDS_NAVIGATEBACKTO              0x3170
#define IDS_NAVIGATEFORWARDTO           0x3171

// Usage strings. These have to be contiguous
#define IDS_OPS_USAGEUNK                0x31A0
#define IDS_OPS_USAGE0                  0x31A1
#define IDS_OPS_USAGE1                  0x31A2
#define IDS_OPS_USAGE2                  0x31A3
#define IDS_OPS_USAGE3                  0x31A4
#define IDS_OPS_USAGE4                  0x31A5
#define IDS_OPS_USAGE5                  0x31A6
#define IDS_OPS_USAGE6                  0x31A7
#define IDS_OPS_USAGE7                  0x31A8
#define IDS_OPS_USAGE8                  0x31A9
#define IDS_OPS_USAGE9                  0x31AA
#define IDS_OPS_USAGE10                 0x31AB
#define IDS_OPS_USAGE11                 0x31AC
#define IDS_OPS_USAGE12                 0x31AD
#define IDS_OPS_USAGEMAX                0x31AD

// Dialogs and controls.
#define IDD_OPS_CONSENT                 0x3200
#define IDD_OPS_UPDATE                  0x3201

#define IDC_OPS_LIST                    0x3210
#define IDC_VIEW_CERT                   0x3211
#define IDC_USAGE_STRING                0x3212
#define IDC_SITE_IDENTITY               0x3213
#define IDC_SECURITY_ICON               0x3214
#define IDC_USAGE_ICON                  0x3215
#define IDC_SECURE_CONNECTION           0x3216
#define IDC_UNSECURE_CONNECTION         0x3217
#define IDC_OPS_URL                     0x3218
#define IDC_EDIT_PROFILE                0x3219
#define IDC_KEEP_SETTINGS               0x321A
#define IDC_OPS_INFO_REQUESTED          0x321B
#define IDC_OPS_PRIVACY                 0x321C

// AutoSuggest dialogs and controls
#define IDD_AUTOSUGGEST_SAVEPASSWORD    0x3220
#define IDD_AUTOSUGGEST_CHANGEPASSWORD  0x3221
#define IDD_AUTOSUGGEST_DELETEPASSWORD  0x3222
#define IDD_AUTOSUGGEST_ASK_USER        0x3223
#define IDC_AUTOSUGGEST_NEVER           0x3225
#define IDC_AUTOSUGGEST_ICON            0x3226
#define IDA_AUTOSUGGEST                 0x3227
//#define IDI_AUTOSUGGEST                 0x3228
#define IDC_AUTOSUGGEST_HELP            0x324F

// Software Update Advertisment Dialogs
#define IDD_SUAVAILABLE                 0x3300
#define IDD_SUDOWNLOADED               0x3301
#define IDD_SUINSTALLED                0x3302

//ids for DLG_SUAVAIL, DLG_SUDOWNLOAD, DLG_SUINSTALL
#define IDC_ICONHOLD                    0x3310
#define IDC_REMIND                      0x3311
#define IDC_DETAILS                     0x3312
#define IDC_DETAILSTEXT                 0x3313

#define IDS_SUDETAILSFMT                0x3320
#define IDS_SUDETAILSOPEN               0x3321
#define IDS_SUDETAILSCLOSE              0x3322

#define IDS_HISTVIEW_FIRST              0x3331
#define IDS_HISTVIEW_DEFAULT            0x3331
#define IDS_HISTVIEW_SITE               0x3332
#define IDS_HISTVIEW_FREQUENCY          0x3333
#define IDS_HISTVIEW_TODAY              0x3334
#define IDS_HISTVIEW_LAST               0x3335

#define IDS_DONE_WITH_SCRIPT_ERRORS     0x3336
#define IDS_SCRIPT_ERROR_ON_PAGE        0x3337

/* ID for install stub progress dialog (template in \shell\inc\inststub.rc) */
#define IDD_InstallStubProgress         0x3340


// IDs for thicket save
#define IDD_SAVETHICKET                 0x3350
#define IDC_THICKETPROGRESS             0x3351
#define IDC_THICKETSAVING               0x3352
#define IDC_THICKETPCT                  0x3353

#define IDS_THICKETDIRFMT               0x3354
#define IDS_THICKETTEMPFMT              0x3355
#define IDS_THICKET_SAVE                0x3356
#define IDS_NOTHICKET_SAVE              0x3357
#define IDS_UNTITLED                    0x3358

#define IDD_ADDTOSAVE_DIALOG            0x3359
#define IDC_SAVE_CHARSET                0x335A

#define IDS_THICKETERRTITLE             0x335B
#define IDS_THICKETERRMEM               0x335C
#define IDS_THICKETERRMISC              0x335D
#define IDS_THICKETERRACC               0x335E
#define IDS_THICKETERRFULL              0x335F
#define IDS_THICKETABORT                0x3360
#define IDS_THICKETSAVINGFMT            0x3361
#define IDS_THICKETPCTFMT               0x3362
#define IDS_THICKETERRFNF               0x3363
#define IDS_NOMHTML_SAVE                0x3364

#define IDD_ADDTOSAVE_NT5_DIALOG        0x3365

#define IDD_IMPEXP                      0x3380
#define IDC_IMPORT                      0x3381
#define IDC_EXPORT                      0x3382
#define IDC_FAVORITES                   0x3383
#define IDC_BROWSEFORFAVORITES          0x3384

#define IDS_IMPORTCONVERTERROR          0x3385
#define IDS_NOTVALIDBOOKMARKS           0x3386
#define IDS_COULDNTOPENBOOKMARKS        0x3387
#define IDS_IMPORTFAILURE_FAV           0x3388
#define IDS_IMPORTSUCCESS_FAV           0x3389
#define IDS_EXPORTFAILURE_FAV           0x338A
#define IDS_EXPORTSUCCESS_FAV           0x338B
#define IDS_IMPORTFAILURE_COOK          0x338C
#define IDS_IMPORTSUCCESS_COOK          0x338D
#define IDS_EXPORTFAILURE_COOK          0x338E
#define IDS_EXPORTSUCCESS_COOK          0x338F
#define IDS_EXPORTDIALOGTITLE           0x3390
#define IDS_IMPORTDIALOGTITLE           0x3391
#define IDS_INVALIDURLFILE              0x3392
#define IDS_CONFIRM_IMPTTL_FAV          0x3393
#define IDS_CONFIRM_EXPTTL_FAV          0x3394
#define IDS_CONFIRM_IMPTTL_COOK         0x3395
#define IDS_CONFIRM_EXPTTL_COOK         0x3396
#define IDS_CONFIRM_IMPORT              0x3397
#define IDS_CONFIRM_EXPORT              0x3398
#define IDS_IMPORT_DISABLED             0x3399
#define IDS_EXPORT_DISABLED             0x339A
#define IDS_IMPORTEXPORTTITLE           0x339B

// Save-as warning dialog
#define DLG_SAVEAS_WARNING              0x3400
#define IDC_SAVEAS_WARNING_STATIC       0x3401
#define IDC_SAVEAS_WARNING_CB           0x3402
#define IDI_SAVEAS_WARNING              0x3403

// HTML dialog resources
#define RT_FILE                         2110

// Print dialog
#define IDC_LINKED                          8140
#define IDC_PREVIEW                         8141
#define IDC_SHORTCUTS                       8142
#define IDC_SCALING                         8143

// Page setup

#define IDC_HEADERFOOTER                    8145
#define IDC_STATICHEADER                    8146
#define IDC_EDITHEADER                      8147
#define IDC_STATICFOOTER                    8148
#define IDC_EDITFOOTER                      8149

#define IDR_PRINT_PREVIEW               8416
#define IDR_PRINT_PREVIEWONEDOC         8417
#define IDR_PRINT_PREVIEWALLDOCS        8418
#define IDR_PRINT_PREVIEWDISABLED       8422

#define IDS_PRINTTOFILE_TITLE           8419
#define IDS_PRINTTOFILE_OK              8420
#define IDS_PRINTTOFILE_SPEC            8421

///////////////////////////////////////////////////////
// Favorites, nsc, and explorer bars
#define IDS_FAVS_BAR_LABELS     3000
#define IDS_HIST_BAR_LABELS     3001
#define IDI_PINNED              3002
#define IDS_SEARCH_MENUOPT      3003
#define IDS_BAND_FAVORITES      3004
#define IDS_BAND_HISTORY        3005
#define IDS_BAND_CHANNELS       3006

#define IDS_RESTRICTED          3007
#define IDS_BAND_EXPLORER       3008
// (see histBand.cpp for more info...)
#define FCIDM_HISTBAND_FIRST      (FCIDM_BROWSERFIRST   + 0x0180)
#define FCIDM_HISTBAND_VIEW       (FCIDM_HISTBAND_FIRST + 0x0000)
#define FCIDM_HISTBAND_SEARCH     (FCIDM_HISTBAND_FIRST + 0x0001)

#define IDC_EDITHISTSEARCH       3205
#define IDD_HISTSRCH_ANIMATION   3206
#define IDA_HISTSEARCHAVI        3207
#define IDB_HISTSRCH_GO          3208
#define IDC_HISTSRCH_STATIC      3209
#define IDC_HISTCUSTOMLINE       3210

#define DLG_HISTSEARCH2          3211

#define POPUP_CONTEXT_NSC        3400

///////////////////////////////////////////////////////

// Flavors of refresh
#define IDM_REFRESH_TOP                  6041   // Normal refresh, topmost doc
#define IDM_REFRESH_THIS                 6042   // Normal refresh, nearest doc
#define IDM_REFRESH_TOP_FULL             6043   // Full refresh, topmost doc
#define IDM_REFRESH_THIS_FULL            6044   // Full refresh, nearest doc

// placeholder for context menu extensions
#define IDM_MENUEXT_PLACEHOLDER          6047
#define IDR_FORM_CONTEXT_MENU       24640  //0x6040  // bad id - not in core range
#define IDR_BROWSE_CONTEXT_MENU     24641  //0x6041  // bad id - not in core range


#define IDM_DEBUG_TRACETAGS         6004
#define IDM_DEBUG_RESFAIL           6005
#define IDM_DEBUG_DUMPOTRACK        6006
#define IDM_DEBUG_BREAK             6007
#define IDM_DEBUG_VIEW              6008
#define IDM_DEBUG_DUMPTREE          6009
#define IDM_DEBUG_DUMPLINES         6010
#define IDM_DEBUG_LOADHTML          6011
#define IDM_DEBUG_SAVEHTML          6012
#define IDM_DEBUG_MEMMON            6013
#define IDM_DEBUG_METERS            6014
#define IDM_DEBUG_DUMPDISPLAYTREE   6015
#define IDM_DEBUG_DUMPFORMATCACHES  6016
#define IDM_DEBUG_DUMPLAYOUTRECTS   6017


#ifdef UNIX
//EULA related entries
#define IDD_EULA                        0x4000
#define IDC_WIZARD                      0x4001
#define IDC_EULA_TEXT                   0x4002
#define IDC_ACCEPT                      0x4003
#define IDC_DONT_ACCEPT                 0x4004
#define IDC_MORE                        0x4005
#define IDC_BIGFONT                     0x4006
#define IDD_ALPHAWRNDLG                 0x4007
#define IDC_NOFUTUREDISPLAY             0x4008
#define IDC_ALIAS_NAME                  0x4009

#define IDS_NEWS_SCRIPT_ERROR           0x4010
#define IDS_NEWS_SCRIPT_ERROR_TITLE     0x4011

#define IDI_MONOFRAME                   0x4020

#define IDS_NS_BOOKMARKS_DIR               137
#endif


#define IDS_IMPFAVORITES                0x4201
#define IDS_IMPFAVORITESDESC            0x4202
#define IDS_EXPFAVORITES                0x4203
#define IDS_EXPFAVORITESDESC            0x4204
#define IDS_IMPCOOKIES                  0x4205
#define IDS_IMPCOOKIESDESC              0x4206
#define IDS_EXPCOOKIES                  0x4207
#define IDS_EXPCOOKIESDESC              0x4208
#define IDS_IMPEXPTRANSFERTYPE_TITLE    0x4209
#define IDS_IMPEXPTRANSFERTYPE_SUBTITLE 0x420A
#define IDS_IMPEXPIMPFAVSRC_TITLE       0x420B
#define IDS_IMPEXPIMPFAVSRC_SUBTITLE    0x420C
#define IDS_IMPEXPIMPFAVDES_TITLE       0x420D
#define IDS_IMPEXPIMPFAVDES_SUBTITLE    0x420E
#define IDS_IMPEXPEXPFAVSRC_TITLE       0x420F
#define IDS_IMPEXPEXPFAVSRC_SUBTITLE    0x4210
#define IDS_IMPEXPEXPFAVDES_TITLE       0x4211
#define IDS_IMPEXPEXPFAVDES_SUBTITLE    0x4212
#define IDS_IMPEXPIMPCKSRC_TITLE        0x4213
#define IDS_IMPEXPIMPCKSRC_SUBTITLE     0x4214
#define IDS_IMPEXPEXPCKDES_TITLE        0x4215
#define IDS_IMPEXPEXPCKDES_SUBTITLE     0x4216
#define IDS_IMPEXP_FILEEXISTS           0x4217
#define IDS_IMPEXP_FILENOTFOUND         0x4218
#define IDS_IMPEXP_COMPLETE_IMPCK       0x4219
#define IDS_IMPEXP_COMPLETE_EXPCK       0x421A
#define IDS_IMPEXP_COMPLETE_IMPFV       0x421B
#define IDS_IMPEXP_COMPLETE_EXPFV       0x421C
#define IDS_IMPEXP_CAPTION              0x421D
#define IDS_NS3_VERSION_CAPTION         0x421E
#define IDS_NS4_FRIENDLY_PROFILE_NAME   0x421F
#define IDS_FB_FRIENDLY_PROFILE_NAME    0x4220
#define IDS_IMPEXP_CHOSEBOOKMARKFILE    0x4221
#define IDS_IMPEXP_CHOSECOOKIEFILE      0x4222
#define IDS_IMPEXP_BOOKMARKFILTER       0x4223
#define IDS_IMPEXP_COOKIEFILTER         0x4224

#define IDS_NETSCAPE_COOKIE_FILE        0x4225
#define IDS_NETSCAPE_BOOKMARK_FILE      0x4226
#define IDS_NETSCAPE_USERS_DIR          0x4227

#define IDC_IMPEXPACTIONDESCSTATIC      0x4261
#define IDC_IMPEXPBROWSE                0x4262
#define IDC_IMPEXPFAVTREE               0x4263

#define IDD_IMPEXPWELCOME               0x4264
#define IDD_IMPEXPTRANSFERTYPE          0x4265
#define IDD_IMPEXPIMPFAVSRC             0x4266
#define IDD_IMPEXPIMPFAVDES             0x4267
#define IDD_IMPEXPEXPFAVSRC             0x4268
#define IDD_IMPEXPEXPFAVDES             0x4269
#define IDD_IMPEXPIMPCKSRC              0x4270
#define IDD_IMPEXPEXPCKDES              0x4271
#define IDD_IMPEXPCOMPLETE              0x4272
#define IDC_IMPEXPACTIONLISTBOX         0x4273
#define IDC_IMPEXPEXTERNALCOMBO         0x4274
#define IDC_IMPEXPMANUAL                0x4275
#define IDC_IMPEXPRADIOAPP              0x4276
#define IDC_IMPEXPRADIOFILE             0x4287
#define IDC_IMPEXPTITLETEXT             0x4288
#define IDC_IMPEXPCOMPLETECONFIRM       0x4289

#define IDB_IMPEXPWATERMARK             0x428A
#define IDB_IMPEXPHEADER                0x428B

#define IDS_MIME_SAVEAS_HEADER_FROM     0x4300
#define IDS_SAVING_STATUS_TEXT          0x4301

#define IDS_CACHECLN_DISPLAY            0x5020
#define IDS_CACHECLN_DESCRIPTION        0x5021
#define IDS_CACHECLN_BTNTEXT            0x5022
#define IDS_CACHEOFF_DISPLAY            0x5023
#define IDS_CACHEOFF_DESCRIPTION        0x5024
#define IDS_CACHEOFF_BTNTEXT            0x5025

#define IDS_ON_DESKTOP                  0x6000
#define IDS_FIND_TITLE                  0x6001

#define IDS_RESET_WEB_SETTINGS_TITLE    0x6002
#define IDS_RESET_WEB_SETTINGS_SUCCESS  0x6003
#define IDS_RESET_WEB_SETTINGS_FAILURE  0x6004
#define IDD_RESET_WEB_SETTINGS          0x6005
#define IDC_RESET_WEB_SETTINGS_HOMEPAGE 0x6006

#define IDS_ERR_NAV_FAILED              0x6007
#define IDS_ERR_NAV_FAILED_TITLE        0x6008
#define IDS_HYPERTEXT_STYLE             0x6009

//
// my pics hoverbar as well as auto image resize feature
//

// buttons and tooltip strings:
#define IDM_MYPICS_SAVE                 4000
#define IDS_MYPICS_SAVE                 4000
#define IDM_MYPICS_PRINT                4001
#define IDS_MYPICS_PRINT                4001
#define IDM_MYPICS_EMAIL                4002
#define IDS_MYPICS_EMAIL                4002
#define IDM_MYPICS_MYPICS               4003
#define IDS_MYPICS_MYPICS               4003

#define IDM_AIR_BUTTON                  4019
#define IDS_AIR_EXPAND                  4018
#define IDS_AIR_SHRINK                  4017

// identifiers:
#define ID_MPTOOLBAR                    4020
#define ID_MPREBAR                      4021

#define ID_AIR_BUTTON                   4028
#define ID_AIR_REBAR                    4029

// bitmaps:
#define IDB_MYPICS_TOOLBAR              4030
#define IDB_MYPICS_TOOLBARG             4031
#define IDB_MYPICS_TOOLBARW             4032
#define IDB_MYPICS_TOOLBARGW            4033

#define IDB_AIR_EXPAND                  4038
#define IDB_AIR_SHRINK                  4039

// context menu thingie:
#define IDR_MYPICS_CONTEXT_MENU         4040
#define IDM_DISABLE_MYPICS              4041
#define IDM_HELP_MYPICS                 4042

// dialogue box popup disable thingie:
#define DLG_DISABLE_MYPICS              4050
#define IDC_MP_TEXT1                    4051
#define IDC_MP_TEXT2                    4052
#define IDC_MP_ALWAYS                   4053
#define IDC_MP_THISSESSION              4054
#define IDC_MP_CANCEL                   4055

// the timer
#define IDT_MP_TIMER                    4060
#define IDT_AIR_TIMER                   4061

// privacy dialog and status bar icons/tooltips
#define IDD_PRIVACY_DIALOG              4070
#define IDC_SITE_LIST                   4071
#define IDC_VIEW_POLICY                 4072
#define IDS_PRIVACY_COLUMN1             4073
#define IDS_PRIVACY_COLUMN2             4074
#define IDS_PRIVACY_TOOLTIP             4075
//  ordering of IDS_PRIVACY_/NOCOOKIE/ACCEPTED/RESTRICTED/BLOCKED must be maintained ..
#define IDS_PRIVACY_NOCOOKIE            4076
#define IDS_PRIVACY_ACCEPTED            4077
#define IDS_PRIVACY_SUPPRESSED          4078
#define IDS_PRIVACY_RESTRICTED          4079
#define IDS_PRIVACY_BLOCKED             4080
#define IDS_PRIVACY_VIEWIMPACTED        4081
#define IDS_PRIVACY_VIEWALL             4082
#define IDS_PRIVACY_LEARNMOREABOUTPRIVACY 4083
#define IDS_PRIVACY_LEARNMOREABOUTCOOKIES 4084
#define IDS_PRIVACY_STATUSIMPACTED      4085
#define IDS_PRIVACY_STATUSNOIMPACT      4086

#define IDC_SETTINGS                    4087
#define IDC_PRIVACY_VIEWCOMBO           4090
#define IDD_PRIVACY_CNTXTMN_PERSITE_ADD_REM     4091
#define IDM_PRIVACY_PAR_ACCEPT          4092
#define IDM_PRIVACY_PAR_REJECT          4093
#define IDM_PRIVACY_PAR_DEFAULT         4094
#define IDD_PRIV_DISCOVER               4095
#define IDB_PRIV_IMPACT                 4096
#define IDC_PRIV_DISCOVER_DONTSHOW      4097
#define IDC_PRIVACY_HELP                4098
#define IDC_PRIVACY_STATUSTEXT          4100
#define IDC_PRIVACY_SHOWPOLICY          4101
#define IDC_PRIVACY_ICON                4102

// media bar
#define IDD_MEDIA_MIME                  4120
#define IDC_MEDIA_MIME_CHKBOX           4121
#define IDS_MEDIABAR_NOWMP7         0x7000
#define IDS_MEDIABAR_NOWMP7TITLE    0x7001
#define IDS_MEDIABAR_NEEDWMP7       0x7002
#define IDC_MEDIABAR_EXTRA           0x7000

//  Since all the PrivacyXML strings are loaded in a string table,
//the resources must fill contiguously identifiers in the range
//IDS_PRIVACYXML6 to IDS_PRIVACYXML6_LASTPRIVACYXML6.
#define IDS_PRIVACYXML6                          0x6500
#define IDS_PRIVACYXML6_ROOTPRIVACY              (IDS_PRIVACYXML6 + 0)
#define IDS_PRIVACYXML6_VERSION                  (IDS_PRIVACYXML6 + 1)
#define IDS_PRIVACYXML6_COOKIEZONE               (IDS_PRIVACYXML6 + 2)
#define IDS_PRIVACYXML6_COOKIEZONE_ZONE          (IDS_PRIVACYXML6 + 3)
//  The four cookie zones must be contiguous in the resources..
#define IDS_PRIVACYXML6_COOKIEZONE_INTERNET      (IDS_PRIVACYXML6 + 4)
#define IDS_PRIVACYXML6_COOKIEZONE_INTRANET      (IDS_PRIVACYXML6 + 5)
#define IDS_PRIVACYXML6_COOKIEZONE_TRUSTED       (IDS_PRIVACYXML6 + 6)
#define IDS_PRIVACYXML6_COOKIEZONE_FIRST         IDS_PRIVACYXML6_COOKIEZONE_INTERNET
#define IDS_PRIVACYXML6_COOKIEZONE_LAST          IDS_PRIVACYXML6_COOKIEZONE_TRUSTED
//  end of four cookie zookes..
#define IDS_PRIVACYXML6_ACTION                   (IDS_PRIVACYXML6 + 7)
#define IDS_PRIVACYXML6_FIRSTPARTY               (IDS_PRIVACYXML6 + 8)
#define IDS_PRIVACYXML6_THIRDPARTY               (IDS_PRIVACYXML6 + 9)
#define IDS_PRIVACYXML6_NOPOLICYDEFAULT          (IDS_PRIVACYXML6 + 10)
#define IDS_PRIVACYXML6_NORULESDEFAULT           (IDS_PRIVACYXML6 + 11)
//  The five action attribute values must be contiguous in the resources..
#define IDS_PRIVACYXML6_ACTION_ACCEPT            (IDS_PRIVACYXML6 + 12)
#define IDS_PRIVACYXML6_ACTION_PROMPT            (IDS_PRIVACYXML6 + 13)
#define IDS_PRIVACYXML6_ACTION_FIRSTPARTY        (IDS_PRIVACYXML6 + 14)
#define IDS_PRIVACYXML6_ACTION_SESSION           (IDS_PRIVACYXML6 + 15)
#define IDS_PRIVACYXML6_ACTION_REJECT            (IDS_PRIVACYXML6 + 16)
#define IDS_PRIVACYXML6_ACTION_FIRST             IDS_PRIVACYXML6_ACTION_ACCEPT
#define IDS_PRIVACYXML6_ACTION_LAST              IDS_PRIVACYXML6_ACTION_REJECT
//  end of five attribute values
#define IDS_PRIVACYXML6_ALWAYSALLOWSESSION       (IDS_PRIVACYXML6 + 17)
#define IDS_PRIVACYXML6_YES                      (IDS_PRIVACYXML6 + 18)
#define IDS_PRIVACYXML6_NO                       (IDS_PRIVACYXML6 + 19)
#define IDS_PRIVACYXML6_IF                       (IDS_PRIVACYXML6 + 20)
#define IDS_PRIVACYXML6_EXPR                     (IDS_PRIVACYXML6 + 21)
#define IDS_PRIVACYXML6_ALWAYSREPLAYLEGACY       (IDS_PRIVACYXML6 + 22)
#define IDS_PRIVACYXML6_FLUSHCOOKIES             (IDS_PRIVACYXML6 + 23)
#define IDS_PRIVACYXML6_FLUSHSITELIST            (IDS_PRIVACYXML6 + 24)
#define IDS_PRIVACYXML6_ROOTPERSITE              (IDS_PRIVACYXML6 + 25)
#define IDS_PRIVACYXML6_SITE                     (IDS_PRIVACYXML6 + 26)
#define IDS_PRIVACYXML6_DOMAIN                   (IDS_PRIVACYXML6 + 27)
#define IDS_PRIVACYXML6_ROOT                     (IDS_PRIVACYXML6 + 28)
#define IDS_PRIVACYXML6_LASTPRIVACYXML6          (IDS_PRIVACYXML6 + 28)

#define IDC_MEDIA_MOREINFO             0x8001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\runonnt.h ===
// no wrappers are needed on non-x86 since this is only for win9x interop
#ifdef _X86_

#define PathCleanupSpec         _AorW_PathCleanupSpec
#define SHCLSIDFromString       _AorW_SHCLSIDFromString
#define SHILCreateFromPath      _AorW_SHILCreateFromPath
#define SHSimpleIDListFromPath  _AorW_SHSimpleIDListFromPath
#define StrToOleStr             _AorW_StrToOleStr
#define GetFileNameFromBrowse   _AorW_GetFileNameFromBrowse
#define OpenRegStream           _AorW_OpenRegStream
#define PathQualify             _AorW_PathQualify
#define PathProcessCommand      _AorW_PathProcessCommand
#define Win32DeleteFile         _AorW_Win32DeleteFile
#define PathYetAnotherMakeUniqueName    _AorW_PathYetAnotherMakeUniqueName
#define PathResolve             _AorW_PathResolve
#define Shell_GetCachedImageIndex _AorW_Shell_GetCachedImageIndex
#define SHRunControlPanel       _AorW_SHRunControlPanel
#define PickIconDlg             _AorW_PickIconDlg
#define SHCreateDirectory       _AorW_SHCreateDirectory

// The following functions were originally only TCHAR versions
// in Win95, but now have A/W versions.  Since we still need to
// run on Win95, we need to treat them as TCHAR versions and
// undo the A/W #define
#ifdef ILCreateFromPath
#undef ILCreateFromPath
#endif
#define ILCreateFromPath        _AorW_ILCreateFromPath

#ifdef SHGetSpecialFolderPath
#undef SHGetSpecialFolderPath
#endif
#define SHGetSpecialFolderPath  _AorW_SHGetSpecialFolderPath

#ifdef IsLFNDrive
#undef IsLFNDrive
#endif
#define IsLFNDrive              _AorW_IsLFNDrive

// Define the prototypes for each of these forwarders...

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */
extern int _AorW_Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);
extern int _WorA_Shell_GetCachedImageIndex(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags);
extern int _AorW_SHRunControlPanel(LPCTSTR pszOrig_cmdline, HWND errwnd);
extern LPITEMIDLIST _AorW_ILCreateFromPath(LPCTSTR pszPath);
extern int _AorW_PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec);
extern void _AorW_PathQualify(LPTSTR pszDir);
extern LONG WINAPI _AorW_PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags);
extern HRESULT _AorW_SHCLSIDFromString(LPCTSTR lpsz, LPCLSID lpclsid);
extern BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR pszPath, int nFolder, BOOL fCreate);
extern HRESULT _AorW_SHILCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);
extern LPITEMIDLIST _AorW_SHSimpleIDListFromPath(LPCTSTR pszPath);
extern BOOL WINAPI _AorW_GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cchFilePath,
        LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle);
extern IStream * _AorW_OpenRegStream(HKEY hkey, LPCTSTR pszSubkey, LPCTSTR pszValue, DWORD grfMode);

extern BOOL _AorW_Win32DeleteFile(LPCTSTR lpszFileName);

extern BOOL _AorW_PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszShort,
                                         LPCTSTR pszFileSpec);

extern BOOL _AorW_PathResolve(LPTSTR lpszPath, LPCTSTR dirs[], UINT fFlags);

extern BOOL _AorW_IsLFNDrive(LPTSTR lpszPath);
extern int  _AorW_PickIconDlg(HWND hwnd, LPTSTR pszIconPath, UINT cchIconPath, int * piIconIndex);
extern int  _AorW_SHCreateDirectory(HWND hwnd, LPCTSTR pszPath);

#ifdef __cplusplus
}

#endif  /* __cplusplus */

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\sccls.h ===
// Create Instance functions

#ifndef _SCCLS_H_
#define _SCCLS_H_



#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags

STDAPI  CDocObjectFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  CWebBrowserOC_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetToolbar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CQuickLinks_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CQuickLinksOld_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMediaBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);   // mediaband.cpp
STDAPI  CAddressBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);   // address.cpp
STDAPI  CAddressEditBox_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);   // aeditbox.cpp
STDAPI  CBandProxy_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);     // bandprxy.cpp
STDAPI  CBrandBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CTargetMenu_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  CSHItemOC_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellHlinkFrame_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CUrlHistory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CURLSearchHook_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDeskBarApp_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CStartMenuBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBrowserBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CSearchBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CCommBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CStubBSC_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellDataSource_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CISFBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CFavBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CHistBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#ifdef ENABLE_CHANNELS
STDAPI  CChannelBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#endif  // ENABLE_CHANNELS
STDAPI  CExplorerBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBandSiteMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAutoComplete_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLHistory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLIShellFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLMRU_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLMulti_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellUIHelper_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CIntShcut_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CCmdFileIcon_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellTaskScheduler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CSharedTaskScheduler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CStartMenuTask_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CDesktopTask_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CBaseBrowser2_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);

STDAPI  CShellFolderView_CreateInstance (IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CWinListShellProc_CreateInstance (IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAugmentedISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CIESplashScreen_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  COrderList_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CActiveDesktop_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CMenuSite_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CCDFCopyHook_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CRegTreeOptions_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  TaskbarList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetCacheCleaner_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  COfflinePagesCacheCleaner_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CImgCtxThumb_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CImageListCache_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDocFileInfoTip_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CDocHostUIHandler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CToolbarExtBand_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CToolbarExtExec_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CNscTree_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CMruLongList_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CMruPidlList_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
#ifdef _HSFOLDER
STDAPI  CacheFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  HistFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
#endif

STDAPI CBaseBrowser_Validate(HWND hwnd, LPVOID* ppsb);
STDAPI CShellBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb);
STDAPI CExplorerBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb);
STDAPI CSDWindows_CreateInstance(IShellWindows **ppunk);

STDAPI CIEFrameAuto_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk);

// to save some typing:
#define CLSIDOFOBJECT(p)          (*((p)->_pObjectInfo->pclsid))
#define VERSIONOFOBJECT(p)          ((p)->_pObjectInfo->lVersion)
#define EVENTIIDOFCONTROL(p)      (*((p)->_pObjectInfo->piidEvents))
#define OLEMISCFLAGSOFCONTROL(p)    ((p)->_pObjectInfo->dwOleMiscFlags)

extern char g_szLibName[]; // shocx.c
extern LCID g_lcidLocale; // shocx.c

#endif // _SCCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\security.h ===
/**************************************************************\
    FILE: security.h

    DESCRIPTION:
        This file will contain helper functions and objects that
    help deal with security.  This mainly means Zones Security, but
    can include other types.
\**************************************************************/

#ifndef _SECURITY_H
#define _SECURITY_H

#include "priv.h"
#include "util.h"

#endif // _SECURITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shdocfl.h ===
//
//  shdocfl.h 
//  
//  helper functions that are useful outside of shdocfl.cpp
//  but are definitely tied to the implementation of the namespace
//
//  WARNING - this should not be abused  - ZekeL - 24-NOV-98
//      by exposing the internal structure of the pidls
//


STDAPI_(LPITEMIDLIST) IEILAppendFragment(LPITEMIDLIST pidl, LPCWSTR pszFragment);
STDAPI_(BOOL) IEILGetFragment(LPCITEMIDLIST pidl, LPWSTR pszFragment, DWORD cchFragment);
STDAPI_(UINT) IEILGetCP(LPCITEMIDLIST pidl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shdocfl.cpp ===
#include "priv.h"
#include "sccls.h"
#include "dochost.h"
#include "resource.h"
#include "stdenum.h"
#include <idhidden.h>
#include "shdocfl.h"
#include <vdate.h>

#include <mluisupp.h>

#ifdef UNIX
#include "unixstuff.h"
#endif

HRESULT CDocObjectView_Create(IShellView** ppv, IShellFolder* psf, LPCITEMIDLIST pidl);


#define DM_STARTUP          0
#define DM_CDOFPDN          0       // CDocObjectFolder::ParseDisplayName

class CDocObjectFolder :    public IShellFolder2, 
                            public IPersistFolder2,
                            public IBrowserFrameOptions
{
public:
    CDocObjectFolder(LPCITEMIDLIST pidlRoot = NULL);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);

    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);

    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                           DWORD uFlags, LPITEMIDLIST * ppidlOut);
    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID pGuid);
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) { return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails){ return E_NOTIMPL; };
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid) { return E_NOTIMPL; };

    // IPersistFolder
    STDMETHODIMP GetClassID(LPCLSID pClassID);
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);
    
    // IBrowserFrameOptions
    STDMETHODIMP GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);

protected:

    ~CDocObjectFolder();

    LONG            _cRef;
    LPITEMIDLIST    _pidlRoot;
};

//========================================================================
// CDocObjectFolder members
//========================================================================

CDocObjectFolder::CDocObjectFolder(LPCITEMIDLIST pidlRoot)
        : _cRef(1), _pidlRoot(NULL)
{
    TraceMsg(TF_SHDLIFE, "ctor CDocObjectFolder %x", this);

    DllAddRef();

    if (pidlRoot)
        _pidlRoot = ILClone(pidlRoot);
}

CDocObjectFolder::~CDocObjectFolder()
{
    TraceMsg(TF_SHDLIFE, "dtor CDocObjectFolder %x", this);

    if (_pidlRoot)
        ILFree(_pidlRoot);

    DllRelease();
}

HRESULT CDocObjectFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CDocObjectFolder, IShellFolder, IShellFolder2),
        QITABENT(CDocObjectFolder, IShellFolder2),
        QITABENTMULTI(CDocObjectFolder, IPersistFolder, IPersistFolder2),
        QITABENT(CDocObjectFolder, IPersistFolder2), 
        QITABENT(CDocObjectFolder, IBrowserFrameOptions), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDocObjectFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDocObjectFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDocObjectFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszDisplayName,
        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    *ppidl = NULL;
    return E_UNEXPECTED;
}
HRESULT CDocObjectFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    *ppenumIDList = NULL;
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    *ppvOut = NULL;
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    *ppvObj = NULL;
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppvOut)
{
    HRESULT hres = E_FAIL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        hres = CDocObjectView_Create((IShellView**)ppvOut, this, _pidlRoot);
    }
    else
    {
        hres = E_NOINTERFACE;
        *ppvOut = NULL;
    }
    return hres;
}

HRESULT CDocObjectFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                 REFIID riid, UINT *prgfInOut, void **ppvOut)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    *ppvOut = NULL;
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    //  we should never have any children.
    ASSERT(cidl == 0);
    if (cidl != 0)
        return E_UNEXPECTED;
        
    if (*rgfInOut)
    {
        //  they want to know about the document itself
        ASSERT(_pidlRoot);
        return SHGetAttributesOf(_pidlRoot, rgfInOut);
    }

    return S_OK;
}

HRESULT CDocObjectFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName)
{
    AssertMsg(FALSE, TEXT("CDocObjFolder - Called Improperly - ZekeL"));
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                           DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    return E_UNEXPECTED;
}

HRESULT CDocObjectFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    *pGuid = SRCID_SWebSearch;
    return S_OK;
}

HRESULT CDocObjectFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

HRESULT CDocObjectFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_CDocObjectFolder;
    return S_OK;
}

HRESULT CDocObjectFolder::Initialize(LPCITEMIDLIST pidl)
{
    if (_pidlRoot) 
    {
        ILFree(_pidlRoot);
        _pidlRoot = NULL;
    }

    if (pidl)
        _pidlRoot = ILClone(pidl);

    return S_OK;
}

HRESULT CDocObjectFolder::GetCurFolder(LPITEMIDLIST* ppidl)
{
    return SHILClone(_pidlRoot, ppidl);
}

// IBrowserFrameOptions
#define BASE_OPTIONS \
                            (BFO_BROWSER_PERSIST_SETTINGS | BFO_RENAME_FOLDER_OPTIONS_TOINTERNET | \
                            BFO_PREFER_IEPROCESS | BFO_ENABLE_HYPERLINK_TRACKING | \
                            BFO_USE_IE_LOGOBANDING | BFO_ADD_IE_TOCAPTIONBAR | BFO_GO_HOME_PAGE | \
                            BFO_USE_IE_TOOLBAR | BFO_NO_PARENT_FOLDER_SUPPORT | BFO_NO_REOPEN_NEXT_RESTART | \
                            BFO_SHOW_NAVIGATION_CANCELLED)


// IBrowserFrameOptions
HRESULT CDocObjectFolder::GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    // We are hosting a DocObj?
    BOOL fIsFileURL = FALSE;

    // Is this under the Internet Name Space? Yes for
    // HTTP and FTP owned by the IE name space.  MSIEFTP
    // pidls are passed straight to that folder.
    // This function will return FALSE for non-IE stuff
    // but we will then want to check if it's a file system
    // thing that wants to act like a web page because it's
    // MIME TYPE or other association is associated with the web.
    if (!IsURLChild(_pidlRoot, TRUE))
    {               
        // Since IsURLChild() returned FALSE, this must be in the file system.
        // This case will happen with:
        // C:\foo.htm
        // http://www.yahoo.com/
        // http://bryanst/resume.doc
        // http://bryanst/notes.txt
        // <Start Page>  [I couldn't find a case that hit CInternetFolder]
        // C:\foo.doc (use the addressbar to repro)
        fIsFileURL = TRUE;
    }

    *pdwOptions = dwMask & BASE_OPTIONS;
    if (!fIsFileURL)
    {
        // Add the Offline Support when we aren't in the file system.
        *pdwOptions |= dwMask & (BFO_USE_IE_OFFLINE_SUPPORT | BFO_USE_DIALUP_REF);
    }
        
    return S_OK;
}


STDAPI CDocObjectFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CDocObjectFolder *psf = new CDocObjectFolder;
    if (psf)
    {
        *ppunk = SAFECAST(psf, IShellFolder *);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}


class CInternetFolder : CDocObjectFolder
{
public:
    CInternetFolder(LPCITEMIDLIST pidlRoot = NULL) ;

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                 REFIID riid, UINT *prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                           DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IPersistFolder
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IBrowserFrameOptions
    STDMETHODIMP GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);

protected:
    ~CInternetFolder();

    HRESULT _CreateProtocolHandler(LPCSTR pszProtocol, IBindCtx * pbc, IShellFolder **ppsf);
    HRESULT _CreateProtocolHandlerFromPidl(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsf);
    HRESULT _GetAttributesOfProtocol(LPCSTR pszProtocol, LPCITEMIDLIST *apidl, UINT cpidl, ULONG *rgfInOut);
    HRESULT _FaultInUrlHandler(LPCSTR pszProtocol, LPCTSTR pszUrl, IUnknown * punkSite);
    HRESULT _ConditionallyFaultInUrlHandler(LPCSTR pszProtocol, LPCTSTR pszUrl, IBindCtx * pbc);
    HRESULT _AssocCreate(LPCITEMIDLIST pidl, REFIID riid, void * *ppv);
    HRESULT _GetScheme(LPCITEMIDLIST pidl, LPWSTR pszOut, DWORD cchOut);
    HRESULT _GetUIObjectFromShortcut(LPCITEMIDLIST pidl, REFIID riid, void **ppvOut);
    HRESULT _GetTitle(LPCWSTR pszUrl, STRRET *pstr);
    HRESULT _InitHistoryStg(IUrlHistoryStg **pphist);

    IUrlHistoryStg *_phist;
};


CInternetFolder::CInternetFolder(LPCITEMIDLIST pidlRoot)
    : CDocObjectFolder(pidlRoot)
{
    TraceMsg(TF_URLNAMESPACE, "[%X] ctor CInternetFolder", this);
    ASSERT(NULL == _phist);
}

CInternetFolder::~CInternetFolder()
{
    ATOMICRELEASE(_phist);
    TraceMsg(TF_URLNAMESPACE, "[%X] dtor CInternetFolder", this);
}

HRESULT CInternetFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CInternetFolder, IShellFolder, IShellFolder2),
        QITABENT(CInternetFolder, IShellFolder2),
        QITABENTMULTI(CDocObjectFolder, IPersistFolder, IPersistFolder2),
        QITABENT(CDocObjectFolder, IPersistFolder2), 
        QITABENT(CInternetFolder, IBrowserFrameOptions), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CInternetFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CInternetFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


typedef struct tagURLID 
{
    ITEMIDLIST idl;     //  cb and SHID
    BYTE bType;         //  URLID
    UINT uiCP;          //  Code Page
    WCHAR achUrl[1];       //  variable size string
} URLID;

#define SHID_INTERNET           0x60
#define SHID_INTERNET_SITE      0x61    // IE name space item

#define URLID_URLBASEA          0x00
/////// URLID_LOCATION          0x01  //  LEGACY IE3/4 used for Frag IDs
/////// URLID_FTPFOLDER         0x02  //  LEGACY used by a pre-release FTP Folder dll
#define URLID_PROTOCOL          0x03  //  this is actually a delegated protocol
#define URLID_URLBASEW          0x80  //  
//      URLIDF_UNICODE          0x80  //  URLID_ is actually of UNICODE type

#ifdef UNICODE 
#define URLID_URLBASE           URLID_URLBASEW
#else
#define URLID_URLBASE           URLID_URLBASEA
#endif

typedef const UNALIGNED URLID *PCURLID;
typedef UNALIGNED URLID *PURLID;

#define PDID_SIG MAKEWORD(SHID_INTERNET_SITE, URLID_PROTOCOL)

inline PCDELEGATEITEMID _IsValidDelegateID(LPCITEMIDLIST pidl)
{
    PCDELEGATEITEMID pdi = (PCDELEGATEITEMID)pidl;
    ASSERT(pdi);

    if ((pdi->cbSize >= (SIZEOF(PDELEGATEITEMID)-1))
    && (pdi->wOuter == PDID_SIG))
        return pdi;

    return NULL;
}
    
LPCSTR _PidlToDelegateProtocol(LPCITEMIDLIST pidl)
{
    PCDELEGATEITEMID pdi = _IsValidDelegateID(pidl);
    if (pdi)
        return (LPCSTR)&(pdi->rgb[pdi->cbInner]);

    return NULL;
}

inline PCURLID _IsValidUrlID(LPCITEMIDLIST pidl)
{
    PCURLID purlid = (PCURLID)pidl;
    ASSERT(purlid);

//  98/12/22 #263932 vtan: ANSI and Unicode URLs are both valid. Use function
//  _ExtractURL to extract the URL from the PIDL as a Unicode string.

    if (purlid->idl.mkid.cb >= SIZEOF(URLID)
    && (purlid->idl.mkid.abID[0] == SHID_INTERNET_SITE)
    && (purlid->bType == URLID_URLBASEA || purlid->bType == URLID_URLBASEW || _IsValidDelegateID(pidl)))
        return purlid;

    return NULL;
}

//  98/12/22 #263932 vtan: IE4 stores the PIDL in a stream as an ANSI
//  string. IE5 stores the PIDL in a stream as a Unicode string. This
//  functions reads the string (ANSI or Unicode) and converts it to
//  an internal Unicode string which is what will be written to the stream.

void _ExtractURL (PCURLID pURLID, LPWSTR wszURL, int iCharCount)
{
    if (pURLID->bType == URLID_URLBASEA)
    {
        char aszURL[MAX_URL_STRING];

#ifdef UNIX
        ualstrcpynA(aszURL, (const char*)(pURLID->achUrl), sizeof(aszURL));
#else
        ualstrcpynA(aszURL, reinterpret_cast<const char*>(pURLID->achUrl), sizeof(aszURL));
#endif
        SHAnsiToUnicode(aszURL, wszURL, iCharCount);
    }
    else if (pURLID->bType == URLID_URLBASEW)
    {
        ualstrcpynW(wszURL, pURLID->achUrl, iCharCount);
    }
}

//  99/01/04 vtan: Added the following to help compare URLIDs which
//  can be AA/UU/AU/UA and perform the correct comparison.

int _CompareURL (PCURLID pURLID1, PCURLID pURLID2)
{
    int iResult;
    
    if ((pURLID1->bType == URLID_URLBASEA) && (pURLID2->bType == URLID_URLBASEA))
    {
#ifdef UNIX
        iResult = ualstrcmpA((const char*)(pURLID1->achUrl), (const char*)(pURLID2->achUrl));
#else
        iResult = ualstrcmpA(reinterpret_cast<const char*>(pURLID1->achUrl), reinterpret_cast<const char*>(pURLID2->achUrl));
#endif
    }
    else if ((pURLID1->bType == URLID_URLBASEW) && (pURLID2->bType == URLID_URLBASEW))
    {
        iResult = ualstrcmpW(pURLID1->achUrl, pURLID2->achUrl);
    }
    else
    {
        PCURLID pCompareURLID;
        WCHAR wszURL[MAX_URL_STRING];
        
        //  AU/UA comparison. To be efficient only convert the ANSI URLID
        //  to Unicode and perform the comparison in Unicode.
        
        if (pURLID1->bType == URLID_URLBASEA)
        {
            pCompareURLID = pURLID2;
            _ExtractURL(pURLID1, wszURL, SIZECHARS(wszURL));
        }
        else
        {
            pCompareURLID = pURLID1;
            _ExtractURL(pURLID2, wszURL, SIZECHARS(wszURL));
        }
        iResult = ualstrcmpW(pCompareURLID->achUrl, wszURL);
    }
    return iResult;
}

IShellFolder* g_psfInternet = NULL;

STDAPI CDelegateMalloc_Create(void *pv, UINT cbSize, WORD wOuter, IMalloc **ppmalloc);
//
// this might modify pszName if it's not a fully qualified url!
BOOL _ValidateURL(LPTSTR pszName, DWORD dwFlags)
{
    //
    // WARNING: In order to allow URL extensions, we assume all strings
    //  which contains ":" in it is a valid string.
    // Assumptions are:
    //
    // (1) CDesktop::ParseDisplayName parse file system strings first.
    // (2) URL moniker will return an error correctly if URL is not valid.
    // (3) someone else (the desktop folder) handles shell: URLs
    //     they should not be used directly by the browser 
    //
    return SUCCEEDED(IURLQualify(pszName, dwFlags, pszName, NULL, NULL)) && (-1 != GetUrlScheme(pszName));
    HRESULT hr = IURLQualify(pszName, dwFlags, pszName, NULL, NULL);
    DWORD nScheme = GetUrlScheme(pszName);
    return SUCCEEDED(hr) && (-1 != nScheme) && (URL_SCHEME_SHELL != nScheme);
}

LPITEMIDLIST IEILAppendFragment(LPITEMIDLIST pidl, LPCWSTR pszFragment)
{
    // WARNING: See IE5 bug #'s 86951 and 36497 for more details.
    //         In a nutshell, we're rolling back the change for 36497 because
    //         the change caused many more problems with customers than
    //         the behavior we had in IE4.
    // 
    //         Because we're not ensuring that
    //         the fragment is prefixed with a '#', there may be
    //         cases where the URL in the address bar looks wrong,
    //         as well as cases where a hyperlink to a different doc
    //         or HTML page may fail if it contains a fragment.
    return ILAppendHiddenStringW(pidl, IDLHID_URLFRAGMENT, pszFragment);
}

// browser only uglyness... we need to construct a desktop relative "regitem" pidl for
// the internet since browser only shell does not support psf->ParseDisplayName("::{guid}", &pidl)
// this uses the same layout as REGITEMs so we have PIDL compatibility with integrated mode
// this ensures that a shortcut to the IE icon made in browser only mode works in integrated

#ifndef NOPRAGMAS
#pragma pack(1)
#endif
typedef struct
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bReserved;  // This is to get DWORD alignment
    CLSID   clsid;
} IDITEM;               // IDREGITEM

typedef struct
{
    IDITEM idri;
    USHORT cbNext;
} IDLITEM;              // IDLREGITEM
#ifndef NOPRAGMAS
#pragma pack()
#endif

// stolen from shell32\shitemid.h

#define SHID_ROOT_REGITEM       0x1f    // MyDocuments, Internet, etc

const IDLITEM c_idlInetRoot = 
{ 
    {SIZEOF(IDITEM), SHID_ROOT_REGITEM, 0, 
    { 0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D },/* CLSID_Internet */ }, 0,
};

LPCITEMIDLIST c_pidlURLRoot = (LPCITEMIDLIST)&c_idlInetRoot;

// it must be an absolute pidl with a root regitem id at the front
// if we're a rooted explorer, this is always false
// this means we're definitely in nashville, so we shouldn't have a split
// world

PCURLID _FindUrlChild(LPCITEMIDLIST pidl, BOOL fIncludeHome = FALSE)
{
    if ((pidl == NULL) ||
        (pidl->mkid.cb != sizeof(IDITEM)) ||
        (pidl->mkid.abID[0] != SHID_ROOT_REGITEM))
    {
        return NULL;
    }

    //
    // the clsid in the pidl must be our internet folder's
    //
    if (!IsEqualGUID(((IDITEM*)pidl)->clsid, CLSID_Internet))
    {
        ASSERT(!IsEqualGUID(((IDITEM*)pidl)->clsid, CLSID_CURLFolder));
        return NULL;
    }

    //  go to the child...
    pidl = _ILNext(pidl);
    
    //
    // if it is a pidl to the internet root then it is the IE3 Home Page
    //
    
    if (fIncludeHome && ILIsEmpty(pidl))
        return (PCURLID)pidl;

    //
    // otherwise it is our child if it is a site object
    //
    return _IsValidUrlID(pidl);
}

STDAPI_(BOOL) IsURLChild(LPCITEMIDLIST pidl, BOOL fIncludeHome)
{
    return (NULL != _FindUrlChild(pidl, fIncludeHome));
}


BOOL IEILGetFragment(LPCITEMIDLIST pidl, LPWSTR pszFragment, DWORD cchFragment)
{
    return ILGetHiddenStringW(pidl, IDLHID_URLFRAGMENT, pszFragment, cchFragment);
}

UINT IEILGetCP(LPCITEMIDLIST pidl)
{
    PCURLID purlid = _FindUrlChild((pidl));
    if (purlid)
    {
        if (!_IsValidDelegateID((LPCITEMIDLIST)purlid))
            return purlid->uiCP;
    }
    return CP_ACP;
}

LPITEMIDLIST _UrlIdCreate(UINT uiCP, LPCTSTR pszUrl)
{
    //
    //  the URLID has a variable sized string
    //  member.  but we put the arbitrary limit
    //  of MAX_URL_STRING because that is what
    //  we use everywhere else.  we could just remove the
    //  limit however.
    //
    USHORT cb = (USHORT)SIZEOF(URLID) - (USHORT)CbFromCch(1);
    USHORT cchUrl = lstrlen(pszUrl) + 1;
    cchUrl = (USHORT)min(cchUrl, MAX_URL_STRING);
    cb += CbFromCch(cchUrl);

    PURLID purlid = (PURLID)IEILCreate(cb + SIZEOF(USHORT));

    if (purlid)
    {
        //  everything is actually aligned right now...
        purlid->idl.mkid.cb = cb;
        purlid->idl.mkid.abID[0] = SHID_INTERNET_SITE;
        purlid->bType = URLID_URLBASE;
        purlid->uiCP = uiCP;
        ualstrcpyn(purlid->achUrl, pszUrl, cchUrl);
    }

    return (LPITEMIDLIST) purlid;
}
        
LPITEMIDLIST UrlToPidl(UINT uiCP, LPCTSTR pszUrl, LPCWSTR pszFragment)
{
    LPITEMIDLIST pidlRet;
    LPCTSTR pszAttachedFrag = UrlGetLocation(pszUrl);
    TCHAR szURLBuf[MAX_URL_STRING];

    //  deal with URL's that still include the location (as in ParseDisplayName)
    if (pszAttachedFrag) 
    {
        StrCpyN(szURLBuf, pszUrl, (int)(pszAttachedFrag-pszUrl+1));
        pszUrl = szURLBuf;

        //  prefer the passed in fragment to the attached one
        if (!pszFragment)
            pszFragment = pszAttachedFrag;
            
    }

    ASSERT(pszUrl);
    
    pidlRet = _UrlIdCreate(uiCP, pszUrl);

    if (pidlRet && pszFragment && *pszFragment)
        pidlRet = IEILAppendFragment(pidlRet, pszFragment);

    return pidlRet;
}

typedef struct
{
    LPCSTR pszProtocol;
    const CLSID * pCLSID;
} FAULTIN_URLHANDERS;

// TODO: If there are other URL Handlers, add them here.
const FAULTIN_URLHANDERS c_FaultInUrlHandlers[] =
{
    {"ftp", &CLSID_FTPShellExtension}
};

HRESULT CInternetFolder::_FaultInUrlHandler(LPCSTR pszProtocol, LPCTSTR pszUrl, IUnknown * punkSite)
{
    HRESULT hr = S_OK;
    if (pszProtocol)
    {
        for (int nIndex = 0; nIndex < ARRAYSIZE(c_FaultInUrlHandlers); nIndex++)
        {
            if (!StrCmpIA(pszProtocol, c_FaultInUrlHandlers[nIndex].pszProtocol))
            {
                // Only fault in the feature if we are navigating to an FTP directory.
                if ((0 == nIndex) && !UrlIs(pszUrl, URLIS_DIRECTORY))
                {
                    // It's not an ftp directory, so skip it.
                    continue;
                }

                // FTP has a URL Shell Extension handler that is optionally
                // installed.  Fault it in now if it's needed.
                uCLSSPEC ucs;
                QUERYCONTEXT qc = { 0 };
                HWND hwnd = NULL;

                ucs.tyspec = TYSPEC_CLSID;
                ucs.tagged_union.clsid = *c_FaultInUrlHandlers[nIndex].pCLSID;

                IUnknown_GetWindow(punkSite, &hwnd);
                if (EVAL(hwnd))
                {
                    // Make it modal while the dialog is being displayed.
                    IUnknown_EnableModless(punkSite, FALSE);
                    FaultInIEFeature(hwnd, &ucs, &qc, 0);
                    IUnknown_EnableModless(punkSite, TRUE);
                }
                break;    // pidl can only have 1 procotol, so we don't need to check the other protocol.
            }
        }
    }

    return hr;    // We don't care if it didn't make it.
}


HRESULT CInternetFolder::_ConditionallyFaultInUrlHandler(LPCSTR pszProtocol, LPCTSTR pszUrl, IBindCtx * pbc)
{
    HRESULT hr = S_OK;

    // Faulting in the feature will probably require UI, so we need to assure that the caller
    // will allow this.
    if (pbc)
    {
        IUnknown * punkSite = NULL;

        pbc->GetObjectParam(STR_DISPLAY_UI_DURING_BINDING, &punkSite);
        if (punkSite)
        {
            hr = _FaultInUrlHandler(pszProtocol, pszUrl, punkSite);
            punkSite->Release();
        }
    }

    ASSERT(SUCCEEDED(hr));
    return S_OK;    // We don't care if it didn't make it.
}


// returns:
//      success S_OK
//      failure FAILED(hres)

HRESULT CInternetFolder::_CreateProtocolHandler(LPCSTR pszProtocol, IBindCtx * pbc, IShellFolder **ppsf)
{
    HRESULT hres;
    CHAR szCLSID[GUIDSTR_MAX];
    DWORD cbSize = SIZEOF(szCLSID);

    *ppsf = NULL;

    if (pszProtocol && 
        SHGetValueA(HKEY_CLASSES_ROOT, pszProtocol, "ShellFolder", NULL, &szCLSID, &cbSize) == ERROR_SUCCESS)
    {
        CLSID clsid;
        IShellFolder *psf;

        GUIDFromStringA(szCLSID, &clsid);
        if (!SHSkipJunction(pbc, &clsid))
        {
            hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hres))
            {
                // IPersistFolder is optional
                IPersistFolder *ppf;
                if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf))))
                {
                    ppf->Initialize(_pidlRoot);
                    ppf->Release();
                }

                IDelegateFolder *pdf;
                hres = psf->QueryInterface(IID_PPV_ARG(IDelegateFolder, &pdf));
                if (SUCCEEDED(hres))
                {
                    // REVIEW: we could cache the malloc on a per protocol basis
                    // to avoid creating these over and over
                    IMalloc *pmalloc;
                    hres = CDelegateMalloc_Create((void*)pszProtocol, (lstrlenA(pszProtocol) + 1), PDID_SIG, &pmalloc);
                    if (SUCCEEDED(hres))
                    {
                        hres = pdf->SetItemAlloc(pmalloc);
                        pmalloc->Release();
                    }
                    pdf->Release();
                }

                if (SUCCEEDED(hres))
                {
                    hres = S_OK;    // force all success codes to S_OK 
                    *ppsf = psf;
                }
                else
                    psf->Release();
            }
        }
        else
            hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    else
        hres = E_FAIL;

    return hres;
}

// returns:
//      S_FALSE if it is not a delegate protocol PIDL
//      hres of the bind opteration to the delegate protocol handler

HRESULT CInternetFolder::_CreateProtocolHandlerFromPidl(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsf)
{
    LPCSTR pszProtocol = _PidlToDelegateProtocol(pidl);
    if (pszProtocol)
    {
        HRESULT hres = _CreateProtocolHandler(pszProtocol, pbc, ppsf);
        ASSERT(hres != S_FALSE);    // enforce the return value comment
        return hres;
    }

    *ppsf = NULL;
    return S_FALSE;     // not a protocal PIDL
}

BOOL _GetUrlProtocol(LPCTSTR pszUrl, LPSTR pszProtocol, DWORD cchProtocol)
{
    TCHAR sz[MAX_PATH];
    DWORD cch = SIZECHARS(sz);
    if (SUCCEEDED(UrlGetPart(pszUrl, sz, &cch, URL_PART_SCHEME, 0)))
    {
        SHTCharToAnsi(sz, pszProtocol, cchProtocol);
        return TRUE;
    }

    return FALSE;
}

UINT CodePageFromBindCtx(LPBC pbc)
{
    UINT uiCP = CP_ACP;
    IDwnCodePage *pDwnCP;
    if (pbc && SUCCEEDED(pbc->QueryInterface(IID_PPV_ARG(IDwnCodePage, &pDwnCP))))
    {
        uiCP = pDwnCP->GetCodePage();
        pDwnCP->Release();
    }
    return uiCP;
}

#define STR_PARSE_INTERNET_DONT_ESCAPE_SPACES   L"Parse Internet Dont Escape Spaces"

HRESULT CInternetFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    HRESULT hres = E_FAIL;

    TCHAR szName[MAX_URL_STRING];
    UINT uiCP = CodePageFromBindCtx(pbc);

    StrCpyN(szName, pwszDisplayName, ARRAYSIZE(szName));
    if (!PathIsFilePath(szName))
    {
        if (_ValidateURL(szName, 0) || ShouldShellExecURL(szName))
        {
            CHAR szProtocol[MAX_PATH];
            DWORD cchName = ARRAYSIZE(szName);
            IShellFolder *psfHandler;
            BOOL fProtocolExists;

            // if we're down here, then the szName was really a url so try to encode it.
            // turn spaces to %20, unless we are being called from shellexec
            // in which case we allow spaces in the URL
            if (!BindCtx_ContainsObject(pbc, STR_PARSE_INTERNET_DONT_ESCAPE_SPACES))
                UrlEscape(szName, szName, &cchName, URL_ESCAPE_SPACES_ONLY);

            fProtocolExists = _GetUrlProtocol(szName, szProtocol, ARRAYSIZE(szProtocol));
            _ConditionallyFaultInUrlHandler(szProtocol, szName, pbc);

            if (fProtocolExists &&
                _CreateProtocolHandler(szProtocol, pbc, &psfHandler) == S_OK)
            {
                TraceMsg(TF_PIDLWRAP, "Asking \"%s\" handler to parse %s (%08X) into a pidl", szProtocol, szName, szName);
                hres = psfHandler->ParseDisplayName(hwnd, pbc,
                                                    pwszDisplayName, pchEaten,
                                                    ppidl, pdwAttributes);
                TraceMsg(TF_PIDLWRAP, "the result is %08X, the pidl is %08X", hres, *ppidl);
                psfHandler->Release();
                TraceMsg(TF_URLNAMESPACE, "CODF::PDN(%s) called psfHandler and returning %x",
                         szName, hres);
            }
            else
            {
                *ppidl = UrlToPidl(uiCP, szName, NULL);
                if (*ppidl)
                {
                    if (pdwAttributes)
                        hres = _GetAttributesOfProtocol(NULL, (LPCITEMIDLIST *)ppidl, 1, pdwAttributes);
                    else
                        hres = S_OK;
                }
                else 
                    hres = E_OUTOFMEMORY;

                TraceMsg(TF_URLNAMESPACE, "CODF::PDN(%s) called UrlToPidl and returning %x", szName, hres);
            }
        } 
        else 
        {
            TraceMsg(DM_CDOFPDN, "CDOF::PDN(%s) returning E_FAIL because of (%s) is FALSE", szName, TEXT("(_ValidateURL(szName) || ShouldShellExecURL( szName ))"));
        }
    } 

    return hres;
}

class CInternetFolderDummyEnum : public IEnumIDList
{
public:
    CInternetFolderDummyEnum();
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumIDList methods ***
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) {return E_NOTIMPL;}
    STDMETHODIMP Reset(void){return E_NOTIMPL;}
    STDMETHODIMP Clone(LPENUMIDLIST *ppenum){return E_NOTIMPL;}

protected:
    ~CInternetFolderDummyEnum() {;}
    
    long _cRef;
};

CInternetFolderDummyEnum::CInternetFolderDummyEnum() : _cRef(1)
{
}

HRESULT CInternetFolderDummyEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CInternetFolderDummyEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CInternetFolderDummyEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CInternetFolderDummyEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CInternetFolderDummyEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    pceltFetched = 0;
    return S_FALSE;
}

HRESULT CInternetFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    CInternetFolderDummyEnum *pdummy = new CInternetFolderDummyEnum();

    if (pdummy)
    {
        *ppenumIDList = (IEnumIDList *)pdummy;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInternetFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut)
{
    IShellFolder *psfHandler = NULL;
    BOOL fUseDefault = TRUE;
    *ppvOut = NULL;

    if (!_IsValidUrlID(pidl))
        return E_INVALIDARG;
        
    HRESULT hres = _CreateProtocolHandlerFromPidl(pidl, pbc, &psfHandler);
    if (hres == S_OK)
    {
        // NOTE: We allow Shell Extensions to take over URL handling on a per
        //     URL basis.  We entered the _CreateProtocolHandlerFromPidl()
        //     block of code above because
        //     a shell extension is registered to take over handling  this
        //     URL.  The above call to IShellFolder::BindToObject() just failed,
        //     so we need to fall back and handle it in the traditional way.
        //     This can be used by Shell Extensions, like the Ftp ShellExt, to
        //     let the browser (us) handle URLs that are either inaccessible because of
        //     the proxy or allow the browser to handle it so the traditional code
        //     will: 1) download the item(s), 2) sniff the data for the type, 3)
        //     use the suggested MIME type from the server or in the web page, 4)
        //     check the file for type extension mappings, 5)
        //     check any downloaded file for security certificates, and 6) display
        //     Open/Save dialogs.
            
        hres = psfHandler->BindToObject(pidl, pbc, riid, ppvOut);

        //  the handler will return ERROR_CANCELLED if it wants default behavior
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hres)
            fUseDefault = FALSE;
    }

    if (fUseDefault)
    {
        STRRET strRet;

        if (psfHandler)
        {
            //  we had a delegated folder that failed, need a normal pidl
            hres = psfHandler->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &strRet);
        }
        else
            hres = GetDisplayNameOf(pidl, SHGDN_FORPARSING, &strRet);

        TCHAR szUrl[MAX_URL_STRING];
        if (SUCCEEDED(hres) &&
            SUCCEEDED(hres = StrRetToBuf(&strRet, pidl, szUrl, ARRAYSIZE(szUrl))))
        {
            if (IsEqualIID(IID_IMoniker, riid))
            {
                hres = MonikerFromURL(szUrl, (IMoniker **)ppvOut);
            }
            else // DEFAULT
            {
                //  create a ShellFolder for the caller
                hres = E_OUTOFMEMORY;
                LPITEMIDLIST pidlT = NULL;

                //  if we are using a handler but it returned cancelled,
                //  then we need to recreate the pidl for ourselves to use
                //  otherwise we just use the one that was passed in, 
                //  which we assume was the one we created.
                if (psfHandler)
                {
                    pidlT = UrlToPidl(CP_ACP, szUrl, NULL);
                    pidl = pidlT;
                }

                if (pidl)
                {
                    LPITEMIDLIST pidlFull = ILCombine(_pidlRoot, pidl);

                    if (pidlFull)
                    {
                        CDocObjectFolder *psf = new CDocObjectFolder(pidlFull);
                        if (psf)
                        {
                            hres = psf->QueryInterface(riid, ppvOut);
                            psf->Release();
                        }
                        
                        ILFree(pidlFull);
                    }

                    ILFree(pidlT);
                }
            }
        }
    }

    
    if (psfHandler)
        psfHandler->Release();
        
    return hres;
}

HRESULT CInternetFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj)
{
    IShellFolder *psfHandler;

    *ppvObj = NULL;

    if (!_IsValidUrlID(pidl))
        return E_INVALIDARG;

    HRESULT hres = _CreateProtocolHandlerFromPidl(pidl, pbc, &psfHandler);
    if (hres != S_FALSE)
    {
        if (SUCCEEDED(hres))
        {
            hres = psfHandler->BindToStorage(pidl, pbc, riid, ppvObj);
            psfHandler->Release();
        }
        return hres;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

int CALLBACK CompareDelegateProtocols(void *pv1, void *pv2, LPARAM lParam)
{
    LPCSTR psz1 = _PidlToDelegateProtocol((LPCITEMIDLIST)pv1);
    LPCSTR psz2 = _PidlToDelegateProtocol((LPCITEMIDLIST)pv2);

    if (psz1 && psz2)
    {
        int iRet = StrCmpA(psz1, psz2);
        if (0 == iRet && lParam)
            *((LPCSTR *)lParam) = psz1;
    }
    else if (psz1)
    {
        return 1;
    }
    else if (psz2)
    {
        return -1;
    }
    return 0;
}


HRESULT CInternetFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet;

    ASSERT(!ILIsEmpty(pidl1) && !ILIsEmpty(pidl2));

    // Check for protocol pidls.
    LPCSTR psz = NULL;
    iRet = CompareDelegateProtocols((void *)pidl1, (void *)pidl2, (LPARAM)&psz);
    if (iRet)
        return ResultFromShort(iRet);

    if (psz)
    {
        IShellFolder *psfHandler;
        if (_CreateProtocolHandler(psz, NULL, &psfHandler) == S_OK)
        {
            iRet = psfHandler->CompareIDs(lParam, pidl1, pidl2);
            psfHandler->Release();
            return ResultFromShort(iRet);
        }
        
    }

    //  we only have one layer of children
    ASSERT(ILIsEmpty(_ILNext(pidl1)));
    ASSERT(ILIsEmpty(_ILNext(pidl2)));

    PCURLID purlid1 = _IsValidUrlID(pidl1);

    if (purlid1)
    {
        PCURLID purlid2 = _IsValidUrlID(pidl2);

        if (purlid2)
        {
            iRet = _CompareURL(purlid1, purlid2);
        }
        else
        {
            iRet = -1;
        }
    }
    else
    {
        iRet = 1;
    }

    return ResultFromShort(iRet);
}


HRESULT CInternetFolder::_GetAttributesOfProtocol(LPCSTR pszProtocol,
                                                   LPCITEMIDLIST *apidl,
                                                   UINT cpidl, ULONG *rgfInOut)
{
    HRESULT hres;

    ASSERT(cpidl);
    
    if (pszProtocol)
    {
        //
        // We have a protocol.  Find the protocol handler
        // and pass it the bundle of pidls.
        //
        IShellFolder *psfHandler;
        hres = _CreateProtocolHandler(pszProtocol, NULL, &psfHandler);
        if (hres == S_OK)
        {
            hres = psfHandler->GetAttributesOf(cpidl, apidl, rgfInOut);
            psfHandler->Release();
        }
    }
    else if (_IsValidUrlID(apidl[0]))
    {
        ULONG uOut = SFGAO_CANLINK | SFGAO_BROWSABLE | SFGAO_STREAM;
        *rgfInOut &= uOut;
        hres = S_OK;
        
    }
    else
        hres = E_INVALIDARG;

    return hres;
}


HRESULT CInternetFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    if (*rgfInOut)
    {
        //
        // Internet folder case.
        //
        LPCSTR pszProtocol;

        if (cidl == 0)
        {
            //
            // They are asking about the Internet Folder itself.
            //
            *rgfInOut &= SFGAO_FOLDER | SFGAO_CANLINK | SFGAO_STREAM;
        }
        else if (cidl == 1)
        {
            //
            // Often we are asked about only one child,
            // so we optimize that case.
            //
            pszProtocol = _PidlToDelegateProtocol(apidl[0]);

            _GetAttributesOfProtocol(pszProtocol, apidl, cidl, rgfInOut);
        }
        else
        {
            //
            // They are asking about multiple internet children.
            // These children may have different protocols,
            // so we have to find the GetAttributesOf handler for
            // each group of protocols in the list.
            //
            LPCITEMIDLIST pidlBase;
            UINT i, cpidlGroup;

            // Create a list of pidls sorted by protocol.
            HDPA hdpa = DPA_Create(100);
            if (!hdpa)
                return E_OUTOFMEMORY;

            for (i = 0; i < cidl; i++)
            {
                DPA_AppendPtr(hdpa, (void *)apidl[i]);
            }
            DPA_Sort(hdpa, CompareDelegateProtocols, NULL);

            //
            // Call GetAttributesOf on each protocol group.
            // A group
            //   starts at pidlBase
            //   contains cpidlGroup pidls
            //   has a protocol of pszProtocol
            //
            pidlBase = (LPCITEMIDLIST)DPA_FastGetPtr(hdpa, 0);
            pszProtocol = NULL;
            cpidlGroup = 0;
            for (i = 0; *rgfInOut && (i < cidl); i++)
            {
                LPCITEMIDLIST pidlNew = (LPCITEMIDLIST)DPA_FastGetPtr(hdpa, i);
                LPCSTR pszProtocolNew = _PidlToDelegateProtocol(pidlNew);
                if (pszProtocolNew)
                {
                    // See if we have a new protocol.
                    if (!pszProtocol || StrCmpA(pszProtocol, pszProtocolNew))
                    {
                        // We have a new protocol, time to process
                        // the last batch pidls.
                        _GetAttributesOfProtocol(pszProtocol, &pidlBase, cpidlGroup, rgfInOut);

                        pidlBase = pidlNew;
                        pszProtocol = pszProtocolNew;
                        cpidlGroup = 0;
                    }
                }
                cpidlGroup++;
            }
            if (*rgfInOut)
            {
                ASSERT(cpidlGroup);
                _GetAttributesOfProtocol(pszProtocol, &pidlBase, cpidlGroup, rgfInOut);
            }

            DPA_Destroy(hdpa);
            hdpa = NULL;
        }
    }

    return S_OK;
}

BOOL GetCommonProtocol(LPCITEMIDLIST *apidl, UINT cpidl, LPCSTR *ppszProtocol)
{
    UINT ipidl;
    LPCSTR pszProtocol;
    LPCSTR pszProtocolNext;

    *ppszProtocol = NULL;

    if (cpidl == 0)
    {
        return TRUE;    // No pidls - no protocols, but they do all match!
    }

    //
    // Grab the protocol of the first pidl, and use it to compare
    // against the rest of the pidls.
    //
    pszProtocol = _PidlToDelegateProtocol(apidl[0]);

    for (ipidl=1; ipidl<cpidl; ipidl++)
    {

        pszProtocolNext = _PidlToDelegateProtocol(apidl[ipidl]);

        //
        // Check if the protocols are different.
        //
        if ((pszProtocol != pszProtocolNext) &&
            ((pszProtocol == NULL) ||
             (pszProtocolNext == NULL) ||
             (StrCmpA(pszProtocol, pszProtocolNext) != 0)))
        {
            return FALSE;
        }
    }

    *ppszProtocol = pszProtocol;
    return TRUE;
}

HRESULT _CombineHidden(LPCITEMIDLIST pidl, DWORD dwIEFlags, LPWSTR pszName, DWORD cchName)
{
    HRESULT hres = S_OK;
    // 
    //  need to correctly append the fragment and query to the base
    //  if pszName is a DOSPATH, it will be converted to a
    //  file: URL so that it can accomadate the location
    //
    WCHAR sz[MAX_URL_STRING];
    DWORD cch = cchName;

    if (ILGetHiddenStringW(pidl, IDLHID_URLQUERY, sz, SIZECHARS(sz)))
        hres = UrlCombineW(pszName, sz, pszName, &cch, 0);
    
    if (!(dwIEFlags & IEGDN_NOFRAGMENT) && IEILGetFragment(pidl, sz, SIZECHARS(sz)))
    {
        hres = UrlCombineW(pszName, sz, pszName, &cchName, 0);
    }

    //  else 
    //      BUBBUG - should we return just the fragment in some case?
    return hres;
}

HRESULT CInternetFolder::_GetUIObjectFromShortcut(LPCITEMIDLIST pidl, REFIID riid, void **ppvOut)
{
    HRESULT hres = E_NOINTERFACE;
    STRRET str;
    TCHAR sz[MAX_URL_STRING];

    if (SUCCEEDED(GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)) 
    && SUCCEEDED(StrRetToBuf(&str, pidl, sz, ARRAYSIZE(sz)))
    && SUCCEEDED(_CombineHidden(pidl, 0, sz, ARRAYSIZE(sz))))
    {
        IUniformResourceLocator *purl;
        hres = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                IID_PPV_ARG(IUniformResourceLocator, &purl));
        if (SUCCEEDED(hres))
        {
            hres = purl->SetURL(sz, 0);
            
            if (SUCCEEDED(hres))
            {
                IShellLink * psl;
                if (SUCCEEDED(purl->QueryInterface(IID_PPV_ARG(IShellLink, &psl))))
                {
                    if (SUCCEEDED(GetDisplayNameOf(pidl, SHGDN_INFOLDER, &str)) &&
                        SUCCEEDED(StrRetToBuf(&str, pidl, sz, ARRAYSIZE(sz))))
                    {
                        PathRenameExtension(sz, TEXT(".url"));
                        psl->SetDescription(sz);
                    }
                    psl->Release();
                }
                
                hres = purl->QueryInterface(riid, ppvOut);
            }
            purl->Release();
        }
    }       

    return hres;
}

HRESULT CInternetFolder::_GetScheme(LPCITEMIDLIST pidl, LPWSTR pszOut, DWORD cchOut)
{
    STRRET str;
    LPCSTR pszProtocol = _PidlToDelegateProtocol(pidl);

    if (pszProtocol)
    {
        SHAnsiToUnicode(pszProtocol, pszOut, cchOut);
        return S_OK;
    }
    else if (SUCCEEDED(GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
    {
        WCHAR sz[MAX_URL_STRING];
        if (SUCCEEDED(StrRetToBufW(&str, pidl, sz, ARRAYSIZE(sz))))
        {
            return UrlGetPartW(sz, pszOut, &cchOut, URL_PART_SCHEME, 0);
        }
    }
    return E_FAIL;
}
    
HRESULT CInternetFolder::_AssocCreate(LPCITEMIDLIST pidl, REFIID riid, void * *ppv)
{
    *ppv = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        WCHAR szScheme[MAX_PATH];
        _GetScheme(pidl, szScheme, SIZECHARS(szScheme));

        hr = pqa->Init(0, szScheme, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = pqa->QueryInterface(riid, ppv);

        pqa->Release();
    }

    return hr;
}

HRESULT CInternetFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                 REFIID riid, UINT *prgfInOut, void **ppvOut)
{
    HRESULT hres = E_NOINTERFACE;
    LPCSTR pszProtocol;
    
    *ppvOut = NULL;

    if (apidl[0] && GetCommonProtocol(apidl, cidl, &pszProtocol) && pszProtocol)
    {
        IShellFolder *psfHandler;
        hres = _CreateProtocolHandlerFromPidl(apidl[0], NULL, &psfHandler);
        if (hres != S_FALSE)
        {
            if (SUCCEEDED(hres))
            {
                hres = psfHandler->GetUIObjectOf(hwnd, 1, apidl, riid, prgfInOut, ppvOut);
                psfHandler->Release();
            }
            return hres;
        }
    }
    else if (IsEqualIID(riid, IID_IExtractIconA) 
         || IsEqualIID(riid, IID_IExtractIconW) 
         || IsEqualIID(riid, IID_IContextMenu)
         || IsEqualIID(riid, IID_IQueryInfo)
         || IsEqualIID(riid, IID_IDataObject))
    {
        //  WARNING - we only support this for one at a time.
        if (cidl == 1)
        {
            hres = _GetUIObjectFromShortcut(apidl[0], riid, ppvOut);
        }
    }
    else if (IsEqualIID(riid, IID_IQueryAssociations))
    {
        //  WARNING - we only support this for one at a time.
        if (cidl == 1)
        {
            hres = _AssocCreate(apidl[0], riid, ppvOut);
        }
    }
        


    return hres;
}

HRESULT CInternetFolder::_InitHistoryStg(IUrlHistoryStg **pphist)
{
    HRESULT hr;
    if (!_phist)
    {
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER,
                IID_PPV_ARG(IUrlHistoryStg, &_phist));
    }
    
    if (_phist)
    {
        *pphist = _phist;
        _phist->AddRef();
        return S_OK;
    }

    return hr;
}

HRESULT CInternetFolder::_GetTitle(LPCWSTR pszUrl, STRRET *pstr)
{
    ASSERT(pszUrl);

    IUrlHistoryStg *phist;

    HRESULT hr = _InitHistoryStg(&phist);

    if (SUCCEEDED(hr))
    {
        ASSERT(phist);
        STATURL stat = {0};
        hr = phist->QueryUrl(pszUrl, STATURL_QUERYFLAG_NOURL, &stat);

        if (SUCCEEDED(hr) && stat.pwcsTitle)
        {
            hr = StringToStrRet(stat.pwcsTitle, pstr); 
            CoTaskMemFree(stat.pwcsTitle);
        }
        else
            hr = E_FAIL;

        phist->Release();
    }

    return hr;
}

HRESULT CInternetFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pstr)
{
    IShellFolder *psfHandler;
    HRESULT hr = _CreateProtocolHandlerFromPidl(pidl, NULL, &psfHandler);
    if (hr != S_FALSE)
    {
        if (SUCCEEDED(hr))
        {
            hr = psfHandler->GetDisplayNameOf(pidl, uFlags, pstr);
            psfHandler->Release();
        }
        return hr;
    }

    // FEATURE ZEKEL - should i handle more SHGDN flags here?? - Zekel - 24-NOV-98
    PCURLID purlid = _IsValidUrlID(pidl);
    if (purlid)
    {
        WCHAR sz[MAX_URL_STRING];

        _ExtractURL(purlid, sz, SIZECHARS(sz));

        if (SHGDN_NORMAL != uFlags)
            hr = StringToStrRet(sz, pstr); 
        else
        {
            hr = _GetTitle(sz, pstr);

            //  fallback to the URL if necessary
            if (FAILED(hr))
                hr = StringToStrRet(sz, pstr); 
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

HRESULT CInternetFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut)
{
    IShellFolder *psfHandler;
    HRESULT hres = _CreateProtocolHandlerFromPidl(pidl, NULL, &psfHandler);
    if (hres != S_FALSE)
    {
        if (SUCCEEDED(hres))
        {
            hres = psfHandler->SetNameOf(hwnd, pidl, pszName, uFlags, ppidlOut);
            psfHandler->Release();
        }
        return hres;
    }

    return E_FAIL;
}


HRESULT CInternetFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_Internet;
    return S_OK;
}


// IBrowserFrameOptions
HRESULT CInternetFolder::GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    // The only case I know of that we hit this code is when you select "Internet Explorer" in the
    // Folder Browser Band.
    HRESULT hr = E_INVALIDARG;

    if (pdwOptions)
    {
        // CInternetFolder should only be used for the "Internet Explorer" pidl that
        // points to the Start Page, so find the start page and substitute it during
        // navigation.
        *pdwOptions |= dwMask & (BFO_SUBSTITUE_INTERNET_START_PAGE | BASE_OPTIONS);
        hr = S_OK;
    }

    return hr;
}



#ifdef DEBUG
extern void remove_from_memlist(void *pv);
#endif

STDAPI CInternetFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CInternetFolder *psf = new CInternetFolder;
    if (psf)
    {
        //
        // HACK:
        //
        //   SHELL32 caches c_sfInetRoot in a static DATA section
        //  and never release it. It caches an instance of CInternetFolder
        //  and never release it. Therefore, we are removing this object
        //  from the to-be-memleak-detected list to avoid a false alarm
        //  assuming that we don't realy leak this object.
        //   Please don't copy it to another place unless you are really
        //  sure that it's OK not to detect leaks in that scenario.
        //  (SatoNa)
        //
        HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        psf->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}
    

STDAPI MonikerFromURL(LPCWSTR wszPath, IMoniker** ppmk)
{
    HRESULT hres = CreateURLMoniker(NULL, wszPath, ppmk);
#ifndef UNIX
    if (FAILED(hres)) 
#else
    // BUG BUG : 
    // IEUNIX  : We use to crash on UNIX if we give a very long invalid url
    // in address bar  or  as home page in inetcpl. We used to crash inside 
    // MkParseDisplayName.
    if (FAILED(hres) && lstrlenW(wszPath) < MAX_PATH) 
#endif
    {
        IBindCtx* pbc;
        hres = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hres)) 
        {
            // Fall back to a system (file) moniker
            ULONG cchEaten = 0;
            hres = MkParseDisplayName(pbc, wszPath, &cchEaten, ppmk);
            pbc->Release();
        }
    }

    return hres;
}

STDAPI MonikerFromString(LPCTSTR szPath, IMoniker** ppmk)
{
    return MonikerFromURL(szPath, ppmk);
}

#if 0
// alternate way to do the below in a more "pure" way on integrated mode

HRESULT InitPSFInternet()
{
    if (g_psfInternet)
        return S_OK;

    IShellFolder *psfTemp;
    IShellFolder *psfDesktop;
    HRESULT hres = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hres))
    {
        ULONG cchEaten;
        LPITEMIDLIST pidl;
        WCHAR wszInternet[] = L"::{871C5380-42A0-1069-A2EA-08002B30309D}"; // CLSID_Internet

        hres = psfDesktop->ParseDisplayName(NULL, NULL, wszInternet, &cchEaten, &pidl, NULL);
        if (SUCCEEDED(hres))
        {
            hres = psfDesktop->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psfTemp));
            SHFree(pidl);
        }
        psfDesktop->Release();
    }

    if (SHInterlockedCompareExchange((void **)&g_psfInternet, psfTemp, 0))
        psfTemp->Release();     // race to the exchange, free dup copy

    return hres;
}
#endif


HRESULT InitPSFInternet()
{
    if (g_psfInternet)
        return S_OK;

    IShellFolder *psfTemp;
    HRESULT hres = CoCreateInstance(CLSID_CURLFolder, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellFolder, &psfTemp));
    if (SUCCEEDED(hres)) 
    {
        IPersistFolder* ppsf;
        hres = psfTemp->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppsf));
        if (SUCCEEDED(hres)) 
        {
            hres = ppsf->Initialize(c_pidlURLRoot);
            if (SUCCEEDED(hres))
            {
                if (SHInterlockedCompareExchange((void **)&g_psfInternet, psfTemp, 0) == 0)
                    psfTemp->AddRef();  // global now holds ref
            }
            ppsf->Release();
        }
        psfTemp->Release();
    }
    return hres;
}

HRESULT _GetInternetRoot(IShellFolder **ppsfRoot)
{
    HRESULT hr = InitPSFInternet();
    *ppsfRoot = NULL;

    if (SUCCEEDED(hr))
    {
        g_psfInternet->AddRef();
        *ppsfRoot = g_psfInternet;
    }
    return hr;
}

HRESULT _GetRoot(LPCITEMIDLIST pidl, BOOL fIsUrl, IShellFolder **ppsfRoot)
{
    HRESULT hr;
    *ppsfRoot = NULL;
    
    if (fIsUrl)
    {
        ASSERT(IsURLChild(pidl, TRUE));
        TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) using the Internet", pidl);
        hr = _GetInternetRoot(ppsfRoot);
    }
    else
    {
        ASSERT(ILIsRooted(pidl));
        TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) using Rooted", pidl);

        CLSID clsid;

        ILRootedGetClsid(pidl, &clsid);

        if (IsEqualGUID(clsid, CLSID_ShellDesktop))
        {
            hr = SHBindToObject(NULL, IID_IShellFolder, ILRootedFindIDList(pidl), (void **)ppsfRoot);
        }
        else
        {
            IShellFolder *psf;
            hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlRoot = ILRootedFindIDList(pidl);
                if (!pidlRoot)
                    pidlRoot = &s_idlNULL;

                IPersistFolder* ppf;
                hr = psf->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
                if (SUCCEEDED(hr))
                {
                    hr = ppf->Initialize(pidlRoot);
                    ppf->Release();
                }

                //  hand over the reference
                *ppsfRoot = psf;
            }
        }
    }

    return hr;
}


STDAPI_(BOOL) IEILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fIgnoreHidden)
{
    UINT cb = ILGetSize(pidl1);

    if (cb != ILGetSize(pidl2) || 0 != memcmp(pidl1, pidl2, cb))
    {
        //  THEY are binarily different
        BOOL fRet = FALSE;
        BOOL fWebOnly = FALSE;

        if (IsURLChild(pidl1, TRUE) || IsURLChild(pidl2, TRUE))
            fWebOnly = TRUE;
       
        if ((IsURLChild(pidl1, FALSE) && IsURLChild(pidl2, FALSE))
        || (ILIsRooted(pidl1) && ILIsEqualRoot(pidl1, pidl2)))
        {
            IShellFolder *psf;
            if (SUCCEEDED(_GetRoot(pidl1, fWebOnly, &psf)))
            {
                if (0 == psf->CompareIDs(0, _ILNext(pidl1), _ILNext(pidl2)))
                    fRet = TRUE;

                psf->Release();
            }
        }
        
        if (!fRet && !fWebOnly)
        {
#undef ILIsEqual
            fRet = ILIsEqual(pidl1, pidl2);
        }
        
        if (fRet && !fIgnoreHidden)
        {
            fRet = (0 == ILCompareHiddenString(pidl1, pidl2, IDLHID_URLFRAGMENT));

            if (fRet)
                fRet = (0 == ILCompareHiddenString(pidl1, pidl2, IDLHID_URLQUERY));

            if (fRet)
                fRet = (0 == ILCompareHiddenString(pidl1, pidl2, IDLHID_NAVIGATEMARKER));
        }
        return fRet;
    }
    
    return TRUE;
}

// pszName must be MAX_URL_STRING
STDAPI IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pszName, UINT uFlags)
{
    return IEGetNameAndFlagsEx(pidl, uFlags, 0, pszName, MAX_URL_STRING, NULL);
}

#ifdef UNIX
//IEUNIX : No support for internal and external names in hp and solaris linker.
extern "C" STDAPI IEGetDisplayNameW(LPCITEMIDLIST pidl, LPWSTR pszName, UINT uFlags)
{
    return IEGetDisplayName(pidl, pszName, uFlags);
}
#endif

HRESULT _GetInternetFolderName(LPWSTR pszName, DWORD cchName)
{
    LPCTSTR pszKey;
    DWORD cbSize = CbFromCch(cchName);

    if (4 > GetUIVersion())
        pszKey = TEXT("CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}");
    else
        pszKey = TEXT("CLSID\\{871C5380-42A0-1069-A2EA-08002B30309D}"); 

    if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, pszKey, NULL, NULL, pszName, &cbSize)
    && *pszName)
        return S_OK;

    if (MLLoadString(IDS_REG_THEINTERNET, pszName, cchName)
    && *pszName)
        return S_OK;

    return E_UNEXPECTED;
}

STDAPI IEGetNameAndFlagsEx(LPCITEMIDLIST pidl, UINT uSHFlags, DWORD dwIEFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs)
{
    HRESULT hres = E_FAIL;

    if (pszName)
    {
        VDATEINPUTBUF(pszName, TCHAR, cchName);
        *pszName = 0;
    }

    //  for support of NON-integrated builds, and 
    //  to expedite handling of URLs while browsing
    if (IsURLChild(pidl, FALSE)) 
    {
        hres = InitPSFInternet();
        if (SUCCEEDED(hres))
        {
            if (pszName)
            {
                STRRET str;
                hres = g_psfInternet->GetDisplayNameOf(_ILNext(pidl), uSHFlags, &str);
                if (SUCCEEDED(hres))
                {
                    StrRetToBufW(&str, pidl, pszName, cchName);
                }
            }

            if (prgfInOutAttrs)
                hres = IEGetAttributesOf(pidl, prgfInOutAttrs);
            
        }
    } 
    else if (GetUIVersion() <= 4 && IsURLChild(pidl, TRUE))
    {
        //
        //  we need to support requests for the Internet SFs
        //  Friendly name.  on NT5 we will always have something
        //  even when the SF is hidden.  but on older versions
        //  of the shell, it was possible to delete the folder
        //  by just removing the icon from the desktop
        //

        if (pszName)
            hres = _GetInternetFolderName(pszName, cchName);

        if (prgfInOutAttrs)
            hres = IEGetAttributesOf(pidl, prgfInOutAttrs);
    }
    else if (ILIsRooted(pidl))
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlChild;
        
        hres = IEBindToParentFolder(pidl, &psf, &pidlChild);
        if (SUCCEEDED(hres))
        {
            if (pszName)
            {
                STRRET str;
                hres = IShellFolder_GetDisplayNameOf(psf, pidlChild, uSHFlags, &str, 0);
                if (SUCCEEDED(hres))
                {
                    hres = StrRetToBufW(&str, pidlChild, pszName, cchName);
                }
            }

            if (prgfInOutAttrs)
                hres = psf->GetAttributesOf(ILIsEmpty(pidlChild) ? 0 : 1, &pidlChild, prgfInOutAttrs);

            psf->Release();
        }
    } 
    else
        hres = SHGetNameAndFlags(pidl, uSHFlags, pszName, cchName, prgfInOutAttrs);

    if (SUCCEEDED(hres) && pszName && (uSHFlags & SHGDN_FORPARSING))
    {
        hres = _CombineHidden(pidl, dwIEFlags, pszName, cchName);
    }

    TraceMsg(TF_URLNAMESPACE, "IEGDN(%s) returning %x", pszName, hres);
    return hres;
}

STDAPI IEGetNameAndFlags(LPCITEMIDLIST pidl, UINT uFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs)
{
    return IEGetNameAndFlagsEx(pidl, uFlags, 0, pszName, cchName, prgfInOutAttrs);
}


BOOL _ClassIsBrowsable(LPCTSTR pszClass)
{
    BOOL fRet = FALSE;
    HKEY hk;
    
    if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_CLASS, pszClass, NULL, &hk)))
    {
        fRet = (NOERROR == RegQueryValueEx(hk, TEXT("DocObject"), NULL, NULL, NULL, NULL)
             || NOERROR == RegQueryValueEx(hk, TEXT("BrowseInPlace"), NULL, NULL, NULL, NULL));

        RegCloseKey(hk);
    }

    return fRet;
}

BOOL _MimeIsBrowsable(LPCTSTR pszExt)
{
    BOOL fRet = FALSE;
    TCHAR sz[MAX_PATH];
    DWORD dwSize = ARRAYSIZE(sz);         

    if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_CONTENTTYPE, pszExt, NULL, sz, &dwSize)))
    {
        TCHAR szKey[MAX_PATH];
        dwSize = SIZEOF(sz);

        // Get the CLSID for the handler of this content type.
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("MIME\\Database\\Content Type\\%s"), sz);

        // reuse sz for the clsid
        if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, szKey, TEXT("CLSID"), NULL, (void *) sz, &dwSize))
        {
            fRet = _ClassIsBrowsable(sz);
        }
    }
    return fRet;
}
                    
BOOL _StorageIsBrowsable(LPCTSTR pszPath)
{
    BOOL fRet = FALSE;
    //
    // If the file is STILL not browsable, try to open it as a structured storage
    // and check its CLSID.
    //
    IStorage *pStg = NULL;

    if (StgOpenStorage(pszPath, NULL, STGM_SHARE_EXCLUSIVE, NULL, 0, &pStg ) == S_OK && pStg)
    {
        STATSTG  statstg;
        if (pStg->Stat( &statstg, STATFLAG_NONAME ) == S_OK)
        {
            TCHAR szClsid[GUIDSTR_MAX];
            SHStringFromGUIDW(statstg.clsid, szClsid, SIZECHARS(szClsid));
            
            fRet = _ClassIsBrowsable(szClsid);
        }
        
        pStg->Release();
    }

    return fRet;
}

BOOL _IEIsBrowsable(LPCITEMIDLIST pidl)
{
    TCHAR szPath[MAX_PATH];
    BOOL fRet = FALSE;
    
    if (SUCCEEDED(SHGetPathFromIDList(pidl, szPath)))
    {
        // Don't change the order of the following OR'd conditions because
        // we want the HTML test to go first.  Also, the NT5 shell will
        // do the ClassIsBrowsable check for us, so we should avoid repeating
        // that check.

        if (PathIsHTMLFile(szPath)
        || _ClassIsBrowsable(szPath)
        || _MimeIsBrowsable(PathFindExtension(szPath))
        || _StorageIsBrowsable(szPath))
            fRet = TRUE;
    }
    
    return fRet;
}


HRESULT _IEGetAttributesOf(LPCITEMIDLIST pidl, DWORD* pdwAttribs, BOOL fAllowExtraChecks)
{
    HRESULT hres = E_FAIL;
    DWORD dwAttribs = *pdwAttribs;
    BOOL fExtraCheckForBrowsable = FALSE;

    //
    // REARCHITECT - Check if we need to execute an additional logic - ZekeL - 7-JAN-99
    // to see if it's browsable or not. this is necessary on shell32s from NT4/win95/IE4 
    // both NT4/win95 have no notion of SFGAO_BROWSABLE, and even though
    // IE4 does, it doesnt handle it correctly for UNICODE file names.
    // We are just as thorough (more) in our private check, so just defer to it.  
    //
    // 78777: Even if we are on NT5, IE can browse things that Shell thinks is not 
    // browsable, for example, .htm files when Netscape is the default browser.  
    // So we should do the extra check on every platform.

    if (fAllowExtraChecks && (dwAttribs & SFGAO_BROWSABLE)) 
    {
        dwAttribs |= SFGAO_FILESYSTEM | SFGAO_FOLDER;
        fExtraCheckForBrowsable = TRUE;
    }

    IShellFolder* psfParent;
    LPCITEMIDLIST pidlChild;
    
    if (ILIsEmpty(pidl))
    {
        hres = SHGetDesktopFolder(&psfParent);
        pidlChild = pidl;
    }
    else if (ILIsRooted(pidl) && ILIsEmpty(_ILNext(pidl)))
    {
        //  
        //  when getting the attributes of the root itself, we
        //  decide its better to just limit the attribs to 
        //  some easily supported subset.  we used to always
        //  fail, but that is a little extreme.
        //
        //  we could also try to get the attributes from HKCR\CLSID\{clsid}\shellfolder\attributes
        //
        *pdwAttribs &= (SFGAO_FOLDER);
        return S_OK;
    }
    else 
    {
        if (GetUIVersion() < 4 && IsURLChild(pidl, TRUE))
        {
            IShellFolder *psfRoot;
            //
            //  if we are Browser Only, and this is the
            //  internet folder itself that we are interested
            //  in, then we need to bind to it by hand
            //  and query it with cidl = 0
            //
            hres = _GetInternetRoot(&psfRoot);

            if (SUCCEEDED(hres))
            {
                hres = SHBindToFolderIDListParent(psfRoot, _ILNext(pidl), IID_PPV_ARG(IShellFolder, &psfParent), &pidlChild);
                psfRoot->Release();
            }
        }
        else if (ILIsRooted(pidl))
            hres = IEBindToParentFolder(pidl, &psfParent, &pidlChild);
        else
            hres = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfParent), &pidlChild);
    }

    if (SUCCEEDED(hres))
    {
        ASSERT(psfParent);
        hres = psfParent->GetAttributesOf(ILIsEmpty(pidlChild) ? 0 : 1, &pidlChild, &dwAttribs);

        if (FAILED(hres))
            TraceMsg(TF_WARNING, "IEGetAttribs psfParent->GetAttr failed %x", hres);

        psfParent->Release();
    }   
    else
        TraceMsg(TF_WARNING, "IEGetAttribs BindTOParent failed %x", hres);

    //
    //  This is the extra logic we need to execute if this is a browser
    // only mode to get the right "browsable" attribute flag to DocObjects.
    //
    if (fExtraCheckForBrowsable && !(dwAttribs & SFGAO_BROWSABLE))
    {
        if ((dwAttribs & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM) 
        {
            if (_IEIsBrowsable(pidl))
                dwAttribs |= SFGAO_BROWSABLE;
        }
    }

    *pdwAttribs &= dwAttribs;
    return hres;
}

HRESULT IEGetAttributesOf(LPCITEMIDLIST pidl, DWORD* pdwAttribs)
{
    return _IEGetAttributesOf(pidl, pdwAttribs, TRUE);
}

// BRYANST: 7/22/97  -  NT Bug #188099
// shell32.dll in IE4 SI and only in that version had a bug if pbc was passed
// to IShellFolder::BindToObject() (fstreex.c!FSBindToFSFolder), it would fail
// to bind to Shell Extensions that extended file system folders, such as:
// the history folder, the occache, etc.  We work around this by passing a NULL pbc
// if the destination is an IE4 shell32.dll and it will go thru FSBindToFSFolder().
BOOL ShouldWorkAroundBCBug(LPCITEMIDLIST pidl)
{
    BOOL fWillBCCauseBug = FALSE;

    if (4 == GetUIVersion())
    {
        LPITEMIDLIST pidlCopy = ILClone(pidl);
        LPITEMIDLIST pidlIterate = pidlCopy;

        // Skip the first two ItemIDs. (#1 could be My Computer)
        if (!ILIsEmpty(pidlIterate))
        {
            IShellFolder * psf;

            // (#2 could be CFSFolder::BindToObject())
            pidlIterate = _ILNext(pidlIterate);
            if (!ILIsEmpty(pidlIterate))
            {
                pidlIterate = _ILNext(pidlIterate);
                // Remove everything else so we bind directly to CFSFolder::BindToObject()
                pidlIterate->mkid.cb = 0;

                if (SUCCEEDED(IEBindToObject(pidlCopy, &psf)))
                {
                    IPersist * pp;

                    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersist, &pp))))
                    {
                        CLSID clsid;

                        if (SUCCEEDED(pp->GetClassID(&clsid)) && 
                            IsEqualCLSID(clsid, CLSID_ShellFSFolder))
                        {
                            fWillBCCauseBug = TRUE;
                        }

                        pp->Release();
                    }
                    psf->Release();
                }
            }

        }

        ILFree(pidlCopy);
    }

    return fWillBCCauseBug;
}

typedef enum
{
    SHOULDBIND_DOCOBJ,
    SHOULDBIND_DESKTOP,
    SHOULDBIND_NONE,
} SHOULDBIND;

//
//  _ShouldDocObjBind() 
//  returns 
//      SHOULDBIND_DOCOBJ   -  Should just use DocObjectFolder directly
//      SHOULDBIND_DESKTOP  -  bind through the desktop
//      SHOULDBIND_NONE     -  FAIL the bind...
//
SHOULDBIND _ShouldDocObjBind(DWORD dwAttribs, BOOL fStrictBind)
{
    if (fStrictBind)
    {
        if ((dwAttribs & (SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_FILESYSTEM)) == (SFGAO_BROWSABLE | SFGAO_FILESYSTEM))
            return SHOULDBIND_DOCOBJ;
        else
            return SHOULDBIND_DESKTOP;
    }
    else
    {
        if (dwAttribs & (SFGAO_FOLDER | SFGAO_BROWSABLE))
            return SHOULDBIND_DESKTOP;

        // manually bind using our CDocObjectFolder for
        // files which are not DocObject. Without this code, file:
        // to non-Docobject files (such as multi-media files)
        // won't do anything.
        //
        // is is needed for non integraded browser mode 
        //
        if (dwAttribs & SFGAO_FILESYSTEM) 
            return SHOULDBIND_DOCOBJ;
        else
            return SHOULDBIND_NONE;
    }
}

STDAPI _IEBindToObjectInternal(BOOL fStrictBind, LPCITEMIDLIST pidl, IBindCtx * pbc, REFIID riid, void **ppvOut)
{
    IShellFolder *psfTemp;
    HRESULT hr;

    *ppvOut = NULL;

    // Special case:  If we have the pidl for the "Desktop" then just use the Desktop folder itself
    if (ILIsEmpty(pidl))
    {
        hr = SHGetDesktopFolder(&psfTemp);
        if (SUCCEEDED(hr))
        {
            hr = psfTemp->QueryInterface(riid, ppvOut);
            psfTemp->Release();
        }
    } 
    else 
    {
        BOOL fIsUrlChild = IsURLChild(pidl, TRUE);

        if (fIsUrlChild || ILIsRooted(pidl))
        {
            hr = _GetRoot(pidl, fIsUrlChild, &psfTemp);
            if (SUCCEEDED(hr))
            {
                pidl = _ILNext(pidl);
                
                if (!ILIsEmpty(pidl))
                    hr = psfTemp->BindToObject(pidl, pbc, riid, ppvOut);
                else
                    hr = psfTemp->QueryInterface(riid, ppvOut);

                psfTemp->Release();
            }
        }
        else
        {
            // non integrated browser mode will succeed on 
            // BindToObject(IID_IShellFolder) even for things that should 
            // fail (files). to avoid the down stream problems caused by this we
            // filter out things that are not "browseable" up front, 
            //
            // NOTE: this does not work on simple PIDLs

            DWORD dwAttribs = SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_FILESYSTEM;

            hr = _IEGetAttributesOf(pidl, &dwAttribs, fStrictBind);
            
            if (SUCCEEDED(hr)) 
            {
                switch (_ShouldDocObjBind(dwAttribs, fStrictBind))
                {
                case SHOULDBIND_DOCOBJ:
                    {
                        //
                        // shortcircuit and bind using our CDocObjectFolder for
                        // files which are BROWSABLE. Without this code, file:
                        // to non-Docobject files (such as multi-media files)
                        // won't do anything.
                        //
                        // is is needed for non integraded browser mode 
                        //
                        CDocObjectFolder *pdof = new CDocObjectFolder();

                        TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) using DocObjectFolder", pidl);
                        if (pdof)
                        {
                            hr = pdof->Initialize(pidl);
                            if (SUCCEEDED(hr)) 
                                hr = pdof->QueryInterface(riid, ppvOut);
                            pdof->Release();
                        }
                        else
                            hr = E_OUTOFMEMORY;    
                    }
                    break;

                case SHOULDBIND_DESKTOP:
                    {
                        //
                        // This is the normal case. We just bind down through the desktop...
                        //
                        TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) using Desktop", pidl);

                        hr = SHGetDesktopFolder(&psfTemp);
                        if (SUCCEEDED(hr))
                        {
                            // BRYANST: 7/22/97  -  NT Bug #188099
                            // shell32.dll in IE4 SI and only in that version had a bug if pbc was passed
                            // to IShellFolder::BindToObject() (fstreex.c!FSBindToFSFolder), it would fail
                            // to bind to Shell Extensions that extended file system folders, such as:
                            // the history folder, the occache, etc.  We work around this by passing a NULL pbc
                            // if the destination is an IE4 shell32.dll and it will go thru FSBindToFSFolder().
                            if (pbc && ShouldWorkAroundBCBug(pidl))
                            {
                                pbc = NULL;
                            }

                            hr = psfTemp->BindToObject(pidl, pbc, riid, ppvOut);
                            psfTemp->Release();
                        }
                    } 
                    break;

                default:
                    hr = E_FAIL;
                }
            } 
        }
    }

    if (SUCCEEDED(hr) && !*ppvOut)
    {
        // Some NSEs have bugs where they will fail to fill in the
        // out pointer but return SUCCEEDED(hr).  WS_FTP is one example
        // in NT #413950.
        TraceMsg(TF_URLNAMESPACE, "IEBTO() BUG!!! An NSE succeeded but returned a NULL interface pointer.");
        hr = E_FAIL;
    }
    
    TraceMsg(TF_URLNAMESPACE, "IEBTO(%x) returning %x", pidl, hr);

    return hr;
}

STDAPI IEBindToObjectEx(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppvOut)
{
    return _IEBindToObjectInternal(TRUE, pidl, pbc, riid, ppvOut);
}

STDAPI IEBindToObject(LPCITEMIDLIST pidl, IShellFolder **ppsfOut)
{
    return _IEBindToObjectInternal(TRUE, pidl, NULL, IID_PPV_ARG(IShellFolder, ppsfOut));
}

STDAPI IEBindToObjectWithBC(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsfOut)
{
    return _IEBindToObjectInternal(TRUE, pidl, pbc, IID_PPV_ARG(IShellFolder, ppsfOut));
}

//  CLASSIC BIND here
HRESULT IEBindToObjectForNavigate(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsfOut)
{
    return _IEBindToObjectInternal(FALSE, pidl, pbc, IID_PPV_ARG(IShellFolder, ppsfOut));
}


//
// CDwnCodePage: Dummy supports IBindCtx interface object only for casting
//               It holds codepage info to pass via LPBC parameter
//
class CDwnCodePage : public IBindCtx
                   , public IDwnCodePage
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IBindCtx methods
    STDMETHODIMP RegisterObjectBound(IUnknown *punk) { return (_pbc ? _pbc->RegisterObjectBound(punk) : E_NOTIMPL); };
    STDMETHODIMP RevokeObjectBound(IUnknown *punk) { return (_pbc ? _pbc->RevokeObjectBound(punk) : E_NOTIMPL); };
    STDMETHODIMP ReleaseBoundObjects(void) { return (_pbc ? _pbc->ReleaseBoundObjects() : E_NOTIMPL); };
    STDMETHODIMP SetBindOptions(BIND_OPTS *pbindopts) { return (_pbc ? _pbc->SetBindOptions(pbindopts) : E_NOTIMPL); };
    STDMETHODIMP GetBindOptions(BIND_OPTS *pbindopts) { return (_pbc ? _pbc->GetBindOptions(pbindopts) : E_NOTIMPL); };
    STDMETHODIMP GetRunningObjectTable(IRunningObjectTable **pprot) { *pprot = NULL; return (_pbc ? _pbc->GetRunningObjectTable(pprot) : E_NOTIMPL); };
    STDMETHODIMP RegisterObjectParam(LPOLESTR pszKey, IUnknown *punk) { return (_pbc ? _pbc->RegisterObjectParam(pszKey, punk) : E_NOTIMPL); };
    STDMETHODIMP GetObjectParam(LPOLESTR pszKey, IUnknown **ppunk) { *ppunk = NULL; return (_pbc ? _pbc->GetObjectParam(pszKey, ppunk) : E_NOTIMPL); };
    STDMETHODIMP EnumObjectParam(IEnumString **ppenum) { *ppenum = NULL; return (_pbc ? _pbc->EnumObjectParam(ppenum) : E_NOTIMPL); };
    STDMETHODIMP RevokeObjectParam(LPOLESTR pszKey) { return (_pbc ? _pbc->RevokeObjectParam(pszKey) : E_NOTIMPL); };

    STDMETHODIMP RemoteSetBindOptions(BIND_OPTS2 *pbindopts) { return E_NOTIMPL; };
    STDMETHODIMP RemoteGetBindOptions(BIND_OPTS2 *pbindopts) { return E_NOTIMPL; };

    // IDwnCodePage methods
    STDMETHODIMP_(UINT) GetCodePage(void) { return _uiCodePage; };
    STDMETHODIMP SetCodePage(UINT uiCodePage) { _uiCodePage = uiCodePage; return S_OK; };

    // Constructor
    CDwnCodePage(IBindCtx * pbc, UINT uiCodePage) : _cRef(1) { _uiCodePage = uiCodePage; _pbc = NULL; IUnknown_Set((IUnknown **)&_pbc, (IUnknown *)pbc); };
    ~CDwnCodePage() { ATOMICRELEASE(_pbc); };

private:
    int     _cRef;
    UINT    _uiCodePage;
    IBindCtx * _pbc;
};

STDAPI CDwnCodePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDwnCodePage, IBindCtx),
        QITABENT(CDwnCodePage, IDwnCodePage), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDAPI_(ULONG) CDwnCodePage::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CDwnCodePage::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;
}

// IEParseDisplayName() will do all of the below functionality in IECreateFromPathCPWithBC()
// plus the following two things:
// 1.  It will call ParseURLFromOutsideSource(), so this is more friendly to
//     strings from outside sources.
// 2.  If the URL has a fragment, this function will pass out a PIDL with the last
//     ID being the location.
HRESULT IECreateFromPathCPWithBCW(UINT uiCP, LPCWSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut)
{
    TraceMsg(TF_URLNAMESPACE, "IECFP(%s) called", pszPath);

    HRESULT hr = S_OK;
    WCHAR szPath[MAX_URL_STRING];
    WCHAR szBuf[MAX_PATH];
    DWORD cchBuf = ARRAYSIZE(szBuf);
    CDwnCodePage DwnCodePage(pbc, uiCP);
    DWORD len;

    // Initialize for failure case
    *ppidlOut = NULL;

    // if we are passed a NULL path, then there is no way we can convert it to a pidl.
    // in some cases the reason we are passed a NULL path is because the IShellFolder
    // provider was unable to generate a parseable display name (MSN Classic 1.3 is
    // a very good example, they return E_NOTIMPL).
    if ( ((len = lstrlen( pszPath )) == 0)  || len >= MAX_URL_STRING )
    {
        return E_FAIL;
    }

    // Is this a "file:" URL?
    if (IsFileUrlW(pszPath) && SUCCEEDED(hr = PathCreateFromUrl(pszPath, szBuf, &cchBuf, 0)))
        pszPath = szBuf;

    BOOL fIsFilePath = PathIsFilePath(pszPath);

#ifdef FEATURE_IE_USE_DESKTOP_PARSING
    //
    //  in order to take advantage of whatever enhancements the desktop
    //  makes to parsing (eg, WebFolders and shell: URLs), then we allow
    //  the desktop first go at it.  it will loop back into the internet
    //  shell folder if all the special cases fail.
    //      maybe use a reg setting to control???
    //
    //
    if (fIsFilePath || GetUIVersion() >= 5)
#else // !FEATURE_IE_USE_DESKTOP_PARSING
    //
    //  right now we just use the desktop if its a file path or
    //  it is a shell: URL on NT5
    //
    if (fIsFilePath || (GetUIVersion() >= 5 && URL_SCHEME_SHELL == GetUrlSchemeW(pszPath)))
#endif // FEATURE_IE_USE_DESKTOP_PARSING
    {
        ASSERT(SUCCEEDED(hr));
        
        // Resolve any dot-dot path reference and remove trailing backslash
        if (fIsFilePath)
        {
            PathCanonicalize(szPath, pszPath);
            pszPath = szPath;

            // This call will cause a network hit: one connection attempt to \\server\IPC$
            // and then a series of FindFirst's - one for each directory.
            if (StrChr(pszPath, L'*') || StrChr(pszPath, L'?'))
            {
                hr = E_FAIL;
            }
        }
        
        if (SUCCEEDED(hr))
        {
            hr = SHILCreateFromPath(pszPath, ppidlOut, NULL);               
            TraceMsg(DM_CDOFPDN, "IECreateFromPath psDesktop->PDN(%s) returned %x", pszPath, hr);
        }
    }
    else
    {
        //
        // Need to put in buffer since ParseDisplayName doesn't take a 'const' string.
        StrCpyN(szPath, pszPath, ARRAYSIZE(szPath));
        pszPath = szPath;

        // Avoid the network and disk hits above for non-file urls.
        // This code path is taken on http: folks so a nice optimization. We will then drop
        // down below where we check the internet namespace.
        IShellFolder *psfRoot;
        hr = _GetInternetRoot(&psfRoot);
        if (SUCCEEDED(hr))
        {
            TraceMsg(TF_URLNAMESPACE, "IECFP(%s) calling g_psfInternet->PDN %x", pszPath, hr);
            LPITEMIDLIST pidlRel;

            hr = psfRoot->ParseDisplayName(NULL, (IBindCtx*)&DwnCodePage, szPath, NULL, &pidlRel, NULL);
            TraceMsg(DM_CDOFPDN, "IECreateFromPath called psfInternet->PDN(%s) %x", pszPath, hr);
            if (SUCCEEDED(hr))
            {
                *ppidlOut = ILCombine(c_pidlURLRoot, pidlRel);
                if (!*ppidlOut)
                    hr = E_OUTOFMEMORY;
                ILFree(pidlRel);
            }
            
            psfRoot->Release();
        }

    }

    // NOTE: NT5 beta 3 and before had a call to SHSimpleIDListFromPath().
    //       This is very bad because it will parse any garbage and prevent
    //       the caller from finding invalid strings.  I(BryanSt) needed
    //       this fixed for IEParseDisplayNameWithBCW() would fail on invalid
    //       address bar strings ("Search Get Rich Quick").
    TraceMsg(TF_URLNAMESPACE, "IECFP(%s) returning %x (hr=%x)",
             pszPath, *ppidlOut, hr);

    return hr;
}

HRESULT IECreateFromPathCPWithBCA(UINT uiCP, LPCSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut)
{
    WCHAR szPath[MAX_URL_STRING];

    ASSERT(lstrlenA(pszPath) < ARRAYSIZE(szPath));
    SHAnsiToUnicodeCP(uiCP, pszPath, szPath, ARRAYSIZE(szPath));

    return IECreateFromPathCPWithBCW(uiCP, szPath, pbc, ppidlOut);
}


HRESULT IEParseDisplayName(UINT uiCP, LPCTSTR pszPath, LPITEMIDLIST * ppidlOut)
{
    return IEParseDisplayNameWithBCW(uiCP, pszPath, NULL, ppidlOut);
}


// This function will do two things that IECreateFromPathCPWithBC() will not do:
// 1.  It will add the "Query" section of the URL into the pidl.
// 2.  If the URL has a fragment, this function will pass out a PIDL with the last
//     ID being the location.
// NOTE: If the caller needs the string to be "cleaned up" because the user manually
//       entered the URL, the caller needs to call ParseURLFromOutsideSource() before
//       calling this function.  That function should only be called on strings entered
//       by the user because of the perf hit and it could incorrectly format valid
//       parsible display names.  For example, ParseURLFromOutsideSource() will
//       convert the string "My Computer" into a search URL for yahoo.com
//       (http://www.yahoo.com/search.asp?p=My+p=Computer) when some callers
//       want that string parsed by an IShellFolder in the desktop.
HRESULT IEParseDisplayNameWithBCW(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut)
{
    TCHAR szPath[MAX_URL_STRING];
    LPCWSTR pwszFileLocation = NULL;
    WCHAR szQuery[MAX_URL_STRING];
    HRESULT hres;

    szQuery[0] = TEXT('\0');
#ifdef DEBUG
    if (IsFlagSet(g_dwDumpFlags, DF_URL)) 
    {
        TraceMsg(DM_TRACE, "IEParseDisplayName got %s", szPath);
    }
#endif

    //  We want to remove QUERY and FRAGMENT sections of
    //  FILE URLs because they need to be added in "Hidden" pidls.
    //  Also, URLs need to be escaped all the time except for paths
    //  to facility parsing and because we already removed all other
    //  parts of the URL (Query and Fragment).
    if (IsFileUrlW(pwszPath)) 
    {
        DWORD cchQuery = SIZECHARS(szQuery) - 1;
        
        pwszFileLocation = UrlGetLocationW(pwszPath);        

        if (SUCCEEDED(UrlGetPart(pwszPath, szQuery+1, &cchQuery, URL_PART_QUERY, 0)) && cchQuery)
            szQuery[0] = TEXT('?');

        DWORD cchPath = ARRAYSIZE(szPath);
        if (FAILED(PathCreateFromUrl(pwszPath, szPath, &cchPath, 0))) 
        {
            // Failed to parse it back. Use the original.
            StrCpyN(szPath, pwszPath, ARRAYSIZE(szPath));
        }
    }        
    else 
    {
        // If we failed, just try to use the original
        StrCpyN(szPath, pwszPath, ARRAYSIZE(szPath));
    }

#ifdef DEBUG
    if (IsFlagSet(g_dwDumpFlags, DF_URL)) 
        TraceMsg(DM_TRACE, "IEParseDisplayName calling IECreateFromPath %s", szPath);
#endif

    hres = IECreateFromPathCPWithBC(uiCP, szPath, pbc, ppidlOut);
    if (SUCCEEDED(hres) && pwszFileLocation)
    {
        ASSERT(*ppidlOut);
        *ppidlOut = IEILAppendFragment(*ppidlOut, pwszFileLocation);
        hres = *ppidlOut ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hres) && szQuery[0] == TEXT('?'))
    {
        *ppidlOut = ILAppendHiddenString(*ppidlOut, IDLHID_URLQUERY, szQuery);
        hres = *ppidlOut ? S_OK : E_OUTOFMEMORY;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\sftupmb.cpp ===
#include "priv.h"
#include "resource.h"

#include <mluisupp.h>

struct SUParams {
    LPSOFTDISTINFO  psdi;
    BITBOOL         bRemind : 1;
    BITBOOL         bDetails : 1;
    LONG            cyNoDetails;
    LONG            cxDlg;
    LONG            cyDlg;
};

INT_PTR CALLBACK SoftwareUpdateDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

SHDOCAPI_(DWORD) SoftwareUpdateMessageBox( HWND hWnd,
                                     LPCWSTR szDistUnit,
                                     DWORD dwFlags,
                                     LPSOFTDISTINFO psdi )
{
    HRESULT hr;
    int iRet = IDIGNORE;
    SOFTDISTINFO    sdi;
    SUParams suparams;
    DWORD dwAdStateNew = SOFTDIST_ADSTATE_NONE;

    if ( psdi == NULL )
    {
        // use a local 
        sdi.cbSize = sizeof(SOFTDISTINFO);
        sdi.dwReserved = 0;
        psdi = &sdi;
    }

    suparams.psdi = psdi;
    suparams.bRemind = TRUE;
    suparams.bDetails = FALSE;

    hr = GetSoftwareUpdateInfo( szDistUnit, psdi );
 
    // we need an HREF to work properly. The title and abstract are negotiable.
    if ( SUCCEEDED(hr) && psdi->szHREF != NULL )
    {
        // see if this is an update the user already knows about.
        // If it is, then skip the dialog.
        if (  (psdi->dwUpdateVersionMS >= psdi->dwInstalledVersionMS ||
                (psdi->dwUpdateVersionMS == psdi->dwInstalledVersionMS &&
                 psdi->dwUpdateVersionLS >= psdi->dwInstalledVersionLS))    && 
              (psdi->dwUpdateVersionMS >= psdi->dwAdvertisedVersionMS ||
                (psdi->dwUpdateVersionMS == psdi->dwAdvertisedVersionMS &&
                 psdi->dwUpdateVersionLS >= psdi->dwAdvertisedVersionLS)) )
        { 
            DWORD idDlg;

            if ( hr == S_OK ) // new version
            {
                // we have a pending update, either on the net, or downloaded
                if ( psdi->dwFlags & SOFTDIST_FLAG_USAGE_PRECACHE )
                {
                    dwAdStateNew = SOFTDIST_ADSTATE_DOWNLOADED;
                    // Show same dialog for downloaded/available states
                    // because users get confused. See IE5 RAID entry 14488
                    idDlg = IDD_SUAVAILABLE;
                }
                else
                {
                    dwAdStateNew = SOFTDIST_ADSTATE_AVAILABLE;
                    idDlg = IDD_SUAVAILABLE;
                }
            }
            else if ( psdi->dwUpdateVersionMS == psdi->dwInstalledVersionMS &&
                      psdi->dwUpdateVersionLS == psdi->dwInstalledVersionLS )
            {
                // if installed version matches advertised, then we autoinstalled already
                dwAdStateNew = SOFTDIST_ADSTATE_INSTALLED;
                idDlg = IDD_SUINSTALLED;
            }
            else
            {
                idDlg = 0;
            }

            // only show the dialog if we've haven't been in this ad state before for
            // this update version
            if ( dwAdStateNew > psdi->dwAdState && idDlg != 0)
            {
                // Sundown: coercion is OK since SoftwareUpdateDlgProc returns true/false
                iRet = (int) DialogBoxParam(MLGetHinst(),
                                            MAKEINTRESOURCE(idDlg),
                                            hWnd,
                                            SoftwareUpdateDlgProc,
                                            (LPARAM)&suparams);
            }
        } // if update is a newer version than advertised

        // If the user doesn't want a reminder and didn't cancel, mark the DU.

        if ( !suparams.bRemind && (iRet == IDNO || iRet == IDYES) )
        {
            SetSoftwareUpdateAdvertisementState( szDistUnit,
                                                dwAdStateNew,
                                                psdi->dwUpdateVersionMS,
                                                psdi->dwUpdateVersionLS );
        } // if we're finished with this ad state for this version
    } // if we got the update info
    else 
        iRet = IDABORT;

    if ( FAILED(hr) || psdi == &sdi )
    {
        if ( psdi->szTitle != NULL )
        {
            CoTaskMemFree( psdi->szTitle );
            psdi->szTitle = NULL;
        }
        if ( psdi->szAbstract != NULL )
        {
            CoTaskMemFree( psdi->szAbstract );
            psdi->szAbstract = NULL;
        };
        if ( psdi->szHREF != NULL )
        {
            CoTaskMemFree( psdi->szHREF );
            psdi->szHREF = NULL;
        }
    }

    return iRet;
}

INT_PTR CALLBACK SoftwareUpdateDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL        fRet = 0;
    SUParams    *psuparam = (SUParams*)GetWindowLongPtr(hDlg, DWLP_USER);;
    HRESULT     hr = S_OK;
    HWND hwndDetails;

    switch (msg)
    {
    case WM_INITDIALOG:
        int         cchDetails;
        TCHAR       *pszTitle;
        TCHAR       *pszAbstract;
        TCHAR       *pszDetails;
        TCHAR       szFmt[MAX_PATH];

        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        psuparam = (SUParams*)lParam;

        if (SHRestricted( REST_NOFORGETSOFTWAREUPDATE))
            EnableWindow(GetDlgItem(hDlg, IDC_REMIND), FALSE);

        // Prepare the details from the SOFTDISTINFO
        MLLoadString(IDS_SUDETAILSFMT, szFmt, ARRAYSIZE(szFmt) );
        cchDetails = lstrlen( szFmt );
        if ( psuparam->psdi->szTitle != NULL )
        {
            pszTitle = psuparam->psdi->szTitle;
        }
        else
        {
            pszTitle = NULL;
        }
        if ( psuparam->psdi->szAbstract != NULL )
        {
            pszAbstract = psuparam->psdi->szAbstract;
        }
        else
        {
            pszAbstract = NULL;
        }
        pszDetails = new TCHAR[cchDetails];
        if ( pszDetails != NULL )
        {
            wnsprintf( pszDetails, cchDetails, szFmt, ((pszTitle!=NULL)?pszTitle:TEXT("")),
                                         ((pszAbstract!=NULL)?pszAbstract:TEXT("")) );
            // set the details text
            SetDlgItemText( hDlg, IDC_DETAILSTEXT, pszDetails );
            // initialize the reminder check box
            CheckDlgButton( hDlg, IDC_REMIND, ((psuparam->bRemind)?BST_CHECKED:BST_UNCHECKED) );
            // Hide or show the details
            RECT rectDlg;
            RECT rectDetails;

            GetWindowRect( hDlg, &rectDlg );
            psuparam->cyDlg = rectDlg.bottom - rectDlg.top;
            psuparam->cxDlg = rectDlg.right - rectDlg.left;
            hwndDetails = GetDlgItem( hDlg, IDC_DETAILSTEXT );
            GetWindowRect( hwndDetails, &rectDetails );
            psuparam->cyNoDetails = rectDetails.top - rectDlg.top;
            SetWindowPos( hwndDetails, NULL, 0,0,0,0, SWP_NOMOVE | SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE );
            SetWindowPos( hDlg, NULL,
                          0,0,psuparam->cxDlg,psuparam->cyNoDetails,
                          SWP_NOMOVE | SWP_NOZORDER );
        }
        else
            EndDialog( hDlg, IDABORT );


        if ( pszDetails != NULL )
            delete pszDetails;

        fRet = TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDYES:
            EndDialog(hDlg, IDYES );
            fRet = TRUE;
            break;
        case IDNO:
            EndDialog(hDlg, IDNO );
            fRet = TRUE;
            break;
        case IDC_REMIND:
            psuparam->bRemind = IsDlgButtonChecked( hDlg, IDC_REMIND ) == BST_CHECKED;
            fRet = TRUE;
            break;
        case IDC_DETAILS:
            {
                TCHAR   szDetails[40];

                // toggle the details
                hwndDetails = GetDlgItem( hDlg, IDC_DETAILSTEXT );
                psuparam->bDetails = !psuparam->bDetails;

                if ( psuparam->bDetails )
                {
                    // show the details
                    // switch button to close text
                    MLLoadString(IDS_SUDETAILSCLOSE, szDetails, ARRAYSIZE(szDetails) );
                    SetDlgItemText( hDlg, IDC_DETAILS, szDetails );
                    SetWindowPos( hDlg, NULL,
                                  0,0,psuparam->cxDlg, psuparam->cyDlg,
                                  SWP_NOMOVE | SWP_NOZORDER );
                    SetWindowPos( hwndDetails, NULL, 0,0,0,0, SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE );
                }
                else
                {
                    MLLoadString(IDS_SUDETAILSOPEN, szDetails, ARRAYSIZE(szDetails) );
                    SetDlgItemText( hDlg, IDC_DETAILS, szDetails );
                    SetWindowPos( hwndDetails, NULL, 0,0,0,0, SWP_NOMOVE | SWP_HIDEWINDOW | SWP_NOZORDER | SWP_NOSIZE );
                    SetWindowPos( hDlg, NULL,
                                  0,0,psuparam->cxDlg,psuparam->cyNoDetails,
                                  SWP_NOMOVE | SWP_NOZORDER );
                }
            }
            fRet = TRUE;
            break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, IDNO);
        fRet = TRUE;
        break;

    case WM_DESTROY:
        fRet = TRUE;
        break;

    default:
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shdocvw.inc ===
#
# Common makefile include for this project
#
!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL=1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES= $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

C_DEFINES       = $(C_DEFINES) \
                  -DIN_SHDOCVW \
                  -DFEATURE_FRAMES \
                  -DMSOCT2=1 \
                  -DBETA1_DIALMON_HACK \
                  -DFEATURE_URLHIST \
                  -DFEATURE_PICS \
                  -DPAGER \
                  -D_HSFOLDER \
                  -DFAVORITESTOSHDOCVW \
                  -DMLUI_SUPPORT \
                  -DMLUI_MESSAGEBOX \
                  -DWINDOWS_ME

# Defines for deskmover
C_DEFINES       = $(C_DEFINES) \
                  -D_NTSDK -D_USRDLL -D_WINNT

!if "$(TEST_AMBIENTS)" == "1"
C_DEFINES       = $(C_DEFINES) -DTEST_AMBIENTS
!endif

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) \
                  -DVSTF
!endif

# We don't define _ATL_MIN_CRT because we implement the functions ourselves
# (crtfree.h).

# Bring in the ATL headers
USE_STATIC_ATL = 1

# Bring in the WTL headers
USE_WTL=1
WTL_VER=10

USE_MSVCRT      = 1

# be careful here-- shdocvw has to run downlevel. Don't add anything to
# the delayload line that you absolutely depend on having downlevel!
DELAYLOAD       = shell32.dll;browseui.dll;oleaut32.dll;wininet.dll;urlmon.dll;\
                  msrating.dll;mshtml.dll;mlang.dll;inetcomm.dll;ole32.dll;\
                  advpack.dll

!if !$(386)
DELAYLOAD       = $(DELAYLOAD);\
                  version.dll
!endif

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shembed.cpp ===
#include "priv.h"
#include "sccls.h"

#include <mluisupp.h>

#define IPSMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IPS::%s called", psz)
#define IPSMSG2(psz, hres)      TraceMsg(TF_SHDCONTROL, "she TR-IPS::%s %x", psz, hres)
#define IPSMSG3(pszName, psz)   TraceMsg(TF_SHDCONTROL, "she TR-IPS::%s:%s called", pszName,psz)
#define IOOMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IOO::%s called", psz)
#define IOOMSGX(psz, hres)      TraceMsg(TF_SHDCONTROL, "she TR-IOO::%s returning %x", psz, hres)
#define IOOMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "she TR-IOO::%s called with (%d)", psz, i)
#define IOOMSG3(psz, i, j)      TraceMsg(TF_SHDCONTROL, "she TR-IOO::%s called with (%d, %d)", psz, i, j)
#define IVOMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IVO::%s called", psz)
#define IVOMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "she TR-IVO::%s called with (%d)", psz, i)
#define IVOMSG3(psz, i, j)      TraceMsg(TF_SHDCONTROL, "she TR-IVO::%s with (%d, %d)", psz, i, j)
#define CCDMSG(psz, punk)       TraceMsg(TF_SHDCONTROL, "she TR-CSV::%s called punk=%x", psz, punk)
#define IDTMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IDT::%s called", psz)
#define IDTMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "she TR-IDT::%s called with %d", psz, i)
#define IDTMSG3(psz, x)         TraceMsg(TF_SHDCONTROL, "she TR-IDT::%s %x", psz, x)
#define IDTMSG4(psz, i, j)      TraceMsg(TF_SHDCONTROL, "she TR-IDT::%s called with %x,%x", psz, i, j)
#define IIPMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IOIPO::%s called", psz)
#define IIAMSG(psz)             TraceMsg(TF_SHDCONTROL, "she TR-IOIPAO::%s called", psz)
#define IEVMSG(psz, i, j, ps)   TraceMsg(TF_SHDCONTROL, "she TR-IEV::%s called celt=%d, _iCur=%d, %x", psz, i, j, ps)

const TCHAR c_szShellEmbedding[] = TEXT("Shell Embedding");

//
// A special lindex value to be passed to ::Draw member indicating
// that it is an internal call from ::GetData
//
#define LINDEX_INTERNAL 12345

// REVIEW: We may want to use the functions in UTIL.C -- they look more efficient...
//
//=========================================================================
// Helper functions
//=========================================================================

#define HIM_PER_IN 2540

int g_iXppli = 0;
int g_iYppli = 0;

void GetLogPixels()
{
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        g_iXppli = GetDeviceCaps(hdc, LOGPIXELSX);
        g_iYppli = GetDeviceCaps(hdc, LOGPIXELSY);
        ReleaseDC(NULL, hdc);
    }
}

// Scalar conversion of MM_HIMETRIC to MM_TEXT
void MetricToPixels(SIZEL* psize)
{
    ASSERT(g_iXppli);

    psize->cx = MulDiv(psize->cx, g_iXppli, HIM_PER_IN);
    psize->cy = MulDiv(psize->cy, g_iYppli, HIM_PER_IN);
}

// Scalar conversion of MM_TEXT to MM_HIMETRIC
void PixelsToMetric(SIZEL* psize)
{
    ASSERT(g_iYppli);

    psize->cx = MulDiv(psize->cx, HIM_PER_IN, g_iXppli);
    psize->cy = MulDiv(psize->cy, HIM_PER_IN, g_iYppli);
}


//=========================================================================
// CShellEmbedding implementaiton
//=========================================================================
HRESULT CShellEmbedding::v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellEmbedding, IPersist),
        QITABENT(CShellEmbedding, IOleObject),
        QITABENT(CShellEmbedding, IViewObject2),
        QITABENTMULTI(CShellEmbedding, IViewObject, IViewObject2),
        QITABENT(CShellEmbedding, IDataObject),
        QITABENT(CShellEmbedding, IOleInPlaceObject),
        QITABENTMULTI(CShellEmbedding, IOleWindow, IOleInPlaceObject),
        QITABENT(CShellEmbedding, IOleInPlaceActiveObject),
        QITABENT(CShellEmbedding, IInternetSecurityMgrSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

CShellEmbedding::CShellEmbedding(IUnknown* punkOuter, LPCOBJECTINFO poi, const OLEVERB* pverbs)
    : _pverbs(pverbs)
    , _nActivate(OC_DEACTIVE)
    , CAggregatedUnknown(punkOuter)
{
    TraceMsg(TF_SHDCONTROL, "ctor CShellEmbedding %x", this);

    DllAddRef();
    _RegisterWindowClass();
    _pObjectInfo = poi;
    _size.cx = 50;
    _size.cy = 20;

    // make sure some globals are set
    GetLogPixels();

    // let our logical size match our physical size
    _sizeHIM = _size;
    PixelsToMetric(&_sizeHIM);
}

CShellEmbedding::~CShellEmbedding()
{
    ASSERT(_hwnd==NULL);
    // IE v 4.1 bug 44541.  In an Office 97 user form, we were seeing this destructor get entered
    // with a non-null hwnd, which would cause a fault the next time the hwnd received a message.
    // 
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    ASSERT(_hwndChild==NULL);
    ASSERT(_pcli==NULL);
    ASSERT(_pipsite==NULL);
    ASSERT(_pipframe==NULL);
    ASSERT(_pipui==NULL);

    //
    // WARNING: Don't call any of virtual functions of this object
    //  itself for clean-up purpose. The Vtable is alreadly adjusted
    //  and we won't be able to perform any full clean up. Do it
    //  right before you delete in CShellEmbedding::CSVInner::Release.
    //
    TraceMsg(TF_SHDCONTROL, "dtor CShellEmbedding %x", this);

    // Warning: if the client site has not been released do not release the advise
    // object as some applications like VC5 will fault on this...
    if (_padv) {
        _padv->OnClose();
        if (!_pcli)
            ATOMICRELEASE(_padv);
    }

    if (!_pcli)
    {
        ATOMICRELEASE(_pdah);
        ATOMICRELEASE(_poah);
    }
    ATOMICRELEASE(_pstg);
    ATOMICRELEASE(_pcliHold);


    DllRelease();
}

// **************** IPersist ****************
HRESULT CShellEmbedding::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSIDOFOBJECT(this);

    return S_OK;
}

BOOL CShellEmbedding::_ShouldDraw(LONG lindex)
{
    // Don't draw if the window is visible.
    return ! (_pipsite && lindex!=LINDEX_INTERNAL);
}

// **************** IViewObject ****************
HRESULT CShellEmbedding::Draw(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL ( __stdcall *pfnContinue )(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    IVOMSG3(TEXT("Draw called"), lprcBounds->top, lprcBounds->bottom);

    // WARNING: this looks wrong to me -- I think we should always respond
    // to a Draw request, as the hdcDraw may not be the screen!
    //
    // Don't draw if the window is visible.
    if (!_ShouldDraw(lindex)) {
        return S_OK;
    }

    if (_hwnd) {
        int iDC = SaveDC(hdcDraw);
          RECTL rcBounds = *lprcBounds;
          ::LPtoDP(hdcDraw, (LPPOINT)&rcBounds, 2);
          IVOMSG3(TEXT("Draw DP=="), rcBounds.top, rcBounds.bottom);
          TraceMsg(TF_SHDCONTROL, "she Draw cx=%d cy=%d", rcBounds.right-rcBounds.left, rcBounds.bottom-rcBounds.top);

          SetMapMode(hdcDraw, MM_TEXT);         // make it 1:1
          SetMapMode(hdcDraw, MM_ANISOTROPIC);  // inherit call from MM_TEXT
          POINT pt;
          SetViewportOrgEx(hdcDraw, rcBounds.left, rcBounds.top, &pt);

          // APPCOMPAT: WordPad does a GetExtent to get the size and passes that in as lprcBounds
          // *without* doing a SetExtent, so when we resize larger (due to a BROWSE verb) _hwnd
          // is still the old size. So we IntersectClipRect to _hwnd but WordPad draws the border
          // to rcBounds. Ugly.

           RECT rc;
           GetClientRect(_hwnd, &rc);
           IntersectClipRect(hdcDraw, 0, 0, rc.right, rc.bottom);
           SendMessage(_hwnd, WM_PRINT, (WPARAM)hdcDraw,
                       PRF_NONCLIENT|PRF_CLIENT|PRF_CHILDREN|PRF_ERASEBKGND);

         SetViewportOrgEx(hdcDraw, pt.x, pt.y, NULL);
        RestoreDC(hdcDraw, iDC);
        return S_OK;
    }

    return OLE_E_BLANK;
}

HRESULT CShellEmbedding::GetColorSet(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    IVOMSG(TEXT("GetColorSet"));
    return S_FALSE;     // Indicating that the object doesn't care
}

HRESULT CShellEmbedding::Freeze(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DWORD *pdwFreeze)
{
    IVOMSG(TEXT("Freeze"));
    *pdwFreeze = 0;
    return S_OK;
}

HRESULT CShellEmbedding::Unfreeze(DWORD dwFreeze)
{
    IVOMSG(TEXT("Unfreeze"));
    return S_OK;
}

HRESULT CShellEmbedding::SetAdvise(
    DWORD aspects,
    DWORD advf,
    IAdviseSink *pAdvSink)
{
    IVOMSG2(TEXT("SetAdvise"), pAdvSink);

    if (advf & ~(ADVF_ONLYONCE | ADVF_PRIMEFIRST))
        return E_INVALIDARG;

    if (pAdvSink != _padv)
    {
        ATOMICRELEASE(_padv);

        if (pAdvSink)
        {
            _padv = pAdvSink;
            _padv->AddRef();
        }
    }

    _asp  = aspects;
    _advf = advf;

    if (advf & ADVF_PRIMEFIRST)
        _SendAdvise(OBJECTCODE_VIEWCHANGED);

    return S_OK;
}

HRESULT CShellEmbedding::GetAdvise(
    DWORD *pAspects,
    DWORD *pAdvf,
    IAdviseSink **ppAdvSink)
{
    IVOMSG(TEXT("GetAdvise"));
    if (pAspects) {
        *pAspects = _asp;
    }

    if (pAdvf) {
        *pAdvf = _advf;
    }

    if (ppAdvSink) {
        *ppAdvSink = _padv;
        if (_padv) {
            _padv->AddRef();
        }
    }

    return S_OK;
}

// **************** IViewObject2 ****************
HRESULT CShellEmbedding::GetExtent(
    DWORD dwDrawAspect,
    LONG lindex,
    DVTARGETDEVICE *ptd,
    LPSIZEL lpsizel)
{
    TraceMsg(TF_SHDCONTROL, "she GetExtent cx=%d cy=%d", _size.cx, _size.cy);
    lpsizel->cx = _size.cx;
    lpsizel->cy = _size.cy;
    PixelsToMetric(lpsizel);
    return S_OK;
}

//
// **************** IOleObject ****************
//

void CShellEmbedding::_OnSetClientSite()
{
    if (_pcli)
    {
        IOleInPlaceSite* pipsite;
        if (SUCCEEDED(_pcli->QueryInterface(IID_IOleInPlaceSite, (LPVOID*)&pipsite)))
        {
            _CreateWindowOrSetParent(pipsite);
            pipsite->Release();
        }
    }
    else if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
}

HRESULT CShellEmbedding::SetClientSite(IOleClientSite *pClientSite)
{
    IOOMSG2(TEXT("SetClientSite"), pClientSite);

    // If I have a client site on hold, get rid of it.
    //
    ATOMICRELEASE(_pcliHold);

    if (_pcli == pClientSite)
    {
        // mshtml is hitting their initialization code twice
        // no need for us to do anything here.
    }
    else
    {
        ATOMICRELEASE(_pcli);
        ATOMICRELEASE(_pipsite);
        ATOMICRELEASE(_pipframe);
        ATOMICRELEASE(_pipui);
    
        _pcli = pClientSite;
    
        if (_pcli)
            _pcli->AddRef();

        _OnSetClientSite();
    }

    return S_OK;
}


//
//  This function create _hwnd (the parent of this embedding) if it not
// created yet. Otherwise, it simply SetParent appropriately.
//
// NOTE: When this object is embedded in PowerPoint 95, the first
//  CreateWindowEx fails  when this function if called from SetClientSite
//  for some unknown reason.
//   It, however, succeeds when it is called from DoVerb. We should find
//  it out.
//
HRESULT CShellEmbedding::_CreateWindowOrSetParent(IOleWindow* pwin)
{
    HWND hwndParent = NULL;
    HRESULT hres = S_OK;

    //
    // NOTES: Unlike IE3.0, we don't fail even if pwin->GetWindow fails.
    //  It allows Trident to SetClientSite (and Navigate) before they
    //  are In-place Activated. In that case (hwndParent==NULL), we
    //  create a top-level window hidden and use it for navigation.
    //  When we are being InPlaceActivated, we hit this function again
    //  and set the parent (and window styles) correctly. Notice that
    //  we need to set WS_POPUP to avoid the Window Manager automatically
    //  add other random styles for verlapped window. 
    //
    pwin->GetWindow(&hwndParent);
#ifdef DEBUG
    // Pretend that GetWindow failed here.
    if (_hwnd==NULL && (g_dwPrototype & 0x00000200))
    {
        TraceMsg(DM_TRACE, "CSE::_CreateWindowOrSetParent pretend unsuccessful GetWindow");
        hwndParent = NULL;
    }
#endif

    _fOpen = TRUE;
    
    if (_hwnd) 
    {
        SetParentHwnd(_hwnd, hwndParent);

    } 
    else 
    {
        _hwnd = SHNoFusionCreateWindowEx(
            WS_EX_WINDOWEDGE,
            c_szShellEmbedding, NULL,
            (hwndParent ?
                (WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_TABSTOP)
                : (WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_TABSTOP)),
            0, 0, _rcPos.right - _rcPos.left, _rcPos.bottom - _rcPos.top,
            hwndParent,
            (HMENU)0,
            HINST_THISDLL,
            (LPVOID)SAFECAST(this, CImpWndProc*));

        if (!_hwnd) 
        {
            hres = E_FAIL;
            TraceMsg(TF_SHDCONTROL, "sdv TR-IOO::_CreateWindowOrSetParent CreateWindowEx failed (%d)", GetLastError());
        }
    }

    return hres;
}
HRESULT CShellEmbedding::GetClientSite(IOleClientSite **ppClientSite)
{
    IOOMSG(TEXT("GetClientSite"));
    *ppClientSite = _pcli;

    if (_pcli) {
        _pcli->AddRef();
    }

    return S_OK;
}

HRESULT CShellEmbedding::SetHostNames(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObj)
{
    IOOMSG(TEXT("SetHostNames"));
    // We are not interested in host name
    return S_OK;
}


// A container application calls IOleObject::Close when it wants
// to move the object from a running to a loaded state. Following
// such a call, the object still appears in its container but is
// not open for editing. Calling IOleObject::Close on an object
// that is loaded but not running has no effect.
//
HRESULT CShellEmbedding::Close(DWORD dwSaveOption)
{
    IOOMSG2(TEXT("Close"), dwSaveOption);
    // Change the state of object back to TEXT("loaded") state.

    BOOL fSave = FALSE;
    if (_fDirty &&
        ((OLECLOSE_SAVEIFDIRTY==dwSaveOption)
         || (dwSaveOption==OLECLOSE_PROMPTSAVE))) {
        fSave = TRUE;
    }

    if (fSave) {
        _SendAdvise(OBJECTCODE_SAVEOBJECT);
        _SendAdvise(OBJECTCODE_SAVED);
    }

    _SendAdvise(OBJECTCODE_CLOSED);
    _fOpen = FALSE;

    // "loaded but not running" is confusing wording... If you look
    // at the OLEIVERB_HIDE comment in _OnActivateChange, it mentions
    // that OLEIVERB_HIDE puts it in the state "just after loading"
    // and puts us in OC_DEACTIVE state. Let's do that here as well.
    //
    // it just came to my awareness that OCs UIDeactivate,
    //         not IPDeactivate...
    _DoActivateChange(NULL, OC_DEACTIVE, FALSE);

    // It seems like some containers (Trident frame set) don't
    // do a SetClientSite(NULL) on us, so do it here. Old code here
    // did a DestroyWindow(_hwnd), which SetClientSite(NULL) will do.
    // NOTE: VB does call SetClientSite, but they do it after Close.

    // If we already have one on hold, release it.
    //
    ATOMICRELEASE(_pcliHold);

    // Hold onto our client site.  We may need it if we're DoVerbed, as Office tends to do.
    //

    IOleClientSite  *pOleClientSite = _pcli;
    if (pOleClientSite)
    {
        pOleClientSite->AddRef();
    }

    SetClientSite(NULL);

    _pcliHold = pOleClientSite;

    return S_OK;
}

HRESULT CShellEmbedding::SetMoniker(
    DWORD dwWhichMoniker,
    IMoniker *pmk)
{
    IOOMSG(TEXT("SetMoniker"));
    // We are not interested in moniker.
    return S_OK;
}

HRESULT CShellEmbedding::GetMoniker(
    DWORD dwAssign,
    DWORD dwWhichMoniker,
    IMoniker **ppmk)
{
    IOOMSG(TEXT("GetMoniker"));
    return E_NOTIMPL;
}

HRESULT CShellEmbedding::InitFromData(
    IDataObject *pDataObject,
    BOOL fCreation,
    DWORD dwReserved)
{
    IOOMSG(TEXT("InitFromData"));
    // LATER: We may want to implement this later.
    return E_FAIL;
}

HRESULT CShellEmbedding::GetClipboardData(
    DWORD dwReserved,
    IDataObject **ppDataObject)
{
    IOOMSG(TEXT("GetClipboardData"));
    return E_FAIL;
}

HRESULT CShellEmbedding::DoVerb(
    LONG iVerb,
    LPMSG lpmsg,
    IOleClientSite *pActiveSite,
    LONG lindex,
    HWND hwndParent,
    LPCRECT lprcPosRect)
{
    IOOMSG2(TEXT("DoVerb"), iVerb);
    HRESULT hres = S_OK;

    // If I don't have a client site, but I have one on "hold", I need to set it up again.
    //
    if (_pcli == NULL
        && _pcliHold)
    {
        IOleClientSite *pOleClientSite = _pcliHold;
        _pcliHold = NULL;
        SetClientSite(pOleClientSite);
        pOleClientSite->Release();
    }

    switch(iVerb)
    {
    case OLEIVERB_HIDE:
        hres = _DoActivateChange(NULL, OC_DEACTIVE, FALSE);
        break;

    case OLEIVERB_OPEN:
        hres = E_FAIL;
        break;

    case OLEIVERB_PRIMARY:
    case OLEIVERB_SHOW:
        if (_pipsite) {
            return S_OK;
        }
        // Fall through
    case OLEIVERB_UIACTIVATE:
        hres = _DoActivateChange(pActiveSite, OC_UIACTIVE, TRUE); //TRUE => We want to force UIACTIVE even if we are already active.
        break;

    case OLEIVERB_INPLACEACTIVATE:
        hres = _DoActivateChange(pActiveSite, OC_INPLACEACTIVE, FALSE);
        break;

    default:
        hres = E_FAIL; // OLEOBJ_S_INVALDVERB;
        break;
    }

    IOOMSGX(TEXT("DoVerb"), hres);
    return hres;
}

//
// fForce == TRUE indicates that we need to call _OnActivateChange even if we
// are already in OC_UIACITVE state.
//
HRESULT CShellEmbedding::_DoActivateChange(IOleClientSite* pActiveSite, UINT uState, BOOL fForce)
{
    if (uState == _nActivate)
    {
        // in general, we have nothing to do if we're already in
        // the correct state. HOWEVER, OLEIVERB_UIACTIVATE is supposed
        // to set focus if we (or our children?) don't currently have it.
        // Fall into _OnActivateChange so CWebBrowserOC can tell the
        // base browser to go uiactive.
        //
        if ((uState != OC_UIACTIVE) || !fForce)
            return S_OK;
    }

    #define STATETOSTRING(n) (n==OC_DEACTIVE ? TEXT("OC_DEACTIVE") : (n==OC_INPLACEACTIVE ? TEXT("OC_INPLACEACTIVE") : (n== OC_UIACTIVE ? TEXT("OC_UIACTIVE") : TEXT("ERROR"))))
    TraceMsg(TF_SHDCONTROL, "she _DoActivateChange from %s to %s", STATETOSTRING(_nActivate), STATETOSTRING(uState));

    return _OnActivateChange(pActiveSite, uState);
}

HRESULT CShellEmbedding::_OnActivateChange(IOleClientSite* pActiveSite, UINT uState)
{
    if (uState != _nActivate)
    {
        // mark us in our new state immediately. this avoids recursion death with bad containers (ipstool)
        UINT uOldState = _nActivate;
        _nActivate = uState;
    
        if (uOldState == OC_DEACTIVE) // going from deactive to IP or UI active
        {
            if (pActiveSite==NULL)
            {
                _nActivate = uOldState;
                return E_INVALIDARG;
            }
    
            ASSERT(!_pipsite); // always true, so why check below?
            if (!_pipsite)
            {
                HRESULT hres = pActiveSite->QueryInterface(IID_IOleInPlaceSite, (LPVOID*)&_pipsite);
        
                if (FAILED(hres))
                {
                    _nActivate = uOldState;
                    return hres;
                }
                
                hres = _pipsite->CanInPlaceActivate();
                if (hres != S_OK) {
                    ATOMICRELEASE(_pipsite);
                    TraceMsg(TF_SHDCONTROL, "she - CanInPlaceActivate returned %x", hres);
                    _nActivate = uOldState;
                    return E_FAIL;
                }
        
                _OnInPlaceActivate(); // do it
            }
        }
        else if (uOldState == OC_UIACTIVE) // going from UIActive to IPActive or deactive
        {
            _OnUIDeactivate();
        }
    
        if (uState == OC_UIACTIVE) // going to UIActive
        {
            _OnUIActivate();
        }
        else if (uState == OC_DEACTIVE) // going to Deactive
        {
            // We fail creation (OLEIVERB_PRIMARY, OLEIVERB_SHOW,
            // OLEIVERB_UIACTIVATE, or OLEIVERB_INPLACEACTIVATE) if we don't
            // get a pipsite, so we should never hit this case.
            ASSERT(_pipsite);
            // OLEIVERB_HIDE should ... return it to the visual state just after
            // initial creation or reloading, before OLEIVERB_SHOW or OLEIVERB_OPEN
            // is sent. Which is what _InPlaceDeactivate does. What's the point of this?
            // htmlobj calls OLEIVERB_HIDE and then ::InPlaceDeactivate
            _OnInPlaceDeactivate();
        }
    }

    return S_OK;
}

// move from de-active to in-place-active
void CShellEmbedding::_OnInPlaceActivate()
{
    //
    // Set the appropriate parent window.
    //
    _CreateWindowOrSetParent(_pipsite);

    _pipsite->OnInPlaceActivate();
    ASSERT(_pipframe == NULL);
    ASSERT(_pipui == NULL);
    _finfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    _pipsite->GetWindowContext(&_pipframe, &_pipui,
                               &_rcPos, &_rcClip, &_finfo);

    TraceMsg(TF_SHDCONTROL, "she::_OnInPlaceActivate x=%d y=%d cx=%d cy=%d (_cx=%d _cy=%d)", _rcPos.left, _rcPos.top, _rcPos.right-_rcPos.left, _rcPos.bottom-_rcPos.top, _size.cx, _size.cy);
    SetWindowPos(_hwnd, 0,
                 _rcPos.left, _rcPos.top,
                 _rcPos.right-_rcPos.left,
                 _rcPos.bottom-_rcPos.top,
                 SWP_SHOWWINDOW | SWP_NOZORDER);

    _SendAdvise(OBJECTCODE_SHOWOBJECT); // just like OLE 2nd ed (p.1074)
}

// Move from in-place-active to de-active
void CShellEmbedding::_OnInPlaceDeactivate(void)
{
    if (_hwnd) {
        ShowWindow(_hwnd, SW_HIDE);

        // re-parent our _hwnd... when we're not active we can't rely on
        // what our parent window is doing. The container can even destroy it!
        //
        // FEATURE: the standard thing to do here is DESTROY our HWND and
        // recreate it if/when we are reactivated. This may break our hosted
        // IShellView and draw code. Investigate this.
        //

        // APPCOMPAT: this has been taken out by CDturner, MikeSH assures me we don't need it, and 
        // this is causing our app to lose activation and regain it which causes the 
        // palette to flash on 256 colour machines...y
        // SetParentHwnd(_hwnd, NULL);
    }

    if (_pipsite) {
        _pipsite->OnInPlaceDeactivate();
        ATOMICRELEASE(_pipsite);
    }

    ATOMICRELEASE(_pipframe);
    ATOMICRELEASE(_pipui);

    //
    // We need to tell the container to update the cached metafile, if any.
    //
    _SendAdvise(OBJECTCODE_DATACHANGED);

}

// move from in-place-active to ui-active
void CShellEmbedding::_OnUIActivate(void)
{
    if (_pipsite) {
        _pipsite->OnUIActivate();
    }

    //
    // HACK: When we are in Excel, _pipui->SetActiveObject sets the focus
    //  to us (for some unknown reason -- trying to be nice?). Since _hwnd
    //  simply forward the focus to the _hwndChild, setting focus to _hwnd
    //  twice causes this:
    //
    //   1. SetFocus(_hwnd)             by us (if we call SetFocus(_hwnd))
    //   2. SetFocus(_hwndChild)        in _hwnd's wndproc
    //   3. SetFocus(_hwnd)             by Excel
    //   4. SetFocus(_hwndChild)        in _hwnd's wndproc
    //
    //   If _hwndChild is a control, it notifies to the parent that it
    //  lost the focus. Then, we think "oh, we lost the focus. We should
    //  deactivate this object". To avoid it, we don't call SetFocus before
    //  we call _pipui->SetActiveObject and do some tricky thing below.
    //
    // SetFocus(_hwnd);

    //
    // RDuke suggest us to change the second parameter to NULL (instead of
    // "FOO" in IE3, but we don't know the side effect of it. I'm changing
    // it to "item" for IE4. (SatoNa)
    //
    if (_pipframe) {
        _pipframe->SetActiveObject(SAFECAST(this, IOleInPlaceActiveObject*), L"item");
    }

    if (_pipui) {
        _pipui->SetActiveObject(SAFECAST(this, IOleInPlaceActiveObject*), L"item");
    }

    //
    // We don't have any menu, so tell the container to use its own menu.
    //
    if (_pipframe) {
        _pipframe->SetMenu(NULL, NULL, _hwnd);
    }

    // Find-out if one of our child window has the input focus.
    for (HWND hwndFocus = GetFocus();
         hwndFocus && hwndFocus!=_hwnd;
         hwndFocus = GetParent(hwndFocus))
    {}

    // If not, set it.
    if (hwndFocus==NULL) {
         SetFocus(_hwnd);
    }

    // If this UIActivate came from below (i.e., our hosted DocObject), then we need to inform
    // our container.  We do this by calling IOleControlSite::OnFocus.  VB5 and Visual FoxPro
    // (at least) rely on this call being made for proper focus handling.
    //
    IUnknown_OnFocusOCS(_pcli, TRUE);
}

void CShellEmbedding::_OnUIDeactivate(void)
{
    //
    // We don't have any shared menu or tools to clean up.
    //

    if (_pipframe) {
        _pipframe->SetActiveObject(NULL, NULL);
    }

    if (_pipui) {
        _pipui->SetActiveObject(NULL, NULL);
    }

    if (_pipsite) {
        _pipsite->OnUIDeactivate(FALSE);
    }
    // If this UIDeactivate came from below (i.e., our hosted DocObject), then we need to inform
    // our container.  We do this by calling IOleControlSite::OnFocus.  VB5 and Visual FoxPro
    // (at least) rely on this call being made for proper focus handling.
    //
    IUnknown_OnFocusOCS(_pcli, FALSE);
}



HRESULT CShellEmbedding::EnumVerbs(
    IEnumOLEVERB **ppEnumOleVerb)
{
    IOOMSG(TEXT("EnumVerbs"));
    *ppEnumOleVerb = new CSVVerb(_pverbs);
    return *ppEnumOleVerb ? S_OK : E_OUTOFMEMORY;
}

HRESULT CShellEmbedding::Update( void)
{
    IOOMSG(TEXT("Update"));
    // Always up-to-date

    return S_OK;
}

HRESULT CShellEmbedding::IsUpToDate( void)
{
    IOOMSG(TEXT("IsUpToDate"));
    // Always up-to-date
    return S_OK;
}

HRESULT CShellEmbedding::GetUserClassID(CLSID *pClsid)
{
    IOOMSG(TEXT("GetUserClassID"));
    return GetClassID(pClsid);
}

HRESULT CShellEmbedding::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    return OleRegGetUserType(CLSIDOFOBJECT(this), dwFormOfType, pszUserType);
}

HRESULT CShellEmbedding::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    // SetExtent sets the LOGICAL size of an object. SetObjectRects determins
    // the size of the object on the screen. If we cared about zooming, we'd
    // keep track of this and do some sort of scaling. But we don't.
    // We still need to remember this value so we return it on GetExtent.
    //
    _sizeHIM = *psizel;

    // HOWEVER, IE3 shipped a SetExtent that changed the physical size of the
    // object. For compat (AOL uses SetExtent to change the size), if we're the
    // old WebBrowser, continue to resize.
    //
    if (_pObjectInfo->pclsid == &CLSID_WebBrowser_V1)
    {
        RECT rc;
        HDC   hdc;
        int   mmOld;
        POINT pt;

        // Make sure a container doesn't do anything strange like
        // make us negative size
        //
        // APPCOMPAT: this breaks Trident because it sizes us negative
        // and we fail that sizing and they get confused...
        //
        //ASSERT(psizel->cx >= 0 && psizel->cy <= 0);
        //if (psizel->cx < 0 || psizel->cy > 0)
        //    return E_FAIL;
    
        // We only support DVASPECT_CONTENT
        if (dwDrawAspect != DVASPECT_CONTENT)
            return E_NOTIMPL;
    
        // Map this to a SetObjectRects call -- that way superclasses
        // only have to watch one function for size changes
        //

        int nScaleFactorX = 1, nScaleFactorY = 1;

        pt.x = psizel->cx;
        pt.y = psizel->cy;

        hdc = GetDC(NULL);

        if (hdc)
        {
            mmOld = SetMapMode(hdc, MM_HIMETRIC);

            if (!g_fRunningOnNT)  // if running on Win95
            {
                // Win95 doesn't like coordinates over 32K

                // SHRT_MIN and SHRT_MAX defined in $NT/public/sdk/inc/crt/limits.h

                while (pt.x > SHRT_MAX || pt.x < SHRT_MIN)
                {
                    pt.x >>= 1;
                    nScaleFactorX <<= 1;
                }
                while (pt.y > SHRT_MAX || pt.y < SHRT_MIN)
                {
                    pt.y >>= 1;
                    nScaleFactorY <<= 1;
                }
            }

            LPtoDP(hdc, &pt, 1);

            if (!g_fRunningOnNT)
            {
                pt.x *= nScaleFactorX;
                pt.y *= nScaleFactorY;
            }

            pt.y = -pt.y;
            SetMapMode(hdc, mmOld);
            ReleaseDC(NULL, hdc);
        }
    
        rc.left = _rcPos.left;
        rc.right = rc.left + pt.x;
        rc.top = _rcPos.top;
        rc.bottom = rc.top + pt.y;
    
        // Assume that using SetExtent adjusts both the pos and clip rects
        return SetObjectRects(&rc, NULL);
    }
    else
    {
        return S_OK;
    }
}

HRESULT CShellEmbedding::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    *psizel = _sizeHIM;
    return S_OK;
}

HRESULT CShellEmbedding::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    IOOMSG2(TEXT("Advise"), pAdvSink);
    HRESULT hr = E_INVALIDARG;

    if (!pdwConnection)
        return hr;

    *pdwConnection = NULL;              // set out params to NULL

    if (!_poah)
        hr = ::CreateOleAdviseHolder(&_poah);
    else
        hr = NOERROR;

    if( SUCCEEDED(hr) )
        hr = _poah->Advise(pAdvSink, pdwConnection);

    return(hr);
}

HRESULT CShellEmbedding::Unadvise(DWORD dwConnection)
{
    IOOMSG(TEXT("Unadvise"));
    HRESULT     hr;

    if (!_poah)
        return(OLE_E_NOCONNECTION);

    hr = _poah->Unadvise(dwConnection);

    return(hr);
}

HRESULT CShellEmbedding::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    IOOMSG(TEXT("EnumAdvise"));
    HRESULT     hr;

    if (!ppenumAdvise)
        return(E_INVALIDARG);

    if (!_poah)
    {
        *ppenumAdvise = NULL;
        hr = S_OK;
    }
    else
    {
        hr = _poah->EnumAdvise(ppenumAdvise);
    }

    return(hr);
}

HRESULT CShellEmbedding::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    IOOMSG(TEXT("GetMiscStatus"));

    *pdwStatus = OLEMISCFLAGSOFCONTROL(this);

    return S_OK;
}

HRESULT CShellEmbedding::SetColorScheme(LOGPALETTE *pLogpal)
{
    IOOMSG(TEXT("GetColorScheme"));
    return S_OK;
}

//
//  Helper function to create an HDC from an OLE DVTARGETDEVICE structure.
//  Very useful for metafile drawing, where the Metafile DC will be the 
//  actual "draw to" dc, and the TargetDC, if present, will describe the ultimate output device.
//
HDC CShellEmbedding::_OleStdCreateDC(DVTARGETDEVICE *ptd)
{
    HDC        hdc = NULL;
    LPDEVNAMES lpDevNames = NULL;
    LPDEVMODEA lpDevMode = NULL;
    LPSTR      lpszDriverName = NULL;
    LPSTR      lpszDeviceName = NULL;
    LPSTR      lpszPortName = NULL;

    if (ptd)
    {
        lpDevNames = (LPDEVNAMES) ptd;
        if (ptd->tdExtDevmodeOffset)
        {
            lpDevMode = (LPDEVMODEA) ( (LPSTR) ptd + ptd->tdExtDevmodeOffset);
        }

        lpszDriverName = (LPSTR) lpDevNames + ptd->tdDriverNameOffset;
        lpszDeviceName = (LPSTR) lpDevNames + ptd->tdDeviceNameOffset;
        lpszPortName   = (LPSTR) lpDevNames + ptd->tdPortNameOffset;

        hdc = CreateDCA(lpszDriverName, lpszDeviceName, lpszPortName, lpDevMode);
    }
    return hdc;
}

// *** IDataObject ***
//
// WARNING:
//   It is well-known fact that Word and Excel (in Office95) does not call
//  IViewObject::Draw to draw embedding. Instead, they GetData(CF_METAFILEPICT).
//  If we don't offer it, Word will fail to embed it and Excel will draw
//  white rectangle when our object is deactivated. To be embedded correctly
//  on those apps, we must support CF_METAFILEPICT. (SatoNa)
//
HRESULT CShellEmbedding::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    IDTMSG4(TEXT("GetData"), pformatetcIn->cfFormat, pformatetcIn->tymed);
    HRESULT hres = DV_E_FORMATETC;
    HDC hdcTargetDevice = NULL;
    HENHMETAFILE hemf = NULL;

    // If a Target device is specified in the FORMATETC structure, create a DC for it.
    // This gets passed to CreateEnhMetaFile and IViewObject::Draw.
    //
    if (pformatetcIn->ptd) 
    {
        hdcTargetDevice = _OleStdCreateDC(pformatetcIn->ptd);
        if (!hdcTargetDevice)
        {
            return E_FAIL;
        }
    }

    // Enhanced metafiles need special processing.
    //
    if (pformatetcIn->cfFormat == CF_ENHMETAFILE
        && (pformatetcIn->tymed & TYMED_ENHMF))
    {
        if (_hwnd)
        {
            RECTL rectBounds = { 0, 0, _sizeHIM.cx, _sizeHIM.cy };

            //
            // Call the "A" version since we're not passing in strings and
            // this needs to work on W95.
            HDC hdc = CreateEnhMetaFileA(hdcTargetDevice, NULL, (RECT*)&rectBounds, NULL);
            IDTMSG3(TEXT("_EnhMetafileFromWindow CreateEnhMetaFile returned"), hdc);
            if (hdc)
            {
                SetMapMode(hdc, MM_HIMETRIC);
                rectBounds.bottom = -rectBounds.bottom;

                Draw(DVASPECT_CONTENT, LINDEX_INTERNAL, NULL, pformatetcIn->ptd,
                     hdcTargetDevice, hdc, &rectBounds, NULL, NULL, 0);

                hemf = CloseEnhMetaFile(hdc);
                IDTMSG3(TEXT("_EnhMetafileFromWindow CloseEnhMetaFile returned"), hemf);
            }
        }

        pmedium->hEnhMetaFile = hemf;
        if (pmedium->hEnhMetaFile) 
        {
            pmedium->tymed = TYMED_ENHMF;
            pmedium->pUnkForRelease = NULL;
            hres = S_OK;
        } 
        else 
        {
            hres = E_FAIL;
        }
    }

    // Create a standard metafile
    //
    else if (pformatetcIn->cfFormat == CF_METAFILEPICT
        && (pformatetcIn->tymed & TYMED_MFPICT))
    {
        hres = E_OUTOFMEMORY;
        HGLOBAL hmem = GlobalAlloc(GPTR, sizeof(METAFILEPICT));
        if (hmem)
        {
            LPMETAFILEPICT pmf = (LPMETAFILEPICT) hmem;
            RECTL rectBounds = { 0, 0, _sizeHIM.cx, _sizeHIM.cy };

            HDC hdc = CreateMetaFile(NULL);
            if (hdc)
            {
                SetMapMode(hdc, MM_HIMETRIC);
                rectBounds.bottom = -rectBounds.bottom;

                SetWindowOrgEx(hdc, 0, 0, NULL);
                SetWindowExtEx(hdc, _sizeHIM.cx, _sizeHIM.cy, NULL);

                Draw(DVASPECT_CONTENT, LINDEX_INTERNAL, NULL, 
                    pformatetcIn->ptd, hdcTargetDevice,
                    hdc, &rectBounds, &rectBounds, NULL, 0);

                pmf->hMF = CloseMetaFile(hdc);

                if (pmf->hMF)
                {
                    pmf->mm = MM_ANISOTROPIC;
                    pmf->xExt = _sizeHIM.cx;
                    pmf->yExt = _sizeHIM.cy;
                    TraceMsg(TF_SHDCONTROL, "sdv TR ::GetData (%d,%d)-(%d,%d)",
                             _size.cx, _size.cy, _sizeHIM.cx, _sizeHIM.cy);

                    pmedium->tymed = TYMED_MFPICT;
                    pmedium->hMetaFilePict = hmem;
                    pmedium->pUnkForRelease = NULL;
                    hres = S_OK;
                }
            }

            if (FAILED(hres))
            {
                GlobalFree(hmem);
                hmem = NULL;
            }
        }
    }

    if (hdcTargetDevice)
        DeleteDC(hdcTargetDevice);

    return hres;
}

HRESULT CShellEmbedding::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    IDTMSG2(TEXT("GetDataHere"), pformatetc->cfFormat);
    return E_NOTIMPL;
}

HRESULT CShellEmbedding::QueryGetData(FORMATETC *pformatetc)
{
    IDTMSG2(TEXT("QueryGetData"), pformatetc->cfFormat);
    HRESULT hres = S_FALSE;
    if (pformatetc->cfFormat == CF_ENHMETAFILE
        && (pformatetc->tymed & TYMED_ENHMF))
    {
        hres = S_OK;
    }
    else if (pformatetc->cfFormat == CF_METAFILEPICT
        && (pformatetc->tymed & TYMED_MFPICT))
    {
        hres = S_OK;
    }

    return hres;
}

HRESULT CShellEmbedding::GetCanonicalFormatEtc(FORMATETC *pformatetcIn, FORMATETC *pformatetcOut)
{
    IDTMSG2(TEXT("GetCanonicalFormatEtc"), pformatetcIn->cfFormat);
    *pformatetcOut = *pformatetcIn;
    return DATA_S_SAMEFORMATETC;
}

HRESULT CShellEmbedding::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    IDTMSG(TEXT("SetData"));
    return E_NOTIMPL;
}

HRESULT CShellEmbedding::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
    IDTMSG(TEXT("EnumFormatEtc"));
    return E_NOTIMPL;
}

HRESULT CShellEmbedding::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    IDTMSG(TEXT("DAdvise"));
    HRESULT hr = E_INVALIDARG;

    if (!pdwConnection)
        return hr;

    *pdwConnection = NULL;              // set out params to NULL

    if (!_pdah)
        hr = ::CreateDataAdviseHolder(&_pdah);
    else
        hr = NOERROR;

    if( SUCCEEDED(hr) )
        hr = _pdah->Advise(this, pformatetc, advf, pAdvSink, pdwConnection);

    return(hr);
}

HRESULT CShellEmbedding::DUnadvise(DWORD dwConnection)
{
    IDTMSG(TEXT("DUnadvise"));
    HRESULT     hr;

    if (!_pdah)
        return(OLE_E_NOCONNECTION);

    hr = _pdah->Unadvise(dwConnection);

    return(hr);
}

HRESULT CShellEmbedding::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    IDTMSG(TEXT("EnumDAdvise"));
    HRESULT     hr;

    if (!ppenumAdvise)
        return(E_INVALIDARG);

    if (!_pdah)
    {
        *ppenumAdvise = NULL;
        hr = S_OK;
    }
    else
    {
        hr = _pdah->EnumAdvise(ppenumAdvise);
    }

    return(hr);
}

// *** IOleWindow ***
HRESULT CShellEmbedding::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return S_OK;
}

HRESULT CShellEmbedding::ContextSensitiveHelp(BOOL fEnterMode)
{
    return S_OK;
}


// *** IOleInPlaceObject ***
HRESULT CShellEmbedding::InPlaceDeactivate(void)
{
    IIPMSG(TEXT("InPlaceDeactivate"));
    return _DoActivateChange(NULL, OC_DEACTIVE, FALSE);
}

HRESULT CShellEmbedding::UIDeactivate(void)
{
    IIPMSG(TEXT("UIDeactivate"));
    return _DoActivateChange(NULL, OC_INPLACEACTIVE, FALSE);
}

HRESULT CShellEmbedding::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    RECT  rcVisible;

    _rcPos = *lprcPosRect;

    if (lprcClipRect)
    {
        _rcClip = *lprcClipRect;
    }
    else
    {
        _rcClip = _rcPos;
    }

    IntersectRect(&rcVisible, &_rcPos, &_rcClip);    
    if (EqualRect(&rcVisible, &_rcPos))
    {
        if (_fUsingWindowRgn)
        {
            SetWindowRgn(_hwnd, NULL, TRUE);
            _fUsingWindowRgn = FALSE;
        }
    }
    else 
    {
        _fUsingWindowRgn = TRUE;
        OffsetRect(&rcVisible, -_rcPos.left, -_rcPos.top);
        SetWindowRgn(_hwnd,
                CreateRectRgnIndirect(&rcVisible),
                TRUE);
    }

    // We should consider this equivalent to a SetExtent as well...
    // But only for valid sizes (html viewer gives us invalid
    // sizes during it's reformat routine). Note: we still need
    // the SetWindowPos because we may move off the window.
    int cx = _rcPos.right - _rcPos.left;
    int cy = _rcPos.bottom - _rcPos.top;
    TraceMsg(TF_SHDCONTROL, "she SetObjectRects to x=%d y=%d cx=%d cy=%d (from cx=%d cy=%d)", _rcPos.left, _rcPos.top, cx, cy, _size.cx, _size.cy);
    if (cx >= 0 && cy >= 0)
    {
        _size.cx = cx;
        _size.cy = cy;
    }

    if (_hwnd)
    {
        SetWindowPos(_hwnd, NULL,
                     _rcPos.left, _rcPos.top,
                     _size.cx,
                     _size.cy,
                     SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return S_OK;
}

HRESULT CShellEmbedding::ReactivateAndUndo(void)
{
    IIPMSG(TEXT("ReactivateAndUndo"));
    return INPLACE_E_NOTUNDOABLE;
}

// *** IOleInPlaceActiveObject ***
HRESULT CShellEmbedding::TranslateAccelerator(LPMSG lpmsg)
{
    extern BOOL IsVK_TABCycler(MSG * pMsg);
    HRESULT hr = S_FALSE;

    // IIAMSG(TEXT("TranslateAccelerator"));
    // We have no accelerators (other than TAB, which we must pass up
    // to IOCS::TA to move on to the next control if any)

    if (IsVK_TABCycler(lpmsg)) {
        // NOTE: grfMods?
        hr = IUnknown_TranslateAcceleratorOCS(_pcli, lpmsg, /*grfMods*/ 0);
    }

    return hr;
}

HRESULT CShellEmbedding::OnFrameWindowActivate(BOOL fActivate)
{
    IIAMSG(TEXT("OnFrameWindowActivate"));

    if (fActivate)
    {
        // our frame has been activated and we are the active object
        // make sure we have focus
        SetFocus(_hwnd);
    }

    return S_OK;
}

HRESULT CShellEmbedding::OnDocWindowActivate(BOOL fActivate)
{
    IIAMSG(TEXT("OnDocWindowActivate"));
    // We don't care
    return S_OK;
}

HRESULT CShellEmbedding::ResizeBorder(LPCRECT prcBorder,
                    IOleInPlaceUIWindow *pUIWindow, BOOL fFrameWindow)
{
    IIAMSG(TEXT("ResizeBorder"));
    // We have no toolbars.
    return S_OK;
}

HRESULT CShellEmbedding::EnableModeless(BOOL fEnable)
{
    IIAMSG(TEXT("EnableModeless"));
    // We have no dialogs.
    return S_OK;
}

void CShellEmbedding::_RegisterWindowClass(void)
{
    WNDCLASS wc = {0};
    wc.style         = CS_DBLCLKS;
    wc.lpfnWndProc   = s_WndProc ;
    //wc.cbClsExtra    = 0;
    wc.cbWndExtra    = SIZEOF(CShellEmbedding*) * 2;
    wc.hInstance     = g_hinst ;
    //wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    //wc.lpszMenuName  = NULL ;
    wc.lpszClassName = c_szShellEmbedding;

    SHRegisterClass(&wc);
}


LRESULT CShellEmbedding::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_NCCREATE:
        DWORD dwExStyles;
        if ((dwExStyles = GetWindowLong(hwnd, GWL_EXSTYLE)) & RTL_MIRRORED_WINDOW)
        {
             SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyles &~ RTL_MIRRORED_WINDOW);
        }
        goto DoDefault;

    case WM_SETFOCUS:
        if (_hwndChild)
            SetFocus(_hwndChild);
        // If this SETFOCUS came from TABbing onto the control, VB5 expects us to call its
        // IOleControlSite::OnFocus.  Then it will UIActivate us.
        //
        IUnknown_OnFocusOCS(_pcli, TRUE);
        break;

    case WM_KILLFOCUS:
        // If this KILLFOCUS came from TABbing off the control, VB5 expects us to call its
        // IOleControlSite::OnFocus.  Then it will UIDeactivate us.
        //
        IUnknown_OnFocusOCS(_pcli, FALSE);
        break;

    case WM_WINDOWPOSCHANGED:
        if (_hwndChild)
        {
            LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;

            if (!(lpwp->flags & SWP_NOSIZE))
            {
                SetWindowPos(_hwndChild, NULL,
                    0, 0, lpwp->cx, lpwp->cy,
                    SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE|
                    (lpwp->flags&(SWP_NOREDRAW|SWP_NOCOPYBITS)));
            }
        }
        goto DoDefault;

#ifdef DEBUG
    // FEATURE: we'll never get this with ShellExplorer OC, but if we did,
    // we'd need to call _DoActivateChange(OC_UIACTIVE, FALSE);
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        TraceMsg(TF_SHDCONTROL, "she ::v_WndProc(WM_xBUTTONDOWN) - we need to UIActivate");
        goto DoDefault;
#endif

    default:
DoDefault:
        return DefWindowProc(_hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

void CShellEmbedding::_ViewChange(DWORD dwAspect, LONG lindex)
{
    dwAspect &= _asp;

    if (dwAspect && _padv)
    {
        IAdviseSink *padv = _padv;
        IUnknown *punkRelease;

        if (_advf & ADVF_ONLYONCE)
        {
            _padv = NULL;
            punkRelease = padv;
        }
        else
            punkRelease = NULL;

        padv->OnViewChange(dwAspect, lindex);

        if (punkRelease)
            punkRelease->Release();
    }
}

void CShellEmbedding::_SendAdvise(UINT uCode)
{
    DWORD       dwAspect=DVASPECT_CONTENT | DVASPECT_THUMBNAIL;

    switch (uCode)
    {
    case OBJECTCODE_SAVED:
        if (NULL!=_poah)
            _poah->SendOnSave();
        break;

    case OBJECTCODE_CLOSED:
        if (NULL!=_poah)
            _poah->SendOnClose();
        break;

    case OBJECTCODE_RENAMED:
        //Call IOleAdviseHolder::SendOnRename (later)
        break;

    case OBJECTCODE_SAVEOBJECT:
        if (_fDirty && NULL!=_pcli)
            _pcli->SaveObject();

        _fDirty=FALSE;
        break;

    case OBJECTCODE_DATACHANGED:
        // _fDirty=TRUE;

        //No flags are necessary here.
        if (NULL!=_pdah)
            _pdah->SendOnDataChange(this, 0, 0);
        //
        // fall through
        //
    case OBJECTCODE_VIEWCHANGED:
        _ViewChange(dwAspect, -1);
        break;

    case OBJECTCODE_SHOWOBJECT:
        if (NULL!=_pcli)
            _pcli->ShowObject();
        break;
    }
}

HRESULT CSVVerb::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IEnumOLEVERB) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IEnumOLEVERB*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    _cRef++;
    return S_OK;
}

ULONG CSVVerb::AddRef()
{
    return ++_cRef;
}

ULONG CSVVerb::Release()
{
    if (--_cRef > 0) {
        return _cRef;
    }

    delete this;
    return 0;
}

HRESULT CSVVerb::Next(
    /* [in] */ ULONG celt,
    /* [out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG *pceltFetched)
{
    HRESULT hres = S_FALSE;
    ULONG celtFetched = 0;


    // We need to enumerate the predefined verbs we support,
    // or some containers will never call them. This list
    // of verbs comes from our ::DoVerb function
    //
    static const OLEVERB rgVerbs[5] =
    {
        {OLEIVERB_PRIMARY, NULL, 0, 0},
        {OLEIVERB_INPLACEACTIVATE, NULL, 0, 0},
        {OLEIVERB_UIACTIVATE, NULL, 0, 0},
        {OLEIVERB_SHOW, NULL, 0, 0},
        {OLEIVERB_HIDE, NULL, 0, 0}
    };
    if (_iCur < ARRAYSIZE(rgVerbs))
    {
        IEVMSG(TEXT("Next"), celt, _iCur, TEXT("OLEIVERB_..."));

        *rgelt = rgVerbs[_iCur++];
        hres = S_OK;
    }
    else if (_pverbs)
    {
        int iCur = _iCur - ARRAYSIZE(rgVerbs);

        IEVMSG(TEXT("Next"), celt, _iCur, _pverbs[iCur].lpszVerbName);

        //
        // FEATURE: Should we do while(celt--)?
        //
        if (_pverbs[iCur].lpszVerbName)
        {
            *rgelt = _pverbs[_iCur++];
            WCHAR* pwszVerb = (WCHAR *)CoTaskMemAlloc(128 * sizeof(WCHAR));
            if (pwszVerb)
            {
                MLLoadStringW(PtrToUint(_pverbs[iCur].lpszVerbName), pwszVerb, 128);
                rgelt->lpszVerbName = pwszVerb;
                celtFetched++;
                hres = S_OK;
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }

    if (pceltFetched) {
        *pceltFetched = celtFetched;
    }
    return hres;
}

HRESULT CSVVerb::Skip(ULONG celt)
{
    return S_OK;
}

HRESULT CSVVerb::Reset( void)
{
    _iCur = 0;
    return S_OK;
}

HRESULT CSVVerb::Clone(IEnumOLEVERB **ppenum)
{
    *ppenum = new CSVVerb(_pverbs);
    return *ppenum ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shdocvw.cpp ===
#include "priv.h"
#include "hlframe.h"
#include "dochost.h"
#include "bindcb.h"
#include "iface.h"
#include "resource.h"
#include "idhidden.h"
#include "shdocfl.h"

const ITEMIDLIST s_idNull = { {0} };
extern HRESULT VariantClearLazy(VARIANTARG *pvarg);
LPWSTR URLFindExtensionW(LPCWSTR pszURL, int * piLen);

#define DM_CACHETRACE   0
#define DM_ZONECROSSING 0

#define NAVMSG3(psz, x, y)          TraceMsg(0, "NAV::%s %x %x", psz, x, y)
#define PAINTMSG(psz,x)             TraceMsg(0, "TraceMsgPAINT::%s %x", psz, x)
#define JMPMSG(psz, psz2)           TraceMsg(0, "TraceMsgCDOV::%s %s", psz, psz2)
#define JMPMSG2(psz, x)             TraceMsg(0, "TraceMsgCDOV::%s %x", psz, x)
#define DOFMSG(psz)                 TraceMsg(0, "TraceMsgDOF::%s", psz)
#define DOFMSG2(psz, x)             TraceMsg(0, "TraceMsgDOF::%s %x", psz, x)
#define URLMSG(psz)                 TraceMsg(0, "TraceMsgDOF::%s", psz)
#define URLMSG2(psz, x)             TraceMsg(0, "TraceMsgDOF::%s %x", psz, x)
#define URLMSG3(psz, x, y)          TraceMsg(0, "TraceMsgDOF::%s %x %x", psz, x, y)
#define BSCMSG(psz, i, j)           TraceMsg(0, "TraceMsgBSC::%s %x %x", psz, i, j)
#define BSCMSG3(psz, i, j, k)       TraceMsg(0, "TraceMsgBSC::%s %x %x %x", psz, i, j, k)
#define BSCMSG4(psz, i, j, k, l)    TraceMsg(0, "TraceMsgBSC::%s %x %x %x %x", psz, i, j, k, l)
#define BSCMSGS(psz, sz)            TraceMsg(0, "TraceMsgBSC::%s %s", psz, sz)
#define OIPSMSG(psz)                TraceMsg(0, "TraceMsgOIPS::%s", psz)
#define OIPSMSG3(psz, sz, p)        TraceMsg(0, "TraceMsgOIPS::%s %s,%x", psz, sz,p)
#define VIEWMSG(psz)                TraceMsg(0, "CDOV::%s", psz)
#define VIEWMSG2(psz,xx)            TraceMsg(0, "CDOV::%s %x", psz,xx)
#define CACHEMSG(psz, d)            TraceMsg(0, "CDocObjectCtx::%s %d", psz, d)
#define OPENMSG(psz)                TraceMsg(0, "OPENING %s", psz)
#define OPENMSG2(psz, x)            TraceMsg(0, "OPENING %s %x", psz, x)
#define HFRMMSG(psz)                TraceMsg(0, "HFRM::%s", psz)
#define HFRMMSG2(psz, x, y)         TraceMsg(0, "HFRM::%s %x %x", psz, x, y)
#define MNKMSG(psz, psz2)           TraceMsg(0, "MNK::%s (%s)", psz, psz2)
#define CHAINMSG(psz, x)            TraceMsg(0, "CHAIN::%s %x", psz, x)
#define SHVMSG(psz, x, y)           TraceMsg(0, "SHV::%s %x %x", psz, x, y)
#define HOMEMSG(psz, psz2, x)       TraceMsg(0, "HOME::%s %s %x", psz, psz2, x)
#define SAVEMSG(psz, x)             TraceMsg(0, "SAVE::%s %x", psz, x)
#define PERFMSG(psz, x)             TraceMsg(TF_SHDPERF, "PERF::%s %d msec", psz, x)

// this saves the view information for this shell view class
typedef struct {
    UINT cbSize;

    BOOL fCoolbar:1;
    BOOL fToolbar:1;
    BOOL fStatusbar:1;

} IEVIEWINFO;



class CDocObjectView :
    /* Group 1 */    public IShellView2, public IDropTarget
                   , public IViewObject, public IAdviseSink
                   , public IOleCommandTarget
                   , public IDocViewSite
                   , public IPrivateOleObject
                   , public IPersistFolder
                   , public IServiceProvider
{
protected:
    CDocObjectHost* _pdoh;
    IDocHostObject* _pdho;

    UINT _cRef;
    IShellFolder *_psf;
    IShellBrowser* _psb;
    IOleCommandTarget* _pctShellBrowser;
    FOLDERSETTINGS _fs;
    LPITEMIDLIST _pidl;
    LPTSTR _pszLocation;
    UINT _uiCP;

    IShellView * _psvPrev;

    // Advisory connection
    IAdviseSink *_padvise;
    DWORD _advise_aspect;
    DWORD _advise_advf;

    BOOL _fInHistory : 1;
    BOOL _fSaveViewState : 1;
    BOOL _fIsGet : 1;
    BOOL _fCanCache : 1;
    BOOL _fCanCacheFetched : 1;
    BOOL _fPrevViewIsDocView : 1;
    BOOL _fSelfDragging : 1;       // DocObject is the drag source

    SYSTEMTIME _stLastRefresh;
    HWND    _hwndParent;

    UINT _uState;
    // DragContext
    DWORD _dwDragEffect;

    ~CDocObjectView();

    void    _RestoreViewSettings();
    void    _SaveViewState();
    void    _GetViewSettings(IEVIEWINFO* pievi);
    int     _ShowControl(UINT idControl, int idCmd);
    void _CreateDocObjHost(IShellView * psvPrev);
    void _CompleteDocHostPassing(IShellView *psvPrev, HRESULT hres);
    BOOL _CanUseCache();
    void _SetLastRefreshTime() { GetSystemTime(&_stLastRefresh); };


    void _ConnectHostSink();
    void _DisconnectHostSink();

public:
    CDocObjectView(LPCITEMIDLIST pidl, IShellFolder *psf);

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IShellView methods ***
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg);
    STDMETHODIMP EnableModelessSV(BOOL fEnable);
    STDMETHODIMP UIActivate(UINT uState);
    STDMETHODIMP Refresh();

    STDMETHODIMP CreateViewWindow(IShellView  *lpPrevView,
                    LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,
                    RECT * prcView, HWND  *phWnd);
    STDMETHODIMP DestroyViewWindow();
    STDMETHODIMP GetCurrentInfo(LPFOLDERSETTINGS lpfs);
    STDMETHODIMP AddPropertySheetPages(DWORD dwReserved,
                    LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam);
    STDMETHODIMP SaveViewState();
    STDMETHODIMP SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags);
    STDMETHODIMP GetItemObject(UINT uItem, REFIID riid, void **ppv);

    STDMETHODIMP GetView(SHELLVIEWID* pvid, ULONG uView) ;
    STDMETHODIMP CreateViewWindow2(LPSV2CVW2_PARAMS lpParams) ;
    STDMETHODIMP HandleRename(LPCITEMIDLIST pidl) ;
    STDMETHODIMP SelectAndPositionItem(LPCITEMIDLIST pidlItem, UINT uFlags, POINT *ppt) {
        return E_NOTIMPL;
    }


    // IViewObject
    STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR);
    STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *,
        HDC, LOGPALETTE **);
    STDMETHODIMP Freeze(DWORD, LONG, void *, DWORD *);
    STDMETHODIMP Unfreeze(DWORD);
    STDMETHODIMP SetAdvise(DWORD, DWORD, IAdviseSink *);
    STDMETHODIMP GetAdvise(DWORD *, DWORD *, IAdviseSink **);

    // IAdviseSink
    STDMETHODIMP_(void) OnDataChange(FORMATETC *, STGMEDIUM *);
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename(IMoniker *);
    STDMETHODIMP_(void) OnSave();
    STDMETHODIMP_(void) OnClose();

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);


    // IDropTarget
    STDMETHODIMP DragEnter(
    IDataObject *pdtobj,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect);

    STDMETHODIMP DragOver(
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect);

    STDMETHODIMP DragLeave(void);

    STDMETHODIMP Drop(
    IDataObject *pdtobj,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect);

    // IDocViewSite
    STDMETHODIMP OnSetTitle(VARIANTARG *pvTitle);

    // IPrivateOleObject
    STDMETHODIMP SetExtent( DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHODIMP GetExtent( DWORD dwDrawAspect, SIZEL *psizel);

    // IPersist methods
    STDMETHODIMP GetClassID(CLSID *pclsid);

    // IPersistFolder methods
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IServiceProvider methods
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);
};

//--------------------------------------------------------------------------
// Detecting a memory leak
//--------------------------------------------------------------------------

CDocObjectView::~CDocObjectView()
{
    // just in case
    DestroyViewWindow();

    if (_pidl)
    {
        ILFree(_pidl);
        _pidl = NULL;
    }

    ATOMICRELEASE(_psf);

    if (_pszLocation)
    {
        LocalFree(_pszLocation);
        _pszLocation = NULL;
    }

    ATOMICRELEASE(_padvise);

    ATOMICRELEASE(_psvPrev);

    TraceMsg(TF_SHDLIFE, "dtor CDocObjectView(%x) being destructed", this);
}

CDocObjectView::CDocObjectView(LPCITEMIDLIST pidl, IShellFolder* psf) :
    _psf(psf),
    _cRef(1)
{
    TraceMsg(TF_SHDLIFE, "ctor CDocObjectView(%x) being constructed", this);

    _dwDragEffect = DROPEFFECT_NONE;
    if (pidl)
    {
        _pidl = ILClone(pidl);

        if (_pidl)
        {
#ifndef UNIX
            WCHAR wszPath[MAX_URL_STRING];
#else
            WCHAR wszPath[MAX_URL_STRING] = TEXT("");
#endif
            if(IEILGetFragment(_pidl, wszPath, SIZECHARS(wszPath)))
            {
                _pszLocation = StrDup(wszPath);
            }

            _uiCP = IEILGetCP(_pidl);
        }
    }

    ASSERT(psf);
    if (_psf) {
        _psf->AddRef();
    }
}

HRESULT CDocObjectView_Create(IShellView** ppvOut, IShellFolder * psf, LPCITEMIDLIST pidl)
{
    *ppvOut = new CDocObjectView(pidl, psf);
    return (*ppvOut) ? S_OK : E_OUTOFMEMORY;
}

HRESULT CDocObjectView::GetWindow(HWND * lphwnd)
{
    *lphwnd = NULL;
    if (_pdoh)
        return _pdoh->GetWindow(lphwnd);
    return S_OK;
}

HRESULT CDocObjectView::ContextSensitiveHelp(BOOL fEnterMode)
{
    // NOTES: This is optional
    return E_NOTIMPL;   // As specified in Kraig's document (optional)
}



// IShellView::TranslateAccelerator
//  From Browser -> DocView -> DocObject
HRESULT CDocObjectView::TranslateAccelerator(LPMSG lpmsg)
{
    HRESULT hres = S_FALSE;
    if (_pdoh)
        hres = _pdoh->_xao.TranslateAccelerator(lpmsg);

    if (hres == S_FALSE && lpmsg->message == WM_KEYDOWN) {
        HWND hwndFocus = GetFocus();
        HWND hwndView = NULL;

        if(_pdoh) //WARNING ZEKEL i found this NULL
            _pdoh->GetWindow(&hwndView);

        if (hwndView && IsChildOrSelf(hwndView, hwndFocus) == S_OK) {

            switch (lpmsg->wParam) {

            case VK_BACK:
                TranslateMessage(lpmsg);
                DispatchMessage(lpmsg);
                hres = NOERROR;
                break;

            }
        }
    }

    return hres;
}

// IShellView::EnableModelessSV
//  From Browser -> DocView -> DocObject
HRESULT CDocObjectView::EnableModelessSV(BOOL fEnable)
{
    HRESULT hres = S_OK;
    // We have no modeless window to be enabled/disabled
    TraceMsg(0, "sdv TR - ::EnableModelessSV(%d) called", fEnable);
    if (_pdoh) {
        hres = _pdoh->_xao.EnableModeless(fEnable);
        TraceMsg(0, "sdv TR - _piact->EnableModeless returned %x", hres);
    }
    return hres;
}


HRESULT CDocObjectView::UIActivate(UINT uState)
{
    HRESULT hres = E_FAIL;

    if (_pdoh)
    {
        hres = _pdoh->UIActivate(uState, _fPrevViewIsDocView);
    }

    _uState = uState;
    return hres;
}

HRESULT CDocObjectView::Refresh()
{
    if (_pdoh)
    {
        VARIANT v = {0};
        v.vt = VT_I4;
        v.lVal = OLECMDIDF_REFRESH_NO_CACHE;
        // send this to exec so that it will update last refresh time.
        // all refresh to dochost should go through our own exec
        return Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_PROMPTUSER, &v, NULL);
    }

    return S_OK;
}


// Return:
//   S_OK: It is a folder shortcut and ppidlTarget is filled out if provided.
//   S_FALSE: It is not a folder shortcut and ppidlTarget is filled with NULL if provided.
//   FAILED: An error occured trying to detect.
//
// Don't use this function if there is a better way.  Look into using
// IBrowserFrameOptions. -BryanSt
HRESULT IsFolderShortcutPidl(IN LPCITEMIDLIST pidl)
{
    IShellFolder * psf = NULL;
    HRESULT hr = IEBindToObject(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        IShellLinkA * psl;

        hr = psf->QueryInterface(IID_PPV_ARG(IShellLinkA, &psl));
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
            psl->Release();
        }
        else
            hr = S_FALSE;   // It's not a folder shortcut.

        psf->Release();
    }

    return hr;
}


// WARNING: This function explicitely creates URLMON monikers
//   because that's what the caller needs.  Some NSEs will
//   support IShellFolder::BindToObject(IMoniker)
//   but this function doesn't use that logic intentionally.
//
STDAPI _URLMONMonikerFromPidl(LPCITEMIDLIST pidl, IMoniker** ppmk, BOOL* pfFileProtocol)
{
    TCHAR szPath[MAX_URL_STRING];
    HRESULT hres = E_UNEXPECTED;

    *ppmk = NULL;
    *pfFileProtocol = FALSE;
    MNKMSG(TEXT("_URLMONMonikerFromPidl"), TEXT("called"));

    AssertMsg((S_OK != IsFolderShortcutPidl(pidl)), TEXT("We shouldn't get Folder Shortcuts here because we don't deref them to get the target. And we should never need to."));

    // Is this a child of the "Internet Explorer" name space?
    if (!IsURLChild(pidl, TRUE))
    {
        // No, so we want to get the display name to use to
        // create the moniker.  We will try to turn it into
        // an URL if it isn't already an URL.

        // NOTE: We don't try IEBindToObject(pidl, IID_IMoniker)
        //       because the caller requires that this
        //       IMoniker come from URLMON.
        HRESULT hrTemp = SHGetPathFromIDList(pidl, szPath);

        AssertMsg(SUCCEEDED(hrTemp), TEXT("_URLMONMonikerFromPidl() failed SHGetPathFromIDList() which is really bad because we probably won't be able to create a moniker from it.  We will try to create a URLMON moniker below."));
        if (SUCCEEDED(hrTemp))
        {
            //  this should never be a fully qualified URL
            DWORD cchPath = ARRAYSIZE(szPath);

            ASSERT(URL_SCHEME_INVALID == GetUrlScheme(szPath));
            if(SUCCEEDED(hres = UrlCreateFromPath(szPath, szPath, &cchPath, 0)))
            {
                MNKMSG(TEXT("_URLMONMonikerFromPidl Creating File Moniker"), szPath);
            }

            *pfFileProtocol = TRUE;
        }

    }
    else
    {
        // Yes so we are guaranteed this is from the "Internet Explorer"
        // name space so remove Fragment hidden itemID.
        // We do this because we navigate to the fragment later,
        // after the page is downloaded.  This is also needed
        // for delegates of the IE name space. (FTP is one example of
        // a delegate).
        ASSERT(pidl);
        ASSERT(!ILIsEmpty(_ILNext(pidl)));  // Make sure it's not the start page URL.

        LPITEMIDLIST pidlClone = ILClone(pidl);
        if (pidlClone)
        {
            //  we dont want to pass the fragment into URLMON
            //  so we pull it off before calling into GDN.
            //  Note that pidlClone needs to be the pidlTarget
            //  of folder shortcuts or the dislpay name will
            //  be the file system path of the folder shortcut
            //  if at the top level.
            ILRemoveHiddenID(pidlClone, IDLHID_URLFRAGMENT);
            IEGetDisplayName(pidlClone, szPath, SHGDN_FORPARSING);
            hres = S_OK;
            ILFree(pidlClone);
        }
    }

    if (SUCCEEDED(hres))
    {
        if (szPath[0])
        {
            hres = MonikerFromString(szPath, ppmk);
        }
        else
        {
            ASSERT(FALSE);
            hres = E_UNEXPECTED;
        }
    }

    return hres;
}

HRESULT CDocObjectView::HandleRename(LPCITEMIDLIST pidl)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectView::CreateViewWindow(IShellView  *psvPrev,
                LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,
                RECT * prcView, HWND  *phWnd)
{
    SV2CVW2_PARAMS cParams;

    cParams.cbSize   = SIZEOF(SV2CVW2_PARAMS);
    cParams.psvPrev  = psvPrev;
    cParams.pfs      = lpfs;
    cParams.psbOwner = psb;
    cParams.prcView  = prcView;
    cParams.pvid     = NULL;

    HRESULT hres = CreateViewWindow2(&cParams);

    *phWnd = cParams.hwndView;
    IOleWindow *pOleWindow;

    // need top level frame available for D&D
    HRESULT hr = IUnknown_QueryService(_psb, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow));
    if(SUCCEEDED(hr))
    {
        ASSERT(pOleWindow);
        pOleWindow->GetWindow(&_hwndParent);
        pOleWindow->Release();
    }
    return(hres);
}

void CDocObjectView::_CompleteDocHostPassing(IShellView * psvPrev, HRESULT hresBinding)
{
    BOOL fPassedSV = FALSE;

    // If there was a previous shell view, see if it was our class.
    //
    if (psvPrev)
    {
        CDocObjectView * pdovPrev;

        HRESULT hres = psvPrev->QueryInterface(CLSID_CDocObjectView, (void **)&pdovPrev);
        if (SUCCEEDED(hres))
        {
            // Previous shell view is also an instance of CDocObjectView,
            // Remember that for optimization later. 
            //
            _fPrevViewIsDocView = TRUE;

            // it was, and we have the same doc host as they do.
            // we've succeeded in taking over, so null them out if we
            // succeeeded in our bind.  null ourselves out if we failed
            //
            if (pdovPrev->_pdoh == _pdoh) 
            {
                if (SUCCEEDED(hresBinding))
                {
                    pdovPrev->_DisconnectHostSink();    // just in case
                    _ConnectHostSink();                 // just in case

                    ATOMICRELEASET(pdovPrev->_pdoh, CDocObjectHost);
                }
                else
                {
                    _DisconnectHostSink();              // unhook
                    pdovPrev->_ConnectHostSink();       // kick other guy

                    ATOMICRELEASET(_pdoh, CDocObjectHost);
                }

                fPassedSV = TRUE;
            }

            pdovPrev->Release();
        }
    }

    if (!fPassedSV)
    {
        if (FAILED(hresBinding))
        {
            DestroyViewWindow();
        }
    }
}

BOOL CDocObjectView::_CanUseCache()
{
    // NOTE:  this function is more like _DontHaveToHitTheNet()
    //  the name is legacy from the objectcache.
    if (!_fCanCacheFetched)
    {
        _fCanCache = TRUE;
        _fCanCacheFetched = TRUE;
        _fIsGet = TRUE;

        IServiceProvider *psp;
        _psb->QueryInterface(IID_PPV_ARG(IServiceProvider, &psp));
        if (psp)
        {
            IBindStatusCallback *pbsc;
            if (SUCCEEDED(GetTopLevelBindStatusCallback(psp, &pbsc)))
            {
                BINDINFO binfo;
                ZeroMemory(&binfo, sizeof(BINDINFO));
                binfo.cbSize = sizeof(BINDINFO);

                DWORD grfBINDF = BINDF_ASYNCHRONOUS;

                HRESULT hr = pbsc->GetBindInfo(&grfBINDF, &binfo);
                if (SUCCEEDED(hr))
                {
                    if (grfBINDF & (BINDF_GETNEWESTVERSION | BINDF_RESYNCHRONIZE))
                    {
                        _fCanCache = FALSE;
                    }

                    _fIsGet = (binfo.dwBindVerb == BINDVERB_GET);
                    ReleaseBindInfo(&binfo);
                }

                pbsc->Release();
            }
            // I believe that failing to get the Bindstatuscallback should
            //  not happen since we no longer use the object cache.
            //  and if it does, then we no that we didnt have to repost
            //  or something similar
            psp->Release();
        }
    }

    return _fCanCache;
}


void CDocObjectView::_ConnectHostSink()
{
    if (_pdoh)
    {
        IAdviseSink *pSink;

        if (FAILED(_pdoh->GetAdvise(NULL, NULL, &pSink)))
            pSink = NULL;

        if (pSink != (IAdviseSink *)this)
            _pdoh->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, this);

        if (pSink)
            pSink->Release();
    }
}

void CDocObjectView::_DisconnectHostSink()
{
    IAdviseSink *pSink;

    // paranoia: only blow away the advise sink if it is still us
    if (_pdoh && SUCCEEDED(_pdoh->GetAdvise(NULL, NULL, &pSink)) && pSink)
    {
        if (pSink == (IAdviseSink *)this)
            _pdoh->SetAdvise(0, 0, NULL);

        pSink->Release();
    }

    OnViewChange(DVASPECT_CONTENT, -1);
}

#if 0
BOOL _SameLocations(LPSTR pszLoc1, LPSTR pszLoc2)
{
    // if they're both the same pointer (null)
    // or if they both exist and have the same string, then
    // they are the same location
    if (pszLoc1 == pszLoc2 ||
        (pszLoc1 && pszLoc2 &&
         !lstrcmp(pszLoc1, pszLoc2))) {
        return TRUE;
    }

    return FALSE;
}
#endif

//
//  This function either (1) Create a new CDocObjectHost or (2) reuse it from
// the previous view. If also returns the DisplayName of previous moniker.
//
void CDocObjectView::_CreateDocObjHost(IShellView * psvPrev)
{
    BOOL fWindowOpen = FALSE;

    // if there was a previous shell view, see if it was our class.
    if (psvPrev)
    {
        CDocObjectView * pdovPrev = NULL;

        HRESULT hres = psvPrev->QueryInterface(CLSID_CDocObjectView, (void **)&pdovPrev);

        if (SUCCEEDED(hres))
        {
            CDocObjectHost * pPrevDOH = pdovPrev->_pdoh;

            ASSERT(_psb);
            ASSERT(_psb == pdovPrev->_psb);

            // find out if we should be saving the view state when we close
            // if the one we're coming from says yes, then we'll take over that
            // job instead of them.
            //
            _fSaveViewState = pdovPrev->_fSaveViewState;
            pdovPrev->_fSaveViewState = FALSE;

            //
            //  if this is a local anchor navigation,
            //  we treat it substantially differently.
            //  we can reuse the DOH and the OLE Object that
            //  it holds.       - zekel - 31-JUL-97
            //
            //  WARNING:  we should not reuse these objects for any other
            //  reason than a local anchor (fragment) navigation.
            //  we used to be a lot more lenient about reusing the DOH
            //  but i think this was mostly because of the old object cache.
            //
            //  we check for equal pidls so that we know we are on
            //  the same URL.  we require that _pszLocation be set.
            //  this is for Netscape compat.  this means that anytime
            //  we get a navigate to ourself it will refresh completely
            //  if there was no fragment.  we also check to make sure that
            //  the binding does not require us to hit the net for
            //  this request.
            //
            //  08-11-1999 (scotrobe): We now reuse the DOH if the
            //  hosted document has indicated that it knows how to
            //  navigate on its own.
            //

            if (_pidl && pdovPrev->_pidl && pPrevDOH &&
                (pPrevDOH->_fDocCanNavigate
                 || (   _pszLocation && IEILIsEqual(_pidl, pdovPrev->_pidl, TRUE)
                     && _CanUseCache())))
            {
                IBrowserService *pbs;

                if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
                {
                    DWORD dwFlags = 0;

                    // If the document doesn't know how to navigate, then this may
                    // mean that this navigation  was delegated from the document. 
                    // In that case, if we have gotten this far, that means that 
                    // _pszLocation is set. If it is and this is a delegated navigation
                    // (i.e., the navigation wasn't due to a link in a non-html document)
                    // we must create a new document.
                    //
                    if (!pPrevDOH->_fDocCanNavigate)
                    {
                        pbs->GetFlags(&dwFlags);
                    }

                    if (!(dwFlags & BSF_DELEGATEDNAVIGATION))
                    {
                        //
                        //  if SetHistoryObject() fails, then that means there is already
                        //  an object there for us to use.  this means that we should
                        //  not treat this as a local anchor navigation.  and
                        //  we shouldnt reuse the DOH even though the pidl is identical
                        //
                        //  TRUE is passed to SetHistoryObject even if this is not a
                        //  local anchor. In the case that this is not a local anchor,
                        //  the document (Trident) handles the navigation. Therefore,
                        //  the document will take care of updating the travel log and
                        //  the fIsLocalAnchor flag is ignored.
                        //
                        if (SUCCEEDED(pbs->SetHistoryObject(pPrevDOH->_pole,
                                                !pPrevDOH->_fDocCanNavigate ? TRUE : FALSE)))
                        {
                            TraceMsg(TF_TRAVELLOG, "CDOV::CreateDocObjHost reusing current DOH on local anchor navigate");
                            //
                            //  we cant update in ActivateNow because at that point
                            //  we have already switched the dochost over to the new
                            //  (reused) view.  so we need to update the entry now
                            //
                            //  The fact that the hosted document can navigate on its own,
                            //  implies that it will take care of updating the travel log.
                            //
                            if (!pPrevDOH->_fDocCanNavigate)
                            {
                                ITravelLog * ptl;

                                pbs->GetTravelLog(&ptl);
                                if (ptl)
                                {
                                    ptl->UpdateEntry(pbs, TRUE);
                                    ptl->Release();
                                }
                            }

                            pdovPrev->_DisconnectHostSink();    // we will connect below

                            // same target!  pass the docobj host
                            _pdoh = pPrevDOH;
                            _pdoh->AddRef();

                            if (_pdoh->_fDocCanNavigate)
                            {
                                _pdoh->OnInitialUpdate();
                            }

                            if ((_pdoh->_dwAppHack & BROWSERFLAG_SUPPORTTOP) && !_pszLocation)
                            {
                                // if there's no location for us to go to, and
                                // we're traversing in the same document,
                                // assume top.
                                //
                                _pszLocation = StrDup(TEXT("#top"));
                                _uiCP = CP_ACP;
                            }
                        }

                        pbs->Release();
                    }
                }
            }

            // In the case where we are opening a non-html mime type 
            // in a new window, we need to pass the _fWindowOpen
            // flag from the previous docobject host to the new
            // docobject host. This is needed so that if we are opening
            // a file outside of IE in a new window, we'll know to close
            // the newly created IE afterwards.
            // The problem is that there isn't really a good place to 
            // clear this flag since it has to remain set from one 
            // instance of the docobject host to the next. This causes
            // us to get into the situation where we'll close the browser
            // window if we click on a link to a file that opens outside
            // of IE after opening a new window for an html file.
            // The bottom line is that we only need to pass this flag to
            // the new docobject host if we opening an non-html mime type
            // in a new window.
            //
            if (!_pdoh && pPrevDOH && pPrevDOH->_fDelegatedNavigation)
            {
                fWindowOpen = pPrevDOH->_fWindowOpen;
            }

            //
            // FEATURE: We should take care of _pibscNC as well
            // to 'chain' the IBindStatusCallback.
            //
            pdovPrev->Release();
        }
    }


    // if we didn't pass the docobj host, create a new one and
    // pass the doc context
    if (!_pdoh)
    {
        ASSERT(_psb);

        _pdoh = new CDocObjectHost(fWindowOpen);

        // Reset host navigation flag in the browser
        //
        IUnknown_Exec(_psb,
                      &CGID_DocHostCmdPriv,
                      DOCHOST_DOCCANNAVIGATE,
                      0, NULL, NULL);
    }

    if (_pdoh)
    {
        _ConnectHostSink();
    }
}

extern HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);

HRESULT CDocObjectView::CreateViewWindow2(LPSV2CVW2_PARAMS lpParams)
{
    HRESULT hres            = S_OK;
    IShellView * psvPrev    = lpParams->psvPrev;
    LPCFOLDERSETTINGS lpfs  = lpParams->pfs;
    IShellBrowser * psb     = lpParams->psbOwner;
    RECT * prcView          = lpParams->prcView;
    HWND UNALIGNED * phWnd  = &lpParams->hwndView;

    if (_pdoh || !_pidl)
    {
        *phWnd = NULL;
        ASSERT(0);
        return E_UNEXPECTED;
    }

    _fs = *lpfs;

    ASSERT(_psb==NULL);

    _psb = psb;
    psb->AddRef();

    ASSERT(_pctShellBrowser==NULL);

    _psb->QueryInterface(IID_IOleCommandTarget, (void **)&_pctShellBrowser);

    //if somebody that is not a ShellBrowser  (like the FileOpenBrowser)
    // tries to use us, we want to block them.  we will fault later on
    // if we dont have the right stuff.
    if (!_pctShellBrowser)
        return E_UNEXPECTED;

    // prime the cache bit.  this needs to be done while we're *the* guy navigating.
    // otherwise, if we ask later when there's a different pending navigation,
    // we'll get his info
    _CanUseCache();
    _SetLastRefreshTime();

    //  Either create a new CDocObjectHost or reuse it from the previous view
    // and set it in _pdoh.
    _CreateDocObjHost(psvPrev);

    if (!_pdoh || !_pdoh->InitHostWindow(this, psb, prcView))
    {
        ATOMICRELEASE(_psb);
        _pctShellBrowser->Release();
        _pctShellBrowser = NULL;
        return E_OUTOFMEMORY;
    }

    _pdoh->GetWindow(phWnd);

    ASSERT(NULL == _pdho);

    _pdoh->QueryInterface(IID_IDocHostObject, (void **)&_pdho);

    IMoniker* pmk = NULL;
    BOOL fFileProtocol;
    hres = ::_URLMONMonikerFromPidl(_pidl, &pmk, &fFileProtocol);

    if (SUCCEEDED(hres) && EVAL(pmk))
    {
        hres = _pdoh->SetTarget(pmk, _uiCP, _pszLocation, _pidl, psvPrev, fFileProtocol);
        _psvPrev = psvPrev;

        if (_psvPrev)
            _psvPrev->AddRef();

#ifdef NON_NATIVE_FRAMES
        _CompleteDocHostPassing(psvPrev, hres);
#endif

        pmk->Release();
    }

    return hres;
}

void CDocObjectView::_GetViewSettings(IEVIEWINFO* pievi)
{
    DWORD dwType, dwSize;

    // REVIEW:  Currently, we have on setting for all docobj class views
    //  (everything hosted by shdocvw).  we may want to subclassify them by clsid
    // of the docobj or maybe special case mshtml...

    dwSize = sizeof(IEVIEWINFO);
    if (SHGetValueGoodBoot(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("ViewSettings"), &dwType, (PBYTE)pievi, &dwSize) == ERROR_SUCCESS)
    {
        if (pievi->cbSize != sizeof(IEVIEWINFO))
        {
            goto DefaultInfo;
        }

    }
    else
    {
DefaultInfo:

        // can't count on 0 init because registry could have read stuff, but
        // of the wrong size (corruption)

        pievi->fToolbar = FALSE;
        pievi->fCoolbar = TRUE;
        pievi->fStatusbar = TRUE;
    }
}

void CDocObjectView::_SaveViewState()
{
    IEVIEWINFO ievi;
    int id;

    // First ask up if it is ok for us to save view state.  If we get the return value of
    //  S_FALSE bail as we were told no.
    if (_pctShellBrowser &&
            (_pctShellBrowser->Exec(&CGID_Explorer, SBCMDID_MAYSAVEVIEWSTATE, 0, NULL, NULL) == S_FALSE))
        return;

    // first load to preserve things we're not going to set
    _GetViewSettings(&ievi);

    ievi.cbSize = sizeof(ievi);

    id = _ShowControl(FCW_STATUS, SBSC_QUERY);
    // bail if it's not supported
    if (id == -1)
        return;
    ievi.fStatusbar = (id == SBSC_SHOW);

    id = _ShowControl(FCW_TOOLBAR, SBSC_QUERY);
    if (id != -1) {
        // this is allowed to fail if toolbar isn't supported (ie30 case)
        ievi.fToolbar = (id == SBSC_SHOW);
    }

    id = _ShowControl(FCW_INTERNETBAR, SBSC_QUERY);
    if (id != -1) {
        // this is allowed to fail if coolbar isn't supported
        ievi.fCoolbar = (id == SBSC_SHOW);
    }

    SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                    TEXT("ViewSettings"), REG_BINARY, (const BYTE *)&ievi, sizeof(ievi));
}

int CDocObjectView::_ShowControl(UINT idControl, int idCmd)
{
    VARIANTARG var;

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = MAKELONG(idControl, idCmd);

    if (_pctShellBrowser  &&
        SUCCEEDED(_pctShellBrowser->Exec(&CGID_Explorer, SBCMDID_SHOWCONTROL, OLECMDEXECOPT_DODEFAULT,
                                    &var, &var)))
        return var.lVal;


    return -1;
}




HRESULT CDocObjectView::DestroyViewWindow()
{
    ATOMICRELEASE(_pdho);

    if (_pdoh)
    {
        BOOL fDestroyHost = TRUE;

        if (_psb && _pdoh->_pwb)
        {
            DWORD dwFlags;

            _pdoh->_pwb->GetFlags(&dwFlags);

            if (dwFlags & BSF_HTMLNAVCANCELED)
            {
                IShellView * psvCur;

                HRESULT hr = _psb->QueryActiveShellView(&psvCur);
                if (S_OK == hr)
                {
                    CDocObjectView * pdovCur;

                    hr = psvCur->QueryInterface(CLSID_CDocObjectView, (void**)&pdovCur);
                    if (S_OK == hr)
                    {
                        ASSERT(this != pdovCur);

                        if (_pdoh == pdovCur->_pdoh)
                        {
                            fDestroyHost = FALSE;
                        }

                        pdovCur->Release();
                    }

                    psvCur->Release();
                }
            }
        }

        if (fDestroyHost)
        {
            TraceMsg(DM_WARNING, "CDocObjectView::DestroyViewWindow(): Destroying Host Window");

            _DisconnectHostSink();

            if (_fSaveViewState)
                _SaveViewState();

            _pdoh->DestroyHostWindow();
        }

        ATOMICRELEASET(_pdoh, CDocObjectHost);
    }

    ATOMICRELEASE(_pctShellBrowser);

    // Note that we should release _psb at the very end.
    ATOMICRELEASE(_psb);

    return S_OK;
}

HRESULT CDocObjectView::GetCurrentInfo(LPFOLDERSETTINGS lpfs)
{
    *lpfs = _fs;
    return S_OK;
}

HRESULT CDocObjectView::AddPropertySheetPages(DWORD dwReserved,
        LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    if (_pdoh)
        return _pdoh->AddPages(lpfn, lParam);

    return E_FAIL;
}

HRESULT CDocObjectView::SaveViewState()
{
    // No viewsate to be saved
    return S_OK;
}

HRESULT CDocObjectView::SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags)
{
    // No item
    return E_FAIL;
}

//
// IShellView::GetItemObject
//
//   For this IShellView object, the only valid uItem is SVGIO_BACKGROUND,
//  which allows the browser to access an interface pointer to the
//  currently active document object.
//
// Notes:
//   The browser should be aware that IShellView::CreateViewWindow might be
//  asynchronous. This method will fail with E_FAIL if the document is not
//  instanciated yet.
//
HRESULT CDocObjectView::GetItemObject(UINT uItem, REFIID riid, void **ppv)
{
    HRESULT hres = E_INVALIDARG;
    *ppv = NULL;    // assumes error
    switch(uItem)
    {
    case SVGIO_BACKGROUND:
        if (_pdoh)
        {
            if (_pdoh->_pole)
            {
                hres = _pdoh->_pole->QueryInterface(riid, ppv);
                break;
            }
            else if (_pdoh->_punkPending)
            {
                hres = _pdoh->_punkPending->QueryInterface(riid, ppv);
                break;
            }
        }

    // fall through on the else's
    default:
        hres = E_FAIL;
        break;
    }
    return hres;
}

HRESULT CDocObjectView::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _fSelfDragging = FALSE;

    //
    // Check if this is a self-dragging or not.
    //
    if (_pdoh && _pdoh->_pmsot) {
        VARIANT var = { 0 };
        HRESULT hresT = _pdoh->_pmsot->Exec(
                    &CGID_ShellDocView, SHDVID_ISDRAGSOURCE, 0, NULL, &var);
        if (SUCCEEDED(hresT) && var.vt==VT_I4 && var.lVal) {
            _fSelfDragging = TRUE;
        }
        VariantClearLazy(&var);
    }

    ASSERT(pdtobj);
    _DragEnter(_hwndParent, ptl, pdtobj);
    _dwDragEffect = CommonDragEnter(pdtobj, grfKeyState, ptl);

    return DragOver(grfKeyState, ptl, pdwEffect);
}

HRESULT CDocObjectView::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect &= _dwDragEffect;
    _DragMove(_hwndParent, ptl);
    if (_fSelfDragging && _pdoh && _pdoh->_hwnd) {
        RECT rc;
        GetClientRect(_pdoh->_hwnd, &rc);
        POINT ptMap =  { ptl.x, ptl.y };
        MapWindowPoints(HWND_DESKTOP, _pdoh->_hwnd, &ptMap, 1);
        if (PtInRect(&rc, ptMap)) {
            *pdwEffect = DROPEFFECT_NONE;
        }
    }

    return S_OK;
}

HRESULT CDocObjectView::DragLeave(void)
{
    DAD_DragLeave();
    return S_OK;
}

HRESULT CDocObjectView::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    LPITEMIDLIST pidlTarget;
    HRESULT hr = SHPidlFromDataObject(pdtobj, &pidlTarget, NULL, 0);
    if (SUCCEEDED(hr)) {
        ASSERT(pidlTarget);
        if((!ILIsWeb(pidlTarget) && _pdoh && SHIsRestricted2W(_pdoh->_hwnd, REST_NOFILEURL, NULL, 0)) ||
            (_pdoh && !IEIsLinkSafe(_pdoh->_hwnd, pidlTarget, ILS_NAVIGATE)))
        {
            ILFree(pidlTarget);
            hr = E_ACCESSDENIED;
        }
        else
        {
            DWORD flags = GetKeyState(VK_CONTROL) < 0 ?
            (SBSP_NEWBROWSER | SBSP_ABSOLUTE) :
            (SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
            hr = _psb->BrowseObject(pidlTarget, flags);
            HFRMMSG2(TEXT("::Drop _psb->BrowseObject returned"), hr, 0);
            ILFree(pidlTarget);
        }
    }
    if (SUCCEEDED(hr))
    {
        *pdwEffect &= _dwDragEffect;
    }

    DAD_DragLeave();
    return hr;
}


ULONG CDocObjectView::AddRef()
{
    _cRef++;
    TraceMsg(TF_SHDREF, "CDocObjectView(%x)::AddRef called new _cRef=%d", this, _cRef);
    return _cRef;
}

ULONG CDocObjectView::Release()
{
    _cRef--;
    TraceMsg(TF_SHDREF, "CDocObjectView(%x)::Release called new _cRef=%d", this, _cRef);

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDocObjectView::GetView(SHELLVIEWID* pvid, ULONG uView)
{
    return E_NOTIMPL;
}


#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_SHDREF, "CDocObjectView(%x)::QI(%s) is AddRefing _cRef=%d", this, psz, _cRef); }
#else
#define _AddRef(psz) ++_cRef
#endif

HRESULT CDocObjectView::QueryInterface(REFIID riid, void ** ppvObj)
{
    HRESULT hres;

    static const QITAB qit[] = {
        QITABENT(CDocObjectView, IShellView2),
        QITABENTMULTI(CDocObjectView, IShellView, IShellView2),
        QITABENTMULTI(CDocObjectView, IOleWindow, IShellView2),
        QITABENT(CDocObjectView, IDropTarget),
        QITABENT(CDocObjectView, IViewObject),
        QITABENT(CDocObjectView, IAdviseSink),
        QITABENT(CDocObjectView, IOleCommandTarget),
        QITABENT(CDocObjectView, IDocViewSite),
        QITABENT(CDocObjectView, IPrivateOleObject ),
        QITABENT(CDocObjectView, IPersistFolder),
        QITABENTMULTI(CDocObjectView, IPersist, IPersistFolder),
        QITABENT(CDocObjectView, IServiceProvider),
        { 0 },
    };

    hres = QISearch(this, qit, riid, ppvObj);

    if (S_OK != hres)
    {
        if (IsEqualIID(riid, CLSID_CDocObjectView))
        {
            *ppvObj = (void*)this;
            _AddRef(TEXT("CLSID_CDocObjectView"));
            return S_OK;
        }
    }

    return hres;
}



/// ***** IViewObject ******

HRESULT CDocObjectView::GetColorSet(DWORD dwAspect, LONG lindex,
    void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    if (_pdoh)
    {
        return _pdoh->GetColorSet(dwAspect, lindex, pvAspect, ptd,
            hicTargetDev, ppColorSet);
    }

    if (ppColorSet)
        *ppColorSet = NULL;

    return S_FALSE;
}

HRESULT CDocObjectView::Freeze(DWORD, LONG, void *, DWORD *pdwFreeze)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectView::Unfreeze(DWORD)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectView::SetAdvise(DWORD dwAspect, DWORD advf,
    IAdviseSink *pSink)
{
    if (dwAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    if (advf & ~(ADVF_PRIMEFIRST | ADVF_ONLYONCE))
        return E_INVALIDARG;

    if (pSink != _padvise)
    {
        ATOMICRELEASE(_padvise);

        _padvise = pSink;

        if (_padvise)
            _padvise->AddRef();
    }

    if (_padvise)
    {
        _advise_aspect = dwAspect;
        _advise_advf = advf;

        if (advf & ADVF_PRIMEFIRST)
            OnViewChange(dwAspect, -1);
    }
    else
        _advise_aspect = _advise_advf = 0;

    return S_OK;
}

HRESULT CDocObjectView::GetAdvise(DWORD *pdwAspect, DWORD *padvf,
    IAdviseSink **ppSink)
{
    if (pdwAspect)
        *pdwAspect = _advise_aspect;

    if (padvf)
        *padvf = _advise_advf;

    if (ppSink)
    {
        if (_padvise)
            _padvise->AddRef();

        *ppSink = _padvise;
    }

    return S_OK;
}

HRESULT CDocObjectView::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
    DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
    const RECTL *lprcBounds, const RECTL *lprcWBounds,
    BOOL (*pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue)
{
    if (_pdoh) {
        return _pdoh->Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev,
            hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
    }

    return OLE_E_BLANK;
}

// IAdviseSink
void CDocObjectView::OnDataChange(FORMATETC *, STGMEDIUM *)
{
}

void CDocObjectView::OnViewChange(DWORD dwAspect, LONG lindex)
{
    dwAspect &= _advise_aspect;

    if (dwAspect && _padvise)
    {
        IAdviseSink *pSink = _padvise;
        IUnknown *punkRelease;

        if (_advise_advf & ADVF_ONLYONCE)
        {
            punkRelease = pSink;
            _padvise = NULL;
            _advise_aspect = _advise_advf = 0;
        }
        else
            punkRelease = NULL;

        pSink->OnViewChange(dwAspect, lindex);

        if (punkRelease)
            punkRelease->Release();
    }
}

void CDocObjectView::OnRename(IMoniker *)
{
}

void CDocObjectView::OnSave()
{
}

void CDocObjectView::OnClose()
{
    //
    // the doc object host went away so tell anybody above what happened
    //
    OnViewChange(_advise_aspect, -1);
}


HRESULT CDocObjectView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (_pdho && _pdoh)
        hres = _pdho->QueryStatusDown(pguidCmdGroup, cCmds, rgCmds, pcmdtext);

    return hres;
}

HRESULT CDocObjectView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (!pguidCmdGroup)
    {
        switch (nCmdID)
        {
        case OLECMDID_REFRESH:
            _SetLastRefreshTime();
            break;

        default:
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
        case SHDVID_UPDATEDOCHOSTSTATE:
            if (_pdoh)
            {
                DOCHOSTUPDATEDATA * pdhud;

                ASSERT(pvarargIn && pvarargIn->vt == VT_PTR);
                pdhud = (DOCHOSTUPDATEDATA *) V_BYREF(pvarargIn);
                return _pdoh->_UpdateState(pdhud->_pidl, pdhud->_fIsErrorUrl);
            }
            return S_OK;

        case SHDVID_COMPLETEDOCHOSTPASSING:
            _CompleteDocHostPassing(_psvPrev, S_OK);
            ATOMICRELEASE(_psvPrev);

            return S_OK;

        case SHDVID_NAVSTART:
            if (_pdoh)
            {
                _pdoh->_Init();
            }
            
            return S_OK;

        default:
            break;
        }
    }

    // only forward on if we aren't 'stolen'.
    // FEATURE ie4: clean this up to steal _pdho along w/ _pdoh.
    if (_pdho && _pdoh)
        hres = _pdho->ExecDown(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    // REVIEW: if _pdoh->ExecDown fails && pguidCmdGroup==NULL && nCmdID is
    //            OLECMDID_STOP or OLECMDID_REFRESH, then we are lying
    //            by returning a failure error code.

    return hres;
}

HRESULT CDocObjectView::OnSetTitle(VARIANTARG *pvTitle)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectView::SetExtent( DWORD dwDrawAspect, SIZEL *psizel)
{
    if ( _pdoh && _pdoh->GetOleObject() )
    {
        return _pdoh->GetOleObject()->SetExtent( dwDrawAspect, psizel );
    }

    return E_NOTIMPL;
}

HRESULT CDocObjectView::GetExtent( DWORD dwDrawAspect, SIZEL *psizel)
{
    if ( _pdoh && _pdoh->GetOleObject() )
    {
        return _pdoh->GetOleObject()->GetExtent( dwDrawAspect, psizel );
    }

    return E_NOTIMPL;
}

HRESULT CDocObjectView::GetClassID(CLSID *pclsid)
{
    if (pclsid)
    {
        *pclsid = CLSID_CDocObjectView;
        return S_OK;
    }
    return E_INVALIDARG;
}

HRESULT CDocObjectView::Initialize(LPCITEMIDLIST pidl)
{
    HRESULT hres = E_OUTOFMEMORY;

    LPITEMIDLIST pidlClone = ILClone(pidl);
    if (pidlClone)
    {
        IShellFolder* psf;
        if (SUCCEEDED(IEBindToObject(_pidl, &psf)))
        {
            ILFree(_pidl);
            ATOMICRELEASE(_psf);

            _pidl = pidlClone;
            _psf = psf;

            hres = S_OK;
        }
        else
        {
            ILFree(pidlClone);
        }
    }

    return hres;
}

HRESULT CDocObjectView::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if( _pdoh && IsEqualGUID(guidService, IID_IElementNamespaceTable) )
    {
        return _pdoh->QueryService( guidService, riid, ppvObj);
    }
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shell32.cpp ===
// Wrappers for APIs that have moved elsewhere

#include "priv.h"
#include "shlwapip.h"

//------------------------------------------------------------------------
//
// APIs from SHDOCVW that are now forwarded to SHLWAPI
//
//
//  Note that we cannot use DLL forwarders because there is a bug
//  in Win95 where the loader screws up forwarders for bound DLLs.

STDAPI_(DWORD) StopWatchModeFORWARD(VOID)
{
    return StopWatchMode();
}

STDAPI_(DWORD) StopWatchFlushFORWARD(VOID)
{
    return StopWatchFlush();
}

STDAPI SHRunIndirectRegClientCommandForward(HWND hwnd, LPCWSTR pszClient)
{
    return SHRunIndirectRegClientCommand(hwnd, pszClient);
}

#ifdef ux10
/*IEUNIX : In the hp-ux linker, there is no option of specifying an internal name and an external name.  */
#define StopWatch StopWatch
#define StopWatchFORWARD StopWatch
#endif 

STDAPI_(DWORD) StopWatchFORWARD(DWORD dwId, LPCSTR pszDesc, DWORD dwType, DWORD dwFlags, DWORD dwCount)
{
    return StopWatchA(dwId, (LPCSTR)pszDesc, dwType, dwFlags, dwCount);
}

//------------------------------------------------------------------------
//
// APIs from SHDOCVW that are now forwarded to SHELL32/SHDOC41

//
//  This variable name is a misnomer.  It's really
//
//  g_hinstShell32OrShdoc401DependingOnWhatWeDetected;
//
//  I can live with the misnomer; saves typing.  Think of it as
//  "the INSTANCE of SHDOC401 or whatever DLL is masquerading as
//  SHDOC401".
//
//

extern "C" { HINSTANCE g_hinstSHDOC401 = NULL; }

//
//  GetShdoc401
//
//  Detect whether we should be using Shell32 or Shdoc401 to handle
//  active desktop stuff.  The rule is
//
//  If PF_FORCESHDOC401 is set, then use shdoc401. (DEBUG only)
//  If shell32 version >= 5, then use shell32.
//  Else use shdoc401.
//
//  Warning:  THIS FUNCTION CANNOT BE CALLED DURING PROCESS_ATTACH
//  because it calls LoadLibrary.

HINSTANCE GetShdoc401()
{
    DWORD dwMajorVersion;
    HINSTANCE hinst;
    HINSTANCE hinstSh32 = GetModuleHandle(TEXT("SHELL32.DLL"));
    ASSERT(hinstSh32);

#ifdef DEBUG
    if (g_dwPrototype & PF_FORCESHDOC401) {
        hinstSh32 = NULL; // force SHDOC401 to be loaded
    }
#endif

    if (hinstSh32) {
        DLLVERSIONINFO dllinfo;
        DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstSh32, "DllGetVersion");

        dllinfo.cbSize = sizeof(DLLVERSIONINFO);
        if (pfnGetVersion && SUCCEEDED(pfnGetVersion(&dllinfo))) {
            dwMajorVersion = dllinfo.dwMajorVersion;
        } else {
            dwMajorVersion = 0;
        }
    } else {
        dwMajorVersion = 0;
    }

    if (dwMajorVersion >= 5) {
        hinst = hinstSh32;
    } else {
        hinst = LoadLibrary(TEXT("SHDOC401.DLL"));

        if (NULL == hinst)
        {
            // If this fails we're screwed
            TraceMsg(TF_ERROR, "Failed to load SHDOC401.DLL.");
        }
    }
    g_hinstSHDOC401 = hinst;

    return hinst;
}

//
//  GetShdoc401ProcAddress
//
//  Get a procedure from SHDOC401 or whoever is masquerading as same.
//
//  Warning:  THIS FUNCTION CANNOT BE CALLED DURING PROCESS_ATTACH
//  because it calls LoadLibrary.

FARPROC GetShdoc401ProcAddress(FARPROC *ppfn, UINT ord)
{
    if (*ppfn) {
        return *ppfn;
    } else {
        HINSTANCE hinst = g_hinstSHDOC401;

        //
        //  No race condition here.  If two threads both call GetShdoc401,
        //  all that happens is that we load SHDOC401 into memory and then
        //  bump his refcount up to 2 instead of leaving it at 1.  Big deal.
        //
        if (hinst == NULL) {
            hinst = GetShdoc401();
        }

        if (hinst) {
            return *ppfn = GetProcAddress(hinst, (LPCSTR)LongToHandle(ord));
        } else {
            return NULL;
        }
    }
}

//
//  Delay-load-like macros.
//

#define DELAY_LOAD_SHDOC401(_type, _err, _fn, _ord, _arg, _nargs)   \
    STDAPI_(_type) _fn _arg                                         \
    {                                                               \
        static FARPROC s_pfn##_fn = NULL;                           \
        FARPROC pfn = GetShdoc401ProcAddress(&s_pfn##_fn, _ord);    \
        if (pfn) {                                                  \
            typedef _type (__stdcall *PFN##_fn) _arg;               \
            return ((PFN##_fn)pfn) _nargs;                          \
        } else {                                                    \
            return _err;                                            \
        }                                                           \
    }                                                               \

#define DELAY_LOAD_SHDOC401_VOID(_fn, _ord, _arg, _nargs)           \
    STDAPI_(void) _fn _arg                                          \
    {                                                               \
        static FARPROC s_pfn##_fn = NULL;                           \
        FARPROC pfn = GetShdoc401ProcAddress(&s_pfn##_fn, _ord);    \
        if (pfn) {                                                  \
            typedef void (__stdcall *PFN##_fn) _arg;                \
            ((PFN##_fn)pfn) _nargs;                                 \
        }                                                           \
    }                                                               \

// IE4 Shell Integrated Explorer called ShellDDEInit in shdocvw to
// set up DDE. Forward this call to SHELL32/SHDOC401 appropriately.

DELAY_LOAD_SHDOC401_VOID(ShellDDEInit, 188,
                         (BOOL fInit),
                         (fInit));

DELAY_LOAD_SHDOC401(HANDLE, NULL,
                    SHCreateDesktop, 200,
                    (IDeskTray* pdtray),
                    (pdtray));

DELAY_LOAD_SHDOC401(BOOL, FALSE,
                    SHDesktopMessageLoop, 201,
                    (HANDLE hDesktop),
                    (hDesktop));

// This may not have been used in IE4
DELAY_LOAD_SHDOC401(BOOL, FALSE,
                    DDEHandleViewFolderNotify, 202,
                    (IShellBrowser* psb, HWND hwnd, LPNMVIEWFOLDER lpnm),
                    (psb, hwnd, lpnm));

DELAY_LOAD_SHDOC401(LPNMVIEWFOLDER, NULL,
                    DDECreatePostNotify, 82,
                   (LPNMVIEWFOLDER pnm), 
                   (pnm));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shembed.h ===
#ifndef __SHEMBED_H__
#define __SHEMBED_H__

#include "caggunk.h"
#include "cwndproc.h"

//=========================================================================
// CShellEmbedding class definition
//
// NOTE: I'm killing the embeddingness of this class since we
// never shipped a control marked for embedding. If we need it
// back we can easily inherit from CImpIPersistStorage instead
// of IPersist. If you do this, make sure dvoc.cpp explicitly
// returns failure for QI for IPersistStorage or Trident won't
// host it.
//
//=========================================================================
class CShellEmbedding
    : public IPersist
    , public IOleObject               // Embedding MUST
    , public IViewObject2             // Embedding MUST
    , public IDataObject              // for Word/Excel
    , public IOleInPlaceObject        // In-Place MUST
    , public IOleInPlaceActiveObject  // In-Place MUST
    , public IInternetSecurityMgrSite
    , public CAggregatedUnknown
    , protected CImpWndProc
{
public:
    // *** IUnknown ***
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CAggregatedUnknown::QueryInterface(riid, ppvObj); }
    virtual ULONG __stdcall AddRef(void)
        { return CAggregatedUnknown::AddRef(); }
    virtual ULONG __stdcall Release(void)
        { return CAggregatedUnknown::Release(); }

    // *** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);

    // *** IViewObject ***
    virtual STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR);
    virtual STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *,
        HDC, LOGPALETTE **);
    virtual STDMETHODIMP Freeze(DWORD, LONG, void *, DWORD *);
    virtual STDMETHODIMP Unfreeze(DWORD);
    virtual STDMETHODIMP SetAdvise(DWORD, DWORD, IAdviseSink *);
    virtual STDMETHODIMP GetAdvise(DWORD *, DWORD *, IAdviseSink **);

    // *** IViewObject2 ***
    virtual STDMETHODIMP GetExtent(DWORD, LONG, DVTARGETDEVICE *, LPSIZEL);

    // *** IOleObject ***
    virtual HRESULT __stdcall SetClientSite(IOleClientSite *pClientSite);
    virtual HRESULT __stdcall GetClientSite(IOleClientSite **ppClientSite);
    virtual HRESULT __stdcall SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    virtual HRESULT __stdcall Close(DWORD dwSaveOption);
    virtual HRESULT __stdcall SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk);
    virtual HRESULT __stdcall GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    virtual HRESULT __stdcall InitFromData(IDataObject *pDataObject,BOOL fCreation,DWORD dwReserved);
    virtual HRESULT __stdcall GetClipboardData(DWORD dwReserved,IDataObject **ppDataObject);
    virtual HRESULT __stdcall DoVerb(LONG iVerb,LPMSG lpmsg,IOleClientSite *pActiveSite,LONG lindex,HWND hwndParent,LPCRECT lprcPosRect);
    virtual HRESULT __stdcall EnumVerbs(IEnumOLEVERB **ppEnumOleVerb);
    virtual HRESULT __stdcall Update(void);
    virtual HRESULT __stdcall IsUpToDate(void);
    virtual HRESULT __stdcall GetUserClassID(CLSID *pClsid);
    virtual HRESULT __stdcall GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType);
    virtual HRESULT __stdcall SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    virtual HRESULT __stdcall GetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    virtual HRESULT __stdcall Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall Unadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumAdvise(IEnumSTATDATA **ppenumAdvise);
    virtual HRESULT __stdcall GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    virtual HRESULT __stdcall SetColorScheme(LOGPALETTE *pLogpal);

    // *** IDataObject ***
    virtual HRESULT __stdcall GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall QueryGetData(FORMATETC *pformatetc);
    virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    virtual HRESULT __stdcall SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT __stdcall DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall DUnadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

    // *** IOleWindow ***
    virtual HRESULT __stdcall GetWindow(HWND * lphwnd);
    virtual HRESULT __stdcall ContextSensitiveHelp(BOOL fEnterMode);

    // *** IOleInPlaceObject ***
    virtual HRESULT __stdcall InPlaceDeactivate(void);
    virtual HRESULT __stdcall UIDeactivate(void);
    virtual HRESULT __stdcall SetObjectRects(LPCRECT lprcPosRect,
        LPCRECT lprcClipRect);
    virtual HRESULT __stdcall ReactivateAndUndo(void);

    // *** IOleInPlaceActiveObject ***
    virtual HRESULT __stdcall TranslateAccelerator(LPMSG lpmsg);
    virtual HRESULT __stdcall OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT __stdcall OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT __stdcall ResizeBorder(LPCRECT prcBorder,
        IOleInPlaceUIWindow *pUIWindow, BOOL fFrameWindow);
    virtual HRESULT __stdcall EnableModeless(BOOL fEnable);

protected:
    CShellEmbedding(IUnknown* punkOuter, LPCOBJECTINFO poi, const OLEVERB* pverbs=NULL);
    virtual ~CShellEmbedding();
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);

    virtual void _OnSetClientSite(void);    // called when we actually get a client site

    // Activation related -- this is the normal order these funcs get called
    HRESULT _DoActivateChange(IOleClientSite* pActiveSite, UINT uState, BOOL fForce); // figures out what to do
    virtual HRESULT _OnActivateChange(IOleClientSite* pActiveSite, UINT uState);// calls below
    virtual void _OnInPlaceActivate(void);      // called when we actually go in-place-active
    virtual void _OnUIActivate(void);           // called when we actually go ui-active
    virtual void _OnUIDeactivate(void);         // called when we actually go ui-deactive
    virtual void _OnInPlaceDeactivate(void);    // called when we actually deactivate

    // Window related
    virtual LRESULT v_WndProc(HWND, UINT, WPARAM, LPARAM);
    void _RegisterWindowClass(void);

    // Helper functions for subclasses
    HRESULT _CreateWindowOrSetParent(IOleWindow* pwin);
    HDC _OleStdCreateDC(DVTARGETDEVICE *ptd);

    void _ViewChange(DWORD dwAspect, LONG lindex);
    void _SendAdvise(UINT uCode);

    BOOL _ShouldDraw(LONG lindex);

    IOleClientSite*     _pcli;
    IOleClientSite*     _pcliHold;  // Save a pointer to our client site if we're DoVerbed after Close
    IAdviseSink*        _padv;
    DWORD               _advf;      // ADVF_ flags (p.166 OLE spec)
    DWORD               _asp;       // DVASPECT
    IStorage*           _pstg;
    SIZE                _size;
    SIZEL               _sizeHIM;       // HIMETRIC SetExtent size -- we pretty much ignore this.
    LPCOBJECTINFO       _pObjectInfo;   // pointer into global object array

    // WARNING: Load's OLE
    IOleAdviseHolder*   _poah;
    IDataAdviseHolder*  _pdah;

    // In-Place object specific
    RECT                _rcPos;
    RECT                _rcClip;
    IOleInPlaceSite*    _pipsite;
    IOleInPlaceFrame*   _pipframe;
    IOleInPlaceUIWindow* _pipui;
    OLEINPLACEFRAMEINFO _finfo;
    HWND                _hwndChild;
    const OLEVERB*      _pverbs;
    BOOL                _fDirty:1;
    BOOL                _fOpen:1;
    BOOL                _fUsingWindowRgn:1;
    UINT                _nActivate;
};

// Activation defines
#define OC_DEACTIVE         0
#define OC_INPLACEACTIVE    1
#define OC_UIACTIVE         2

//
//Copied from polyline.h in Inside OLE 2nd edition
//
//Code for CShellEmbedding::_SendAdvise
//......Code.....................Method called in CShellEmbedding::_SendAdvise
#define OBJECTCODE_SAVED       0 //IOleAdviseHolder::SendOnSave
#define OBJECTCODE_CLOSED      1 //IOleAdviseHolder::SendOnClose
#define OBJECTCODE_RENAMED     2 //IOleAdviseHolder::SendOnRename
#define OBJECTCODE_SAVEOBJECT  3 //IOleClientSite::SaveObject
#define OBJECTCODE_DATACHANGED 4 //IDataAdviseHolder::SendOnDataChange
#define OBJECTCODE_SHOWWINDOW  5 //IOleClientSite::OnShowWindow(TRUE)
#define OBJECTCODE_HIDEWINDOW  6 //IOleClientSite::OnShowWindow(FALSE)
#define OBJECTCODE_SHOWOBJECT  7 //IOleClientSite::ShowObject
#define OBJECTCODE_VIEWCHANGED 8 //IAdviseSink::OnViewChange

// A helper function in shembed.c
void PixelsToMetric(SIZEL* psize);
void MetricToPixels(SIZEL* psize);

//=========================================================================
// CSVVerb class definition
//=========================================================================
class CSVVerb : public IEnumOLEVERB
{
public:
    // *** IUnknown ***
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual ULONG __stdcall AddRef(void) ;
    virtual ULONG __stdcall Release(void);

    // *** IEnumOLEVERB ***
    virtual /* [local] */ HRESULT __stdcall Next(
        /* [in] */ ULONG celt,
        /* [out] */ LPOLEVERB rgelt,
        /* [out] */ ULONG *pceltFetched);

    virtual HRESULT __stdcall Skip(
        /* [in] */ ULONG celt);

    virtual HRESULT __stdcall Reset( void);

    virtual HRESULT __stdcall Clone(
        /* [out] */ IEnumOLEVERB **ppenum);

    CSVVerb(const OLEVERB* pverbs) : _cRef(1), _iCur(0), _pverbs(pverbs) {}

protected:
    UINT _cRef;
    UINT _iCur;
    const OLEVERB* _pverbs;
};


#endif // __SHEMBED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shuioc.cpp ===
//
// Shell UI Control Class (CShellUIHelper)
//
// Sample code : shell\docs\shuiod.htm
//
// This is the source code of the ShellUI control class. You can put an instance
// of ShellUI control on any HTML pages then
// 
// The key thing is it always bring up some UI and never alter the system
// silently (without the User's interaction). By doing this, we can expose
// shell features as much as we want without worrying about the security
// problem (which automation interface has).
// 
// This control also allow us to provide many configuration type UI (such as
// "Customize your IE page") as well as rich web-view on some folders
// (especially control panel ;-) without paying the cost of data-binding. 
// 
#include "priv.h"
#include "sccls.h"
#ifndef UNIX
#include <webcheck.h>
#else
#include <subsmgr.h>
#endif
#include "favorite.h"
#include "caggunk.h"
#include "resource.h"
#include "channel.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "iforms.h"
#include "dspsprt.h"
#include "impexp.h" // needed for RunImportExportWizard()
#include "iforms.h"
//#include "cobjsafe.h" // CObjectSafety
#include "shvocx.h" // WrapSpecialUrl()

#include <mluisupp.h>

#define REG_DESKCOMP_SCHEME                 TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Scheme")
#define REG_VAL_SCHEME_DISPLAY              TEXT("Display")
#define REG_VAL_GENERAL_WALLPAPER           TEXT("Wallpaper")
#define REG_VAL_GENERAL_TILEWALLPAPER       TEXT("TileWallpaper")
#define REG_DESKCOMP_GENERAL                TEXT("Software\\Microsoft\\Internet Explorer\\Desktop%sGeneral")

STDAPI SHAddSubscribeFavorite (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO* pInfo);

// move it to shdocvw.h
UINT IE_ErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCTSTR pszURLparam,
                    UINT idResource, UINT wFlags);

#define DM_SHUIOC   DM_TRACE

LONG GetSearchFormatString(DWORD dwIndex, LPTSTR psz, DWORD cbpsz);

HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);

EXTERN_C const SA_BSTRGUID s_sstrSearch;
EXTERN_C const SA_BSTRGUID s_sstrFailureUrl;


class CShellUIHelper :
        public CAggregatedUnknown,
        public IObjectWithSite,
        public IObjectSafety,
        public IShellUIHelper,  // dual, IDispatch
        public IDispatchEx,
        protected CImpIDispatch
{
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj) { return CAggregatedUnknown::QueryInterface(riid, ppvObj);};
    STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, 
        DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, 
        DWORD dwEnabledOptions);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                               LCID lcid, DISPID * rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, 
                        DISPPARAMS * pdispparams, VARIANT * pvarResult, 
                        EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // IDispatchEx
    STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
                          VARIANT *pvarRes, EXCEPINFO *pei, 
                          IServiceProvider *pspCaller);
    STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex);           
    STDMETHODIMP DeleteMemberByDispID(DISPID id);           
    STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);           
    STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName);
    STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk);

    // IShellUIHelper
    STDMETHODIMP Execute();
    STDMETHODIMP ResetSafeMode();
    STDMETHODIMP ResetFirstBootMode();
    STDMETHODIMP RefreshOfflineDesktop();
    STDMETHODIMP AddFavorite(BSTR strURL, VARIANT *Title);
    STDMETHODIMP AddChannel(BSTR bstrURL);
    STDMETHODIMP AddDesktopComponent(BSTR strURL, BSTR strType, 
                        VARIANT *Left, VARIANT *Top, 
                        VARIANT *Width, VARIANT *Height);
    STDMETHODIMP IsSubscribed(BSTR bstrURL, VARIANT_BOOL* pBool);
    STDMETHODIMP NavigateAndFind(BSTR URL, BSTR strQuery, VARIANT* varTargetFrame);
    STDMETHODIMP ImportExportFavorites(VARIANT_BOOL fImport, BSTR strImpExpPath);
    STDMETHODIMP AutoCompleteSaveForm(VARIANT *Form);
    STDMETHODIMP AutoScan(BSTR strSearch, BSTR strFailureUrl, VARIANT* pvarTargetFrame);
    STDMETHODIMP AutoCompleteAttach(VARIANT *Form);
    STDMETHODIMP ShowBrowserUI(BSTR bstrName, VARIANT *pvarIn, VARIANT *pvarOut);

    HRESULT v_InternalQueryInterface(REFIID riid, void ** ppvObj);

    CShellUIHelper(IUnknown* punkAgg);
    ~CShellUIHelper();

    inline IDispatch *GetExternalDispatch()
    {
        return _pExternalDispEx ? _pExternalDispEx : _pExternalDisp;
    }

    void SetExternalDispatch(IDispatch *pExternalDisp)
    {
        ATOMICRELEASE(_pExternalDisp);
        ATOMICRELEASE(_pExternalDispEx);

        //  If we were passed an IDispatch to delegate to then we need to
        //  see if it can do IDispatchEx so we can support it as well,
        //  otherwise we just fall back to good ole IDispatch.
        if (pExternalDisp)
        {
            if (FAILED(pExternalDisp->QueryInterface(IID_IDispatchEx, 
                                      (void **)&_pExternalDispEx)))
            {
                _pExternalDisp = pExternalDisp;
                _pExternalDisp->AddRef();
            }
        }
    }

    STDMETHODIMP ShowChannel(IChannelMgrPriv *pChMgrPriv, LPWSTR pwszURL, HWND hwnd);
    HWND _GetOwnerWindow();
    HRESULT _ConnectToTopLevelConnectionPoint(BOOL fConnect, IUnknown* punk);
    STDMETHODIMP _DoFindOnPage(IDispatch* pdisp);

    friend HRESULT CShellUIHelper_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend HRESULT CShellUIHelper_CreateInstance2(IUnknown** ppunk, REFIID riid, 
                                                 IUnknown *pSite, IDispatch *pExternalDisp);

    DWORD               _dwSafety;
    // Cached pointers, hwnd
    IUnknown*           _punkSite;  // site pointer
    IDispatchEx*        _pExternalDispEx;
    IDispatch*          _pExternalDisp;
    DWORD               _dwcpCookie;
    BOOL                _fWaitingToFindText;
    BSTR                _bstrQuery;
    VOID *              _pvIntelliForms;
};

STDAPI CShellUIHelper_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;
    CShellUIHelper* psuo = new CShellUIHelper(punkOuter);
    if (psuo)
    {
        *ppunk = psuo->_GetInner();
        hres = S_OK;
    }
    return hres;
}

HRESULT CShellUIHelper_CreateInstance2(IUnknown** ppunk, REFIID riid, 
                                      IUnknown *pSite, IDispatch *pExternalDisp)
{
    HRESULT hres = E_OUTOFMEMORY;
    CShellUIHelper* psuo = new CShellUIHelper(NULL);
    
    if (psuo)
    {
        hres = psuo->QueryInterface(riid, (void **)ppunk);
        psuo->Release();

        if (SUCCEEDED(hres))
        {
            psuo->SetSite(pSite);
            psuo->SetExternalDispatch(pExternalDisp);
        }
    }

    return hres;
}

CShellUIHelper::CShellUIHelper(IUnknown* punkAgg) :
    CAggregatedUnknown(punkAgg),
    CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_IShellUIHelper)
{
    DllAddRef();
    _fWaitingToFindText = FALSE;
    _bstrQuery = NULL;
}

CShellUIHelper::~CShellUIHelper()
{

    ReleaseIntelliForms(_pvIntelliForms);

    if (_punkSite)
        SetSite(NULL);  // In case the parent did not clean it up.
    if (_bstrQuery)
        SysFreeString(_bstrQuery);
    ATOMICRELEASE(_pExternalDisp);
    ATOMICRELEASE(_pExternalDispEx);

    DllRelease();
}

HRESULT CShellUIHelper::v_InternalQueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IShellUIHelper))
    {
        *ppvObj = SAFECAST(this, IShellUIHelper *);
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite *);
    }
    else if (IsEqualIID(riid, IID_IObjectSafety))
    {
        *ppvObj = SAFECAST(this, IObjectSafety *);
    }
    else if (IsEqualIID(riid, IID_IDispatchEx))
    {
        *ppvObj = SAFECAST(this, IDispatchEx *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HWND CShellUIHelper::_GetOwnerWindow()
{
    HWND hwnd;
    HRESULT hres;

    // this deals with NULL _punkSite and zeros hwnd on failure
    IUnknown_GetWindow(_punkSite, &hwnd);

    if (!hwnd)
    {
        //
        //  We get to this point if we are instantiated like this
        //  in jscript:
        //      foo = new ActiveXObject("Shell.UIControl");
        //  or vbscript:
        //      set foo = CreateObject("Shell.UIControl");
        //
        if (_punkSite)
        {
            IServiceProvider *pSP = NULL;
            IOleWindow *pOleWindow = NULL;
            hres = _punkSite->QueryInterface(IID_IServiceProvider, (void **)&pSP);

            if (SUCCEEDED(hres))
            {
                ASSERT(pSP);

                hres = pSP->QueryService(SID_SContainerDispatch, IID_IOleWindow, 
                                         (void **)&pOleWindow);
                if (SUCCEEDED(hres))
                {
                    pOleWindow->GetWindow(&hwnd);
                    pOleWindow->Release();
                }
                pSP->Release();
            }
        }
        else
        {
            //  It's either this or the functions we call should take NULL for HWNDs.
            hwnd = GetDesktopWindow();
        }
    }

    return hwnd;
}

HRESULT CShellUIHelper::_ConnectToTopLevelConnectionPoint(BOOL fConnect, IUnknown* punk)
{
    HRESULT hr = E_INVALIDARG;
    IConnectionPointContainer* pcpContainer;
    IServiceProvider*          psp;
    IServiceProvider*          psp2;

    ASSERT(punk);
    if (punk)
    {
        hr = punk->QueryInterface(IID_IServiceProvider, (void**)&psp);

        if (SUCCEEDED(hr))
        {
            hr = psp->QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void**) &psp2);

            if (SUCCEEDED(hr))
            {
                hr = psp2->QueryService(SID_SWebBrowserApp, IID_IConnectionPointContainer, (void **)&pcpContainer);

                if (SUCCEEDED(hr))
                {
                    //to avoid ambiguous reference
                    IDispatch* pdispThis;
                    this->QueryInterface(IID_IDispatch, (void **)&pdispThis);
                    ASSERT(pdispThis);
                
                    hr = ConnectToConnectionPoint(pdispThis, DIID_DWebBrowserEvents2, fConnect,
                                                  pcpContainer, &_dwcpCookie, NULL);
                    pcpContainer->Release();
                    pdispThis->Release();
                }
                psp2->Release();
            }
            psp->Release();
        }
    }
    
    return hr;
}

HRESULT CShellUIHelper::SetSite(IUnknown *punkSite)
{
    if (!_punkSite)
    {
        _ConnectToTopLevelConnectionPoint(TRUE, punkSite);
    } 
    else
    {
        ASSERT(punkSite == NULL);   //if we've already got _punkSite, we'd better be releasing the site

        _ConnectToTopLevelConnectionPoint(FALSE, _punkSite);
        ATOMICRELEASE(_punkSite);
    }
    
    _punkSite = punkSite;

    if (_punkSite)
        _punkSite->AddRef();

    return S_OK;
}

HRESULT CShellUIHelper::GetSite(REFIID riid, void **ppvSite)
{
    TraceMsg(DM_SHUIOC, "SHUO::GetSite called");

    if (_punkSite) 
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}

STDMETHODIMP CShellUIHelper::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, 
                                             DWORD *pdwEnabledOptions)
{
    HRESULT hr = S_OK;

    if (!pdwSupportedOptions || !pdwEnabledOptions)
        return E_POINTER;

    if (IID_IDispatch == riid)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions = _dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}


STDMETHODIMP CShellUIHelper::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, 
                                             DWORD dwEnabledOptions)
{
    HRESULT hr = S_OK;
    
    if (IID_IDispatch == riid)
        _dwSafety = dwOptionSetMask & dwEnabledOptions;
    else
        hr = E_NOINTERFACE;

    return hr;
}


struct SHUI_STRMAP 
{
    LPCTSTR psz;
    int id;
};

int _MapStringToId(LPCTSTR pszStr, const SHUI_STRMAP* const psmap, int cel, int idDefault)
{
    if (pszStr)
    {
        for (int i=0; i<cel ; i++) 
        {
            if (StrCmpI(psmap[i].psz, pszStr) == 0) 
            {
                return psmap[i].id;
            }
        }
    }
    return idDefault;
}


LPCTSTR OptionalVariantToStr(VARIANT *pvar, LPTSTR pszBuf, UINT cchBuf)
{
    if (pvar->vt == VT_BSTR && pvar->bstrVal)
    {
        SHUnicodeToTChar(pvar->bstrVal, pszBuf, cchBuf);
        return pszBuf;
    }
    *pszBuf = 0;
    return NULL;
}

int OptionalVariantToInt(VARIANT *pvar, int iDefault)
{
    VARIANT v;
    VariantInit(&v);
    if (SUCCEEDED(VariantChangeType(&v, pvar, 0, VT_I4)))
    {
        iDefault = v.lVal;
        // VariantClear(&v);   // not needed, VT_I4 has no allocs
    }
    return iDefault;
}

BOOL OptionalVariantToBool(VARIANT *pvar, BOOL fDefault)
{
    VARIANT v;
    VariantInit(&v);
    if (SUCCEEDED(VariantChangeType(&v, pvar, 0, VT_BOOL)))
    {
        fDefault = v.boolVal;
    }
    return fDefault;
}

//------------------------------------------------------------------------
STDMETHODIMP CShellUIHelper::AddFavorite(/* [in] */ BSTR strURL, /* [in][optional] */ VARIANT *Title)
{
    HRESULT hres = S_OK;
    LPITEMIDLIST pidl;
    BSTR bstrTemp = NULL;

    if (IsSpecialUrl(strURL))
    {
        bstrTemp = SysAllocString(strURL);
        if (bstrTemp)
        {
            hres = WrapSpecialUrl(&bstrTemp);
            if (SUCCEEDED(hres))
                strURL = bstrTemp;
        }
        else
            hres = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hres))
        hres = IECreateFromPath(strURL, &pidl);
    if (SUCCEEDED(hres)) 
    {
        TCHAR szTitle[MAX_PATH];
        hres = ::AddToFavorites(_GetOwnerWindow(), pidl, OptionalVariantToStr(Title, szTitle, ARRAYSIZE(szTitle)), TRUE, NULL, NULL);
        ILFree(pidl);
    }
    if (bstrTemp)
        SysFreeString(bstrTemp);
    return hres;
}


//------------------------------------------------------------------------

STDMETHODIMP CShellUIHelper::ShowChannel(IChannelMgrPriv *pChMgrPriv, LPWSTR pwszURL, HWND hwnd)
{
    HRESULT hres = E_FAIL;
    IServiceProvider *pSP1 = NULL,
                     *pSP2 = NULL;
    IWebBrowser2 *pWebBrowser2 = NULL;

    if (_punkSite)
    {
        hres = _punkSite->QueryInterface(IID_IServiceProvider, (void **)&pSP1);
        if (SUCCEEDED(hres))
        {
            ASSERT(pSP1);
            hres = pSP1->QueryService(SID_STopLevelBrowser,
                                      IID_IServiceProvider,
                                      (void**)&pSP2);
            if (SUCCEEDED(hres))
            {
                ASSERT(pSP2);
                hres = pSP2->QueryService(SID_SWebBrowserApp,
                                          IID_IWebBrowser2,
                                          (void**)&pWebBrowser2);
                ASSERT((SUCCEEDED(hres) && pWebBrowser2) || FAILED(hres));
                pSP2->Release();
            }
            pSP1->Release();
        }
    }

    if (FAILED(hres))
    {
        hres = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pWebBrowser2));
    }

    if (SUCCEEDED(hres))
    {
        ASSERT(pWebBrowser2);
        hres = pChMgrPriv->ShowChannel(pWebBrowser2, pwszURL, hwnd);
        pWebBrowser2->Release();
    }
    
    return hres;
}

STDMETHODIMP CShellUIHelper::AddChannel(BSTR bstrURL)
{
    HRESULT hres;
    IChannelMgrPriv *pChMgrPriv;

    TCHAR szURL[MAX_URL_STRING];
    HWND hwnd;

    if (!bstrURL)
    {
        return E_INVALIDARG;
    }
    
    hwnd = _GetOwnerWindow();

    //
    //  As long as the underlying functions choke on NULL HWNDs then we may as well
    //  bail early.
    //
    if (hwnd)
    {
        if (!SHIsRestricted2W(hwnd, REST_NoChannelUI, NULL, 0) && !SHIsRestricted2W(hwnd, REST_NoAddingChannels, NULL, 0))
        {
            StrCpyNW(szURL, bstrURL, ARRAYSIZE(szURL));

            hres = JITCoCreateInstance(CLSID_ChannelMgr, 
                                    NULL,
                                    CLSCTX_INPROC_SERVER, 
                                    IID_IChannelMgrPriv, 
                                    (void **)&pChMgrPriv,
                                    hwnd,
                                    FIEF_FLAG_FORCE_JITUI);

            if (S_OK == hres)
            {
                ASSERT(pChMgrPriv);
            
                hres = pChMgrPriv->AddAndSubscribe(hwnd, bstrURL, NULL);
                if (hres == S_OK)
                {
                    hres = ShowChannel(pChMgrPriv, bstrURL, hwnd);
                }
                else if (FAILED(hres))
                {
                    IE_ErrorMsgBox(NULL, hwnd, hres, NULL, szURL, IDS_CHANNEL_UNAVAILABLE, MB_OK| MB_ICONSTOP);
                    hres = S_FALSE;
                }
                pChMgrPriv->Release();
            }
            else if (SUCCEEDED(hres))
            {
                hres = S_FALSE; // FAIL silently for now - throw dialog for indicating that reboot required if needed
            } else
            {
                IE_ErrorMsgBox(NULL, hwnd, hres, NULL, szURL, IDS_FAV_UNABLETOCREATE, MB_OK| MB_ICONSTOP);
                hres = S_FALSE;
            }
        }
        else
        {
            hres = S_FALSE;  // Failure code results in a script error.
        }
    }
    else    //  !hwnd
    {
        hres = E_FAIL;
    }
    return hres;
}

STDAPI GetHTMLDoc2(IUnknown *punk, IHTMLDocument2 **ppHtmlDoc)
{
    *ppHtmlDoc = NULL;

    if (!punk)
        return E_FAIL;
        
    *ppHtmlDoc = NULL;
    //  The window.external, jscript "new ActiveXObject" and the <OBJECT> tag
    //  don't take us down the same road.

    IOleClientSite *pClientSite;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IOleClientSite, &pClientSite));
    if (SUCCEEDED(hr))
    {
        //  <OBJECT> tag path

        IOleContainer *pContainer;
        hr = pClientSite->GetContainer(&pContainer);
        if (SUCCEEDED(hr))
        {
            hr = pContainer->QueryInterface(IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
            pContainer->Release();
        }
    
        if (FAILED(hr))
        {
            //  window.external path
            IWebBrowser2 *pWebBrowser2;
            hr = IUnknown_QueryService(pClientSite, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pWebBrowser2));
            if (SUCCEEDED(hr))
            {
                IDispatch *pDispatch;
                hr = pWebBrowser2->get_Document(&pDispatch);
                if (SUCCEEDED(hr))
                {
                    hr = pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
                    pDispatch->Release();
                }
                pWebBrowser2->Release();
            }
        }
        pClientSite->Release();
    }
    else
    {
        //  jscript path
        hr = IUnknown_QueryService(punk, SID_SContainerDispatch, IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
    }

    ASSERT(FAILED(hr) || (*ppHtmlDoc));

    return hr;
}


// A lot like GetHTMLDoc2, but only cares about window.external
STDMETHODIMP GetTopLevelBrowser(IUnknown *punk, IWebBrowser2 **ppwb2)
{
    return IUnknown_QueryService(punk, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, ppwb2));
}


STDMETHODIMP ZoneCheck(IUnknown *punkSite, BSTR bstrReqUrl)
{
    HRESULT hr = E_ACCESSDENIED;

    //  Return S_FALSE if we don't have a host site since we have no way of doing a 
    //  security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
        return S_FALSE;

    //  1)  Get an IHTMLDocument2 pointer
    //  2)  Get URL from doc
    //  3)  Create security manager
    //  4)  Check if doc URL zone is local, if so everything's S_OK
    //  5)  Otherwise, get and compare doc URL SID to requested URL SID

    IHTMLDocument2 *pHtmlDoc;
    if (SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
    {
        ASSERT(pHtmlDoc);
        BSTR bstrDocUrl;
        if (SUCCEEDED(pHtmlDoc->get_URL(&bstrDocUrl)))
        {
            ASSERT(bstrDocUrl);
            IInternetSecurityManager *pSecMgr;

            if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, 
                                           NULL, 
                                           CLSCTX_INPROC_SERVER,
                                           IID_IInternetSecurityManager, 
                                           (void **)&pSecMgr)))
            {
                ASSERT(pSecMgr);
                DWORD dwZoneID = URLZONE_UNTRUSTED;
                if (SUCCEEDED(pSecMgr->MapUrlToZone(bstrDocUrl, &dwZoneID, 0)))
                {
                    if (dwZoneID == URLZONE_LOCAL_MACHINE)
                        hr = S_OK;
                }
                if (hr != S_OK && bstrReqUrl)
                {
                    BYTE reqSid[MAX_SIZE_SECURITY_ID], docSid[MAX_SIZE_SECURITY_ID];
                    DWORD cbReqSid = ARRAYSIZE(reqSid);
                    DWORD cbDocSid = ARRAYSIZE(docSid);

                    if (   SUCCEEDED(pSecMgr->GetSecurityId(bstrReqUrl, reqSid, &cbReqSid, 0))
                        && SUCCEEDED(pSecMgr->GetSecurityId(bstrDocUrl, docSid, &cbDocSid, 0))
                        && (cbReqSid == cbDocSid)
                        && (memcmp(reqSid, docSid, cbReqSid) == 0))
                    {

                        hr = S_OK;
                    }
                }
                pSecMgr->Release();
            }
            SysFreeString(bstrDocUrl);
        }
        pHtmlDoc->Release();
    }
    else
    {
        //  If we don't have an IHTMLDocument2 we aren't running in a browser that supports
        //  our OM.  We shouldn't block in this case since we could potentially
        //  get here from other hosts (VB, WHS, etc.).
        hr = S_FALSE;
    }

    return hr;
}

// This function checks to see if a navigation is happening from either internet
// or restricted url to LOCAL_MACHINE.
BOOL CanNavigateToUrlWithLocalMachineCheck(IUnknown *punkSite, BSTR pchurltarget)
{
    BOOL    bCanNavigate = FALSE;

    // Get the DochostUI flags for the site.
    IDocHostUIHandler *pIDocHostUI;
    if (SUCCEEDED(punkSite->QueryInterface(IID_PPV_ARG(IDocHostUIHandler, &pIDocHostUI))))
    {
        DOCHOSTUIINFO   dhInfo;
        if (SUCCEEDED(pIDocHostUI->GetHostInfo(&dhInfo)))
        {
            if (!(dhInfo.dwFlags & DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK))
                bCanNavigate = TRUE;
        }
        pIDocHostUI->Release();
    }

    // If the DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK is set or if we failed to
    // get the flags, do a check to see if the zone is elevated to local machine.
    if (!bCanNavigate)
    {
        // Get the site's url.
        IHTMLDocument2 *pHtmlDoc;
        if (SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
        {
            BSTR pchurlsource;
            if (SUCCEEDED(pHtmlDoc->get_URL(&pchurlsource)))
            {
                IInternetSecurityManager *pSecMgr;
                if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_SInternetSecurityManager,
                                                    IID_PPV_ARG(IInternetSecurityManager, &pSecMgr))) ||
                    SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                                            IID_PPV_ARG(IInternetSecurityManager, &pSecMgr))))
                {
                    DWORD   dwZoneIDSource  = URLZONE_UNTRUSTED;
                    DWORD   dwZoneIDTarget  = URLZONE_LOCAL_MACHINE;
                    DWORD   dwFlags         = PUAF_DEFAULT;

                    // Get zone of the source url.
                    if (!pchurlsource || IsSpecialUrl(pchurlsource))
                    {
                        // Treat special Urls as restricted.
                        dwZoneIDSource = URLZONE_UNTRUSTED;
                    }
                    else if (!SUCCEEDED(pSecMgr->MapUrlToZone(pchurlsource, &dwZoneIDSource, 0)))
                    {
                        // If MapUrlToZone fails, treat the url as restricted.
                        dwZoneIDSource = URLZONE_UNTRUSTED;
                    }

                    // Get zone of the target url
                    if (!SUCCEEDED(pSecMgr->MapUrlToZone(pchurltarget, &dwZoneIDTarget, 0)))
                    {
                        // If MapUrlToZone fails, treat the url as MyComputer.  This is safe.
                        dwZoneIDTarget = URLZONE_LOCAL_MACHINE;
                    }

                    // Check if there is a zone elevation.
                    if ((dwZoneIDSource != URLZONE_INTERNET &&
                        dwZoneIDSource != URLZONE_UNTRUSTED) ||
                        dwZoneIDTarget != URLZONE_LOCAL_MACHINE)
                    {
                        // There is no zone elevation.
                        bCanNavigate = TRUE;
                    }
                    pSecMgr->Release();
                }
                SysFreeString(pchurlsource);
            }
            pHtmlDoc->Release();
        }
    }
    return bCanNavigate;
}

STDMETHODIMP CShellUIHelper::IsSubscribed(BSTR bstrURL, VARIANT_BOOL* pBool)
{
    HRESULT hr;

    if (!bstrURL || !pBool)
    {
        return E_INVALIDARG;
    }

    hr = ZoneCheck(_punkSite, bstrURL);

    if (SUCCEEDED(hr))
    {
        ISubscriptionMgr *pSubscriptionMgr;

        hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                              IID_ISubscriptionMgr, (void**)&pSubscriptionMgr);
        if (SUCCEEDED(hr))
        {
            ASSERT(pSubscriptionMgr);

            BOOL tmpBool;
            
            hr = pSubscriptionMgr->IsSubscribed(bstrURL, &tmpBool);
            *pBool = tmpBool ? VARIANT_TRUE : VARIANT_FALSE;
            
            pSubscriptionMgr->Release();
        }
    }

    return hr;
}

/****************************************************************************
 *
 *  AddDesktopComponentA - Adds a component to the desktop
 *
 *  ENTRY:
 *      hwnd - the parent for all UI
 *      pszUrlA - the URL of the component
 *      iCompType - one of COMP_TYPE_*
 *      iLeft, iTop, iWidth, iHeight - dimensions of the component
 *      dwFlags - additional flags
 *
 *  RETURNS:
 *      TRUE on success
 *      
 ****************************************************************************/
BOOL AddDesktopComponentW(HWND hwnd, LPCWSTR pszUrl, int iCompType,
                                    int iLeft, int iTop, int iWidth, int iHeight,
                                    DWORD dwFlags)
{
    COMPONENT Comp;
    BOOL    fRet = FALSE;
    HRESULT hres;

    Comp.dwSize = sizeof(Comp);

    //
    // Build the pcomp structure.
    //
    Comp.dwID = -1;
    Comp.iComponentType = iCompType;
    Comp.fChecked = TRUE;
    Comp.fDirty = FALSE;
    Comp.fNoScroll = FALSE;
    Comp.dwSize = SIZEOF(Comp);
    Comp.cpPos.dwSize = SIZEOF(COMPPOS);
    Comp.cpPos.iLeft = iLeft;
    Comp.cpPos.iTop = iTop;
    Comp.cpPos.dwWidth = iWidth;
    Comp.cpPos.dwHeight = iHeight;
    Comp.cpPos.izIndex = COMPONENT_TOP;
    Comp.cpPos.fCanResize = TRUE;
    Comp.cpPos.fCanResizeX = TRUE;
    Comp.cpPos.fCanResizeY = TRUE;
    Comp.cpPos.iPreferredLeftPercent = 0;
    Comp.cpPos.iPreferredTopPercent = 0;
    StrCpyNW(Comp.wszSource, pszUrl, ARRAYSIZE(Comp.wszSource));
    StrCpyNW(Comp.wszSubscribedURL, pszUrl, ARRAYSIZE(Comp.wszSource));
    StrCpyNW(Comp.wszFriendlyName, pszUrl, ARRAYSIZE(Comp.wszFriendlyName));
    Comp.dwCurItemState = IS_NORMAL;

    IActiveDesktop * piad;

    //
    // Add it to the system.
    //
    hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (LPVOID*)&piad);
    if (SUCCEEDED(hres))
    {
        dwFlags |= DTI_ADDUI_POSITIONITEM;
        piad->AddDesktopItemWithUI(hwnd, &Comp, dwFlags);
        piad->Release();
        fRet = TRUE;
    } 

    return fRet;
}

//------------------------------------------------------------------------

STDMETHODIMP CShellUIHelper::AddDesktopComponent(BSTR strURL, BSTR strType, 
            /* [optional, in] */ VARIANT *Left,
            /* [optional, in] */ VARIANT *Top,
            /* [optional, in] */ VARIANT *Width,
            /* [optional, in] */ VARIANT *Height)
{
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX

    HRESULT hres;
    int iType;

    if (StrCmpIW(strType, L"image")==0) 
    {
        iType = COMP_TYPE_PICTURE;
    } 
    else if (StrCmpIW(strType, L"website")==0) 
    {
        iType = COMP_TYPE_WEBSITE;
    }
    else
    {
        iType = 0;
    }

    if (iType) 
    {
        AddDesktopComponentW(_GetOwnerWindow(), strURL, iType,
                             OptionalVariantToInt(Left, -1),
                             OptionalVariantToInt(Top, -1),
                             OptionalVariantToInt(Width, -1),
                             OptionalVariantToInt(Height, -1),
                             DTI_ADDUI_DISPSUBWIZARD);
        hres = S_OK;
    }
    else 
    {
        hres = E_INVALIDARG;
    }
    return hres;
#else // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX

return E_INVALIDARG;

#endif // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
}
void RemoveDefaultWallpaper();
STDMETHODIMP CShellUIHelper::ResetFirstBootMode()
{
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX

    if (MLShellMessageBox(
                        _GetOwnerWindow(),
                        MAKEINTRESOURCE(IDS_CONFIRM_RESETFLAG),
                        MAKEINTRESOURCE(IDS_TITLE),
                        MB_YESNO | MB_ICONQUESTION) == IDYES)
    {
        RemoveDefaultWallpaper();
        return S_OK;
    }

#endif // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    return S_FALSE;
}

// Little helper function used to change the safemode state
void SetSafeMode(DWORD dwFlags)
{
    IActiveDesktopP * piadp;

    HRESULT hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktopP, (LPVOID*)&piadp);
    if (SUCCEEDED(hres))
    {
        piadp->SetSafeMode(dwFlags);
        piadp->Release();
    }
}

STDMETHODIMP CShellUIHelper::ResetSafeMode()
{
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX

    if ((ZoneCheck(_punkSite, NULL) == S_OK) || (MLShellMessageBox(
                       _GetOwnerWindow(),
                       MAKEINTRESOURCE(IDS_CONFIRM_RESET_SAFEMODE),
                       MAKEINTRESOURCE(IDS_TITLE),
                       MB_YESNO | MB_ICONQUESTION) == IDYES))
    {
        SetSafeMode(SSM_CLEAR | SSM_REFRESH);
        return S_OK;
    }

#endif // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    return S_FALSE;
}

STDMETHODIMP CShellUIHelper::RefreshOfflineDesktop()
{
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    IADesktopP2 * piad;

    HRESULT hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IADesktopP2, (LPVOID*)&piad);
    if (SUCCEEDED(hres))
    {
        piad->UpdateAllDesktopSubscriptions();
        piad->Release();
    }
#endif // #ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    return S_OK;
}

STDMETHODIMP CShellUIHelper::GetTypeInfoCount(UINT * pctinfo)
{ 
    return E_NOTIMPL;
}

STDMETHODIMP CShellUIHelper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{ 
    return E_NOTIMPL;
}

STDMETHODIMP CShellUIHelper::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, 
                                      UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    HRESULT hr = E_FAIL;

    //  First let our host get a crack at this method
    IDispatch *pDisp = GetExternalDispatch();

    if (pDisp)
    {
        hr = pDisp->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
        if (SUCCEEDED(hr))
        {
            if (rgdispid[0] > 0)
            {
                //  Offset there dispid
                rgdispid[0] += DISPID_SHELLUIHELPERLAST;
            }
        }
    }

    if (FAILED(hr))
    {
        //  Our host didn't support it so we'll see if it's one of ours.
        hr = CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }

    return hr;
}

HRESULT CShellUIHelper::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS *pdispparams, VARIANT * pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    
    if ((dispidMember > 0) && (dispidMember <= DISPID_SHELLUIHELPERLAST))
    {
        hr = CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, 
                                   pvarResult, pexcepinfo, puArgErr);
    }
    else if (_fWaitingToFindText && (dispidMember == DISPID_DOCUMENTCOMPLETE))
    {
        ASSERT(pdispparams->rgvarg[1].vt == VT_DISPATCH);

        _fWaitingToFindText = FALSE;
        hr = _DoFindOnPage(pdispparams->rgvarg[1].pdispVal);
    }
    else
    {
        IDispatch *pDisp = GetExternalDispatch();
        if (pDisp)
        {
            if (dispidMember > 0)
            {
                //  Fixup the offset we added in GetIDsOfNames
                dispidMember -= DISPID_SHELLUIHELPERLAST;
            }
            hr = pDisp->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, 
                                        pvarResult, pexcepinfo, puArgErr);
        }
    }

    return hr;                                   
}

STDMETHODIMP CShellUIHelper::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr = E_FAIL;
    LCID lcid = GetSystemDefaultLCID();

    //  First let our host get a crack at this method via IDispatchEx or IDispatch
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetDispID(bstrName, grfdex, pid);
    }
    else if (_pExternalDisp)
    {
        hr = _pExternalDisp->GetIDsOfNames(IID_NULL, &bstrName, 1, lcid, pid);
    }

    if (SUCCEEDED(hr))
    {
        if (*pid > 0)
        {
            *pid += DISPID_SHELLUIHELPERLAST;
        }
    }
    else
    {
        //  Our host didn't support it so we'll see if it's one of ours.
        hr = CImpIDispatch::GetIDsOfNames(IID_NULL, &bstrName, 1, lcid, pid);
    }

    return hr;
}

STDMETHODIMP CShellUIHelper::InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
                                 VARIANT *pvarRes, EXCEPINFO *pei, 
                                 IServiceProvider *pspCaller)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    UINT ArgErr;    //  inetsdk says this isn't used here

    //  First see if it's ours
    if ((id > 0) && (id <= DISPID_SHELLUIHELPERLAST))
    {
        hr = CImpIDispatch::Invoke(id, IID_NULL, lcid, wFlags, pdp, 
                                   pvarRes, pei, &ArgErr);
    }
    else
    {
        if (id > 0)
        {
            id -= DISPID_SHELLUIHELPERLAST;
        }
        //  otherwise try external IDispatchEx 
        if (_pExternalDispEx)
        {
            hr = _pExternalDispEx->InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
        }
        //  finally try the external IDispatch
        else if (_pExternalDisp)
        {
            hr = _pExternalDisp->Invoke(id, IID_NULL, lcid, wFlags, pdp, 
                                        pvarRes, pei, &ArgErr);
        }
    }
    
    return hr;
}

STDMETHODIMP CShellUIHelper::DeleteMemberByName(BSTR bstr, DWORD grfdex)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->DeleteMemberByName(bstr, grfdex);
    }

    return hr;
}
        
STDMETHODIMP CShellUIHelper::DeleteMemberByDispID(DISPID id)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->DeleteMemberByDispID(id);
    }

    return hr;
}
        
STDMETHODIMP CShellUIHelper::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetMemberProperties(id, grfdexFetch, pgrfdex);
    }

    return hr;
}
        
STDMETHODIMP CShellUIHelper::GetMemberName(DISPID id, BSTR *pbstrName)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetMemberName(id, pbstrName);
    }

    return hr;
}

STDMETHODIMP CShellUIHelper::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetNextDispID(grfdex, id, pid);
    }

    return hr;
}
        
STDMETHODIMP CShellUIHelper::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT hr = E_NOTIMPL;
    
    if (_pExternalDispEx)
    {
        hr = _pExternalDispEx->GetNameSpaceParent(ppunk);
    }

    return hr;
}

int GetIntFromReg(HKEY    hKey,
                  LPCTSTR lpszSubkey,
                  LPCTSTR lpszNameValue,
                  int     iDefault)
{
    TCHAR szValue[20];
    DWORD dwSizeofValueBuff = SIZEOF(szValue);
    int iRetValue = iDefault;
    DWORD dwType;

    if ((SHGetValue(hKey, lpszSubkey, lpszNameValue, &dwType,(LPBYTE)szValue,
                   &dwSizeofValueBuff) == ERROR_SUCCESS) && dwSizeofValueBuff)
    {
        if (dwType == REG_SZ)
        {
            iRetValue = (int)StrToInt(szValue);
        }
    }

    return iRetValue;
}

void GetRegLocation(LPTSTR lpszResult, DWORD cchResult, LPCTSTR lpszKey, LPCTSTR lpszScheme)
{
    TCHAR szSubkey[MAX_PATH];
    DWORD dwDataLength = sizeof(szSubkey) - 2 * sizeof(TCHAR);
    DWORD dwType;

    StrCpyN(szSubkey, TEXT("\\"), ARRAYSIZE(szSubkey));
    if (lpszScheme)
        StrCatBuff(szSubkey, lpszScheme, ARRAYSIZE(szSubkey));
    else
        SHGetValue(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, REG_VAL_SCHEME_DISPLAY, &dwType,
            (LPBYTE)(szSubkey) + sizeof(TCHAR), &dwDataLength);
    if (szSubkey[1])
        StrCatBuff(szSubkey, TEXT("\\"), ARRAYSIZE(szSubkey));

    wnsprintf(lpszResult, cchResult, lpszKey, szSubkey);
}

#define c_szWallpaper  REG_VAL_GENERAL_WALLPAPER
void RemoveDefaultWallpaper()
{
    // Read the Wallpaper from the Old location.
    TCHAR   szOldWallpaper[MAX_PATH];
    DWORD dwType;
    DWORD dwSize = SIZEOF(szOldWallpaper);
    if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_DESKTOP, c_szWallpaper, &dwType, szOldWallpaper, &dwSize) != ERROR_SUCCESS)
        szOldWallpaper[0] = TEXT('\0');

    // Read the wallpaper style
    DWORD dwWallpaperStyle = GetIntFromReg(HKEY_CURRENT_USER, REGSTR_PATH_DESKTOP, REG_VAL_GENERAL_TILEWALLPAPER, WPSTYLE_TILE);

    TCHAR szDeskcomp[MAX_PATH];
    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, NULL);

    // Set the old wallpaper into the new location.
    SHSetValue(HKEY_CURRENT_USER, szDeskcomp,
        c_szWallpaper, REG_SZ, (LPBYTE)szOldWallpaper, SIZEOF(szOldWallpaper));


//  98/08/14 vtan: This used to write out a REG_DWORD. It should've
//  written out a REG_SZ.

    TCHAR   szWallpaperStyle[2];

    (TCHAR*)StrCpyN(szWallpaperStyle, TEXT("0"), ARRAYSIZE(szWallpaperStyle));
    szWallpaperStyle[0] += static_cast<TCHAR>(dwWallpaperStyle & WPSTYLE_MAX);

    // Set the old wallpaper style into the new location.
    SHSetValue(HKEY_CURRENT_USER, szDeskcomp,
        REG_VAL_GENERAL_TILEWALLPAPER, REG_SZ, (LPBYTE)szWallpaperStyle, SIZEOF(szWallpaperStyle));

//  98/08/14 vtan #196226: Moved the create instance of IActiveDesktop
//  to here from entry of the function. When the instance is created the
//  registry information is cached in the member variable data. The
//  registry information for the wallpaper is then changed behind the
//  object instance and ApplyChanges() is called on STALE information.
//  By deferring the object instantiation to after the registry changes
//  the changes are applied correctly.

    IActiveDesktop * piad;
    HRESULT hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (LPVOID*)&piad);
    if (SUCCEEDED(hres))
    {
        piad->ApplyChanges(AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH);
        piad->Release();
    }
}


HRESULT GetTargetFrame(IUnknown* _punkSite, BSTR bstrFrame, IWebBrowser2** ppunkTargetFrame)
{
    IWebBrowser2 * pwb2;
    HRESULT        hr = GetTopLevelBrowser(_punkSite, &pwb2);

    *ppunkTargetFrame = NULL;

    if (SUCCEEDED(hr))
    {
        ITargetFrame2 * pOurTargetFrame;
        IUnknown      * punkTargetFrame = NULL;

        // See if there is an existing frame with the specified target name
        hr = TargetQueryService(pwb2, IID_PPV_ARG(ITargetFrame2, &pOurTargetFrame));
        
        if (SUCCEEDED(hr))
        {
            hr = pOurTargetFrame->FindFrame(bstrFrame, FINDFRAME_JUSTTESTEXISTENCE, &punkTargetFrame);
            if (SUCCEEDED(hr) && punkTargetFrame)
            {
                // yes, we found a frame with that name.  QI for the automation
                // interface on that frame.
                hr = punkTargetFrame->QueryInterface(IID_PPV_ARG(IWebBrowser2, ppunkTargetFrame));
                punkTargetFrame->Release();
            }
            pOurTargetFrame->Release();
        }
        pwb2->Release();
    }
    return hr;
}

// NavigateAndFind
// 1. navigate the specified target frame to the specified url
// 2. set _fWaitingToFindText so that on DocumentComplete, 
//    mimic the find dialog and select/highlight the specified text
STDMETHODIMP CShellUIHelper::NavigateAndFind(BSTR URL, BSTR strQuery, VARIANT* varTargetFrame)
{
    HRESULT        hr;
    IWebBrowser2 * pwb2         = NULL;
    BSTR           bstrFrameSrc = NULL;

    if (_bstrQuery)
        SysFreeString(_bstrQuery);
    _bstrQuery = SysAllocString(strQuery);
     
    BSTR bstrTemp = NULL;
    if (!IsSpecialUrl(URL))
    {
        hr = S_OK;
    }
    else
    {
        bstrTemp = SysAllocString(URL);
        if (bstrTemp)
        {
            hr = WrapSpecialUrl(&bstrTemp);
            if (SUCCEEDED(hr))
                URL = bstrTemp;
        }
        else
            hr = E_OUTOFMEMORY;
    }
        
    // Security:  Don't allow javascript on one web page
    //            to automatically execute in the zone
    //            of the target frame URL.
    if (SUCCEEDED(hr) && varTargetFrame)
    {
        hr = GetTargetFrame(_punkSite, varTargetFrame->bstrVal, &pwb2); // GetTargetFrame can return NULL pwb2 on S_OK (when bstrVal is "_blank")
        if (SUCCEEDED(hr) && pwb2)
        {
            hr = pwb2->get_LocationURL(&bstrFrameSrc);
            
            if (SUCCEEDED(hr))
            {
                IHTMLDocument2 *pHtmlDoc;
                if (SUCCEEDED(GetHTMLDoc2(_punkSite, &pHtmlDoc)))
                {
                    BSTR bstrDocUrl;
                    if (SUCCEEDED(pHtmlDoc->get_URL(&bstrDocUrl)))
                    {
                        hr = AccessAllowed(bstrDocUrl, bstrFrameSrc) ? S_OK : E_ACCESSDENIED;

                        if(!IsSpecialUrl(URL) && hr == E_ACCESSDENIED)
                        {
                            // For non-script navigates check policy
                            DWORD dwPolicy = 0;
                            DWORD dwContext = 0;
                            if( SUCCEEDED(ZoneCheckUrlEx(bstrDocUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, 
                                    sizeof(dwContext), URLACTION_HTML_SUBFRAME_NAVIGATE, 0, NULL)) && 
                                    GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW) 
                            {
                                hr = S_OK;
                            }
                        }
                        SysFreeString(bstrDocUrl);
                    }
                    pHtmlDoc->Release();
                }
                SysFreeString(bstrFrameSrc);
            }
            pwb2->Release();
            pwb2 = NULL;
        }
    }

    // Don't allow access to MyComputer zone from non-MyComputer zone.
    if (SUCCEEDED(hr) && !CanNavigateToUrlWithLocalMachineCheck(_punkSite, URL))
        hr = E_ACCESSDENIED;

    if (SUCCEEDED(hr))
        hr = GetTopLevelBrowser(_punkSite, &pwb2);

    if (SUCCEEDED(hr))
    {
        _fWaitingToFindText = TRUE;
        pwb2->Navigate(URL, PVAREMPTY, varTargetFrame, PVAREMPTY, PVAREMPTY);
        pwb2->Release();
    }

    if (bstrTemp)
        SysFreeString(bstrTemp);
        
    //script runtime error protection
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}


// AutoScan
//
// Takes the search string and tries to navigate to www.%s.com, www.%s.org etc.  If all of
// these fail then we navigate to pvarTargetFrame.
//
STDMETHODIMP CShellUIHelper::AutoScan
(
    BSTR strSearch,             // String to autoscan
    BSTR strFailureUrl,         // url to display is search fails
    VARIANT* pvarTargetFrame    // [optional] target frame
)
{
    HRESULT hr = E_FAIL;
    IWebBrowser2* pwb2;

    // Don't bother autoscanning if there are extended characters in the search string
    if (!HasExtendedChar(strSearch))
    {
        //first, check to see if the url is trying to spoof /1 security
        BSTR bstrTemp = NULL;
        if (IsSpecialUrl(strFailureUrl))
        {
            bstrTemp = SysAllocString(strFailureUrl);
            if (bstrTemp)
            {
                hr = WrapSpecialUrl(&bstrTemp);
                if (SUCCEEDED(hr))
                    strFailureUrl = bstrTemp;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            LPWSTR pszTarget = (pvarTargetFrame && pvarTargetFrame->vt == VT_BSTR && pvarTargetFrame->bstrVal) ?
                                    pvarTargetFrame->bstrVal : L"_main";

            hr = GetTargetFrame(_punkSite, pszTarget, &pwb2); // GetTargetFrame can return NULL pwb2 on S_OK (when bstrVal is "_blank")
            if (!pwb2)
                hr = E_FAIL;
            if (SUCCEEDED(hr))
            {
                BSTR bstrFrameSrc = NULL;               
                
                hr = pwb2->get_LocationURL(&bstrFrameSrc);
                
                if (SUCCEEDED(hr))
                {
                    IHTMLDocument2 *pHtmlDoc;
                    if (SUCCEEDED(GetHTMLDoc2(_punkSite, &pHtmlDoc)))
                    {
                        BSTR bstrDocUrl;
                        if (SUCCEEDED(pHtmlDoc->get_URL(&bstrDocUrl)))
                        {
                            hr = AccessAllowed(bstrDocUrl, bstrFrameSrc) ? S_OK : E_ACCESSDENIED;
                            SysFreeString(bstrDocUrl);
                        }
                        pHtmlDoc->Release();
                    }
                    SysFreeString(bstrFrameSrc);
                }

                // Don't allow access to MyComputer zone from non-MyComputer zone.
                if (SUCCEEDED(hr) && !CanNavigateToUrlWithLocalMachineCheck(_punkSite, strFailureUrl))
                    hr = E_ACCESSDENIED;

                if (SUCCEEDED(hr))
                {
                    
                    // We don't want to navigate to strSearch.  Start searching using the 
                    // first autoscan substitution.
                    WCHAR szFormat[MAX_PATH];
                    WCHAR szUrl[MAX_URL_STRING];
                    if (GetSearchFormatString(1, szFormat, sizeof(szFormat)) != ERROR_SUCCESS)
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        wnsprintf(szUrl, ARRAYSIZE(szUrl), szFormat, strSearch);
                        BSTRBLOB bstrBlob;
                        bstrBlob.cbSize = lstrlenW(szUrl) * sizeof(WCHAR);
                        bstrBlob.pData = (BYTE*)szUrl;
                        BSTR bstrUrl = (BSTR)bstrBlob.pData;
                        
                        // Save the original search string for autoscanning.  Normally
                        // this come from the addressbar, but in our case we store it as
                        // a property
                        VARIANT v;
                        VariantInit (&v);
                        
                        v.vt = VT_BSTR;
                        v.bstrVal = strSearch;
                        pwb2->PutProperty((BSTR)s_sstrSearch.wsz, v);
                        
                        // Save the error page in case the scan fails
                        v.vt = VT_BSTR;
                        v.bstrVal = strFailureUrl;
                        pwb2->PutProperty((BSTR)s_sstrFailureUrl.wsz, v);
                        
                        // Navigate with autosearch enabled
                        VARIANT vFlags;
                        vFlags.vt = VT_I4;
                        vFlags.lVal = navAllowAutosearch;
                        
                        pwb2->Navigate(bstrUrl, &vFlags, pvarTargetFrame, PVAREMPTY, PVAREMPTY);
                    }
                }
                pwb2->Release();
            }
        }
        if (bstrTemp)
            SysFreeString(bstrTemp);
    }

    //script runtime error protection
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

typedef HRESULT (*PFNSHOWBROWSERUI)(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut);

typedef void (*PFNOPENLANGUAGEDIALOG)(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);

HRESULT ShowLanguageDialog(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hInstInetcpl = LoadLibrary(TEXT("inetcpl.cpl"));

    if (hInstInetcpl)
    {
        
        PFNOPENLANGUAGEDIALOG pfnOpenLanguageDialog = 
            (PFNOPENLANGUAGEDIALOG)GetProcAddress( hInstInetcpl, "OpenLanguageDialog" );

        if (pfnOpenLanguageDialog)
        {
            pfnOpenLanguageDialog(hwnd, NULL, NULL, SW_SHOW);
            hr = S_OK;
        }

        FreeLibrary(hInstInetcpl);
    }

    return hr;
}

HRESULT ShowOrganizeFavorites(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut)
{
    return DoOrganizeFavDlgW(hwnd, NULL) ? S_OK : E_FAIL;
}

HRESULT ShowPrivacySettings(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut)
{
    LaunchPrivacySettings(hwnd);

    return S_OK;
}

HRESULT ShowProgramAccessAndDefaults(IUnknown *punkSite, HWND hwnd, VARIANT *pvarIn, VARIANT *pvarOut)
{
    HRESULT hr;

    const WCHAR c_szControlExe[] = L"control.exe";
    WCHAR szControlPath[MAX_PATH];

    UINT nLen = GetSystemDirectory(szControlPath, ARRAYSIZE(szControlPath));

    //  This accounts for needing a backslash after the sysdir
    if ((nLen + ARRAYSIZE(c_szControlExe)) < ARRAYSIZE(szControlPath))
    {
        PathAppend(szControlPath, c_szControlExe);

        HINSTANCE hInst = ShellExecute(NULL, NULL, szControlPath, L"appwiz.cpl,,3", NULL, SW_SHOWNORMAL);

        if (hInst > (HINSTANCE)HINSTANCE_ERROR)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(PtrToInt(hInst));
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

struct BROWSERUI_MAP
{
    LPWSTR pwszName;
    PFNSHOWBROWSERUI pfnShowBrowserUI;
};

const BROWSERUI_MAP s_browserUIMap[] =
{
    { L"LanguageDialog",            ShowLanguageDialog              },
    { L"OrganizeFavorites",         ShowOrganizeFavorites           },
    { L"PrivacySettings",           ShowPrivacySettings             },
    { L"ProgramAccessAndDefaults",  ShowProgramAccessAndDefaults    }
};

STDMETHODIMP CShellUIHelper::ShowBrowserUI(BSTR bstrName, VARIANT *pvarIn, VARIANT *pvarOut)
{
    HRESULT hr = E_FAIL;

    for (int i = 0; i < ARRAYSIZE(s_browserUIMap); i++)
    {
        if (pvarOut)
        {
            VariantInit(pvarOut);
        }
        
        if (0 == StrCmpIW(s_browserUIMap[i].pwszName, bstrName))
        {
            hr = s_browserUIMap[i].pfnShowBrowserUI(_punkSite, _GetOwnerWindow(), pvarIn, pvarOut);
        }
    }

    return S_OK == hr ? S_OK : S_FALSE;
}


// the find dialog does the following:
// 
// rng = document.body.createTextRange();
// if (rng.findText("Find this text"))
//     rng.select();
STDMETHODIMP CShellUIHelper::_DoFindOnPage(IDispatch* pdisp)
{
    HRESULT           hr;
    IWebBrowser2*     pwb2;
    IDispatch*        pdispDocument;
    IHTMLDocument2*   pDocument;
    IHTMLElement*     pBody;
    IHTMLBodyElement* pBodyElement;
    IHTMLTxtRange*    pRange;

    ASSERT(pdisp);
    if (!pdisp)
        return E_FAIL;

    hr = pdisp->QueryInterface(IID_IWebBrowser2, (void**)&pwb2);

    if (SUCCEEDED(hr))
    {
        hr = pwb2->get_Document(&pdispDocument);

        if (SUCCEEDED(hr) && (NULL != pdispDocument))
        {
            hr = pdispDocument->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument);
            
            if (SUCCEEDED(hr))
            {
                hr = pDocument->get_body(&pBody);
                
                if (SUCCEEDED(hr) && (NULL != pBody))
                {
                    hr = pBody->QueryInterface(IID_IHTMLBodyElement, (void**)&pBodyElement);

                    if (SUCCEEDED(hr))
                    {
                        hr = pBodyElement->createTextRange(&pRange);

                        if (SUCCEEDED(hr) && (NULL != pRange))
                        {
                            VARIANT_BOOL vbfFoundText;
                            
                            hr = pRange->findText(_bstrQuery, 1000000, 0, &vbfFoundText);

                            if (SUCCEEDED(hr) && (vbfFoundText == VARIANT_TRUE))
                            {
                                hr = pRange->select();
                            }
                            
                            pRange->Release();
                        }
                        pBodyElement->Release();
                    }
                    pBody->Release();
                }
                pDocument->Release();
            }
            pdispDocument->Release();
        }
        pwb2->Release();
    }
    return hr;
}

//
// Launch the favorites import/export wizard
//
STDMETHODIMP CShellUIHelper::ImportExportFavorites(VARIANT_BOOL fImport, BSTR strImpExpPath) 
{
    //don't allow to import/export to folders other than Favorites from OM
    DoImportOrExport(fImport==VARIANT_TRUE, NULL, (LPCWSTR)strImpExpPath, TRUE);
    return S_OK;
}

//
// Save the form data via intelliforms
//
STDMETHODIMP CShellUIHelper::AutoCompleteSaveForm(VARIANT *Form)
{
    HRESULT hrRet = S_FALSE;

    IHTMLDocument2 *pDoc2=NULL;

    GetHTMLDoc2(_punkSite, &pDoc2);
    
    if (pDoc2)
    {
        hrRet = IntelliFormsSaveForm(pDoc2, Form);
        pDoc2->Release();
    }

    return hrRet;
}

//
// Attach intelliforms to this document
//
STDMETHODIMP CShellUIHelper::AutoCompleteAttach(VARIANT *Reserved)
{
    HRESULT hr=E_FAIL;

    if (_pvIntelliForms == NULL)
    {
        IHTMLDocument2 *pDoc2=NULL;

        GetHTMLDoc2(_punkSite, &pDoc2);

        if (pDoc2)
        {
            hr = S_OK;
            AttachIntelliForms(NULL, _GetOwnerWindow(), pDoc2, &_pvIntelliForms);
            pDoc2->Release();
        }
    }

    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\smallutil.cpp ===
#include "priv.h"
#include <mluisupp.h>

#include "SmallUtil.hpp"


CCancellableThread::CCancellableThread()
{
    _hCancelEvent = NULL;
    _hThread = NULL;
    _fIsFinished = FALSE;
    _dwThreadResult = 0;
}

CCancellableThread::~CCancellableThread()
{
    if( _hCancelEvent)
        CloseHandle( _hCancelEvent);

    if( _hThread)
    {
        DWORD dwThreadStatus;
        if(0 != GetExitCodeThread( _hThread, &dwThreadStatus)
           && dwThreadStatus == STILL_ACTIVE)
        {
            ASSERT( 0);  // bad error case, shouldn't need to terminate thread.
            TerminateThread( _hThread, 0);
        }
        CloseHandle( _hThread);
    }
}


BOOL CCancellableThread::Initialize()
{
    BOOL retVal = FALSE;
    
    _hCancelEvent = CreateEvent( NULL, TRUE, FALSE, NULL);

    if( !_hCancelEvent)
        goto doneCCancellableThreadInitialize;

    retVal = TRUE;
doneCCancellableThreadInitialize:
    return retVal;
}


BOOL CCancellableThread::IsCancelled()
{
    if( !_hCancelEvent)
        return FALSE;

    DWORD dwEventWaitResult;
    dwEventWaitResult = WaitForSingleObject( _hCancelEvent, 0);

    if( dwEventWaitResult == WAIT_OBJECT_0)
        return TRUE;
    else
        return FALSE;
}


BOOL CCancellableThread::IsRunning()
{
    if( NULL == _hThread)
        return FALSE;
    else
        return _fIsFinished ? FALSE : TRUE;
}


BOOL CCancellableThread::IsFinished()
{
    return _fIsFinished;
}


BOOL CCancellableThread::GetResult( PDWORD pdwResult)
{
    BOOL retVal = FALSE;

    if( IsFinished() != TRUE)
        goto doneCCancellableThreadGetStatus;

    *pdwResult = _dwThreadResult;
    retVal = TRUE;
    
doneCCancellableThreadGetStatus:
    return retVal;
}


BOOL CCancellableThread::WaitForNotRunning( DWORD dwMilliseconds, PBOOL pfFinished)
{
    BOOL retVal = FALSE;
    BOOL result;

    if( NULL == _hThread)
    {
        result = TRUE;
    }
    else
    {
        DWORD dwWaitResult;

        dwWaitResult = WaitForSingleObject( _hThread, dwMilliseconds);

        if( dwWaitResult == WAIT_OBJECT_0)
            result = TRUE;
        else if ( dwWaitResult == WAIT_TIMEOUT)
            result = FALSE;
        else
        {
            DWORD dwError = GetLastError();
            goto doneCCancellableThreadWaitForComplete;
        }
    }

    retVal = TRUE;
    
doneCCancellableThreadWaitForComplete:
    if( retVal == TRUE && pfFinished != NULL)
        *pfFinished = result;

    return retVal;
}


BOOL CCancellableThread::WaitForCancel( DWORD dwMilliseconds, PBOOL pfCanceled)
{
    BOOL retVal = FALSE;
    BOOL result;

    if( NULL == _hCancelEvent)
    {
        result = FALSE;
    }
    else
    {
        DWORD dwWaitResult;

        dwWaitResult = WaitForSingleObject( _hCancelEvent, dwMilliseconds);

        if( dwWaitResult == WAIT_OBJECT_0)
            result = TRUE;
        else if ( dwWaitResult == WAIT_TIMEOUT)
            result = FALSE;
        else
        {
            DWORD dwError = GetLastError();
            goto doneCCancellableThreadWaitForComplete;
        }
    }

    retVal = TRUE;
    
doneCCancellableThreadWaitForComplete:
    if( retVal == TRUE && pfCanceled != NULL)
        *pfCanceled = result;

    return retVal;
}


BOOL CCancellableThread::Run()
{
    BOOL retVal = FALSE;
    DWORD dw;

    if( _hThread != NULL)
        goto doneCCancellableThreadRun;

    if( NULL == (_hThread = CreateThread( NULL, 0, threadProc, (LPVOID)this, 0, &dw)))
        goto doneCCancellableThreadRun;

    retVal = TRUE;

doneCCancellableThreadRun:
    return retVal;
}


BOOL CCancellableThread::NotifyCancel()
{
    if( !_hCancelEvent) 
        return FALSE;
    
    if( 0 == SetEvent( _hCancelEvent))
        return FALSE;

    return TRUE;
}


DWORD WINAPI CCancellableThread::threadProc( LPVOID lpParameter)
{
    PCCancellableThread pThis = (PCCancellableThread)lpParameter;
    
    if( FAILED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
        goto doneCCancellableThreadThreadProc;

    pThis->_dwThreadResult = ((CCancellableThread*)lpParameter)->run();

    CoUninitialize();

    pThis->_fIsFinished = TRUE;
    
doneCCancellableThreadThreadProc:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shvocx.h ===
#ifndef __SHVOCX_H__
#define __SHVOCX_H__

#include "shocx.h"
#include "basesb.h"
#include "sfview.h"
#include "util.h" // for BSTR functions
#include "cobjsafe.h"
#include "ipstg.h"
#include "fldset.h"

class CWebBrowserOC;

#define CS_BACK 0x0001
#define CS_FORE 0x0002

#define AUTOSIZE_OFF            0x00000000L
#define AUTOSIZE_ON             0x00000001L

#define AUTOSIZE_PERCENTWIDTH   0x00000002L
#define AUTOSIZE_FULLSIZE       0x00000004L

#define VB_CLASSNAME_LENGTH 20            

//
// NOTES:
//
//  A CWebBrowserSB object is ALWAYS paired with CWebBrowserOC, and bahaves
// as a "ShellExplorer" OC together. CWebBrowserOC exports OLE control
// interfaces and an OLE automation interface (IWebBrowser) to the
// container. CWebBrowserSB exports IShellBrowser interface and a few other
// interfaces to the containee (IShellView object and DocObject).
//
//  It's important to know that those objects have pointers (not interface
// pointers but explicit object pointers) to each other. In order to avoid
// a circular reference, we don't AddRef to the pointer to CWebBrowserOC
// (_psvo).
//
class CWebBrowserSB : public CBASEBROWSER
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef() { return CBASEBROWSER::AddRef(); };
    STDMETHODIMP_(ULONG) Release() { return CBASEBROWSER::Release(); };

    // IOleInPlaceUIWindow (also IOleWindow)
    STDMETHODIMP EnableModelessSB(BOOL fEnable);
    STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);
    STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv);

    // IBrowserService
    STDMETHODIMP GetParentSite(struct IOleInPlaceSite** ppipsite);
    STDMETHODIMP GetOleObject(struct IOleObject** ppobjv);
    STDMETHODIMP SetNavigateState(BNSTATE bnstate);
    STDMETHODIMP_(LRESULT) WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    STDMETHODIMP ReleaseShellView();
    STDMETHODIMP ActivatePendingView();
    STDMETHODIMP SetTopBrowser();
    STDMETHODIMP GetFolderSetData(struct tagFolderSetData* pfsd) { /* we modify base directly */ return S_OK; };
    STDMETHODIMP _SwitchActivationNow();

    // IShellBrowser
    STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    HRESULT QueryServiceItsOwn(REFGUID guidService, REFIID riid, void **ppvObj)
        { return CBASEBROWSER::QueryService(guidService, riid, ppvObj); }

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    CWebBrowserSB(IUnknown* pauto, CWebBrowserOC* psvo);

    void ReleaseShellExplorer(void) { _psvo = NULL; } // NOTE: Note that we haven't AddRef'ed it.
    
    IShellView* GetShellView() { return _bbd._psv;};

    // Load/Save to be called by CWebBrowserOC's IPS::Save
    HRESULT Load(IStream *pStm);
    HRESULT Save(IStream *pStm /*, BOOL fClearDirty */);

protected:

    ~CWebBrowserSB();

    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void    _ViewChange(DWORD dwAspect, LONG lindex);

    //ViewStateStream related
    STDMETHODIMP_(IStream*) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName);
    
    // se DIRECTION_ flags below
    HRESULT _EnableModeless(BOOL fEnable, BOOL fDirection);
    HRESULT _TranslateAccelerator(LPMSG lpmsg, WORD wID, BOOL fDirection);
    HRESULT _IncludeByPidl(struct IShellView *psv, LPCITEMIDLIST pidl);
    HRESULT _IncludeByName(struct IShellView *psv, LPCTSTR pszInclude, LPCTSTR pszExclude);
    HRESULT _QueryServiceParent(REFGUID guidService, REFIID riid, void **ppvObj);

    BOOL    _IsDesktopOC(void);

    virtual BOOL    _HeyMoe_IsWiseGuy(void);


    friend CWebBrowserOC;
    CWebBrowserOC* _psvo;

    long _cbScriptNesting;
};


#define DIRECTION_FORWARD_TO_CHILD  FALSE
#define DIRECTION_FORWARD_TO_PARENT TRUE

class CWebBrowserOC : public CShellOcx
                    , public IWebBrowser2      // wrapped _pauto
                    , public CImpIExpDispSupport   // wrapped _pauto
                    , public IExpDispSupportOC
                    , public IPersistString
                    , public IOleCommandTarget
                    , public CObjectSafety
                    , public ITargetEmbedding
                    , public CImpIPersistStorage
                    , public IPersistHistory
{
public:
    // IUnknown (we multiply inherit from IUnknown, disambiguate here)
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) { return CShellOcx::QueryInterface(riid, ppvObj); }
    STDMETHOD_(ULONG, AddRef)() { return CShellOcx::AddRef(); }
    STDMETHOD_(ULONG, Release)() { return CShellOcx::Release(); }

    // IDispatch (we multiply inherit from IDispatch, disambiguate here)
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { return CShellOcx::GetTypeInfoCount(pctinfo); }
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CShellOcx::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CShellOcx::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgdispid); }
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // IPersistXXX disambiguate here
    STDMETHODIMP IsDirty(void) {return CShellOcx::IsDirty();}

    // IOleCommandTarget
    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHOD(Exec)(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IObjectSafety
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);

    // IWebBrowser
    STDMETHOD(GoBack)();
    STDMETHOD(GoForward)();
    STDMETHOD(GoHome)();
    STDMETHOD(GoSearch)();
    STDMETHOD(Navigate)(BSTR URL, VARIANT *Flags, VARIANT *TargetFrameName, VARIANT *PostData, VARIANT *Headers);
    STDMETHOD(Refresh)();
    STDMETHOD(Refresh2)(VARIANT *Level);
    STDMETHOD(Stop)();
    STDMETHOD(get_Application)(IDispatch **ppDisp);
    STDMETHOD(get_Parent)(IDispatch **ppDisp);
    STDMETHOD(get_Container)(IDispatch **ppDisp);
    STDMETHOD(get_Document)(IDispatch **ppDisp);
    STDMETHOD(get_TopLevelContainer)(VARIANT_BOOL *pBool);
    STDMETHOD(get_Type)(BSTR * pbstrType);
    STDMETHOD(get_Left)(long * pl);
    STDMETHOD(put_Left)(long Left);
    STDMETHOD(get_Top)(long * pl);
    STDMETHOD(put_Top)(long Top);
    STDMETHOD(get_Width)(long * pl);
    STDMETHOD(put_Width)(long Width);
    STDMETHOD(get_Height)(long * pl);
    STDMETHOD(put_Height)(long Height);
    STDMETHOD(get_LocationName)(BSTR * pbstrLocationName);
    STDMETHOD(get_LocationURL)(BSTR * pbstrLocationURL);
    STDMETHOD(get_Busy)(VARIANT_BOOL * pBool);

    /* IWebBrowserApp methods */
    STDMETHOD(Quit)(THIS);
    STDMETHOD(ClientToWindow)(THIS_ int FAR* pcx, int FAR* pcy);
    STDMETHOD(PutProperty)(THIS_ BSTR szProperty, VARIANT vtValue);
    STDMETHOD(GetProperty)(THIS_ BSTR szProperty, VARIANT FAR* pvtValue);
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName);
    STDMETHOD(get_HWND)(THIS_ LONG_PTR* pHWND);
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* pbstrFullName);
    STDMETHOD(get_Path)(THIS_ BSTR FAR* pbstrPath);
    STDMETHOD(get_FullScreen)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_FullScreen)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_StatusBar)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_StatusBar)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_StatusText)(THIS_ BSTR FAR* pbstr);
    STDMETHOD(put_StatusText)(THIS_ BSTR bstr);
    STDMETHOD(get_ToolBar)(THIS_ int FAR* pBool);
    STDMETHOD(put_ToolBar)(THIS_ int Value);
    STDMETHOD(get_MenuBar)(THIS_ VARIANT_BOOL FAR* pValue);
    STDMETHOD(put_MenuBar)(THIS_ VARIANT_BOOL Value);

    // IWebBrowser2 methods
    STDMETHOD(Navigate2)(THIS_ VARIANT FAR* URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers);
    STDMETHOD(ShowBrowserBar)(THIS_ VARIANT FAR* pvaClsid, VARIANT FAR* pvaShow, VARIANT FAR* pvaSize);
    STDMETHOD(QueryStatusWB)(THIS_ OLECMDID cmdID, OLECMDF FAR* pcmdf);
    STDMETHOD(ExecWB)(THIS_ OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT FAR* pvaIn, VARIANT FAR* pvaOut);
    STDMETHOD(get_ReadyState)(THIS_ READYSTATE FAR* plReadyState);
    STDMETHOD(get_Offline)(THIS_ VARIANT_BOOL FAR* pbOffline);
    STDMETHOD(put_Offline)(THIS_ VARIANT_BOOL bOffline);
    STDMETHOD(get_Silent)(THIS_ VARIANT_BOOL FAR* pbSilent);
    STDMETHOD(put_Silent)(THIS_ VARIANT_BOOL bSilent);
    STDMETHOD(get_RegisterAsBrowser)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_RegisterAsBrowser)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_RegisterAsDropTarget)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_RegisterAsDropTarget)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_TheaterMode)(THIS_ VARIANT_BOOL FAR* pValue);
    STDMETHOD(put_TheaterMode)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_AddressBar)(THIS_ VARIANT_BOOL FAR* Value);
    STDMETHOD(put_AddressBar)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_Resizable)(THIS_ VARIANT_BOOL FAR* Value) { return E_NOTIMPL; }
    STDMETHOD(put_Resizable)(THIS_ VARIANT_BOOL Value);

    // *** CImpIExpDispSupport override ***
    STDMETHODIMP OnTranslateAccelerator(MSG *pMsg,DWORD grfModifiers);
    STDMETHODIMP OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                        VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr);

    // *** IExpDispSupportOC ***
    STDMETHODIMP OnOnControlInfoChanged();
    STDMETHODIMP GetDoVerbMSG(MSG *pMsg);


    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID) { return CShellOcx::GetClassID(pClassID); }

    // IPersistString
    STDMETHOD(Initialize)(LPCWSTR pwszInit);

    // ITargetEmbedding
    STDMETHOD(GetTargetFrame)(ITargetFrame **ppTargetFrame);

    // IPersistStreamInit
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(InitNew)(void);

    // IPersistPropertyBag
    STDMETHOD(Load)(IPropertyBag *pBag, IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag *pBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // IOleObject
    STDMETHODIMP Close(DWORD dwSaveOption);
    STDMETHODIMP DoVerb(
        LONG iVerb,
        LPMSG lpmsg,
        IOleClientSite *pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect);
    STDMETHODIMP SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);

    // IViewObject2
    STDMETHODIMP Draw(
        DWORD dwDrawAspect,
        LONG lindex,
        void *pvAspect,
        DVTARGETDEVICE *ptd,
        HDC hdcTargetDev,
        HDC hdcDraw,
        LPCRECTL lprcBounds,
        LPCRECTL lprcWBounds,
        BOOL ( __stdcall *pfnContinue )(ULONG_PTR dwContinue),
        ULONG_PTR dwContinue);

    STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *,
        HDC, LOGPALETTE **);

    virtual HRESULT STDMETHODCALLTYPE SetExtent( DWORD dwDrawAspect,
            SIZEL *psizel);
            
    // IOleControl
    STDMETHODIMP GetControlInfo(LPCONTROLINFO pCI);
    STDMETHODIMP OnMnemonic(LPMSG pMsg);
    STDMETHODIMP OnAmbientPropertyChange(DISPID dispid);
    STDMETHODIMP FreezeEvents(BOOL bFreeze);

    // IOleInPlaceActiveObject
    virtual HRESULT __stdcall OnFrameWindowActivate(BOOL fActivate);
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg);
    STDMETHODIMP EnableModeless(BOOL fEnable);

    // *** CShellOcx's CImpIConnectionPointContainer override ***
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum);

    // *** IPersistHistory
    STDMETHODIMP LoadHistory(IStream *pStream, IBindCtx *pbc);
    STDMETHODIMP SaveHistory(IStream *pStream);
    STDMETHODIMP SetPositionCookie(DWORD dwPositionCookie);
    STDMETHODIMP GetPositionCookie(DWORD *pdwPositioncookie);

    // random public functions
    friend HRESULT CWebBrowserOC_SavePersistData(IStream *pstm, SIZE* psizeObj,
        FOLDERSETTINGS* pfs, IShellLinkA* plink, SHELLVIEWID* pvid,
        BOOL fOffline = FALSE, BOOL fSilent = FALSE,
        BOOL fRegisterAsBrowser = FALSE, BOOL fRegisterAsDropTarget = TRUE,
        BOOL fEmulateOldStream = FALSE, DWORD * pdwExtra = NULL);


protected:
    CWebBrowserOC(IUnknown* punkOuter, LPCOBJECTINFO poi);
    ~CWebBrowserOC();
    BOOL _InitializeOC(IUnknown* punkOuter);
    IUnknown* _GetInner() { return CShellOcx::_GetInner(); }
    friend HRESULT CWebBrowserOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    // Override private virtual function
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj);
    virtual void _OnSetClientSite(void);
    virtual HRESULT _OnActivateChange(IOleClientSite* pActiveSite, UINT uState);
    virtual void _OnInPlaceActivate(void);
    virtual void _OnInPlaceDeactivate(void);
    virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid);

    // Private non-virtual
    LRESULT _OnPaintPrint(HDC hdcPrint);
    LRESULT _OnCreate(LPCREATESTRUCT lpcs);
    HRESULT _BrowseObject(LPCITEMIDLIST pidlBrowseTo);
    void    _InitDefault(void);
    void    _OnSetShellView(IShellView*);
    void    _OnReleaseShellView(void);
    BOOL    _GetViewInfo(SHELLVIEWID* pvid);
    void    _RegisterWindow();
    void    _UnregisterWindow();
    HRESULT _SetDownloadState(HRESULT hresRet, DWORD nCmdexecopt, VARIANTARG *pvarargIn);
    void    _OnLoaded(BOOL fUpdateBrowserReadyState);
    HMODULE _GetBrowseUI();
    BOOL    _HeyMoe_IsWiseGuy(void) {return _fHostedInImagineer;}
    void    _OnSetSecureLockIcon(int lock);
    BOOL    AccessAllowedToNamedFrame(VARIANT *varTargetFrameName);

    static LRESULT CALLBACK s_DVWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    IUnknown*       _pauto; // we aggregate this and pass it to the shellbrowser
    IWebBrowser2*   _pautoWB2;
    IExpDispSupport*_pautoEDS;

    BOOL            _fInit:1;               // TRUE iff we are initialized
    BOOL            _fEmulateOldStream:1;   // TRUE iff we emulate ie30 stream format
    BOOL            _fNavigateOnSetClientSite:1; // set when Loaded before SetClientSite
    BOOL            _fShouldRegisterAsBrowser:1; // TRUE iff OC should be registered in windows list
    BOOL            _fDidRegisterAsBrowser:1;    // TRUE iff registered in windows list
    BOOL            _fTopLevel:1;           // TRUE iff we're the topmost CBaseBrowser around
    BOOL            _fVisible:1;            // BETA1: bindable props of the OC that we can't
    BOOL            _fNoMenuBar:1;          //        call IEDisp's version of the props.
    BOOL            _fNoToolBar:1;          //        for beta2 we should let us call
    BOOL            _fNoStatusBar:1;        //        iedisp's version to get the events
    BOOL            _fFullScreen:1;         //        to fire and persistence correct.
    BOOL            _fTheaterMode:1;
    BOOL            _fNoAddressBar:1;
    BOOL            _fHostedInVB5:1;        // Our immediate container is the VB5 forms engine.
    BOOL            _fHostedInImagineer:1;  // 
    BOOL            _fIncrementedSessionCount:1;  // We incremented session count and need to decrement it
    BOOL            _fInsideInvokeCall;     // Currently processing an invoke call

    MSG             *_pmsgDoVerb;        // valid only when _fDoVerbMSGValid
    
    long            _cbCookie;              // our cookie for registering in windows list
    SIZE            _szIdeal;       // ideal size of view, based on _size.cx
    SIZE            _szNotify;      // last size we notified conainer

    FOLDERSETTINGS  _fs;            // FolderViewMode and FolderFlags

    // cached draw aspect incase we are not READSTATE_INTERACTIVE when we get SetExtent
    DWORD           _dwDrawAspect;
    
    friend CWebBrowserSB;
    CWebBrowserSB*      _psb;
    ITargetFramePriv*   _pTargetFramePriv;  // QueryService(IID_ITARGETFRAME2)

    IShellLinkA*        _plinkA;        // used in save/load code only

    IOleCommandTarget*  _pctContainer;  // container

    HGLOBAL             _hmemSB;        // Initializing stream

    CConnectionPoint    m_cpWB1Events;  // CShellOcx holds the WB2 event source
    LPMESSAGEFILTER     _lpMF;          // Pointer to message filter for cross-thread containers (e.g., AOL)

    HMODULE             _hBrowseUI;     // Handle for use in design mode brand drawing

    DWORD               _cPendingFreezeEvents;
};

#define IS_INITIALIZED if(!_fInit){TraceMsg(TF_WARNING,"shvocx: BOGUS CONTAINER calling when we haven't been initialized"); _InitDefault();}

#endif // __SHVOCX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\smallutil.hpp ===
#ifndef _SMALLUTIL_H_
#define _SMALLUTIL_H_



//  CCancellableThread
//
//  Lets you define a thread object that can be cancelled by the creator.
//To implement the thread, derivce from CCancellableThread and override the
//run() function.  run() will be ran in its own thread, and the value returned
//by run can be accessed by GetResult().  run() should check IsCancelled()
//at appropriate intervals and exit early if true.
//  Clients of the cancellable thread then create the object, and execute Run()
//when ready.  If they wish to cancel, they can call NotifyCancel().

typedef class CCancellableThread
{
private:
    HANDLE _hCancelEvent;
    HANDLE _hThread;

    static DWORD WINAPI threadProc( LPVOID lpParameter);

    BOOL _fIsFinished;
    DWORD _dwThreadResult;
    
public:
    CCancellableThread();
    ~CCancellableThread();

    virtual BOOL Initialize();

    BOOL IsCancelled();
    BOOL IsRunning();
    BOOL IsFinished();
    BOOL GetResult( PDWORD pdwResult);

    BOOL Run();
    BOOL NotifyCancel();
    BOOL WaitForNotRunning( DWORD dwMilliseconds, PBOOL pfFinished = NULL);
    BOOL WaitForCancel( DWORD dwMilliseconds, PBOOL pfCancelled = NULL);

protected:
    virtual DWORD run() = 0;
}*PCCancellableThread;



//  CQueueSortOf - a queue(sort of) used to store stuff
//in a renumerable way..

class CQueueSortOf
{
  //  This sort-of-queue is just a data structure to build up a list of items
  //(always adding to the end) and then be able to enumerate that list
  //repeatedly from start to end.
  //  The list does not own any of the objects added to it..
    typedef struct SEntry
    {
        SEntry* pNext;
        void* data;
    } *PSEntry;

    PSEntry m_pHead, m_pTail;

public:
    CQueueSortOf()
    {
        m_pHead = NULL;
        m_pTail = NULL;
    }

    ~CQueueSortOf()
    {
        while( m_pHead != NULL)
        {
            PSEntry temp = m_pHead;
            m_pHead = m_pHead->pNext;
            delete temp;
        }
    }

    bool InsertAtEnd( void* newElement)
    {
        PSEntry pNewEntry = new SEntry;

        if( pNewEntry == NULL)
            return false;

        pNewEntry->data = newElement;
        pNewEntry->pNext = NULL;

        if( m_pHead == NULL)
        {
            m_pHead = m_pTail = pNewEntry;
        }
        else
        {
            m_pTail->pNext = pNewEntry;
            m_pTail = pNewEntry;
        }

        return true;
    }

    // enumerations are managed by an 'iterator' which simply a void pointer into
    //the list.  To start an enumeration, pass NULL as the iterator.  The end
    //of enumeration will be indicated by a NULL iterator being returned.
    void* StepEnumerate( void* iterator)
    {
        return (iterator == NULL) ? m_pHead : ((PSEntry)iterator)->pNext;
    }

    void* Get( void* iterator)
    {
        return ((PSEntry)iterator)->data;
    }
};


//  CGrowingString is a simple utility class that allows you to create
//a string and append to it without worrying about reallocating memory
//every time.

class CGrowingString
{
public:
    WCHAR* m_szString;
    long m_iBufferSize;
    long m_iStringLength;

    CGrowingString()
    {
        m_szString = NULL;
        m_iBufferSize = 0;
        m_iStringLength = 0;
    }

    ~CGrowingString()
    {
        delete[] m_szString;
    }

    BOOL AppendToString( LPCWSTR pszNew)
    {
        long iLength = lstrlen( pszNew);

        if( m_szString == NULL
            || m_iStringLength + iLength + 1 > m_iBufferSize)
        {
            long iNewSize = max(1024, m_iStringLength + iLength * 10);
            WCHAR* pNewBuffer = new WCHAR[iNewSize];
            if( pNewBuffer == NULL)
                return FALSE;
            if( m_szString == NULL)
            {
                m_szString = pNewBuffer;
                m_iBufferSize = iNewSize;
            }
            else
            {
                StrCpyNW( pNewBuffer, m_szString, m_iStringLength + 1);
                delete[] m_szString;
                m_szString = pNewBuffer;
                m_iBufferSize = iNewSize;
            }
        }

        StrCpyNW( m_szString + m_iStringLength, pszNew, iLength+1);
        m_iStringLength += iLength;
        m_szString[m_iStringLength] = L'\0';
        return TRUE;
    }
};


//****************************************************
//
//  FileOutputStream - retrofitted for WCHAR
//     from wininet\cookexp.cpp

class CFileOutputStream
{
public:
    CFileOutputStream()
    {
        m_hFile = INVALID_HANDLE_VALUE;
        m_fError = FALSE;
        m_dwLastError = 0;
    }

    ~CFileOutputStream()
    {
        if( m_hFile != INVALID_HANDLE_VALUE)
            CloseHandle( m_hFile);
    }

    BOOL Load( LPCWSTR szFilename, BOOL fAppend)
    {
        m_hFile = CreateFile( szFilename, GENERIC_WRITE | GENERIC_READ, 0, NULL, 
                              fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);

        if( m_hFile == INVALID_HANDLE_VALUE)
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }

        if( fAppend
            && SetFilePointer( m_hFile, 0, NULL, FILE_END) == 0xFFFFFFFF)
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }

        return TRUE;
    }

    BOOL DumpStr( const CHAR* szString, DWORD cLength)
    {
        DWORD dwTemp;

        if( m_fError == TRUE)
            return FALSE;
        
        if( WriteFile( m_hFile, szString, cLength, &dwTemp, NULL) == TRUE)
        {
            return TRUE;
        }
        else
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }
    }
    
    BOOL WriteNewline()
    {
        static const LPCSTR szNewLine = "\r\n";
        return DumpStr( szNewLine, sizeof( szNewLine) - 1);
    }

    BOOL IsError()
    {
        return m_fError;
    }

private:
    HANDLE m_hFile;
    BOOL m_fError;
    DWORD m_dwLastError;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shocx.h ===
#ifndef __SHOCX_H__
#define __SHOCX_H__

#include "cnctnpt.h"
#include "dspsprt.h"
#include "expdsprt.h"

//
// shocx.h
//

#define _INTERFACEOFOBJECT      1
#define _CLSIDOFOBJECT          2

class CShellOcx: public CShellEmbedding,        // IOleObject, IOleInPlacceObject, IOleInPlaceActiveObject,
                                                // IViewObject2, IPersistStorage
                 public IPersistStreamInit,
                 public IPersistPropertyBag,
                 public IOleControl,            // OnAmbientPropertyChange
                 public IDispatch,
                 public IProvideClassInfo2,
                 protected CImpIConnectionPointContainer,
                 protected CImpIDispatch
{
public:
    // *** IUnknown *** (we multiply inherit from IUnknown, disambiguate here)
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)
        { return CShellEmbedding::QueryInterface(riid, ppvObj); }
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return CShellEmbedding::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CShellEmbedding::Release(); }

    // *** IPersistStreamInit ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) {return CShellEmbedding::GetClassID(pClassID);} // IPersistStorage implementation
    virtual STDMETHODIMP IsDirty(void) {return _fDirty ? S_OK : S_FALSE;}
    virtual STDMETHODIMP Load(IStream *pStm) PURE;
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) PURE;
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
    virtual STDMETHODIMP InitNew(void) PURE;

    // *** IPersistPropertyBag ***
    virtual STDMETHODIMP Load(IPropertyBag *pBag, IErrorLog *pErrorLog) PURE;
    virtual STDMETHODIMP Save(IPropertyBag *pBag, BOOL fClearDirty, BOOL fSaveAllProperties) PURE;

    // *** IOleControl ***
    virtual STDMETHODIMP GetControlInfo(LPCONTROLINFO pCI);
    virtual STDMETHODIMP OnMnemonic(LPMSG pMsg);
    virtual STDMETHODIMP OnAmbientPropertyChange(DISPID dispid);
    virtual STDMETHODIMP FreezeEvents(BOOL bFreeze);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames, LCID lcid, DISPID FAR* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // *** CImpIConnectionPointContainer ***
    virtual STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum);

    // *** IProvideClassInfo2 ***
    virtual STDMETHODIMP GetClassInfo(LPTYPEINFO * ppTI);
    virtual STDMETHODIMP GetGUID(DWORD dwGuidKind, GUID *pGUID);

    // IPropertyNotifySink stuff.
    //
    inline void  PropertyChanged(DISPID dispid) {
        m_cpPropNotify.OnChanged(dispid);
    }

    /*
    ** CShellEmbedding stuff
    */

    // *** IOleObject ***
    virtual STDMETHODIMP EnumVerbs(IEnumOLEVERB **ppEnumOleVerb);
    virtual STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // *** IViewObject ***
    virtual STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR);

    /*
    ** CShellOcx specific stuff
    */

    CShellOcx(IUnknown* punkOuter, LPCOBJECTINFO poi, const OLEVERB* pverbs=NULL, const OLEVERB* pdesignverbs=NULL);
    ~CShellOcx();

protected:

    // from CShellEmbedding
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid);

    ITypeInfo *_pClassTypeInfo; // ITypeInfo of class

    const OLEVERB* _pDesignVerbs;   // verb list for design mode -- run mode is in CShellEmbedding

    // Ambient Properties we care about
    IDispatch* _pDispAmbient;
    BOOL _GetAmbientProperty(DISPID dispid, VARTYPE vt, void *pData);
    int  _nDesignMode;          // MODE_UNKNOWN, MODE_TRUE, MODE_FALSE
    BOOL _IsDesignMode(void);   // TRUE means we have a design-mode container

    BOOL _fEventsFrozen:1;


    CConnectionPoint m_cpEvents;
    CConnectionPoint m_cpPropNotify;
} ;

// _nDesignMode,etc flags
#define MODE_UNKNOWN -1      // mode has not yet been determined
#define MODE_TRUE    1
#define MODE_FALSE   0

// CConnectionPoint types:
#define SINK_TYPE_EVENT      0
#define SINK_TYPE_PROPNOTIFY 1

#endif // __SHOCX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shocx.cpp ===
// builds an ocx out of the embedding in shembed.c

#include "priv.h"
#include "sccls.h"
#include "olectl.h"
#include "stdenum.h"
#include "shocx.h"
#include "resource.h"

LCID g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

#define SUPERCLASS CShellEmbedding

CShellOcx::CShellOcx(IUnknown* punkOuter, LPCOBJECTINFO poi, const OLEVERB* pverbs, const OLEVERB* pdesignverbs) :
                        CShellEmbedding(punkOuter, poi, pverbs),
                        _pDesignVerbs(pdesignverbs),
                        CImpIDispatch(LIBID_SHDocVw, 1, 1, *(poi->piid))
{
    // CShellEmbedding class handles the DllAddRef / DllRelease

    m_cpEvents.SetOwner(_GetInner(), poi->piidEvents);
    m_cpPropNotify.SetOwner(_GetInner(), &IID_IPropertyNotifySink);

    _nDesignMode = MODE_UNKNOWN;
}

CShellOcx::~CShellOcx()
{
    // Should have been released when cllient site was set to NULL.... Don't release
    // it here as this will cause some applications like VC5 to fault...
    ASSERT(_pDispAmbient==NULL);

    if (_pClassTypeInfo)
        _pClassTypeInfo->Release();
}

//
// We have a different set of verbs in design mode
//
HRESULT CShellOcx::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    TraceMsg(TF_SHDCONTROL, "sho: EnumVerbs");

    if (_IsDesignMode())
    {
        *ppEnumOleVerb = new CSVVerb(_pDesignVerbs);
        if (*ppEnumOleVerb)
            return S_OK;
    }

    return SUPERCLASS::EnumVerbs(ppEnumOleVerb);
}


//
// For the interfaces we support here
//
HRESULT CShellOcx::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellOcx, IDispatch),
        QITABENT(CShellOcx, IOleControl),
        QITABENT(CShellOcx, IConnectionPointContainer),
        QITABENT(CShellOcx, IPersistStreamInit),
        QITABENTMULTI(CShellOcx, IPersistStream, IPersistStreamInit),
        QITABENT(CShellOcx, IPersistPropertyBag),
        QITABENT(CShellOcx, IProvideClassInfo2),
        QITABENTMULTI(CShellOcx, IProvideClassInfo, IProvideClassInfo2),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
        hr = SUPERCLASS::v_InternalQueryInterface(riid, ppvObj);
    return hr;
}

//
// On a SetClientSite, we need to discard everything created from _pcli
// because shembed frees _pcli
//
HRESULT CShellOcx::SetClientSite(IOleClientSite *pClientSite)
{
    if (_pDispAmbient)
    {
        _pDispAmbient->Release();
        _pDispAmbient = NULL;
    }

    return SUPERCLASS::SetClientSite(pClientSite);
}


HRESULT CShellOcx::Draw(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL ( __stdcall *pfnContinue )(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    if (_IsDesignMode())
    {
        HBRUSH hbrOld = (HBRUSH)SelectObject(hdcDraw, (HBRUSH)GetStockObject(WHITE_BRUSH));
        HPEN hpenOld = (HPEN)SelectObject(hdcDraw, (HPEN)GetStockObject(BLACK_PEN));
        Rectangle(hdcDraw, lprcBounds->left, lprcBounds->top, lprcBounds->right, lprcBounds->bottom);
        MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->top, NULL);
        LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom);
        MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->bottom, NULL);
        LineTo(hdcDraw, lprcBounds->right, lprcBounds->top);
        SelectObject(hdcDraw, hbrOld);
        SelectObject(hdcDraw, hpenOld);
        return S_OK;
    }

    return SUPERCLASS::Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw,
                            lprcBounds, lprcWBounds, pfnContinue, dwContinue);
}


// IPersistStream

HRESULT CShellOcx::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    // REVIEW: this is overly large, I believe E_NOTIMPL is a valid
    // return from this and it tells the container that we don't know how big we are.

    ULARGE_INTEGER cbMax = { 1028 * 8, 0 }; // isn't this overly large?
    *pcbSize = cbMax;
    return S_OK;
}

// IOleControl
STDMETHODIMP CShellOcx::GetControlInfo(LPCONTROLINFO pCI)
{
    return E_NOTIMPL; // for mnemonics
}
STDMETHODIMP CShellOcx::OnMnemonic(LPMSG pMsg)
{
    return E_NOTIMPL; // for mnemonics
}
STDMETHODIMP CShellOcx::OnAmbientPropertyChange(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_AMBIENT_USERMODE:           // design mode  vs  run mode
    case DISPID_UNKNOWN:
        _nDesignMode = MODE_UNKNOWN;
        break;
    }

    return S_OK;
}

STDMETHODIMP CShellOcx::FreezeEvents(BOOL bFreeze)
{
    _fEventsFrozen = bFreeze;
    return S_OK;
}

HRESULT CShellOcx::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    // This is gross, for some reason from VBScript in a page can not get "Document" through so try "Doc" and map
    HRESULT hres = CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (FAILED(hres) && (cNames == 1) && rgszNames)
    {
        OLECHAR const *c_pwszDocument = L"Document";

        if (StrCmpIW(*rgszNames, L"Doc") == 0)
            hres = CImpIDispatch::GetIDsOfNames(riid, (OLECHAR**)&c_pwszDocument, cNames, lcid, rgdispid);
    }
    return hres;
}


// ConnectionPointContainer
CConnectionPoint* CShellOcx::_FindCConnectionPointNoRef(BOOL fdisp, REFIID iid)
{
    CConnectionPoint* pccp;

    if (IsEqualIID(iid, EVENTIIDOFCONTROL(this)) ||
        (fdisp && IsEqualIID(iid, IID_IDispatch)))
    {
        pccp = &m_cpEvents;
    }
    else if (IsEqualIID(iid, IID_IPropertyNotifySink))
    {
        pccp = &m_cpPropNotify;
    }
    else
    {
        pccp = NULL;
    }

    return pccp;
}

STDMETHODIMP CShellOcx::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 2,
            m_cpEvents.CastToIConnectionPoint(),
            m_cpPropNotify.CastToIConnectionPoint());
}

// IProvideClassInfo2
STDMETHODIMP CShellOcx::GetClassInfo(LPTYPEINFO * ppTI)
{
    if (!_pClassTypeInfo) 
        GetTypeInfoFromLibId(LANGIDFROMLCID(g_lcidLocale),
            LIBID_SHDocVw, 1, 1, CLSIDOFOBJECT(this), &_pClassTypeInfo);

    if (_pClassTypeInfo) 
    {
        _pClassTypeInfo->AddRef();
        *ppTI = _pClassTypeInfo;
        return S_OK;
    }

    ppTI = NULL;
    return E_FAIL;
}

// IProvideClassInfo2

STDMETHODIMP CShellOcx::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    if (pGUID == NULL)
        return E_POINTER;
    
    if ( (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
        && _pObjectInfo->piidEvents)
    {
        *pGUID = EVENTIIDOFCONTROL(this);
        return S_OK;
    }
    *pGUID = GUID_NULL;
    return E_FAIL;
}
 
// returns TRUE iff MODE_DESIGN

BOOL CShellOcx::_IsDesignMode(void)
{
    if (_nDesignMode == MODE_UNKNOWN)
    {
        VARIANT_BOOL fBool;

        if (_GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &fBool))
        {
            _nDesignMode = fBool ? MODE_FALSE : MODE_TRUE;
        }
        else
            _nDesignMode = MODE_FALSE;
    }
    return _nDesignMode == MODE_TRUE;
}

// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type
//
const BYTE g_rgcbDataTypeSize[] = {
    0,                      // VT_EMPTY = 0,
    0,                      // VT_NULL = 1,
    sizeof(short),          // VT_I2 = 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(float),          // VT_R4 = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH = 9,
    sizeof(SCODE),          // VT_ERROR = 10,
    sizeof(VARIANT_BOOL),   // VT_BOOL = 11,
    sizeof(VARIANT),        // VT_VARIANT = 12,
    sizeof(IUnknown *),     // VT_UNKNOWN = 13,
};


// returns the value of an ambient property
//
// Parameters:
//    DISPID        - [in]  property to get
//    VARTYPE       - [in]  type of desired data
//    void *        - [out] where to put the data
//
// Output:
//    BOOL          - FALSE means didn't work.
//
// Notes:
//
BOOL CShellOcx::_GetAmbientProperty(DISPID dispid, VARTYPE vt, void *pData)
{
    // IE30's WebBrowser OC never requested ambient properties.
    // IE40's does and we're finding that apps implemented some of
    // the properties we care about incorrectly. Assume old classid
    // means this is an old app and fail. The code that calls this
    // is smart enough to deal with failure.
    //
    if (_pObjectInfo->pclsid == &CLSID_WebBrowser_V1)
        return FALSE;

    HRESULT hr = E_FAIL;

    if (!_pDispAmbient && _pcli)
        _pcli->QueryInterface(IID_PPV_ARG(IDispatch, &_pDispAmbient));

    if (_pDispAmbient)
    {
        DISPPARAMS dispparams = {0};
        VARIANT v;
        VariantInit(&v);
        hr = _pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams, &v, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            VARIANT vDest;
            VariantInit(&vDest);
            // we've got the variant, so now go an coerce it to the type
            // that the user wants.
            //
            hr = VariantChangeType(&vDest, &v, 0, vt);
            if (SUCCEEDED(hr))
            {
                // copy the data to where the user wants it
                //
                CopyMemory(pData, &vDest.lVal, g_rgcbDataTypeSize[vt]);
                VariantClear(&vDest);
            }
            VariantClear(&v);
        }
    }
    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\splash.cpp ===
/* Copyright 1997 Microsoft */

#include "priv.h"
#include "resource.h"

#include <mluisupp.h>

#define TIMER_TIMEOUT      1
#define SPLASHWM_DISMISS    WM_USER

////////////////////////////////////////////////////////////////////////////
//
//  InitLF -- modified from comdlg32\fonts.c, used by ShowSplashScreen
//
//  Initalize a LOGFONT structure to some base generic regular type font.
//
////////////////////////////////////////////////////////////////////////////

VOID InitLF(
    HDC hdc,
    LPLOGFONT lplf)
{
    TEXTMETRIC tm;

    lplf->lfEscapement = 0;
    lplf->lfOrientation = 0;
    lplf->lfOutPrecision = OUT_DEFAULT_PRECIS;
    lplf->lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lplf->lfQuality = DEFAULT_QUALITY;
    lplf->lfPitchAndFamily = DEFAULT_PITCH;
    lplf->lfItalic = 0;
    lplf->lfWeight = FW_NORMAL;
    lplf->lfStrikeOut = 0;
    lplf->lfUnderline = 0;
    lplf->lfWidth = 0;            // otherwise we get independant x-y scaling

    GetTextMetrics(hdc, &tm);   // get the current textmetrics
    lplf->lfCharSet = tm.tmCharSet;

    lplf->lfFaceName[0] = 0;
    MLLoadString(IDS_SPLASH_FONT, lplf->lfFaceName, ARRAYSIZE(lplf->lfFaceName));

    TCHAR szTmp[16];
    MLLoadString(IDS_SPLASH_SIZE, szTmp, ARRAYSIZE(szTmp));
    lplf->lfHeight = StrToInt(szTmp);
}

BOOL g_fShown = FALSE;

class CIESplashScreen : public ISplashScreen
{
protected:
    HBITMAP  _hbmSplash;     // The bitmap to display.
    HBITMAP  _hbmOld;
    HDC      _hdc;
    HWND     _hwnd;
    LONG     _cRef;

public:
    CIESplashScreen( HRESULT * pHr );
    ~CIESplashScreen();

    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef) ( THIS );
    STDMETHOD_(ULONG, Release) ( THIS );

    STDMETHOD ( Show ) ( HINSTANCE hinst, UINT idResHi, UINT idResLow, HWND * phwshnd );
    STDMETHOD ( Dismiss ) ( void );
    
    static LRESULT s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL _RegisterWindowClass(void);
    HWND ShowSplashScreen(HINSTANCE hinst, UINT idResHi, UINT idResLow);

};


CIESplashScreen::CIESplashScreen(HRESULT * pHr) : _cRef (1)
{
    DllAddRef();
    *pHr = NOERROR;
}

CIESplashScreen::~CIESplashScreen()
{
    if (_hdc)
    {
        // select the previous hbm we got when we put the splash in there,
        // so that we can now destroy the hbitmap
        SelectObject( _hdc, _hbmOld );
        DeleteObject(_hdc);
    }

    // destroy the hbitmpa, can only do this if we have deselected it above...
    if (_hbmSplash)
        DeleteObject(_hbmSplash);

    DllRelease();
}

STDMETHODIMP CIESplashScreen::QueryInterface (REFIID riid, void ** ppv)
{
    HRESULT hr = NOERROR;
    if ( IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ISplashScreen ))
    {
        *ppv = SAFECAST( this, ISplashScreen *);
        this->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CIESplashScreen::AddRef ( )
{
    _cRef ++;
    return _cRef;
}

STDMETHODIMP_(ULONG) CIESplashScreen::Release ( )
{
    _cRef --;
    if ( !_cRef )
    {
        delete this;
        return 0;
    }
    return _cRef;
}

STDMETHODIMP CIESplashScreen::Show ( HINSTANCE hinst, UINT idResHi, UINT idResLow, HWND * phwnd )
{
    if ( !phwnd )
    {
        return E_INVALIDARG;
    }
    
    // First thing to do is to see if see if browser or a splash screen up...
    if ( g_fShown )
        return NULL;
    
    *phwnd = ShowSplashScreen( hinst, idResHi, idResLow );
    
    return ( *phwnd ? NOERROR : E_UNEXPECTED );
}

STDMETHODIMP CIESplashScreen::Dismiss ( void )
{
    if ( _hwnd )
    {
        // Synchronously dismiss the splash screen then post a message to
        // destroy the window.
        SendMessage(_hwnd, SPLASHWM_DISMISS, 0, 0);
        PostMessage(_hwnd, WM_CLOSE, 0, 0);
    }
    return S_OK;
}

HWND CIESplashScreen::ShowSplashScreen( HINSTANCE hinst, UINT idResHi, UINT idResLow )
{
    // don't show splash screen for IE in intergrated mode or if it's been disabled 
    // by the admin
    if (
        ( (WhichPlatform() == PLATFORM_INTEGRATED) && (hinst == HINST_THISDLL) ) ||
        ( SHRestricted2(REST_NoSplash, NULL, 0) )
       )
    {
        return NULL;
    }
    
    if (!_RegisterWindowClass())
        return NULL;

    // provide default bitmap resource ID's for IE
    if (hinst == HINST_THISDLL)
    {
        if (idResHi == -1)
            idResHi = IDB_SPLASH_IEXPLORER_HI;
        if (idResLow == -1)
            idResLow = IDB_SPLASH_IEXPLORER;
    }
            
     // Now load the appropriate bitmap depending on colors, only use the 256 colour splash
     // if we are greater than 256 colours (such as 32K or 65K upwards), this will mean we don't have
     // to flash the palette just to put up the splash screen.
    _hbmSplash = (HBITMAP)LoadImage(hinst, MAKEINTRESOURCE((GetCurColorRes() > 8) ? idResHi : idResLow), 
                                    IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    _hdc = CreateCompatibleDC(NULL);
    
    if (!_hbmSplash || !_hdc)
        return NULL;

    // remember the old hbitmap so we can select it back before we delete the bitmap..
    _hbmOld = (HBITMAP) SelectObject(_hdc, _hbmSplash);

    // set font and color for text
    LOGFONT lf;
    HFONT   hfont;
    HFONT   hfontOld;
    
    InitLF(_hdc, &lf);
    hfont = CreateFontIndirect(&lf);
    if ( hfont == NULL ) // show the bitmap without text if we can't create the font
        goto Done;

    // select the new font and remember the old one
    hfontOld = (HFONT)SelectObject(_hdc, hfont);

    if (hfontOld)
    {
        SetTextColor(_hdc, RGB(0,0,0));
        SetBkColor(_hdc, RGB(255,255,255));
        SetBkMode(_hdc, TRANSPARENT);
    
        // draw the text on top of the selected bitmap
        TCHAR   szText[512], szY[32];
        RECT    rect;
    
        MLLoadString(IDS_SPLASH_Y1, szY, ARRAYSIZE(szY));
        MLLoadString(IDS_SPLASH_STR1, szText, ARRAYSIZE(szText));
        SetRect(&rect, 104, StrToInt(szY), 386, StrToInt(szY) + 10);
        DrawText(_hdc, szText, -1, &rect, DT_TOP | DT_LEFT | DT_SINGLELINE | DT_CALCRECT);
        DrawText(_hdc, szText, -1, &rect, DT_TOP | DT_LEFT | DT_SINGLELINE);

        MLLoadString(IDS_SPLASH_Y2, szY, ARRAYSIZE(szY));
        MLLoadString(IDS_SPLASH_STR2, szText, ARRAYSIZE(szText));
        SetRect(&rect, 104, StrToInt(szY), 386, 400);
        DrawText(_hdc, szText, -1, &rect, DT_TOP | DT_LEFT | DT_CALCRECT);
        DrawText(_hdc, szText, -1, &rect, DT_TOP | DT_LEFT);

        // select back the old font and delete the new one
        SelectObject(_hdc, hfontOld);
    }

    DeleteObject(hfont);
     
Done:
    // we now have everything in the DC, ready for painting.
    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, TEXT("CIESplashScreen"), NULL, 
                           WS_OVERLAPPED | WS_CLIPCHILDREN,
                           CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
                           NULL, (HMENU)NULL, HINST_THISDLL, this);
    if (_hwnd)
        ShowWindow(_hwnd, SW_NORMAL);

    return _hwnd;
}

LRESULT CIESplashScreen::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    CIESplashScreen *piess = (CIESplashScreen*)GetWindowPtr0(hwnd);

    if (!piess && (uMsg != WM_CREATE))
        return DefWindowProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_CREATE:
        DllAddRef();        // make sure we are not unloaded while in dialog
        if (lParam)
        {
            DWORD dwExStyles;

            piess = (CIESplashScreen*)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowPtr0(hwnd, piess);

            //
            // Turn off mirroring for the GUI splash screen bitmap.
            //
            if ((dwExStyles=GetWindowLong(hwnd, GWL_EXSTYLE))&RTL_MIRRORED_WINDOW)
            {
                SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyles&~RTL_MIRRORED_WINDOW);
            }

            // Now lets try to center the window on the screen.
            BITMAP bm;

            GetObject(piess->_hbmSplash, sizeof(bm), &bm);

            SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) & 
                          ~(WS_CAPTION|WS_SYSMENU|WS_BORDER|WS_THICKFRAME));
            SetWindowPos(hwnd, HWND_TOP, 
                         (GetSystemMetrics(SM_CXSCREEN) - bm.bmWidth) / 2, 
                         (GetSystemMetrics(SM_CYSCREEN) - bm.bmHeight) / 2, 
                         bm.bmWidth, bm.bmHeight, 0);

            // Set a 5 second timer to time it out.
            SetTimer(hwnd, TIMER_TIMEOUT, 15000, NULL);
        }
        g_fShown = TRUE;
        break;

    case WM_NCDESTROY:
        // the splash screen has left the building
        g_fShown = FALSE;
        
        DllRelease();
        break;

    case WM_ERASEBKGND:
        {
            RECT rc;
            GetClientRect(hwnd, &rc);
            HDC hdc = (HDC)wParam;

            BitBlt((HDC)hdc, 0, 0, rc.right, rc.bottom, piess->_hdc, 0, 0, SRCCOPY);

            return 1;
        }
        break;

    case WM_TIMER:
        // Now assume it is the right one.
        KillTimer( hwnd, TIMER_TIMEOUT );
        PostMessage(hwnd, WM_CLOSE, 0, 0);
        break;

    case SPLASHWM_DISMISS:
        // Hide ourselves and remove our reference to piess - it may be gone at any point
        // after this call.
        ShowWindow(hwnd, SW_HIDE);
        SetWindowPtr0(hwnd, 0);
        break;

    case WM_ACTIVATE:
        if ( wParam == WA_INACTIVE && hwnd != NULL )
        {
            KillTimer( hwnd, TIMER_TIMEOUT );

            // create a new timer for 2 seconds after loss of activation...
            SetTimer( hwnd, TIMER_TIMEOUT, 2000, NULL );
            break;
        }
        // drop through
    
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}


BOOL CIESplashScreen::_RegisterWindowClass(void)
{
    WNDCLASS wc = {0};

    //wc.style         = 0;
    wc.lpfnWndProc   = s_WndProc ;
    //wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(CIESplashScreen *);
    wc.hInstance     = g_hinst ;
    //wc.hIcon         = NULL ;
    //wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    //wc.lpszMenuName  = NULL ;
    wc.lpszClassName = TEXT("CIESplashScreen");

    return SHRegisterClass(&wc);
}

STDAPI CIESplashScreen_CreateInstance(IUnknown * pUnkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = E_FAIL;
    CIESplashScreen * pSplash = new CIESplashScreen( & hr );
    if ( !pSplash )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr ))
    {
        delete pSplash;
        return hr;
    }
    
    *ppunk = SAFECAST(pSplash, ISplashScreen *);
    return NOERROR;
}

STDAPI SHCreateSplashScreen(ISplashScreen **ppSplash)
{
    return CIESplashScreen_CreateInstance(NULL, (IUnknown **)ppSplash, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\shvocx.cpp ===
#include "priv.h"

#include "sccls.h"
#include "comcat.h"
#include "dvocx.h"
#include <hliface.h>
#include "shlguid.h"
#include "shvocx.h"
#include "winlist.h"
#include <mshtml.h>
#include "stdenum.h"
#include "iface.h"
#include "resource.h"
#include "msiehost.h"

#include <mluisupp.h>

#define SUPERCLASS CShellOcx

#define MIN_HEIGHT 80   // minimum height of a ShellFolderViewOC
#define MIN_WIDTH  80   // minimum width of a ShellFolderViewOC.
#define DEF_WIDTH  300  // default width when we cannot get sizing information
#define DEF_HEIGHT 150  // default height when we cannot get sizing information

#define IPSMSG(psz)             TraceMsg(TF_SHDCONTROL, "shv IPS::%s called", (psz))
#define IPSMSG2(psz, hres)      TraceMsg(TF_SHDCONTROL, "shv IPS::%s %x", (psz), hres)
#define IPSMSG3(psz, hres, x, y) TraceMsg(TF_SHDCONTROL,"shv IPS::%s %x %d (%d)", (psz), hres, x, y)
#define IOOMSG(psz)             TraceMsg(TF_SHDCONTROL, "shv IOO::%s called", (psz))
#define IOOMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "shv IOO::%s called with (%d)", (psz), i)
#define IOOMSG3(psz, i, j)      TraceMsg(TF_SHDCONTROL, "shv IOO::%s called with (%d, %d)", (psz), i, j)
#define IVOMSG(psz)             TraceMsg(TF_SHDCONTROL, "shv IVO::%s called", (psz))
#define IVOMSG2(psz, i)         TraceMsg(TF_SHDCONTROL, "shv IVO::%s called with (%d)", (psz), i)
#define IVOMSG3(psz, i, j)      TraceMsg(TF_SHDCONTROL, "shv IVO::%s called with (%d, %d)", (psz), i, j)
#define PROPMSG(psz)            TraceMsg(TF_SHDCONTROL, "shv %s", (psz))
#define PROPMSG2(psz, pstr)     TraceMsg(TF_SHDCONTROL, "shv %s with [%s]", (psz), pstr)
#define PROPMSG3(psz, hex)      TraceMsg(TF_SHDCONTROL, "shv %s with 0x%x", (psz), hex)
#define PRIVMSG(psz)            TraceMsg(TF_SHDCONTROL, "shv %s", (psz))
#define CVOCBMSG(psz)           TraceMsg(TF_SHDCONTROL, "shv CWebBrowserSB::%s", (psz))
#define IOIPAMSG(psz)           TraceMsg(TF_SHDCONTROL, "shv IOIPA::%s", (psz));

#define ABS(i)  (((i) < 0) ? -(i) : (i))

#define BOOL_TO_VARIANTBOOL(b) ((b) ? VARIANT_TRUE : VARIANT_FALSE)
#define VARIANTBOOL_TO_BOOL(vb) ((vb == VARIANT_FALSE) ? FALSE : TRUE)

// sizing messages are annoying, but occasionally useful:
#define DM_FORSEARCHBAND    0

static const OLEVERB c_averbsSV[] = {
        { 0, (LPWSTR)MAKEINTRESOURCE(IDS_VERB_EDIT), 0, OLEVERBATTRIB_ONCONTAINERMENU },
        { 0, NULL, 0, 0 }
    };
static const OLEVERB c_averbsDesignSV[] = {
        { 0, NULL, 0, 0 }
    };

#define HMODULE_NOTLOADED   ((HMODULE)-1)

HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);

/*
 * CMsgFilter - implementation of IMessageFilter
 *
 * Used to reject RPC-reentrant calls while inside AOL
 *
 */
class CMsgFilter : public IMessageFilter {
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
    {
        // This interface doesn't get QI'ed.
        ASSERT(FALSE);
        return E_NOINTERFACE;
    };
    virtual ULONG __stdcall AddRef(void)    {   return ++_cRef; };
    virtual ULONG __stdcall Release(void)   {   ASSERT(_cRef > 0);
                                                _cRef--;
                                                if (_cRef > 0)
                                                    return _cRef;

                                                delete this;
                                                return 0;
                                            };

    // *** IMessageFilter specific methods ***
    virtual DWORD __stdcall HandleInComingCall(
        IN DWORD dwCallType,
        IN HTASK htaskCaller,
        IN DWORD dwTickCount,
        IN LPINTERFACEINFO lpInterfaceInfo)
    {
#ifdef DEBUG
        WCHAR   wszIID[39];

        StringFromGUID2( lpInterfaceInfo->iid, wszIID, ARRAYSIZE(wszIID) );

        TraceMsg(TF_SHDCONTROL, "shvMF HandleIncomingCall: calltype=%lx, pUnk=%lx, IID=%ws, wMethod=%hu",
                dwCallType,
                lpInterfaceInfo->pUnk,
                wszIID,
                lpInterfaceInfo->wMethod);
#endif

        //
        //  The following statement guards against RPC-reentrancy by checking if
        //  the calltype is TOPLEVEL_CALLPENDING, which means that a call has arrived with a new
        //  logical threadid and that the object is currently waiting for a reply from a previous
        //  outgoing call.  It's this type of call that has proven troublesome in the past with AOL.
        //
        //  2-Dec-97: AOL QFE: We need to allow resizing requests to pass through the message filter.
        //            These appear as IOleObject::SetExtent.  Check the IID for IOleObject, and the 
        //            wMethod for 17 (SetExtent is the 17th method in the vtable, Zero-based).
        //
        const int SetExtent = 17;

        if ( ( dwCallType == CALLTYPE_TOPLEVEL_CALLPENDING )
            && !(IsEqualIID(lpInterfaceInfo->iid, IID_IOleObject) && lpInterfaceInfo->wMethod == SetExtent) )
        {
#ifdef DEBUG
            TraceMsg(TF_SHDCONTROL, "shvMF rejected call: calltype=%lx, pUnk=%lx, IID=%ws, wMethod=%hu",
                dwCallType,
                lpInterfaceInfo->pUnk,
                wszIID,
                lpInterfaceInfo->wMethod);
#endif
            return SERVERCALL_RETRYLATER;
        }

        if (_lpMFOld)
        {
           HRESULT hr = _lpMFOld->HandleInComingCall(dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo);
           TraceMsg(TF_SHDCONTROL, "shvMF HIC Previous MF returned %x", hr);
           return hr;
        }
        else
        {
            TraceMsg(TF_SHDCONTROL, "shvMF HIC returning SERVERCALL_ISHANDLED.");
            return SERVERCALL_ISHANDLED;
        }
    };

    virtual DWORD __stdcall RetryRejectedCall(
        IN HTASK htaskCallee,
        IN DWORD dwTickCount,
        IN DWORD dwRejectType)
    {
        TraceMsg(TF_SHDCONTROL, "shv MF RetryRejectedCall htaskCallee=%x, dwTickCount=%x, dwRejectType=%x",
            htaskCallee,
            dwTickCount,
            dwRejectType);

        if (_lpMFOld)
        {
            HRESULT hr = _lpMFOld->RetryRejectedCall(htaskCallee, dwTickCount, dwRejectType);
            TraceMsg(TF_SHDCONTROL, "shvMF RRC returned %x", hr);
            return hr;
        }
        else
        {
            TraceMsg(TF_SHDCONTROL, "shvMF RRC returning 0xffffffff");
            return 0xffffffff;
        }
    };

    virtual DWORD __stdcall MessagePending(
        IN HTASK htaskCallee,
        IN DWORD dwTickCount,
        IN DWORD dwPendingType)
    {
        TraceMsg(TF_SHDCONTROL, "shv MF MessagePending htaskCallee=%x, dwTickCount=%x, dwPendingType=%x",
            htaskCallee,
            dwTickCount,
            dwPendingType);

        if (_lpMFOld)
        {
            HRESULT hr = _lpMFOld->MessagePending(htaskCallee, dwTickCount, dwPendingType);
            TraceMsg(TF_SHDCONTROL, "shvMF RRC returned %x", hr);
            return hr;
        }
        else
        {
            TraceMsg(TF_SHDCONTROL, "shvMF MP returning PENDINGMSG_WAITDEFPROCESS");
            return PENDINGMSG_WAITDEFPROCESS;
        }
    };

    CMsgFilter() : _cRef(1)
    {
        ASSERT(_lpMFOld == NULL);
    };

    BOOL Initialize()
    {
        BOOL bResult = CoRegisterMessageFilter((LPMESSAGEFILTER)this, &_lpMFOld) != S_FALSE;
        TraceMsg(TF_SHDCONTROL, "shv Previous message filter is %lx", _lpMFOld);
        return bResult;
    };

    void UnInitialize()
    {
        TraceMsg(TF_SHDCONTROL, "shv MF Uninitializing, previous message filter = %x", _lpMFOld);
        CoRegisterMessageFilter(_lpMFOld, NULL);

        // we shouldn't ever get called again, but after 30 minutes
        // of automation driving we once hit a function call above
        // and we dereferenced this old pointer and page faulted.

        ATOMICRELEASE(_lpMFOld);
    };

protected:
    int _cRef;
    LPMESSAGEFILTER _lpMFOld;
};


CWebBrowserOC::CWebBrowserOC(IUnknown* punkOuter, LPCOBJECTINFO poi) :
    SUPERCLASS(punkOuter, poi, c_averbsSV, c_averbsDesignSV)
{
    TraceMsg(TF_SHDLIFE, "ctor CWebBrowserOC %x", this);

    // flag special so we only try to load browseui once
    _hBrowseUI = HMODULE_NOTLOADED;    
}

BOOL CWebBrowserOC::_InitializeOC(IUnknown *punkOuter)
{
    // we used a zero-init memory allocator, so everything else is NULL.
    // check to be sure:
    ASSERT(!_fInit);

    // By default, we're visible.  Everything else can default to FALSE.
    //
    _fVisible = 1;

    // CShellOcx holds the default event source which is DIID_DWebBrowserEvents2
    m_cpWB1Events.SetOwner(_GetInner(), &DIID_DWebBrowserEvents);

    // some stuff we want to set up now. we're a WebBrowser, so create the
    // IShellBrowser now. We need an aggregated automation object before
    // we do that.
    CIEFrameAuto_CreateInstance(SAFECAST(this, IOleControl*), &_pauto);
    if (_pauto)
    {
        // Cache some interfaces of CIEFrameAuto.
        //
        // Since we aggregate CIEFrameAuto, this will increase our refcount.
        // We cannot release this interface and expect it to work, so we
        // call release on ourself to remove the refcount cycle.
        //
        // Since we ourselves may be aggregated and we always want to get
        // CIEFrameAuto's interface and not our aggregator's, we delay
        // setting up punkOuter until below.
        //
        _pauto->QueryInterface(IID_PPV_ARG(IWebBrowser2, &_pautoWB2));
        ASSERT(_pautoWB2);
        Release();

        _pauto->QueryInterface(IID_PPV_ARG(IExpDispSupport, &_pautoEDS));
        ASSERT(_pautoEDS);
        Release();
    }

    // Now set up our aggregator's punkOuter
    if (punkOuter)
    {
        CAggregatedUnknown::_SetOuter(punkOuter);
    }

    // postpone initialization of stuff that may be persisted
    // until InitNew is called.

    // Were we successful? (we don't have to free this
    // here on failure, cuz we'll free them on delete)
    return (NULL!=_pauto);
}

CWebBrowserOC::~CWebBrowserOC()
{
    TraceMsg(TF_SHDLIFE, "dtor CWebBrowserOC %x", this);

    ASSERT(!_fDidRegisterAsBrowser);
    _UnregisterWindow();    // Last Chance - should have been done in InplaceDeactivate

    if (_psb) {
        ATOMICRELEASET(_psb, CWebBrowserSB);
    }

    ATOMICRELEASE(_plinkA);

    // We need to release these cached interface pointers.
    //
    // Since we cached them before setting up our outer-aggregation,
    // we need to un-outer-aggregate ourself first.
    //
    // Since we aggregate CIEFrameAuto (where these come from) we need
    // to AddRef ourself before releasing. Fortunately, this is done for us
    // by CAggregatedUnknown::Release (it bumps _cRef to 1000).
    //
    CAggregatedUnknown::_SetOuter(CAggregatedUnknown::_GetInner());
    ATOMICRELEASE(_pautoWB2);
    ATOMICRELEASE(_pautoEDS);

    ATOMICRELEASE(_pauto);

    if (_hmemSB) {
        GlobalFree(_hmemSB);
        _hmemSB = NULL;
    }

    if (_hBrowseUI != 0 && _hBrowseUI != HMODULE_NOTLOADED)
        FreeLibrary(_hBrowseUI);
}



IStream *CWebBrowserSB::v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName)
{
    TCHAR szName[MAX_PATH];
    SHUnicodeToTChar(pwszName, szName, ARRAYSIZE(szName));
    return GetViewStream(pidl, grfMode, szName, REGSTR_PATH_EXPLORER TEXT("\\OCXStreamMRU"), TEXT("OCXStreams"));
}

void CWebBrowserOC::_InitDefault()
{
    if (_fInit)
    {
        IPSMSG(TEXT("_InitDefault already initialized"));
        return;
    }
    _fInit = TRUE;

    // Different versions of the control get different defaults.
    if (_pObjectInfo->lVersion == VERSION_1)
    {
        // AOL 3.0 compatibility: register as a browser window on InPlaceActivate
        _fShouldRegisterAsBrowser = TRUE;
    }
    else
    {
        // we use a zero-init memory allocator, so everything else is NULL.
        ASSERT(FALSE == _fShouldRegisterAsBrowser);
    }

    _size.cx = DEF_WIDTH;
    _size.cy = DEF_HEIGHT;
    _sizeHIM = _size;
    PixelsToMetric(&_sizeHIM);

    _fs.ViewMode = FVM_ICON;
    _fs.fFlags = FWF_AUTOARRANGE | FWF_NOCLIENTEDGE;
    
}

void CWebBrowserOC::_RegisterWindow()
{
    if (!_fDidRegisterAsBrowser && _pipsite && _fShouldRegisterAsBrowser)
    {
        ITargetFrame2 *ptgf;
        HRESULT hr;
    
        if (SUCCEEDED(QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
        {
            IUnknown *pUnkParent;

            hr = ptgf->GetParentFrame(&pUnkParent);
            if (SUCCEEDED(hr) && pUnkParent != NULL)
            {
                pUnkParent->Release();
            }
            else
            {
                IShellWindows* psw = WinList_GetShellWindows(TRUE);
                if (psw)
                {
                    IDispatch* pid;

                    if (SUCCEEDED(ptgf->QueryInterface(IID_PPV_ARG(IDispatch, &pid))))
                    {
                        psw->Register(pid, PtrToLong(_hwnd), SWC_3RDPARTY, &_cbCookie);
                        _fDidRegisterAsBrowser = 1;
                        pid->Release();
                    }
                    psw->Release();
                }
            }
            ptgf->Release();
        }
    }
}

void CWebBrowserOC::_UnregisterWindow()
{
    if (_fDidRegisterAsBrowser)
    {
        IShellWindows* psw = NULL;

        psw = WinList_GetShellWindows(TRUE);
        if (psw)
        {
            psw->Revoke(_cbCookie);
            _fDidRegisterAsBrowser = 0;
            psw->Release();
        }
    }
}

HRESULT CWebBrowserOC::Draw(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL ( __stdcall *pfnContinue )(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    IS_INITIALIZED;

    HRESULT hres;

    IVOMSG3(TEXT("Draw called"), lprcBounds->top, lprcBounds->bottom);
    IViewObject *pvo;
    if (_psb && _psb->GetShellView() &&
        SUCCEEDED(_psb->GetShellView()->QueryInterface(IID_PPV_ARG(IViewObject, &pvo)))) 
    {
        hres = pvo->Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw,
                              lprcBounds, lprcWBounds, pfnContinue, dwContinue);
        pvo->Release();
        if (SUCCEEDED(hres))
            return hres;
    }
    
    // If we don't have a shell view, or if it couldn't draw, then we draw ourselves.
    // (if we're in design mode).
    //
    if (_IsDesignMode())
    {
        FillRect(hdcDraw, (RECT*) lprcBounds, (HBRUSH)GetStockObject(BLACK_BRUSH));

        SIZE     size = { ABS( lprcBounds->right - lprcBounds->left ), 
                          ABS( lprcBounds->bottom - lprcBounds->top ) };

        HBITMAP  hImage;
        HDC      hdcTmp = CreateCompatibleDC( hdcDraw );
        HMODULE  hBrowseUI;

        hBrowseUI = _GetBrowseUI();
        if ( hBrowseUI )      
            hImage = LoadBitmap( hBrowseUI, MAKEINTRESOURCE( IDB_IEBRAND ));
        else 
            hImage = NULL;

        // hdcDraw may be a metafile, in which case the CreateCompatibleDC call will fail.
        // 
        if ( !hdcTmp )
        {
            hdcTmp = CreateCompatibleDC( hdcTargetDev );  // Okay if hdcTargetDev == NULL
        }

        if (hdcTmp)
        {
            if ( hImage )
            {
                BITMAP bm;
                POINT  ptOriginDest;  // origin of destination
                SIZE   sizeDest;
                POINT  ptOriginSrc = { 0, 0 };
                SIZE   sizeSrc;

                GetObject( hImage, sizeof( bm ), &bm );
            
                HGDIOBJ hPrev = SelectObject( hdcTmp, hImage );

                // Yes, this looks wrong, but it's right.  We only want the first frame
                // of the brand bitmap, and the frames are stacked vertically.
                //
                sizeSrc.cx = sizeSrc.cy = bm.bmWidth;
            
                // This code centers the bitmap while preserving its aspect ratio.
                //            
                if ( size.cx > size.cy )
                {
                    // if destination is wider than tall,
                    //
                    ptOriginDest.x = lprcBounds->left + size.cx/2 - size.cy/2;
                    ptOriginDest.y = lprcBounds->top;
                    sizeDest.cx = size.cy;
                    sizeDest.cy = lprcBounds->bottom - lprcBounds->top >= 0 ? size.cy : -size.cy;
                }
                else
                {
                    // else destination is taller than wide
                    //
                    ptOriginDest.x = lprcBounds->left;
                    ptOriginDest.y = lprcBounds->bottom - lprcBounds->top >= 0
                        ? ( lprcBounds->top + size.cy/2 - size.cx/2 )
                        : -( lprcBounds->top + size.cy/2 - size.cx/2 );
                    sizeDest.cx = size.cx;
                    sizeDest.cy = lprcBounds->bottom - lprcBounds->top >= 0 ? size.cx : -size.cx;
                }

                StretchBlt( hdcDraw,
                            ptOriginDest.x, ptOriginDest.y,
                            sizeDest.cx, sizeDest.cy,
                            hdcTmp, 
                            ptOriginSrc.x, ptOriginSrc.y,
                            sizeSrc.cx, sizeSrc.cy,
                            SRCCOPY );

                SelectObject( hdcTmp, hPrev );
                DeleteObject( hImage );
            }

            DeleteDC( hdcTmp );
        }

        return S_OK;
    }
    
    return SUPERCLASS::Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw,
                              lprcBounds, lprcWBounds, pfnContinue, dwContinue);
}

HRESULT CWebBrowserOC::GetColorSet(DWORD dwAspect, LONG lindex,
    void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    IViewObject *pvo;

    if (_psb && _psb->GetShellView() &&
        SUCCEEDED(_psb->GetShellView()->QueryInterface(IID_PPV_ARG(IViewObject, &pvo))))
    {
        HRESULT hres = pvo->GetColorSet(dwAspect, lindex, pvAspect, ptd,
            hicTargetDev, ppColorSet);

        pvo->Release();

        if (SUCCEEDED(hres))
            return hres;
    }

    return SUPERCLASS::GetColorSet(dwAspect, lindex, pvAspect, ptd,
        hicTargetDev, ppColorSet);
}

 HRESULT CWebBrowserOC::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    HRESULT hr = SUPERCLASS::SetExtent(dwDrawAspect, psizel);
    if ( FAILED( hr ))
    {
        return hr;
    }

    //
    // If oc < inplace then forward SetExtent through to docobject.
    // If docobject is already inplace active, SetExtent is meaningless.
    //
    
    if (_nActivate < OC_INPLACEACTIVE)
    {        
        IPrivateOleObject * pPrivOle = NULL;
        if ( _psb && _psb->GetShellView() && 
             SUCCEEDED(_psb->GetShellView()->QueryInterface(IID_PPV_ARG(IPrivateOleObject, &pPrivOle))))
        {
            // we have an ole object, delegate downwards...
            hr = pPrivOle->SetExtent( dwDrawAspect, psizel );
            pPrivOle->Release();
        }

        _dwDrawAspect = dwDrawAspect;
        // the size is already cached in _sizeHIM in our base class by the SUPERCLASS::SetExtent()
    }
    
    return hr;
}



// Called after the client site has been set so we can process
// stuff in the correct order
//
void CWebBrowserOC::_OnSetClientSite()
{
    // Until we have a client site we can't determine toplevelness.
    //
    if (_pcli)
    {
        BOOL fFoundBrowserService = FALSE;
        IBrowserService *pbsTop;

        if (SUCCEEDED(IUnknown_QueryService(_pcli, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbsTop))))
        {
            fFoundBrowserService = TRUE;
            pbsTop->Release();
        }

        // if nobody above us supports IBrowserService, we must be toplevel.
        if (!fFoundBrowserService)
            _fTopLevel = TRUE;


        // If we haven't created CWebBrowserSB, do so now.
        // We do this before our superclass OnSetClientSite
        // because shembed will create the window which
        // requires _psb's existence.
        //
        // NOTE: We do this here instead of _Initialize because
        // CBaseBrowser will QI us for interfaces during this call.
        // If we're in the middle of our CreateInstance function
        // and we've been aggregated, we pass the QI to _punkAgg
        // who faults because we haven't returned from CoCreateInstance.
        //
        // NOTE: We now destroy our window on SetClientSite(NULL)
        // which frees ths _psb, so we should create this every time.
        //
        if (!_psb)
        {
            // Give _psb our inner unknown so we never get interfaces
            // from whoever may aggregate us. _GetInner gives us
            // first crack at QueryInterface so we get the correct
            // IWebBrowser implementation.
            //
            _psb = new CWebBrowserSB(CAggregatedUnknown::_GetInner(), this);
    
            // if we don't get _psb we're totally hosed...
            //
            if (_psb)
            {
                _psb->_fldBase._fld._fs = _fs;
                // tell _psb if it's top-level or not
                //
                if (_fTopLevel)
                {
                    _psb->SetTopBrowser();
                }

                // CBaseBrowser assumes SVUIA_ACTIVATE_FOCUS, tell it what we really are
                //
                ASSERT(OC_DEACTIVE == _nActivate); // we shouldn't be activated yet
                _psb->_UIActivateView(SVUIA_DEACTIVATE);
            }
            else
            {
                TraceMsg(TF_WARNING, "Couldn't create _psb.  We are hosed!");
                // don't let the window get created by our superclass,
                // as we can't do anything anyway...
                //
                return;
            }
        }
    }
    else
    {
        // Tell our aggregatee that their cached window is invalid
        //
        IEFrameAuto * piefa;
        if (EVAL(SUCCEEDED(_pauto->QueryInterface(IID_PPV_ARG(IEFrameAuto, &piefa)))))
        {
            piefa->SetOwnerHwnd(NULL);
            piefa->Release();
        }

        if (_lpMF) 
        {
            IMessageFilter* lpMF = _lpMF;
            _lpMF = NULL;
            ((CMsgFilter *)lpMF)->UnInitialize();
            EVAL(lpMF->Release() == 0);
        }

        // Decrement the browser session count
        //
        if (_fIncrementedSessionCount)
        {
            SetQueryNetSessionCount(SESSION_DECREMENT);
            _fIncrementedSessionCount = FALSE;  // In case this instance is reused.
        }
    }

    SUPERCLASS::_OnSetClientSite();
    
    if (_pcli)
    {
        VARIANT_BOOL fAmbient = VARIANT_FALSE;
        HWND         hwndParent = NULL;
        // We init the local properties using ambients if available
        // If this fails, fAmbient will be left at VARIANT_FALSE which is what we need for the next 
        // statement.
        //
        if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED, VT_BOOL, &fAmbient))
        {
            put_Offline(fAmbient);
        } 
                       
        // If top-level and not offline, increment the browser session count.
        //
        if (_fTopLevel && !fAmbient)
        {
            SetQueryNetSessionCount(SESSION_INCREMENT_NODEFAULTBROWSERCHECK);
            _fIncrementedSessionCount = TRUE;
        }

        if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_SILENT, VT_BOOL, &fAmbient))
        {
            put_Silent(fAmbient);
        }

        // After the parent window has been set, check to see if it is on the same thread as us.
        // If not, we have a cross-thread container and we need a message filter.
        //
        if ( _fTopLevel    // If we're top level
            && _hwnd       //  and we have an hwnd (we should)
            && (hwndParent = GetParent( _hwnd ) )  // and we have a parent window
                           //  and the parent window is on a different thread
            && GetWindowThreadProcessId( _hwnd, NULL ) != GetWindowThreadProcessId( hwndParent, NULL ))
        {
            if (!_lpMF)
            {
                /*
                 * Create a message filter here to reject RPC-reentrant calls.
                 */
                _lpMF = new CMsgFilter();

                if (_lpMF && !(((CMsgFilter *)_lpMF)->Initialize()))
                {
                    ATOMICRELEASE(_lpMF);
                }
                TraceMsg(TF_SHDCONTROL, "shv Registering message filter (%lx) for RPC-reentrancy", _lpMF);
            }
        }


        // if we have a pending navigation from IPS::Load, do it now.
        //
        if (_fNavigateOnSetClientSite && _plinkA && _psb)
        {
            //
            // We hit this code if this OC is IPersistStream::Loaded before
            // the client site is set.
            //
            LPITEMIDLIST pidl;
            if (SUCCEEDED(_plinkA->GetIDList(&pidl)) && pidl)
            {
                _BrowseObject(pidl);
                ILFree(pidl);
            }

            _fNavigateOnSetClientSite = FALSE;
        }
    }
    
}

STDAPI CWebBrowserOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres;

    hres = E_OUTOFMEMORY;
    CWebBrowserOC* psvo = new CWebBrowserOC(NULL, poi);
    if (psvo)
    {
        if (!psvo->_InitializeOC(punkOuter))
        {
            psvo->Release();
        }
        else
        {
            *ppunk = psvo->_GetInner();
            hres = S_OK;
        }
    }
    return hres;
}


LRESULT CWebBrowserOC::_OnPaintPrint(HDC hdcPrint)
{
    PAINTSTRUCT ps;
    HDC hdc = hdcPrint ? hdcPrint : BeginPaint(_hwnd, &ps);
    RECT rc;
    GetClientRect(_hwnd, &rc);
    DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_ADJUST|BF_RECT|BF_SOFT);
    DrawText(hdc, hdcPrint ? TEXT("Print") : TEXT("Paint"),
            -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    if (!hdcPrint) 
    {
        EndPaint(_hwnd, &ps);
    }
    return 0;
}

HRESULT CWebBrowserOC::_BrowseObject(LPCITEMIDLIST pidlBrowseTo)
{
    if (_psb)
        return _psb->BrowseObject(pidlBrowseTo, SBSP_SAMEBROWSER | SBSP_ABSOLUTE);

    // if no _psb at this point, container did not
    // honor OLEMISC_SETCLIENTSITEFIRST bit, so silently
    // fail instead of trying to make this work
    ASSERT(FALSE);
    return E_FAIL;
}

LRESULT CWebBrowserOC::_OnCreate(LPCREATESTRUCT lpcs)
{
    LRESULT lres;

    if (_psb)
    {
        ASSERT(_hwnd);
        _psb->_SetWindow(_hwnd);

        lres = _psb->OnCreate(NULL);
    }
    else
    {
        lres = (LRESULT)-1;
    }

    //
    //  If IPersistStream::Load has stored away a block of stream for
    // toolbars, this is the time to use it.
    //
    if (_hmemSB) 
    {
#if 0
        // only do the load if we're successfully creating the window
        if (lres != -1) 
        {
            IStream* pstm;
            HRESULT hresT = ::CreateStreamOnHGlobal(_hmemSB, FALSE, &pstm);
            if (SUCCEEDED(hresT)) 
            {
                _psb->_LoadToolbars(pstm);
                pstm->Release();
            }
        }
#endif
        GlobalFree(_hmemSB);
        _hmemSB = NULL;
    }

    return lres;
}

//
//  This is a virtual function defined in CShellEmbedding class, which
// is called when all but WM_NCCREATE and WM_NCDESTROY messages are
// dispatched to the our "Shell Embedding" window. It's important
// to remember that we pass this window handle to the constructor of
// CWebBrowserSB (which calls the constructor of CBaseBrowser).
// That's why we forward all messages to _psb->WndProcBS. (SatoNa)
//
LRESULT CWebBrowserOC::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0L;

    if (WM_CREATE == uMsg)
    {
        // We need first crack at this message before
        // forwarding it along to _psb (which we do
        // in this _OnCreate call)
        return _OnCreate((LPCREATESTRUCT)lParam);
    }

    // only let _psb look at it if the message is not reserved for us
    if (!IsInRange(uMsg, CWM_RESERVEDFORWEBBROWSER_FIRST, CWM_RESERVEDFORWEBBROWSER_LAST))
    {
        BOOL fDontForward = FALSE;
        
        // destroy bottom up for these 
        switch (uMsg) 
        {
        case WM_DESTROY:
        case WM_CLOSE:
            SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
            fDontForward = TRUE;
            break;
        }

        //
        // This AssertMsg will help debugging IE v4.1 bug 12931.
        //
        //  Comment out assert now that we don't create _psb at constructor time.  (?)
        //AssertMsg((BOOL)_psb, "WBOC::v_WndProc _psb==NULL! uMsg=%x", uMsg);

        if (_psb)
        {
            lres = _psb->WndProcBS(hwnd, uMsg, wParam, lParam);

            //  Due to aggregation of IEFrameAuto, _psb is holding references
            //  to us, so we need to break the cycle.
            //  _psb may have been freed above.  Double check it.
            //
            if (uMsg == WM_DESTROY && _psb)
            {
                _psb->ReleaseShellView();
                _psb->ReleaseShellExplorer();
                ATOMICRELEASET(_psb, CWebBrowserSB);
            }
        }
        if (uMsg >= WM_USER || fDontForward)
        {
            return lres;
        }
    }

    switch(uMsg)
    {
        /* these are handled by CBaseBrowser only */
    case WM_NOTIFY:
        return lres;

    case WM_SETCURSOR:
        if (lres) {
            return lres;
        }
        goto DoDefault;

DoDefault:
    default:
        return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

HRESULT CWebBrowserOC::Close(DWORD dwSaveOption)
{
    if (_psb)
    {
        _psb->_CancelPendingNavigation();
    }

    if (_pauto)
    {
        IWebBrowserPriv * pWBPriv;

        HRESULT hr = _pauto->QueryInterface(IID_IWebBrowserPriv, (void**)&pWBPriv);
        if (SUCCEEDED(hr))
        {
            pWBPriv->OnClose();
            pWBPriv->Release();
        }
    }

    return SUPERCLASS::Close(dwSaveOption);
}

HRESULT CWebBrowserOC::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    IOOMSG(TEXT("SetHostNames"));

    // We are not interested in host name
    // ...well ... maybe a little.  this turns out to be the best place to
    // do an apphack for VC 5.0.  VC 5.0 has a bug where it calls Release()
    // one too many times.  the only good way to detect being hosted in the
    // offending container is to check the szContainerApp in SetHostNames!
    // ...chrisfra 8/14/97, bug 30428
    // NOTE: Mike Colee of VC verified their bug and will put a Raid bug in
    // their database including how to signal that a new version works by
    // changing szContainerApp string.
    if (_fTopLevel && szContainerApp && !StrCmpW(szContainerApp, L"DevIV Package"))
    {
        AddRef();
    }
    return SUPERCLASS::SetHostNames(szContainerApp, szContainerObj);
}

HRESULT CWebBrowserOC::DoVerb(
    LONG iVerb,
    LPMSG lpmsg,
    IOleClientSite *pActiveSite,
    LONG lindex,
    HWND hwndParent,
    LPCRECT lprcPosRect)
{
    IS_INITIALIZED;

    _pmsgDoVerb = lpmsg;

    HRESULT hr = SUPERCLASS::DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);

    _pmsgDoVerb = NULL;

    return hr;
}

// *** IPersistStreamInit ***

// in order to have upgrade and downgrade compatibility in stream formats
// we can't have any size assumptions in this code. Extra data streamed
// after our PersistSVOCX structure must be referenced by a dwOffX offset
// so the downgrade case knows where to start reading from.
//
// since we always write out a stream that's downward compatible, we don't
// need to folow the "source compatible" rule of: reading an old stream
// with an old CLSID WebBrowser implies that when we save, we need to
// save using the old stream format.
//
typedef struct _PersistSVOCX
{
    struct _tagIE30 {
        DWORD cbSize;
        SIZE sizeObject;            // IE3 saves as PIXELS, IE4 saves as HIMETRIC
        FOLDERSETTINGS fs;
        long lAutoSize;             // IE3, no longer used
        DWORD fColorsSet;           // IE3, no longer used
        COLORREF clrBack;           // IE3, no longer used
        COLORREF clrFore;           // IE3, no longer used
        DWORD dwOffPersistLink;
        long lAutoSizePercentage;   // IE3, no longer used
    } ie30;
    struct _tagIE40 {
        DWORD   dwExtra;
        BOOL    bRestoreView;
        SHELLVIEWID vid;
        DWORD   fFlags;
        DWORD   dwVersion;
    } ie40;
} PersistSVOCX;

//
// Flags for dwExtra. Having a flag indicate that we have some extra
// streamed data after this structure + persisted link.
//
// NOTE: All data stored this way (instead of storing an offset to
// the data, such as dwOffPersistLink) will be lost on downgrade
// cases and cases where we have to emulate old stream formats.
//
#define SVO_EXTRA_TOOLBARS 0x00000001

// Random flags we need to persist
#define SVO_FLAGS_OFFLINE           0x00000001
#define SVO_FLAGS_SILENT            0x00000002
#define SVO_FLAGS_REGISTERASBROWSER 0x00000004
#define SVO_FLAGS_REGISTERASDROPTGT 0x00000008

#define SVO_VERSION 0 // increment for upgrade changes when size doesn't change

HRESULT CWebBrowserOC::Load(IStream *pstm)
{
    IPSMSG(TEXT("Load"));
    // Load _size
    ULONG cbRead;
    PersistSVOCX sPersist;
    HRESULT hres, hresNavigate = E_FAIL;
    DWORD dwExtra = 0;

    // It is illegal to call Load or InitNew more than once
    if (_fInit)
    {
        TraceMsg(TF_SHDCONTROL, "shv IPersistStream::Load called when ALREADY INITIALIZED!");
        ASSERT(FALSE);
        return E_FAIL;
    }

    // we need an IShellLink to read into
    if (_plinkA == NULL)
    {
        hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &_plinkA));
        if (FAILED(hres))
            return hres;
    }

    // remember our starting location
    ULARGE_INTEGER liStart;
    //ULARGE_INTEGER liEnd;
    LARGE_INTEGER liMove;
    liMove.LowPart = liMove.HighPart = 0;
    hres = pstm->Seek(liMove, STREAM_SEEK_CUR, &liStart);
    if (FAILED(hres))
    {
        return hres;
    }

    // Zero initialize our struct
    ZeroMemory(&sPersist, SIZEOF(sPersist));

    hres = pstm->Read(&sPersist, SIZEOF(DWORD), &cbRead);
    if (SUCCEEDED(hres))
    {
        // Validate the data
        if (cbRead != SIZEOF(DWORD) ||
            sPersist.ie30.cbSize < SIZEOF(sPersist.ie30))
        {
            TraceMsg(DM_ERROR, "Someone is asking us to read the wrong thing.");
            hres = E_FAIL;
        }
        else
        {
            DWORD cbSizeToRead = sPersist.ie30.cbSize;
            if (cbSizeToRead > SIZEOF(sPersist))
            {
                // must be a newer struct, only read what we know (ie, don't trash the stack!)
                cbSizeToRead = SIZEOF(sPersist);
            }
            cbSizeToRead -= SIZEOF(DWORD); // remove what we've already read
            hres = pstm->Read(&sPersist.ie30.sizeObject, cbSizeToRead, &cbRead);
            if (SUCCEEDED(hres))
            {
                if (cbRead != cbSizeToRead)
                {
                    hres = E_FAIL;
                }
                else
                {
                    // read ie30 data
                    //
                    if (EVAL(sPersist.ie30.cbSize >= SIZEOF(sPersist.ie30)))
                    {
                        _size = sPersist.ie30.sizeObject;
                        _fs = sPersist.ie30.fs;

                        // IE3 saved size in pixels IE4 saves size in HIM already
                        //
                        _sizeHIM = _size;
                        if (sPersist.ie30.cbSize == SIZEOF(sPersist.ie30) ||
                            sPersist.ie30.cbSize == SIZEOF(sPersist) - SIZEOF(sPersist.ie40.dwVersion)) // handle upgrade
                        {
                            // Size is in pixels.  Adjust _sizeHIM to Hi Metric.
                            PixelsToMetric(&_sizeHIM);
                        }
                        else
                        {
                            // Size is in Hi Metric.  Adjust _size to Pixels.
                            MetricToPixels(&_size);
                        }

                        if (_psb) // if no _psb then container ignored OLEMISC_SETCLIENTSITEFIRST
                            _psb->_fldBase._fld._fs = _fs;
                            
                        // Load _plinkA
                        IPersistStream* ppstm;
                        hres = _plinkA->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
                        if (SUCCEEDED(hres))
                        {
                            ASSERT(sPersist.ie30.dwOffPersistLink >= sPersist.ie30.cbSize);
                            liMove.LowPart = liStart.LowPart + sPersist.ie30.dwOffPersistLink;

                            hres = pstm->Seek(liMove, STREAM_SEEK_SET, NULL);
                            if (SUCCEEDED(hres))
                            {
                                hres = ppstm->Load(pstm);
                                if (SUCCEEDED(hres)) 
                                {
                                    // We always save link info last,
                                    // so remember where we are in the stream.
                                    // Since we don't have more dwOff variables
                                    // currently, don't bother remebering this...
                                    //hres = pstm->Seek(liMove, STREAM_SEEK_CUR, &liEnd);
                                    //if (SUCCEEDED(hres))
                                        _fInit = TRUE;
                                
                                    // in case the target moved invoke link tracking (ignore errors)
                                    _plinkA->Resolve(_hwnd, SLR_NO_UI);

                                    // If we already have the client site,
                                    // navigate now. Otherwise, navigate
                                    // when the client site is set.
                                    if (_pcli) 
                                    {
                                        LPITEMIDLIST pidl;
                                        if (SUCCEEDED(_plinkA->GetIDList(&pidl)) && pidl)
                                        {
                                            ASSERT(FALSE == _psb->_fAsyncNavigate);
                                            _psb->_fAsyncNavigate = TRUE;
                                            hresNavigate = _BrowseObject(pidl);
                                            _psb->_fAsyncNavigate = FALSE;
                                            ILFree(pidl);
                                        }
                                    } 
                                    else 
                                    {
                                        _fNavigateOnSetClientSite = TRUE;
                                    }
                                }
                            }

                            ppstm->Release();
                        }
                    } // read ie30 data


                    // temp upgrade hack for older struct
                    if (sPersist.ie30.cbSize == SIZEOF(sPersist) - SIZEOF(sPersist.ie40.dwVersion))
                    {
                        // dwVersion field is already correct, update cbSize
                        // to pass below size check
                        sPersist.ie30.cbSize = SIZEOF(sPersist);
                    }

                    // read ie40 data
                    if (SUCCEEDED(hres) &&
                        sPersist.ie30.cbSize >= SIZEOF(sPersist))
                    {
                        if (_psb) // if no _psb then container ignored OLEMISC_SETCLIENTSITEFIRST
                        {
                            if (sPersist.ie40.bRestoreView)
                            {
                                _psb->_fldBase._fld._vidRestore = sPersist.ie40.vid;
                                // since we read the ie40 data, this is a cache hit
                                _psb->_fldBase._fld._dwViewPriority = VIEW_PRIORITY_CACHEHIT;
                            }
                        }

                        // We let ambients take precedence over what we have persisted
                        VARIANT_BOOL fAmbient;
                        if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED, VT_BOOL, &fAmbient))
                        {
                            put_Offline(fAmbient);
                        } 
                        else
                        {
                            put_Offline((sPersist.ie40.fFlags & SVO_FLAGS_OFFLINE) ? -1 : FALSE);
                        }
                        if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_SILENT, VT_BOOL, &fAmbient))
                        {
                            put_Silent(fAmbient);
                        }
                        else
                        {
                            put_Silent((sPersist.ie40.fFlags & SVO_FLAGS_SILENT) ? -1 : FALSE);
                        }

                        
                        put_RegisterAsDropTarget(BOOL_TO_VARIANTBOOL(sPersist.ie40.fFlags & SVO_FLAGS_REGISTERASDROPTGT));

                        _fShouldRegisterAsBrowser = (sPersist.ie40.fFlags & SVO_FLAGS_REGISTERASBROWSER) ? TRUE : FALSE;

                        // remember this for later
                        dwExtra = sPersist.ie40.dwExtra;
                    }
                    else
                    {
                        // if CLSID_WebBrowser_V1 reads an old stream format,
                        // it means that we must write out an old stream format later
                        // remember this...
                        if (_pObjectInfo->lVersion == VERSION_1)
                        {
                            _fEmulateOldStream = TRUE;
                        }
                    } // read ie40 data
                }

                // if we read all the data then make sure we're at
                // the end of the stream
                if (SUCCEEDED(hres) && _fInit)
                {
                    //liMove.LowPart = liEnd.LowPart;
                    //hres = pstm->Seek(liMove, STREAM_SEEK_SET, NULL);

                    // now we can read in extra streamed data if we have it
                    if (dwExtra & SVO_EXTRA_TOOLBARS)
                    {
                        DWORD dwTotal;
                        hres = pstm->Read(&dwTotal, SIZEOF(dwTotal), NULL);
                        if (SUCCEEDED(hres)) 
                        {
                            ASSERT(dwTotal >= SIZEOF(dwTotal));
                            dwTotal -= SIZEOF(dwTotal);

                            if (_hmemSB) 
                            {
                                GlobalFree(_hmemSB);
                            }

                            _hmemSB = GlobalAlloc(GPTR, dwTotal);
                            if (_hmemSB) 
                            {
                                hres = pstm->Read((BYTE*)_hmemSB, dwTotal, NULL);
                            }
                            else 
                            {
                                hres = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
            }
        }
    }

    _OnLoaded(FAILED(hresNavigate));

    if (SUCCEEDED(hres))
        hres = S_OK;    // convert S_FALSE to S_OK
 
    return hres;
}

HRESULT CWebBrowserOC_SavePersistData(IStream *pstm, SIZE* psizeObj,
    FOLDERSETTINGS* pfs, IShellLinkA* plinkA, SHELLVIEWID* pvid,
    BOOL fOffline, BOOL fSilent, BOOL fRegisterAsBrowser, BOOL fRegisterAsDropTarget,
    BOOL fEmulateOldStream, DWORD *pdwExtra)
{
    ULONG cbWritten;
    PersistSVOCX sPersist;
    HRESULT hres;

    // This means that this instance of CWebBrowserOC was created using
    // the ie30 CLSID and we were persisted from an old format stream.
    // Under this scenario, we have to write out a stream format that
    // can be read by the old ie30 object.
    if (fEmulateOldStream && pdwExtra)
    {
        // The only data we stream out that can't be read back in by
        // the old ie30 webbrowser is the dwExtra data.
        *pdwExtra = 0;
    }


    ZeroMemory(&sPersist, SIZEOF(sPersist));

    sPersist.ie30.cbSize = fEmulateOldStream ? SIZEOF(sPersist.ie30) : SIZEOF(sPersist);
    sPersist.ie30.sizeObject = *psizeObj;
    sPersist.ie30.fs = *pfs;
    sPersist.ie30.dwOffPersistLink = SIZEOF(sPersist);
    if (pvid)
    {
        sPersist.ie40.bRestoreView = TRUE;
        sPersist.ie40.vid = *pvid;
    }
    sPersist.ie40.dwExtra = pdwExtra ? *pdwExtra : 0;
    if (fOffline)
        sPersist.ie40.fFlags |= SVO_FLAGS_OFFLINE;
    if (fSilent)
        sPersist.ie40.fFlags |= SVO_FLAGS_SILENT;
    if (fRegisterAsBrowser)
        sPersist.ie40.fFlags |= SVO_FLAGS_REGISTERASBROWSER;
    if (fRegisterAsDropTarget)
        sPersist.ie40.fFlags |= SVO_FLAGS_REGISTERASDROPTGT;
    sPersist.ie40.dwVersion = SVO_VERSION;

    hres = pstm->Write(&sPersist, SIZEOF(sPersist), &cbWritten);
    IPSMSG3(TEXT("Save 1st Write(&_size) returned"), hres, cbWritten, sizeof(*psizeObj));
    if (SUCCEEDED(hres))
    {
        // Save plinkA
        ASSERT(plinkA);
        IPersistStream* ppstm;
        hres = plinkA->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
        if (SUCCEEDED(hres))
        {
            hres = ppstm->Save(pstm, TRUE);
            IPSMSG2(TEXT("Save plink->Save() returned"), hres);

            ppstm->Release();
        }
    }

    return hres;
}

BOOL CWebBrowserOC::_GetViewInfo(SHELLVIEWID* pvid)
{
    BOOL bGotView = FALSE;

    if (_psb)
    {
        if (_psb->GetShellView())
        {
            _psb->GetShellView()->GetCurrentInfo(&_fs);
        }
        else
        {
            _fs = _psb->_fldBase._fld._fs;
        }
        bGotView = FileCabinet_GetDefaultViewID2(&_psb->_fldBase, pvid);
    }
    
    return bGotView;
}

HRESULT CWebBrowserOC::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    LPITEMIDLIST pidl;
    SHELLVIEWID vid;
    BOOL bGotView;
    VARIANT_BOOL fOffline, fSilent, fRegDT;

    IPSMSG(TEXT("Save"));
    IS_INITIALIZED;

    pidl = NULL;
    if (_psb)
        pidl = _psb->_bbd._pidlCur;

    // we need an IShellLink to save with
    if (_plinkA == NULL)
    {
        hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &_plinkA));
        if (FAILED(hres))
            return hres;
    }
    _plinkA->SetIDList(pidl);

    bGotView = _GetViewInfo(&vid);

    DWORD dwExtra = 0;
#if 0
    if (_psb && _psb->_SaveToolbars(NULL)==S_OK) {
        dwExtra |= SVO_EXTRA_TOOLBARS;
    }
#endif

    get_Offline(&fOffline);
    get_Silent(&fSilent);
    get_RegisterAsDropTarget(&fRegDT);

    hres = CWebBrowserOC_SavePersistData(pstm, _fEmulateOldStream ? &_size : &_sizeHIM, &_fs, _plinkA,
            (bGotView ? &vid : NULL),
            fOffline, fSilent, _fShouldRegisterAsBrowser, fRegDT,
            _fEmulateOldStream, &dwExtra);

    ASSERT(!(dwExtra & SVO_EXTRA_TOOLBARS));
#if 0
    if (SUCCEEDED(hres) && (dwExtra & SVO_EXTRA_TOOLBARS)) 
    {
        // Remember the current location.
        ULARGE_INTEGER liStart;
        pstm->Seek(c_li0, STREAM_SEEK_CUR, &liStart);

        // Write the dummy size.
        DWORD dwTotal = 0;
        hres = pstm->Write(&dwTotal, SIZEOF(dwTotal), NULL);
        if (SUCCEEDED(hres)) {
            if (_psb)
                hres = _psb->_SaveToolbars(pstm);

            // Remember the end
            ULARGE_INTEGER liEnd;
            pstm->Seek(c_li0, STREAM_SEEK_CUR, &liEnd);

            // Seek back to the original location
            LARGE_INTEGER liT;
            liT.HighPart = 0;
            liT.LowPart = liStart.LowPart; 
            pstm->Seek(liT, STREAM_SEEK_SET, NULL);

            // Get the real dwTotal and write it
            dwTotal = liEnd.LowPart - liStart.LowPart;
            hres = pstm->Write(&dwTotal, SIZEOF(dwTotal), NULL);

            // Seek forward to the end
            liT.LowPart = liEnd.LowPart;
            pstm->Seek(liT, STREAM_SEEK_SET, NULL);
        }
    }
#endif

    if (fClearDirty)
    {
        _fDirty = FALSE;
    }

    return hres;
}

void CWebBrowserOC::_OnLoaded(BOOL fUpdateBrowserReadyState)
{
    IEFrameAuto * piefa;
    if (SUCCEEDED(_pauto->QueryInterface(IID_PPV_ARG(IEFrameAuto, &piefa))))
    {
        piefa->put_DefaultReadyState(READYSTATE_COMPLETE, fUpdateBrowserReadyState);
        piefa->Release();
    }
}

HRESULT CWebBrowserOC::InitNew(void)
{
    IPSMSG(TEXT("InitNew"));

    _InitDefault();

    // On the InitNew case, we do want to update the browser's ready state
    _OnLoaded(TRUE);

    return NOERROR;
}

// IPersistPropertyBag

static const struct {
    LPOLESTR pName;
    UINT     flag;
} g_boolprops[] = {
    {L"AutoArrange",        FWF_AUTOARRANGE},
    {L"NoClientEdge",       FWF_NOCLIENTEDGE},
    {L"AlignLeft",          FWF_ALIGNLEFT},
    {L"NoWebView",          FWF_NOWEBVIEW},
    {L"HideFileNames",      FWF_HIDEFILENAMES},
    {L"SingleClick",        FWF_SINGLECLICKACTIVATE},
    {L"SingleSelection",    FWF_SINGLESEL},
    {L"NoFolders",          FWF_NOSUBFOLDERS},
    {L"Transparent",        FWF_TRANSPARENT},
};

HRESULT CWebBrowserOC::Load(IPropertyBag *pBag, IErrorLog *pErrorLog)
{
    BOOL fOffline = FALSE;
    BOOL fSilent = FALSE;
    BOOL fRegisterAsBrowser = FALSE;
    BOOL fRegisterAsDropTgt = FALSE;
    BOOL fUpdateBrowserReadyState = TRUE;
    VARIANT_BOOL fAmbient;

    // It is illegal to call ::Load or ::InitNew more than once
    if (_fInit)
    {
        TraceMsg(TF_SHDCONTROL, "shv IPersistPropertyBag::Load called when ALREADY INITIALIZED!");
        ASSERT(FALSE);
        return E_FAIL;
    }

    _InitDefault();

    // grab all our DWORD-sized (VT_UI4) properties
    struct {
        LPOLESTR pName;
        DWORD*   pdw;
    } rgLoadProps[] = {
        {L"Height",         (DWORD *)&_size.cy},
        {L"Width",          (DWORD *)&_size.cx},
        {L"ViewMode",       (DWORD *)&_fs.ViewMode},
        {L"Offline",        (DWORD *)&fOffline},
        {L"Silent",         (DWORD *)&fSilent},
        {L"RegisterAsBrowser", (DWORD *)&fRegisterAsBrowser},
        {L"RegisterAsDropTarget", (DWORD *)&fRegisterAsDropTgt}
    };

    for (int i = 0; i < ARRAYSIZE(rgLoadProps); i++)
    {
        SHPropertyBag_ReadDWORD(pBag, rgLoadProps[i].pName, rgLoadProps[i].pdw);
    }

    // We let ambients take precedence over what we have persisted
    if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED, VT_BOOL, &fAmbient))
    {
        put_Offline(fAmbient);
    } 
    else
    {
        put_Offline(BOOL_TO_VARIANTBOOL(fOffline));
    }

    if (SUPERCLASS::_GetAmbientProperty(DISPID_AMBIENT_SILENT, VT_BOOL, &fAmbient))
    {
        put_Silent(fAmbient);
    }
    else
    {
        put_Silent(BOOL_TO_VARIANTBOOL(fSilent));
    }

    // If You use fOffline or fSilent after this, you will have to re-init them according 
    // to the returned values of fAmbient in the if statements above
    
    put_RegisterAsDropTarget(BOOL_TO_VARIANTBOOL(fRegisterAsDropTgt));

    _fShouldRegisterAsBrowser = VARIANTBOOL_TO_BOOL(fRegisterAsBrowser);

    // IE3 saved PIXEL size, IE4 saves HIMETRIC size
    DWORD lVal;
    HRESULT hr = SHPropertyBag_ReadDWORD(pBag, L"ExtentX", &lVal);
    if (SUCCEEDED(hr))
    {
        _sizeHIM.cx = lVal;
        hr = SHPropertyBag_ReadDWORD(pBag, L"ExtentY", &lVal);
        if (SUCCEEDED(hr))
        {
            _sizeHIM.cy = lVal;
        }
    }

    if (FAILED(hr))
    {
        // convert IE3 info to HIMETRIC
        _sizeHIM = _size;
        PixelsToMetric(&_sizeHIM);
    }

    hr = S_OK;

    for (i = 0; i < ARRAYSIZE(g_boolprops); i++)
    {
        if (SHPropertyBag_ReadBOOLDefRet(pBag, g_boolprops[i].pName, FALSE))
            _fs.fFlags |= g_boolprops[i].flag;
        else
            _fs.fFlags &= ~g_boolprops[i].flag;
    }

    // grab special properties

    if (_psb) // if no _psb then container ignored OLEMISC_SETCLIENTSITEFIRST
    {
        if (SUCCEEDED(SHPropertyBag_ReadGUID(pBag, L"ViewID", &_psb->_fldBase._fld._vidRestore)))
        {
            // we sucessfully read the ViewID, so this is a cache hit
            _psb->_fldBase._fld._dwViewPriority = VIEW_PRIORITY_CACHEHIT;
        }

        _psb->_fldBase._fld._fs = _fs;

        BSTR bstrVal;
        if (SUCCEEDED(SHPropertyBag_ReadBSTR(pBag, L"Location", &bstrVal)))
        {
            ASSERT(FALSE == _psb->_fAsyncNavigate);

            hr = WrapSpecialUrl(&bstrVal);
            if (SUCCEEDED(hr))
            {
                _psb->_fAsyncNavigate = TRUE;

                if (FAILED(Navigate(bstrVal, NULL, NULL, NULL, NULL)))
                {
                    TraceMsg(TF_SHDCONTROL, "Load PropertyBag Navigate FAILED!");
                }
                else
                {
                    // Navigate is successful (at least initially), let it update ReadyState
                    //
                    fUpdateBrowserReadyState = FALSE;
                }
                _psb->_fAsyncNavigate = FALSE;
            }
            SysFreeString(bstrVal);
        }
    }

    _OnLoaded(fUpdateBrowserReadyState);
 
    return hr;
}
HRESULT CWebBrowserOC::Save(IPropertyBag *pBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    IS_INITIALIZED;

    HRESULT hres;
    VARIANT var;
    int i;
    SHELLVIEWID vid;
    BOOL bGotView = FALSE;

    VARIANT_BOOL f;
    BOOL fOffline;
    BOOL fSilent;
    BOOL fRegisterAsDropTgt;
    BOOL fRegisterAsBrowser;
    
    get_Offline(&f);
    fOffline = f ? TRUE : FALSE;
    get_Silent(&f);
    fSilent = f ? TRUE : FALSE;
    get_RegisterAsDropTarget(&f);
    fRegisterAsDropTgt = f ? TRUE : FALSE;
    fRegisterAsBrowser = _fShouldRegisterAsBrowser ? TRUE : FALSE;

    // our state may have changed
    bGotView = _GetViewInfo(&vid);

    // save all our DWORD-sized properties
    struct {
        LPOLESTR pName;
        DWORD*   pdw;
    } rgLoadProps[] = {
        {L"ExtentX",        (DWORD *)&_sizeHIM.cx},
        {L"ExtentY",        (DWORD *)&_sizeHIM.cy},
        {L"ViewMode",       (DWORD *)&_fs.ViewMode},
        {L"Offline",        (DWORD *)&fOffline},
        {L"Silent",         (DWORD *)&fSilent},
        {L"RegisterAsBrowser", (DWORD *)&fRegisterAsBrowser},
        {L"RegisterAsDropTarget", (DWORD *)&fRegisterAsDropTgt},

        // IE3 OC stuff here
        {L"Height",         (DWORD *)&_size.cy},
        {L"Width",          (DWORD *)&_size.cx}
    };
    VariantInit(&var);
    var.vt = VT_I4; // VB doesn't understand VT_UI4! (pBag->Write succeeds,
                    // but it doesn't write anything! The load then fails!)
    int nCount = ARRAYSIZE(rgLoadProps);
    if (_pObjectInfo->lVersion != VERSION_1)
        nCount -= 2;

    for (i = 0; i < nCount; i++)
    {
        var.lVal = *rgLoadProps[i].pdw;
        hres = pBag->Write(rgLoadProps[i].pName, &var);
        if (FAILED(hres))
        {
            TraceMsg(TF_SHDCONTROL, "Save PropertyBag could not save %ws for DWORD", rgLoadProps[i].pName);
            return hres;
        }
    }

    // save all our _fs.fFlags (VT_BOOL) flags
    var.vt = VT_BOOL;
    for (i = 0; i < ARRAYSIZE(g_boolprops); i++)
    {
        var.boolVal = BOOL_TO_VARIANTBOOL(_fs.fFlags & g_boolprops[i].flag);
        hres = pBag->Write(g_boolprops[i].pName, &var);
        if (FAILED(hres))
        {
            TraceMsg(TF_SHDCONTROL, "Load PropertyBag did not save %ws for BOOL", g_boolprops[i].pName);
        }
    }

    // save special properties

    if (bGotView)
    {
        SHPropertyBag_WriteGUID(pBag, L"ViewID", &(GUID)vid);
    }

    var.vt = VT_BSTR;
    if (SUCCEEDED(get_LocationURL(&var.bstrVal)))
    {
        hres = pBag->Write(L"Location", &var);

        VariantClear(&var);

        if (FAILED(hres))
        {
            TraceMsg(TF_SHDCONTROL, "Save PropertyBag could not save Location");
            return hres;
        }
    }
    else
    {
        var.vt = VT_EMPTY;
        TraceMsg(TF_SHDCONTROL, "Save PropertyBag get_Location FAILED!");
    }

    return NOERROR;
}


// IPersistString

STDMETHODIMP CWebBrowserOC::Initialize(LPCWSTR pwszInit)
{
    HRESULT hr = E_OUTOFMEMORY;
    BSTR bstr = SysAllocString(pwszInit);
    if (bstr)
    {
        hr = Navigate(bstr, NULL, NULL, NULL, NULL);
        SysFreeString(bstr);
    }
    return hr;
}


#define THISCLASS CWebBrowserOC
HRESULT CWebBrowserOC::v_InternalQueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IWebBrowser2),
        QITABENTMULTI(THISCLASS, IDispatch, IWebBrowser2), // VBA QI's IDispatch and assumes it gets the "default" automation interface, which is IWebBrowser2
        QITABENTMULTI(THISCLASS, IWebBrowser, IWebBrowser2),
        QITABENTMULTI(THISCLASS, IWebBrowserApp, IWebBrowser2),
        QITABENT(THISCLASS, IPersistString),
        QITABENT(THISCLASS, IOleCommandTarget),
        QITABENT(THISCLASS, IObjectSafety),
        QITABENT(THISCLASS, ITargetEmbedding),
        QITABENT(THISCLASS, IExpDispSupport),
        QITABENT(THISCLASS, IExpDispSupportOC),
        QITABENT(THISCLASS, IPersistHistory),
        QITABENT(THISCLASS, IPersistStorage),
        { 0 },
    };
    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
    {
        hres = SUPERCLASS::v_InternalQueryInterface(riid, ppvObj);

        // we want to expose our aggregated CIEFrameAuto's interfaces
        // in addition to ours.
        if (FAILED(hres))
        {
            hres = _pauto->QueryInterface(riid, ppvObj);
        }
    }

    return hres;
}

// *** IOleInPlaceActiveObject ***
HRESULT CWebBrowserOC::OnFrameWindowActivate(BOOL fActivate)
{
    if (_psb)
        _psb->OnFrameWindowActivateBS(fActivate);
        
    return S_OK;
}

HRESULT CWebBrowserOC::TranslateAccelerator(LPMSG lpMsg)
{
    if (_psb)
    {
        // FEATURE REVIEW: what wID should we really pass? Is 0 ok?
        if (S_OK == _psb->_TranslateAccelerator(lpMsg, 0, DIRECTION_FORWARD_TO_CHILD))
            return S_OK;
    }
    else
    {
        IOIPAMSG(TEXT("TranslateAccelerator cannot forward to _psb"));
    }

    // SUPERCLASS has no accelerators
    return S_FALSE;
}

HRESULT CWebBrowserOC::EnableModeless(BOOL fEnable)
{
    SUPERCLASS::EnableModeless(fEnable);
    if (_psb)
    {
        return _psb->_EnableModeless(fEnable, DIRECTION_FORWARD_TO_CHILD);
    }
    else
    {
        IOIPAMSG(TEXT("EnableModeless cannot forward to _psb"));
        return S_OK;
    }
}


HRESULT CWebBrowserOC::_OnActivateChange(IOleClientSite* pActiveSite, UINT uState)
{
    HRESULT hres = SUPERCLASS::_OnActivateChange(pActiveSite, uState);

    if (SUCCEEDED(hres))
    {
        UINT uViewState;

        switch (uState)
        {
        case OC_DEACTIVE:       uViewState = SVUIA_DEACTIVATE; break;
        case OC_INPLACEACTIVE:  uViewState = SVUIA_INPLACEACTIVATE; break;
        case OC_UIACTIVE:       uViewState = SVUIA_ACTIVATE_FOCUS; break;
        default:                ASSERT(FALSE); return E_INVALIDARG;
        }

        if (_psb)
            _psb->_UIActivateView(uViewState);
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "shv _OnActivateChange failed, _psb=0x%x", _psb);
    }

    return hres;
}

void CWebBrowserOC::_OnInPlaceActivate(void)
{
    HWND       hwnd = NULL;

    SUPERCLASS::_OnInPlaceActivate();

    _RegisterWindow();

    if (_pipsite)
    {

        // we have to hold on to the target frame until we deactivate,
        // because the psbFrame will delete this thing when it shuts down
        // *before* we are actually deactivated, leaking the unadvise
        // in ieframeauto.
        ASSERT(NULL==_pTargetFramePriv);
        if (SUCCEEDED(IUnknown_QueryService(_pipsite, IID_ITargetFrame2, IID_PPV_ARG(ITargetFramePriv, &_pTargetFramePriv))))
        {
            _pTargetFramePriv->OnChildFrameActivate(SAFECAST(this, IConnectionPointContainer* ));
        }

        ASSERT(NULL==_pctContainer);
        if (FAILED(_pipsite->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_pctContainer))))
        {
            // NT 305187 discover.exe crash on exit when _pcli is NULL
            if (_pcli) 
            {
                // APPCOMPAT: It should be on IOleInPlaceSite,
                // but MSHTML currently has it on IOleContainer.
                IOleContainer *pCont;
                if (SUCCEEDED(_pcli->GetContainer(&pCont)))
                {
                    pCont->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_pctContainer));
                    pCont->Release();
                }
            }
        }

        if (_pipframe && SUCCEEDED(_pipframe->GetWindow(&hwnd)))
        {
            // Check to see if our inplace frame is VB5.  If so, we have to hack around 
            // _pipframe->EnableModeless calls
            //
            const TCHAR VBM_THUNDER[] = TEXT("Thunder");
            TCHAR strBuf[VB_CLASSNAME_LENGTH];

            // Check to see if the inplace frame we just called is VB5's forms engine.
            //
            memset(strBuf, 0, ARRAYSIZE(strBuf));    // Clear the buffer
            GetClassName(hwnd, strBuf, (VB_CLASSNAME_LENGTH - 1));  // Get the class name of the window.
            if (StrCmpN(strBuf, VBM_THUNDER, (sizeof(VBM_THUNDER)/sizeof(TCHAR))-1) == 0)   // Is the first part "Thunder"?
            {
                _fHostedInVB5 = TRUE;
            }
        }

        {
            //
            // App compat:  Check for imagineer technical
            //

            const WCHAR STR_IMAGINEER[] = L"imagine.exe";
            WCHAR szBuff[MAX_PATH];

            if (GetModuleFileName(NULL, szBuff, ARRAYSIZE(szBuff)))
            {
                LPWSTR pszFile = PathFindFileName(szBuff);

                if (pszFile)
                {
                    _fHostedInImagineer = (0 == StrNCmpI(pszFile, STR_IMAGINEER,
                                                 ARRAYSIZE(STR_IMAGINEER) - 1));
                }
            }
        }
    }
    else
    {
        IOIPAMSG(TEXT("_OnInPlaceActivate doesn't have pipsite!"));
    }
}

void CWebBrowserOC::_OnInPlaceDeactivate(void)
{
    _UnregisterWindow();

    if (_pTargetFramePriv)
    {
        _pTargetFramePriv->OnChildFrameDeactivate(SAFECAST(this, IConnectionPointContainer*));
        ATOMICRELEASE(_pTargetFramePriv);
    }

    ATOMICRELEASE(_pctContainer);

    SUPERCLASS::_OnInPlaceDeactivate();
}


/*
 ** Ambient properties we care about
 */

// We forward IOleControl calls to the docobj.
// This helper function returns the docobj's IOleControl interface.
//
// NOTE: we may want to fail this when the WebBrowserOC was created
//       using IE3's classid just to be safe...
//
IOleControl* GetForwardingIOC(IWebBrowser* pwb)
{
    IOleControl* poc = NULL;
    IDispatch* pdisp;

    if (SUCCEEDED(pwb->get_Document(&pdisp)))
    {
        pdisp->QueryInterface(IID_PPV_ARG(IOleControl, &poc));

        pdisp->Release();
    }

    return poc;
}
STDMETHODIMP CWebBrowserOC::GetControlInfo(LPCONTROLINFO pCI)
{
    HRESULT hres = E_NOTIMPL;

    // REVIEW: What if we return some docobjects CONTROLINFO here and
    //         we navigate somewhere else. Do we have to know when this
    //         happens and tell our container that the CONTROLINFO has
    //         changed??

    IOleControl* poc = GetForwardingIOC(_pautoWB2);
    if (poc)
    {
        hres = poc->GetControlInfo(pCI);
        poc->Release();
    }

    return hres;
}
STDMETHODIMP CWebBrowserOC::OnMnemonic(LPMSG pMsg)
{
    HRESULT hres = E_NOTIMPL;

    IOleControl* poc = GetForwardingIOC(_pautoWB2);
    if (poc)
    {
        hres = poc->OnMnemonic(pMsg);
        poc->Release();
    }

    return hres;
}
HRESULT __stdcall CWebBrowserOC::OnAmbientPropertyChange(DISPID dispid)
{
    IS_INITIALIZED;

    // First let our base class know about the change
    //
    SUPERCLASS::OnAmbientPropertyChange(dispid);

    // Forward ambient property changes down to the docobject
    // if it is something other than offline or silent
    // for offline and silent, we call the methods to set
    // the properties so that we remember it and these 
    // methods forward downwards on their own and so we we
    // end up forwarding twice. 

    if((dispid == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED) || (dispid == DISPID_AMBIENT_SILENT))
    {
        VARIANT_BOOL fAmbient;
        if (SUPERCLASS::_GetAmbientProperty(dispid, VT_BOOL, &fAmbient))
        {
            if (dispid == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED)
            {
                put_Offline(fAmbient);
            } 
            else if(dispid == DISPID_AMBIENT_SILENT) 
            {
                put_Silent(fAmbient);
            }
        }
        // return ; // BharatS 01/20/97
        // APPCOMPAT --- This could be avoided if the forwarding
        // from simply calling put_offline worked fine but it does not
        // and so the second forwarding can be removed when that is fixed


    }
    IOleControl* poc = GetForwardingIOC(_pautoWB2);
    if (poc)
    {
        poc->OnAmbientPropertyChange(dispid);
        poc->Release();
    }

    return S_OK;
}
STDMETHODIMP CWebBrowserOC::FreezeEvents(BOOL bFreeze)
{
    // First let our base class know about the change
    //
    SUPERCLASS::FreezeEvents(bFreeze);

    // Forward this down to the docobject
    //
    IOleControl* poc = GetForwardingIOC(_pautoWB2);

    // delegate only if the freezeevents count is balanced when
    // you receive a FALSE. There may be FALSE calls coming in,
    // before we get a chance to delegate the pending freezeevents calls
    // TRUE is always delegated.
    if (poc && (bFreeze || (_cPendingFreezeEvents == 0)))
    {
        poc->FreezeEvents(bFreeze);
    }
    else
    {
        // keeping a total number of FreezeEvents(TRUE) calls 
        // that we have to make up for.
        if ( bFreeze )
        {
            _cPendingFreezeEvents++;
        }
        else 
        {
            // Don't let this go negative, otherwise we'll send 4 billion FreezeEvents(TRUE) 
            // to the DocObject in CWebBrowserOC::_OnSetShellView. (QFE [alanau])(ferhane)
            if (EVAL(_cPendingFreezeEvents > 0))
            {
                _cPendingFreezeEvents --;
            }        
        }
    }

    if (poc)
        poc->Release();

    return S_OK;
}

// CWebBrowserSB just started viewing psvNew - do our OC stuff now
//
void CWebBrowserOC::_OnSetShellView(IShellView* psvNew)
{
    _fDirty = TRUE;
    // NOTE: Document, Type, LocationName, LocationURL, Busy just changed...
    // PropertyChanged(DISPID_LOCATION);
    // NOTE: that is the job of the CBaseBrowser to tell us really.
    //    ideally we would not put this here at all (or in _OnReleaseShellV...
    _SendAdvise(OBJECTCODE_DATACHANGED);    // implies OBJECTCODE_VIEWCHANGED

    // we might have received FreezeEvents(TRUE) calls from the container
    // and if the document was not ready, we might not have had a chance
    // to pass them down the stream. This is the time to make up for it.

    if (_cPendingFreezeEvents > 0)
    {
        IOleControl* poc = GetForwardingIOC(_pautoWB2);

        if (poc)
        {
            for ( ; _cPendingFreezeEvents > 0; _cPendingFreezeEvents-- )
            {
                // Forward this down to the docobject
                poc->FreezeEvents(TRUE);
            }

            poc->Release();
        }
    }
}

// CWebBrowserSB is releasing the currently viewed IShellView
void CWebBrowserOC::_OnReleaseShellView()
{
}


// *** IOleCommandTarget
//
// our version simply forwards to the object below our CWebBrowserSB
//
HRESULT CWebBrowserOC::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (_psb && _psb->_bbd._pctView)
        return _psb->_bbd._pctView->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);

    return OLECMDERR_E_UNKNOWNGROUP;
}
HRESULT CWebBrowserOC::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    if (_psb) 
    {
        if (pguidCmdGroup==NULL) 
        {
            switch(nCmdID) 
            {
            case OLECMDID_STOP:
                {
                    LPITEMIDLIST pidlIntended = (_psb->_bbd._pidlPending) ? ILClone(_psb->_bbd._pidlPending) : NULL;
                    _psb->_CancelPendingNavigation();

                    // We've just canceled the pending navigation.  We may not have a current page!  The following
                    // accomplishes two goals:
                    //
                    //  1.  Gives the user some information about the frame that couldn't navigate.
                    //  2.  Allows the browser to reach READYSTATE_COMPLETE
                    //
                    if (!_psb->_bbd._pidlCur)
                    {
                        // We display the navcancl.htm page in most cases.
                        // However, we won't display it if the call has 
                        // explicitly specified that we shouldn't.
                        //
                        if (  !pvarargIn
                           || V_VT(pvarargIn) != VT_BOOL
                           || V_BOOL(pvarargIn) == VARIANT_TRUE)
                        {
                            TCHAR   szResURL[MAX_URL_STRING];

                            hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                                   HINST_THISDLL,
                                                   ML_CROSSCODEPAGE,
                                                   TEXT("navcancl.htm"),
                                                   szResURL,
                                                   ARRAYSIZE(szResURL),
                                                   TEXT("shdocvw.dll"));
                            if (SUCCEEDED(hr))
                            {
                                _psb->_ShowBlankPage(szResURL, pidlIntended);
                            }
                        }
                    }

                    if(pidlIntended)
                        ILFree(pidlIntended);
                    break;  // Note that we need to fall through.
                }

            case OLECMDID_ENABLE_INTERACTION:
                if (pvarargIn && pvarargIn->vt == VT_I4) 
                {
                    _psb->_fPausedByParent = BOOLIFY(pvarargIn->lVal);
                }
                break;  // Note that we need to fall through.
            }

            hr = S_OK;
            // WARNING: fall through to forward down 
        }
        if (_psb->_bbd._pctView)
            hr = _psb->_bbd._pctView->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    return hr;
}

//
//  We hit this code if the normal IOleCommandTarget chain is broken (such as
// browser band in the browser bar). In this case, we get the command target
// to the top level browser and send OLECMDID_SETDOWNLOADSTATE to it.
//
// Returns:
//      S_OK    If we found the top level browser and it processed it.
//      hresRet Otherwise
//
HRESULT CWebBrowserOC::_SetDownloadState(HRESULT hresRet, DWORD nCmdexecopt, VARIANTARG *pvarargIn)
{
    ASSERT(hresRet == OLECMDERR_E_UNKNOWNGROUP || hresRet == OLECMDERR_E_NOTSUPPORTED);

    IOleCommandTarget* pcmdtTop;
    if (_psb && SUCCEEDED(_psb->_QueryServiceParent(SID_STopLevelBrowser, IID_PPV_ARG(IOleCommandTarget, &pcmdtTop)))) 
    {
        ASSERT(pcmdtTop != _psb);
        VARIANTARG var;
        if (pvarargIn && pvarargIn->lVal) 
        {
            ASSERT(pvarargIn->vt == VT_I4 || pvarargIn->vt == VT_BOOL || pvarargIn->vt == VT_UNKNOWN);
            //
            // Notice that we pass the pointer to this OC so that the top
            // level browser can keep track of it. This is a new behavior
            // which is different from IE 3.0. 
            //
            var.vt = VT_UNKNOWN;
            var.punkVal = SAFECAST(this, IOleCommandTarget*);
        }
        else
        {
            var.vt = VT_BOOL;
            var.lVal = FALSE;
        }
        HRESULT hresT = pcmdtTop->Exec(NULL, OLECMDID_SETDOWNLOADSTATE, nCmdexecopt, &var, NULL);

        TraceMsg(DM_FORSEARCHBAND, "WBOC::_SetDownloadState pcmdTop->Exec returned %x", hresT);

        if (SUCCEEDED(hresT)) 
        {
            hresRet = S_OK;
        }
        pcmdtTop->Release();
    } 
    else 
    {
        TraceMsg(DM_FORSEARCHBAND, "WBOC::_SetDownloadState can't find the top guy");
    }

    return hresRet;
}

#if 0 // not sure if this is correct, waiting for reply from OLEPSS alias
// VB is not happy if we fail a property get, so when an IDispatch
// is not safe we return an instance of this dummy IDispatch
class CDispatchDummy : public IDispatch
{
public:
    CDispatchDummy() { m_cRef=1; DllAddRef(); };
    ~CDispatchDummy() { DllRelease(); };

    // IUnknown methods
    STDMETHOD(QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount) (unsigned int *pctinfo)
        { return E_FAIL; };
    STDMETHOD(GetTypeInfo) (unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return E_FAIL; };
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, unsigned int cNames, LCID lcid, DISPID * rgdispid)
        { return E_FAIL; };
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,VARIANT * pvarResult,EXCEPINFO * pexcepinfo,UINT * puArgErr)
        { return E_FAIL; };

protected:
    ULONG m_cRef;
};

HRESULT CDispatchDummy::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = SAFECAST(this, IDispatch*);
        return S_OK;
    }

    return E_NOINTERFACE;
}
ULONG CDispatchDummy::AddRef(THIS)
{
    return ++m_cRef;
}
ULONG CDispatchDummy::Release(THIS)
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CreateDummyDispatch(IDispatch** ppDisp)
{
    HRESULT hres = E_OUTOFMEMORY;

    CDispatchDummy* pdisp = new(CDispatchDummy);
    if (pdisp)
    {
        hres = pdisp->QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));
        pdisp->Release();
    }

    return hres;
}
#endif


#ifdef FEATURE_FRAMES

// *** ITargetEmedding ***

HRESULT CWebBrowserOC::GetTargetFrame(ITargetFrame **ppTargetFrame)
{
    if (_psb)
    {
        return _psb->QueryServiceItsOwn(IID_ITargetFrame2, IID_PPV_ARG(ITargetFrame, ppTargetFrame));
    }
    else
    {
        *ppTargetFrame = NULL;
        return E_FAIL;
    }
}

#endif

// *** CImpIConnectionPoint override ***
CConnectionPoint* CWebBrowserOC::_FindCConnectionPointNoRef(BOOL fdisp, REFIID iid)
{
    CConnectionPoint *pccp;

    // Warning: Some apps (MSDN for one) passes in IID_IDispatch and
    // expect the ole events.  So we need to be careful on which one we return.
    //
    if (fdisp && IsEqualIID(iid, IID_IDispatch))
    {
        if (_pObjectInfo->lVersion == VERSION_1)
            pccp = &m_cpWB1Events;
        else
            pccp = &m_cpEvents;
    }

    else if (IsEqualIID(iid, DIID_DWebBrowserEvents2))
    {
        pccp = &m_cpEvents;
    }
    else if (IsEqualIID(iid, DIID_DWebBrowserEvents))
    {
        pccp = &m_cpWB1Events;
    }
    else if (IsEqualIID(iid, IID_IPropertyNotifySink))
    {
        pccp = &m_cpPropNotify;
    }
    else
    {
        pccp = NULL;
    }

    return pccp;
}

STDMETHODIMP CWebBrowserOC::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 3,
                m_cpEvents.CastToIConnectionPoint(),
                m_cpWB1Events.CastToIConnectionPoint(),
                m_cpPropNotify.CastToIConnectionPoint());
}



/*
** Properties and Methods we implement
*/

// Invoke perf
//
HRESULT CWebBrowserOC::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hres = S_OK;

    // we should probably check that riid is IID_NULL...

   _fInsideInvokeCall = TRUE;   // we're inside an invoke

    switch (dispidMember)
    {
    // handle ReadyState immediately for performance (avoid oleaut a tad longer)...
    case DISPID_READYSTATE:
        ASSERT(pdispparams && pdispparams->cArgs==0);
        if (EVAL(pvarResult) && (wFlags & DISPATCH_PROPERTYGET))
        {
            ZeroMemory(pvarResult, SIZEOF(*pvarResult));
            pvarResult->vt = VT_I4;
            hres = get_ReadyState((READYSTATE*)(&pvarResult->lVal));
            goto Cleanup;
        }
        break; // let the below invoke call give us the proper error value

    // forward these two down to our embedded object so that
    // Trident can handle cross-frame security correctly
    case DISPID_SECURITYCTX:
    case DISPID_SECURITYDOMAIN:
    {
        IDispatch* pdisp;
        if (SUCCEEDED(_pautoWB2->get_Document(&pdisp)))
        {
            hres = pdisp->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            pdisp->Release();
            goto Cleanup;
        }

        break;
    }

    default:
        // handle the default after the switch.
        break;
    }

    hres = CShellOcx::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

Cleanup:

   _fInsideInvokeCall = FALSE;   // We are leaving the invoke

    return hres;
}


// IObjectSafety override so script can't talk to us from an unsafe zone
HRESULT CWebBrowserOC::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    HRESULT hr = CObjectSafety::SetInterfaceSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);

    // If we are hosted in IEXPLORER.EXE or EXPLORER.EXE (eventually this should be the default, but we need longer app-compat simmer time)
    // And we can get a URL from our parent
    // And the policy for that URL is "disable WebOC script access" (default for internet zone)
    if (GetModuleHandle(TEXT("EXPLORER.EXE")) || GetModuleHandle(TEXT("IEXPLORE.EXE")))
    {
        IHTMLDocument2 *pHtmlDoc;
        if (SUCCEEDED(GetHTMLDoc2(_pcli, &pHtmlDoc))) // if the parent isn't trident, then we must be client-side code hosting weboc directly - no need to bail
        {
            BSTR bstrURL;
            if (SUCCEEDED(pHtmlDoc->get_URL(&bstrURL)))
            {
                DWORD dwPolicy = 0;
                DWORD dwContext = 0;

                ZoneCheckUrlEx(bstrURL, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                               URLACTION_ACTIVEX_NO_WEBOC_SCRIPT, 0, NULL);

                if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                {
                    // Then we don't support script access - override whatever we were told above.
                    hr = E_ACCESSDENIED;
                }

                SysFreeString(bstrURL);
            }
            pHtmlDoc->Release();
        }
    }

    return hr;
}


//
// Wrap around iedisp
//

#define WRAP_WB2(fn, args, nargs) \
    HRESULT CWebBrowserOC :: fn args { return _pautoWB2-> fn nargs; }
#define WRAP_WB2_DESIGN(fn, args, nargs) \
    HRESULT CWebBrowserOC :: fn args { if (_IsDesignMode()) return E_FAIL; else return _pautoWB2-> fn nargs; }

// IWebBrowser methods
//
WRAP_WB2_DESIGN(GoBack, (), ())
WRAP_WB2_DESIGN(GoForward, (), ())
WRAP_WB2_DESIGN(GoHome, (), ())
WRAP_WB2_DESIGN(GoSearch, (), ())
WRAP_WB2_DESIGN(Refresh, (), ())
WRAP_WB2_DESIGN(Refresh2, (VARIANT * Level), (Level))
WRAP_WB2_DESIGN(Stop, (), ())
WRAP_WB2(get_Type, (BSTR * pbstrType), (pbstrType))
WRAP_WB2(get_LocationName, (BSTR * pbstrLocationName), (pbstrLocationName))
WRAP_WB2(get_LocationURL, (BSTR * pbstrLocationURL), (pbstrLocationURL))
WRAP_WB2(get_Busy, (VARIANT_BOOL * pBool), (pBool))

HRESULT CWebBrowserOC::Navigate(BSTR      URL,
                        VARIANT * Flags,
                        VARIANT * TargetFrameName,
                        VARIANT * PostData,
                        VARIANT * Headers)
{
    HRESULT hr = S_OK;

    if (_dwSafetyOptions)
    {
        hr = WrapSpecialUrl(&URL);
        if (SUCCEEDED(hr))
        {
            if (!AccessAllowedToNamedFrame(TargetFrameName))
                hr = E_ACCESSDENIED;
            else
                hr = _pautoWB2->Navigate(URL, Flags, TargetFrameName, PostData, Headers);
        }
    }
    else
        hr = _pautoWB2->Navigate(URL, Flags, TargetFrameName, PostData, Headers);

    return hr;
}

HRESULT CWebBrowserOC::get_Application(IDispatch **ppDisp)
{
    PROPMSG(TEXT("get_Application"));
    return QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));
}

HRESULT CWebBrowserOC::get_Parent(IDispatch **ppDisp)
{
    HRESULT hres = E_FAIL;
    PROPMSG(TEXT("get_Parent"));

    if (ppDisp)
        *ppDisp = NULL;

    if (_pcli)
    {
        IOleContainer* pContainer;

        hres = _pcli->GetContainer(&pContainer);
        if (SUCCEEDED(hres))
        {
            hres = pContainer->QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));

            if (SUCCEEDED(hres) && _dwSafetyOptions)
                hres = MakeSafeForScripting((IUnknown**)ppDisp);

            pContainer->Release();
        }
        else
        {
            PROPMSG(TEXT("get_Parent couldn't find the container!"));
        }
    }
    else
    {
        PROPMSG(TEXT("get_Parent does not have _pcli!"));
    }

    // if there was an error *ppDisop is NULL, and so VB realizes 
    // this is a "nothing" dispatch -- returning failure causes 
    // error boxes to appear. ugh.

    return S_OK;
}
HRESULT CWebBrowserOC::get_Container(IDispatch **ppDisp)
{
    // Container property is "same as parent" unless there is no parent.
    // Since we always have a parent, let get_Parent handle this.
    PROPMSG(TEXT("get_Containter passing off to get_Parent"));
    return get_Parent(ppDisp);
}
HRESULT CWebBrowserOC::get_Document(IDispatch **ppDisp)
{
    HRESULT hres = _pautoWB2->get_Document(ppDisp);

    if (FAILED(hres) && ppDisp)
    {
        *ppDisp = NULL;
    }

    if (SUCCEEDED(hres) && _dwSafetyOptions)
        hres = MakeSafeForScripting((IUnknown**)ppDisp);


    // if there was an error *ppDisop is NULL, and so VB realizes 
    // this is a "nothing" dispatch -- returning failure causes 
    // error boxes to appear. ugh.

    return S_OK;
}

HRESULT CWebBrowserOC::get_TopLevelContainer(VARIANT_BOOL * pBool)
{
    PROPMSG(TEXT("get_TopLevelContainer"));

    if (!pBool)
        return E_INVALIDARG;

    *pBool = FALSE;

    return S_OK;
}


void FireEvent_OnSetWindowPos(IUnknown *punkCPContainer, DISPID dispid, long lValue)
{
    VARIANTARG args[1];
    IUnknown_CPContainerInvokeParam(punkCPContainer, DIID_DWebBrowserEvents2,
                                    dispid, args, 1, VT_I4, lValue);
}

HRESULT CWebBrowserOC::get_Left(long * pl)
{
    *pl = _rcPos.left;
    return S_OK;
}
HRESULT CWebBrowserOC::put_Left(long Left)
{
    FireEvent_OnSetWindowPos(_pautoEDS, DISPID_WINDOWSETLEFT, Left);

    if (_pipsite)
    {
        RECT rc = _rcPos;
        rc.left = Left;

        return _pipsite->OnPosRectChange(&rc);
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "put_Left has no _pipsite to notify!");
        return E_UNEXPECTED;
    }
}
HRESULT CWebBrowserOC::get_Top(long * pl)
{
    *pl = _rcPos.top;
    return S_OK;
}
HRESULT CWebBrowserOC::put_Top(long Top)
{
    FireEvent_OnSetWindowPos(_pautoEDS, DISPID_WINDOWSETTOP, Top);

    if (_pipsite)
    {
        RECT rc = _rcPos;
        rc.top = Top;

        return(_pipsite->OnPosRectChange(&rc));
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "put_Top has no _pipsite to notify!");
        return(E_UNEXPECTED);
    }
}
HRESULT CWebBrowserOC::get_Width(long * pl)
{
    *pl = _rcPos.right - _rcPos.left;
    return S_OK;
}
HRESULT CWebBrowserOC::put_Width(long Width)
{
    FireEvent_OnSetWindowPos(_pautoEDS, DISPID_WINDOWSETWIDTH, Width);

    if (_pipsite)
    {
        RECT rc = _rcPos;
        rc.right = rc.left + Width;

        return(_pipsite->OnPosRectChange(&rc));
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "put_Width has no _pipsite to notify!");
        return(E_UNEXPECTED);
    }
}
HRESULT CWebBrowserOC::get_Height(long * pl)
{
    *pl = _rcPos.bottom - _rcPos.top;
    return S_OK;
}
HRESULT CWebBrowserOC::put_Height(long Height)
{
    FireEvent_OnSetWindowPos(_pautoEDS, DISPID_WINDOWSETHEIGHT, Height);

    if (_pipsite)
    {
        RECT rc = _rcPos;
        rc.bottom = rc.top + Height;

        return(_pipsite->OnPosRectChange(&rc));
    }
    else
    {
        TraceMsg(TF_SHDCONTROL, "put_Height has no _pipsite to notify!");
        return(E_UNEXPECTED);
    }
}

// IWebBrowserApp methods
//
WRAP_WB2_DESIGN(PutProperty, (BSTR szProperty, VARIANT vtValue), (szProperty, vtValue))
WRAP_WB2_DESIGN(GetProperty, (BSTR szProperty, VARIANT * pvtValue), (szProperty, pvtValue))
WRAP_WB2(get_FullName, (BSTR * pbstrFullName), (pbstrFullName))
WRAP_WB2(get_Path, (BSTR * pbstrPath), (pbstrPath))

HRESULT CWebBrowserOC::Quit()
{
    return E_FAIL;
}
HRESULT CWebBrowserOC::ClientToWindow(int * pcx, int * pcy)
{
    LONG lX = *pcx, lY = *pcy;

    VARIANTARG args[2];
    IUnknown_CPContainerInvokeParam(_pautoEDS, DIID_DWebBrowserEvents2,
                                    DISPID_CLIENTTOHOSTWINDOW, args, 2, 
                                    VT_I4 | VT_BYREF, &lX,
                                    VT_I4 | VT_BYREF, &lY);
    *pcx = lX;
    *pcy = lY;

    return S_OK;
}
HRESULT CWebBrowserOC::get_Name(BSTR * pbstrName)
{
    *pbstrName = LoadBSTR(IDS_SHELLEXPLORER);
    return *pbstrName ? S_OK : E_OUTOFMEMORY;
}
HRESULT CWebBrowserOC::get_HWND(LONG_PTR * pHWND)
{
    *pHWND = NULL;
    return E_FAIL;
}

HRESULT CWebBrowserOC::get_FullScreen(VARIANT_BOOL * pBool)
{
    *pBool = BOOL_TO_VARIANTBOOL(_fFullScreen);
    return S_OK;
}
HRESULT CWebBrowserOC::put_FullScreen(VARIANT_BOOL Value)
{
    _fFullScreen = VARIANTBOOL_TO_BOOL(Value);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONFULLSCREEN, Value);
    return S_OK;
}
HRESULT CWebBrowserOC::get_Visible(VARIANT_BOOL * pBool)
{
    *pBool = BOOL_TO_VARIANTBOOL(_fVisible);
    return S_OK;
}
HRESULT CWebBrowserOC::put_Visible(VARIANT_BOOL Value)
{
    _fVisible = VARIANTBOOL_TO_BOOL(Value);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONVISIBLE, Value);
    return S_OK;
}
HRESULT CWebBrowserOC::get_StatusBar(VARIANT_BOOL * pBool)
{
    *pBool = BOOL_TO_VARIANTBOOL(!_fNoStatusBar);
    return S_OK;
}
HRESULT CWebBrowserOC::put_StatusBar(VARIANT_BOOL Value)
{
    _fNoStatusBar = !VARIANTBOOL_TO_BOOL(Value);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONSTATUSBAR, Value);
    return S_OK;
}
HRESULT CWebBrowserOC::get_StatusText(BSTR * pbstr)
{
    *pbstr = NULL;
    return E_FAIL;
}
HRESULT CWebBrowserOC::put_StatusText(BSTR bstr)
{
    return E_FAIL;
}
HRESULT CWebBrowserOC::get_ToolBar(int * pBool)
{
    // BOGUS: variant values for int type
    *pBool = (!_fNoToolBar) ? VARIANT_TRUE : VARIANT_FALSE; 
    return S_OK;
}
HRESULT CWebBrowserOC::put_ToolBar(int iToolbar)
{
    _fNoToolBar = (!iToolbar) ? TRUE : FALSE;
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONTOOLBAR, iToolbar);
    return S_OK;
}
HRESULT CWebBrowserOC::get_MenuBar(VARIANT_BOOL * pvbMenuBar)
{
    *pvbMenuBar = BOOL_TO_VARIANTBOOL(!_fNoMenuBar);
    return S_OK;
}
HRESULT CWebBrowserOC::put_MenuBar(VARIANT_BOOL vbMenuBar)
{
    _fNoMenuBar = !VARIANTBOOL_TO_BOOL(vbMenuBar);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONMENUBAR, vbMenuBar);
    return S_OK;
}
HRESULT CWebBrowserOC::get_AddressBar(VARIANT_BOOL * pvbAddressBar)
{
    *pvbAddressBar = BOOL_TO_VARIANTBOOL(!_fNoAddressBar);
    return S_OK;
}
HRESULT CWebBrowserOC::put_AddressBar(VARIANT_BOOL vbAddressBar)
{
    _fNoAddressBar = !VARIANTBOOL_TO_BOOL(vbAddressBar);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONADDRESSBAR, vbAddressBar);
    return S_OK;
}

HRESULT CWebBrowserOC::put_Resizable(VARIANT_BOOL vbResizable)
{
    FireEvent_OnAdornment(_pautoEDS, DISPID_WINDOWSETRESIZABLE, vbResizable);
    return S_OK;
}

// IWebBrowser2 methods
//
WRAP_WB2_DESIGN(QueryStatusWB, (OLECMDID cmdID, OLECMDF * pcmdf), (cmdID, pcmdf))
WRAP_WB2_DESIGN(ShowBrowserBar, (VARIANT * pvaClsid, VARIANT * pvaShow, VARIANT * pvaSize), (pvaClsid, pvaShow, pvaSize))
WRAP_WB2(get_ReadyState, (READYSTATE * plReadyState), (plReadyState))
WRAP_WB2(get_RegisterAsDropTarget, (VARIANT_BOOL * pbRegister), (pbRegister))
WRAP_WB2(put_RegisterAsDropTarget, (VARIANT_BOOL bRegister), (bRegister))
WRAP_WB2(get_Offline, (VARIANT_BOOL * pbOffline), (pbOffline))
WRAP_WB2(put_Offline, (VARIANT_BOOL bOffline), (bOffline))
WRAP_WB2(get_Silent, (VARIANT_BOOL * pbSilent), (pbSilent))
WRAP_WB2(put_Silent, (VARIANT_BOOL bSilent), (bSilent))


HRESULT
CWebBrowserOC::Navigate2(VARIANT * URL,
                         VARIANT * Flags,
                         VARIANT * TargetFrameName,
                         VARIANT * PostData,
                         VARIANT * Headers)
{
    HRESULT hr = S_OK;

    if (_dwSafetyOptions && ((WORD)VT_BSTR == URL->vt) && URL->bstrVal)
    {
        hr = WrapSpecialUrl(&URL->bstrVal);
        if (SUCCEEDED(hr))
        {
            if (!AccessAllowedToNamedFrame(TargetFrameName))
                hr = E_ACCESSDENIED;
            else
                hr = _pautoWB2->Navigate2(URL, Flags, TargetFrameName, PostData, Headers);
        }
    }
    else
        hr = _pautoWB2->Navigate2(URL, Flags, TargetFrameName, PostData, Headers);

    return hr;
}

HRESULT  CWebBrowserOC::ExecWB(OLECMDID cmdID,  OLECMDEXECOPT cmdexecopt, 
                      VARIANT * pvaIn, VARIANT * pvaOut)
{ 
    HRESULT hr = E_FAIL;

    if ( !_IsDesignMode() )
    {

        // do not process print preview commands given from script for security reasons
        // Ferhane IE60 Bug#16693
        // Print templates have extra privelages.
        // Print/Preview allows you to specify a custom print template URL as a BSTR or in a safearray.
        // This is a security hole if available from script.  Disallow it.
        if (    _fInsideInvokeCall
            && (    cmdID == OLECMDID_PRINTPREVIEW
                ||  cmdID == OLECMDID_PRINT)
            &&  pvaIn
            &&  (   V_VT(pvaIn) == VT_BSTR
                ||  V_VT(pvaIn) == VT_ARRAY)
            )
        {
            return E_ACCESSDENIED;      // More meaningful than E_FAIL
        }

        // if _dwSafetyOptions are set then we are suppossed to be 
        // running in secure mode. This means the UI-less printing should NOT
        // be honored.  This is a security issue, see ie bug 23620.
        // otherwise just let the call go through
        if ((cmdID == OLECMDID_PRINT) && _dwSafetyOptions)
        {
            // so if the UI-less- request flag is set we need to unset it.
            if (cmdexecopt == OLECMDEXECOPT_DONTPROMPTUSER)
                cmdexecopt = OLECMDEXECOPT_DODEFAULT;
        }

        // If the optional argument pvargin is not specified make it VT_EMPTY.
        if (pvaIn && (V_VT(pvaIn) == VT_ERROR) && (V_ERROR(pvaIn) == DISP_E_PARAMNOTFOUND))
        {
            V_VT(pvaIn) = VT_EMPTY;
            V_I4(pvaIn) = 0;
        }

        // If the optional argument pvargin is not specified make it VT_EMPTY.
        if (pvaOut && (V_VT(pvaOut) == VT_ERROR) && (V_ERROR(pvaOut) == DISP_E_PARAMNOTFOUND))
        {
            V_VT(pvaOut) = VT_EMPTY;
            V_I4(pvaOut) = 0;
        }

        if (    cmdID == OLECMDID_PASTE
            ||  cmdID == OLECMDID_COPY
            ||  cmdID == OLECMDID_CUT)
        {
            BSTR bstrUrl;

            if (_dwSafetyOptions)
                return S_OK;

            if (SUCCEEDED(get_LocationURL(&bstrUrl)))
            {
                DWORD dwPolicy = 0;
                DWORD dwContext = 0;

                ZoneCheckUrlEx(bstrUrl, &dwPolicy, SIZEOF(dwPolicy), &dwContext, SIZEOF(dwContext),
                               URLACTION_SCRIPT_PASTE, 0, NULL);

                SysFreeString(bstrUrl);

                if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                    return S_OK;
            }
        }

        // now pass along the call
        hr = _pautoWB2->ExecWB(cmdID, cmdexecopt, pvaIn, pvaOut); 
    }

    return hr;
}

HRESULT CWebBrowserOC::get_RegisterAsBrowser(VARIANT_BOOL * pbRegister)
{
    *pbRegister = BOOL_TO_VARIANTBOOL(_fShouldRegisterAsBrowser);
    return S_OK;
}

HRESULT CWebBrowserOC::put_RegisterAsBrowser(VARIANT_BOOL bRegister)
{
    _fShouldRegisterAsBrowser = VARIANTBOOL_TO_BOOL(bRegister);

    if (bRegister)
        _RegisterWindow();
    else
        _UnregisterWindow();

    return S_OK;
}

HRESULT CWebBrowserOC::get_TheaterMode(VARIANT_BOOL * pvbTheaterMode)
{
    *pvbTheaterMode = BOOL_TO_VARIANTBOOL(_fTheaterMode);
    return S_OK;
}
HRESULT CWebBrowserOC::put_TheaterMode(VARIANT_BOOL Value)
{
    _fTheaterMode = VARIANTBOOL_TO_BOOL(Value);
    FireEvent_OnAdornment(_pautoEDS, DISPID_ONTHEATERMODE, Value);
    return S_OK;
}

// IExpDispSupport
//
HRESULT CWebBrowserOC::OnTranslateAccelerator(MSG *pMsg,DWORD grfModifiers)
{
    return IUnknown_TranslateAcceleratorOCS(_pcli, pMsg, grfModifiers);
}

HRESULT CWebBrowserOC::OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,
    VARIANT * pVarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    // We get first crack at this
    HRESULT hres = _pautoEDS->OnInvoke(dispidMember, iid, lcid, wFlags, pdispparams, pVarResult,pexcepinfo,puArgErr);

    // let the container get second crack at ambient properties
    //
    if (FAILED(hres))
    {
        if (!_pDispAmbient)
        {
            if (_pcli)
                _pcli->QueryInterface(IID_PPV_ARG(IDispatch, &_pDispAmbient));
        }
        if (_pDispAmbient)
        {
            hres = _pDispAmbient->Invoke(dispidMember, iid, lcid, wFlags, pdispparams, pVarResult,pexcepinfo,puArgErr);
        }
    }
   
    return hres;    
}

// IExpDispSupportOC
//
HRESULT CWebBrowserOC::OnOnControlInfoChanged()
{
    HRESULT hres = E_NOTIMPL;

    if (_pcli)
    {
        IOleControlSite* pocs;
        if (SUCCEEDED(_pcli->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs))))
        {
            hres = pocs->OnControlInfoChanged();
            pocs->Release();
        }
    }

    return hres;
}
HRESULT CWebBrowserOC::GetDoVerbMSG(MSG *pMsg)
{
    if (_pmsgDoVerb)
    {
        *pMsg = *_pmsgDoVerb;
        return S_OK;
    }

    return E_FAIL;
}


HRESULT CWebBrowserOC::LoadHistory(IStream *pstm, IBindCtx *pbc)
{
    _InitDefault();

    ASSERT(_psb);

    HRESULT hr = E_FAIL;

    if (_psb)
    {
        hr = _psb->LoadHistory(pstm, pbc);
    
        _OnLoaded(FAILED(hr));

        TraceMsg(TF_TRAVELLOG, "WBOC::LoadHistory pstm = %x, pbc = %x, hr = %x", pstm, pbc, hr);
    }
    return hr;
}

HRESULT CWebBrowserOC::SaveHistory(IStream *pstm)
{
    ASSERT(_psb);
    
    TraceMsg(TF_TRAVELLOG, "WBOC::SaveHistory calling psb->SaveHistory");

    return _psb ? _psb->SaveHistory(pstm) : E_FAIL;
}

HRESULT CWebBrowserOC::SetPositionCookie(DWORD dw)
{
    ASSERT(_psb);

    TraceMsg(TF_TRAVELLOG, "WBOC::SetPositionCookie calling psb->GetPositionCookie");
    return _psb ? _psb->SetPositionCookie(dw) : E_FAIL;
}

HRESULT CWebBrowserOC::GetPositionCookie(DWORD *pdw)
{
    ASSERT(_psb);

    TraceMsg(TF_TRAVELLOG, "WBOC::GetPositionCookie calling psb->GetPositionCookie");
    return _psb ? _psb->GetPositionCookie(pdw) : E_FAIL;
}

HMODULE CWebBrowserOC::_GetBrowseUI()
{
    if (_hBrowseUI == HMODULE_NOTLOADED)
    {
        _hBrowseUI = LoadLibrary(TEXT("browseui.dll"));
    }

    return _hBrowseUI;
}

BOOL CWebBrowserOC::AccessAllowedToNamedFrame(VARIANT *varTargetFrameName)
{
    BOOL            fAllowed        = TRUE;
    HRESULT         hr              = S_OK;
    ITargetFrame2 * pTopTargetFrame = NULL;
    IUnknown      * punkTargetFrame = NULL;
    IWebBrowser2  * pIWB2Target     = NULL;
    BSTR            bstrTargetUrl   = NULL;
    BSTR            bstrSrcUrl      = NULL;

    if (varTargetFrameName && ((WORD)VT_BSTR == varTargetFrameName->vt) && varTargetFrameName->bstrVal)
    {
        IEFrameAuto * piefa = NULL;
        
        hr = _pauto->QueryInterface(IID_PPV_ARG(IEFrameAuto, &piefa));
        if (SUCCEEDED(hr))
        {

            hr = TargetQueryService((IShellBrowser *)piefa, IID_PPV_ARG(ITargetFrame2, &pTopTargetFrame));

            if (SUCCEEDED(hr))
            {
                hr = pTopTargetFrame->FindFrame(
                              varTargetFrameName->bstrVal,
                              FINDFRAME_JUSTTESTEXISTENCE,
                              &punkTargetFrame);
                if (SUCCEEDED(hr) && punkTargetFrame)
                {
                    // yes, we found a frame with that name.  QI for the automation
                    // interface on that frame.
                    hr = punkTargetFrame->QueryInterface(IID_PPV_ARG(IWebBrowser2, &pIWB2Target));

                    if (SUCCEEDED(hr))
                    {
                        hr = pIWB2Target->get_LocationURL(&bstrTargetUrl);

                        if (SUCCEEDED(hr))
                        {
                            hr = _pautoWB2->get_LocationURL(&bstrSrcUrl);
                            if (SUCCEEDED(hr))
                            {
                                fAllowed = AccessAllowed(bstrSrcUrl, bstrTargetUrl);
                                SysFreeString(bstrSrcUrl);
                            }
                            SysFreeString(bstrTargetUrl);
                        }
                        pIWB2Target->Release();
                    }
                    punkTargetFrame->Release();
                }
                pTopTargetFrame->Release();
            }
            piefa->Release();
        }
    }
    return fAllowed;
}


// The SECURELOCK enumeration must be sorted in order of security level, and we may
// need to insert new values into the middle of the list in future.  So we'll map
// the values to a set of constants.

BOOL SecureLockToIconConstant(int nSecureLock, LONG *plIconConstant)
{
    BOOL fRet = TRUE;

    switch (nSecureLock)
    {
    case SECURELOCK_SET_UNSECURE         : *plIconConstant = secureLockIconUnsecure;          break;
    case SECURELOCK_SET_MIXED            : *plIconConstant = secureLockIconMixed;             break;
    case SECURELOCK_SET_SECUREUNKNOWNBIT : *plIconConstant = secureLockIconSecureUnknownBits; break;
    case SECURELOCK_SET_SECURE40BIT      : *plIconConstant = secureLockIconSecure40Bit;       break;
    case SECURELOCK_SET_SECURE56BIT      : *plIconConstant = secureLockIconSecure56Bit;       break;
    case SECURELOCK_SET_SECURE128BIT     : *plIconConstant = secureLockIconSecure128Bit;      break;
    case SECURELOCK_SET_FORTEZZA         : *plIconConstant = secureLockIconSecureFortezza;    break;
    default:
        // Don't need to fire an event
        fRet = FALSE;
    }

    return fRet;
}

void CWebBrowserOC::_OnSetSecureLockIcon(int lock)  
{
    LONG lIconConstant;

    if (SecureLockToIconConstant(lock, &lIconConstant))
    {
        // Fire the OnUpdateSecurityIcon event only from the DWebBrowserEvents2 connection point

        VARIANTARG args[1];
        IUnknown_CPContainerInvokeParam(_pautoEDS, DIID_DWebBrowserEvents2,
            DISPID_SETSECURELOCKICON, args, 1, VT_I4, lIconConstant);
    }
}

// CWebBrowserSB implementation

CWebBrowserSB::CWebBrowserSB(IUnknown* pauto, CWebBrowserOC* psvo)
        : CBASEBROWSER(NULL)
        , _psvo(psvo)
{
    _Initialize(0, pauto);
}

CWebBrowserSB::~CWebBrowserSB()
{
}

HRESULT CWebBrowserSB::QueryInterface(REFIID riid, void ** ppvObj)
{
    HRESULT hr = CBASEBROWSER::QueryInterface(riid, ppvObj);

    if (FAILED(hr) && (riid == IID_IIsWebBrowserSB))
        hr = CBASEBROWSER::QueryInterface(IID_IUnknown, ppvObj);

    return hr;
}

BOOL VirtualTopLevelBrowser(IOleClientSite * pcls)
{
    IOleContainer * poc;
    BOOL fNonStandard = FALSE;

    if (SUCCEEDED(pcls->GetContainer(&poc)))
    {
        ITargetContainer * ptc;

        // Is our container hosting us?
        if (SUCCEEDED(poc->QueryInterface(IID_PPV_ARG(ITargetContainer, &ptc))))
        {
            fNonStandard = TRUE;
            ptc->Release();
        }
        poc->Release();
    }

    return fNonStandard;
}

HRESULT CWebBrowserSB::SetTopBrowser()
{
    HRESULT hres = CBASEBROWSER::SetTopBrowser();

    if (_fTopBrowser && EVAL(_psvo))
        _fNoTopLevelBrowser = VirtualTopLevelBrowser(_psvo->_pcli);

    return hres;
}


LRESULT CWebBrowserSB::WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lret = CBASEBROWSER::WndProcBS(hwnd, uMsg, wParam, lParam);

    switch(uMsg)
    {
    case WM_DESTROY:
        //  Because we won't get WM_NCDESTROY here, we should clean up
        // this member variable here. 
        _bbd._hwnd = NULL;
        break;
    }

    return lret;
}

// *** IOleWindow methods ***

// CBASEBROWSER maps SetStatusTextSB to SendControlMsg,
// so we don't need a CWebBrowserSB::SetStatusTextSB implementation.

HRESULT CWebBrowserSB::_EnableModeless(BOOL fEnable, BOOL fDirection)
{
    HRESULT hres = S_OK;

    CBASEBROWSER::EnableModelessSB(fEnable);

    if (fDirection == DIRECTION_FORWARD_TO_PARENT)
    {
        if (_psvo && _psvo->_pipframe)
        {
            hres = _psvo->_pipframe->EnableModeless(fEnable);
            if (!fEnable && _psvo->_fHostedInVB5)
            {
                // APPHACK: VB5 -- If we haven't put up a dialog between the EnableModelessSB(FALSE) call and this
                // call, we'll end up with a message on the queue that will disable all windows.
                // Let's peek for this message and dispatch it if it is VB5's.
                //
                #define VBM_POSTENABLEMODELESS  0x1006
                #define VBM_MAINCLASS1          TEXT("ThunderRT5Main")
                #define VBM_MAINCLASS2          TEXT("ThunderRT6Main")
                #define VBM_MAINCLASS3          TEXT("ThunderMain")

                MSG   msg;
                HWND  hwnd = NULL;
                TCHAR strBuf[15];

                if (PeekMessage( &msg, NULL, VBM_POSTENABLEMODELESS, VBM_POSTENABLEMODELESS, PM_NOREMOVE))
                {
                    /* On Win95, apparently PeekMessage can return one type of message
                     * outside the range specified: WM_QUIT.  Double-check the message we 
                     * got back.
                     */
                    if (msg.message == VBM_POSTENABLEMODELESS)
                    {
                        GetClassName(msg.hwnd, strBuf, sizeof(strBuf));
                        if (StrCmp(strBuf, VBM_MAINCLASS1) == 0 ||
                            StrCmp(strBuf, VBM_MAINCLASS2) == 0 ||
                            StrCmp(strBuf, VBM_MAINCLASS3) == 0)
                        {
                            PeekMessage( &msg, msg.hwnd, VBM_POSTENABLEMODELESS, VBM_POSTENABLEMODELESS, PM_REMOVE);
                            TraceMsg(TF_SHDCONTROL, "shv CWebBrowserSB::_EnableModeless dispatching VBM_POSTENABLEMODELESS" );
                            DispatchMessage(&msg);
                        }
                    }
                }
            }
            else
            {
                // If we're a subframe 
                //   AND the EnableModeless(FALSE) count (_cRefCannotNavigate) has become zero
                //   AND our window is disabled
                // THEN the likely scenario is that VB5 failed to reenable us.  Trace it and reenable
                //   ourselves.
                //
                if (!_fTopBrowser 
                    && _cRefCannotNavigate == 0 
                    && GetWindowLong(_bbd._hwnd, GWL_STYLE) & WS_DISABLED)
                {
                    TraceMsg(TF_WARNING, "shv Subframe was left disabled.  Reenabling ourselves.");
                    EnableWindow(_bbd._hwnd, TRUE);
                }
            }
        }
        else if (_psvo && _psvo->_pcli) 
        {
            IShellBrowser* psbParent;
            if (SUCCEEDED(IUnknown_QueryService(_psvo->_pcli, SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psbParent)))) 
            {
                psbParent->EnableModelessSB(fEnable);
                psbParent->Release();
            }
        } 
        else 
        {
            IOIPAMSG(TEXT("_EnableModeless NOT forwarding on to _pipframe"));
        }
    }
    else // DIRECTION_FORWARD_TO_CHILD
    {
        ASSERT(fDirection == DIRECTION_FORWARD_TO_CHILD);
        if (_bbd._psv)
        {
            hres = _bbd._psv->EnableModelessSV(fEnable);
        }
        else
        {
            IOIPAMSG(TEXT("_EnableModeless NOT forwarding on to _psv"));
        }
    }

    return hres;
}

HRESULT CWebBrowserSB::EnableModelessSB(BOOL fEnable)
{
    return _EnableModeless(fEnable, DIRECTION_FORWARD_TO_PARENT);
}

HRESULT CWebBrowserSB::_TranslateAccelerator(LPMSG lpmsg, WORD wID, BOOL fDirection)
{
    // see if we handle it
    HRESULT hr = CBASEBROWSER::TranslateAcceleratorSB(lpmsg, wID);
    if (hr == S_OK)
    {
        IOIPAMSG(TEXT("_TranslateAccelerator: CBASEBROWSER's TranslateAcceleratorSB handled it"));
    }
    else if (fDirection == DIRECTION_FORWARD_TO_PARENT)
    {
        if (_psvo && _psvo->_pipframe)
        {
            hr = _psvo->_pipframe->TranslateAccelerator(lpmsg, wID);
        }
        else
        {
            IOIPAMSG(TEXT("_TranslateAccelerator NOT forwarding on to _pipframe"));
            hr = S_FALSE;
        }
    }
    else // fDirection == DIRECTION_FORWARD_TO_CHILD
    {
        if (_bbd._psv)
        {
            hr = _bbd._psv->TranslateAccelerator(lpmsg);
        }
        else
        {
            IOIPAMSG(TEXT("_TranslateAccelerator NOT forwarding on to _psv"));
            hr = S_FALSE;
        }
    }

    return hr;
}

HRESULT CWebBrowserSB::TranslateAcceleratorSB(LPMSG lpmsg, WORD wID)
{
    return _TranslateAccelerator(lpmsg, wID, DIRECTION_FORWARD_TO_PARENT);
}

HRESULT CWebBrowserSB::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
            LPARAM lParam, LRESULT * pret)
{
    // let CBASEBROWSER try first so we get automation notifications working
    HRESULT hres = CBASEBROWSER::SendControlMsg(id, uMsg, wParam, lParam, pret);

    // if we're in a blocking frame, our GetControlWindow above will fail
    // causing CBASEBROWSER to fail. try to map to an IOleInPlaceFrame call.
    if (FAILED(hres) && _psvo)
    {
        // forward status bar text changes to the frame.
        if ((id == FCW_STATUS) &&
            (uMsg == SB_SETTEXT || uMsg == SB_SETTEXTW) && // trying to set status text
            (!(wParam & SBT_OWNERDRAW)) &&  // we don't own the window -- this can't work
            (((wParam & 0x00FF) == 0x00FF) || ((wParam & 0x00FF)== 0))) // simple or 0th item
        {
            WCHAR szStatusText[256];

            if (uMsg == SB_SETTEXT) {
                if (lParam)
                {
                    SHTCharToUnicode((LPTSTR)lParam, szStatusText, ARRAYSIZE(szStatusText));
                }
                else
                {
                    szStatusText[0] = L'\0';
                }

                lParam = (LPARAM) szStatusText;
            }
            else if (!lParam)
            {
                // uMsg == SB_SETTEXTW
                // Found a container that doesn't like null string pointers.  Pass an empty string instead.
                // (IE v 4.1 bug 64629)
                szStatusText[0] = 0;
                lParam = (LPARAM) szStatusText;
            }

            if (_psvo->_pipframe)
            {
                if (pret)
                {
                    *pret = 0;
                }
                hres = _psvo->_pipframe->SetStatusText((LPCOLESTR)lParam);
            }
            else
            {
                IOIPAMSG(TEXT("SetStatusTextSB NOT forwarding on to _pipframe"));
            }
        }
    }

    return hres;
}


HRESULT CWebBrowserSB::OnViewWindowActive(struct IShellView * psv)
{
    if (_psvo)
    {
        // The view is notifying us that it just went UIActive,
        // we need to update our state. OC_UIACTIVE normally
        // tells the view to UIActivate itself, but in this case
        // it already is. Avoid an infinite loop and pass FALSE.
        _psvo->_DoActivateChange(NULL, OC_UIACTIVE, FALSE);
    }

    return CBASEBROWSER::OnViewWindowActive(psv);
}


LRESULT CWebBrowserSB::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // explicitly do nothing...
    // this is just to override CBASEBROWSER's _DefWindowProc.
    return 0;
}

void CWebBrowserSB::_ViewChange(DWORD dwAspect, LONG lindex)
{
    //
    // forward this notify up to the OC's OBJECTCODE_VIEWCHANGE handler so it
    // gets forwarded on to our container.
    //
    if (_psvo)
        _psvo->_ViewChange(dwAspect, lindex);

    //
    // also let the base browser handle this view change in case nobody else is
    // handling palette messages.  most of the time this will be a nop but in
    // the case where a WM_QUERYNEWPALETTE makes it down to us this will allow
    // us to manage the palette properly.
    //
    CBASEBROWSER::_ViewChange(dwAspect, lindex);
}

HRESULT CWebBrowserSB::ActivatePendingView()
{
    CVOCBMSG(TEXT("_ActivatePendingView"));

    // CBASEBROWSER::_ActivatePendingView will send a NavigateComplete
    // event. During this event our parent may destroy us. We then fault
    // dereferencing _psvo below. So we need to wrap this function with
    // an AddRef/Release.  (bug 15424)
    //
    AddRef();

    HRESULT hres = CBASEBROWSER::ActivatePendingView();

    if (SUCCEEDED(hres) && _psvo)
        _psvo->_OnSetShellView(_bbd._psv);

    Release();

    return hres;
}

HRESULT CWebBrowserSB::ReleaseShellView(void)
{
    CVOCBMSG(TEXT("_ReleaseShellView"));

    if (_psvo)
        _psvo->_OnReleaseShellView();

    return CBASEBROWSER::ReleaseShellView();
}


/// IBrowserService stuff
HRESULT CWebBrowserSB::GetParentSite(struct IOleInPlaceSite** ppipsite)
{
    HRESULT hres = E_FAIL;  // assume error
    *ppipsite = NULL;        // assume error

    if (_psvo)
    {
        if (_psvo->_pipsite) 
        {
            *ppipsite = _psvo->_pipsite;
            _psvo->_pipsite->AddRef();
            hres = S_OK;
        } 
        else if (_psvo->_pcli) 
        {
            hres = _psvo->_pcli->QueryInterface(IID_PPV_ARG(IOleInPlaceSite, ppipsite));
        }
        else 
        {
            // Is it expected?
            TraceMsg(DM_WARNING, "CWBSB::GetParentSite called when _pcli is NULL");
        }
    }

    return hres;
}

#ifdef FEATURE_FRAMES
HRESULT CWebBrowserSB::GetOleObject(struct IOleObject** ppobjv)
{
    if (_psvo == NULL)
    {
        *ppobjv = NULL;
        return E_FAIL;
    }
    return _psvo->QueryInterface(IID_PPV_ARG(IOleObject, ppobjv));
}
#endif

HRESULT CWebBrowserSB::SetNavigateState(BNSTATE bnstate)
{
    // Do our own things (such as firing events and update _fNavigate).
    HRESULT hres = CBASEBROWSER::SetNavigateState(bnstate);

    //
    // Then, tell the container to update the download state.
    // This will start the animation if this OC is either in a frameset
    // or in a browser band.
    //
    VARIANTARG var;
    var.vt = VT_I4;
    var.lVal = _fNavigate;
    Exec(NULL, OLECMDID_SETDOWNLOADSTATE, 0, &var, NULL);

    return hres;
}


LRESULT CWebBrowserSB::OnNotify(LPNMHDR pnm)
{
    switch(pnm->code) 
    {
    case SEN_DDEEXECUTE:
    {
        IShellBrowser *psbTop;
        if (pnm->idFrom == 0 && SUCCEEDED(_QueryServiceParent(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psbTop)))) 
        {   
            HWND hwndTop;
            
            psbTop->GetWindow(&hwndTop);
            psbTop->Release();
            if (psbTop != this)
                return SendMessage(hwndTop, WM_NOTIFY, 0, (LPARAM)pnm);
        }
        break;
    }

    default:
        return CBASEBROWSER::OnNotify(pnm);
    }

    return S_OK;
}

// IServiceProvider stuff
//

HRESULT CWebBrowserSB::_QueryServiceParent(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;

    *ppvObj = NULL;

    // Pass it on to our parent
    if (_psvo && _psvo->_pcli)
    {
        hres = IUnknown_QueryService(_psvo->_pcli, guidService, riid, ppvObj);
    }
    else
    {
        CVOCBMSG(TEXT("QueryService doesn't have _pipsite!"));
    }

    return hres;
}

// NOTES:
//  If SID_STopLevelBrowser, go to parent (upto the top level browser)
//  If SID_SWebBrowserApp, go to parent (up to the top level browser automation)
//  If SID_SContainerDispatch, expose CWebBrowserOC (instead of _pauto)
//  Then, try CBASEBROWSER::QueryService, which will handle SID_SHlinkFrame,
//  SID_SUrlHistory, SID_SShellBrowser, etc.
//  If all fails and not SID_SShellBrowser, then we go up the parent chain.
//
HRESULT CWebBrowserSB::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;  // service object not found

    *ppvObj = NULL; // assume error

    // if the guidService is SID_QIClientSite then delegate the iid to the 
    // container through a queryinterface call.
    if (_psvo && _psvo->_pcli && IsEqualGUID( guidService, SID_QIClientSite))
    {
        return _psvo->_pcli->QueryInterface( riid, ppvObj);
    }

    // If guidService is SID_STopLevelBrowser, we should not ask the super
    // class to handle. Instead, we ask the parent to handle (if any).
    if (IsEqualGUID(guidService, SID_STopLevelBrowser) || 
        IsEqualGUID(guidService, SID_STopWindow)) 
    {
        // APPCOMPAT: WebBrowser is not supposed to respond to QS(SID_SInetExp) because
        //  it does not support IWebBrowserApp. However, rejecting this causes
        //  a stack fault when opening a frame-set. We need to find out what is causing
        //  this stack fault but I'll backup this delta for now to stop GPF.
        //
        //   || IsEqualGUID(guidService, SID_SWebBrowserApp)
        goto AskParent;
    }

    if (IsEqualGUID(guidService, SID_STopFrameBrowser)) 
    {
        BOOL fAskParent = TRUE;

        // Don't ask the parent if we are a desktop component and we are
        // not doing drag/drop.  Treat it as a top level frame.  For all other
        // cases, ask the parent.
        if (!IsEqualIID(riid, IID_IDropTarget) && _ptfrm)
        {
            IUnknown *pUnkParent;
            if (SUCCEEDED(_ptfrm->GetParentFrame(&pUnkParent)))
            {
                if (pUnkParent) 
                {
                    // Has a parent, not a desktop component
                    pUnkParent->Release();
                } 
                else 
                {
                    // Doesn't have a parent, must be a desktop component so
                    // fall through to call our CBASEBROWSER::QueryService
                    fAskParent = FALSE;
                }
            }
        }

        if (fAskParent)
            goto AskParent;
    }

    // If the containee is asking for SID_SContainerDispatch (parent),
    // we should return the automation interface of the buddy CWebBrowserOC.
    if (IsEqualGUID(guidService, SID_SContainerDispatch)) 
    {
        if (_psvo) 
        {
            return _psvo->QueryInterface(riid, ppvObj);
        }
        return E_UNEXPECTED;
    }

    // If the guidService is SID_SVersionHost,
    // give the host a crack at it first
    //
    if (IsEqualGUID(guidService, SID_SVersionHost))
    {
        hr = _QueryServiceParent(guidService, riid, ppvObj);
        
        // Return if the host handled the service,
        //
        if (S_OK == hr)
            return hr;
    }

    hr = CBASEBROWSER::QueryService(guidService, riid, ppvObj);

    // Notes: If guidService is SID_SShellBrowser, it indicates that
    //  the caller wants to talk to the immediate IShellBrowser.
    //  We should not try our parent in that case. Doing it so will
    //  break nested browser (frame set). In addition, notice that
    //  we don't want to go up the parent chain if hr is E_NOINTERFACE
    //  (which indicates unsuccessfull QueryInterface).
    //
    //  We don't want a shell view in a frame-set add buttons on the
    // toolbar. We should skip AskParent if guidService is SID_SExplroerToolbar. 

    if (FAILED(hr) && hr != E_NOINTERFACE
        && !IsEqualIID(guidService, SID_SShellBrowser)
        && !IsEqualIID(guidService, SID_SExplorerToolbar))
    {
AskParent:
        hr = _QueryServiceParent(guidService, riid, ppvObj);

        // hey, we're the top-level browser if there ain't no top-level browser
        // above us. (Such as our OC embedded in AOL/CIS/VB.) We must do this
        // or we don't get a _tlGlobal on the top frame, so navigation history
        // is screwy and the back/forward buttons are incorrect.
        if (FAILED(hr) && 
            (IsEqualGUID(guidService, SID_STopLevelBrowser) ||
             IsEqualGUID(guidService, SID_STopFrameBrowser) ||
             IsEqualGUID(guidService, SID_STopWindow)))
        {
            hr = CBASEBROWSER::QueryService(guidService, riid, ppvObj);
        }
    }
    return hr;
}


// IOleCommandTarget
//
// We simply forward to the container above our parent OC

HRESULT CWebBrowserSB::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;
    HRESULT hresLocal;

    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CGID_ShellDocView))
    {
        hres = S_OK;
        for (ULONG i=0 ; i < cCmds ; i++)
        {
            if (rgCmds[i].cmdID == SHDVID_CANGOBACK ||
                rgCmds[i].cmdID == SHDVID_CANGOFORWARD)
            {
                hresLocal = CBASEBROWSER::QueryStatus(pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
            }
            else if (_psvo && _psvo->_pctContainer)
            {
                hresLocal = _psvo->_pctContainer->QueryStatus(pguidCmdGroup, 1, &rgCmds[i], pcmdtext);

                if (hresLocal == OLECMDERR_E_UNKNOWNGROUP || hresLocal == OLECMDERR_E_NOTSUPPORTED)
                {
                    hresLocal = CBASEBROWSER::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
                }
            }
            else
                hresLocal = OLECMDERR_E_NOTSUPPORTED;
            if (hresLocal != S_OK) hres = hresLocal;
        }
    } 
    else    
    {
        if (_psvo && _psvo->_pctContainer)
            hres = _psvo->_pctContainer->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);

        // if container does not support the command try base browser
        // before we only used to return an error
        if (hres == OLECMDERR_E_UNKNOWNGROUP || hres == OLECMDERR_E_NOTSUPPORTED)
        {
            hres = CBASEBROWSER::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
        }
    }

    return hres;
}


struct WBCMDLIST {
    const GUID* pguidCmdGroup;
    DWORD       nCmdID;
};

//
//  SBCMDID_CANCELNAVIGATION:                                           
//   Don't pass SBCMDID_CANCELNAVIGATION up to ROOT browser.  Canceling 
//  here doesn't need to be forwarded and will cause navigations of to  
//  initiated by javascript: navigations in this frame to be aborted.   
//                                                                      
//  SHDVID_ACTIVATEMENOW:                                               
//   The DocHost's request to activate the pending view must be handled 
//  by THIS browser, not the parent's -- if we're in a frameset page,   
//  we've probably already activated the top-level browser, now we may  
//  be trying to activate an individual frame.                          
//
const WBCMDLIST c_acmdWBSB[] = {
        { NULL, OLECMDID_HTTPEQUIV },
        { NULL, OLECMDID_HTTPEQUIV_DONE },
        { &CGID_ShellDocView, SHDVID_GETPENDINGOBJECT },
        { &CGID_ShellDocView, SHDVID_ACTIVATEMENOW },   
        { &CGID_ShellDocView, SHDVID_DOCFAMILYCHARSET },
        { &CGID_Explorer, SBCMDID_CANCELNAVIGATION },
        { &CGID_Explorer, SBCMDID_CREATESHORTCUT },     
        { &CGID_ShellDocView, SHDVID_CHECKINCACHEIFOFFLINE },
        { &CGID_ShellDocView, SHDVID_SETPRINTSTATUS },
        { &CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD },
        { &CGID_DocHostCmdPriv, DOCHOST_DOCCANNAVIGATE },
        { &CGID_InternetExplorer, IECMDID_BEFORENAVIGATE_GETSHELLBROWSE },
        { &CGID_InternetExplorer, IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE },
        { &CGID_InternetExplorer, IECMDID_BEFORENAVIGATE_GETIDLIST },
        { &CGID_DocHostCmdPriv, DOCHOST_SETBROWSERINDEX },
};

HRESULT CWebBrowserSB::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    //
    //  First, test if the spcified command is supposed to processed by
    // this browser or not. If that's the case, just call CBASEBROWSER::Exec
    // and return.
    //
    for (int i=0; i<ARRAYSIZE(c_acmdWBSB); i++) 
    {
        if (nCmdID == c_acmdWBSB[i].nCmdID) 
        {
            if (pguidCmdGroup==NULL || c_acmdWBSB[i].pguidCmdGroup==NULL) 
            {
                if (pguidCmdGroup==c_acmdWBSB[i].pguidCmdGroup) 
                {
                    return CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                }
            } 
            else if (IsEqualGUID(*pguidCmdGroup, *c_acmdWBSB[i].pguidCmdGroup)) 
            {
                return CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
        }
    }

    // In some cases, we need perform some additional operations
    // before passing it to the parent. 
    //
    if (pguidCmdGroup == NULL)
    {                
        switch(nCmdID) {
        case OLECMDID_SETDOWNLOADSTATE:
            if (pvarargIn) 
            {
                _setDescendentNavigate(pvarargIn);
            }
            break;
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CGID_ShellDocView))
    {
        switch (nCmdID) 
        {
        /* The DocHost's request to activate the pending view must be handled
         * by THIS browser, not the parent's -- then we forward up the chain
         * so that all potentially blocked frames can attempt to deactivate
         */
        case SHDVID_DEACTIVATEMENOW:
            if (_cbScriptNesting  > 0)
                _cbScriptNesting--;
            hres = CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            if (FAILED(hres) || _cbScriptNesting > 0)
                return hres;
            break;

        case SHDVID_NODEACTIVATENOW:
            _cbScriptNesting++;
            if (_cbScriptNesting > 1)
                return S_OK;
            break;

        case SHDVID_DELEGATEWINDOWOM:
            if (_psvo && _psvo->_pauto)
            {
                // Forward this command to the CIEFrameAuto instance for this webOC.
                return IUnknown_Exec(_psvo->_pauto, &CGID_ShellDocView, nCmdID, 0, pvarargIn, NULL);
            }
            break;

        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CGID_Explorer))
    {
        //  this needs to be handled by the specific browser that 
        //  received the exec.
        switch (nCmdID)
        {
        case SBCMDID_UPDATETRAVELLOG:
        case SBCMDID_REPLACELOCATION:
            return CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

        case SBCMDID_SETSECURELOCKICON:
            {
                CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
               
                // Let the WebBrowserOC fire the event
                if (_psvo)
                {
                    _psvo->_OnSetSecureLockIcon(_bbd._eSecureLockIcon);   
                }
            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_ExplorerBarDoc, *pguidCmdGroup)) 
    {
        // These are ignored so that Explorer bar changes are done once - and only in response to
        // global changes applied to top Document if frameset of browser.
        //    NOT for changes applied to frames
        //    NOT for changes applied to browserbands
        return S_OK;
    }

    //
    // Forward this EXEC to the container (if we have). 
    //
    if (_psvo && _psvo->_pctContainer)
        hres = _psvo->_pctContainer->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    //
    // if the above exec failed, we're probably in some random container
    // so let CBASEBROWSER try to simulate a top-level frame.
    // might as well be a bit paranoid and make sure it failed with "i dunno"
    //
    if (hres == OLECMDERR_E_UNKNOWNGROUP || hres == OLECMDERR_E_NOTSUPPORTED) 
    {
        if (pguidCmdGroup==NULL && nCmdID==OLECMDID_SETDOWNLOADSTATE && _psvo) 
        {
            TraceMsg(DM_FORSEARCHBAND, "WBSB::QueryStatus Container does not support OLECMDID_SETDOWNLOADSTATE");
            hres = _psvo->_SetDownloadState(hres, nCmdexecopt, pvarargIn);
        }

        if (hres != S_OK) 
        {
            hres = CBASEBROWSER::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    return hres;
}


HRESULT CWebBrowserSB::_SwitchActivationNow()
{
    CBASEBROWSER::_SwitchActivationNow();

    if (_bbd._psv && 
        _psvo && 
        _psvo->_nActivate < OC_INPLACEACTIVE && 
        _psvo->_dwDrawAspect)
    {
        // pass on the SetExtent to the now ready browser...
        IPrivateOleObject * pPrivOle;
        if (SUCCEEDED(_bbd._psv->QueryInterface(IID_PPV_ARG(IPrivateOleObject, &pPrivOle))))
        {
            // we have an ole object, delegate downwards...
            pPrivOle->SetExtent( _psvo->_dwDrawAspect, &_psvo->_sizeHIM );
            pPrivOle->Release();
        }
    }
    return S_OK;
}

BOOL CWebBrowserSB::_HeyMoe_IsWiseGuy()
{
    BOOL fRet;

    if (_psvo)
    {
        fRet = _psvo->_HeyMoe_IsWiseGuy();
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

HRESULT CWebBrowserSB::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    // if client does not specify we will do so for them
    if (SBSP_DEFBROWSER == (wFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)))
    {
        IShellBrowser *psbDesktop;
        if (SUCCEEDED(QueryService(SID_SShellDesktop, IID_PPV_ARG(IShellBrowser, &psbDesktop))))
        {
            HRESULT hr = psbDesktop->BrowseObject(pidl, wFlags);
            psbDesktop->Release();
            return hr;
        }
        wFlags |= SBSP_SAMEBROWSER; // always navigate in place
    }

    return CBASEBROWSER::BrowseObject(pidl, wFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information


#include "priv.h"

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_)
#define AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif


//#define _WIN32_WINNT 0x0400       // (scotth): Use what is defined in priv.h
#define _ATL_APARTMENT_THREADED

#define _ATL_NO_DEBUG_CRT           // use the shell debug facilities
#define _ATL_NO_UUIDOF

extern "C"
inline HRESULT __stdcall OleCreatePropertyFrame(
  HWND hwndOwner,    //Parent window of property sheet dialog box
  UINT x,            //Horizontal position for dialog box
  UINT y,            //Vertical position for dialog box
  LPCOLESTR lpszCaption,
                     //Pointer to the dialog box caption
  ULONG cObjects,    //Number of object pointers in lplpUnk
  LPUNKNOWN FAR* lplpUnk,
                     //Pointer to the objects for property sheet
  ULONG cPages,      //Number of property pages in lpPageClsID
  LPCLSID lpPageClsID,
                     //Array of CLSIDs for each property page
  LCID lcid,         //Locale identifier for property sheet locale
  DWORD dwReserved,  //Reserved
  LPVOID lpvReserved //Reserved
)
{
    return S_OK;
}
 
#include <debug.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\srchasst.h ===
#ifndef __SRCHASST_H_
#define __SRCHASST_H_

#include "caggunk.h"
#include "dspsprt.h"

class CSearch : public ISearch,
                protected CImpIDispatch
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch members
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    //ISearch methods
    STDMETHODIMP get_Title(BSTR *pbstrTitle);
    STDMETHODIMP get_Id(BSTR *pbstrId);
    STDMETHODIMP get_Url(BSTR *pbstrUrl);

private:
    CSearch(GUID *pguid, BSTR bstrTitle, BSTR bstrUrl);
    ~CSearch();
    
    LONG _cRef;
    BSTR _bstrTitle;
    BSTR _bstrUrl;
    TCHAR _szId[40];

    friend HRESULT CSearch_Create(GUID *pguid, BSTR bstrTitle, BSTR bstrUrl, ISearch **ppSearch);
};

class CSearchCollection : public ISearches,
                          protected CImpIDispatch
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch members
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    STDMETHODIMP get_Count(long *plCount);
    STDMETHODIMP get_Default(BSTR *pbstr);
    STDMETHODIMP Item(VARIANT index, ISearch **ppid);
    STDMETHODIMP _NewEnum(IUnknown **ppunk);

private:
    CSearchCollection(IFolderSearches *pfs);
    ~CSearchCollection();
    
    LONG  _cRef;
    TCHAR _szDefault[40];
    HDSA  _hdsaItems;

    friend HRESULT CSearchCollection_Create(IFolderSearches *pfs, ISearches **ppSearches);
};

//////////////////////////////////////////////////////////////////////////////
// CProxy_SearchAssistantEvents
template <class T>
class CProxy_SearchAssistantEvents : public IConnectionPointImpl<T, &
DIID__SearchAssistantEvents, CComDynamicUnkArray>
{
public:
//methods:
//_SearchAssistantEvents : IDispatch
public:
    void Fire_OnNextMenuSelect(int idItem)
    {
        VARIANTARG* pvars = new VARIANTARG[1];

        if (NULL != pvars)
        {
            for (int i = 0; i < 1; i++)
                VariantInit(&pvars[i]);
            T* pT = (T*)this;
            pT->Lock();
            IUnknown** pp = m_vec.begin();
            while (pp < m_vec.end())
            {
                if (*pp != NULL)
                {
                    pvars[0].vt = VT_I4;
                    pvars[0].lVal= idItem;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
                pp++;
            }
            pT->Unlock();
            delete[] pvars;
        }
    }

    void Fire_OnNewSearch()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
};


/////////////////////////////////////////////////////////////////////////////
// CSearchAssistantOC
class ATL_NO_VTABLE CSearchAssistantOC : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSearchAssistantOC, &CLSID_SearchAssistantOC>,
    public CComControl<CSearchAssistantOC>,
#ifndef UNIX
    public IDispatchImpl<ISearchAssistantOC3, &IID_ISearchAssistantOC3, &LIBID_SHDocVw>,
    public IProvideClassInfo2Impl<&CLSID_SearchAssistantOC, &DIID__SearchAssistantEvents, &LIBID_SHDocVw>,
#else
    public IDispatchImpl<ISearchAssistantOC3, &IID_ISearchAssistantOC3, &LIBID_SHDocVw, 1, 0, CComTypeInfoHolder>,
    public IProvideClassInfo2Impl<&CLSID_SearchAssistantOC, &DIID__SearchAssistantEvents, &LIBID_SHDocVw, 1, 0, CComTypeInfoHolder>,
#endif
    public IPersistStreamInitImpl<CSearchAssistantOC>,
    public IPersistStorageImpl<CSearchAssistantOC>,
    public IQuickActivateImpl<CSearchAssistantOC>,
    public 